## ##  ##   ##  ##  ###   ##  ## ##     ## ##   ####     ##   ##
     ###   ## ##  ##   ##  ##   ###  ##  ## ##     ## ##   ####     #######
      ### ####### ##   ##  ##    ### #####  ##    #######   ##      ##   ##
    #  ## ##   ## ##  ##   ##  #  ## ##     ##    ##   ##   ##   ## ##   ##
     ###  ##   ## #####   ####  ###  ##     ##### ##   ##   ##   ## ##   ##

Abstract:

    This header file contains the class definition for
    the ISaDisplay interface class.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    User mode only.

Notes:

--*/

#ifndef __SADISPLAY_H_
#define __SADISPLAY_H_

class ATL_NO_VTABLE CSaDisplay :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSaDisplay, &CLSID_SaDisplay>,
    public IDispatchImpl<ISaDisplay, &IID_ISaDisplay, &LIBID_SACOMLib>
{
public:
    CSaDisplay();
    ~CSaDisplay();

DECLARE_REGISTRY_RESOURCEID(IDR_SADISPLAY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSaDisplay)
    COM_INTERFACE_ENTRY(ISaDisplay)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    STDMETHOD(ClearDisplay)();
    STDMETHOD(ShowMessage)(long MsgCode, long Width, long Height, unsigned char *Bits);
    STDMETHOD(ShowMessageFromFile)(long MsgCode,BSTR BitmapFileName);
    STDMETHOD(StoreBitmap)(long MessageId,long Width,long Height,unsigned char *Bits);
    STDMETHOD(Lock)();
    STDMETHOD(UnLock)();
    STDMETHOD(ReloadRegistryBitmaps)();
    STDMETHOD(ShowRegistryBitmap)(long MessageId);

    STDMETHOD(get_InterfaceVersion)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_DisplayWidth)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_DisplayHeight)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CharacterSet)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_DisplayType)(/*[out, retval]*/ long *pVal);

private:

    void
    ConvertBottomLeft2TopLeft(
        PUCHAR Bits,
        ULONG Width,
        ULONG Height
        );

    int
    DisplayBitmap(
        long MsgCode,
        long Width,
        long Height,
        unsigned char *Bits
        );

    HANDLE                      m_hFile;
    SA_DISPLAY_CAPS             m_DisplayCaps;
    ULONG                       m_InterfaceVersion;
    PUCHAR                      m_CachedBitmap;
    ULONG                       m_CachedBitmapSize;
    SA_DISPLAY_SHOW_MESSAGE     m_SaDisplay;

};

#endif //__SADISPLAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sainstall\sainstall.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      SaInstall.cpp : Implementation of SaInstall
//
//  Description:
//      Implements the 3 methods in ISaInstall to provide 
//      installation and uninstallation of the SAK 2.0.
//      SASetup.msi is located and run from the system32 directory.
//
//  Documentation:
//      SaInstall2.2.doc
//
//  Header File:
//      SaInstall.h
//
//  History:
//      travisn   23-JUL-2001    Created
//      travisn    2-AUG-2001    Modified to better follow coding standards
//      travisn   22-AUG-2001    Added file tracing calls
//      travisn    5-OCT-2001    Added UsersAndGroups to Blade
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <initguid.h>
#include <assert.h>

#include "sainstallcom.h"
#include "SaInstall.h"
#include "MetabaseObject.h"
#include "helper.h"
#include "satrace.h"

/////////////////////////////////////////////////////////////////////////////
// Define constants
/////////////////////////////////////////////////////////////////////////////

//
// Command line options for a silent install, prepended to other options
//
const LPCWSTR MSIEXEC_INSTALL = L"msiexec.exe /qb /i ";

//
// Command line options for a silent install without a progress dialog
//
const LPCWSTR MSIEXEC_NO_PROGRESS_INSTALL = L"msiexec.exe /qn /i ";

//
// Install 16 components for WEB
// What WEB has that NAS doesn't: WebBlade
//
const LPCWSTR WEB_INSTALL_OPTIONS =
L" ADDLOCAL=BackEndFramework,WebUI,WebCore,SetDateAndTime,Set_Language,\
NetworkSetup,Logs,AlertEmail,Shutdown,\
UsersAndGroups,RemoteDesktop,SysInfo,WebBlade";

//
// Other command line options
//
const LPCWSTR REMOVE_ALL = L"msiexec /qn /X";

//Path to IIS in the metabase
const LPCWSTR METABASE_IIS_PATH = L"LM/w3svc";


//////////////////////////////////////////////////////////////////////////////
//  
//  SaInstall::SAAlreadyInstalled
//
//  Description:
//      Detects if a type of Server Appliance is installed.
//
//  Arguments:
//		[in] SA_TYPE: The type of SA to query (NAS or WEB)
//      [OUT] VARIANT_BOOL:  Whether this type of SA is installed
//
//  Returns:
//      HRESULT  
//
//  history:
//      travisn   Created   23-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP SaInstall::SAAlreadyInstalled(
    const SA_TYPE installedType, //[in] Is a NAS or WEB solution is installed?
    VARIANT_BOOL *pbInstalled)//[out] tells if the SAK is already installed
{
    HRESULT hr = S_OK;
    SATraceString ("Entering SaInstall::SAAlreadyInstalled");

    try 
    {
        //Check to see if a valid SAK type was passed in
        if (installedType != NAS && installedType != WEB)
        {
            hr = E_ABORT;
            SATraceString (" Invalid installedType");
        }
        else
        {   //Check to see if the NAS or WEB is installed
            *pbInstalled = bSAIsInstalled(installedType) ? VARIANT_TRUE : VARIANT_FALSE;
	        hr = S_OK;
        }
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    //Single point of return
    SATraceString ("Exiting SaInstall::SAAlreadyInstalled");
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//  
//  SaInstall::SAUninstall
//
//  Description:
//      Uninstalls a Server Appliance solution, if the type requested
//      is installed.  
//
//  Arguments:
//		[in] SA_TYPE: The type to uninstall (WEB)
//      [OUT] BSTR*:  Currently there are no reported errors
//  Returns:
//      HRESULT  
//
//  history:
//      travisn   Created   23-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP SaInstall::SAUninstall(
           const SA_TYPE uninstallType, //[in]Type of SAK to uninstall
           BSTR* pbstrErrorString)//[out]
{
    SATraceString ("Entering SaInstall::SAUninstall");
    //Clear out the error string
    *pbstrErrorString = NULL;
    HRESULT hr = S_OK;

    try
    {
        //
        // Create this do...while(false) loop to create a single point 
        // of return
        //
        do
        {
            if (uninstallType != WEB)
            {
                //Unidentified or unsupported type to uninstall
                hr = E_ABORT;
                ReportError(pbstrErrorString, VARIANT_FALSE, IDS_INVALID_TYPE);
                break;
            }

            //Detect if it's installed
            if (bSAIsInstalled(WEB))
            {
                //
                // uninstall the whole thing.
                // Generate the command line to call MSI to uninstall the package
                //
                wstring wsCommand(REMOVE_ALL);
                wsCommand += SAK_PRODUCT_CODE;
                hr = CreateHiddenConsoleProcess(wsCommand.data());
                if (FAILED(hr))
                {
                    ReportError(pbstrErrorString, VARIANT_FALSE, IDS_UNINSTALL_SA_FAILED);
                }
                break;
            }
            
            //
            // Neither of these types are installed, so report an error
            // since they shouldn't have requested to uninstall.
            //
            ReportError(pbstrErrorString, VARIANT_FALSE, IDS_NOT_INSTALLED);

            //
            // Since trying to uninstall something that is not present
            // isn't fatal, return S_FALSE
            //
            hr = S_FALSE;
        }
        while (false);
    }
    catch (...)
    {
        hr = E_FAIL;
    }

    //Single point of return
    SATraceString ("Exiting SaInstall::SAUninstall");
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//  
//  SaInstall::SAInstall
//
//  Description:
//      Installs a Server Appliance solution, depending on the arguments.
//      Does some simple error checking to make sure that SaSetup.msi
//      is present, and displays error messages if any errors occur.
//
//  Arguments:
//		[in] SA_TYPE: The type to install (NAS or WEB)
//		[in] BSTR:    The name of the CD that will be prompted for if 
//                    SaSetup.msi is not found. Not used anymore
//      [in] VARIANT_BOOL: Whether error dialog prompts will appear
//      [in] VARIANT_BOOL: Whether the install is unattended
//      [OUT] BSTR*:  If an error occurs during installation, the error
//                    string is returned here
//  Returns:
//      HRESULT  
//
//  history:
//      travisn   Created   23-JUL-2001
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP SaInstall::SAInstall(
    const SA_TYPE installType,     //[in]
	const BSTR bstrDiskName,         //[in]
    const VARIANT_BOOL bDispError,  //[in]
    const VARIANT_BOOL bUnattended, //[in]
    BSTR* pbstrErrorString)         //[out]
{
    HRESULT hr = E_FAIL;
    SATraceString("Entering SaInstall::SAInstall");

    try
    {
        //Clear out the error string
        *pbstrErrorString = NULL;

        //
        // Create this do...while(false) loop to create a single point 
        // of return
        //
        do 
        {   //
            //Check the parameters
            //
         
            //Check to see if a valid SAK type was passed in
            if (installType != WEB)
            {
                ReportError(pbstrErrorString, VARIANT_FALSE, IDS_INVALID_TYPE);
                break;
            }
            
            //Check to see if this SAK type is already installed
            if (bSAIsInstalled(installType))
	        {
                ReportError(pbstrErrorString, VARIANT_FALSE, IDS_ALREADY_INSTALLED);
                break;
	        }

            //
            // Make sure that IIS is installed and functioning
            //
            {   // CMetabaseObject must go out of scope to avoid keeping a read-lock
                // on the metabase during our install
                CMetabaseObject metabase;
                hr = metabase.openObject(METABASE_IIS_PATH);
                if (FAILED(hr))
                {
                     ReportError(pbstrErrorString, VARIANT_FALSE, IDS_IIS_NOT_INSTALLED);
                     break;  // Something wrong with IIS installation
                }
            }

            //
            // Make sure we're installing on an NTFS partition
            //
            if (!InstallingOnNTFS())
	        {
                ReportError(pbstrErrorString, VARIANT_FALSE, IDS_NTFS_REQUIRED);
                hr = E_FAIL;
                break;
	        }

            //
            // Find the path to SaSetup.msi in system32
            //
            wstring wsLocationOfSaSetup;
            hr = GetInstallLocation(wsLocationOfSaSetup);
            if (FAILED(hr))
	        {
                ReportError(pbstrErrorString, VARIANT_FALSE, IDS_SASETUP_NOT_FOUND);
                break;
	        }

            //
	        // Create the complete command line for the SaSetup, whether for NAS or 
            // WebBlade. We already have the complete path to SaSetup.msi in 
            // wsLocationOfSaSetup, so we need to append the command-line parameters.
            //

            //Create the command-line options applicable to all installations
            wstring wsCommand;

            //
            // There are 3 sources that call this installation: CYS, IIS, and SaInstall.exe.
            // We want to display a progress dialog for CYS and IIS, but not SaInstall.
            // SaInstall is the only source that calls this function with bDispError == true.
            //
            if (bDispError)
                wsCommand = MSIEXEC_NO_PROGRESS_INSTALL;
            else
                wsCommand = MSIEXEC_INSTALL;

            wsCommand += wsLocationOfSaSetup;

		    //Install a Web solution
            wsCommand += WEB_INSTALL_OPTIONS;

            //
            //Take the command line and create a hidden window to execute it
            //
	        hr = CreateHiddenConsoleProcess(wsCommand.data());
            if (FAILED(hr))
            {
                ReportError(pbstrErrorString, VARIANT_FALSE, IDS_SASETUP_FAILED);
                break;
            }

            //
            // Check to make sure that the installation completed successfully
            // in case the user aborted by clicking Cancel
            // If they did cancel, return E_FAIL
            // If it is a valid installation, return S_OK
            // This is necessary since the return value from the MSI process
            // always returns SUCCESS, even if the user aborted
            //

            if (!bSAIsInstalled(installType))
            {
                ReportError(pbstrErrorString, VARIANT_FALSE, IDS_INSTALL_FAILED);
                hr = E_FAIL;
                break;
            }

            //
            // Test to make sure the Admin site started
            //
            TestWebSites(bDispError, pbstrErrorString);

            hr = S_OK;
        }
        while (false);

    }
    catch (...)
    {
        SATraceString ("Unexpected exception in SAInstall::SAInstall");
        //Unexpected exception!!
    }

    SATraceString("Exiting SAInstall::SAInstall");
    //Single point of return
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  SaInstall::InterfaceSupportsErrorInfo
//
//  Description:
//    From Interface ISupportErrorInfo
//
//  history
//      travisn   2-AUG-2001  Some comments added
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP SaInstall::InterfaceSupportsErrorInfo(REFIID riid)//[in]
{
	if (InlineIsEqualGUID(IID_ISaInstall, riid))
    {
		return S_OK;
    }

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\cominterfaces\sadisplay.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###    ###   #####   ####  ###  #####  ##      ###   ##  ##     ####  #####  #####
    ##  #   ###   ##  ##   ##  ##  # ##  ## ##      ###   ##  ##    ##   # ##  ## ##  ##
    ###    ## ##  ##   ##  ##  ###   ##  ## ##     ## ##   ####     ##     ##  ## ##  ##
     ###   ## ##  ##   ##  ##   ###  ##  ## ##     ## ##   ####     ##     ##  ## ##  ##
      ### ####### ##   ##  ##    ### #####  ##    #######   ##      ##     #####  #####
    #  ## ##   ## ##  ##   ##  #  ## ##     ##    ##   ##   ##   ## ##   # ##     ##
     ###  ##   ## #####   ####  ###  ##     ##### ##   ##   ##   ##  ####  ##     ##

Abstract:

    This module contains the implementation for
    the ISaDisplay interface class.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    User mode only.

Notes:

--*/

#include "internal.h"



CSaDisplay::CSaDisplay()
{
    m_hFile = OpenSaDevice( SA_DEVICE_DISPLAY );
    if (m_hFile != INVALID_HANDLE_VALUE) {
        ULONG Bytes;
        m_DisplayCaps.SizeOfStruct = sizeof(SA_DISPLAY_CAPS);
        BOOL b = DeviceIoControl(
            m_hFile,
            IOCTL_SA_GET_CAPABILITIES,
            NULL,
            0,
            &m_DisplayCaps,
            sizeof(SA_DISPLAY_CAPS),
            &Bytes,
            NULL
            );
        if (!b) {
            CloseHandle( m_hFile );
            m_hFile = NULL;
        }


        b = DeviceIoControl(
            m_hFile,
            IOCTL_SA_GET_VERSION,
            NULL,
            0,
            &m_InterfaceVersion,
            sizeof(ULONG),
            &Bytes,
            NULL
            );
        if (!b) {
            CloseHandle( m_hFile );
            m_hFile = NULL;
        }

        m_CachedBitmapSize = m_DisplayCaps.DisplayHeight * (m_DisplayCaps.DisplayWidth / 8);
        m_CachedBitmap = (PUCHAR) malloc( m_CachedBitmapSize );
        if (m_CachedBitmap == NULL) {
            CloseHandle( m_hFile );
            m_hFile = NULL;
        }

    } else {
        m_hFile = NULL;
    }
}


CSaDisplay::~CSaDisplay()
{
    if (m_hFile != NULL) {
        CloseHandle( m_hFile );
    }
    if (m_CachedBitmap) {
        free( m_CachedBitmap );
    }
}


STDMETHODIMP CSaDisplay::get_InterfaceVersion(long *pVal)
{
    *pVal = m_InterfaceVersion;
    return S_OK;
}


STDMETHODIMP CSaDisplay::get_DisplayType(long *pVal)
{
    *pVal = m_DisplayCaps.DisplayType;
    return S_OK;
}


STDMETHODIMP CSaDisplay::get_CharacterSet(long *pVal)
{
    *pVal = m_DisplayCaps.CharacterSet;
    return S_OK;
}


STDMETHODIMP CSaDisplay::get_DisplayHeight(long *pVal)
{
    *pVal = m_DisplayCaps.DisplayHeight;
    return S_OK;
}


STDMETHODIMP CSaDisplay::get_DisplayWidth(long *pVal)
{
    *pVal = m_DisplayCaps.DisplayWidth;
    return S_OK;
}

void
CSaDisplay::ConvertBottomLeft2TopLeft(
    PUCHAR Bits,
    ULONG Width,
    ULONG Height
    )
{
    ULONG Row;
    ULONG Col;
    UCHAR Temp;


    Width = Width >> 3;

    for (Row = 0; Row < (Height / 2); Row++) {
        for (Col = 0; Col < Width; Col++) {
            Temp = Bits[Row * Width + Col];
            Bits[Row * Width + Col] = Bits[(Height - Row - 1) * Width + Col];
            Bits[(Height - Row - 1) * Width + Col] = Temp;
        }
    }
}


int
CSaDisplay::DisplayBitmap(
    long MsgCode,
    long Width,
    long Height,
    unsigned char *Bits
    )
{
    ULONG SizeOfBits;
    ULONG Bytes;
    BOOL b;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }
    ConvertBottomLeft2TopLeft( Bits, Width, Height );

    //
    // Check the cache for a hit
    //

    SizeOfBits = Height * (Width >> 3);
    if (SizeOfBits == m_CachedBitmapSize && (memcmp( m_CachedBitmap, Bits, SizeOfBits ) == 0)) {
        return ERROR_SUCCESS;
    }

    //
    // Display the new bitmap
    //

    m_SaDisplay.SizeOfStruct = sizeof(SA_DISPLAY_SHOW_MESSAGE);
    m_SaDisplay.MsgCode = MsgCode;

    m_SaDisplay.Width = (USHORT)Width;
    m_SaDisplay.Height = (USHORT)Height;

    memcpy( m_SaDisplay.Bits, Bits, SizeOfBits );

    b = WriteFile( m_hFile, &m_SaDisplay, sizeof(SA_DISPLAY_SHOW_MESSAGE), &Bytes, NULL );
    if (b == FALSE || Bytes != sizeof(SA_DISPLAY_SHOW_MESSAGE)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Cache the bitmap
    //

    m_CachedBitmapSize = SizeOfBits;
    memcpy( m_CachedBitmap, Bits, m_CachedBitmapSize );

    return ERROR_SUCCESS;
}


STDMETHODIMP
CSaDisplay::ShowMessage(
    long MsgCode,
    long Width,
    long Height,
    unsigned char *Bits
    )
{

    if (Width > m_DisplayCaps.DisplayWidth) {
        return E_FAIL;
    }

    if (Height > m_DisplayCaps.DisplayHeight) {
        return E_FAIL;
    }

    if (DisplayBitmap( MsgCode, Width, Height, Bits) == -1) {
        return E_FAIL;
    }

    return S_OK;
}


STDMETHODIMP CSaDisplay::ClearDisplay()
{
    ULONG Bytes;
    BOOL b;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    memset( &m_SaDisplay, 0, sizeof(SA_DISPLAY_SHOW_MESSAGE) );

    m_SaDisplay.SizeOfStruct = sizeof(SA_DISPLAY_SHOW_MESSAGE);
    m_SaDisplay.MsgCode = SA_DISPLAY_READY;

    m_SaDisplay.Width = m_DisplayCaps.DisplayWidth;
    m_SaDisplay.Height = m_DisplayCaps.DisplayHeight;

    b = WriteFile( m_hFile, &m_SaDisplay, sizeof(SA_DISPLAY_SHOW_MESSAGE), &Bytes, NULL );
    if (b == FALSE || Bytes != sizeof(SA_DISPLAY_SHOW_MESSAGE)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Clear the bitmap cache
    //

    m_CachedBitmapSize = 0;

    return S_OK;
}


STDMETHODIMP
CSaDisplay::ShowMessageFromFile(
    long MsgCode,
    BSTR BitmapFileName
    )
{
    HRESULT hr = E_FAIL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBITMAPFILEHEADER bmf;
    PBITMAPINFOHEADER bmi;
    PUCHAR BitmapData = NULL;
    ULONG FileSize;
    ULONG Bytes;


    __try {

        hFile = CreateFile(
            BitmapFileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );
        if (hFile == INVALID_HANDLE_VALUE) {
            __leave;
        }

        FileSize = GetFileSize( hFile, NULL );

        BitmapData = (PUCHAR) malloc( FileSize );
        if (BitmapData == NULL) {
            __leave;
        }

        if (!ReadFile( hFile, BitmapData, FileSize, &Bytes, NULL )) {
            __leave;
        }

        bmf = (PBITMAPFILEHEADER) BitmapData;
        bmi = (PBITMAPINFOHEADER) (BitmapData + sizeof(BITMAPFILEHEADER));

        if (bmf->bfType != 0x4d42) {
            __leave;
        }

        if (bmi->biBitCount != 1 &&  bmi->biCompression != 0) {
            __leave;
        }

        if (DisplayBitmap( 0, bmi->biWidth, bmi->biHeight, (PUCHAR)(BitmapData + bmf->bfOffBits) ) == -1) {
            __leave;
        }

        hr = S_OK;

    } __finally {

        if (BitmapData) {
            free( BitmapData );
        }

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
        }

    }

    return hr;
}


STDMETHODIMP
CSaDisplay::StoreBitmap(
    long MessageId,
    long Width,
    long Height,
    unsigned char *Bits
    )
{
    BOOL b;
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    ConvertBottomLeft2TopLeft( Bits, Width, Height );

    m_SaDisplay.SizeOfStruct = sizeof(SA_DISPLAY_SHOW_MESSAGE);
    m_SaDisplay.MsgCode = MessageId;
    m_SaDisplay.Width = (USHORT)Width;
    m_SaDisplay.Height = (USHORT)Height;

    memcpy( m_SaDisplay.Bits, Bits, Height * (Width >> 3) );

    b = DeviceIoControl(
        m_hFile,
        IOCTL_FUNC_DISPLAY_STORE_BITMAP,
        &m_SaDisplay,
        sizeof(SA_DISPLAY_SHOW_MESSAGE),
        NULL,
        0,
        &Bytes,
        NULL
        );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}


STDMETHODIMP CSaDisplay::Lock()
{
    BOOL b;
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    b = DeviceIoControl(
        m_hFile,
        IOCTL_SADISPLAY_LOCK,
        NULL,
        0,
        NULL,
        0,
        &Bytes,
        NULL
        );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}


STDMETHODIMP CSaDisplay::UnLock()
{
    BOOL b;
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    b = DeviceIoControl(
        m_hFile,
        IOCTL_SADISPLAY_UNLOCK,
        NULL,
        0,
        NULL,
        0,
        &Bytes,
        NULL
        );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

STDMETHODIMP CSaDisplay::ReloadRegistryBitmaps()
{
    BOOL b;
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    b = DeviceIoControl(
        m_hFile,
        IOCTL_SADISPLAY_CHANGE_LANGUAGE,
        NULL,
        0,
        NULL,
        0,
        &Bytes,
        NULL
        );

    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

STDMETHODIMP CSaDisplay::ShowRegistryBitmap(long MessageId)
{
    BOOL b;
    DWORD dwIoControlCode = 0;
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    if (MessageId == SA_DISPLAY_CHECK_DISK){
        dwIoControlCode = IOCTL_SADISPLAY_BUSY_MESSAGE;
    }
    else if (MessageId == SA_DISPLAY_SHUTTING_DOWN){
        dwIoControlCode = IOCTL_SADISPLAY_SHUTDOWN_MESSAGE;
    }
    else{
        return E_INVALIDARG;
    }


    b = DeviceIoControl(
            m_hFile,
            dwIoControlCode,
            NULL,
            0,
            NULL,
            0,
            &Bytes,
            NULL
            );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\cominterfaces\sanvram.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###    ###   ##   # ##  ## #####    ###   ##    ##    ##   ##
    ##  #   ###   ###  # ##  ## ##  ##   ###   ###  ###    ##   ##
    ###    ## ##  #### # ##  ## ##  ##  ## ##  ########    ##   ##
     ###   ## ##  # ####  ####  #####   ## ##  # ### ##    #######
      ### ####### #  ###  ####  ####   ####### #  #  ##    ##   ##
    #  ## ##   ## #   ##   ##   ## ##  ##   ## #     ## ## ##   ##
     ###  ##   ## #    #   ##   ##  ## ##   ## #     ## ## ##   ##

Abstract:

    This header file contains the class definition for
    the ISaNvram interface class.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    User mode only.

Notes:

--*/

#ifndef __SANVRAM_H_
#define __SANVRAM_H_

class ATL_NO_VTABLE CSaNvram :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSaNvram, &CLSID_SaNvram>,
    public IDispatchImpl<ISaNvram, &IID_ISaNvram, &LIBID_SACOMLib>
{
public:
    CSaNvram();
    ~CSaNvram();

DECLARE_REGISTRY_RESOURCEID(IDR_SANVRAM)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSaNvram)
    COM_INTERFACE_ENTRY(ISaNvram)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    STDMETHOD(get_DataSlot)(/*[in]*/ long Number, /*[out, retval]*/ long *pVal);
    STDMETHOD(put_DataSlot)(/*[in]*/ long Number, /*[in]*/ long newVal);
    STDMETHOD(get_Size)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_BootCounter)(/*[in]*/ long Number, /*[out, retval]*/ long *pVal);
    STDMETHOD(put_BootCounter)(/*[in]*/ long Number, /*[in]*/ long newVal);
    STDMETHOD(get_InterfaceVersion)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_DeviceId)(/*[in]*/ long Number, /*[out, retval]*/ long *pVal);
    STDMETHOD(put_DeviceId)(/*[in]*/ long Number, /*[in]*/ long newVal);


private:
    HANDLE                      m_hFile;
    ULONG                       m_InterfaceVersion;
    SA_NVRAM_CAPS               m_NvramCaps;

};

#endif //__SANVRAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\cominterfaces\sakeypad.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###    ###   ##  ## ##### ##  ## #####    ###   #####       ####  #####  #####
    ##  #   ###   ## ##  ##    ##  ## ##  ##   ###   ##  ##     ##   # ##  ## ##  ##
    ###    ## ##  ####   ##     ####  ##  ##  ## ##  ##   ##    ##     ##  ## ##  ##
     ###   ## ##  ###    #####  ####  ##  ##  ## ##  ##   ##    ##     ##  ## ##  ##
      ### ####### ####   ##      ##   #####  ####### ##   ##    ##     #####  #####
    #  ## ##   ## ## ##  ##      ##   ##     ##   ## ##  ##  ## ##   # ##     ##
     ###  ##   ## ##  ## #####   ##   ##     ##   ## #####   ##  ####  ##     ##

Abstract:

    This module contains the implementation for
    the ISaKeypad interface class.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    Kernel mode only.

Notes:

--*/

#include "internal.h"



HANDLE
OpenSaDevice(
    ULONG DeviceType
    )
{
    HANDLE hDevice;
    WCHAR buf[128];


    wcscpy( buf, L"\\\\?\\GLOBALROOT" );

    switch (DeviceType) {
        case SA_DEVICE_DISPLAY:
            wcscat( buf, SA_DEVICE_DISPLAY_NAME_STRING );
            break;

        case SA_DEVICE_KEYPAD:
            wcscat( buf, SA_DEVICE_KEYPAD_NAME_STRING );
            break;

        case SA_DEVICE_NVRAM:
            wcscat( buf, SA_DEVICE_NVRAM_NAME_STRING );
            break;

        case SA_DEVICE_WATCHDOG:
            wcscat( buf, SA_DEVICE_WATCHDOG_NAME_STRING );
            break;
    }

    hDevice = CreateFile(
        buf,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );

    return hDevice;
}


CSaKeypad::CSaKeypad()
{

    m_hFile = OpenSaDevice( SA_DEVICE_KEYPAD );
    if (m_hFile != INVALID_HANDLE_VALUE) {
        ULONG Bytes;
        BOOL b = DeviceIoControl(
            m_hFile,
            IOCTL_SA_GET_VERSION,
            NULL,
            0,
            &m_InterfaceVersion,
            sizeof(ULONG),
            &Bytes,
            NULL
            );
        if (!b) {
            CloseHandle( m_hFile );
            m_hFile = NULL;
        }
    } else {
        m_hFile = NULL;
    }
}


CSaKeypad::~CSaKeypad()
{
    if (m_hFile != NULL) {
        CloseHandle( m_hFile );
    }
}


STDMETHODIMP CSaKeypad::get_InterfaceVersion(long *pVal)
{
    *pVal = (long)m_InterfaceVersion;
    return S_OK;
}


STDMETHODIMP
CSaKeypad::get_Key(
    SAKEY *pVal
    )
{
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    if (!ReadFile( m_hFile, &m_Keypress, sizeof(UCHAR), &Bytes, NULL )) {
        return E_FAIL;
    }

    if (m_Keypress & SA_KEYPAD_UP) {
        *pVal = SAKEY_UP;
    } else
    if (m_Keypress & SA_KEYPAD_DOWN) {
        *pVal = SAKEY_DOWN;
    } else
    if (m_Keypress & SA_KEYPAD_LEFT) {
        *pVal = SAKEY_LEFT;
    } else
    if (m_Keypress & SA_KEYPAD_RIGHT) {
        *pVal = SAKEY_RIGHT;
    } else
    if (m_Keypress & SA_KEYPAD_CANCEL) {
        *pVal = SAKEY_ESCAPE;
    } else
    if (m_Keypress & SA_KEYPAD_SELECT) {
        *pVal = SAKEY_RETURN;
    } else {
        *pVal = (SAKEY)0;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\cominterfaces\sakeypad.h ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###    ###   ##  ## ##### ##  ## #####    ###   #####      ##   ##
    ##  #   ###   ## ##  ##    ##  ## ##  ##   ###   ##  ##     ##   ##
    ###    ## ##  ####   ##     ####  ##  ##  ## ##  ##   ##    ##   ##
     ###   ## ##  ###    #####  ####  ##  ##  ## ##  ##   ##    #######
      ### ####### ####   ##      ##   #####  ####### ##   ##    ##   ##
    #  ## ##   ## ## ##  ##      ##   ##     ##   ## ##  ##  ## ##   ##
     ###  ##   ## ##  ## #####   ##   ##     ##   ## #####   ## ##   ##

Abstract:

    This header file contains the class definition for
    the ISaKeypad interface class.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    User mode only.

Notes:

--*/

#ifndef __SAKEYPAD_H_
#define __SAKEYPAD_H_

class ATL_NO_VTABLE CSaKeypad :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSaKeypad, &CLSID_SaKeypad>,
    public IDispatchImpl<ISaKeypad, &IID_ISaKeypad, &LIBID_SACOMLib>
{
public:
    CSaKeypad();
    ~CSaKeypad();

DECLARE_REGISTRY_RESOURCEID(IDR_SAKEYPAD)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSaKeypad)
    COM_INTERFACE_ENTRY(ISaKeypad)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    STDMETHOD(get_InterfaceVersion)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Key)(/*[out, retval]*/ SAKEY *pVal);

private:
    HANDLE              m_hFile;
    ULONG               m_InterfaceVersion;
    UCHAR               m_Keypress;

};

#endif //__SAKEYPAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\cominterfaces\sanvram.cpp ===
/*++

Copyright (c) 1991 - 2001 Microsoft Corporation

Module Name:

     ###    ###   ##   # ##  ## #####    ###   ##    ##     ####  #####  #####
    ##  #   ###   ###  # ##  ## ##  ##   ###   ###  ###    ##   # ##  ## ##  ##
    ###    ## ##  #### # ##  ## ##  ##  ## ##  ########    ##     ##  ## ##  ##
     ###   ## ##  # ####  ####  #####   ## ##  # ### ##    ##     ##  ## ##  ##
      ### ####### #  ###  ####  ####   ####### #  #  ##    ##     #####  #####
    #  ## ##   ## #   ##   ##   ## ##  ##   ## #     ## ## ##   # ##     ##
     ###  ##   ## #    #   ##   ##  ## ##   ## #     ## ##  ####  ##     ##

Abstract:

    This module contains the implementation for
    the ISaNvram interface class.

Author:

    Wesley Witt (wesw) 1-Oct-2001

Environment:

    User mode only.

Notes:

--*/

#include "internal.h"



CSaNvram::CSaNvram()
{
    m_hFile = OpenSaDevice( SA_DEVICE_NVRAM );
    if (m_hFile != INVALID_HANDLE_VALUE) {
        ULONG Bytes;
        m_NvramCaps.SizeOfStruct = sizeof(SA_NVRAM_CAPS);
        BOOL b = DeviceIoControl(
            m_hFile,
            IOCTL_SA_GET_CAPABILITIES,
            NULL,
            0,
            &m_NvramCaps,
            sizeof(SA_NVRAM_CAPS),
            &Bytes,
            NULL
            );
        if (!b) {
            CloseHandle( m_hFile );
            m_hFile = NULL;
        }
        b = DeviceIoControl(
            m_hFile,
            IOCTL_SA_GET_VERSION,
            NULL,
            0,
            &m_InterfaceVersion,
            sizeof(ULONG),
            &Bytes,
            NULL
            );
        if (!b) {
            CloseHandle( m_hFile );
            m_hFile = NULL;
        }
    } else {
        m_hFile = NULL;
    }
}


CSaNvram::~CSaNvram()
{
    if (m_hFile != NULL) {
        CloseHandle( m_hFile );
    }
}


STDMETHODIMP CSaNvram::get_InterfaceVersion(long *pVal)
{
    *pVal = (long)m_InterfaceVersion;
    return S_OK;
}

STDMETHODIMP CSaNvram::get_BootCounter(long Number, long *pVal)
{
    BOOL b;
    SA_NVRAM_BOOT_COUNTER BootCounter;
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    BootCounter.SizeOfStruct = sizeof(SA_NVRAM_BOOT_COUNTER);
    BootCounter.Number = Number;
    BootCounter.Value = 0;
    BootCounter.DeviceId = 0;

    b = DeviceIoControl(
        m_hFile,
        IOCTL_NVRAM_READ_BOOT_COUNTER,
        NULL,
        0,
        &BootCounter,
        sizeof(SA_NVRAM_BOOT_COUNTER),
        &Bytes,
        NULL
        );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *pVal = BootCounter.Value;

    return S_OK;
}

STDMETHODIMP CSaNvram::put_BootCounter(long Number, long newVal)
{
    BOOL b;
    SA_NVRAM_BOOT_COUNTER BootCounter;
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    BootCounter.SizeOfStruct = sizeof(SA_NVRAM_BOOT_COUNTER);
    BootCounter.Number = Number;
    BootCounter.Value = 0;
    BootCounter.DeviceId = 0;

    b = DeviceIoControl(
        m_hFile,
        IOCTL_NVRAM_READ_BOOT_COUNTER,
        NULL,
        0,
        &BootCounter,
        sizeof(SA_NVRAM_BOOT_COUNTER),
        &Bytes,
        NULL
        );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    BootCounter.SizeOfStruct = sizeof(SA_NVRAM_BOOT_COUNTER);
    BootCounter.Number = Number;
    BootCounter.Value = newVal;

    b = DeviceIoControl(
        m_hFile,
        IOCTL_NVRAM_WRITE_BOOT_COUNTER,
        &BootCounter,
        sizeof(SA_NVRAM_BOOT_COUNTER),
        NULL,
        0,
        &Bytes,
        NULL
        );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

STDMETHODIMP CSaNvram::get_DeviceId(long Number, long *pVal)
{
    BOOL b;
    SA_NVRAM_BOOT_COUNTER BootCounter;
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    BootCounter.SizeOfStruct = sizeof(SA_NVRAM_BOOT_COUNTER);
    BootCounter.Number = Number;
    BootCounter.Value = 0;
    BootCounter.DeviceId = 0;

    b = DeviceIoControl(
        m_hFile,
        IOCTL_NVRAM_READ_BOOT_COUNTER,
        NULL,
        0,
        &BootCounter,
        sizeof(SA_NVRAM_BOOT_COUNTER),
        &Bytes,
        NULL
        );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *pVal = BootCounter.DeviceId;

    return S_OK;
}

STDMETHODIMP CSaNvram::put_DeviceId(long Number, long newVal)
{
    BOOL b;
    SA_NVRAM_BOOT_COUNTER BootCounter;
    ULONG Bytes;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    BootCounter.SizeOfStruct = sizeof(SA_NVRAM_BOOT_COUNTER);
    BootCounter.Number = Number;
    BootCounter.Value = 0;
    BootCounter.DeviceId = 0;

    b = DeviceIoControl(
        m_hFile,
        IOCTL_NVRAM_READ_BOOT_COUNTER,
        NULL,
        0,
        &BootCounter,
        sizeof(SA_NVRAM_BOOT_COUNTER),
        &Bytes,
        NULL
        );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    BootCounter.SizeOfStruct = sizeof(SA_NVRAM_BOOT_COUNTER);
    BootCounter.Number = Number;
    BootCounter.DeviceId = newVal;

    b = DeviceIoControl(
        m_hFile,
        IOCTL_NVRAM_WRITE_BOOT_COUNTER,
        &BootCounter,
        sizeof(SA_NVRAM_BOOT_COUNTER),
        NULL,
        0,
        &Bytes,
        NULL
        );
    if (!b) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

STDMETHODIMP CSaNvram::get_Size(long *pVal)
{
    *pVal = m_NvramCaps.NvramSize;
    return S_OK;
}

STDMETHODIMP CSaNvram::get_DataSlot(long Number, long *pVal)
{
    BOOL b;
    ULONG Bytes;
    ULONG Position;
    ULONG NewPosition;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    Position = (Number - 1) * sizeof(ULONG);

    NewPosition = SetFilePointer( m_hFile, Position, NULL, FILE_BEGIN );
    if (NewPosition != Position) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    b = ReadFile( m_hFile, pVal, sizeof(ULONG), &Bytes, NULL );
    if (!b ) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

STDMETHODIMP CSaNvram::put_DataSlot(long Number, long newVal)
{
    BOOL b;
    ULONG Bytes;
    ULONG Position;
    ULONG NewPosition;

    if (m_hFile == NULL){
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    Position = (Number - 1) * sizeof(ULONG);

    NewPosition = SetFilePointer( m_hFile, Position, NULL, FILE_BEGIN );
    if (NewPosition != Position) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    b = WriteFile( m_hFile, &newVal, sizeof(ULONG), &Bytes, NULL );
    if (!b ) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\test\delayboot\delayboot.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <stdlib.h>

#define SecToNano(_sec)     (LONGLONG)((_sec) * 1000 * 1000 * 10)


int __cdecl
main(
    int     argc,
    char**  argv,
    char**  envp,
    ULONG   DebugParameter
    )
{
    LARGE_INTEGER TimeOut;
    ULONG Seconds;


    if (argc == 2) {
        Seconds = atol(argv[1]);
    } else {
        Seconds = 60;
    }

    DbgPrint( "Delaying boot for [%d] seconds\n", Seconds );

    TimeOut.QuadPart = -SecToNano(Seconds);
    NtDelayExecution( 0, &TimeOut );

    DbgPrint( "Resuming boot...\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\test\cmdline\acpi.cpp ===
extern "C" {
#include <nt.h>
typedef PVOID PPM_DISPATCH_TABLE;
#include <ntacpi.h>
#include <acpitabl.h>
#include <stdio.h>
}


void
PrintACPITable(
    PVOID AcpiTable
    )
{
    PWATCHDOG_TIMER_RESOURCE_TABLE WdTable = (PWATCHDOG_TIMER_RESOURCE_TABLE)AcpiTable;

    wprintf( L"\n" );
    wprintf( L"Signature                 [%08x]\n",             WdTable->Header.Signature );
    wprintf( L"Length                    [%08x]\n",             WdTable->Header.Length );
    wprintf( L"Revision                  [%02x]\n",             WdTable->Header.Revision );
    wprintf( L"Checksum                  [%02x]\n",             WdTable->Header.Checksum );
    wprintf( L"OEMID                     [%c%c%c%c%c%c]\n",     WdTable->Header.OEMID[0],
                                                                WdTable->Header.OEMID[1],
                                                                WdTable->Header.OEMID[2],
                                                                WdTable->Header.OEMID[3],
                                                                WdTable->Header.OEMID[4],
                                                                WdTable->Header.OEMID[5] );
    wprintf( L"OEMTableID                [%c%c%c%c%c%c%c%c]\n", WdTable->Header.OEMTableID[0],
                                                                WdTable->Header.OEMTableID[1],
                                                                WdTable->Header.OEMTableID[2],
                                                                WdTable->Header.OEMTableID[3],
                                                                WdTable->Header.OEMTableID[4],
                                                                WdTable->Header.OEMTableID[5],
                                                                WdTable->Header.OEMTableID[6],
                                                                WdTable->Header.OEMTableID[7] );
    wprintf( L"OEMRevision               [%08x]\n",             WdTable->Header.OEMRevision );
    wprintf( L"CreatorID                 [%c%c%c%c]\n",         WdTable->Header.CreatorID[0],
                                                                WdTable->Header.CreatorID[1],
                                                                WdTable->Header.CreatorID[2],
                                                                WdTable->Header.CreatorID[3] );
    wprintf( L"CreatorRev                [%08x]\n",             WdTable->Header.CreatorRev );
    wprintf( L"ControlRegisterAddress    [%08x]\n",             WdTable->ControlRegisterAddress.Address.u.LowPart );
    wprintf( L"CountRegisterAddress      [%08x]\n",             WdTable->CountRegisterAddress.Address.u.LowPart );
    wprintf( L"PciDeviceId               [%04x]\n",             WdTable->PciDeviceId );
    wprintf( L"PciVendorId               [%04x]\n",             WdTable->PciVendorId );
    wprintf( L"PciBusNumber              [%02x]\n",             WdTable->PciBusNumber );
    wprintf( L"PciSlotNumber             [%02x]\n",             WdTable->PciSlotNumber );
    wprintf( L"PciFunctionNumber         [%02x]\n",             WdTable->PciFunctionNumber );
    wprintf( L"PciSegment                [%02x]\n",             WdTable->PciSegment );
    wprintf( L"MaxCount                  [%04x]\n",             WdTable->MaxCount );
    wprintf( L"Units                     [%02x]\n",             WdTable->Units );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\test\cmdline\test.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include "saio.h"
#include "..\driver\ioctl.h"



void
PrintACPITable(
    PVOID AcpiTable
    );

PWSTR SaDeviceName[] =
{
    { NULL                                                      },       //  SA_DEVICE_UNKNOWN
    { L"\\\\?\\GLOBALROOT\\Device\\ServerApplianceLocalDisplay" },       //  SA_DEVICE_DISPLAY
    { L"\\\\?\\GLOBALROOT\\Device\\ServerApplianceKeypad"       },       //  SA_DEVICE_KEYPAD
    { L"\\\\?\\GLOBALROOT\\Device\\ServerApplianceNvram"        },       //  SA_DEVICE_NVRAM
    { L"\\\\?\\GLOBALROOT\\Device\\ServerApplianceWatchdog"     }        //  SA_DEVICE_WATCHDOG
};

ULONG NvramData[32];
UCHAR KeyBuffer[32];
PVOID WdTable;


HANDLE
OpenSaDevice(
    ULONG DeviceType
    )
{
    HANDLE hDevice;
    WCHAR buf[128];


    wcscpy( buf, L"\\\\?\\GLOBALROOT" );

    switch (DeviceType) {
        case SA_DEVICE_DISPLAY:
            wcscat( buf, SA_DEVICE_DISPLAY_NAME_STRING );
            break;

        case SA_DEVICE_KEYPAD:
            wcscat( buf, SA_DEVICE_KEYPAD_NAME_STRING );
            break;

        case SA_DEVICE_NVRAM:
            wcscat( buf, SA_DEVICE_NVRAM_NAME_STRING );
            break;

        case SA_DEVICE_WATCHDOG:
            wcscat( buf, SA_DEVICE_WATCHDOG_NAME_STRING );
            break;
    }

    hDevice = CreateFile(
        buf,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );

    return hDevice;
}


HANDLE
OpenSaTestDriver(
    void
    )
{
    HANDLE hDevice;

    hDevice = CreateFile(
        L"\\\\.\\SaTest",
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );

    return hDevice;
}


int
WriteBitmap(
    PUCHAR Bitmap,
    ULONG Width,
    ULONG Height,
    ULONG BitmapSize
    )
{
    HANDLE hFile;
    SA_DISPLAY_SHOW_MESSAGE SaDisplay;
    ULONG Count;


    hFile = OpenSaDevice( SA_DEVICE_DISPLAY );
    if (hFile == INVALID_HANDLE_VALUE) {
        return -1;
    }

    SaDisplay.SizeOfStruct = sizeof(SA_DISPLAY_SHOW_MESSAGE);
    SaDisplay.MsgCode = SA_DISPLAY_READY;

    SaDisplay.Width = (USHORT)Width;
    SaDisplay.Height = (USHORT)Height;

    memcpy( SaDisplay.Bits, Bitmap, BitmapSize );

    WriteFile( hFile, &SaDisplay, sizeof(SA_DISPLAY_SHOW_MESSAGE), &Count, NULL );

    CloseHandle( hFile );

    return 0;
}


void
ConvertBottomLeft2TopLeft(
    PUCHAR Bits,
    ULONG Width,
    ULONG Height
    )
{
    ULONG Row;
    ULONG Col;
    UCHAR Temp;


    Width = Width >> 3;

    for (Row = 0; Row < (Height / 2); Row++) {
        for (Col = 0; Col < Width; Col++) {
            Temp = Bits[Row * Width + Col];
            Bits[Row * Width + Col] = Bits[(Height - Row - 1) * Width + Col];
            Bits[(Height - Row - 1) * Width + Col] = Temp;
        }
    }
}


int
DisplayBitmap(
    PWSTR BitmapName
    )
{
    HANDLE hFile;
    ULONG FileSize;
    PUCHAR BitmapData;
    PBITMAPFILEHEADER bmf;
    PBITMAPINFOHEADER bmi;
    ULONG Bytes;
    PUCHAR Bits;


    hFile = CreateFile(
        BitmapName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        return -1;
    }

    FileSize = GetFileSize( hFile, NULL );

    BitmapData = (PUCHAR) malloc( FileSize );
    if (BitmapData == NULL) {
        return -1;
    }
    memset( BitmapData, 0, FileSize );

    if (!ReadFile( hFile, BitmapData, FileSize, &Bytes, NULL )) {
        return -1;
    }

    bmf = (PBITMAPFILEHEADER) BitmapData;
    bmi = (PBITMAPINFOHEADER) (BitmapData + sizeof(BITMAPFILEHEADER));

    if (bmf->bfType != 0x4d42) {
        return -1;
    }

    if (bmi->biBitCount != 1 &&  bmi->biCompression != 0) {
        return -1;
    }

    Bits = (PUCHAR) BitmapData + bmf->bfOffBits;

    ConvertBottomLeft2TopLeft( Bits, bmi->biWidth, bmi->biHeight );

    WriteBitmap(
        Bits,
        bmi->biWidth,
        bmi->biHeight,
        (bmi->biWidth >> 3) * bmi->biHeight  //NewSize
        );

    free( BitmapData );

    CloseHandle( hFile );

    return 0;
}


int
ClearDisplay(
    int val
    )
{
    PUCHAR BitmapData;
    ULONG Width = 128;
    ULONG Height = 64;
    ULONG Size = (Width * Height) / 8;



    BitmapData = (PUCHAR) malloc( Size );
    if (BitmapData == NULL) {
        return -1;
    }

    memset( BitmapData, val, Size );

    return WriteBitmap( BitmapData, Width, Height, Size );
}


int
DoKeypadTest(
    void
    )
{
    HANDLE hFile;
    ULONG Count;
    UCHAR Keypress;


    hFile = OpenSaDevice( SA_DEVICE_KEYPAD );
    if (hFile == INVALID_HANDLE_VALUE) {
        return -1;
    }

    while (1) {
        wprintf( L">>> " );
        if (ReadFile( hFile, KeyBuffer, sizeof(UCHAR), &Count, NULL )) {
            Keypress = KeyBuffer[0];
            if (Keypress & SA_KEYPAD_UP) {
                wprintf( L"Up Arrow\n" );
            } else
            if (Keypress & SA_KEYPAD_DOWN) {
                wprintf( L"Down Arrow\n" );
            } else
            if (Keypress & SA_KEYPAD_LEFT) {
                wprintf( L"Left Arrow\n" );
            } else
            if (Keypress & SA_KEYPAD_RIGHT) {
                wprintf( L"Right Arrow\n" );
            } else
            if (Keypress & SA_KEYPAD_CANCEL) {
                wprintf( L"Escape\n" );
            } else
            if (Keypress & SA_KEYPAD_SELECT) {
                wprintf( L"Enter\n" );
            } else {
                wprintf( L"**-> Unknown key [%x] <-**\n", Keypress );
            }
        }
    }

    CloseHandle( hFile );

    return 0;
}


int
NvramWrite(
    ULONG Slot,
    ULONG Val
    )
{
    HANDLE hFile;
    ULONG Count;


    hFile = OpenSaDevice( SA_DEVICE_NVRAM );
    if (hFile == INVALID_HANDLE_VALUE) {
        return -1;
    }

    SetFilePointer(  hFile, sizeof(ULONG)*Slot, NULL, FILE_BEGIN );
    WriteFile( hFile, &Val, sizeof(ULONG), &Count, NULL );

    CloseHandle( hFile );

    return 0;
}


ULONG
NvramRead(
    ULONG Slot
    )
{
    HANDLE hFile;
    ULONG Count;
    ULONG Val;


    hFile = OpenSaDevice( SA_DEVICE_NVRAM );
    if (hFile == INVALID_HANDLE_VALUE) {
        return -1;
    }

    SetFilePointer(  hFile, sizeof(ULONG)*Slot, NULL, FILE_BEGIN );
    ReadFile( hFile, &Val, sizeof(ULONG), &Count, NULL );

    CloseHandle( hFile );

    return Val;
}


BOOL
BootCounterRead(
    ULONG Slot,
    PULONG Val
    )
{
    HANDLE hFile;
    BOOL b;
    ULONG Bytes;
    SA_NVRAM_BOOT_COUNTER BootCounter;


    hFile = OpenSaDevice( SA_DEVICE_NVRAM );
    if (hFile == INVALID_HANDLE_VALUE) {
        return -1;
    }

    BootCounter.SizeOfStruct = sizeof(SA_NVRAM_BOOT_COUNTER);
    BootCounter.Number = Slot;
    BootCounter.Value = 0;

    b = DeviceIoControl(
        hFile,
        IOCTL_NVRAM_READ_BOOT_COUNTER,
        NULL,
        0,
        &BootCounter,
        sizeof(SA_NVRAM_BOOT_COUNTER),
        &Bytes,
        NULL
        );
    if (!b) {
        *Val = 0;
    } else {
        *Val = BootCounter.Value;
    }

    CloseHandle( hFile );

    return b;
}


BOOL
BootCounterWrite(
    ULONG Slot,
    ULONG Val
    )
{
    HANDLE hFile;
    BOOL b;
    ULONG Bytes;
    SA_NVRAM_BOOT_COUNTER BootCounter;


    hFile = OpenSaDevice( SA_DEVICE_NVRAM );
    if (hFile == INVALID_HANDLE_VALUE) {
        return -1;
    }

    BootCounter.SizeOfStruct = sizeof(SA_NVRAM_BOOT_COUNTER);
    BootCounter.Number = Slot;
    BootCounter.Value = Val;

    b = DeviceIoControl(
        hFile,
        IOCTL_NVRAM_WRITE_BOOT_COUNTER,
        &BootCounter,
        sizeof(SA_NVRAM_BOOT_COUNTER),
        NULL,
        0,
        &Bytes,
        NULL
        );

    CloseHandle( hFile );

    return b;
}


int
DoWatchdogTest(
    void
    )
{
    HANDLE hFileWd;
    HANDLE hFileNvram;
    ULONG Count;
    ULONG WatchdogState;
    ULONG i;

    hFileNvram = OpenSaDevice( SA_DEVICE_NVRAM );
    if (hFileNvram == INVALID_HANDLE_VALUE) {
        return -1;
    }

    ReadFile( hFileNvram, NvramData, sizeof(NvramData), &Count, NULL );

    for (i=0; i<32; i++) {
        wprintf( L"[%08x]\n", NvramData[i] );
    }

    NvramData[28] = 10;
    NvramData[29] = 10;
    NvramData[30] = 10;
    NvramData[31] = 10;

    WriteFile( hFileNvram, &NvramData, sizeof(NvramData), &Count, NULL );

    CloseHandle( hFileNvram );

    hFileWd = OpenSaDevice( SA_DEVICE_WATCHDOG );
    if (hFileWd == INVALID_HANDLE_VALUE) {
        return -1;
    }

    WatchdogState = 1;

    Count = DeviceIoControl(
        hFileWd,
        IOCTL_SAWD_DISABLE,
        &WatchdogState,
        sizeof(ULONG),
        &WatchdogState,
        sizeof(ULONG),
        &Count,
        NULL
        );

    CloseHandle( hFileWd );

    return 0;
}


int
DoWatchdogPingLoop(
    void
    )
{
    HANDLE hFile;
    ULONG Count;


    hFile = OpenSaDevice( SA_DEVICE_WATCHDOG );
    if (hFile == INVALID_HANDLE_VALUE) {
        return -1;
    }

    while (1) {
        DeviceIoControl(
            hFile,
            IOCTL_SAWD_PING,
            NULL,
            0,
            NULL,
            0,
            &Count,
            NULL
            );
        wprintf( L"ping...\n" );
        Sleep( 90 * 1000 );
    }

    CloseHandle( hFile );

    return 0;
}


int
InstallTestDriver(
    void
    )
{
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    WCHAR DriverBinaryPath[MAX_PATH];
    PWSTR s;



    if (GetModuleFileName( NULL, DriverBinaryPath, sizeof(DriverBinaryPath)/sizeof(WCHAR) ) == 0) {
        return GetLastError();
    }

    s = wcsrchr( DriverBinaryPath, L'\\' );
    if (s == NULL) {
        return -1;
    }

    s += 1;
    wcscpy( s, L"satest.sys" );

    ScmHandle = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (ScmHandle == NULL) {
        return GetLastError();
    }

    ServiceHandle = CreateService(
        ScmHandle,
        L"satest",
        L"satest",
        SERVICE_ALL_ACCESS,
        SERVICE_KERNEL_DRIVER,
        SERVICE_DEMAND_START,
        SERVICE_ERROR_NORMAL,
        DriverBinaryPath,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );
    if (ServiceHandle == NULL) {
        CloseServiceHandle( ScmHandle );
        return GetLastError();
    }

    if (!StartService( ServiceHandle, NULL, NULL )) {
        CloseServiceHandle( ServiceHandle );
        CloseServiceHandle( ScmHandle );
        return GetLastError();
    }

    CloseServiceHandle( ServiceHandle );
    CloseServiceHandle( ScmHandle );

    return 0;
}


int
UnInstallTestDriver(
    void
    )
{
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS Status;


    ScmHandle = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (ScmHandle == NULL) {
        return GetLastError();
    }

    ServiceHandle = OpenService(
        ScmHandle,
        L"satest",
        SERVICE_ALL_ACCESS
        );
    if (ServiceHandle == NULL) {
        CloseServiceHandle( ScmHandle );
        return GetLastError();
    }

    if (!ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &Status )) {
        CloseServiceHandle( ServiceHandle );
        CloseServiceHandle( ScmHandle );
        return GetLastError();
    }

    if (!DeleteService( ServiceHandle )) {
        CloseServiceHandle( ServiceHandle );
        CloseServiceHandle( ScmHandle );
        return GetLastError();
    }
    CloseServiceHandle( ServiceHandle );
    CloseServiceHandle( ScmHandle );

    return 0;
}


int
GetAcpiTable(
    void
    )
{
    HANDLE SatestDevice;
    BOOL b;
    ULONG Bytes;


    WdTable = (PVOID) malloc( 4096 );
    if (WdTable == NULL) {
        wprintf( L"could not allocate memory for ACPI table\n" );
        return -1;
    }

    SatestDevice = OpenSaTestDriver();
    if (SatestDevice == INVALID_HANDLE_VALUE) {
        wprintf( L"could not open satest driver, ec=[%d]\n", GetLastError() );
        return -1;
    }

    b = DeviceIoControl(
        SatestDevice,
        IOCTL_SATEST_GET_ACPI_TABLE,
        NULL,
        0,
        WdTable,
        4096,
        &Bytes,
        NULL
        );
    if (!b) {
        wprintf( L"could not get the WDRT ACPI table data, ec=[%d]", GetLastError() );
        CloseHandle( SatestDevice );
        return -1;
    }

    CloseHandle( SatestDevice );

    return 0;
}


int
QueryWdTimerInfo(
    WCHAR option
    )
{
    HANDLE SatestDevice;
    BOOL b;
    ULONG Bytes;
    SYSTEM_WATCHDOG_TIMER_INFORMATION WdTimerInfo;


    switch (option) {
        case L'x':
            WdTimerInfo.WdInfoClass = WdInfoTimeoutValue;
            break;

        case L't':
            WdTimerInfo.WdInfoClass = WdInfoTriggerAction;
            break;

        case L's':
            WdTimerInfo.WdInfoClass = WdInfoState;
            break;

        default:
            wprintf( L"missing option\n" );
            return -1;
    }

    SatestDevice = OpenSaTestDriver();
    if (SatestDevice == INVALID_HANDLE_VALUE) {
        wprintf( L"could not open satest driver, ec=[%d]\n", GetLastError() );
        return -1;
    }

    b = DeviceIoControl(
        SatestDevice,
        IOCTL_SATEST_QUERY_WATCHDOG_TIMER_INFORMATION,
        NULL,
        0,
        &WdTimerInfo,
        sizeof(WdTimerInfo),
        &Bytes,
        NULL
        );
    if (!b) {
        wprintf( L"could not query the WD timer info, ec=[%d]", GetLastError() );
        CloseHandle( SatestDevice );
        return -1;
    }

    switch (option) {
        case L'x':
            wprintf( L"Watchdog timeout value = [%x]\n", WdTimerInfo.DataValue );
            break;

        case L't':
            wprintf( L"Watchdog trigger action = [%x]\n", WdTimerInfo.DataValue );
            break;

        case L's':
            wprintf( L"Watchdog state = [%x]\n", WdTimerInfo.DataValue );
            break;
    }

    CloseHandle( SatestDevice );
    return 0;
}


int
SetWdTimerInfo(
    PWSTR option
    )
{
    HANDLE SatestDevice;
    BOOL b;
    ULONG Bytes;
    SYSTEM_WATCHDOG_TIMER_INFORMATION WdTimerInfo;


    switch (option[0]) {
        case L'x':
            if (option[1] != '=') {
                wprintf( L"missing timeout value\n" );
                return -1;
            }
            WdTimerInfo.WdInfoClass = WdInfoTimeoutValue;
            WdTimerInfo.DataValue = wcstoul( &option[2], NULL, 0 );
            break;

        case L't':
            if (option[1] != '=') {
                wprintf( L"missing trigger action value\n" );
                return -1;
            }
            WdTimerInfo.WdInfoClass = WdInfoTriggerAction;
            WdTimerInfo.DataValue = wcstoul( &option[2], NULL, 0 );
            break;

        case L'r':
            WdTimerInfo.WdInfoClass = WdInfoResetTimer;
            WdTimerInfo.DataValue = 0;
            break;

        case L'p':
            WdTimerInfo.WdInfoClass = WdInfoStopTimer;
            WdTimerInfo.DataValue = 0;
            break;

        case L's':
            WdTimerInfo.WdInfoClass = WdInfoStartTimer;
            WdTimerInfo.DataValue = 0;
            break;

        default:
            wprintf( L"missing option\n" );
            return -1;
    }

    SatestDevice = OpenSaTestDriver();
    if (SatestDevice == INVALID_HANDLE_VALUE) {
        wprintf( L"could not open satest driver, ec=[%d]\n", GetLastError() );
        return -1;
    }

    b = DeviceIoControl(
        SatestDevice,
        IOCTL_SATEST_SET_WATCHDOG_TIMER_INFORMATION,
        &WdTimerInfo,
        sizeof(WdTimerInfo),
        NULL,
        0,
        &Bytes,
        NULL
        );
    if (!b) {
        wprintf( L"could not set the WD timer info, ec=[%d]", GetLastError() );
        CloseHandle( SatestDevice );
        return -1;
    }

    CloseHandle( SatestDevice );
    return 0;
}


int
StopWatchdogPing(
    void
    )
{
    return SetWdTimerInfo( L"t=0xbadbadff" );
}


int Usage( void )
{
    wprintf( L"\nServer Availaibility Command Line Test Tool\n" );
    wprintf( L"Copyright Microsoft Corporation\n" );
    wprintf( L"\n" );
    wprintf( L"SATEST\n" );
    wprintf( L"\n" );
    wprintf( L"    c                                    - Clear the local display\n" );
    wprintf( L"    w <bitmap file name>                 - Display a bitmap on the local display\n" );
    wprintf( L"    n<r|w>:<slot number> [data value]    - Read or write to nvram data slot\n" );
    wprintf( L"    b<r|w>:<slot number> [data value]    - Read or write to boot counter\n" );
    wprintf( L"    k                                    - Keypad test\n" );
    wprintf( L"    a                                    - Dump ACPI table\n" );
    wprintf( L"    t                                    - Stop pinging watchdog hardware timer\n" );
    wprintf( L"    q:<x|t|s>                            - Query watchdog timer information\n" );
    wprintf( L"      x = Timeout value\n" );
    wprintf( L"      t = Trigger action\n" );
    wprintf( L"      s = State\n" );
    wprintf( L"    s:<x|t|s>=<value>                    - Set watchdog timer information\n" );
    wprintf( L"      x = Timeout value\n" );
    wprintf( L"      t = Trigger action\n" );
    wprintf( L"      r = Reset timer\n" );
    wprintf( L"      p = Stop timer\n" );
    wprintf( L"      s = Start timer\n" );
    return 0;
}


int _cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )
{
    if (argc == 1) {
        Usage();
        return -1;
    }

    switch (argv[1][0]) {
        case L'?':
            Usage();
            break;

        case L'c':
            if (argc == 3) {
                int val = wcstoul( argv[2], NULL, 0 );
                ClearDisplay( val );
            } else {
                ClearDisplay( 0 );
            }
            break;

        case L'w':
            DisplayBitmap( argv[2] );
            break;

        case L'n':
            {
                int slot = 0;
                ULONG val = 0;
                BOOL Read = TRUE;
                if (argv[1][1] == 'r') {
                    Read = TRUE;
                } else if (argv[1][1] == 'w') {
                    Read = FALSE;
                } else {
                    wprintf( L"test n[r|w]:<slot> <value>\n" );
                    return -1;
                }
                if (argv[1][2] != ':') {
                    wprintf( L"test n[r|w]:<slot> <value>\n" );
                    return -1;
                }
                slot = argv[1][3] - L'0';
                if (Read) {
                    val = NvramRead( slot );
                    wprintf( L"Slot #%x [%08x]\n", slot, val );
                } else {
                    val = wcstoul( argv[2], NULL, 0 );
                    NvramWrite( slot, val );
                }
            }
            break;

        case L'b':
            {
                int slot = 0;
                ULONG val = 0;
                BOOL Read = TRUE;
                if (argv[1][1] == 'r') {
                    Read = TRUE;
                } else if (argv[1][1] == 'w') {
                    Read = FALSE;
                } else {
                    wprintf( L"test b[r|w]:<slot> <value>\n" );
                    return -1;
                }
                if (argv[1][2] != ':') {
                    wprintf( L"test b[r|w]:<slot> <value>\n" );
                    return -1;
                }
                slot = argv[1][3] - L'0';
                if (Read) {
                    if (BootCounterRead( slot, &val )) {
                        wprintf( L"Boot counter #%x [%08x]\n", slot, val );
                    } else {
                        wprintf( L"Could not read boot counter #%d, ec=%d\n", slot, GetLastError() );
                    }
                } else {
                    val = wcstoul( argv[2], NULL, 0 );
                    if (!BootCounterWrite( slot, val )) {
                        wprintf( L"Could not write boot counter #%d, ec=%d\n", slot, GetLastError() );
                    }
                }
            }
            break;

        case L'k':
            DoKeypadTest();
            break;

        case L'd':
            DoWatchdogPingLoop();
            break;

        case L'a':
            if (InstallTestDriver() == ERROR_SUCCESS) {
                if (GetAcpiTable() == 0) {
                    PrintACPITable( WdTable );
                }
                UnInstallTestDriver();
            }
            break;

        case L'q':
            if (argv[1][1] != ':') {
                return -1;
            }
            if (InstallTestDriver() == ERROR_SUCCESS) {
                QueryWdTimerInfo( argv[1][2] );
                UnInstallTestDriver();
            }
            break;

        case L's':
            if (argv[1][1] != ':') {
                return -1;
            }
            if (InstallTestDriver() == ERROR_SUCCESS) {
                SetWdTimerInfo( &argv[1][2] );
                UnInstallTestDriver();
            }
            break;

        case L't':
            if (InstallTestDriver() == ERROR_SUCCESS) {
                StopWatchdogPing();
                UnInstallTestDriver();
            }
            break;

        default:
            Usage();
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\alertboottask\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\alertboottask\csaalertboottask.h ===
// CSAAlertBootTask.h: Definition of the SAAlertBootTask class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CSAALERTBOOTTASK_H__329DF228_9542_4C97_BFE6_6D60DB8273AB__INCLUDED_)
#define AFX_CSAALERTBOOTTASK_H__329DF228_9542_4C97_BFE6_6D60DB8273AB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include <appsrvcs.h>


/////////////////////////////////////////////////////////////////////////////
// SAAlertBootTask

class ATL_NO_VTABLE CSAAlertBootTask : 
    public IDispatchImpl<IApplianceTask, &IID_IApplianceTask, &LIBID_SAALERTBOOTTASKLib>, 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<SAAlertBootTask,&CLSID_SAAlertBootTask>
{
public:
    CSAAlertBootTask() {}
BEGIN_COM_MAP(CSAAlertBootTask)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IApplianceTask)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_SAAlertBootTask)

DECLARE_NOT_AGGREGATABLE(CSAAlertBootTask)

DECLARE_PROTECT_FINAL_CONSTRUCT()



public:
    //
    // IApplianceTask
    //
    STDMETHOD(OnTaskExecute)(
                     /*[in]*/ IUnknown* pTaskContext
                            );

    STDMETHOD(OnTaskComplete)(
                      /*[in]*/ IUnknown* pTaskContext, 
                      /*[in]*/ LONG      lTaskResult
                             );    
private:

    HRESULT ParseTaskParameter(
                              IUnknown *pTaskContext
                              );

    HRESULT RaisePersistentAlerts(
                              IApplianceServices *pAppSrvcs
                              );

};

#endif // !defined(AFX_CSAALERTBOOTTASK_H__329DF228_9542_4C97_BFE6_6D60DB8273AB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\test\driver\ioctl.h ===
#define DEVICE_NAME                         L"\\Device\\SaTest"
#define DOSDEVICE_NAME                      L"\\DosDevices\\SaTest"

#define IOCTL_SATEST_GET_ACPI_TABLE                    CTL_CODE((ULONG)'S',0x801,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_SATEST_QUERY_WATCHDOG_TIMER_INFORMATION  CTL_CODE((ULONG)'S',0x802,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_SATEST_SET_WATCHDOG_TIMER_INFORMATION    CTL_CODE((ULONG)'S',0x803,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_SATEST_RAISE_IRQL                        CTL_CODE((ULONG)'S',0x804,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\test\driver\acpi.cpp ===
extern "C" {
#include <ntosp.h>
#include <zwapi.h>
#include <ntacpi.h>
#include <acpitabl.h>
}


#define KEY_MULTIFUNCTION L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter"
#define VALUE_IDENTIFIER L"Identifier"
#define VALUE_CONFIGURATION_DATA L"Configuration Data"
#define ACPI_BIOS_ID L"ACPI BIOS"



BOOLEAN
PciOpenKey(
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    )

/*++

Description:

    Open a registry key.

Arguments:

    KeyName      Name of the key to be opened.
    ParentHandle Pointer to the parent handle (OPTIONAL)
    Handle       Pointer to a handle to recieve the opened key.

Return Value:

    TRUE is key successfully opened, FALSE otherwise.

--*/

{
    UNICODE_STRING    nameString;
    OBJECT_ATTRIBUTES nameAttributes;
    NTSTATUS localStatus;

    PAGED_CODE();

    RtlInitUnicodeString(&nameString, KeyName);

    InitializeObjectAttributes(&nameAttributes,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               ParentHandle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );
    localStatus = ZwOpenKey(Handle,
                            KEY_READ,
                            &nameAttributes
                            );

    if (Status != NULL) {

        //
        // Caller wants underlying status.
        //

        *Status = localStatus;
    }

    //
    // Return status converted to a boolean, TRUE if
    // successful.
    //

    return NT_SUCCESS(localStatus);
}

NTSTATUS
PciGetRegistryValue(
    IN  PWSTR   ValueName,
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PVOID   *Buffer,
    OUT ULONG   *Length
    )
{
    NTSTATUS status;
    HANDLE keyHandle;
    ULONG neededLength;
    ULONG actualLength;
    UNICODE_STRING unicodeValueName;
    PKEY_VALUE_PARTIAL_INFORMATION info;

    if (!PciOpenKey(KeyName, ParentHandle, &keyHandle, &status)) {
        return status;
    }

    unicodeValueName.Buffer = ValueName;
    unicodeValueName.MaximumLength = (wcslen(ValueName) + 1) * sizeof(WCHAR);
    unicodeValueName.Length = unicodeValueName.MaximumLength - sizeof(WCHAR);

    //
    // Find out how much memory we need for this.
    //

    status = ZwQueryValueKey(
                 keyHandle,
                 &unicodeValueName,
                 KeyValuePartialInformation,
                 NULL,
                 0,
                 &neededLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Get memory to return the data in.  Note this includes
        // a header that we really don't want.
        //

        info = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool( PagedPool, neededLength );
        if (info == NULL) {
            ZwClose(keyHandle);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Get the data.
        //

        status = ZwQueryValueKey(
                 keyHandle,
                 &unicodeValueName,
                 KeyValuePartialInformation,
                 info,
                 neededLength,
                 &actualLength
                 );
        if (!NT_SUCCESS(status)) {

            ExFreePool(info);
            ZwClose(keyHandle);
            return status;
        }

        //
        // Subtract out the header size and get memory for just
        // the data we want.
        //

        neededLength -= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);

        *Buffer = ExAllocatePool( PagedPool, neededLength );
        if (*Buffer == NULL) {
            ExFreePool(info);
            ZwClose(keyHandle);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Copy data sans header.
        //

        RtlCopyMemory(*Buffer, info->Data, neededLength);
        ExFreePool(info);

        if (Length) {
            *Length = neededLength;
        }

    } else {

        if (NT_SUCCESS(status)) {

            //
            // We don't want to report success when this happens.
            //

            status = STATUS_UNSUCCESSFUL;
        }
    }
    ZwClose(keyHandle);
    return status;
}





NTSTATUS
PciAcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    )
{
    PKEY_FULL_INFORMATION multiKeyInformation = NULL;
    PKEY_BASIC_INFORMATION keyInfo = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION identifierValueInfo = NULL;
    UNICODE_STRING unicodeString;
    HANDLE keyMultifunction = NULL, keyTable = NULL;
    PCM_PARTIAL_RESOURCE_LIST prl = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PACPI_BIOS_MULTI_NODE multiNode;
    ULONG multiNodeSize;
    ULONG i, length, maxKeyLength, identifierValueLen;
    BOOLEAN result;
    NTSTATUS status;

    //
    // Open the multifunction key
    //
    result = PciOpenKey(KEY_MULTIFUNCTION,
                        NULL,
                        &keyMultifunction,
                        &status);
    if (!result) {
        goto Cleanup;
    }

    //
    // Do allocation of buffers up front
    //

    //
    // Determine maximum size of a keyname under the multifunction key
    //
    status = ZwQueryKey(keyMultifunction,
                        KeyFullInformation,
                        NULL,
                        sizeof(multiKeyInformation),
                        &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        goto Cleanup;
    }
    multiKeyInformation = (PKEY_FULL_INFORMATION)ExAllocatePool( PagedPool, length );
    if (multiKeyInformation == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    status = ZwQueryKey(keyMultifunction,
                        KeyFullInformation,
                        multiKeyInformation,
                        length,
                        &length);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }
    // includes space for a terminating null that will be added later.
    maxKeyLength = multiKeyInformation->MaxNameLen +
        sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR);

    //
    // Allocate buffer used for storing subkeys that we are enumerated
    // under multifunction.
    //
    keyInfo = (PKEY_BASIC_INFORMATION)ExAllocatePool( PagedPool, maxKeyLength );
    if (keyInfo == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Allocate buffer large enough to store a value containing REG_SZ
    // 'ACPI BIOS'.  We hope to find such a value under one of the
    // multifunction subkeys
    //
    identifierValueLen = sizeof(ACPI_BIOS_ID) + sizeof(KEY_VALUE_PARTIAL_INFORMATION);
    identifierValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ExAllocatePool( PagedPool, identifierValueLen );
    if (identifierValueInfo == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Enumerate subkeys of multifunction key looking for keys with an
    // Identifier value of "ACPI BIOS".  If we find one, look for the
    // irq routing table in the tree below.
    //
    i = 0;
    do {
        status = ZwEnumerateKey(keyMultifunction,
                                i,
                                KeyBasicInformation,
                                keyInfo,
                                maxKeyLength,
                                &length);
        if (NT_SUCCESS(status)) {
            //
            // Found a key, now we need to open it and check the
            // 'Identifier' value to see if it is 'ACPI BIOS'
            //
            keyInfo->Name[keyInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
            result = PciOpenKey(keyInfo->Name,
                                keyMultifunction,
                                &keyTable,
                                &status);
            if (result) {
                //
                // Checking 'Identifier' value to see if it contains 'ACPI BIOS'
                //
                RtlInitUnicodeString(&unicodeString, VALUE_IDENTIFIER);
                status = ZwQueryValueKey(keyTable,
                                         &unicodeString,
                                         KeyValuePartialInformation,
                                         identifierValueInfo,
                                         identifierValueLen,
                                         &length);
                if (NT_SUCCESS(status) &&
                    RtlEqualMemory((PCHAR)identifierValueInfo->Data,
                                   ACPI_BIOS_ID,
                                   identifierValueInfo->DataLength))
                {
                    //
                    // This is the ACPI BIOS key.  Try to get Configuration Data
                    // This is the key we were looking
                    // for so regardless of success, break out.
                    //

                    ZwClose(keyTable);

                    status = PciGetRegistryValue(VALUE_CONFIGURATION_DATA,
                                                 keyInfo->Name,
                                                 keyMultifunction,
                                                 (PVOID*)&prl,
                                                 &length);

                    break;
                }
                ZwClose(keyTable);
            }
        } else {
            //
            // If not NT_SUCCESS, only alowable value is
            // STATUS_NO_MORE_ENTRIES,... otherwise, someone
            // is playing with the keys as we enumerate
            //
            break;
        }
        i++;
    }
    while (status != STATUS_NO_MORE_ENTRIES);

    if (NT_SUCCESS(status) && prl) {

        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)((PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST));

        multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) + ((ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY));

        *AcpiMulti = (PACPI_BIOS_MULTI_NODE) ExAllocatePool( NonPagedPool, multiNodeSize );
        if (*AcpiMulti == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(*AcpiMulti, multiNode, multiNodeSize);
    }

 Cleanup:
    if (identifierValueInfo != NULL) {
        ExFreePool(identifierValueInfo);
    }

    if (keyInfo != NULL) {
        ExFreePool(keyInfo);
    }

    if (multiKeyInformation != NULL) {
        ExFreePool(multiKeyInformation);
    }

    if (keyMultifunction != NULL) {
        ZwClose(keyMultifunction);
    }

    if (prl) {
        ExFreePool(prl);
    }

    return status;
}

PVOID
PciGetAcpiTable(
    void
  )
/*++

  Routine Description:

      This routine will retrieve any table referenced in the ACPI
      RSDT.

  Arguments:

      Signature - Target table signature

  Return Value:

      pointer to a copy of the table, or NULL if not found

--*/
{
  PACPI_BIOS_MULTI_NODE multiNode;
  NTSTATUS status;
  ULONG entry, rsdtEntries;
  PDESCRIPTION_HEADER header;
  PHYSICAL_ADDRESS physicalAddr;
  PRSDT rsdt;
  ULONG rsdtSize;
  PVOID table = NULL;
  ULONG Signature = WDTT_SIGNATURE;


  //
  // Get the physical address of the RSDT from the Registry
  //

  status = PciAcpiFindRsdt(&multiNode);

  if (!NT_SUCCESS(status)) {
    DbgPrint("AcpiFindRsdt() Failed!\n");
    return NULL;
  }


  //
  // Map down header to get total RSDT table size
  //

  header = (PDESCRIPTION_HEADER) MmMapIoSpace(multiNode->RsdtAddress, sizeof(DESCRIPTION_HEADER), MmCached);

  if (!header) {
    return NULL;
  }

  rsdtSize = header->Length;
  MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));


  //
  // Map down entire RSDT table
  //

  rsdt = (PRSDT) MmMapIoSpace(multiNode->RsdtAddress, rsdtSize, MmCached);

  ExFreePool(multiNode);

  if (!rsdt) {
    return NULL;
  }


  //
  // Do a sanity check on the RSDT.
  //

  if ((rsdt->Header.Signature != RSDT_SIGNATURE) &&
      (rsdt->Header.Signature != XSDT_SIGNATURE)) {

    DbgPrint("RSDT table contains invalid signature\n");
    goto GetAcpiTableEnd;
  }


  //
  // Calculate the number of entries in the RSDT.
  //

  rsdtEntries = rsdt->Header.Signature == XSDT_SIGNATURE ?
      NumTableEntriesFromXSDTPointer(rsdt) :
      NumTableEntriesFromRSDTPointer(rsdt);


  //
  // Look down the pointer in each entry to see if it points to
  // the table we are looking for.
  //

  for (entry = 0; entry < rsdtEntries; entry++) {

    if (rsdt->Header.Signature == XSDT_SIGNATURE) {
      physicalAddr = ((PXSDT)rsdt)->Tables[entry];
    } else {
      physicalAddr.HighPart = 0;
      physicalAddr.LowPart = (ULONG)rsdt->Tables[entry];
    }

    //
    // Map down the header, check the signature
    //

    header = (PDESCRIPTION_HEADER) MmMapIoSpace(physicalAddr, sizeof(DESCRIPTION_HEADER), MmCached);

    if (!header) {
      goto GetAcpiTableEnd;
    }

    if (header->Signature == Signature) {

      table = ExAllocatePool( PagedPool, header->Length );
      if (table) {
        RtlCopyMemory(table, header, header->Length);
      }

      MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));
      break;
    }

    MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));
  }


GetAcpiTableEnd:

  MmUnmapIoSpace(rsdt, rsdtSize);
  return table;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\drivers\test\driver\satest.cpp ===
extern "C" {
#include <ntosp.h>
#include <acpitabl.h>
#include <zwapi.h>
#include <stdio.h>
}
#include "ioctl.h"


PWATCHDOG_TIMER_RESOURCE_TABLE WdTable;

PVOID
PciGetAcpiTable(
    void
    );


NTSTATUS
CompleteRequest(
    PIRP Irp,
    NTSTATUS Status,
    ULONG_PTR Information
    )
{
    Irp->IoStatus.Information = Information;
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;
}


extern "C"
NTSTATUS
SaTestDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID OutputBuffer;
    ULONG OutputBufferLength;
    PSYSTEM_WATCHDOG_TIMER_INFORMATION WdTimerInfo;
    ULONG ReturnLength;
    KIRQL OldIrql;


    if (Irp->MdlAddress) {
        OutputBuffer = (PVOID) MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );
        if (OutputBuffer == NULL) {
            return CompleteRequest( Irp, STATUS_INSUFFICIENT_RESOURCES, 0 );
        }
        OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    } else {
        OutputBuffer = NULL;
        OutputBufferLength = 0;
    }

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_SATEST_GET_ACPI_TABLE:
            if (WdTable == NULL) {
                return CompleteRequest( Irp, STATUS_INVALID_PARAMETER, 0 );
            }
            if (OutputBufferLength < sizeof(WATCHDOG_TIMER_RESOURCE_TABLE)) {
                return CompleteRequest( Irp, STATUS_INVALID_PARAMETER, 0 );
            }
            RtlCopyMemory( OutputBuffer, WdTable, sizeof(WATCHDOG_TIMER_RESOURCE_TABLE) );
            return CompleteRequest( Irp, STATUS_SUCCESS, OutputBufferLength );

        case IOCTL_SATEST_QUERY_WATCHDOG_TIMER_INFORMATION:
            if (OutputBufferLength < sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION)) {
                return CompleteRequest( Irp, STATUS_INVALID_PARAMETER, 0 );
            }
            WdTimerInfo = (PSYSTEM_WATCHDOG_TIMER_INFORMATION)OutputBuffer;
            Status = ZwQuerySystemInformation(
                SystemWatchdogTimerInformation,
                WdTimerInfo,
                sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION),
                &ReturnLength
                );
            if (NT_SUCCESS(Status)) {
                return CompleteRequest( Irp, Status, sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION) );
            }
            return CompleteRequest( Irp, Status, 0 );

        case IOCTL_SATEST_SET_WATCHDOG_TIMER_INFORMATION:
            WdTimerInfo = (PSYSTEM_WATCHDOG_TIMER_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION)) {
                return CompleteRequest( Irp, STATUS_INVALID_PARAMETER, 0 );
            }
            Status = ZwSetSystemInformation(
                SystemWatchdogTimerInformation,
                WdTimerInfo,
                sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION)
                );
            if (NT_SUCCESS(Status)) {
                return CompleteRequest( Irp, Status, sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION) );
            }
            return CompleteRequest( Irp, Status, 0 );

        case IOCTL_SATEST_RAISE_IRQL:
            KeRaiseIrql( HIGH_LEVEL, &OldIrql );
            return CompleteRequest( Irp, Status, 0 );

        default:
            return CompleteRequest( Irp, STATUS_INVALID_PARAMETER, 0 );
    }

    return CompleteRequest( Irp, STATUS_SUCCESS, 0 );
}


extern "C"
VOID
SaTestUnload(
    IN PDRIVER_OBJECT  DriverObject
    )
{
    PDEVICE_OBJECT currentDevice = DriverObject->DeviceObject;
    UNICODE_STRING fullLinkName;

    while (currentDevice) {
        RtlInitUnicodeString( &fullLinkName, DOSDEVICE_NAME );
        IoDeleteSymbolicLink(&fullLinkName);
        IoDeleteDevice(currentDevice);
        currentDevice = DriverObject->DeviceObject;
    }
}


extern "C"
NTSTATUS
SaTestOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, 0 );

    return status;
}


extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;
    UNICODE_STRING DeviceName;
    PDEVICE_OBJECT deviceObject;
    UNICODE_STRING LinkObject;
    WCHAR LinkName[80];
    ULONG DeviceSize;


    RtlInitUnicodeString( &DeviceName, DEVICE_NAME );
    status = IoCreateDevice(
        DriverObject,
        0,
        &DeviceName,
        FILE_DEVICE_NULL,
        0,
        FALSE,
        &deviceObject
        );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    LinkName[0] = UNICODE_NULL;

    RtlInitUnicodeString( &LinkObject, LinkName );

    LinkObject.MaximumLength = sizeof(LinkName);

    RtlAppendUnicodeToString( &LinkObject, L"\\DosDevices" );

    DeviceSize = sizeof(L"\\Device") - sizeof(UNICODE_NULL);
    DeviceName.Buffer += DeviceSize / sizeof(WCHAR);
    DeviceName.Length -= (USHORT)DeviceSize;

    RtlAppendUnicodeStringToString( &LinkObject, &DeviceName );

    DeviceName.Buffer -= DeviceSize / sizeof(WCHAR);
    DeviceName.Length += (USHORT)DeviceSize;

    status = IoCreateSymbolicLink( &LinkObject, &DeviceName );

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice( deviceObject );
        return status;
    }

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SaTestDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SaTestOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SaTestOpenClose;
    DriverObject->DriverUnload = SaTestUnload;

    WdTable = (PWATCHDOG_TIMER_RESOURCE_TABLE) PciGetAcpiTable();

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\alertboottask\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SAAlertBootTask.rc
//
#define IDS_PROJNAME                    100
#define IDS_SAALERTBOOTTASK_DESC        101
#define IDR_SAAlertBootTask             102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\alertboottask\csaalertboottask.cpp ===
// CSAAlertBootTask.cpp : Implementation of CSAAlertBootTaskApp and DLL registration.

#include "stdafx.h"
#include "SAAlertBootTask.h"
#include "CSAAlertBootTask.h"

#include <appliancetask.h>
#include <taskctx.h>
#include <propertybagfactory.h>

const WCHAR SZ_ALERTID_VALUE[]      = L"AlertID";
const WCHAR SZ_ALERTLOG_VALUE[]     = L"AlertLog";
const WCHAR SZ_ALERTTTL_VALUE[]     = L"TimeToLive";
const WCHAR SZ_ALERTTYPE_VALUE[]    = L"AlertType";
const WCHAR SZ_ALERTFLAG_VALUE[]    = L"AlertFlags";
const WCHAR SZ_ALERTSOURCE_VALUE[]  = L"AlertSource";
const WCHAR SZ_ALERTSTRINGS_VALUE[] = L"ReplacementStrings";

const WCHAR SZ_METHOD_NAME[] = L"MethodName";

const WCHAR SZ_APPLIANCE_EVERYBOOT_TASK []=L"EveryBootTask";

const WCHAR SZ_SAALERT_KEY_NAME [] =
           L"SOFTWARE\\Microsoft\\ServerAppliance\\ApplianceManager\\ObjectManagers\\Microsoft_SA_Alert";

//////////////////////////////////////////////////////////////////////////////
//
// Function:  CSelfSignCert::OnTaskComplete
//
// Synopsis:  
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   HRESULT
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CSAAlertBootTask::OnTaskComplete(
    IUnknown *pTaskContext, 
    LONG lTaskResult
    )
{
    SATracePrintf( "OnTaskComplete" );
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::OnTaskExecute
//
// Synopsis:  This function is the entry point for AppMgr.
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   Always returns S_OK
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CSAAlertBootTask::OnTaskExecute(
    IUnknown *pTaskContext
    )
{
    HRESULT hr;
    LPWSTR  pstrApplianceName = NULL;
    WCHAR   pstrSubjectName[MAX_COMPUTERNAME_LENGTH + 3];
    DWORD   dwReturn;

    PPROPERTYBAGCONTAINER pObjSubMgrs;

    SATraceString( "Entering OnTaskExecute" );

    try
    {
        do
        {
            hr = ParseTaskParameter( pTaskContext ); 
            if( FAILED( hr ) )
            {
                SATracePrintf("ParseTaskParameter failed: %x", hr);
                break;
            }

            CComPtr<IApplianceServices>    pAppSrvcs;
            hr = CoCreateInstance(CLSID_ApplianceServices,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IApplianceServices,
                                    (void**)&pAppSrvcs);
            if (FAILED(hr))
            {
                break;
            }

            hr = pAppSrvcs->Initialize(); 
            if (FAILED(hr))
            {
                SATracePrintf("pAppSrvcs->Initialize() failed: %x", hr);
                break;
            }
            
            hr = RaisePersistentAlerts( pAppSrvcs );
            if ( FAILED(hr))
               {
                SATracePrintf("RaisePersistentAlerts failed: %x", hr);
               }
            else
                {
                SATraceString("RaisePersistentAlerts succeeded");
                }
        }
        while( FALSE );
    }
    catch(...)
    {
        SATracePrintf( "OnTaskExecute unexpected exception" );
    }

    return S_OK;
}

HRESULT 
CSAAlertBootTask::ParseTaskParameter(
    IUnknown *pTaskContext
    )
{
    CComVariant varValue;
     CComPtr<ITaskContext> pTaskParameter;
    CComVariant varLangID;

    SATracePrintf( "Entering ParseTaskParameter" );

    HRESULT hrRet = E_INVALIDARG;

    try
    {
        do
        {
            if(NULL == pTaskContext)
            {
                SATracePrintf( "ParseTaskParameter error para" );
                break;
            }
            
            hrRet = pTaskContext->QueryInterface(IID_ITaskContext,
                                              (void **)&pTaskParameter);
            if(FAILED(hrRet))
            {
                SATracePrintf( "ParseTaskParameter QueryInterface" );
                break;
            }

            hrRet = pTaskParameter->GetParameter(
                                            CComBSTR(SZ_METHOD_NAME),
                                            &varValue
                                            );
            if ( FAILED( hrRet ) )
            {
                SATracePrintf( "ParseTaskParameter GetParameter" );
                break;
            }

            if ( V_VT( &varValue ) != VT_BSTR )
            {
                SATracePrintf( "ParseTaskParameter error type" );
                break;
            }

            if ( lstrcmp( V_BSTR(&varValue), SZ_APPLIANCE_EVERYBOOT_TASK ) == 0 )
            {
                hrRet=S_OK;
            }
        }
        while(false);
    }
    catch(...)
    {
        SATracePrintf( "ParseTaskParameter exception" );
        hrRet=E_FAIL;
    }

    return hrRet;
}


HRESULT 
CSAAlertBootTask::RaisePersistentAlerts(
    IApplianceServices *pAppSrvcs
    )
{
    HRESULT hr =     E_FAIL;

    SATracePrintf( "Entering RaisePersistentAlerts" );
    
    
    CLocationInfo LocSubInfo ( HKEY_LOCAL_MACHINE, SZ_SAALERT_KEY_NAME );

    SATracePrintf( "Making Property Bag Container for HKLM %ws", SZ_SAALERT_KEY_NAME );
        
    
    PPROPERTYBAGCONTAINER     pObjSubMgrs =  ::MakePropertyBagContainer(
                                                    PROPERTY_BAG_REGISTRY,
                                                    LocSubInfo
                                                    );
    if ( !pObjSubMgrs.IsValid() )
       {
           SATraceString( "pObjSubMgrs.IsValid failed, REG key probably missing." );
        return hr;
       }

    if ( !pObjSubMgrs->open() )
       {
           SATraceString( "pObjSubMgrs->open failed" );
        return hr;
       }

    pObjSubMgrs->reset();

       CComVariant vtRawData;
    LONG        lAlertCookie;


    SATracePrintf( "Fetching persistent Alerts from Registry" );
       do
    {
        
           PPROPERTYBAG pSubBag = pObjSubMgrs->current();
        if (!pSubBag.IsValid())  
        {
            // Empty set, no alerts found
            SATracePrintf( "No Alerts found" );
            hr = S_OK;
            break;
        }

        SATracePrintf( "Found Alert" );
        
        if (!pSubBag->open() ) 
        {
               SATraceString( "pSubBag->open failed" );
            break;
        }

           pSubBag->reset ();

           CComVariant vtAlertID;
        if ( !pSubBag->get( SZ_ALERTID_VALUE, &vtAlertID ) ) 
        {
            SATraceString( "Get alert ID error" );
            pObjSubMgrs->next ();
            continue;
        }

        CComVariant vtAlertLog;
        if (!pSubBag->get ( SZ_ALERTLOG_VALUE, &vtAlertLog)) 
        {
            SATraceString( "Get alert Log error" );
            pObjSubMgrs->next ();
            continue;
        }

        CComVariant vtAlertType;
        if (!pSubBag->get ( SZ_ALERTTYPE_VALUE, &vtAlertType)) 
        {
            SATraceString( "Get alert type error" );
            pObjSubMgrs->next ();
            continue;
        }

        CComVariant vtAlertFlags;
        if (!pSubBag->get ( SZ_ALERTFLAG_VALUE, &vtAlertFlags)) 
        {
            SATraceString( "Get alert flages error" );
            vtAlertFlags = SA_ALERT_FLAG_PERSISTENT;
        }

        CComVariant vtAlertTTL;
        if (!pSubBag->get ( SZ_ALERTTTL_VALUE, &vtAlertTTL)) 
        {
            SATraceString( "Get alert TTL error" );
            vtAlertTTL = SA_ALERT_DURATION_ETERNAL;
        }

        CComVariant vtAlertSource;
        if (!pSubBag->get ( SZ_ALERTSOURCE_VALUE, &vtAlertSource)) 
        {
            SATraceString( "Get alert Source error" );
        }

        CComVariant vtAlertStrings;
        if (!pSubBag->get ( SZ_ALERTSTRINGS_VALUE, &vtAlertStrings)) 
        {
            SATraceString( "Get alert strings error" );
        }


        SATracePrintf("AlertType %d",V_I4( &vtAlertType ));
        SATracePrintf("AlertID %d",V_I4( &vtAlertID ));
        SATracePrintf("AlertLog %ws",V_BSTR( &vtAlertLog ));
        SATracePrintf("AlertSource %ws",V_BSTR( &vtAlertSource ));

        hr = pAppSrvcs->RaiseAlertEx (
                                    V_I4( &vtAlertType ), 
                                    V_I4( &vtAlertID ),
                                    V_BSTR( &vtAlertLog ), 
                                    V_BSTR( &vtAlertSource ), 
                                    V_I4( &vtAlertTTL ),
                                    &vtAlertStrings,    
                                    &vtRawData,      
                                    V_I4( &vtAlertFlags ),
                                    &lAlertCookie
                                    );
        if( FAILED( hr ) )
        {
               SATracePrintf("RaiseAlertEx failed: %x", hr);
            break;
        }
    }
       while (pObjSubMgrs->next ());
        
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\alertboottask\saalertboottask.cpp ===
// SAAlertBootTask.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SAAlertBootTaskps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SAAlertBootTask.h"
#include "CSAAlertBootTask.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAAlertBootTask, CSAAlertBootTask)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\alertboottask\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F90CE523_D504_416D_947B_E785DE454155__INCLUDED_)
#define AFX_STDAFX_H__F90CE523_D504_416D_947B_E785DE454155__INCLUDED_

#pragma once

#define _ATL_APARTMENT_THREADED
#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <satrace.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F90CE523_D504_416D_947B_E785DE454155__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\appliancemanager.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      appliancemanager.h
//
// Project:     Chameleon
//
// Description: Appliance Manager Class Defintion
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 12/03/98     TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_APPLIANCE_MANAGER_H_
#define __INC_APPLIANCE_MANAGER_H_

#include "resource.h"       
#include "appmgr.h"            
#include "appmgrutils.h"
#include <satrace.h>
#include <basedefs.h>
#include <atlhlpr.h>
#include <appmgrobjs.h>
#include <propertybagfactory.h>
#include <componentfactory.h>
#include <comdef.h>
#include <comutil.h>
#include <wbemcli.h>        
#include <wbemprov.h>        

#pragma warning( disable : 4786 )
#include <map>
#include <string>
using namespace std;

#define    SA_DEFAULT_BUILD    L"0.0.0000.0"
#define SA_DEFAULT_PID      L"00000000000000000000"

class CApplianceManager;    // Forward declaraion

////////////////////////////////////////////////////////////////////////////
// CAppObjMgrStatus
class ATL_NO_VTABLE CAppObjMgrStatus : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IApplianceObjectManagerStatus, &IID_IApplianceObjectManagerStatus, &LIBID_APPMGRLib>
{

public:

    CAppObjMgrStatus() { m_dwRef++; }
    virtual ~CAppObjMgrStatus() { }

// ATL Interface Map
BEGIN_COM_MAP(CAppObjMgrStatus)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IApplianceObjectManagerStatus)
END_COM_MAP()

    /////////////////////////////////////////
    // IApplianceObjectManager Status Methods
    
    //////////////////////////////////////////////////////////////////////////////
    STDMETHOD(SetManagerStatus)(
                         /*[in]*/ APPLIANCE_OBJECT_MANAGER_STATUS eStatus
                               );

private:

friend class CApplianceManager;

    CAppObjMgrStatus(const CAppObjMgrStatus& rhs);
    CAppObjMgrStatus& operator = (CAppObjMgrStatus& rhs);

    void InternalInitialize(
                    /*[in]*/ CApplianceManager* pAppMgr
                           );

    CApplianceManager*   m_pAppMgr;

}; // End of class cSdoSchemaClass

typedef CComObjectNoLock<CAppObjMgrStatus>    APP_MGR_OBJ_STATUS;


/////////////////////////////////////////////////////////////////////////////
// CApplianceManager

class ATL_NO_VTABLE CApplianceManager : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CApplianceManager, &CLSID_ApplianceManager>,
    public IDispatchImpl<IApplianceObjectManager, &IID_IApplianceObjectManager, &LIBID_APPMGRLib>,
    public IWbemEventProvider
{
    //////////////////////////////////////////////////////////////////////////
    // CProviderInit - Nested class implements IWbemProviderInit
    //////////////////////////////////////////////////////////////////////////

    class CProviderInit : public IWbemProviderInit
    {
        // Outer unknown
        CApplianceManager*      m_pAppMgr;

    public:

        CProviderInit(CApplianceManager *pAppMgr)
            : m_pAppMgr(pAppMgr) { }
        
        ~CProviderInit() { }

        // IUnknown methods - delegate to outer IUnknown
        //
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv)
        { return (dynamic_cast<IApplianceObjectManager*>(m_pAppMgr))->QueryInterface(riid, ppv); }

        STDMETHOD_(ULONG,AddRef)(void)
        { return (dynamic_cast<IApplianceObjectManager*>(m_pAppMgr))->AddRef(); }

        STDMETHOD_(ULONG,Release)(void)
        { 
            return (dynamic_cast<IApplianceObjectManager*>(m_pAppMgr))->Release(); 
        }

        //////////////////////////////////////////////////////////////////////
        // IWbemProviderInit methods
        //////////////////////////////////////////////////////////////////////
    
        STDMETHOD(Initialize)(
        /*[in, unique, string]*/ LPWSTR                 wszUser,
                        /*[in]*/ LONG                   lFlags,
                /*[in, string]*/ LPWSTR                 wszNamespace,
        /*[in, unique, string]*/ LPWSTR                 wszLocale,
                        /*[in]*/ IWbemServices*         pNamespace,
                        /*[in]*/ IWbemContext*          pCtx,
                        /*[in]*/ IWbemProviderInitSink* pInitSink    
                             );
    };


    class CProviderServices : public IWbemServices
    {
        // Outer unknown
        CApplianceManager*      m_pAppMgr;

    public:

        CProviderServices(CApplianceManager *pAppMgr)
            : m_pAppMgr(pAppMgr) { }
        
        ~CProviderServices() { }

        //////////////////////////////////////////////////////////////////////////
        // IWbemServices
        //////////////////////////////////////////////////////////////////////////

        STDMETHOD(QueryInterface)(REFIID riid, void **ppv)
        { return (dynamic_cast<IApplianceObjectManager*>(m_pAppMgr))->QueryInterface(riid, ppv); }

        STDMETHOD_(ULONG,AddRef)(void)
        { return (dynamic_cast<IApplianceObjectManager*>(m_pAppMgr))->AddRef(); }

        STDMETHOD_(ULONG,Release)(void)
        { 
            Shutdown();
            return (dynamic_cast<IApplianceObjectManager*>(m_pAppMgr))->Release(); 
        }

        STDMETHOD(OpenNamespace)(
            /*[in]*/             const BSTR        strNamespace,
            /*[in]*/             long              lFlags,
            /*[in]*/             IWbemContext*     pCtx,
            /*[out, OPTIONAL]*/  IWbemServices**   ppWorkingNamespace,
            /*[out, OPTIONAL]*/  IWbemCallResult** ppResult
                               );

        STDMETHOD(CancelAsyncCall)(
                          /*[in]*/ IWbemObjectSink* pSink
                                  );

        STDMETHOD(QueryObjectSink)(
                           /*[in]*/    long              lFlags,
                          /*[out]*/ IWbemObjectSink** ppResponseHandler
                                  );

        STDMETHOD(GetObject)(
                    /*[in]*/    const BSTR         strObjectPath,
                    /*[in]*/    long               lFlags,
                    /*[in]*/    IWbemContext*      pCtx,
            /*[out, OPTIONAL]*/ IWbemClassObject** ppObject,
            /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                            );

        STDMETHOD(GetObjectAsync)(
                         /*[in]*/  const BSTR       strObjectPath,
                         /*[in]*/  long             lFlags,
                         /*[in]*/  IWbemContext*    pCtx,        
                         /*[in]*/  IWbemObjectSink* pResponseHandler
                                 );

        STDMETHOD(PutClass)(
                   /*[in]*/     IWbemClassObject* pObject,
                   /*[in]*/     long              lFlags,
                   /*[in]*/     IWbemContext*     pCtx,        
            /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                           );

        STDMETHOD(PutClassAsync)(
                        /*[in]*/ IWbemClassObject* pObject,
                        /*[in]*/ long              lFlags,
                        /*[in]*/ IWbemContext*     pCtx,        
                        /*[in]*/ IWbemObjectSink*  pResponseHandler
                               );

        STDMETHOD(DeleteClass)(
            /*[in]*/            const BSTR        strClass,
            /*[in]*/            long              lFlags,
            /*[in]*/            IWbemContext*     pCtx,        
            /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                              );

        STDMETHOD(DeleteClassAsync)(
                           /*[in]*/ const BSTR       strClass,
                           /*[in]*/ long             lFlags,
                           /*[in]*/ IWbemContext*    pCtx,        
                           /*[in]*/ IWbemObjectSink* pResponseHandler
                                   );

        STDMETHOD(CreateClassEnum)(
                          /*[in]*/ const BSTR             strSuperclass,
                          /*[in]*/ long                   lFlags,
                          /*[in]*/ IWbemContext*          pCtx,        
                         /*[out]*/ IEnumWbemClassObject** ppEnum
                                 );

        STDMETHOD(CreateClassEnumAsync)(
                               /*[in]*/  const BSTR       strSuperclass,
                               /*[in]*/  long             lFlags,
                               /*[in]*/  IWbemContext*    pCtx,        
                               /*[in]*/  IWbemObjectSink* pResponseHandler
                                      );

        // Instance Provider Services

        STDMETHOD(PutInstance)(
            /*[in]*/            IWbemClassObject* pInst,
            /*[in]*/            long              lFlags,
            /*[in]*/            IWbemContext*     pCtx,        
            /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                              );

        STDMETHOD(PutInstanceAsync)(
                           /*[in]*/ IWbemClassObject* pInst,
                           /*[in]*/ long              lFlags,
                           /*[in]*/ IWbemContext*     pCtx,        
                           /*[in]*/ IWbemObjectSink*  pResponseHandler
                                  );

        STDMETHOD(DeleteInstance)(
            /*[in]*/              const BSTR        strObjectPath,
            /*[in]*/              long              lFlags,
            /*[in]*/              IWbemContext*     pCtx,        
            /*[out, OPTIONAL]*/   IWbemCallResult** ppCallResult        
                                );

        STDMETHOD(DeleteInstanceAsync)(
                              /*[in]*/ const BSTR       strObjectPath,
                              /*[in]*/ long             lFlags,
                              /*[in]*/ IWbemContext*    pCtx,        
                              /*[in]*/ IWbemObjectSink* pResponseHandler
                                     );

        STDMETHOD(CreateInstanceEnum)(
                             /*[in]*/ const BSTR             strClass,
                             /*[in]*/ long                   lFlags,
                             /*[in]*/ IWbemContext*          pCtx,        
                            /*[out]*/ IEnumWbemClassObject** ppEnum
                                    );

        STDMETHOD(CreateInstanceEnumAsync)(
                                  /*[in]*/ const BSTR       strClass,
                                  /*[in]*/ long             lFlags,
                                  /*[in]*/ IWbemContext*    pCtx,        
                                  /*[in]*/ IWbemObjectSink* pResponseHandler
                                         );

        STDMETHOD(ExecQuery)(
                     /*[in]*/ const BSTR             strQueryLanguage,
                     /*[in]*/ const BSTR             strQuery,
                     /*[in]*/ long                   lFlags,
                     /*[in]*/ IWbemContext*          pCtx,        
                    /*[out]*/ IEnumWbemClassObject** ppEnum
                            );

        STDMETHOD(ExecQueryAsync)(
                         /*[in]*/ const BSTR       strQueryLanguage,
                         /*[in]*/ const BSTR       strQuery,
                         /*[in]*/ long             lFlags,
                         /*[in]*/ IWbemContext*    pCtx,        
                         /*[in]*/ IWbemObjectSink* pResponseHandler
                                );


        STDMETHOD(ExecNotificationQuery)(
                                /*[in]*/ const BSTR             strQueryLanguage,
                                /*[in]*/ const BSTR             strQuery,
                                /*[in]*/ long                   lFlags,
                                /*[in]*/ IWbemContext*          pCtx,        
                               /*[out]*/ IEnumWbemClassObject** ppEnum
                                        );

        STDMETHOD(ExecNotificationQueryAsync)(
                                     /*[in]*/ const BSTR       strQueryLanguage,
                                     /*[in]*/ const BSTR       strQuery,
                                     /*[in]*/ long             lFlags,
                                     /*[in]*/ IWbemContext*    pCtx,        
                                     /*[in]*/ IWbemObjectSink* pResponseHandler
                                            );


        STDMETHOD(ExecMethod)(
            /*[in]*/            const BSTR         strObjectPath,
            /*[in]*/            const BSTR         strMethodName,
            /*[in]*/            long               lFlags,
            /*[in]*/            IWbemContext*      pCtx,        
            /*[in]*/            IWbemClassObject*  pInParams,
            /*[out, OPTIONAL]*/ IWbemClassObject** ppOutParams,
            /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                             );

        STDMETHOD(ExecMethodAsync)(
                          /*[in]*/ const BSTR        strObjectPath,
                          /*[in]*/ const BSTR        strMethodName,
                          /*[in]*/ long              lFlags,
                          /*[in]*/ IWbemContext*     pCtx,        
                          /*[in]*/ IWbemClassObject* pInParams,
                          /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                  );
    private:

        // Called to reset the server appliance (orderly shutdown)
        HRESULT ResetAppliance(
                       /*[in]*/ IWbemContext*        pCtx,
                       /*[in]*/ IWbemClassObject*    pInParams,
                       /*[in]*/ IWbemObjectSink*    pResponseHandler
                              );

        // Called when WMI releases us (primary provider interface)
        void Shutdown(void);
    };

public:
    
DECLARE_CLASSFACTORY_SINGLETON(CApplianceManager)

DECLARE_REGISTRY_RESOURCEID(IDR_APPLIANCEMANAGER)

DECLARE_NOT_AGGREGATABLE(CApplianceManager)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CApplianceManager)
    COM_INTERFACE_ENTRY(IWbemEventProvider)
    COM_INTERFACE_ENTRY(IApplianceObjectManager)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_FUNC(IID_IWbemServices, 0, &CApplianceManager::QueryInterfaceRaw)
    COM_INTERFACE_ENTRY_FUNC(IID_IWbemProviderInit, 0, &CApplianceManager::QueryInterfaceRaw)
END_COM_MAP()

    CApplianceManager();

    ~CApplianceManager();

    //////////////////////////////////////////////////////////////////////////
    // IWbemEventProvider
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD(ProvideEvents)(
                     /*[in]*/ IWbemObjectSink *pSink,
                     /*[in]*/ LONG lFlags
                            );

    //////////////////////////////////////////////////////////////////////////
    // IServiceControl Interface
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD(InitializeManager)(
                         /*[in]*/ IApplianceObjectManagerStatus* pObjMgrStatus
                                );

    STDMETHOD(ShutdownManager)(void);

private:

friend class CProviderInit;
friend class CProviderServices;
friend class CAppObjMgrStatus;

    typedef enum _AMSTATE 
    { 
        AM_STATE_SHUTDOWN, 
        AM_STATE_INITIALIZED, 

    } AMSTATE;

    // Called to retrieve appliance software version
    void GetVersionInfo(void);

    // Determine an object manager given a WBEM object path
    IWbemServices* GetObjectMgr(
                        /*[in]*/ BSTR bstrObjPath
                               );

    // Service Object Manager status change notification
    void SetServiceObjectManagerStatus(
                               /*[in]*/ APPLIANCE_OBJECT_MANAGER_STATUS eStatus
                                      );

    // Called when someone queries for any of the object's "Raw" interfaces.
    static HRESULT WINAPI QueryInterfaceRaw(
                                             void*     pThis,
                                             REFIID    riid,
                                             LPVOID*   ppv,
                                             DWORD_PTR dw
                                            );

    typedef enum 
    { 
        SHUTDOWN_WMI_SYNC_WAIT           = 1000, 
        SHUTDOWN_WMI_SYNC_MAX_WAIT       = 10 * SHUTDOWN_WMI_SYNC_WAIT,
    };

    // Provider (Object Manager) Map
    typedef map< wstring, CComPtr<IWbemServices> > ProviderMap;
    typedef ProviderMap::iterator                   ProviderMapIterator;

    // The Provider Init class (implements IWbemProviderInit)
    CProviderInit        m_clsProviderInit;

    // The Provider Services class (implements IWbemServices)
    CProviderServices   m_clsProviderServices;

    // True when we've been initialized by WMI
    bool                m_bWMIInitialized;    

    // Number of WMI requests active inside the appmgr
    DWORD                m_dwEnteredCount;

    // True when we've initialized ourselves
    AMSTATE                m_eState;

    // Map of object managers
    ProviderMap            m_ObjMgrs;

    // Current build number
    wstring                m_szCurrentBuild;

    // Product ID
    wstring                m_szPID;

    // Service Object Manager Status
    APP_MGR_OBJ_STATUS    m_ServiceObjMgrStatus;
};

//
// class used to indicate the IApplianceManager interface is called by SCM
//
class CSCMIndicator 
{
public:
    CSCMIndicator ()
        :m_bSet (false)
    {
        InitializeCriticalSection (&m_CritSect);
    }

    ~CSCMIndicator ()
    {
        DeleteCriticalSection (&m_CritSect);
    }

    void Set ()
    {
        EnterCriticalSection (&m_CritSect);
        m_bSet = true;
        LeaveCriticalSection (&m_CritSect);
    }

    bool CheckAndReset ()
    {
        bool bRetVal = false;
        EnterCriticalSection (&m_CritSect);
        if (m_bSet)
        {
                m_bSet = false;
                 bRetVal = true;
        }
        LeaveCriticalSection (&m_CritSect);
        return (bRetVal);
    }
            
    
private:
    bool m_bSet;
    CRITICAL_SECTION m_CritSect;
};

#endif //__INC_APPLIANCE_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\appmgrutils.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      appmgrtils.cpp
//
// Project:     Chameleon
//
// Description: Appliance Manager Utility Functions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "appmgrutils.h"

//////////////////////////////////////////////////////////////////////////
// Global Helper Functions
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetObjectClass()
//
// Synopsis:    Return the class name part of a WBEM object path
//
// pszObjectPath will look something like this if its a full path:
// 
// \\Server\Namespace:ClassName.KeyName="KeyValue"
//
// or...
//
// \\Server\Namespace:ClassName="KeyValue"
//
// If its a relative path then just the part after the ':' will
// be present and pszObject will look something like:
//
// ClassName.KeyName="KeyValue"
// or...
// ClassName.KeyName="KeyValue"
//
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
BSTR GetObjectClass(
            /*[in]*/ LPWSTR  pszObjectPath
                   )
{
    _ASSERT( pszObjectPath && (MAX_PATH >= (DWORD)lstrlen(pszObjectPath)) );
    if ( pszObjectPath && (MAX_PATH >= (DWORD)lstrlen(pszObjectPath)) )
    {
        // Get a copy of the object path (we'll manipulate the copy)
        wchar_t szBuffer[MAX_PATH + 1];
        lstrcpy(szBuffer, pszObjectPath);

        // Find the start of the class name (may be relative path)
        wchar_t* p = wcschr( szBuffer, ':');
        if ( ! p )
        {
            p = szBuffer;
        }
        else
        {
            p++;
        }

        // Terminate at the end of the class name
        wchar_t* q = wcschr(p, '.');
        if ( q )
        {
            *q = '\0';
        }
        else
        {
            q = wcschr(p, '=');
            if ( q )
            {
                *q = '\0';
            }
        }
        return SysAllocString(p);
    }
    return NULL;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    GetObjectKey()
//
// Synopsis:    Return the instance name part of a WBEM object path
//
// pszObjectPath will look something like this if its a full path:
// 
// \\Server\Namespace:ClassName.KeyName="KeyValue"
//
// or...
//
// \\Server\Namespace:ClassName="KeyValue"
//
// If its a relative path then just the part after the ':' will
// be present and pszObject will look something like:
//
// ClassName.KeyName="KeyValue"
// or...
// ClassName.KeyName=KeyValue
//
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
BSTR GetObjectKey(
          /*[in]*/ LPWSTR  pszObjectPath
                 )
{
    _ASSERT( pszObjectPath && (MAX_PATH >= (DWORD)lstrlen(pszObjectPath)) );
    if ( pszObjectPath && (MAX_PATH >= (DWORD)lstrlen(pszObjectPath)) )
    {
        // Use everything to the right of '=' as the key
        // (and strip off the quotes if the key is a string)

        // Locate the '=' character starting from the end
        wchar_t *p = pszObjectPath;
        p += lstrlen(pszObjectPath) - 1;
        while ( *p != '=' && p > pszObjectPath)
        { p--; }
        if ( *p == '=' )
        {
            // Move to the char after the '='
            p++;
            // Are we dealing with a stringized key?
            if ( *p == '"' )
            { 
                // Yes... don't include the quotes
                p++;
                wchar_t szKey[MAX_PATH + 1];
                lstrcpy(szKey, p);
                p = szKey;
                while ( *p != '"' && *p != '\0' )
                { p++; }
                if ( *p == '"' )
                {
                    *p = '\0';
                    return SysAllocString(szKey);
                }
            }
            else
            {
                return SysAllocString(p);
            }
        }
    }
    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
static IWbemServices* g_pNameSpace;

//////////////////////////////////////////////////////////////////////////
//
// Function:    SetNameSpace()
//
// Synopsis:    Set the name space pointer into Windows Managment
//
//////////////////////////////////////////////////////////////////////////////
void SetNameSpace(IWbemServices* pNameSpace)
{
    if ( g_pNameSpace )
    { g_pNameSpace->Release(); }
    g_pNameSpace = pNameSpace;
    if ( pNameSpace )
    { g_pNameSpace->AddRef(); }
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetNameSpace()
//
// Synopsis:    Get the name space pointer into Windows Management
//
//////////////////////////////////////////////////////////////////////////////
IWbemServices* GetNameSpace(void)
{
    _ASSERT( NULL != (IWbemServices*) g_pNameSpace );
    return g_pNameSpace;
}


//////////////////////////////////////////////////////////////////////////////
static IWbemObjectSink* g_pEventSink;

//////////////////////////////////////////////////////////////////////////
//
// Function:    SetEventSink()
//
// Synopsis:    Set the event sink pointer into Windows Management
//
//////////////////////////////////////////////////////////////////////////////
void SetEventSink(IWbemObjectSink* pEventSink)
{
    if ( g_pEventSink )
    { g_pEventSink ->Release(); }
    g_pEventSink = pEventSink;
    if ( pEventSink  )
    { g_pEventSink->AddRef(); }
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetEventSink()
//
// Synopsis:    Get the event sink pointer into Windows Management
//
//////////////////////////////////////////////////////////////////////////////
IWbemObjectSink* GetEventSink(void)
{
    return g_pEventSink; // Note can be NULL if there are no consumers...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\appmgr.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      appmgr.cpp
//
// Project:     Chameleon
//
// Description: Implementation of WinMain and NT service application logic
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version - Most code produced by VS 6.0
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "appmgr.h"

#include <stdio.h>
#include "ApplianceManager.h"

CServiceModule _Module;

//
// global class to indicate that SCM has called us
//
CSCMIndicator  g_SCMIndicator;

//
// forward declaration of method to set ACLs
//
DWORD
SetAclForComObject ( 
    /*[in]*/    PSECURITY_DESCRIPTOR pSD,
    /*[out*/    PACL             *ppacl
    );
//////////////////////////////////////////////////////////////////////////////
// Change these for a new service...

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ApplianceManager, CApplianceManager)
END_OBJECT_MAP()

const DWORD   dwServiceIDR = IDR_Appmgr;
const wchar_t szServiceAppID[] = L"{6CBECC11-BF0A-11D2-90B6-00AA00A71DCA}";

///////////////////////////////////////////////////////////////////////////////
bool StartMyService(void);
bool StopMyService(void);

///////////////////////////////////////////////////////////////////////////////
LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// Although some of these functions are big they are declared inline 
// since they are only used once
///////////////////////////////////////////////////////////////////////////////

#define SERVICE_NAME            L"appmgr"

#define EVENT_LOG_KEY           L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" SERVICE_NAME

#define EVENT_SOURCE_EXTENSION  L"dll"

#define EVENT_MESSAGE_FILE      L"%SystemRoot%\\system32\\serverappliance\\mui\\0409\\sagenmsg.dll"  

///////////////////////////////////////////////////////////////////////////////
inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if ( FAILED(hr) )
    {
        return hr;
    }

    do
    {
        // Remove any previous service since it may point to
        // the incorrect file
        // Uninstall();

        // Add service entries
        UpdateRegistryFromResource(dwServiceIDR, TRUE);

        // Adjust the AppID for Local Server or Service
        CRegKey keyAppID;
        LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRes);
            break;
        }

        CRegKey key;
        lRes = key.Open(keyAppID, szServiceAppID, KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRes);
            break;
        }

        key.DeleteValue(_T("LocalService"));
    
        if (bService)
        {
            key.SetValue(SERVICE_NAME, _T("LocalService"));
            key.SetValue(_T("-Service"), _T("ServiceParameters"));

            CRegKey EventLogKey;
            DWORD dwError = EventLogKey.Create(
                                                HKEY_LOCAL_MACHINE,
                                                 EVENT_LOG_KEY,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_SET_VALUE
                                              );
            if ( ERROR_SUCCESS != dwError) 
            {
                hr = HRESULT_FROM_WIN32(dwError);
                break;
            }
            dwError = EventLogKey.SetValue(EVENT_MESSAGE_FILE, L"EventMessageFile");
            if ( ERROR_SUCCESS != dwError ) 
            { 
                hr = HRESULT_FROM_WIN32(dwError);
                break;
            }

            // Create the NT service
            Install();
        }

        // Add object entries
        hr = CComModule::RegisterServer(bRegTypeLib);

    } while ( FALSE );

    CoUninitialize();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(dwServiceIDR, FALSE);

    // Remove service
    Uninstall();
    // Remove object entries

    // TLP - No ATL 3.0...
    CComModule::UnregisterServer(&CLSID_ApplianceManager /* TRUE */ );
    // CComModule::UnregisterServer(TRUE);

    // ToodP - End of non-generic code...

    CoUninitialize();
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    // TLP - No ATL 3.0...
    CComModule::Init(p, h /*, plibid */ );
    // CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));
    LoadString(h, IDS_SERVICENICENAME, m_szServiceNiceName, sizeof(m_szServiceNiceName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}


///////////////////////////////////////////////////////////////////////////////
LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}


///////////////////////////////////////////////////////////////////////////////
BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH +1];
    DWORD dwResult = ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);
    if (0 == dwResult)
    {
        return (FALSE);
    }
    szFilePath[_MAX_PATH] = L'\0';

    SC_HANDLE hService = ::CreateService(
                                          hSCM, 
                                          m_szServiceName, 
                                          m_szServiceNiceName,
                                          SERVICE_ALL_ACCESS, 
                                          SERVICE_WIN32_OWN_PROCESS,
                                          SERVICE_DEMAND_START, 
                                          SERVICE_ERROR_NORMAL,
                                          szFilePath, 
                                          NULL, 
                                          NULL, 
                                          _T("RPCSS\0"), // Requires RPC Service
                                          NULL, 
                                          NULL
                                        );

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// Logging functions
///////////////////////////////////////////////////////////////////////////////

void CServiceModule::LogEvent(
                             /*[in]*/ WORD        wMsgType,
                             /*[in]*/ LONG        lMsgID,
                             /*[in]*/ DWORD        dwMsgParamCount,
                             /*[in]*/ LPCWSTR*    pszMsgParams,
                             /*[in]*/ DWORD        dwDataSize,
                             /*[in]*/ BYTE*        pData
                              )
{
    if ( m_bService )
    {
        // Get a handle to use with ReportEvent().
        HANDLE hEventSource = RegisterEventSource( NULL, m_szServiceName );
        if ( NULL != hEventSource )
        {
            // Write to event log.
            ReportEvent(
                         hEventSource, 
                         wMsgType, 
                         0, 
                         lMsgID, 
                         NULL, 
                         dwMsgParamCount, 
                         dwDataSize, 
                         pszMsgParams, 
                         pData
                       );

            // Free the event source
            DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        wchar_t szMsg[128] = L"Logged Event: ";
        wchar_t szEventID[16];
        lstrcat(szMsg, _itow(lMsgID, szEventID, 16));
        _putts(szMsg);
    }
}


///////////////////////////////////////////////////////////////////////////////
// Service startup and registration
///////////////////////////////////////////////////////////////////////////////

inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };

    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
    {
        Run();
    }
}

///////////////////////////////////////////////////////////////////////////////
inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler 

    // TODO: ToddP - Why would this fail? If so what action can we take?
    //       Currently the watchdog timer would eventually cause a system reboot.

    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    
    if (m_hServiceStatus == NULL)
    {
        SATraceString ("Appliance Manager Service registration failed");
        return;
    }

    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();
}


///////////////////////////////////////////////////////////////////////////////
inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            // Post a thread quit message - picked up inside of the Run() function
            PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
            break;

        case SERVICE_CONTROL_PAUSE:
            break;

        case SERVICE_CONTROL_CONTINUE:
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        default:

            // ToddP - Just ignore the unrecognized request. Should never
            //         happen if practice.
            _ASSERT(FALSE);
    }
}


///////////////////////////////////////////////////////////////////////////////
void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}


///////////////////////////////////////////////////////////////////////////////
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}


///////////////////////////////////////////////////////////////////////////////
void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}


///////////////////////////////////////////////////////////////////////////////
void CServiceModule::Run()
{
    _Module.dwThreadID = GetCurrentThreadId();

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( SUCCEEDED(hr) )
    {
        // Initialize security for the service process

        // RPC_C_AUTHN_LEVEL_CONNECT 
        // Authenticates the credentials of the client only when the client 
        // establishes a relationship with the server. 
        // Datagram transports always use RPC_AUTHN_LEVEL_PKT instead. 

        // RPC_C_IMP_LEVEL_IMPERSONATE 
        // The server process can impersonate the client's security
        // context while acting on behalf of the client. This level of
        // impersonation can be used to access local resources such as files. 
        // When impersonating at this level, the impersonation token can only 
        // be passed across one machine boundary. 
        // In order for the impersonation token to be passed, you must use 
        // Cloaking, which is available in Windows NT 5.0. 

        CSecurityDescriptor sd;
        sd.InitializeFromThreadToken();

         PACL pacl = NULL;
         //
         // 
         // Add ACLs to the SD using the builtin RIDs.
         //
         DWORD dwRetVal =  SetAclForComObject  ( 
                        (PSECURITY_DESCRIPTOR) sd.m_pSD,
                                &pacl
                            );    
        if (ERROR_SUCCESS != dwRetVal)      {return;}
            
        hr = CoInitializeSecurity(
                                    sd, 
                                    -1, 
                                    NULL, 
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    RPC_C_IMP_LEVEL_IDENTIFY, 
                                    NULL, 
                                    EOAC_DYNAMIC_CLOAKING, 
                                    NULL
                                 );

        // Register the class with COM
        //
        _ASSERTE(SUCCEEDED(hr));
        if ( SUCCEEDED(hr) )
        {
            hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE);
            _ASSERTE(SUCCEEDED(hr));
            if ( SUCCEEDED(hr) )
            {
                // Now do service specific startup
                if ( StartMyService() )
                {
                    SetServiceStatus(SERVICE_RUNNING);
                    MSG msg;
                    while (GetMessage(&msg, 0, 0, 0))
                        DispatchMessage(&msg);
                    
                    SetServiceStatus(SERVICE_STOP_PENDING);
                    StopMyService();
                    SetServiceStatus(SERVICE_STOPPED);
                }

                _Module.RevokeClassObjects();
            }
        }


      //
      // cleanup
      //
      if (pacl) {LocalFree (pacl);}

      CoUninitialize();
    }
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    // ToddP - Below is the only code that is not generic in this module.
    //         I should change this VS 6.0 code to use UUID or a property of the Module.
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_APPMGRLib);
    //
    // ToddP - End of non-eneric code...

    _Module.m_bService = TRUE;

    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);
        
        // Register as Service
        if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);
        
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, szServiceAppID, KEY_READ);

    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}


//////////////////////////////////////////////////////////////////////////////
// 
// Function: StartMyService()
//
// Synopsis: Perform service specific startup functions
//
//////////////////////////////////////////////////////////////////////////////
bool StartMyService()
{
    bool bResult = false;

    // Appliance manager is a singleton so all the following code 
    // does is get a reference to the single instance and invoke shutdown

    CComPtr<IApplianceObjectManager> pObjMgr;
    HRESULT hr = CoCreateInstance(
                                  CLSID_ApplianceManager,
                                  NULL,
                                  CLSCTX_LOCAL_SERVER,
                                  IID_IApplianceObjectManager,
                                  (void**)&pObjMgr
                                 );
    if ( SUCCEEDED(hr) )
    {
        //
        // indicate we have been called by SCM
        //
        g_SCMIndicator.Set ();
        
        hr = pObjMgr->InitializeManager(NULL);
        if ( SUCCEEDED(hr) )
        {
            bResult = true;
        }
    }
    return bResult;
}


//////////////////////////////////////////////////////////////////////////////
// 
// Function: StopMyService()
//
// Synopsis: Perform service specific shutdown functions
//
//////////////////////////////////////////////////////////////////////////////
bool StopMyService()
{
    bool bResult = false;

    // Appliance manager is a singleton so all the following code 
    // does is get a reference to the single instance and invoke shutdown

    CComPtr<IApplianceObjectManager> pObjMgr;
    HRESULT hr = CoCreateInstance(
                                  CLSID_ApplianceManager,
                                  NULL,
                                  CLSCTX_LOCAL_SERVER,
                                  IID_IApplianceObjectManager,
                                  (void**)&pObjMgr
                                 );
    if ( SUCCEEDED(hr) )
    {
        //
        // indicate we have been called by SCM
        //
        g_SCMIndicator.Set ();

        hr = pObjMgr->ShutdownManager();
        if ( SUCCEEDED(hr) )
        {
            bResult = true;
        }
    }
    return bResult;
}


//++--------------------------------------------------------------
//
//  Function:   SetAclForComObject
//
//  Synopsis: method for providing only the Local System and Admins rights 
//             to access the COM object
//
//  Arguments:  none
//
//  Returns:    HRESULT
//
//  History:    MKarki      11/15/2001    Created
//			MKarki	 04/15/2002    Copied to Appmgr
//
//----------------------------------------------------------------
DWORD
SetAclForComObject ( 
    /*[in]*/    PSECURITY_DESCRIPTOR pSD,
    /*[out*/    PACL             *ppacl
    )
{    
    DWORD              dwError = ERROR_SUCCESS;
        int                         cbAcl = 0;
        PACL                    pacl = NULL;
        PSID                    psidLocalSystemSid = NULL;
     PSID                    psidAdminSid = NULL;
       SID_IDENTIFIER_AUTHORITY siaLocalSystemSidAuthority = SECURITY_NT_AUTHORITY;

    CSATraceFunc objTraceFunc ("SetAclFromComObject");

    do
    {
        if (NULL == pSD)
        {
            SATraceString ("SetAclFromComObject - invalid parameter passed in");
            dwError = ERROR_INVALID_PARAMETER;
            break;
        }
            
        //
        // Create a SID for Local System account
        //
            BOOL bRetVal = AllocateAndInitializeSid (  
                            &siaLocalSystemSidAuthority,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0,
                            0,
                            0,
                            0,
                            0,
                          0,
                            0,
                            &psidLocalSystemSid 
                            );
        if (!bRetVal)
        {     
            dwError = GetLastError ();
                SATraceFailure ("SetAclFromComObject:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  dwError);
                break;
            }

        //
            // Create a SID for Admin group
            //
            bRetVal = AllocateAndInitializeSid (  
                            &siaLocalSystemSidAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &psidAdminSid
                            );
        if (!bRetVal)
        {      
            dwError = GetLastError ();
                SATraceFailure ("SetAclFromComObject:AllocateAndInitializeSid (Admin) failed",  dwError);
                break;
            }

        //
            // Calculate the length of required ACL buffer
            // with 2 ACEs.
            //
            cbAcl =     sizeof (ACL)
                            +   2 * sizeof (ACCESS_ALLOWED_ACE)
                            +   GetLengthSid( psidAdminSid )
                            +   GetLengthSid( psidLocalSystemSid );

            pacl = (PACL) LocalAlloc ( 0, cbAcl );
            if (NULL == pacl) 
            {
                dwError = ERROR_OUTOFMEMORY;
                SATraceFailure ("SetAclFromComObject::LocalAlloc failed:", dwError);
            break;
            }

        //
        // initialize the ACl now
        //
            bRetVal =InitializeAcl ( 
                        pacl,
                                cbAcl,
                                ACL_REVISION2
                                );
            if (!bRetVal)
            {
                 dwError = GetLastError();
            SATraceFailure ("SetAclFromComObject::InitializeAcl failed:", dwError);
                break;
            }

        //
            // Add ACE with EVENT_ALL_ACCESS for Local System account
            //
            bRetVal = AddAccessAllowedAce ( 
                            pacl,
                                        ACL_REVISION2,
                                        COM_RIGHTS_EXECUTE,
                                        psidLocalSystemSid
                                        );
        if (!bRetVal)
        {
                dwError = GetLastError();
                SATraceFailure ("SetAclFromComObject::AddAccessAllowedAce (LOCAL SYSTEM)  failed:", dwError);
            break;
        }

        //
            // Add ACE with EVENT_ALL_ACCESS for Admin Group
            //
            bRetVal = AddAccessAllowedAce ( 
                            pacl,
                                        ACL_REVISION2,
                                        COM_RIGHTS_EXECUTE,
                                        psidAdminSid
                                        );
        if (!bRetVal)
        {
                dwError = GetLastError();
                     SATraceFailure ("SetAclFromComObject::AddAccessAllowedAce (ADMIN) failed:", dwError);
            break;
        }

        //
            // Set the ACL which allows EVENT_ALL_ACCESS for all users and
            // Local System to the security descriptor.
            bRetVal = SetSecurityDescriptorDacl (   
                            pSD,
                                            TRUE,
                                            pacl,
                                            FALSE 
                                            );
        if (!bRetVal)
        {
                dwError = GetLastError();
                     SATraceFailure ("SetAclFromComObject::SetSecurityDescriptorDacl failed:", dwError);
            break;
        }
    
        //
        // success
        //
    }
    while (false);
    
       //
    // in case of error, cleanup
    //
     if (dwError) 
     {
            if ( pacl ) 
            {
                   LocalFree ( pacl );
            }
        }
        else 
        {
            *ppacl = pacl;
        }


    //
    // free up resources now
    //
    if ( psidLocalSystemSid ) {FreeSid ( psidLocalSystemSid );}
    if ( psidAdminSid ) {FreeSid ( psidAdminSid );}

        return (dwError);
        
}//End of SetAclFromComObject method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\appliancemanager.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      appliancemanager.h
//
// Project:     Chameleon
//
// Description: Implementation of CApplianceManager class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "appliancemanager.h"
#include "appmgrutils.h"
#include <appmgrobjs.h>
#include <getvalue.h>
#include <appsrvcs.h>
#include <taskctx.h>
#include <varvec.h>

extern CServiceModule _Module;
extern CSCMIndicator  g_SCMIndicator;

_bstr_t bstrCurrentBuild = PROPERTY_APPMGR_CURRENT_BUILD;
_bstr_t bstrPID = PROPERTY_APPMGR_PRODUCT_ID;

//////////////////////////////////////////////////////////////////////////////
// CAppObjMgrStatus Implementation
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
void
CAppObjMgrStatus::InternalInitialize(
                             /*[in]*/ CApplianceManager* pAppMgr
                                    )
{
    _ASSERT(pAppMgr);
    m_pAppMgr = pAppMgr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAppObjMgrStatus::SetManagerStatus(
                            /*[in]*/ APPLIANCE_OBJECT_MANAGER_STATUS eStatus
                                  )
{
    
    try
    {
        _ASSERT(m_pAppMgr);
        m_pAppMgr->SetServiceObjectManagerStatus(eStatus);
        return S_OK;
    }
    catch(...)
    {
    }

    return E_FAIL;
}



/////////////////////////////////////////////////////////////////////////////
// CApplianceManager Implementation
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
CApplianceManager::CApplianceManager()
    : m_eState(AM_STATE_SHUTDOWN),
      m_bWMIInitialized(false),
      m_dwEnteredCount(0),
      m_clsProviderInit(this),
      m_clsProviderServices(this)
{ 
    m_ServiceObjMgrStatus.InternalInitialize(this);
}

//////////////////////////////////////////////////////////////////////////////
CApplianceManager::~CApplianceManager()
{
}


//////////////////////////////////////////////////////////////////////////////
// IWbemProviderInit Interface Implementation
//////////////////////////////////////////////////////////////////////////////
  
STDMETHODIMP CApplianceManager::CProviderInit::Initialize(
                                    /*[in, unique, string]*/ LPWSTR                 wszUser,
                                                    /*[in]*/ LONG                   lFlags,
                                            /*[in, string]*/ LPWSTR                 wszNamespace,
                                    /*[in, unique, string]*/ LPWSTR                 wszLocale,
                                                    /*[in]*/ IWbemServices*         pNamespace,
                                                    /*[in]*/ IWbemContext*          pCtx,
                                                    /*[in]*/ IWbemProviderInitSink* pInitSink    
                                                         )
{
    // Main initialization occurs during service start. Here we just save
    // away the provided name space pointer for subsequent use.

    HRESULT hr = WBEM_E_FAILED;

    {
        CLockIt theLock(*m_pAppMgr);

        _ASSERT( NULL != pNamespace );
        if ( NULL == pNamespace )
        { return WBEM_E_INVALID_PARAMETER; }

        TRY_IT

        _ASSERT( AM_STATE_SHUTDOWN != m_pAppMgr->m_eState );
        if ( AM_STATE_SHUTDOWN != m_pAppMgr->m_eState )
        {
            SATraceString("WMI is initializing the Appliance Manager...");

            // Save the name space provided by Windows Management for
            // subsequent use.
            ::SetNameSpace(pNamespace);

            // Set our state to WMI intialized (enables subsequent requests
            // from Windows Management)
            m_pAppMgr->m_bWMIInitialized = true;

            // Alle ist klar...
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            SATraceString("WMI could not initialize the Appliance Manager...");
        }

        CATCH_AND_SET_HR
    }

    if ( SUCCEEDED(hr) )
    { pInitSink->SetStatus(WBEM_S_INITIALIZED,0); }
    else
    { pInitSink->SetStatus(WBEM_E_FAILED, 0); }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:    Shutdown()
//
// Synoposis:    Invoked when WBEM releases us (primary interface)
//
//////////////////////////////////////////////////////////////////////////////
void CApplianceManager::CProviderServices::Shutdown(void)
{
    // Clear our hold on the Windows Management namespace
    ::SetNameSpace(NULL);
    ::SetEventSink(NULL);

    // Set our state to WMI uninitialized
    m_pAppMgr->m_bWMIInitialized = false;

    // Set the number of times entered to 0
    m_pAppMgr->m_dwEnteredCount = 0;

    SATraceString("WMI has released the Appliance Manager...");
}


//////////////////////////////////////////////////////////////////////////////
// IWbemEventProvider Interface Implementation
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplianceManager::ProvideEvents(
                                      /*[in]*/ IWbemObjectSink *pSink,
                                      /*[in]*/ LONG lFlags
                                             )
{
    _ASSERT( m_bWMIInitialized );
    if ( ! m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    _ASSERT( NULL != pSink );
    if ( NULL == pSink )
    { return WBEM_E_INVALID_PARAMETER; }

    //////////////////////////////////////////
    // Synchronize operation with NT SCM Logic
    //////////////////////////////////////////
    {
        CLockIt theLock(*this);
        if ( AM_STATE_SHUTDOWN == m_eState )
        { return WBEM_E_FAILED;    }
        else
        { m_dwEnteredCount++; }
    }
    /////////////////////////////////////////


    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    _ASSERT( m_bWMIInitialized );
    if ( m_bWMIInitialized )
    {
        // Save the event sink provided by Windows Management
        // for subsequent use
        SATraceString("WMI has asked the Appliance Manager to provide events...");
        ::SetEventSink(pSink);
        hr = WBEM_S_NO_ERROR;
    }

    CATCH_AND_SET_HR

    //////////////////////////////////////////
    // Synchronize operation with NT SCM Logic
    //////////////////////////////////////////
    m_dwEnteredCount--;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// IWbemServices Interface Implementation
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::OpenNamespace(
                               /*[in]*/    const BSTR        strNamespace,
                               /*[in]*/    long              lFlags,
                               /*[in]*/    IWbemContext*     pCtx,
                    /*[out, OPTIONAL]*/    IWbemServices**   ppWorkingNamespace,
                    /*[out, OPTIONAL]*/    IWbemCallResult** ppResult
                                                )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::CancelAsyncCall(
                                        /*[in]*/ IWbemObjectSink* pSink
                                               )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::QueryObjectSink(
                                        /*[in]*/ long              lFlags,
                                       /*[out]*/ IWbemObjectSink** ppResponseHandler
                                               )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::GetObject(
                                  /*[in]*/ const BSTR         strObjectPath,
                                  /*[in]*/ long               lFlags,
                                  /*[in]*/ IWbemContext*      pCtx,
                       /*[out, OPTIONAL]*/ IWbemClassObject** ppObject,
                       /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                                         )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::GetObjectAsync(
                                       /*[in]*/  const BSTR       strObjectPath,
                                       /*[in]*/  long             lFlags,
                                       /*[in]*/  IWbemContext*    pCtx,        
                                       /*[in]*/  IWbemObjectSink* pResponseHandler
                                              )
{
    //////////////////////////////////////////
    // Synchronize operation with NT SCM Logic
    //////////////////////////////////////////
    {
        CLockIt theLock(*m_pAppMgr);
        if ( AM_STATE_SHUTDOWN == m_pAppMgr->m_eState )
        { return WBEM_E_FAILED;    }
        else
        { m_pAppMgr->m_dwEnteredCount++; }
    }
    /////////////////////////////////////////

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

        SATraceString ("CApplianceManager::GetObjectAsync Impersonating Client");
    //
    // impersonate the client here
    //
    hr = CoImpersonateClient ();
    if (FAILED (hr))
    {
        SATracePrintf ("CApplianceManager::GetObjectAsync failed on CoImpersonateClient with error:%x", hr);
        //
        // Report function status
        //
        pResponseHandler->SetStatus(0, hr, 0, 0);
        throw _com_error (hr);
    }

    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { throw _com_error(WBEM_E_UNEXPECTED); }

    _ASSERT( NULL != strObjectPath && NULL != pResponseHandler );
    if ( NULL == strObjectPath || NULL == pResponseHandler )
    { throw _com_error(WBEM_E_INVALID_PARAMETER); }

    // Is the call destined for an object manager...
    CComPtr<IWbemServices> pWbemSrvcs = m_pAppMgr->GetObjectMgr(strObjectPath);
    if ( NULL != (IWbemServices*) pWbemSrvcs )
    {
        // Yes... give the call to the appropriate object manager
        hr = pWbemSrvcs->GetObjectAsync(
                                        strObjectPath,
                                        lFlags,
                                        pCtx,
                                        pResponseHandler
                                       );
    }
    else
    {
        // No... Is it a request for the appliance manager class?
        _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrClass )
        {
            hr = WBEM_E_NOT_FOUND;
        }
        else
        {
            if ( lstrcmp((LPWSTR)bstrClass, CLASS_WBEM_APPMGR) )
            {
                hr = WBEM_E_NOT_FOUND;
            }
            else
            {
                // Yes... return the instance of the singleton appliance manager class
                CComPtr<IWbemClassObject> pClassDefintion;
                hr = (::GetNameSpace())->GetObject(
                                                   bstrClass, 
                                                   0, 
                                                   pCtx, 
                                                   &pClassDefintion, 
                                                   NULL
                                                  );
                if ( SUCCEEDED(hr) )
                {
                    CComPtr<IWbemClassObject> pWbemObj;
                    hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
                    if ( SUCCEEDED(hr) )
                    {
                        _variant_t vtPropertyValue = (LPCWSTR)m_pAppMgr->m_szCurrentBuild.c_str();
                        hr = pWbemObj->Put(
                                            bstrCurrentBuild, 
                                            0, 
                                            &vtPropertyValue, 
                                            0
                                          );
                        if ( SUCCEEDED(hr) )
                        {
                            vtPropertyValue = (LPCWSTR)m_pAppMgr->m_szPID.c_str();
                            hr = pWbemObj->Put(
                                                bstrPID, 
                                                0, 
                                                &vtPropertyValue, 
                                                0
                                              );
                            if ( SUCCEEDED(hr) )
                            {
                                pResponseHandler->Indicate(1, &pWbemObj.p);
                                hr = WBEM_S_NO_ERROR;
                            }
                        }
                    }
                }
            }
        }

        // Set the function status
        pResponseHandler->SetStatus(0, hr, NULL, NULL);
    }

    CATCH_AND_SET_HR

    //////////////////////////////////////////
    // Synchronize operation with NT SCM Logic
    //////////////////////////////////////////
    m_pAppMgr->m_dwEnteredCount--;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::PutClass(
               /*[in]*/     IWbemClassObject* pObject,
               /*[in]*/     long              lFlags,
               /*[in]*/     IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                       )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::PutClassAsync(
                                      /*[in]*/ IWbemClassObject* pObject,
                                      /*[in]*/ long              lFlags,
                                      /*[in]*/ IWbemContext*     pCtx,        
                                      /*[in]*/ IWbemObjectSink*  pResponseHandler
                                             )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::DeleteClass(
                                    /*[in]*/ const BSTR        strClass,
                                    /*[in]*/ long              lFlags,
                                    /*[in]*/ IWbemContext*     pCtx,        
                         /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                                           )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::DeleteClassAsync(
                                         /*[in]*/ const BSTR       strClass,
                                         /*[in]*/ long             lFlags,
                                         /*[in]*/ IWbemContext*    pCtx,        
                                         /*[in]*/ IWbemObjectSink* pResponseHandler
                                                )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::CreateClassEnum(
                                        /*[in]*/ const BSTR             strSuperclass,
                                        /*[in]*/ long                   lFlags,
                                        /*[in]*/ IWbemContext*          pCtx,        
                                       /*[out]*/ IEnumWbemClassObject** ppEnum
                                               )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::CreateClassEnumAsync(
                                              /*[in]*/  const BSTR       strSuperclass,
                                              /*[in]*/  long             lFlags,
                                              /*[in]*/  IWbemContext*    pCtx,        
                                              /*[in]*/  IWbemObjectSink* pResponseHandler
                                                     )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::PutInstance(
                                    /*[in]*/ IWbemClassObject* pInst,
                                    /*[in]*/ long              lFlags,
                                    /*[in]*/ IWbemContext*     pCtx,        
                         /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                                           )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::PutInstanceAsync(
                       /*[in]*/ IWbemClassObject* pInst,
                       /*[in]*/ long              lFlags,
                       /*[in]*/ IWbemContext*     pCtx,        
                       /*[in]*/ IWbemObjectSink*  pResponseHandler
                              )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::DeleteInstance(
        /*[in]*/              const BSTR        strObjectPath,
        /*[in]*/              long              lFlags,
        /*[in]*/              IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/   IWbemCallResult** ppCallResult        
                                              )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::DeleteInstanceAsync(
                          /*[in]*/ const BSTR       strObjectPath,
                          /*[in]*/ long             lFlags,
                          /*[in]*/ IWbemContext*    pCtx,        
                          /*[in]*/ IWbemObjectSink* pResponseHandler
                                                   )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::CreateInstanceEnum(
                         /*[in]*/ const BSTR             strClass,
                         /*[in]*/ long                   lFlags,
                         /*[in]*/ IWbemContext*          pCtx,        
                        /*[out]*/ IEnumWbemClassObject** ppEnum
                                                  )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::CreateInstanceEnumAsync(
                              /*[in]*/ const BSTR       strClass,
                              /*[in]*/ long             lFlags,
                              /*[in]*/ IWbemContext*    pCtx,        
                              /*[in]*/ IWbemObjectSink* pResponseHandler
                                                       )
{
    //////////////////////////////////////////
    // Synchronize operation with NT SCM Logic
    //////////////////////////////////////////
    {
        CLockIt theLock(*m_pAppMgr);
        if ( AM_STATE_SHUTDOWN == m_pAppMgr->m_eState )
        { return WBEM_E_FAILED;    }
        else
        { m_pAppMgr->m_dwEnteredCount++; }
    }
    /////////////////////////////////////////

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

     SATraceString ("CApplianceManager::CreateInstanceEnumAsync Impersonating Client");
    //
    // impersonate the client here
    //
    hr = CoImpersonateClient ();
    if (FAILED (hr))
    {
        SATracePrintf ("CApplianceManager::CreateInstanceEnumAsync failed on CoImpersonateClient with error:%x", hr);
        //
        // Report function status
        //
        pResponseHandler->SetStatus(0, hr, 0, 0);
        throw _com_error (hr);
    }

    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { throw _com_error(WBEM_E_UNEXPECTED); }

    _ASSERT( NULL != strClass && NULL != pResponseHandler );
    if ( NULL == strClass || NULL == pResponseHandler )
    { throw _com_error(WBEM_E_INVALID_PARAMETER); }

    // Is the call destined for an object manager...
    CComPtr<IWbemServices> pWbemSrvcs = m_pAppMgr->GetObjectMgr(strClass);
    if ( NULL != (IWbemServices*) pWbemSrvcs )
    {
        // Yes... give the call to the appropriate object manager
        hr = pWbemSrvcs->CreateInstanceEnumAsync(
                                                 strClass,
                                                 lFlags,
                                                 pCtx,
                                                 pResponseHandler
                                                );
    }
    else
    {
        // No... Is it a request for the appliance manager class?
        if ( lstrcmp((LPWSTR)strClass, CLASS_WBEM_APPMGR) )
        {
            hr = WBEM_E_NOT_FOUND;
        }
        else
        {
            // Yes... return the instance of the singleton appliance manager class
            CComPtr<IWbemClassObject> pClassDefintion;
            hr = (::GetNameSpace())->GetObject(
                                               strClass, 
                                               0, 
                                               pCtx, 
                                               &pClassDefintion, 
                                               NULL
                                              );
            if ( SUCCEEDED(hr) )
            {
                CComPtr<IWbemClassObject> pWbemObj;
                hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
                if ( SUCCEEDED(hr) )
                {
                    _variant_t vtPropertyValue = (LPCWSTR)m_pAppMgr->m_szCurrentBuild.c_str();
                    hr = pWbemObj->Put(
                                        bstrCurrentBuild, 
                                        0, 
                                        &vtPropertyValue, 
                                        0
                                      );
                    if ( SUCCEEDED(hr) )
                    {
                        vtPropertyValue = (LPCWSTR)m_pAppMgr->m_szPID.c_str();
                        hr = pWbemObj->Put(
                                            bstrPID, 
                                            0, 
                                            &vtPropertyValue, 
                                            0
                                          );
                        if ( SUCCEEDED(hr) )
                        {
                            pResponseHandler->Indicate(1, &pWbemObj.p);
                            hr = WBEM_S_NO_ERROR;
                        }
                    }
                }
            }
        }
    }

    // Set the function status
    pResponseHandler->SetStatus(0, hr, NULL, NULL);

    CATCH_AND_SET_HR

    //////////////////////////////////////////
    // Synchronize operation with NT SCM Logic
    //////////////////////////////////////////
    m_pAppMgr->m_dwEnteredCount--;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::ExecQuery(
                 /*[in]*/ const BSTR             strQueryLanguage,
                 /*[in]*/ const BSTR             strQuery,
                 /*[in]*/ long                   lFlags,
                 /*[in]*/ IWbemContext*          pCtx,        
                /*[out]*/ IEnumWbemClassObject** ppEnum
                                         )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::ExecQueryAsync(
                     /*[in]*/ const BSTR       strQueryLanguage,
                     /*[in]*/ const BSTR       strQuery,
                     /*[in]*/ long             lFlags,
                     /*[in]*/ IWbemContext*    pCtx,        
                     /*[in]*/ IWbemObjectSink* pResponseHandler
                                              )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::ExecNotificationQuery(
                            /*[in]*/ const BSTR             strQueryLanguage,
                            /*[in]*/ const BSTR             strQuery,
                            /*[in]*/ long                   lFlags,
                            /*[in]*/ IWbemContext*          pCtx,        
                           /*[out]*/ IEnumWbemClassObject** ppEnum
                                                     )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::ExecNotificationQueryAsync(
                                                /*[in]*/ const BSTR       strQueryLanguage,
                                                /*[in]*/ const BSTR       strQuery,
                                                /*[in]*/ long             lFlags,
                                                /*[in]*/ IWbemContext*    pCtx,        
                                                /*[in]*/ IWbemObjectSink* pResponseHandler
                                                          )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::ExecMethod(
                                    /*[in]*/ const BSTR         strObjectPath,
                                    /*[in]*/ const BSTR         strMethodName,
                                    /*[in]*/ long               lFlags,
                                    /*[in]*/ IWbemContext*      pCtx,        
                                    /*[in]*/ IWbemClassObject*  pInParams,
                         /*[out, OPTIONAL]*/ IWbemClassObject** ppOutParams,
                         /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                                          )
{
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { return WBEM_E_UNEXPECTED; }

    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::CProviderServices::ExecMethodAsync(
                                        /*[in]*/ const BSTR        strObjectPath,
                                        /*[in]*/ const BSTR        strMethodName,
                                        /*[in]*/ long              lFlags,
                                        /*[in]*/ IWbemContext*     pCtx,        
                                        /*[in]*/ IWbemClassObject* pInParams,
                                        /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                               )
{
    //////////////////////////////////////////
    // Synchronize operation with NT SCM Logic
    //////////////////////////////////////////
    {
        CLockIt theLock(*m_pAppMgr);
        if ( AM_STATE_SHUTDOWN == m_pAppMgr->m_eState )
        { return WBEM_E_FAILED;    }
        else
        { m_pAppMgr->m_dwEnteredCount++; }
    }
    /////////////////////////////////////////

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT
        
      
      SATraceString ("CApplianceManager::ExecMethodAsync Impersonating Client");
    //
    // impersonate the client here
    //
    hr = CoImpersonateClient ();
    if (FAILED (hr))
    {
        SATracePrintf ("CApplianceManager::ExecMethodAsync failed on CoImpersonateClient with error:%x", hr);
        //
        // Report function status
        //
        pResponseHandler->SetStatus(0, hr, 0, 0);
        throw _com_error (hr);
    }
    
    _ASSERT( m_pAppMgr->m_bWMIInitialized );
    if ( ! m_pAppMgr->m_bWMIInitialized )
    { throw _com_error(WBEM_E_UNEXPECTED); }

    _ASSERT( NULL != strObjectPath && NULL != strMethodName && NULL != pResponseHandler );
    
    if ( NULL == strObjectPath || NULL == strMethodName || NULL == pResponseHandler )
    { throw _com_error(WBEM_E_INVALID_PARAMETER); }

    _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
    if ( NULL != (LPCWSTR)bstrClass )
    {
        // Assume the method execution request will be routed
        // to one of the object managers
        bool bRouteMethod = true;
        // Is the method against the Appliance Manager?
        if ( ! lstrcmpi((LPWSTR)bstrClass, CLASS_WBEM_APPMGR) )
        { 
            // Yes... Is it the 'ResetAppliance' method?
            if ( ! lstrcmpi(strMethodName, METHOD_APPMGR_RESET_APPLIANCE) )
            {
                // Yes... Reset the server appliance (orderly shutdown)
                bRouteMethod = false;
                hr = ResetAppliance(
                                    pCtx,
                                    pInParams,
                                    pResponseHandler
                                   );
            }
            else
            {
                // No... Then it must be one of the Microsoft_SA_Manager methods
                // implemented by the Alert Object Manager...
                bstrClass = CLASS_WBEM_ALERT; 
                (BSTR)strObjectPath = (BSTR)bstrClass;
            }
        }
        if ( bRouteMethod )
        {
            CComPtr<IWbemServices> pWbemSrvcs = m_pAppMgr->GetObjectMgr(bstrClass);
            if ( NULL != (IWbemServices*) pWbemSrvcs )
            {
                hr = pWbemSrvcs->ExecMethodAsync(
                                                  strObjectPath,
                                                  strMethodName,
                                                  lFlags,
                                                  pCtx,
                                                  pInParams,
                                                  pResponseHandler
                                                );
            }
        }
    }

    CATCH_AND_SET_HR;

    //////////////////////////////////////////
    // Synchronize operation with NT SCM Logic
    //////////////////////////////////////////
    m_pAppMgr->m_dwEnteredCount--;

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function:    ResetAppliance()
//
// Synopsis:    Asks the Appliance Monitor to reset the server appliance
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
CApplianceManager::CProviderServices::ResetAppliance(
                                             /*[in]*/ IWbemContext*        pCtx,
                                             /*[in]*/ IWbemClassObject*    pInParams,
                                             /*[in]*/ IWbemObjectSink*    pResponseHandler
                                                    )
{
    return (E_FAIL);
}

////////////////////////////////////////////////////////
// The following registry structure is assumed:
//
// HKLM\SYSTEM\CurrentControlSet\Services\ApplianceManager
//
// ObjectManagers
//       |
//        - Microsoft_SA_Service
//       |     |
//       |      - ServiceX
//       |     |  (ServiceX Properties)
//       |     |
//       |      - ServiceY
//       |     |  (ServiceY Properties)
//       |
//        - Microsoft_SA_Task
//       |    |
//       |     - TaskX
//       |    |  (TaskX Properties)
//       |    |
//       |     - TaskY
//         |    |  (TaskY Properties)
//       |
//        - Microsoft_SA_Alert
//       |    |
//       |     - PruneInterval
//       | 
//        - Microsoft_SA_User
//          (Empty)


// ObjectManagers registry key location
const wchar_t szObjectManagers[] = L"SOFTWARE\\Microsoft\\ServerAppliance\\ApplianceManager\\ObjectManagers";

// Strings used for Appliance Initialization and Shutdown Tasks
const _bstr_t bstrClassService = CLASS_WBEM_SERVICE; 
const _bstr_t bstrClassTask = CLASS_WBEM_TASK; 

///////////////////////////////////////////////////////////////////////////////
//
// Function:    InitializeService()
//
// Synopsis:    Called by the _Module::Run() method at service start time.
//                responsible for initializing the appliance manager service.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::    InitializeManager(
                        /*[in]*/ IApplianceObjectManagerStatus* pObjMgrStatus          
                                                 )
{
    HRESULT hr = E_FAIL;
    CComPtr<IApplianceObjectManager> pObjMgr;

    CLockIt theLock(*this);

    //
    // only proceed if SCM has called us
    //
    if (!g_SCMIndicator.CheckAndReset ())
    {
        SATraceString ("CApplianceManager::InitializeManager not called by SCM");
        return (hr);
    }
    
    TRY_IT

    if ( AM_STATE_SHUTDOWN == m_eState )
    {
        SATraceString("The Appliance Manager Service is initializing...");

        // Get the current appliance build number
        GetVersionInfo();

        // Create and initialize the appliance object managers
        do
        {
            CLocationInfo LocInfo(HKEY_LOCAL_MACHINE, szObjectManagers);
            PPROPERTYBAGCONTAINER pObjMgrs = ::MakePropertyBagContainer(
                                                                        PROPERTY_BAG_REGISTRY,
                                                                        LocInfo
                                                                       );
            if ( ! pObjMgrs.IsValid() )
            { break; }

            if ( ! pObjMgrs->open() )
            { 
                SATraceString("IServiceControl::InitializeService() - Failed - could not open the 'ObjectManagers' registry key...");
                break; 
            }
            
            hr = S_OK;

            if ( pObjMgrs->count() )
            {
                pObjMgrs->reset();
                do
                {
                    PPROPERTYBAG pObjBag = pObjMgrs->current();
                    if ( ! pObjBag.IsValid() )
                    { 
                        hr = E_FAIL;
                        break; 
                    }

                    if ( ! pObjBag->open() )
                    { 
                        SATracePrintf("IServiceControl::InitializeService() - Failed - Could not open the '%ls' registry key...", pObjBag->getName());
                        hr = E_FAIL;
                        break; 
                    }

                    CComPtr<IWbemServices> pObjMgr = (IWbemServices*) ::MakeComponent(
                                                                                       pObjBag->getName(),
                                                                                      pObjBag
                                                                                     );
                    if ( NULL == (IWbemServices*)pObjMgr )
                    { 
                        SATracePrintf("IServiceControl::InitializeService() - Failed - could not create object manager '%ls'...", pObjBag->getName());
                        hr = E_FAIL;
                        break; 
                    }

                    pair<ProviderMapIterator, bool> thePair = 
                    m_ObjMgrs.insert(ProviderMap::value_type(pObjBag->getName(), pObjMgr));
                    if ( false == thePair.second )
                    { 
                        hr = E_FAIL;
                        break; 
                    }

                } while ( pObjMgrs->next() );

                if ( SUCCEEDED(hr) )
                {
                    // Initialize the Chameleon services
                    CComPtr<IWbemServices> pWbemSrvcs = GetObjectMgr(bstrClassService);
                    if ( NULL != (IWbemServices*) pWbemSrvcs )
                    {
                        hr = pWbemSrvcs->QueryInterface(IID_IApplianceObjectManager, (void**)&pObjMgr);
                        if ( FAILED(hr) )
                        {
                            SATracePrintf("CApplianceManager::InitializeService() - QueryIntferface() returned: %lx", hr);
                            break;
                        }
                    }
                    else
                    {
                        SATraceString("CApplianceManager::InitializeService() - Info - No chameleon services defined...");
                    }
                }
            }
            if ( SUCCEEDED(hr) )
            {
                // Set the appliance manager state to initialized
                m_eState = AM_STATE_INITIALIZED; 

                // Initialize the Chameleon services
                if ( NULL != (IApplianceObjectManager*)pObjMgr )
                {
                    hr = pObjMgr->InitializeManager((IApplianceObjectManagerStatus*)&m_ServiceObjMgrStatus);
                }
                SATraceString("The Appliance Manager Service was successfully initialized...");
            }

        } while ( FALSE );
    }

    CATCH_AND_SET_HR

    if ( FAILED(hr) )
    {
        // Initialization failed so free the object managers...
        ProviderMapIterator p = m_ObjMgrs.begin();
        while ( p != m_ObjMgrs.end() )
        { p = m_ObjMgrs.erase(p); }
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function:    ShutdownService()
//
// Synopsis:    Called by the CServiceModule::Handler() method for service
//                shutdown. Responsible for shutting down the appliance manager.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceManager::ShutdownManager()
{
    HRESULT hr = E_FAIL;

    CLockIt theLock(*this);

    //
    // only proceed if SCM has called us
    //
    if (!g_SCMIndicator.CheckAndReset ())
    {
        SATraceString ("CApplianceManager::ShutdownManager not called by SCM");
        return (hr);
    }
    
    TRY_IT

    if ( AM_STATE_SHUTDOWN != m_eState )
    {
        SATraceString("The Appliance Manager Service is shutting down...");

        // Synchronize shutdown with the WMI Provider Logic (COM Client)
        m_eState = AM_STATE_SHUTDOWN;
        DWORD dwTotalWait = 0;
        while ( m_dwEnteredCount )
        { 
            Sleep(SHUTDOWN_WMI_SYNC_WAIT);
            dwTotalWait += SHUTDOWN_WMI_SYNC_WAIT;
            if ( dwTotalWait >= SHUTDOWN_WMI_SYNC_MAX_WAIT )
            {
                SATraceString("The Appliance Manager Service could not synchronize its shutdown with WMI...");
            }
        }

        // Disconnect COM clients and disallow subsequent client connections
        CoSuspendClassObjects();
        CoDisconnectObject((IApplianceObjectManager*)this, 0); 

        // Shutdown the Chameleon services
        CComPtr<IWbemServices> pWbemSrvcs = GetObjectMgr(bstrClassService);
        if ( NULL != (IWbemServices*) pWbemSrvcs )
        {
            CComPtr<IApplianceObjectManager> pObjMgr;
            hr = pWbemSrvcs->QueryInterface(IID_IApplianceObjectManager, (void**)&pObjMgr);
            if ( SUCCEEDED(hr) )
            {
                pObjMgr->ShutdownManager();
            }
            else
            {
                SATraceString("CApplianceManager::ShutdownService() - Could not shutdown Chameleon service object manager...");
            }
        }
        else
        {
            SATraceString("CApplianceManager::ShutdownService() - Info - No chameleon services defined...");
        }

        // Free the object managers
        ProviderMapIterator p = m_ObjMgrs.begin();
        while ( p != m_ObjMgrs.end() )
        { p = m_ObjMgrs.erase(p); }

        // Alle ist klar...
        hr = S_OK;
        SATraceString("The Appliance Manager Service has successfully shut down...");
    }

    CATCH_AND_SET_HR

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// Private Functions
//////////////////////////////////////////////////////////////////////////////

static _bstr_t        bstrResourceType = L"e1847820-43a0-11d3-bfcd-00105a1f3461";
static _variant_t    vtMsgParams;
static _variant_t    vtFailureData;    // Empty

//////////////////////////////////////////////////////////////////////////
//
// Function:    SetServiceObjectManagerStatus()
//
// Synopsis:    Process the service object manager status notification
//
//////////////////////////////////////////////////////////////////////////////
void
CApplianceManager::SetServiceObjectManagerStatus(
                              /*[in]*/ APPLIANCE_OBJECT_MANAGER_STATUS eStatus
                                                )
{
    if ( OBJECT_MANAGER_INITIALIZED != eStatus && OBJECT_MANAGER_SHUTDOWN != eStatus )
    {
        // Shutdown the appliance manager service (in an orderly fashion)
        PostThreadMessage(_Module.dwThreadID, WM_QUIT, 0, 0);
    }
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetObjectMgr()
//
// Synopsis:    Return the IWbemServices interface for the object
//                manager that supports the specified class
//
//////////////////////////////////////////////////////////////////////////////
IWbemServices* CApplianceManager::GetObjectMgr(BSTR bstrObjPath)
{
    _bstr_t bstrClass(::GetObjectClass(bstrObjPath), false);
    if ( NULL == (LPCWSTR)bstrClass )
    { return NULL; }

    ProviderMapIterator p =    m_ObjMgrs.find((LPCWSTR)bstrClass);
    if ( p == m_ObjMgrs.end() )
    { return NULL; }

    return (IWbemServices*)(*p).second;
}


/////////////////////////////////////////////////////////////////////////////
//
// FuncName:        QueryInterfaceRaw()
//
// Description:     Function called by AtlInternalQueryInterface() because
//                  we used COM_INTERFACE_ENTRY_FUNC in the definition of
//                  CRequest. Its purpose is to return a pointer to one
//                  or the request object's "raw" interfaces.
//
// Preconditions:   None
//
// Inputs:          Defined by ATL COM_INTERFACE_ENTRY_FUNC macro
//
// Outputs:         Defined by ATL COM_INTERFACE_ENTRY_FUNC macro
//
//////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI CApplianceManager::QueryInterfaceRaw(
                                                    void*     pThis, 
                                                    REFIID    riid, 
                                                    LPVOID*   ppv, 
                                                    DWORD_PTR dw
                                                   )
{
    if ( InlineIsEqualGUID(riid, IID_IWbemProviderInit) )
    {
        *ppv = &(static_cast<CApplianceManager*>(pThis))->m_clsProviderInit;
    }
    else if ( InlineIsEqualGUID(riid, IID_IWbemServices) )
    {
        *ppv = &(static_cast<CApplianceManager*>(pThis))->m_clsProviderServices;
    }
    else
    {
        _ASSERT(FALSE);
        return E_NOTIMPL;
    }
    ((LPUNKNOWN)*ppv)->AddRef();
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    GetVersionInfo()
//
// Synopsis:    Retrieve the server appliance software version
//
//////////////////////////////////////////////////////////////////////////////

const wchar_t szServerAppliance[] = L"SOFTWARE\\Microsoft\\ServerAppliance\\";
const wchar_t szCurrentBuild[] = PROPERTY_APPMGR_CURRENT_BUILD;
const wchar_t szVersionInfo[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\";
const wchar_t szProductId[] = PROPERTY_APPMGR_PRODUCT_ID;

void CApplianceManager::GetVersionInfo()
{
    _variant_t vtBuild;
    if ( GetObjectValue(
                        szServerAppliance,
                        szCurrentBuild,
                        &vtBuild,
                        VT_BSTR
                       ) )
    {
        m_szCurrentBuild = V_BSTR(&vtBuild);
        SATracePrintf("CApplianceManager::GetVersionInfo() - Current Build '%ls'", V_BSTR(&vtBuild));
    }
    else
    {
        m_szCurrentBuild = SA_DEFAULT_BUILD;
        SATraceString("CApplianceManager::GetVersionInfo() - Could not get build number using default");
    }
    
    _variant_t    vtPID;
    if ( GetObjectValue(
                        szVersionInfo,
                        szProductId,
                        &vtPID,
                        VT_BSTR
                       ) )
    {
        m_szPID = V_BSTR(&vtPID);
        SATracePrintf("CApplianceManager::GetVersionInfo() - Product Id '%ls'", V_BSTR(&vtPID));
    }
    else
    {
        m_szPID = SA_DEFAULT_PID;
        SATraceString("CApplianceManager::GetVersionInfo() - Could not get product ID using default");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\appmgrutils.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      appmgrutils.h
//
// Project:     Chameleon
//
// Description: Appliance Manager Utility Functions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_APPMGR_UTILS_H_
#define __INC_APPMGR_UTILS_H_

#include "resource.h"
#include <wbemprov.h>

/////////////////////////////////////////////////////////////////////////////
// Global Helper Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BSTR GetObjectClass(
              /*[in]*/ LPWSTR  pszObjectPath
                   );

/////////////////////////////////////////////////////////////////////////////
BSTR GetObjectKey(
             /*[in]*/ LPWSTR  pszObjectPath
                    );

/////////////////////////////////////////////////////////////////////////////
void SetNameSpace(
            /*[in*/ IWbemServices* pNameSpace
                 );

/////////////////////////////////////////////////////////////////////////////
IWbemServices* GetNameSpace(void);


/////////////////////////////////////////////////////////////////////////////
void SetEventSink(
            /*[in*/ IWbemObjectSink* pSink
                 );

/////////////////////////////////////////////////////////////////////////////
IWbemObjectSink* GetEventSink(void);


#endif // __INC_APPMGR_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\componentfactory.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      componentfactory.cpp
//
// Project:     Chameleon
//
// Description: Component Factory Implementation
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Original Version
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "componentfactory.h"

// Make sure that in your class map include file 
// you've named the the component factory "TheFactoryMap" 

#include "componentfactorymap.h"

//////////////////////////////////////////////////////////////////////////////
// Global Component Factory Function.
// 
// Note that the interface returned is the interface specified in the
// DECLARE_COMPONENT_FACTORY macro
//
//////////////////////////////////////////////////////////////////////////////
IUnknown* MakeComponent(
                   /*[in]*/ LPCWSTR      pszClassId,
                 /*[in]*/ PPROPERTYBAG pPropertyBag
                       )
{
    IUnknown* pComponent = NULL;
    bool      bFound = false;
    PCOMPONENT_FACTORY_INFO pFactoryInfo = TheFactoryMap;
    while ( pFactoryInfo->pszClassId )
    {
        if ( 0 == lstrcmpi(pFactoryInfo->pszClassId, pszClassId) )
        {
            _ASSERT ( NULL != pFactoryInfo->pfnFactory );
            bFound = true;
            pComponent = (pFactoryInfo->pfnFactory)(pPropertyBag);
            // Ref count of new component pointed at by pComponent is 0 at this point...
            break;
        }
        pFactoryInfo++;
    }
    if ( NULL == pComponent )
    {    
        if ( bFound )
        { 
            SATracePrintf("::MakeComponent() - Failed - Component of type '%ls' was not created...", pszClassId); 
        }
        else
        { 
            SATracePrintf("::MakeComponent() - Failed - Component of type '%ls' was not found...", pszClassId); 
            _ASSERT( FALSE ); /* Should never happens - signifies error in our static factory map */ 
        }
    }    
    return pComponent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\applianceobjectbase.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      applianceobjectbase.h
//
// Project:     Chameleon
//
// Description: Appliance Object Base Class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_BASE_APPLIANCE_OBJECT_H_
#define __INC_BASE_APPLIANCE_OBJECT_H_

#include "resource.h"
#include "appmgr.h"
#include <satrace.h>
#include <componentfactory.h>
#include <propertybagfactory.h>
#include <appmgrobjs.h>
#include <atlhlpr.h>
#include <comdef.h>
#include <comutil.h>

#pragma warning( disable : 4786 )
#include <map>
using namespace std;

//////////////////////////////////////////////////////////////////////////////
// CApplianceObj - Default Appliance Object Implementation

class ATL_NO_VTABLE CApplianceObject :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IApplianceObject, &IID_IApplianceObject, &LIBID_APPMGRLib>
{

public:

    // Constructor
    CApplianceObject() { }

    // Destructor
    virtual ~CApplianceObject() { }

//////////////////////////////////////////////////////////////////
// Derived classes need to contain the following ATL Interface Map
//////////////////////////////////////////////////////////////////

//BEGIN_COM_MAP(CDerivedClassName)
//    COM_INTERFACE_ENTRY(IDispatch)
//    COM_INTERFACE_ENTRY(IApplianceObject)
//END_COM_MAP()

    //////////////////////////////////////////////////////////////////////////
    // IApplianceObject Interface
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(GetProperty)(
                   /*[in]*/ BSTR     pszPropertyName, 
          /*[out, retval]*/ VARIANT* pPropertyValue
                          )
    {
        return E_NOTIMPL;
    }


    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(PutProperty)(
                   /*[in]*/ BSTR     pszPropertyName, 
                   /*[in]*/ VARIANT* pPropertyValue
                          )
    {
        return E_NOTIMPL;
    }

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(SaveProperties)(void)
    {
        return E_NOTIMPL;
    }

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(RestoreProperties)(void)
    {
        return E_NOTIMPL;
    }

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(LockObject)(
         /*[out, retval]*/ IUnknown** ppLock
                         )
    {
        return E_NOTIMPL;
    }

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(Initialize)(void)
    {
        return E_NOTIMPL;
    }

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(Shutdown)(void)
    {
        return E_NOTIMPL;
    }

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(Enable)(void)
    {
        return E_NOTIMPL;
    }

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(Disable)(void)
    {
        return E_NOTIMPL;
    }

protected:

    //////////////////////////////////////////////////////////////////////////
    // Object initialization function
    //////////////////////////////////////////////////////////////////////////
    virtual HRESULT InternalInitialize(
                               /*[in]*/ PPROPERTYBAG pProperties
                                      )
    {
        HRESULT hr = S_OK;
        _ASSERT( pProperties.IsValid() );
        if ( ! pProperties.IsValid() )
        { 
            SATraceString("CApplianceObject::InternalInitialize() - Failed - Invalid property bag...");
            return E_FAIL;
        }
        pProperties->getLocation(m_PropertyBagLocation);
        wchar_t szPropertyName[MAX_PATH + 1];
        if ( MAX_PATH < pProperties->getMaxPropertyName() )
        { 
            SATraceString("CApplianceObject::InternalInitialize() - Failed - Max property name > MAX_PATH...");
            return E_FAIL; 
        }
        pProperties->reset();
        do
        {
            {
                _variant_t vtPropertyValue;
                if ( pProperties->current(szPropertyName, &vtPropertyValue) )
                {
                    pair<PropertyMapIterator, bool> thePair = 
                    m_Properties.insert(PropertyMap::value_type(szPropertyName, vtPropertyValue));
                    if ( false == thePair.second )
                    {
                        SATraceString("CApplianceObject::InternalInitialize() - Failed - map.insert() failed...");
                        PropertyMapIterator p = m_Properties.begin();
                        while ( p != m_Properties.end() )
                        { p = m_Properties.erase(p); }
                        hr = E_FAIL;
                        break;    
                    }
                }
            }

        } while ( pProperties->next() );

        return hr;
    }

    //////////////////////////////////////////////////////////////////////////
    bool AddPropertyInternal(BSTR bstrPropertyName, VARIANT* pPropertyValue)
    {
        pair<PropertyMapIterator, bool> thePair = 
        m_Properties.insert(PropertyMap::value_type(bstrPropertyName, pPropertyValue));
        if ( false == thePair.second )
        {
            SATraceString("CApplianceObject::AddPropertyInternal() - Failed - map.insert() failed...");
        }
        return thePair.second;
    }

    //////////////////////////////////////////////////////////////////////////
    bool RemovePropertyInternal(BSTR bstrPropertyName)
    {
        bool bReturn = false;

        PropertyMapIterator p = m_Properties.find(bstrPropertyName);
        if ( p != m_Properties.end() )
        {
            m_Properties.erase(p);
            bReturn = true;
        }
        else
        {
            SATraceString("CApplianceObject::RemovePropertyInternal() - Failed - map.find() failed...");
        }

        return bReturn;
    }

    //////////////////////////////////////////////////////////////////////////
    bool GetPropertyInternal(BSTR bstrPropertyName, VARIANT* pPropertyValue)
    {
        bool bReturn = false;

        PropertyMapIterator p = m_Properties.find(bstrPropertyName);
        if ( p != m_Properties.end() )
        {
            HRESULT hr = VariantCopy(pPropertyValue, &((*p).second));
            if ( SUCCEEDED(hr) )
            { 
                bReturn = true;
            }
            else
            {
                SATracePrintf("CApplianceObject::GetPropertyInternal() - Failed - VariantCopy() returned: %lx...", hr);
            }
        }
        else
        {
            SATracePrintf("CApplianceObject::GetPropertyInternal() - Failed - Could not find property '%ls'...", bstrPropertyName);
        }
        return bReturn;
    }

    //////////////////////////////////////////////////////////////////////////
    bool PutPropertyInternal(BSTR bstrPropertyName, VARIANT* pPropertyValue )
    {
        bool bReturn = false;

        PropertyMapIterator p = m_Properties.find(bstrPropertyName);
        if ( p != m_Properties.end() )
        {
            HRESULT hr = VariantCopy(&((*p).second), pPropertyValue);
            if ( SUCCEEDED(hr) )
            { 
                bReturn = true;    
            }
            else
            {
                SATracePrintf("CApplianceObject::PutPropertyInternal() - Failed - VariantCopy() returned: %lx...", hr);
            }
        }
        else
        {
            SATracePrintf("CApplianceObject::PutPropertyInternal() - Failed - Could not find property '%ls'...", bstrPropertyName);
        }
        return bReturn;
    }


    //////////////////////////////////////////////////////////////////////////
    bool SavePropertiesInternal()
    {
        bool bReturn = false;

        do
        {
            PPROPERTYBAG pBag = ::MakePropertyBag(
                                                  PROPERTY_BAG_REGISTRY,
                                                  m_PropertyBagLocation
                                                 );
            if ( ! pBag.IsValid() )
            {
                SATraceString("CApplianceObject::SavePropertiesInternal() - Failed - Could not create a propert bag...");
                break;
            }

            if ( ! pBag->open() )
            {
                SATraceString("CApplianceObject::SavePropertiesInternal() - Failed - Could not open property bag...");
                break;
            }

            PropertyMapIterator p = m_Properties.begin();
            while( p != m_Properties.end() )
            {
                if ( ! pBag->put(((*p).first).c_str(), &((*p).second)) )
                {
                    SATracePrintf("CApplianceObject::SavePropertiesInternal() - Failed - could not put property '%ls'...", ((*p).first).c_str());
                    break;
                }                
                p++;
            }

            if ( p == m_Properties.end() )
            {
                if ( ! pBag->save() )
                {
                    SATraceString("CApplianceObject::SavePropertiesInternal() - Failed - could not persist property bag contents...");
                    break;
                }
            }

            bReturn = true;
        
        } while ( FALSE );

        return bReturn;
    }


private:

    // Property Map
    typedef map<wstring, _variant_t>     PropertyMap;
    typedef PropertyMap::iterator         PropertyMapIterator;

    CLocationInfo        m_PropertyBagLocation;
    PropertyMap            m_Properties;
};


#endif // __INC_BASE_APPLIANCE_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\componentfactorymap.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      componentfactory.h
//
// Project:     Chameleon
//
// Description: Component Factory Class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_COMPONENT_FACTORY_MAP_H_
#define __INC_COMPONENT_FACTORY_MAP_H_

#include "wbemalert.h"
#include "wbemservice.h"
#include "wbemtask.h"
#include "wbemalertmgr.h"
#include "wbemservicemgr.h"
#include "wbemtaskmgr.h"
#include "wbemusermgr.h"

//////////////////////////////////////////////////////////////////////////////
BEGIN_COMPONENT_FACTORY_MAP(TheFactoryMap)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_WBEM_ALERT_MGR_FACTORY,    CWBEMAlertMgr)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_WBEM_SERVICE_MGR_FACTORY,    CWBEMServiceMgr)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_WBEM_TASK_MGR_FACTORY,     CWBEMTaskMgr)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_WBEM_USER_MGR_FACTORY,        CWBEMUserMgr)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_WBEM_ALERT_FACTORY,        CWBEMAlert)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_WBEM_SERVICE_FACTORY,        CWBEMService)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_WBEM_TASK_FACTORY,            CWBEMTask)
END_COMPONENT_FACTORY_MAP()

#endif // __INC_COMPONENT_FACTORY_MAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by appmgr.rc
//
#define IDS_SERVICENAME                 100
#define IDR_Appmgr                      100
#define IDR_APPLIANCEMANAGER            101
#define IDR_WBEMCONTEXT                 102
#define IDS_SERVICENICENAME             104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\resourceretriever.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      resourceretriever.h
//
// Project:     Chameleon
//
// Description: Resource Retriever Class and Helper Functions 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_RESOURCE_RETRIEVER_H_
#define __INC_RESOURCE_RETRIEVER_H_

#include "resource.h"
#include "appmgr.h"
#include <satrace.h>
#include <propertybag.h>
#include <comdef.h>
#include <comutil.h>
#include <varvec.h>

#pragma warning( disable : 4786 )
#include <list>
#include <vector>
using namespace std;

//////////////////////////////////////////////////////////////////////////////

#define        PROPERTY_RETRIEVER_PROGID    L"RetrieverProgID"

class CResourceRetriever
{

public:

    // Constructors
    CResourceRetriever() { }
    CResourceRetriever(PPROPERTYBAG pPropertyBag) throw (_com_error);

    // Destructor
    ~CResourceRetriever() { }

    // Retrieve resource objects of the specified type
    HRESULT GetResourceObjects(
                       /*[in]*/ VARIANT*   pResourceTypes,
                      /*[out]*/ IUnknown** ppEnumVARIANT
                              ) throw (_com_error);

private:
    
    CResourceRetriever(const CResourceRetriever& rhs);
    CResourceRetriever& operator = (const CResourceRetriever& rhs);

    _variant_t                        m_vtResourceTypes;
    CComPtr<IResourceRetriever>        m_pRetriever;
};

typedef CResourceRetriever* PRESOURCERETRIEVER;


//////////////////////////////////////////////////////////////////////////////
// Global Resource Retriever Helper Functions

HRESULT LocateResourceObjects(
                       /*[in]*/ VARIANT*               pResourceTypes,
                      /*[in]*/ PRESOURCERETRIEVER  pRetriever,
                     /*[out]*/ IEnumVARIANT**       ppEnum 
                             );


HRESULT LocateResourceObject(
                     /*[in]*/ LPCWSTR             szResourceType,
                     /*[in]*/ LPCWSTR              szResourceName,
                     /*[in]*/ LPCWSTR              szResourceNameProperty,
                     /*[in]*/ PRESOURCERETRIEVER  pRetriever,
                    /*[out]*/ IApplianceObject**  ppResourceObj 
                            );


#endif // __INC_RESOURCE_RETRIEVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\resourceretriever.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      resourceretriever.cpp
//
// Project:     Chameleon
//
// Description: Resource Retriever Class and Helper Functions  
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resourceretriever.h"

//////////////////////////////////////////////////////////////////////////
// CResourceRetriever Class Implementation
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// 
// Function:    CResourceRetriever
//
// Synoposis:    Constructor - Initialize the resource retriever component
//
//////////////////////////////////////////////////////////////////////////
CResourceRetriever::CResourceRetriever(PPROPERTYBAG pRetrieverProperties) 
{
    // Create an instance of the specified retriever and obtain its supported resource types.
    // Note that the progID of the retriever is passed in via the property bag parameter

    _variant_t vtProgID;
    _bstr_t bstrProgID = PROPERTY_RETRIEVER_PROGID;
    if (! pRetrieverProperties->get(bstrProgID, &vtProgID) )
    {
        SATraceString("CResourceRetriever::CResourceRetriever() - Failed - Could not get retriever's ProgID...");
        throw _com_error(E_FAIL);
    }
    CLSID clsid;
    if ( FAILED(::CLSIDFromProgID(V_BSTR(&vtProgID), &clsid)) )
    {
        SATraceString("CResourceRetriever::CResourceRetriever() - Failed - Could not get retriever's CLSID...");
        throw _com_error(E_FAIL);
    }
    CComPtr<IResourceRetriever> pRetriever;
    if ( FAILED(CoCreateInstance(
                                   clsid, 
                                   NULL, 
                                   CLSCTX_INPROC_SERVER, 
                                   IID_IResourceRetriever, 
                                   (void**)&pRetriever
                                 )) )
    {
        SATraceString("CResourceRetriever::CResourceRetriever() - Failed - Could not create retriever component...");
        throw _com_error(E_FAIL);
    }
    if ( FAILED(pRetriever->GetResourceTypes(&m_vtResourceTypes)) )
    {
        SATraceString("CResourceRetriever::CResourceRetriever() - Failed - Could not get resource types from retriever...");
        throw _com_error(E_FAIL);
    }
    m_pRetriever = pRetriever;
}


//////////////////////////////////////////////////////////////////////////
// 
// Function:    GetResourceObjects()
//
// Synoposis:    Obtain an enumerator for iterating through a collection
//                of IApplianceObject interface pointers.
//
//////////////////////////////////////////////////////////////////////////
HRESULT CResourceRetriever::GetResourceObjects(
                                       /*[in]*/ VARIANT*   pResourceTypes,
                                      /*[out]*/ IUnknown** ppEnumVARIANT
                                              )
{
    HRESULT hr = E_FAIL;    

    // May only be asking for a subset of the supported types...
    CVariantVector<BSTR> SupportedTypes(&m_vtResourceTypes);
    CVariantVector<BSTR> RequestedTypes(pResourceTypes);
    int i = 0, j = 0, k = 0;
    vector<int> ToCopy;
    while ( i < RequestedTypes.size() )
    {
        j = 0;
        while ( j < SupportedTypes.size() )
        {
            if ( ! lstrcmp(RequestedTypes[i], SupportedTypes[j]) )
            {
                ToCopy.push_back(j);
                k++;
            }
            j++;
        }
        i++;
    }
    if ( ToCopy.size() )
    {            
        _variant_t vtRetrievalTypes;
        CVariantVector<BSTR> RetrievalTypes(&vtRetrievalTypes, ToCopy.size());
        i = 0;
        while ( i < ToCopy.size() )
        {
            RetrievalTypes[i] = SysAllocString(SupportedTypes[ToCopy[i]]);
            if ( NULL == RetrievalTypes[i] )
            { break; }
            i++;
        }
        try 
        {
            *ppEnumVARIANT = NULL;
            hr = m_pRetriever->GetResources(&vtRetrievalTypes, ppEnumVARIANT);
            if ( SUCCEEDED(hr) )
            { _ASSERT( NULL != *ppEnumVARIANT); }
        }
        catch(...)
        {
            SATraceString("CResourceRetriever::GetResourceObjects() - Info - Caught unhandled exception...");
        }
    }
    else
    {
        SATraceString("CResourceRetriever::GetResourceObjects() - Failed - Unsupported resource type...");
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
// Resource Retriever Helper Functions
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// 
//    Function:    LocateResourceObjects()
//
//  Synopsis:    Get a collection of resource objects given a set of resource
//                types and a resource retriever.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT LocateResourceObjects(
                       /*[in]*/ VARIANT*               pResourceTypes,
                      /*[in]*/ PRESOURCERETRIEVER  pRetriever,
                     /*[out]*/ IEnumVARIANT**       ppEnum 
                             )
{
    HRESULT hr = E_FAIL;
    CComPtr<IUnknown> pUnkn;

    if ( VT_BSTR == V_VT(pResourceTypes) )
    {
        // Convert pResourceTypes into a safearay of BSTRs
        _variant_t vtResourceTypeArray;
        CVariantVector<BSTR> ResourceType(&vtResourceTypeArray, 1);
        ResourceType[0] = SysAllocString(V_BSTR(pResourceTypes));
        if ( NULL != ResourceType[0] )
        {
            // Ask the resource retriever for objects of the specified resource type
            hr = pRetriever->GetResourceObjects(&vtResourceTypeArray, &pUnkn);
        }            
    }
    else
    {
        // Ask the resource retriever for objects of the specified resource type
        hr = pRetriever->GetResourceObjects(pResourceTypes, &pUnkn);
    }
    if ( SUCCEEDED(hr) )
    { 
        // Retreiver returned objects of the support types so get the 
        // IEnumVARIANT interface on the returned enumerator
        hr = pUnkn->QueryInterface(IID_IEnumVARIANT, (void**)ppEnum);
        if ( FAILED(hr) )
        { 
            SATracePrintf("CWBEMResourceMgr::LocateResourceObject() - Failed - QueryInterface(IEnumVARIANT) returned %lx...", hr);
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// 
//    Function:    LocateResourceObject()
//
//  Synopsis:    Get a resource object given a resource type, resource name,
//                resource name property and resource retriever
//
///////////////////////////////////////////////////////////////////////////////
HRESULT LocateResourceObject(
                     /*[in]*/ LPCWSTR             szResourceType,
                     /*[in]*/ LPCWSTR              szResourceName,
                     /*[in]*/ LPCWSTR              szResourceNameProperty,
                     /*[in]*/ PRESOURCERETRIEVER  pRetriever,
                    /*[out]*/ IApplianceObject**  ppResourceObj 
                                          )
{
    // Ask the resource retriever for objects of the specified resource type
    CComPtr<IEnumVARIANT> pEnum;
    _variant_t vtResourceType = szResourceType;
    HRESULT hr = LocateResourceObjects(&vtResourceType, pRetriever, &pEnum);
    if ( SUCCEEDED(hr) )
    { 
        // Retreiver returned objects of the support types so attempt to locate
        // the object specified by the caller.

        _variant_t    vtDispatch;
        DWORD        dwRetrieved = 1;
        _bstr_t     bstrResourceNameProperty = szResourceNameProperty;

        hr = pEnum->Next(1, &vtDispatch, &dwRetrieved);
        if ( FAILED(hr) )
        { 
            SATracePrintf("CWBEMResourceMgr::LocateResourceObject() - Failed - IEnumVARIANT::Next(1) returned %lx...", hr);
        }
        else
        {
            while ( S_OK == hr )
            {
                {
                    CComPtr<IApplianceObject> pResourceObj;
                    hr = vtDispatch.pdispVal->QueryInterface(IID_IApplianceObject, (void**)&pResourceObj);
                    if ( FAILED(hr) )
                    { 
                        SATracePrintf("CWBEMResourceMgr::LocateResourceObject() - Failed - QueryInterface(IApplianceObject) returned %lx...", hr);
                        break; 
                    }
                    _variant_t vtResourceNameValue;
                    hr = pResourceObj->GetProperty(bstrResourceNameProperty, &vtResourceNameValue);
                    if ( FAILED(hr) )
                    { 
                        SATracePrintf("CWBEMResourceMgr::LocateResourceObject() - Failed - IApplianceObject::GetProperty() returned %lx...", hr);
                        break; 
                    }
                    if ( ! lstrcmp(V_BSTR(&vtResourceNameValue), szResourceName) )
                    {    
                        (*ppResourceObj = pResourceObj)->AddRef();
                        hr = S_OK;
                        break;
                    }
                }                            

                vtDispatch.Clear();
                dwRetrieved = 1;
                hr = pEnum->Next(1, &vtDispatch, &dwRetrieved);
                if ( FAILED(hr) )
                {
                    SATracePrintf("CWBEMResourceMgr::LocateResourceObject() - Failed - IEnumVARIANT::Next(2) returned %lx...", hr);
                    break;
                }
            }
        }
    }

    if ( S_FALSE == hr )
    { hr = DISP_E_MEMBERNOTFOUND; }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemalert.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemalert.h
//
// Project:     Chameleon
//
// Description: WBEM Appliance Alert Object Class 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_ALERT_WBEM_OBJECT_H_
#define __INC_ALERT_WBEM_OBJECT_H_

#include "resource.h"
#include "applianceobjectbase.h"

#define     CLASS_WBEM_ALERT_FACTORY    L"Microsoft_SA_Alert_Object"

//////////////////////////////////////////////////////////////////////////////
class CWBEMAlert : public CApplianceObject
{

public:

    CWBEMAlert() { }
    ~CWBEMAlert() { }

BEGIN_COM_MAP(CWBEMAlert)
    COM_INTERFACE_ENTRY(IApplianceObject)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CWBEMAlert, IApplianceObject)

    //////////////////////////////////////////////////////////////////////////
    // IApplianceObject Interface
    //////////////////////////////////////////////////////////////////////////

    STDMETHODIMP GetProperty(
                     /*[in]*/ BSTR     pszPropertyName, 
            /*[out, retval]*/ VARIANT* pPropertyValue
                            );


    STDMETHODIMP PutProperty(
                     /*[in]*/ BSTR     pszPropertyName, 
                     /*[in]*/ VARIANT* pPropertyValue
                            );

    //////////////////////////////////////////////////////////////////////////
    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              );
};

#endif // __INC_ALERT_WBEM_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__086053C1_BF0B_11D2_90B6_00AA00A71DCA__INCLUDED_)
#define AFX_STDAFX_H__086053C1_BF0B_11D2_90B6_00AA00A71DCA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

// #define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
    HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
    HRESULT UnregisterServer();
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
    LONG Unlock();
    void LogEvent(
                 /*[in]*/ WORD        wMsgType,
                 /*[in]*/ LONG        lMsgID,
                 /*[in]*/ DWORD        dwMsgParamCount,
                 /*[in]*/ LPCWSTR*    pszMsgParams,
                 /*[in]*/ DWORD        dwDataSize,
                 /*[in]*/ BYTE*        pData
                 );
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    TCHAR m_szServiceNiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
    BOOL m_bService;
};

extern CServiceModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__086053C1_BF0B_11D2_90B6_00AA00A71DCA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbembase.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbembase.h
//
// Project:     Chameleon
//
// Description: WBEM Object Default Implementation
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_BASE_WBEM_OBJECT_H_
#define __INC_BASE_WBEM_OBJECT_H_

#include "resource.h"
#include "appmgr.h"
#include <satrace.h>
#include <basedefs.h>
#include <atlhlpr.h>
#include <propertybagfactory.h>
#include <componentfactory.h>
#include <comdef.h>
#include <comutil.h>
#include <wbemcli.h>
#include <wbemprov.h>

#pragma warning( disable : 4786 )
#include <string>
#include <map>
using namespace std;

#define BEGIN_OBJECT_PROPERTY_MAP(x)    static LPCWSTR x[] = { 

#define DEFINE_OBJECT_PROPERTY(x)        x,

#define END_OBJECT_PROPERTY_MAP()        NULL };

//////////////////////////////////////////////////////////////////////////////
// CWBEMProvider - Default WBEM Class Provider Implementation

class ATL_NO_VTABLE CWBEMProvider :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IWbemServices
{

public:

    // Constructor
    CWBEMProvider() { }

    // Destructor
    virtual ~CWBEMProvider() { }

// Derived Classes Need to contain the following ATL Interface Map
//BEGIN_COM_MAP(CDerivedClassName)
//    COM_INTERFACE_ENTRY(IWbemServices)
//END_COM_MAP()


    // ==========================
    // IWbemServices Interface
    // ==========================

    // Context
    // =======

    STDMETHOD(OpenNamespace)(
        /*[in]*/             const BSTR        strNamespace,
        /*[in]*/             long              lFlags,
        /*[in]*/             IWbemContext*     pCtx,
        /*[out, OPTIONAL]*/  IWbemServices**   ppWorkingNamespace,
        /*[out, OPTIONAL]*/  IWbemCallResult** ppResult
                           )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(CancelAsyncCall)(
                      /*[in]*/ IWbemObjectSink* pSink
                              )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(QueryObjectSink)(
                       /*[in]*/    long              lFlags,
                      /*[out]*/ IWbemObjectSink** ppResponseHandler
                              )
      {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }


    // Classes and instances
    // =====================

    STDMETHOD(GetObject)(
                /*[in]*/    const BSTR         strObjectPath,
                /*[in]*/    long               lFlags,
                /*[in]*/    IWbemContext*      pCtx,
        /*[out, OPTIONAL]*/ IWbemClassObject** ppObject,
        /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                        )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

        
    STDMETHOD(GetObjectAsync)(
                     /*[in]*/  const BSTR       strObjectPath,
                     /*[in]*/  long             lFlags,
                     /*[in]*/  IWbemContext*    pCtx,        
                     /*[in]*/  IWbemObjectSink* pResponseHandler
                             )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    // Class manipulation.
    // ===================

    STDMETHOD(PutClass)(
               /*[in]*/     IWbemClassObject* pObject,
               /*[in]*/     long              lFlags,
               /*[in]*/     IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                       )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(PutClassAsync)(
                    /*[in]*/ IWbemClassObject* pObject,
                    /*[in]*/ long              lFlags,
                    /*[in]*/ IWbemContext*     pCtx,        
                    /*[in]*/ IWbemObjectSink*  pResponseHandler
                           )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(DeleteClass)(
        /*[in]*/            const BSTR        strClass,
        /*[in]*/            long              lFlags,
        /*[in]*/            IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                          )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }


    STDMETHOD(DeleteClassAsync)(
                       /*[in]*/ const BSTR       strClass,
                       /*[in]*/ long             lFlags,
                       /*[in]*/ IWbemContext*    pCtx,        
                       /*[in]*/ IWbemObjectSink* pResponseHandler
                               )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(CreateClassEnum)(
                      /*[in]*/ const BSTR             strSuperclass,
                      /*[in]*/ long                   lFlags,
                      /*[in]*/ IWbemContext*          pCtx,        
                     /*[out]*/ IEnumWbemClassObject** ppEnum
                             )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(CreateClassEnumAsync)(
                           /*[in]*/  const BSTR       strSuperclass,
                           /*[in]*/  long             lFlags,
                           /*[in]*/  IWbemContext*    pCtx,        
                           /*[in]*/  IWbemObjectSink* pResponseHandler
                                  )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }


    // Instances
    // =========

    STDMETHOD(PutInstance)(
        /*[in]*/            IWbemClassObject* pInst,
        /*[in]*/            long              lFlags,
        /*[in]*/            IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                         )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(PutInstanceAsync)(
                       /*[in]*/ IWbemClassObject* pInst,
                       /*[in]*/ long              lFlags,
                       /*[in]*/ IWbemContext*     pCtx,        
                       /*[in]*/ IWbemObjectSink*  pResponseHandler
                              )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(DeleteInstance)(
        /*[in]*/              const BSTR        strObjectPath,
        /*[in]*/              long              lFlags,
        /*[in]*/              IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/   IWbemCallResult** ppCallResult        
                            )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(DeleteInstanceAsync)(
                          /*[in]*/ const BSTR       strObjectPath,
                          /*[in]*/ long             lFlags,
                          /*[in]*/ IWbemContext*    pCtx,        
                          /*[in]*/ IWbemObjectSink* pResponseHandler
                                 )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(CreateInstanceEnum)(
                         /*[in]*/ const BSTR             strClass,
                         /*[in]*/ long                   lFlags,
                         /*[in]*/ IWbemContext*          pCtx,        
                        /*[out]*/ IEnumWbemClassObject** ppEnum
                                )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(CreateInstanceEnumAsync)(
                              /*[in]*/ const BSTR       strClass,
                              /*[in]*/ long             lFlags,
                              /*[in]*/ IWbemContext*    pCtx,        
                              /*[in]*/ IWbemObjectSink* pResponseHandler
                                     )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    // Queries
    // =======

    STDMETHOD(ExecQuery)(
                 /*[in]*/ const BSTR             strQueryLanguage,
                 /*[in]*/ const BSTR             strQuery,
                 /*[in]*/ long                   lFlags,
                 /*[in]*/ IWbemContext*          pCtx,        
                /*[out]*/ IEnumWbemClassObject** ppEnum
                        )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(ExecQueryAsync)(
                     /*[in]*/ const BSTR       strQueryLanguage,
                     /*[in]*/ const BSTR       strQuery,
                     /*[in]*/ long             lFlags,
                     /*[in]*/ IWbemContext*    pCtx,        
                     /*[in]*/ IWbemObjectSink* pResponseHandler
                            )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(ExecNotificationQuery)(
                            /*[in]*/ const BSTR             strQueryLanguage,
                            /*[in]*/ const BSTR             strQuery,
                            /*[in]*/ long                   lFlags,
                            /*[in]*/ IWbemContext*          pCtx,        
                           /*[out]*/ IEnumWbemClassObject** ppEnum
                                    )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(ExecNotificationQueryAsync)(
                                 /*[in]*/ const BSTR       strQueryLanguage,
                                 /*[in]*/ const BSTR       strQuery,
                                 /*[in]*/ long             lFlags,
                                 /*[in]*/ IWbemContext*    pCtx,        
                                 /*[in]*/ IWbemObjectSink* pResponseHandler
                                        )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    // Methods
    // =======

    STDMETHOD(ExecMethod)(
        /*[in]*/            const BSTR         strObjectPath,
        /*[in]*/            const BSTR         strMethodName,
        /*[in]*/            long               lFlags,
        /*[in]*/            IWbemContext*      pCtx,        
        /*[in]*/            IWbemClassObject*  pInParams,
        /*[out, OPTIONAL]*/ IWbemClassObject** ppOutParams,
        /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                        )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    STDMETHOD(ExecMethodAsync)(
                      /*[in]*/ const BSTR        strObjectPath,
                      /*[in]*/ const BSTR        strMethodName,
                      /*[in]*/ long              lFlags,
                      /*[in]*/ IWbemContext*     pCtx,        
                      /*[in]*/ IWbemClassObject* pInParams,
                      /*[in]*/ IWbemObjectSink*  pResponseHandler     
                              )
    {
        return WBEM_E_PROVIDER_NOT_CAPABLE;
    }

    //////////////////////////////////////////////////////////////////////////
    // Provider Initialization

    HRESULT InternalInitialize(
                       /*[in]*/ LPCWSTR      pszClassId,
                       /*[in]*/ LPCWSTR         pszObjectNameProperty,
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              )
    {
        HRESULT hr = S_OK; 

        TRY_IT

        // Initialize each object from the specified object container. Note
        // that we don't consider it a failure if an object container or
        // the objects therein cannot be initialized. 
        
        _ASSERT( pPropertyBag->IsContainer() );
        PPROPERTYBAGCONTAINER pBagObjMgr = pPropertyBag->getContainer();
        if ( ! pBagObjMgr.IsValid() )
        { 
            SATraceString("CWbemBase::InternalInitialize() - Info - Invalid property bag container...");
            return S_OK; 
        }
        if ( ! pBagObjMgr->open() )
        { 
            SATraceString("CWbemBase::InternalInitialize() - Info - Could not open property bag container...");
            return S_OK; 
        }
        
        if ( pBagObjMgr->count() )
        {
            pBagObjMgr->reset();
            do
            {
                PPROPERTYBAG pBagObj = pBagObjMgr->current();
                if ( pBagObj.IsValid() )
                { 
                    if ( pBagObj->open() )
                    { 
                        CComPtr<IApplianceObject> pObj = 
                        (IApplianceObject*) ::MakeComponent(
                                                             pszClassId,
                                                             pBagObj
                                                           );

                        if ( NULL != (IApplianceObject*) pObj )
                        { 
                            _variant_t vtObjectNameProperty;
                            if ( pBagObj->get(pszObjectNameProperty, &vtObjectNameProperty) )
                            {
                                _ASSERT( VT_BSTR == V_VT(&vtObjectNameProperty) );
                                if ( VT_BSTR == V_VT(&vtObjectNameProperty) )
                                {
                                    pair<ObjMapIterator, bool> thePair = 
                                    m_ObjMap.insert(ObjMap::value_type(V_BSTR(&vtObjectNameProperty), pObj));
                                    if ( false == thePair.second )
                                    { 
                                        SATraceString("CWbemBase::InternalInitialize() - Info - map.insert() failed...");
                                    }
                                }
                                else
                                {
                                    SATracePrintf("CWbemBase::InternalInitialize() - Info - Invalid type for property '%ls'...", pszObjectNameProperty);
                                }
                            }
                            else
                            {
                                SATracePrintf("CWbemBase::InternalInitialize() - Info - Could not get property '%ls'...", pszObjectNameProperty);
                            }
                        }
                    }
                    else
                    {
                        SATracePrintf("CWbemBase::InternalInitialize() - Info - Could not open property bag: '%ls'...", pPropertyBag->getName());
                    }
                }
                else
                {
                    SATraceString("CWbemBase::InternalInitialize() - Info - Invalid property bag...");
                }

            } while ( pBagObjMgr->next() );
        }
        
        CATCH_AND_SET_HR

        if ( FAILED(hr) )
        {
            // Caught an unhandled exception this is a critical error...
            // Free any objects we've created...
            ObjMapIterator p = m_ObjMap.begin();
            while (  p != m_ObjMap.end() )
            { p = m_ObjMap.erase(p); }
            hr = E_FAIL;
        }

        return hr;
    }

protected:

    ///////////////////////////////////////////////////////////////////////////////
    HRESULT InitWbemObject(
                   /*[in]*/ LPCWSTR*          pPropertyNames,
                   /*[in]*/ IApplianceObject* pAppObj, 
                   /*[in]*/ IWbemClassObject* pWbemObj
                          )
    {
        // Initialize a WBEM object from an appliance object using
        // the specified property set...
        HRESULT hr = WBEM_S_NO_ERROR;
        int i = 0;
        while ( pPropertyNames[i] )
        {
            {
                _variant_t vtPropertyValue;
                _bstr_t bstrPropertyName = (LPCWSTR)pPropertyNames[i];
                hr = pAppObj->GetProperty(
                                          bstrPropertyName, 
                                          &vtPropertyValue
                                         );
                if ( FAILED(hr) )
                { 
                    SATracePrintf("CWbemBase::InitWbemObject() - IApplianceObject::GetProperty() - Failed on property: %ls...", pPropertyNames[i]);
                    break; 
                }

                hr = pWbemObj->Put(
                                    bstrPropertyName, 
                                    0, 
                                    &vtPropertyValue, 
                                    0
                                  );
                if ( FAILED(hr) )
                { 
                    SATracePrintf("CWbemBase::InitWbemObject() - IWbemClassObject::Put() - Failed on property: %ls...", pPropertyNames[i]);
                    break; 
                }

            }
            i++;
        }
        return hr;
    }

    ///////////////////////////////////////////////////////////////////////////////
    HRESULT InitApplianceObject(
                        /*[in]*/ LPCWSTR*           pPropertyNames,
                        /*[in]*/ IApplianceObject* pAppObj, 
                        /*[in]*/ IWbemClassObject* pWbemObj
                               )
    {
        // Initialize an appliance object from a WBEM object using
        // the specified property set...
        HRESULT hr = WBEM_S_NO_ERROR;
        _variant_t vtPropertyValue;
        _variant_t vtPropertyName;
        int i = 0;
        while ( pPropertyNames[i] )
        {
            {
                _variant_t vtPropertyValue;
                _bstr_t bstrPropertyName = (LPCWSTR) pPropertyNames[i];
                hr = pWbemObj->Get(
                                    bstrPropertyName, 
                                    0, 
                                    &vtPropertyValue, 
                                    0, 
                                    0
                                  );
                if ( FAILED(hr) )
                { 
                    SATracePrintf("CWbemBase::InitApplianceObject() - IWbemClassObject::Get() - Failed on property: %ls...", pPropertyNames[i]);
                    break; 
                }

                hr = pAppObj->PutProperty(
                                          bstrPropertyName, 
                                          &vtPropertyValue
                                         );
                if ( FAILED(hr) )
                { 
                    SATracePrintf("CWbemBase::InitApplianceObject() - IApplianceObject::PutProperty() - Failed on property: %ls...", pPropertyNames[i]);
                    break; 
                }
                i++;
            }
        }
        return hr;
    }

    //////////////////////////////////////////////////////////////////////////
    typedef map< wstring, CComPtr<IApplianceObject> >  ObjMap;
    typedef ObjMap::iterator                           ObjMapIterator;

    ObjMap        m_ObjMap;
};


#endif // __INC_BASE_WBEM_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemalert.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemalert.cpp
//
// Project:     Chameleon
//
// Description: WBEM Appliance Alert Object Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wbemalert.h"

static _bstr_t bstrAlertStrings = PROPERTY_ALERT_STRINGS;
static _bstr_t bstrAlertData = PROPERTY_ALERT_DATA;
static _bstr_t bstrAlertType = PROPERTY_ALERT_TYPE;
static _bstr_t bstrAlertID = PROPERTY_ALERT_ID;
static _bstr_t bstrAlertTTL = PROPERTY_ALERT_TTL;
static _bstr_t bstrAlertCookie = PROPERTY_ALERT_COOKIE;
static _bstr_t bstrAlertSource = PROPERTY_ALERT_SOURCE;
static _bstr_t bstrAlertLog = PROPERTY_ALERT_LOG;
static _bstr_t bstrAlertFlags = PROPERTY_ALERT_FLAGS;

///////////////////////////////////////////////////////////////////////////////
// IApplianceObject Interface Implmentation - see ApplianceObject.idl
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetProperty()
//
// Synopsis:    Get a specified alert object property
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMAlert::GetProperty(
                            /*[in]*/ BSTR     pszPropertyName, 
                   /*[out, retval]*/ VARIANT* pPropertyValue
                                   )
{
    HRESULT hr = E_FAIL;

    CLockIt theLock(*this);

    TRY_IT

    if ( GetPropertyInternal(pszPropertyName, pPropertyValue) )
    { 
        hr = WBEM_S_NO_ERROR;
    }

    CATCH_AND_SET_HR

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMAlert::PutProperty(
                            /*[in]*/ BSTR     pszPropertyName, 
                            /*[in]*/ VARIANT* pPropertyValue
                                   )
{
    HRESULT hr = E_FAIL;

    CLockIt theLock(*this);

    TRY_IT

    if ( PutPropertyInternal(pszPropertyName, pPropertyValue) )
    { 
        hr = WBEM_S_NO_ERROR;
    }

    CATCH_AND_SET_HR

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    InternalInitialize()
//
// Synopsis:    Function called by the component factory that enables the
//                component to load its state from the given property bag.
//
//////////////////////////////////////////////////////////////////////////

HRESULT CWBEMAlert::InternalInitialize(
                                /*[in]*/ PPROPERTYBAG pPropertyBag
                                      )
{
    _variant_t vtPropertyValue;    // VT_EMPTY

    if ( ! AddPropertyInternal(bstrAlertStrings, &vtPropertyValue) )
    { return WBEM_E_FAILED; }

    if ( ! AddPropertyInternal(bstrAlertData, &vtPropertyValue) )
    { return WBEM_E_FAILED; }

    if ( ! AddPropertyInternal(bstrAlertType, &vtPropertyValue) )
    { return WBEM_E_FAILED; }

    if ( ! AddPropertyInternal(bstrAlertID, &vtPropertyValue) )
    { return WBEM_E_FAILED; }

    if ( ! AddPropertyInternal(bstrAlertTTL, &vtPropertyValue) )
    { return WBEM_E_FAILED; }
    
    if ( ! AddPropertyInternal(bstrAlertCookie, &vtPropertyValue) )
    { return WBEM_E_FAILED; }

    if ( ! AddPropertyInternal(bstrAlertSource, &vtPropertyValue) )
    { return WBEM_E_FAILED; }

    if ( ! AddPropertyInternal(bstrAlertLog, &vtPropertyValue) )
    { return WBEM_E_FAILED; }

    if ( ! AddPropertyInternal(bstrAlertFlags, &vtPropertyValue) )
    { return WBEM_E_FAILED; }

    return WBEM_S_NO_ERROR;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemalertmgr.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemalertmgr.h
//
// Project:     Chameleon
//
// Description: WBEM Appliance Alert Object Class 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_ALERT_WBEM_OBJECT_MGR_H_
#define __INC_ALERT_WBEM_OBJECT_MGR_H_

#include "resource.h"
#include "wbembase.h"
#include <workerthread.h>

#define        CLASS_WBEM_ALERT_MGR_FACTORY    L"Microsoft_SA_Alert"

#define        PROPERTY_ALERT_PRUNE_INTERVAL    L"PruneInterval"
#define        ALERT_PRUNE_INTERVAL_DEFAULT    500    // Default - 1/2 second

//////////////////////////////////////////////////////////////////////////////
class CWBEMAlertMgr : public CWBEMProvider
{

public:

    CWBEMAlertMgr();
    ~CWBEMAlertMgr();

BEGIN_COM_MAP(CWBEMAlertMgr)
    COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CWBEMAlertMgr, IWbemServices)

    //////////////////////////////////////////////////////////////////////////
    // IWbemServices Interface Methods
    //////////////////////////////////////////////////////////////////////////
    
    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP GetObjectAsync(
                        /*[in]*/  const BSTR       strObjectPath,
                        /*[in]*/  long             lFlags,
                        /*[in]*/  IWbemContext*    pCtx,        
                        /*[in]*/  IWbemObjectSink* pResponseHandler
                               );

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP CreateInstanceEnumAsync(
                                 /*[in]*/ const BSTR       strClass,
                                 /*[in]*/ long             lFlags,
                                 /*[in]*/ IWbemContext*    pCtx,        
                                 /*[in]*/ IWbemObjectSink* pResponseHandler
                                        );

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP ExecMethodAsync(
                         /*[in]*/ const BSTR        strObjectPath,
                         /*[in]*/ const BSTR        strMethodName,
                         /*[in]*/ long              lFlags,
                         /*[in]*/ IWbemContext*     pCtx,        
                         /*[in]*/ IWbemClassObject* pInParams,
                         /*[in]*/ IWbemObjectSink*  pResponseHandler  
                                );

    //////////////////////////////////////////////////////////////////////////
    // Alert Manager Methods
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              ) throw(_com_error);

    //////////////////////////////////////////////////////////////////////////
    void Prune(void);

private:

    //////////////////////////////////////////////////////////////////////////
    HRESULT RaiseHeck(
              /*[in]*/ IWbemContext*     pCtx,
              /*[in]*/ IApplianceObject* pAlert
                     );

    //////////////////////////////////////////////////////////////////////////
    HRESULT ClearHeck(
              /*[in]*/ IWbemContext*     pCtx,
              /*[in]*/ IApplianceObject* pAlert
                     );

    /////////////////////////////////////////////////////////////////////////
    BOOL ClearPersistentAlertKey(
              /*[in]*/ IApplianceObject* pAlert
                        );

    BOOL IsOperationAllowedForClient (
            VOID
            );


    // Prune interval
    DWORD                m_dwPruneInterval;

    // Alert Cookie Value (counter that rolls every 4 gig cookies)
    DWORD                m_dwCookie;

    // Alert collection pruner callback
    Callback*            m_pCallback;

    // Alert collection pruner thread
    CTheWorkerThread    m_PruneThread;
};

#endif // __INC_ALERT_WBEM_OBJECT_MGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemalertmgr.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemalertmgr.cpp
//
// Project:     Chameleon
//
// Description: WBEM Appliance Alert Manager Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "appmgrutils.h"
#include "wbemalertmgr.h"
#include "wbemalert.h"
#include <appsrvcs.h>

//////////////////////////////////////////////////////////////////////////
// properties common to appliance object and WBEM class instance
//////////////////////////////////////////////////////////////////////////
BEGIN_OBJECT_PROPERTY_MAP(AlertOutProperties)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_TYPE)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_ID)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_SOURCE)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_LOG)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_TTL)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_STRINGS)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_DATA)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_FLAGS)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_COOKIE)
END_OBJECT_PROPERTY_MAP()

BEGIN_OBJECT_PROPERTY_MAP(AlertInProperties)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_TYPE)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_ID)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_SOURCE)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_LOG)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_TTL)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_STRINGS)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_DATA)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_FLAGS)
END_OBJECT_PROPERTY_MAP()

static _bstr_t bstrReturnValue = L"ReturnValue";
static _bstr_t bstrClassAppMgr = CLASS_WBEM_APPMGR;
static _bstr_t bstrCookie = PROPERTY_ALERT_COOKIE;
static _bstr_t bstrAlertId = PROPERTY_ALERT_ID;
static _bstr_t bstrAlertLog = PROPERTY_ALERT_LOG;
static _bstr_t bstrAlertFlags = PROPERTY_ALERT_FLAGS;
static _bstr_t bstrTTL = PROPERTY_ALERT_TTL;
static _bstr_t bstrClassRaiseAlert = CLASS_WBEM_RAISE_ALERT;
static _bstr_t bstrClassClearAlert = CLASS_WBEM_CLEAR_ALERT;
static _bstr_t bstrAlertRegPath =  SA_ALERT_REGISTRY_KEYNAME;


//////////////////////////////////////////////////////////////////////////
// Constructor
//////////////////////////////////////////////////////////////////////////
CWBEMAlertMgr::CWBEMAlertMgr()
: m_dwCookie(0x100),
  m_dwPruneInterval(ALERT_PRUNE_INTERVAL_DEFAULT),
  m_pCallback(NULL)
{

}

//////////////////////////////////////////////////////////////////////////
// Destructor
//////////////////////////////////////////////////////////////////////////
CWBEMAlertMgr::~CWBEMAlertMgr()
{
    m_PruneThread.End(INFINITE, false);
    if ( m_pCallback )
        { delete m_pCallback; }
}

//////////////////////////////////////////////////////////////////////////
// IWbemServices Methods (Instance / Method Provider)
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetObjectAsync()
//
// Synopsis:    Get a specified instance of a WBEM class
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMAlertMgr::GetObjectAsync(
                                  /*[in]*/  const BSTR       strObjectPath,
                                  /*[in]*/  long             lFlags,
                                  /*[in]*/  IWbemContext*    pCtx,        
                                  /*[in]*/  IWbemObjectSink* pResponseHandler
                                           )
{
    // Check parameters (enforce contract)
    _ASSERT( NULL != strObjectPath && NULL != pResponseHandler );
    if ( NULL == strObjectPath || NULL == pResponseHandler )
    { return WBEM_E_INVALID_PARAMETER; }

    CLockIt theLock(*this);

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    do 
    {
        // Determine the object's class 
        _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrClass )
        { break; }

        // Retrieve the object's class definition. We'll use this
        // to initialize the returned instance.
        CComPtr<IWbemClassObject> pClassDefintion;
        hr = (::GetNameSpace())->GetObject(bstrClass, 0, pCtx, &pClassDefintion, NULL);
        if ( FAILED(hr) )
        { break; }

        // Get the object's instance key
        _bstr_t bstrKey(::GetObjectKey(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrKey )
        { break; }

        // Create a WBEM instance of the object and initialize it
        CComPtr<IWbemClassObject> pWbemObj;
        hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
        if ( FAILED(hr) )
        { break; }

        // Now try to locate the specified object
        ObjMapIterator p = m_ObjMap.find((LPCWSTR)bstrKey);
        if ( p == m_ObjMap.end() )
        { 
            hr = WBEM_E_NOT_FOUND;
            break; 
        }

        // Initialize the new WBEM object
        hr = CWBEMProvider::InitWbemObject(AlertOutProperties, (*p).second, pWbemObj);
        if ( FAILED(hr) )
        { break; }

        // Tell the caller about the new WBEM object
        pResponseHandler->Indicate(1, &pWbemObj.p);

        hr = WBEM_S_NO_ERROR;
    
    } while (FALSE);

    CATCH_AND_SET_HR

    // Report function status
    pResponseHandler->SetStatus(0, hr, NULL, NULL);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemAlertMgr::GetObjectAsync() - Failed - Object: '%ls' Result Code: %lx", strObjectPath, hr); }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    CreateInstanceEnumAsync()
//
// Synopsis:    Enumerate the instances of the specified class
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMAlertMgr::CreateInstanceEnumAsync( 
                                         /* [in] */ const BSTR         strClass,
                                         /* [in] */ long             lFlags,
                                         /* [in] */ IWbemContext     *pCtx,
                                         /* [in] */ IWbemObjectSink  *pResponseHandler
                                                     )
{
    // Check parameters (enforce contract)
    _ASSERT( NULL != strClass && NULL != pResponseHandler );
    if ( NULL == strClass || NULL == pResponseHandler )
    { return WBEM_E_INVALID_PARAMETER; }

    CLockIt theLock(*this);

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    // Retrieve the object's class definition. We'll use this
    // to initialize the returned instances.
    CComPtr<IWbemClassObject> pClassDefintion;
       hr = (::GetNameSpace())->GetObject(strClass, 0, NULL, &pClassDefintion, 0);
    if ( SUCCEEDED(hr) )
    {
        // Create and initialize a wbem object instance for each
        // alert object... 

        ObjMapIterator p = m_ObjMap.begin();
        while ( p != m_ObjMap.end() )
        {
            {
                CComPtr<IWbemClassObject> pWbemObj;
                hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
                if ( FAILED(hr) )
                { break; }

                hr = CWBEMProvider::InitWbemObject(AlertOutProperties, (*p).second, pWbemObj);
                if ( FAILED(hr) )
                { break; }

                // Tell the caller about the WBEM object
                pResponseHandler->Indicate(1, &pWbemObj.p);
            }

            p++; 
        }
    }

    CATCH_AND_SET_HR

    // Report function status
    pResponseHandler->SetStatus(0, hr, 0, 0);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemAlertMgr::CreateInstanceEnumAsync() - Failed - Result Code: %lx", hr); }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    ExecMethodAsync()
//
// Synopsis:    Execute the instances of the specified class
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMAlertMgr::ExecMethodAsync(
                                    /*[in]*/ const BSTR        strObjectPath,
                                    /*[in]*/ const BSTR        strMethodName,
                                    /*[in]*/ long              lFlags,
                                    /*[in]*/ IWbemContext*     pCtx,        
                                    /*[in]*/ IWbemClassObject* pInParams,
                                    /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                            )
{
    
    // Check parameters (enforce contract)
    _ASSERT( strObjectPath && strMethodName );
    if ( strObjectPath == NULL || strMethodName == NULL )
    { return WBEM_E_INVALID_PARAMETER; }

    CLockIt theLock(*this);
    
        HRESULT hr = WBEM_E_FAILED;

    
    TRY_IT

    do
    {
        //
        // we only allow administrator's and Local Systm accounts to carry out
        // this operation
        //
        if (!IsOperationAllowedForClient ())
        {
            SATraceString ("CWbemAlertMgr::ExecMethodAsync - client not allowed operation on alerts");
            hr = WBEM_E_ACCESS_DENIED;
            break;
        }
        
        // Get a WBEM object for use with output parameters
        // Determine the object's class 
        _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrClass )
        { break; }

        // Retrieve the object's class definition. 
        CComPtr<IWbemClassObject> pClassDefinition;
            hr = (::GetNameSpace())->GetObject(
                                            bstrClass, 
                                            0, 
                                            pCtx, 
                                            &pClassDefinition, 
                                            NULL
                                           );
        if ( FAILED(hr) )
        { break; }

        if ( ! lstrcmp(strMethodName, METHOD_APPMGR_RAISE_ALERT) )
        {
            // RAISING AN ALERT...

            // Create a new IApplianceObject and initialize it from the 
            // input parameters
            CLocationInfo LocInfo;
            PPROPERTYBAG pBag = ::MakePropertyBag(
                                                  PROPERTY_BAG_REGISTRY, 
                                                  LocInfo
                                                 );
            if ( ! pBag.IsValid() )
            { break; }

            CComPtr<IApplianceObject> pAlertObj = 
            (IApplianceObject*) ::MakeComponent(
                                                CLASS_WBEM_ALERT_FACTORY,
                                                pBag
                                               );

            if ( NULL == (IApplianceObject*) pAlertObj )
            { break; }

            hr = InitApplianceObject(
                                     AlertInProperties, 
                                     pAlertObj, 
                                     pInParams
                                    );
            if ( FAILED(hr) )
            { break; }

            // Return the cookie to the caller via an output parameter...
            // The following code does this...
            CComPtr<IWbemClassObject> pClassDefinition;
            hr = (::GetNameSpace())->GetObject(
                                               bstrClassAppMgr, 
                                               0, 
                                               pCtx, 
                                               &pClassDefinition, 
                                               NULL
                                              );
            if ( FAILED(hr) )
            { break; }

            CComPtr<IWbemClassObject> pMethodRet;
            hr = pClassDefinition->GetMethod(
                                             strMethodName, 
                                             0, 
                                             NULL, 
                                             &pMethodRet
                                            );
            if ( FAILED(hr) )
            { break; }

            CComPtr<IWbemClassObject> pOutParams;
            hr = pMethodRet->SpawnInstance(0, &pOutParams);
            if ( FAILED(hr) )
            { break; }

            // Set the return parameters
            _variant_t vtCookie = (long)m_dwCookie;
            if ( FAILED(pAlertObj->PutProperty(bstrCookie,&vtCookie)) )
            { break; }

            hr = pOutParams->Put(bstrCookie, 0, &vtCookie, 0);      
            if ( FAILED(hr) )
            { break; }

            _variant_t vtReturnValue = (long)S_OK;
            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if ( FAILED(hr) )
            { break; }

            // Cookie to string...
            wchar_t szCookie[32];
            _itow( m_dwCookie, szCookie, 10 );

            // Put the new alert object into the object map for subsequent use
            pair<ObjMapIterator, bool> thePair = 
            m_ObjMap.insert(ObjMap::value_type(szCookie, pAlertObj));
            if ( false == thePair.second )
            { 
                hr = WBEM_E_FAILED;
                break; 
            }    

            // Increment the cookie value (for the next raised alert)
            m_dwCookie++;

            // Post a raise alert event
            RaiseHeck(pCtx, pAlertObj);

            // Tell the caller alle ist klar...
            SATracePrintf("CWbemAlertMgr::ExecMethodAsync() - Info - Raised Alert: %d", m_dwCookie - 1);
            pResponseHandler->Indicate(1, &pOutParams.p);    
        }
        else if ( ! lstrcmp(strMethodName, METHOD_APPMGR_CLEAR_ALERT) )
        {
            // CLEARING AN ALERT...

            // Get the alert cookie
            _variant_t vtCookie;
            hr = pInParams->Get(bstrCookie, 0, &vtCookie, 0, 0);
            if ( FAILED(hr) )
            { break; }

            // Get the alert object for the given cookie...

            // Cookie to string...
            wchar_t szCookie[32];
            _itow(V_I4(&vtCookie), szCookie, 10);

            // Build the output parameter so we can return S_OK...
            CComPtr<IWbemClassObject> pClassDefinition;
            hr = (::GetNameSpace())->GetObject(bstrClassAppMgr, 0, pCtx, &pClassDefinition, NULL);
            if ( FAILED(hr) )
            { break; }

            CComPtr<IWbemClassObject> pMethodRet;
            hr = pClassDefinition->GetMethod(strMethodName, 0, NULL, &pMethodRet);
            if ( FAILED(hr) )
            { break; }

            CComPtr<IWbemClassObject> pOutParams;
            hr = pMethodRet->SpawnInstance(0, &pOutParams);
            if ( FAILED(hr) )
            { break; }

            // set return value to S_OK;
            _variant_t vtReturnValue = (long)S_OK;
            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if ( FAILED(hr) )
            { break; }

            // Find the alert in the alert collection
            ObjMapIterator p = m_ObjMap.find(szCookie);
            if ( p == m_ObjMap.end() )
            { 
                hr = WBEM_E_NOT_FOUND;
                break; 
            }

            // Post a clear alert event
            ClearHeck(pCtx, (*p).second);
            
            // Clear alert persistent information
            ClearPersistentAlertKey( (*p).second );

            // Erase the alert from the map the map
            m_ObjMap.erase(p);

            SATracePrintf("CWbemAlertMgr::ExecMethodAsync() - Info - Cleared Alert: %d",V_I4(&vtCookie));
            pResponseHandler->Indicate(1, &pOutParams.p);    
        }
        else if ( ! lstrcmp(strMethodName, METHOD_APPMGR_CLEAR_ALERT_ALL) )
        {
            // CLEARING ALL ALERTS...

            // Get the alert ID and log
            _variant_t vtAlertId;
            hr = pInParams->Get(bstrAlertId, 0, &vtAlertId, 0, 0);
            if ( FAILED(hr) )
            { break; }

            _variant_t vtAlertLog;
            hr = pInParams->Get(bstrAlertLog, 0, &vtAlertLog, 0, 0);
            if ( FAILED(hr) )
            { break; }

            // Build the output parameter so we can return S_OK...
            CComPtr<IWbemClassObject> pClassDefinition;
            hr = (::GetNameSpace())->GetObject(bstrClassAppMgr, 0, pCtx, &pClassDefinition, NULL);
            if ( FAILED(hr) )
            { break; }

            CComPtr<IWbemClassObject> pMethodRet;
            hr = pClassDefinition->GetMethod(strMethodName, 0, NULL, &pMethodRet);
            if ( FAILED(hr) )
            { break; }

            CComPtr<IWbemClassObject> pOutParams;
            hr = pMethodRet->SpawnInstance(0, &pOutParams);
            if ( FAILED(hr) )
            { break; }

            // initialize the return value
            _variant_t vtReturnValue = (long)WBEM_E_NOT_FOUND;
            BOOL bFindPersistentFlags = FALSE;

            // Find the alert objects in the collection that meet the criteria
            // and clear them...
            ObjMapIterator p = m_ObjMap.begin();
            while ( p != m_ObjMap.end() )
            { 
                {
                    _variant_t vtId;
                    _variant_t vtLog;
                    if ( FAILED(((*p).second)->GetProperty(bstrAlertId, &vtId)) )
                    { 
                        hr = WBEM_E_FAILED;
                        break; 
                    }
                    if ( FAILED(((*p).second)->GetProperty(bstrAlertLog, &vtLog)) )
                    { 
                        hr = WBEM_E_FAILED;
                        break; 
                    }
                    if ( V_I4(&vtId) == V_I4(&vtAlertId) && ! lstrcmp(V_BSTR(&vtLog), V_BSTR(&vtAlertLog)) )
                    {
                        ClearHeck(pCtx, (*p).second);
                        
                        if( !bFindPersistentFlags )
                        {
                            bFindPersistentFlags = ClearPersistentAlertKey( (*p).second );
                        }

                        p = m_ObjMap.erase(p);
                        SATracePrintf("CWbemAlertMgr::ExecMethodAsync() - Info - Cleared Alert: %d by ID",V_I4(&vtId));
                        vtReturnValue = (long)WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        p++;
                    }
                }
            }

            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if ( FAILED(hr) )
            { break; }

            pResponseHandler->Indicate(1, &pOutParams.p);    
        }
        else
        {
            // Invalid method!
            SATracePrintf("CWbemAlertMgr::ExecMethodAsync() - Failed - Method '%ls' not supported...", (LPWSTR)strMethodName);
            hr = WBEM_E_FAILED;
        }

    } while ( FALSE );

    CATCH_AND_SET_HR

    pResponseHandler->SetStatus(0, hr, 0, 0);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemAlertMgr::ExecMethodAsync() - Failed - Method: '%ls' Result Code: %lx", strMethodName, hr); }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    Prune()
//
// Synopsis:    Prune the alert map of aged (TTL has expired) entries.
//
//////////////////////////////////////////////////////////////////////////
void CWBEMAlertMgr::Prune()
{
    CLockIt theLock(*this);

    try
    {
        ObjMapIterator p = m_ObjMap.begin();
        while ( p != m_ObjMap.end() )
        {
            {
                // Get current alerts TTL value
                _variant_t vtTTL;
                HRESULT hr = ((*p).second)->GetProperty(bstrTTL, &vtTTL);
                if ( FAILED(hr) )
                {
                    SATracePrintf("CWBEMAlertMgr::Prune() - IApplianceObject::GetProperty(TTL) failed with result code: %lx...", hr);
                    p++;
                    continue;
                }
                // Is the current alert iternal?
                if ( V_I4(&vtTTL) >= SA_ALERT_DURATION_ETERNAL )
                {
                    p++;
                    continue;
                }
                else
                {
                    // No... has it expired?
                    if ( V_I4(&vtTTL) > m_dwPruneInterval )
                    {
                        // No... update the alert object's TTL
                        V_I4(&vtTTL) -= m_dwPruneInterval;
                        ((*p).second)->PutProperty(bstrTTL, &vtTTL);
                        p++;
                    }
                    else
                    {
                        // Yes... prune it (or 'clear it' for those of you who are'nt into gardening...)
                        _variant_t vtCookie;
                        hr = ((*p).second)->GetProperty(bstrCookie, &vtCookie);
                        if ( SUCCEEDED(hr) )
                        {
                            SATracePrintf("CWBEMAlertMgr::Prune() - Info - TTL for alert '%d' has expired and the alert has been cleared...", V_I4(&vtCookie));
                        }
                        else
                        {
                            SATracePrintf("CWBEMAlertMgr::Prune() - IApplianceObject::GetProperty(Cookie) failed with result code: %lx...", hr);
                        }
                        // Post a clear alert event
                        ClearHeck(NULL, (*p).second);
                        // Remove it from the alert collection
                        p = m_ObjMap.erase(p);
                    }
                }
            }
        }
    }
    catch(...)
    {
        SATraceString("CWbemAlertMgr::Prune() - Info - Caught unhandled execption...");
        _ASSERT(FALSE);
    }
}


_bstr_t bstrPruneInterval = PROPERTY_ALERT_PRUNE_INTERVAL;

//////////////////////////////////////////////////////////////////////////
//
// Function:    InternalInitialize()
//
// Synopsis:    Function called by the component factory that enables the
//                component to load its state from the given property bag.
//
//////////////////////////////////////////////////////////////////////////
HRESULT CWBEMAlertMgr::InternalInitialize(
                                   /*[in]*/ PPROPERTYBAG pPropertyBag
                                         )
{
    SATraceString("The Alert Object Manager is initializing...");


    // Get the alert prune interval from the property bag.
    // If we cannot retrieve a prune interval then use the default interval.
    _variant_t vtPruneInterval;
    if ( ! pPropertyBag->get(bstrPruneInterval, &vtPruneInterval) )
    {
        m_dwPruneInterval = ALERT_PRUNE_INTERVAL_DEFAULT;
    }
    else
    {
        m_dwPruneInterval = V_I4(&vtPruneInterval);
    }

    SATracePrintf("The Alert Object Manager's prune thread will run at %lx millisecond intervals...", m_dwPruneInterval);

    // Start the alert collection pruning (aged entries) thread... Note 
    // that it will start in the suspended state since the collection is
    // initially empty.
    m_pCallback = MakeCallback(this, &CWBEMAlertMgr::Prune);
    if ( ! m_PruneThread.Start(m_dwPruneInterval, m_pCallback) )
    { 
        SATraceString("CWBEMAlertMgr::InternalInitialize() - Failed - Could not create prune thread...");
        throw _com_error(WBEM_E_FAILED); 
    }

    SATraceString("The Alert Object Manager was successfully initialized...");

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    RaiseHeck()
//
// Synopsis:    Function called to process a newly raised alert. Currently
//                we log an NT event log event using the specified source
//                and then post a WMI event. The consumer of the event is
//                currently the LDM. 
//
//////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_PROPERTY_MAP(RaiseAlertProperties)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_COOKIE)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_TYPE)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_ID)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_SOURCE)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_LOG)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_STRINGS)
END_OBJECT_PROPERTY_MAP()

HRESULT CWBEMAlertMgr::RaiseHeck(
                         /*[in]*/ IWbemContext*     pCtx,
                         /*[in]*/ IApplianceObject* pAlert
                                )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRY_IT

    // Post an alert raised event...

    IWbemObjectSink* pEventSink = ::GetEventSink();
    if ( NULL != (IWbemObjectSink*) pEventSink )
    {
        CComPtr<IWbemClassObject> pClassDefinition;
        hr = (::GetNameSpace())->GetObject(
                                            bstrClassRaiseAlert, 
                                            0, 
                                            pCtx, 
                                            &pClassDefinition, 
                                            NULL
                                          );
        if (SUCCEEDED(hr) )
        { 
            CComPtr<IWbemClassObject> pEvent;
            hr = pClassDefinition->SpawnInstance(0, &pEvent);
            if ( SUCCEEDED(hr) )
            { 
                hr = CWBEMProvider::InitWbemObject(
                                                   RaiseAlertProperties, 
                                                   pAlert, 
                                                   pEvent
                                                  );
                if ( SUCCEEDED(hr) )
                {

                    // Don't care if the receiver gets this event or not...
                    SATraceString("CWbemAlertMgr::RaiseHeck() - Posted Micorosoft_SA_RaiseAlert");
                    pEventSink->Indicate(1, &pEvent.p);
                    hr = WBEM_S_NO_ERROR;
                }
            }
        }
    }

    CATCH_AND_SET_HR

    if ( FAILED(hr) )
    { SATracePrintf("CWbemAlertMgr::RaiseHeck() - Failed - Result Code: %lx", hr); }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    ClearHeck()
//
// Synopsis:    Function called to process a newly cleared alert. Currently
//                we log an NT event log event using the specified source
//                and then post a WMI event. The consumer of the event is
//                currently the LDM. 
//
//////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_PROPERTY_MAP(ClearAlertProperties)
    DEFINE_OBJECT_PROPERTY(PROPERTY_ALERT_COOKIE)
END_OBJECT_PROPERTY_MAP()

HRESULT CWBEMAlertMgr::ClearHeck(
                         /*[in]*/ IWbemContext*     pCtx,
                         /*[in]*/ IApplianceObject* pAlert
                                )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRY_IT

    // Post an alert raised event...

    IWbemObjectSink* pEventSink = ::GetEventSink();
    if ( NULL != (IWbemObjectSink*) pEventSink )
    {
        CComPtr<IWbemClassObject> pClassDefinition;
        hr = (::GetNameSpace())->GetObject(
                                            bstrClassClearAlert, 
                                            0, 
                                            pCtx, 
                                            &pClassDefinition, 
                                            NULL
                                          );
        if (SUCCEEDED(hr) )
        { 
            CComPtr<IWbemClassObject> pEvent;
            hr = pClassDefinition->SpawnInstance(0, &pEvent);
            if ( SUCCEEDED(hr) )
            { 
                hr = CWBEMProvider::InitWbemObject(
                                                   ClearAlertProperties, 
                                                   pAlert, 
                                                   pEvent
                                                  );
                if ( SUCCEEDED(hr) )
                {

                    // Don't care if the receiver gets this event or not...
                    SATraceString("CWbemAlertMgr::ClearHeck() - Posted Micorosoft_SA_ClearAlert");                    
                    pEventSink->Indicate(1, &pEvent.p);
                    hr = WBEM_S_NO_ERROR;
                }
            }
        }
    }

    CATCH_AND_SET_HR

    if ( FAILED(hr) )
    { SATracePrintf("CWbemAlertMgr::ClearHeck() - Failed - Result Code: %lx", hr); }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    ClearPersistentAlertKey()
//
// Synopsis:    Function called to delete the key stored the persistent
//              information of cleared alert which is set as persitent
//              alert.
//
//////////////////////////////////////////////////////////////////////////
BOOL CWBEMAlertMgr::ClearPersistentAlertKey(
                          /*[in]*/ IApplianceObject* pAlert
                                    )
{
    LONG    lFlags;
    LONG    lAlertId;
    BOOL    bReturn = FALSE;
    WCHAR   wstrAlertItem[MAX_PATH];  
    HRESULT hr;

    do
    {   
        _variant_t vtPropertyValue;
        hr = pAlert->GetProperty( bstrAlertFlags, &vtPropertyValue );
        if ( FAILED(hr) )
        { 
            SATracePrintf("ClearPersistentAlertKey - IApplianceObject::GetProperty() - Failed on property: %ls...", PROPERTY_ALERT_FLAGS);
            break;
        }
    
        lFlags = V_I4( &vtPropertyValue );
        if( lFlags & SA_ALERT_FLAG_PERSISTENT )
        {
            bReturn = TRUE;

            hr = pAlert->GetProperty( bstrAlertId, &vtPropertyValue );
            if ( FAILED(hr) )
            { 
                SATracePrintf("ClearPersistentAlertKey - IApplianceObject::GetProperty() - Failed on property: %ls...", PROPERTY_ALERT_FLAGS);
                break;
            }

            lAlertId = V_I4( &vtPropertyValue );               

            hr = pAlert->GetProperty( bstrAlertLog, &vtPropertyValue );
            if ( FAILED(hr) )
            { 
                SATracePrintf("ClearPersistentAlertKey - IApplianceObject::GetProperty() - Failed on property: %ls...", PROPERTY_ALERT_FLAGS);
                break;
            }

            // Set location information.
            CLocationInfo LocSubInfo ( HKEY_LOCAL_MACHINE, bstrAlertRegPath );

            // Set key name as AlertLog + AlertId.
            ::wsprintf( wstrAlertItem, L"%s%8lX", V_BSTR( &vtPropertyValue ), lAlertId );
    
            // Open the main key as propertybag container.
            PPROPERTYBAGCONTAINER 
            pObjSubMgrs =  ::MakePropertyBagContainer(
                                    PROPERTY_BAG_REGISTRY,
                                    LocSubInfo
                                    );
            if ( !pObjSubMgrs.IsValid() )
            {
                break;
            }

            if ( !pObjSubMgrs->open() )
            {
                SATraceString( "ClearPersistentAlertKey -  no key for the alert" );
            }else
            {
                // Remove the subkey of alert if it exist.
                pObjSubMgrs->remove( wstrAlertItem );
            }
        }
    }
    while (FALSE);

    return bReturn; 
}


//**********************************************************************
// 
// FUNCTION:  IsOperationAllowedForClient - This function checks the token of the 
//            calling thread to see if the caller belongs to the Administrators group or it is
//          the Local System account
// 
// PARAMETERS:   none
// 
// RETURN VALUE: TRUE if the caller is an administrator on the local
//            machine.  Otherwise, FALSE.
// 
//**********************************************************************
BOOL 
CWBEMAlertMgr::IsOperationAllowedForClient (
            VOID
            )
{

    HANDLE hToken = NULL;
       DWORD  dwStatus  = ERROR_SUCCESS;
       DWORD  dwAccessMask = 0;;
       DWORD  dwAccessDesired = 0;
       DWORD  dwACLSize = 0;
       DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
       PACL   pACL            = NULL;
       PSID   psidAdmin    =  NULL;
       PSID   psidLocalSystem  = NULL;
       BOOL   bReturn        =  FALSE;

       PRIVILEGE_SET   ps;
       GENERIC_MAPPING GenericMapping;

       PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
       SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

       CSATraceFunc objTraceFunc ("CWBEMAlertMgr::IsOperationAllowedForClient ");
       
      do
      {
        //
        // we assume to always have a thread token, because the function calling in
        // appliance manager will be impersonating the client
        //
           bReturn  = OpenThreadToken(
                       GetCurrentThread(), 
                       TOKEN_QUERY, 
                       FALSE, 
                            &hToken
                            );
        if (!bReturn)
        {
            SATraceFailure ("CWbemAlertMgr::IsOperationAllowedForClient failed on OpenThreadToken:", GetLastError ());
                 break;
        }


        //
        // Create a SID for Local System account
        //
            bReturn = AllocateAndInitializeSid (  
                            &SystemSidAuthority,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0,
                            0,
                            0,
                            0,
                            0,
                          0,
                            0,
                            &psidLocalSystem
                            );
        if (!bReturn)
        {     
                   SATraceFailure ("CWbemAlertMgr:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  GetLastError ());
                break;
            }
    
        //
        // SID for Admins now
        //
              bReturn = AllocateAndInitializeSid(
                          &SystemSidAuthority, 
                          2, 
                            SECURITY_BUILTIN_DOMAIN_RID, 
                            DOMAIN_ALIAS_RID_ADMINS,
                            0,
                            0,
                            0,
                            0,
                            0, 
                            0, 
                            &psidAdmin
                            );
        if (!bReturn)
        {
            SATraceFailure ("CWbemAlertMgr::IsOperationForClientAllowed failed on AllocateAndInitializeSid (Admin):", GetLastError ());
                 break;
        }


             //
             // get memory for the security descriptor
             //
              psdAdmin = HeapAlloc (
                          GetProcessHeap (),
                          0,
                          SECURITY_DESCRIPTOR_MIN_LENGTH
                          );
              if (NULL == psdAdmin)
              {
                  SATraceString ("CWbemAlertMgr::IsOperationForClientAllowed failed on HeapAlloc");
            bReturn = FALSE;
                 break;
              }
      
              bReturn = InitializeSecurityDescriptor(
                                      psdAdmin,
                                        SECURITY_DESCRIPTOR_REVISION
                                        );
              if (!bReturn)
        {
            SATraceFailure ("CWbemAlertMgr::IsOperationForClientAllowed failed on InitializeSecurityDescriptor:", GetLastError ());
                 break;
        }

        // 
           // Compute size needed for the ACL.
           //
            dwACLSize = sizeof(ACL) + 2*sizeof(ACCESS_ALLOWED_ACE) +
                            GetLengthSid(psidAdmin) + GetLengthSid (psidLocalSystem);

        //
           // Allocate memory for ACL.
              //
              pACL = (PACL) HeapAlloc (
                             GetProcessHeap (),
                          0,
                    dwACLSize
                    );
              if (NULL == pACL)
              {
                  SATraceString ("CWbemAlertMgr::IsOperationForClientAllowed failed on HeapAlloc2");
            bReturn = FALSE;
                 break;
              }

        //
              // Initialize the new ACL.
              //
              bReturn = InitializeAcl(
                          pACL, 
                          dwACLSize, 
                          ACL_REVISION2
                          );
              if (!bReturn)
              {
                  SATraceFailure ("CWbemAlertMgr::IsOperationForClientAllowed failed on InitializeAcl", GetLastError ());
                 break;
              }


        // 
        // Make up some private access rights.
        // 
        const DWORD ACCESS_READ = 1;
        const DWORD  ACCESS_WRITE = 2;
              dwAccessMask= ACCESS_READ | ACCESS_WRITE;
            //
              // Add the access-allowed ACE to the DACL for Local System
              //
              bReturn = AddAccessAllowedAce (
                          pACL, 
                          ACL_REVISION2,
                            dwAccessMask, 
                            psidLocalSystem
                            );
              if (!bReturn)
              {
                      SATraceFailure ("CWbemAlertMgr::IsOperationForClientAllowed failed on AddAccessAllowedAce (LocalSystem)", GetLastError ());
                     break;
              }
              
              //
              // Add the access-allowed ACE to the DACL for Admin
              //
              bReturn = AddAccessAllowedAce (
                          pACL, 
                          ACL_REVISION2,
                            dwAccessMask, 
                            psidAdmin
                            );
              if (!bReturn)
              {
                      SATraceFailure ("CWbemAlertMgr::IsOperationForClientAllowed failed on AddAccessAllowedAce (Admin)", GetLastError ());
                     break;
              }

              //
              // Set our DACL to the SD.
              //
              bReturn = SetSecurityDescriptorDacl (
                              psdAdmin, 
                              TRUE,
                              pACL,
                              FALSE
                              );
            if (!bReturn)
             {
                  SATraceFailure ("CWbemAlertMgr::IsOperationForClientAllowed failed on SetSecurityDescriptorDacl", GetLastError ());
                 break;
              }

        //
              // AccessCheck is sensitive about what is in the SD; set
              // the group and owner.
              //
              SetSecurityDescriptorGroup(psdAdmin, psidAdmin, FALSE);
              SetSecurityDescriptorOwner(psdAdmin, psidAdmin, FALSE);

           bReturn = IsValidSecurityDescriptor(psdAdmin);
           if (!bReturn)
             {
                  SATraceFailure ("CWbemAlertMgr::IsOperationForClientAllowed failed on IsValidSecurityDescriptorl", GetLastError ());
                 break;
              }
     

              dwAccessDesired = ACCESS_READ;

             // 
              // Initialize GenericMapping structure even though we
              // won't be using generic rights.
              // 
        GenericMapping.GenericRead    = ACCESS_READ;
             GenericMapping.GenericWrite   = ACCESS_WRITE;
             GenericMapping.GenericExecute = 0;
             GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;
        BOOL bAccessStatus = FALSE;
        //
        // check the access now
        //
              bReturn = AccessCheck  (
                          psdAdmin, 
                          hToken, 
                          dwAccessDesired, 
                            &GenericMapping, 
                            &ps,
                            &dwStructureSize, 
                            &dwStatus, 
                            &bAccessStatus
                            );
           if (!bReturn || !bAccessStatus)
             {
                  SATraceFailure ("CWbemAlertMgr::IsOperationForClientAllowed failed on AccessCheck", GetLastError ());
              } 
           else
           {
               SATraceString ("Client is allowed to carry out operation!");
           }

        //
        // successfully checked 
        //
        bReturn  = bAccessStatus;        
 
    }    
    while (false);

    //
    // Cleanup 
    //
    if (pACL) 
    {
        HeapFree (GetProcessHeap (), 0, pACL);
    }

    if (psdAdmin) 
    {
        HeapFree (GetProcessHeap (), 0, psdAdmin);
    }
          
    if (psidAdmin) 
    {
        FreeSid(psidAdmin);
       }

    if (psidLocalSystem) 
    {
        FreeSid(psidLocalSystem);
       }

    if (hToken)
    {
        CloseHandle (hToken);
    }

   return (bReturn);

}// end of CWbemAlertMgr::IsOperationValidForClient method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemservice.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemservice.cpp
//
// Project:     Chameleon
//
// Description: WBEM Appliance Service Object Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wbemservice.h"

static _bstr_t  bstrStatus = PROPERTY_SERVICE_STATUS;    

extern "C" CLSID CLSID_ServiceSurrogate;
///////////////////////////////////////////////////////////////////////////////
// IApplianceObject Interface Implmentation - see ApplianceObject.idl
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMService::GetProperty(
                            /*[in]*/ BSTR     pszPropertyName, 
                   /*[out, retval]*/ VARIANT* pPropertyValue
                                   )
{
    HRESULT hr = WBEM_E_FAILED;

    CLockIt theLock(*this);

    TRY_IT

    if ( GetPropertyInternal(pszPropertyName, pPropertyValue) )
    { 
        hr = WBEM_S_NO_ERROR;
    }

    CATCH_AND_SET_HR

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMService::PutProperty(
                            /*[in]*/ BSTR     pszPropertyName, 
                            /*[in]*/ VARIANT* pPropertyValue
                                   )
{
    HRESULT hr = WBEM_E_FAILED;

    CLockIt theLock(*this);

    TRY_IT

    if ( PutPropertyInternal(pszPropertyName, pPropertyValue) )
    { 
        hr = WBEM_S_NO_ERROR;
    }

    CATCH_AND_SET_HR

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMService::SaveProperties(void)
{
    HRESULT hr = WBEM_E_FAILED;
    
    CLockIt theLock(*this);

    TRY_IT

    if ( SavePropertiesInternal() )
    {
        hr = WBEM_S_NO_ERROR;
    }

    CATCH_AND_SET_HR

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMService::Initialize(void)
{
    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    CComPtr<IApplianceObject> pService;

    {
        CLockIt theLock(*this);
        m_pService.Release();
        hr = GetRealService(&pService);
    }
    if ( SUCCEEDED(hr) )
    { 
        hr = pService->Initialize(); 
        if ( SUCCEEDED(hr) )
        {
            m_pService = pService;
        }
    }

    CATCH_AND_SET_HR

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMService::Shutdown(void)
{
    HRESULT hr = WBEM_E_FAILED;

    TRY_IT
    
    CLockIt theLock(*this);
    
    if ( (IApplianceObject*)m_pService )
    {
        hr = m_pService->Shutdown(); 
    }

    CATCH_AND_SET_HR

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMService::Enable(void)
{
    HRESULT hr = WBEM_E_FAILED;
    
    TRY_IT

    CLockIt theLock(*this);

    if ( (IApplianceObject*)m_pService )
    {
        hr = m_pService->Enable(); 
        if ( SUCCEEDED(hr) )
        {
            _variant_t vtIsEnabled = (long)TRUE;
            if ( PutPropertyInternal(bstrStatus, &vtIsEnabled) )
            {
                if ( ! SavePropertiesInternal() )
                {
                    hr = WBEM_E_FAILED;
                }
            }
            else
            {
                hr = WBEM_E_FAILED;
            }
        }
    }

    CATCH_AND_SET_HR

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMService::Disable(void)
{
    HRESULT hr = E_FAIL;

    TRY_IT

    CLockIt theLock(*this);

    if ( (IApplianceObject*)m_pService )
    {
        hr = m_pService->Disable(); 
        if ( SUCCEEDED(hr) )
        {
            _variant_t vtIsEnabled = (long)FALSE;
            if ( PutPropertyInternal(bstrStatus, &vtIsEnabled) )
            {
                if ( ! SavePropertiesInternal() )
                {
                    hr = WBEM_E_FAILED;
                }
            }
            else
            {
                hr = WBEM_E_FAILED;
            }
        }
    }

    CATCH_AND_SET_HR

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    InternalInitialize()
//
// Synopsis:    Function called by the component factory that enables the
//                component to load its state from the given property bag.
//
//////////////////////////////////////////////////////////////////////////
HRESULT CWBEMService::InternalInitialize(
                                  /*[in]*/ PPROPERTYBAG pPropertyBag
                                        )
{
    SATracePrintf("Initializing Service object '%ls'...", pPropertyBag->getName());

    HRESULT hr = CApplianceObject::InternalInitialize(pPropertyBag);
    if ( FAILED(hr) )
    {
        SATracePrintf("Service object '%ls' failed to initialize...", pPropertyBag->getName());
    }
    else
    {
        SATracePrintf("Service object '%ls' successfully initialized...", pPropertyBag->getName());
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetRealService()
//
// Synopsis:    Function called to obtain the IApplianceObject 
//                interface for the "real" serivce component
//                (as opposed to the serivce object we keep around to
//                satisfy instance requests from WMI clients)
//
//////////////////////////////////////////////////////////////////////////
HRESULT CWBEMService::GetRealService(
                            /*[out]*/ IApplianceObject** ppService
                                    )
{
    // Enforce contract
    _ASSERT( NULL != ppService );

    // Used to obtain a reference to the Chameleon service component 
    // hosted by the service surrogate process.

    *ppService = NULL;
    HRESULT hr = E_FAIL;
    _variant_t vtServiceName;
    if ( GetPropertyInternal(_bstr_t (PROPERTY_SERVICE_NAME), &vtServiceName) )
    { 
        CComPtr<IApplianceObject> pSurrogate;
        hr = CoCreateInstance(
                                CLSID_ServiceSurrogate,
                                NULL,
                                CLSCTX_LOCAL_SERVER,
                                IID_IApplianceObject,
                                (void**)&pSurrogate
                             );
        if ( SUCCEEDED(hr) )
        {
            _variant_t vtService;
            hr = pSurrogate->GetProperty(V_BSTR(&vtServiceName), &vtService);
            if ( SUCCEEDED(hr) )
            {
                hr = (V_UNKNOWN(&vtService))->QueryInterface(IID_IApplianceObject, (void**)ppService);
                if ( FAILED(hr) )
                {
                    SATracePrintf("CWBEMService::GetRealService() - Failed - QueryInterface() returned %lx", hr);    
                }
            }
            else
            {
                SATracePrintf("CWBEMService::GetRealService() - Failed - Could not get service surrogate reference for service '%ls'", V_BSTR(&vtServiceName));
            }
        }
        else
        {
            SATracePrintf("CWBEMService::GetRealService() - Failed - CoCreateInstance(surrogate) returned %lx for service '%ls'", hr, V_BSTR(&vtServiceName));
        }
    }
    else
    {
        SATraceString("CWBEMService::GetRealService() - Failed - Could not get service name property");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemservicemgr.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemservicemgr.h
//
// Project:     Chameleon
//
// Description: WBEM Appliance Service Object Class 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_SERVICE_WBEM_OBJECT_MGR_H_
#define __INC_SERVICE_WBEM_OBJECT_MGR_H_

#include "resource.h"
#include "wbembase.h"

#define    CLASS_WBEM_SERVICE_MGR_FACTORY    L"Microsoft_SA_Service"

//////////////////////////////////////////////////////////////////////////////
class CWBEMServiceMgr : 
    public CWBEMProvider,
    public IDispatchImpl<IApplianceObjectManager, &IID_IApplianceObjectManager, &LIBID_APPMGRLib>
{

public:

    CWBEMServiceMgr();
    ~CWBEMServiceMgr();

BEGIN_COM_MAP(CWBEMServiceMgr)
    COM_INTERFACE_ENTRY(IWbemServices)
    COM_INTERFACE_ENTRY(IApplianceObjectManager)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CWBEMServiceMgr, IWbemServices)

    //////////////////////////////////////////////////////////////////////////
    // IWbemServices Methods (Implemented by the ServiceMgr)
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP GetObjectAsync(
                        /*[in]*/  const BSTR       strObjectPath,
                        /*[in]*/  long             lFlags,
                        /*[in]*/  IWbemContext*    pCtx,        
                        /*[in]*/  IWbemObjectSink* pResponseHandler
                               );

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP CreateInstanceEnumAsync(
                                 /*[in]*/ const BSTR       strClass,
                                 /*[in]*/ long             lFlags,
                                 /*[in]*/ IWbemContext*    pCtx,        
                                 /*[in]*/ IWbemObjectSink* pResponseHandler
                                        );

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP ExecMethodAsync(
                      /*[in]*/ const BSTR        strObjectPath,
                      /*[in]*/ const BSTR        strMethodName,
                      /*[in]*/ long              lFlags,
                      /*[in]*/ IWbemContext*     pCtx,        
                      /*[in]*/ IWbemClassObject* pInParams,
                      /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                );


    /////////////////////////////////////
    // IApplianceObjectManager Interface

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(InitializeManager)(
                         /*[in]*/ IApplianceObjectManagerStatus* pObjMgrStatus
                                );

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(ShutdownManager)(void);

    /////////////////////////////////////
    // Component Initialization Function

    //////////////////////////////////////////////////////////////////////////
    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              );
private:

    typedef enum 
    { 
        INIT_CHAMELEON_SERVICES_WAIT     = 30000,
        SHUTDOWN_CHAMELEON_SERVICES_WAIT = 30000
    };

    //////////////////////////////////////////////////////////////////////////
    typedef multimap< long, CComPtr<IApplianceObject> >  MeritMap;
    typedef MeritMap::iterator                             MeritMapIterator;
    typedef MeritMap::reverse_iterator                     MeritMapReverseIterator;

    bool OrderServices(
                /*[in]*/ MeritMap& theMap
                      );

    // Worker thread function
    void InitializeChameleonServices(void);

    // Worker thread function
    void ShutdownChameleonServices(void);

    void 
    StartSurrogate(void);

    void
    StopSurrogate(void);

    // WMI provider DLL surrogate process termination function
    static void WINAPI SurrogateTerminationFunc(HANDLE hProcess, PVOID pThis);

    // Surrogate object interface
    CComPtr<IApplianceObject>                m_pSurrogate;

    // Status notification object (monitors status of the Service Object Manager)
    // Surrogate process handle
    HANDLE                                    m_hSurrogateProcess;
};

#endif // __INC_SERVICE_WBEM_OBJECT_MGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemservice.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemservice.h
//
// Project:     Chameleon
//
// Description: WBEM Appliance Service Object Class 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_SERVICE_WBEM_OBJECT_H_
#define __INC_SERVICE_WBEM_OBJECT_H_

#include "resource.h"
#include "applianceobjectbase.h"

#define        CLASS_WBEM_SERVICE_FACTORY    L"Microsoft_SA_Service_Object"

//////////////////////////////////////////////////////////////////////////////
class CWBEMService : public CApplianceObject
{

public:

    CWBEMService() { }
    ~CWBEMService() { }

BEGIN_COM_MAP(CWBEMService)
    COM_INTERFACE_ENTRY(IApplianceObject)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CWBEMService, IApplianceObject)

    //////////////////////////////////////////////////////////////////////////
    // IApplianceObject Interface
    //////////////////////////////////////////////////////////////////////////

    STDMETHODIMP GetProperty(
                     /*[in]*/ BSTR     pszPropertyName, 
            /*[out, retval]*/ VARIANT* pPropertyValue
                            );


    STDMETHODIMP PutProperty(
                     /*[in]*/ BSTR     pszPropertyName, 
                     /*[in]*/ VARIANT* pPropertyValue
                            );

    STDMETHODIMP SaveProperties(void);

    STDMETHODIMP Initialize(void);

    STDMETHODIMP Shutdown(void);

    STDMETHODIMP Enable(void);

    STDMETHODIMP Disable(void);

    //////////////////////////////////////////////////////////////////////////
    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              );

private:

    //////////////////////////////////////////////////////////////////////////
    HRESULT GetRealService(
                  /*[out]*/ IApplianceObject** ppService
                          );

    //////////////////////////////////////////////////////////////////////////
    CComPtr<IApplianceObject>    m_pService;
};

#endif // __INC_SERVICE_WBEM_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemtask.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemtask.h
//
// Project:     Chameleon
//
// Description: WBEM Appliance Task Object Class 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_TASK_WBEM_OBJECT_H_
#define __INC_TASK_WBEM_OBJECT_H_

#include "resource.h"
#include "applianceobjectbase.h"

#define        CLASS_WBEM_TASK_FACTORY        L"Microsoft_SA_Task_Object"

//////////////////////////////////////////////////////////////////////////////
class CWBEMTask : public CApplianceObject
{

public:

    CWBEMTask() { }

    ~CWBEMTask() { }

BEGIN_COM_MAP(CWBEMTask)
    COM_INTERFACE_ENTRY(IApplianceObject)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CWBEMTask, IApplianceObject)

    //////////////////////////////////////////////////////////////////////////
    // IApplianceObject Interface
    //////////////////////////////////////////////////////////////////////////

    STDMETHODIMP GetProperty(
                     /*[in]*/ BSTR     pszPropertyName, 
            /*[out, retval]*/ VARIANT* pPropertyValue
                            );


    STDMETHODIMP PutProperty(
                     /*[in]*/ BSTR     pszPropertyName, 
                     /*[in]*/ VARIANT* pPropertyValue
                            );

    STDMETHODIMP SaveProperties(void);

    STDMETHODIMP Enable(void);

    STDMETHODIMP Disable(void);

    //////////////////////////////////////////////////////////////////////////
    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              );
};

#endif // __INC_TASK_WBEM_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemservicemgr.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemservicemgr.cpp
//
// Project:     Chameleon
//
// Description: WBEM Appliance Service Manager Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "appmgrutils.h"
#include "wbemservicemgr.h"
#include "wbemservice.h"
#include <workerthread.h>

static _bstr_t bstrReturnValue = L"ReturnValue";
static _bstr_t bstrControlName = PROPERTY_SERVICE_CONTROL;
static _bstr_t bstrServiceName = PROPERTY_SERVICE_NAME;
static _bstr_t bstrMerit = PROPERTY_SERVICE_MERIT;

extern "C" CLSID CLSID_ServiceSurrogate;
//////////////////////////////////////////////////////////////////////////
// properties common to appliance object and WBEM class instance
//////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_PROPERTY_MAP(ServiceProperties)
    DEFINE_OBJECT_PROPERTY(PROPERTY_SERVICE_STATUS)
    DEFINE_OBJECT_PROPERTY(PROPERTY_SERVICE_CONTROL)
    DEFINE_OBJECT_PROPERTY(PROPERTY_SERVICE_NAME)
    DEFINE_OBJECT_PROPERTY(PROPERTY_SERVICE_PROGID)
    DEFINE_OBJECT_PROPERTY(PROPERTY_SERVICE_MERIT)
END_OBJECT_PROPERTY_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// Function:    CWBEMServiceMgr()
//
// Synopsis:    Constructor
//
//////////////////////////////////////////////////////////////////////////////
CWBEMServiceMgr::CWBEMServiceMgr()
:    m_hSurrogateProcess(NULL)
{

}

/////////////////////////////////////////////////////////////////////////////
//
// Function:    ~CWBEMServiceMgr()
//
// Synopsis:    Destructor
//
//////////////////////////////////////////////////////////////////////////////
CWBEMServiceMgr::~CWBEMServiceMgr()
{
    StopSurrogate();
}



//////////////////////////////////////////////////////////////////////////
// IWbemServices Methods (Instance / Method Provider)
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetObjectAsync()
//
// Synopsis:    Get a specified instance of a WBEM class
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMServiceMgr::GetObjectAsync(
                                  /*[in]*/  const BSTR       strObjectPath,
                                  /*[in]*/  long             lFlags,
                                  /*[in]*/  IWbemContext*    pCtx,        
                                  /*[in]*/  IWbemObjectSink* pResponseHandler
                                           )
{
    // Check parameters (enforce contract)
    _ASSERT( strObjectPath && pResponseHandler );
    if ( strObjectPath == NULL || pResponseHandler == NULL )
    { return WBEM_E_INVALID_PARAMETER; }

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    do 
    {
        // Determine the object's class 
        _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrClass )
        { break; }

        // Retrieve the object's class definition. We'll use this
        // to initialize the returned instance.
        CComPtr<IWbemClassObject> pClassDefintion;
        hr = (::GetNameSpace())->GetObject(
                                           bstrClass, 
                                           0, 
                                           pCtx, 
                                           &pClassDefintion, 
                                           NULL
                                          );
        if ( FAILED(hr) )
        { break; }

        // Get the object's instance key
        _bstr_t bstrKey(::GetObjectKey(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrKey )
        { break; }

        // Now try to locate the specified object
        hr = WBEM_E_NOT_FOUND;
        ObjMapIterator p = m_ObjMap.find((LPCWSTR)bstrKey);
        if ( p == m_ObjMap.end() )
        { break; }

        // Create a WBEM instance of the object and initialize it
        CComPtr<IWbemClassObject> pWbemObj;
        hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
        if ( FAILED(hr) )
        { break; }

        hr = CWBEMProvider::InitWbemObject(
                                           ServiceProperties, 
                                           (*p).second, 
                                           pWbemObj
                                          );
        if ( FAILED(hr) )
        { break; }

        // Tell the caller about the new WBEM object
        pResponseHandler->Indicate(1, &pWbemObj.p);
        hr = WBEM_S_NO_ERROR;
    
    } while (FALSE);

    CATCH_AND_SET_HR

    pResponseHandler->SetStatus(0, hr, NULL, NULL);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemServiceMgr::GetObjectAsync() - Failed - Object: '%ls' Result Code: %lx", strObjectPath, hr); }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    CreateInstanceEnumAsync()
//
// Synopsis:    Enumerate the instances of the specified class
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMServiceMgr::CreateInstanceEnumAsync( 
                                         /* [in] */ const BSTR         strClass,
                                         /* [in] */ long             lFlags,
                                         /* [in] */ IWbemContext     *pCtx,
                                         /* [in] */ IWbemObjectSink  *pResponseHandler
                                                     )
{
    // Check parameters (enforce contract)
    _ASSERT( strClass && pResponseHandler );
    if ( strClass == NULL || pResponseHandler == NULL )
    { return WBEM_E_INVALID_PARAMETER; }

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    // Retrieve the object's class definition. We'll use this
    // to initialize the returned instances.
    CComPtr<IWbemClassObject> pClassDefintion;
       hr = (::GetNameSpace())->GetObject(
                                       strClass, 
                                       0, 
                                       NULL, 
                                       &pClassDefintion, 
                                       0
                                      );
    if ( SUCCEEDED(hr) )
    {
        // Create and initialize a wbem object instance
        // for each object and return same to the caller
        ObjMapIterator p = m_ObjMap.begin();
        while ( p != m_ObjMap.end() )
        {
            {
                CComPtr<IWbemClassObject> pWbemObj;
                hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
                if ( FAILED(hr) )
                { break; }

                hr = CWBEMProvider::InitWbemObject(
                                                   ServiceProperties, 
                                                   (*p).second, 
                                                   pWbemObj
                                                  );
                if ( FAILED(hr) )
                { break; }

                pResponseHandler->Indicate(1, &pWbemObj.p);
            }

            p++; 
        }
    }

    CATCH_AND_SET_HR

    pResponseHandler->SetStatus(0, hr, 0, 0);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemServiceMgr::CreateInstanceEnumAsync() - Failed - Result Code: %lx", hr); }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    ExecMethodAsync()
//
// Synopsis:    Execute the specified method on the specified instance
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMServiceMgr::ExecMethodAsync(
                    /*[in]*/ const BSTR        strObjectPath,
                    /*[in]*/ const BSTR        strMethodName,
                    /*[in]*/ long              lFlags,
                    /*[in]*/ IWbemContext*     pCtx,        
                    /*[in]*/ IWbemClassObject* pInParams,
                    /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                          )
{
    // Check parameters (enforce contract)
    _ASSERT( strObjectPath && strMethodName && pResponseHandler );
    if ( NULL == strObjectPath || NULL == strMethodName || NULL == pResponseHandler )
    { return WBEM_E_INVALID_PARAMETER; }

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    do
    {
        // Get the object's instance key (service name)
        _bstr_t bstrKey(::GetObjectKey(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrKey )
        { break; }

        // Now try to locate the specified service
        hr = WBEM_E_NOT_FOUND;
        ObjMapIterator p = m_ObjMap.find((LPCWSTR)bstrKey);
        if ( p == m_ObjMap.end() )
        { break; }

        // Service located... get the output parameter object
        // Determine the object's class 
        _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
        if ( (LPCWSTR)bstrClass == NULL )
        { break; }

        // Retrieve the object's class definition.
        CComPtr<IWbemClassObject> pClassDefinition;
        hr = (::GetNameSpace())->GetObject(bstrClass, 0, pCtx, &pClassDefinition, NULL);
        if ( FAILED(hr) )
        { break; }

        // Get an instance of IWbemClassObject for the output parameter
        CComPtr<IWbemClassObject> pMethodRet;
        hr = pClassDefinition->GetMethod(strMethodName, 0, NULL, &pMethodRet);
        if ( FAILED(hr) )
        { break; }

        CComPtr<IWbemClassObject> pOutParams;
        hr = pMethodRet->SpawnInstance(0, &pOutParams);
        if ( FAILED(hr) )
        { break; }

        if ( ! lstrcmp(strMethodName, METHOD_SERVICE_ENABLE_OBJECT) )
        {
            //
            //  we don't allow services to be enabled or disabled anymore dynamically
            // 
            SATraceString ("CWbemServiceMgr::ExecMethodAsync - disable service object not allowed");
            hr = WBEM_E_FAILED;
            break;

            
            // Attempt to enable the service
            _variant_t vtReturnValue = (HRESULT) ((*p).second)->Enable();
            SATracePrintf("CWbemServiceMgr::ExecMethodAsync() - Info - Enable() for service '%ls' returned %lx",(LPWSTR)bstrKey, V_I4(&vtReturnValue));

            // Set the method return status
            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if ( FAILED(hr) )
            { break; }

            // Tell the caller what happened
            pResponseHandler->Indicate(1, &pOutParams.p);    
        }
        else if ( ! lstrcmp(strMethodName, METHOD_SERVICE_DISABLE_OBJECT) )
        {
            //
            //  we don't allow services to be enabled or disabled anymore dynamically
            // 
            SATraceString ("CWbemServiceMgr::ExecMethodAsync - enable service object not allowed");
            hr = WBEM_E_FAILED;
            break;

            // Ensure that the service can be disabled
            _variant_t vtControlValue;
            if ( FAILED(((*p).second)->GetProperty(bstrControlName, &vtControlValue)) )
            { 
                SATracePrintf("CWbemServiceMgr::ExecMethodAsync() - Info - Property 'disable' not found for service: %ls",(LPWSTR)bstrKey);
                hr = WBEM_E_FAILED;
                break;
            }
            _variant_t vtReturnValue = (long)WBEM_E_FAILED;
            if ( VARIANT_FALSE != V_BOOL(&vtControlValue) )
            { 
                // Service can be disabled so disable it...
                vtReturnValue = ((*p).second)->Disable();
                SATracePrintf("CWbemServiceMgr::ExecMethodAsync() - Info - Disable() for service '%ls' returned %lx",(LPWSTR)bstrKey, V_I4(&vtReturnValue));
            }
            else
            {
                SATracePrintf("CWbemServiceMgr::ExecMethodAsync() - Info - Service '%ls' cannot be disabled...", bstrKey);
            }
            // Set the method return value
            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if (FAILED(hr) )
            { break; }

            pResponseHandler->Indicate(1, &pOutParams.p);    
        }
        else
        {
            // Invalid method!
            SATracePrintf("CWbemServiceMgr::ExecMethodAsync() - Failed - Method '%ls' not supported...", (LPWSTR)bstrKey);
            hr = WBEM_E_NOT_FOUND;
            break;
        }

    } while ( FALSE );

    CATCH_AND_SET_HR

    pResponseHandler->SetStatus(0, hr, 0, 0);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemServiceMgr::ExecMethodAsync() - Failed - Method: '%ls' Result Code: %lx", strMethodName, hr); }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    InternalInitialize()
//
// Synopsis:    Function called by the component factory that enables the
//                component to load its state from the given property bag.
//
//////////////////////////////////////////////////////////////////////////
HRESULT CWBEMServiceMgr::InternalInitialize(
                                     /*[in]*/ PPROPERTYBAG pPropertyBag
                                           )
{
    SATraceString("The Service Object Manager is initializing...");

    // Defer remainder of the initialization tasks to base class (see wbembase.h...)
    HRESULT    hr = CWBEMProvider::InternalInitialize(
                                                   CLASS_WBEM_SERVICE_FACTORY, 
                                                   PROPERTY_SERVICE_NAME,
                                                   pPropertyBag
                                                  );
    if ( FAILED(hr) )
    {
        SATraceString("The Service Object Manager failed to initialize...");
    }
    else
    {
        SATraceString("The Service Object Manager was successfully initialized...");
    }
    return hr;
}


////////////////////////////////////////////////////////////////////////
//
// Function:    InitializeManager()
//
// Synopsis:    Object Manager initialization function
//
//////////////////////////////////////////////////////////////////////////

static Callback* pInitCallback = NULL;
static CTheWorkerThread InitThread;

STDMETHODIMP 
CWBEMServiceMgr::InitializeManager(
                     /*[in]*/ IApplianceObjectManagerStatus* pObjMgrStatus
                                  )

{
    //
    // we ignore the IApplianceObjectManagerStatus interface here as we are
    // not sending any status back
    //
    CLockIt theLock(*this);

    if ( NULL != pInitCallback )
    {
        return S_OK;
    }

    HRESULT hr = E_FAIL;

    TRY_IT

    // Initialize the Chameleon services... Note that we don't currently 
    // consider it fatal if a Chameleon service does not start. 
    
    pInitCallback = MakeCallback(this, &CWBEMServiceMgr::InitializeChameleonServices);
    if ( NULL != pInitCallback )
    {
        if ( InitThread.Start(0, pInitCallback) )
        { 
            hr = S_OK;
        }
        else
        {
            SATraceString("CWBEMServiceMgr::InitializeService() - Failed - Could not create service initialization thread...");
        }
    }

    CATCH_AND_SET_HR

    if ( FAILED(hr) )
    {
        if ( pInitCallback )
        {
            delete pInitCallback;
            pInitCallback = NULL;
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////
//
// Function:    ShutdownService()
//
// Synopsis:    Object Manager shutdown functions
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CWBEMServiceMgr::ShutdownManager(void)
{
    CLockIt theLock(*this);
    
    if ( NULL == pInitCallback )
    {
        return S_OK;
    }

    HRESULT hr = S_OK;

    TRY_IT

    // Shutdown the initialization thread (if its still running)
    if ( pInitCallback )
    {
        InitThread.End(0, false);
        delete pInitCallback;
        pInitCallback = NULL;
    }

    ShutdownChameleonServices();

    CATCH_AND_SET_HR

    return hr;
}


///////////////////////////////////////////////////////////////////////////
//
// Function:    OrderServices()
//
// Synopsis:    Order the collection of Chameleon services based on Merit
//
//////////////////////////////////////////////////////////////////////////
bool CWBEMServiceMgr::OrderServices(
                             /*[in]*/ MeritMap& theMap
                                     )
{
    bool bReturn = true;

    ObjMapIterator p = m_ObjMap.begin();
    while (  p != m_ObjMap.end() )
    {
        _variant_t vtMerit;
        HRESULT hr = ((*p).second)->GetProperty(bstrMerit, &vtMerit);
        if ( FAILED(hr) )
        {
            SATracePrintf("CWBEMServiceMgr::OrderServices() - Failed - GetProperty() returned...", hr);
            bReturn = false;
            break; 
        }
        
        _ASSERT( VT_I4 == V_VT(&vtMerit) );

        MeritMapIterator q = theMap.insert(MeritMap::value_type(V_I4(&vtMerit), (*p).second));
        if ( q == theMap.end() )
        { 
            SATraceString("CWBEMServiceMgr::OrderServices() - Failed - multimap.insert() failed...");
            bReturn = false;
            break; 
        }
        p++;
    }
    return bReturn;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:    InitializeChameleonServices()
//
// Synopsis:    Worker thread function that initializes the Chameleon services
//
//////////////////////////////////////////////////////////////////////////////
void CWBEMServiceMgr::InitializeChameleonServices(void)
{
    bool bAllServicesInitialized = false;

    try
    {
        // Start monitoring the service surrogate process
        StartSurrogate();

        // Initialize the Chameleon services
        SATraceString("CWBEMServiceMgr::InitializeChameleonServices() - Initializing the Chameleon services...");

        // Sort the Chameleon services by merit
        MeritMap theMeritMap;
        if ( OrderServices(theMeritMap) )
        {
            // Initialize from lowest to highest merit
            MeritMapIterator p = theMeritMap.begin();
            while (  p != theMeritMap.end() )
            {
                {
                    _variant_t vtServiceName;
                    HRESULT hr = ((*p).second)->GetProperty(bstrServiceName, &vtServiceName);
                    if ( FAILED(hr) )
                    {
                        SATraceString("CWBEMServiceMgr::InitializeChameleonServices() - Could not obtain service name property...");
                        break;
                    }
                    else
                    {
                        SATracePrintf("CWBEMServiceMgr::InitializeChameleonServices() - Initializing Chameleon service '%ls'...",V_BSTR(&vtServiceName));
                        hr = ((*p).second)->Initialize();
                        if ( SUCCEEDED(hr) )
                        {
                            SATracePrintf("CWBEMServiceMgr::InitializeChameleonServices() -  Initialized Chameleon service '%ls'...", V_BSTR(&vtServiceName));
                        }
                        else
                        {
                            SATracePrintf("CWBEMServiceMgr::InitializeChameleonServices() - Chameleon service '%ls' failed to initialize - hr = %lx...", V_BSTR(&vtServiceName), hr);
                            break;
                        }
                    }
                }
                p++;
            }
            if ( p == theMeritMap.end() )
            {
                bAllServicesInitialized = true;
            }
        }
    }
    catch(...)
    {
        SATracePrintf("CWBEMServiceMgr::InitializeChameleonServices() - Caught unhandled exception...");
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:    ShutdownChameleonServices()
//
// Synopsis:    Worker thread function that shuts down the Chameleon services
//
//////////////////////////////////////////////////////////////////////////////
void CWBEMServiceMgr::ShutdownChameleonServices(void)
{
    try
    {
        // Stop monitoring the service surrogate process
        StopSurrogate();

        // Shutdown the Chameleon services
        SATraceString("CWBEMServiceMgr::ShutdownService() - Shutting down the Chameleon services...");

        // Sort the Chameleon services by merit
        MeritMap theMeritMap;
        if ( OrderServices(theMeritMap) )
        { 
            // Shutdown the services from highest to lowest merit
            MeritMapReverseIterator p = theMeritMap.rbegin();
            while (  p != theMeritMap.rend() )
            {
                {
                    _variant_t vtServiceName;
                    HRESULT hr = ((*p).second)->GetProperty(bstrServiceName, &vtServiceName);
                    if ( FAILED(hr) )
                    {
                        SATraceString("CWBEMServiceMgr::ShutdownChameleonService() - Could not obtain service name...");
                    }
                    else
                    {
                        SATracePrintf("CWBEMServiceMgr::ShutdownChameleonService() - Shutting down Chameleon service '%ls'...",V_BSTR(&vtServiceName));
                        hr = ((*p).second)->Shutdown();
                        if ( SUCCEEDED(hr) )
                        {
                            SATracePrintf("CWBEMServiceMgr::ShutdownChameleonService() - Successfully shutdown Chameleon service '%ls'...", V_BSTR(&vtServiceName));
                        }
                        else
                        {
                            SATracePrintf("CWBEMServiceMgr::ShutdownChameleonService() - Chameleon service '%ls' failed to shutdown...", V_BSTR(&vtServiceName));
                        }
                    }
                }
                p++;
            }
        }
    }
    catch(...)
    {
        SATracePrintf("CWBEMServiceMgr::ShutdownChameleonServices() - Caught unhandled exception...");
    }
}

const _bstr_t    bstrProcessId = L"SurrogateProcessId";

/////////////////////////////////////////////////////////////////////////////
//
// Function:    StartSurrogate()
//
// Synopsis:    Starts the service surrogate process
//
//////////////////////////////////////////////////////////////////////////////
void 
CWBEMServiceMgr::StartSurrogate(void)
{
    CLockIt theLock(*this);

    try
    {
        // Free existing references to the surrogate
        StopSurrogate();

        // Establish or reestablish communication with the surrogate
        HRESULT hr = CoCreateInstance(
                                        CLSID_ServiceSurrogate,
                                        NULL,
                                        CLSCTX_LOCAL_SERVER,
                                        IID_IApplianceObject,
                                        (void**)&m_pSurrogate
                                     );
        if ( SUCCEEDED(hr) )
        {
            hr = m_pSurrogate->Initialize();
            if ( SUCCEEDED(hr) )
            {
                SATraceString ("CWBEMServiceMgr::StartSurrogate() succeeded Surrogate initialization");
            }
            else
            {
                m_pSurrogate.Release();
                SATracePrintf("CWBEMServiceMgr::StartSurrogate() - Failed - IApplianceObject::Initialize() returned %lx", hr);
            }
        }
        else
        {
            SATracePrintf("CWBEMServiceMgr::StartSurrogate() - Failed - CoCreateInstance() returned %lx", hr);
        }
    }
    catch(...)
    {
        SATraceString("CWBEMServiceMgr::StartSurrogate() - Failed - Caught unhandled exception");
        StopSurrogate();
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// Function:    StopSurrogate()
//
// Synopsis:    Stops monitoring the service surrogate process
//
//////////////////////////////////////////////////////////////////////////////
void 
CWBEMServiceMgr::StopSurrogate()
{
    CLockIt theLock(*this);

    try
    {
        m_pSurrogate.Release();
        if ( m_hSurrogateProcess )
        {
            CloseHandle(m_hSurrogateProcess);
            m_hSurrogateProcess = NULL;
        }
    }
    catch(...)
    {
        SATraceString("CWBEMServiceMgr::StopSurrogate() - Failed - Caught unhandled exception");
    }
}



/////////////////////////////////////////////////////////////////////////////
//
// Function:    SurrogateTerminationFunc
//
// Synopsis:    Function called if the service surrogate process terminates
//
//////////////////////////////////////////////////////////////////////////////
void 
WINAPI CWBEMServiceMgr::SurrogateTerminationFunc(HANDLE hProcess, PVOID pThis)
{
    ((CWBEMServiceMgr*)pThis)->InitializeChameleonServices();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemtask.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemtask.cpp
//
// Project:     Chameleon
//
// Description: WBEM Appliance Task Object Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wbemtask.h"

static _bstr_t bstrStatus = PROPERTY_SERVICE_STATUS;    
static _bstr_t bstrAvailability = PROPERTY_TASK_AVAILABILITY;
static _bstr_t bstrIsSingleton = PROPERTY_TASK_CONCURRENCY;
static _bstr_t bstrMaxExecutionTime = PROPERTY_TASK_MET;
static _bstr_t bstrRestartAction = PROPERTY_TASK_RESTART_ACTION;

///////////////////////////////////////////////////////////////////////////////
// IApplianceObject Interface Implmentation - see ApplianceObject.idl
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMTask::GetProperty(
                            /*[in]*/ BSTR     pszPropertyName, 
                   /*[out, retval]*/ VARIANT* pPropertyValue
                                   )
{
    HRESULT hr = E_FAIL;

    CLockIt theLock(*this);

    TRY_IT

    if ( GetPropertyInternal(pszPropertyName, pPropertyValue) )
    { 
        hr = WBEM_S_NO_ERROR;
    }

    CATCH_AND_SET_HR

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMTask::PutProperty(
                            /*[in]*/ BSTR     pszPropertyName, 
                            /*[in]*/ VARIANT* pPropertyValue
                                   )
{
    HRESULT hr = WBEM_E_FAILED;

    CLockIt theLock(*this);

    TRY_IT

    if ( PutPropertyInternal(pszPropertyName, pPropertyValue) )
    { 
        hr = WBEM_S_NO_ERROR;
    }

    CATCH_AND_SET_HR

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMTask::SaveProperties(void)
{

    HRESULT hr = WBEM_E_FAILED;

    CLockIt theLock(*this);

    TRY_IT

    _variant_t vtAvailability;
    _variant_t vtEmpty;

    if ( GetPropertyInternal(bstrAvailability, &vtAvailability) )
    {
        if ( RemovePropertyInternal(bstrAvailability) )
        {
            if ( SavePropertiesInternal() )
            {
                if ( AddPropertyInternal(bstrAvailability,&vtAvailability) )
                {
                    hr = WBEM_S_NO_ERROR;
                }
            }
        }
    }

    CATCH_AND_SET_HR

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMTask::Enable(void)
{
    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    _variant_t vtIsEnabled = (long)TRUE;

    CLockIt theLock(*this);

    if ( PutPropertyInternal(bstrStatus, &vtIsEnabled) )
    { 
        hr = SaveProperties();
    }

    CATCH_AND_SET_HR

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMTask::Disable(void)
{
    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    _variant_t vtIsEnabled = (long)FALSE;

    CLockIt theLock(*this);

    if ( PutPropertyInternal(bstrStatus, &vtIsEnabled) )
    {
        hr = SaveProperties();
    }

    CATCH_AND_SET_HR

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    InternalInitialize()
//
// Synopsis:    Function called by the component factory that enables the
//                component to load its state from the given property bag.
//
//////////////////////////////////////////////////////////////////////////

HRESULT CWBEMTask::InternalInitialize(
                               /*[in]*/ PPROPERTYBAG pPropertyBag
                                     )
{
    SATracePrintf("Initializing Task object '%ls'...", pPropertyBag->getName());

    HRESULT hr;

    do
    {
        // Defer to the base class... (see applianceobject.h)
        hr = CApplianceObject::InternalInitialize(pPropertyBag);
        if ( FAILED(hr) )
        {
            SATracePrintf("Task object '%ls' failed to initialize...", pPropertyBag->getName());
            break;
        }
        // Add defaults (may not be defined in registry)
        _variant_t    vtTaskProperty = (LONG) VARIANT_TRUE;
        if ( ! AddPropertyInternal(bstrAvailability, &vtTaskProperty) )
        {
            SATracePrintf("Task object '%ls' failed to initialize - Could not add property '%ls'...", PROPERTY_TASK_AVAILABILITY);
            break;
        }
        vtTaskProperty = (LONG) VARIANT_FALSE;
        if (  ! GetPropertyInternal(bstrIsSingleton, &vtTaskProperty) )
        {
            if ( ! AddPropertyInternal(bstrIsSingleton, &vtTaskProperty) )
            {
                hr = E_FAIL;
                SATracePrintf("Task object '%ls' failed to initialize - Could not add property '%ls'...", PROPERTY_TASK_CONCURRENCY);
                break;
            }
        }
        vtTaskProperty = (LONG) 0;
        if ( ! GetPropertyInternal(bstrMaxExecutionTime, &vtTaskProperty) )
        {
            if ( ! AddPropertyInternal(bstrMaxExecutionTime, &vtTaskProperty) )
            {
                hr = E_FAIL;
                SATracePrintf("Task object '%ls' failed to initialize - Could not add property '%ls'...", PROPERTY_TASK_MET);
                break;
            }
        }
        vtTaskProperty = (LONG) TASK_RESTART_ACTION_NONE;
        if (  ! GetPropertyInternal(bstrRestartAction, &vtTaskProperty) )
        {
            if ( ! AddPropertyInternal(bstrRestartAction, &vtTaskProperty) )
            {
                hr = E_FAIL;
                SATracePrintf("Task object '%ls' failed to initialize - Could not add property '%ls'...", PROPERTY_TASK_RESTART_ACTION);
                break;
            }
        }

        SATracePrintf("Task object '%ls' successfully initialized...", pPropertyBag->getName());

    } while ( FALSE );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemtaskmgr.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemtaskmgr.cpp
//
// Project:     Chameleon
//
// Description: WBEM Appliance Task Manager Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "appmgrutils.h"
#include "wbemtaskmgr.h"
#include "wbemtask.h"
#include <taskctx.h>

static _bstr_t bstrReturnValue = L"ReturnValue";
static _bstr_t bstrControlName = PROPERTY_TASK_CONTROL;
static _bstr_t bstrTaskStatus = PROPERTY_TASK_STATUS;
static _bstr_t bstrTaskConcurrency = PROPERTY_TASK_CONCURRENCY;
static _bstr_t bstrTaskAvailability = PROPERTY_TASK_AVAILABILITY;
static _bstr_t bstrCtx = PROPERTY_TASK_CONTEXT;
static _bstr_t bstrTaskMethodName = PROPERTY_TASK_METHOD_NAME;
static _bstr_t bstrMaxExecutionTime = PROPERTY_TASK_MET;
static _bstr_t bstrTaskExecutables = PROPERTY_TASK_EXECUTABLES;

extern "C" CLSID CLSID_TaskCoordinator;
//////////////////////////////////////////////////////////////////////////
// properties common to appliance object and WBEM class instance
//////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_PROPERTY_MAP(TaskProperties)
    DEFINE_OBJECT_PROPERTY(PROPERTY_TASK_STATUS)
    DEFINE_OBJECT_PROPERTY(PROPERTY_TASK_CONTROL)
    DEFINE_OBJECT_PROPERTY(PROPERTY_TASK_NAME)        
    DEFINE_OBJECT_PROPERTY(PROPERTY_TASK_EXECUTABLES)
    DEFINE_OBJECT_PROPERTY(PROPERTY_TASK_CONCURRENCY)
    DEFINE_OBJECT_PROPERTY(PROPERTY_TASK_MET)
    DEFINE_OBJECT_PROPERTY(PROPERTY_TASK_AVAILABILITY)
    DEFINE_OBJECT_PROPERTY(PROPERTY_TASK_RESTART_ACTION)
END_OBJECT_PROPERTY_MAP()

//////////////////////////////////////////////////////////////////////////
// IWbemServices Methods - Task Instance Provider
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetObjectAsync()
//
// Synopsis:    Get a specified instance of a WBEM class
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMTaskMgr::GetObjectAsync(
                                  /*[in]*/  const BSTR       strObjectPath,
                                  /*[in]*/  long             lFlags,
                                  /*[in]*/  IWbemContext*    pCtx,        
                                  /*[in]*/  IWbemObjectSink* pResponseHandler
                                         )
{
    // Check parameters (enforce function contract)
    _ASSERT( strObjectPath && pCtx && pResponseHandler );
    if ( strObjectPath == NULL || pCtx == NULL || pResponseHandler == NULL )
    { return WBEM_E_INVALID_PARAMETER; }

    HRESULT hr = WBEM_E_FAILED;
    
    TRY_IT

    do 
    {
                
        // Determine the object's class 
        _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrClass )
        { break; }

        // Retrieve the object's class definition. We'll use this
        // to initialize the returned instance.
        CComPtr<IWbemClassObject> pClassDefintion;
        hr = (::GetNameSpace())->GetObject(bstrClass, 0, pCtx, &pClassDefintion, NULL);
        if ( FAILED(hr) )
        { break; }

        // Get the object's instance key
        _bstr_t bstrKey(::GetObjectKey(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrKey )
        { break; }

        // Now try to locate the specified object
        hr = WBEM_E_NOT_FOUND;
        ObjMapIterator p = m_ObjMap.find((LPCWSTR)bstrKey);
        if ( p == m_ObjMap.end() )
        { break; }

        // Create a WBEM instance of the object and initialize it
        CComPtr<IWbemClassObject> pWbemObj;
        hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
        if ( FAILED(hr) )
        { break; }

        {
            CLockIt theLock(*this);
            hr = CWBEMProvider::InitWbemObject(TaskProperties, (*p).second, pWbemObj);
        }

        if ( FAILED(hr) )
        { break; }

        // Tell the caller about the new WBEM object
        pResponseHandler->Indicate(1, &pWbemObj.p);
        hr = WBEM_S_NO_ERROR;
    
    } while (FALSE);

    CATCH_AND_SET_HR

    pResponseHandler->SetStatus(0, hr, NULL, NULL);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemTaskMgr::GetObjectAsync() - Failed - Object: '%ls' Result Code: %lx", strObjectPath, hr); }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    CreateInstanceEnumAsync()
//
// Synopsis:    Enumerate the instances of the specified class
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMTaskMgr::CreateInstanceEnumAsync( 
                                         /* [in] */ const BSTR         strClass,
                                         /* [in] */ long             lFlags,
                                         /* [in] */ IWbemContext     *pCtx,
                                         /* [in] */ IWbemObjectSink  *pResponseHandler
                                                  )
{
    // Check parameters (enforce contract)
    _ASSERT( strClass && pCtx && pResponseHandler );
    if ( strClass == NULL || pCtx == NULL || pResponseHandler == NULL )
        return WBEM_E_INVALID_PARAMETER;
    
    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    // Retrieve the object's class definition. We'll use this
    // to initialize the returned instances.
    CComPtr<IWbemClassObject> pClassDefintion;
       hr = (::GetNameSpace())->GetObject(strClass, 0, pCtx, &pClassDefintion, NULL);
    if ( SUCCEEDED(hr) )
    {
        // Create and initialize a task wbem object instance
        // for each task and return same to the caller
        ObjMapIterator p = m_ObjMap.begin();
        while ( p != m_ObjMap.end() )
        {
            {
                CComPtr<IWbemClassObject> pWbemObj;
                hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
                if ( FAILED(hr) )
                { break; }

                {
                    CLockIt theLock(*this);
                    hr = CWBEMProvider::InitWbemObject(TaskProperties, (*p).second, pWbemObj);
                }

                if ( FAILED(hr) )
                { break; }

                pResponseHandler->Indicate(1, &pWbemObj.p);
            }

            p++; 
        }
    }

    CATCH_AND_SET_HR

    pResponseHandler->SetStatus(0, hr, 0, 0);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemTaskMgr::CreateInstanceEnumAsync() - Failed - Result Code: %lx", hr); }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    ExecMethodAsync()
//
// Synopsis:    Execute the specified method on the specified instance
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMTaskMgr::ExecMethodAsync(
                    /*[in]*/ const BSTR        strObjectPath,
                    /*[in]*/ const BSTR        strMethodName,
                    /*[in]*/ long              lFlags,
                    /*[in]*/ IWbemContext*     pCtx,        
                    /*[in]*/ IWbemClassObject* pInParams,
                    /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                          )
{
    // Check parameters (enforce contract)
    _ASSERT( strObjectPath && strMethodName /* && pResponseHandler */ );
    if ( NULL == strObjectPath || NULL == strMethodName /*|| NULL == pResponseHandler */ )
    { return WBEM_E_INVALID_PARAMETER; }
    
    HRESULT        hr = WBEM_E_FAILED;
    
    TRY_IT

    do
    {
        // Get the object's instance key (task name)
        _bstr_t bstrKey(::GetObjectKey(strObjectPath), false);
        if ( (LPCWSTR)bstrKey == NULL )
        { break; }

        // Now try to locate the specified task
        hr = WBEM_E_NOT_FOUND;
        ObjMapIterator p = m_ObjMap.find((LPCWSTR)bstrKey);
        if ( p == m_ObjMap.end() )
        { 
            SATracePrintf("CWBEMTaskMgr::ExecMethodAsync() - Could not locate task '%ls'...", (BSTR)bstrKey);
            break; 
        }

        // Task located... get the output parameter object
        // Determine the object's class 
        _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
        if ( (LPCWSTR)bstrClass == NULL )
        { break; }

        // Retrieve the object's class definition. 
        CComPtr<IWbemClassObject> pClassDefinition;
            hr = (::GetNameSpace())->GetObject(
                                            bstrClass, 
                                            0, 
                                            pCtx, 
                                            &pClassDefinition, 
                                            NULL
                                           );
        if ( FAILED(hr) )
        { break; }

        // Get an instance of IWbemClassObject for the output parameter
        CComPtr<IWbemClassObject> pMethodRet;
        hr = pClassDefinition->GetMethod(strMethodName, 0, NULL, &pMethodRet);
        if ( FAILED(hr) )
        { break; }

        CComPtr<IWbemClassObject> pOutParams;
        hr = pMethodRet->SpawnInstance(0, &pOutParams);
        if ( FAILED(hr) )
        { break; }

        if ( ! lstrcmp(strMethodName, METHOD_TASK_ENABLE_OBJECT) )
        {
            //
            // Attempt to enable the task -
            // dynamic enable and disable is not allowed anymore - MKarki (11/12/20001)
            //
            {
                SATraceString ("CWbemTaskMgr::ExecMethodAsync - enable task object not allowed");
                hr = WBEM_E_FAILED;
                break;
            }

            _variant_t vtReturnValue = ((*p).second)->Enable();
            
            // Set the method return value
            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if ( FAILED(hr) )
            { break; }

            // Tell the caller what happened
            SATracePrintf("CWbemTaskMgr::ExecMethodAsync() - Info - Enabled Task: %ls",(LPWSTR)bstrKey);
            if ( pResponseHandler )
            {
                pResponseHandler->Indicate(1, &pOutParams.p);
            }
        }
        else if ( ! lstrcmp(strMethodName, METHOD_TASK_DISABLE_OBJECT) )
        {
            //
            // Ensure that the task can be disabled
            // dynamic enable and disable is not allowed anymore - MKarki (11/12/2001)
            //
            {
                SATraceString ("CWbemTaskMgr::ExecMethodAsync - disable task object not allowed");
                hr = WBEM_E_FAILED;
                break; 
            }

            _variant_t vtControlValue;
            hr = ((*p).second)->GetProperty(bstrControlName, &vtControlValue);
            if (FAILED (hr))
            {break;}

            _variant_t vtReturnValue = (long)WBEM_E_FAILED;
            if ( VARIANT_FALSE != V_BOOL(&vtControlValue) )
            {  
                // Task can be disabled so disable it
                vtReturnValue = (HRESULT) ((*p).second)->Disable();
            }

            // Set the method return value
            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if ( FAILED(hr) )
            { break; }

            // Tell the caller what happened
            SATracePrintf("CWbemTaskMgr::ExecMethodAsync() - Info - Disabled Task: %ls",(LPWSTR)bstrKey);
            if ( pResponseHandler )
            {
                pResponseHandler->Indicate(1, &pOutParams.p);    
            }
        }
        else if ( ! lstrcmp(strMethodName, METHOD_TASK_EXECUTE) )
        {
            // Task execution... 

            _variant_t    vtTaskProperty;
            _variant_t    vtTaskConcurrency = VARIANT_FALSE;

            hr = WBEM_E_FAILED;

            // Enter critical section
            //
            // Is Task Enabled ?
            //    Yes... 
            //    Is Task a Singleton?
            //       Yes...
            //       Is Task Currently Busy?
            //          No...
            //          Set Task State to "Busy"
            //
            // End critical section

            {
                CLockIt theLock(*this);

                if ( FAILED(((*p).second)->GetProperty(
                                                        bstrTaskStatus, 
                                                        &vtTaskProperty
                                                      )) )
                { break; }

                if ( VARIANT_FALSE == V_BOOL(&vtTaskProperty) )
                { 
                    SATracePrintf("CWBEMTaskMgr::ExecMethod() - Failed - Task '%ls' is disabled...", (LPCWSTR)bstrKey);
                    break; 
                }
                
                if ( FAILED(((*p).second)->GetProperty(
                                                        bstrTaskConcurrency, 
                                                        &vtTaskConcurrency
                                                      )) )
                { break; }

                if ( VARIANT_FALSE != V_BOOL(&vtTaskConcurrency) )
                {
                    if ( FAILED(((*p).second)->GetProperty(
                                                            bstrTaskAvailability, 
                                                            &vtTaskProperty
                                                          )) )
                    { break; }

                    if ( VARIANT_FALSE == V_BOOL(&vtTaskProperty) )
                    { 
                        SATracePrintf("CWBEMTaskMgr::ExecMethod() - Failed - Task '%ls' is busy...", (LPCWSTR)bstrKey);
                        hr = WBEM_E_PROVIDER_NOT_CAPABLE;
                        break; 
                    }
                    else
                    {
                        vtTaskProperty = VARIANT_FALSE;
                        if ( FAILED(((*p).second)->PutProperty(
                                                                bstrTaskAvailability, 
                                                                &vtTaskProperty
                                                              )) )
                        { break; }
                    }
                }
            }

            // Create a task context object and associate it with the wbem
            // context object. The task context is a thin wraper around an 
            // object that exports IWBEMContext. Its only value add is the
            // ability to persist task parameters.

            CComPtr<ITaskContext> pTaskContext; 
            if ( FAILED(CoCreateInstance(
                                          CLSID_TaskContext,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_ITaskContext,
                                          (void**)&pTaskContext
                                        )) )
            { break; }

            if ( pCtx )
            {
                _variant_t vtCtx = (IUnknown*)((IWbemContext*)pCtx);
                if ( FAILED(pTaskContext->SetParameter(bstrCtx, &vtCtx)) )
                { break; }
            }

            // Add the task name to the task context object. We do this so that
            // a single task executable can be used for multiple tasks
            vtTaskProperty = bstrKey;
            if ( FAILED(pTaskContext->SetParameter(
                                                   bstrTaskMethodName, 
                                                   &vtTaskProperty
                                                  )) )
            { break; }
            vtTaskProperty.Clear();

            // Add the task max execution time to the task context object.
            if ( FAILED(((*p).second)->GetProperty(
                                                    bstrMaxExecutionTime, 
                                                    &vtTaskProperty
                                                  )) )
            { break; }
            if ( FAILED(pTaskContext->SetParameter(
                                                    bstrMaxExecutionTime, 
                                                    &vtTaskProperty
                                                  )) )
            { break; }
            vtTaskProperty.Clear();

            // Add the task executables to the task context object.
            if ( FAILED(((*p).second)->GetProperty(
                                                    bstrTaskExecutables, 
                                                    &vtTaskProperty
                                                  )) )
            { break; }
            if ( FAILED(pTaskContext->SetParameter(
                                                   bstrTaskExecutables, 
                                                   &vtTaskProperty
                                                  )) )
            { break; }
            vtTaskProperty.Clear();

            // Add the task concurrency to the task context object
            if ( FAILED(pTaskContext->SetParameter(
                                                   bstrTaskConcurrency, 
                                                   &vtTaskConcurrency
                                                  )) )
            { break; }

            SATraceString ("CWbemTaskMgr::Creating Task Coordinator...");
            // Create the task coordinator (object responsible for executing the task)
            CComPtr<IApplianceTask> pTaskCoordinator; 
            //if ( FAILED(CoCreateInstance(
            HRESULT hr1 = CoCreateInstance(
                                          CLSID_TaskCoordinator,
                                          NULL,
                                          CLSCTX_LOCAL_SERVER,
                                          IID_IApplianceTask,
                                          (void**)&pTaskCoordinator
                                        ); 
                    if (FAILED (hr1))
            { 
                SATracePrintf ("CWbemTaskMgr::ExecMethodAsync() - Failed - Could not create task coordinator...:%x", hr1);
                break; 
            }

               // Ask the coordinator to execute the task
            SATracePrintf("CWbemTaskMgr::ExecMethodAsync() - Info - Executing Task: %ls...",(LPWSTR)bstrKey);
            _variant_t vtReturnValue = hr =  (HRESULT) pTaskCoordinator->OnTaskExecute(pTaskContext);
            if (FAILED (hr))
            {
                SATracePrintf ("CWbemTaskCoordinator::TaskCoordinator::OnTaskExecute failed:%x", hr);
                break;
            }
            
            // Set the task execution result
            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if ( FAILED(hr) )
            { 
                break; 
            }

            // Mark the task as available
            {
                CLockIt theLock(*this);
                if ( VARIANT_FALSE != V_BOOL(&vtTaskConcurrency) )
                {
                    vtTaskProperty = VARIANT_TRUE;
                    if ( FAILED(((*p).second)->PutProperty(
                                                            bstrTaskAvailability, 
                                                            &vtTaskProperty
                                                          )) )
                    {
                        SATraceString("CWbemTaskMgr::ExecMethodAsync() - Info - Could not reset task availability");
                    }
                }
            }
            // Tell the caller what happened
            if ( pResponseHandler )
            {
                pResponseHandler->Indicate(1, &pOutParams.p);    
            }
        }
        else
        {
            // Invalid method!
            SATracePrintf("CWbemTaskMgr::ExecMethodAsync() - Failed - Method '%ls' not supported...", (LPWSTR)bstrKey);
            hr = WBEM_E_NOT_FOUND;
            break;
        }

    } while ( FALSE );

    CATCH_AND_SET_HR

    if ( pResponseHandler )
    {
        pResponseHandler->SetStatus(0, hr, 0, 0);
    }        

    if ( FAILED(hr) )
    { SATracePrintf("CWbemTaskMgr::ExecMethodAsync() - Failed - Method: '%ls' Result Code: %lx", strMethodName, hr); }

    return hr;
}



//////////////////////////////////////////////////////////////////////////
//
// Function:    InternalInitialize()
//
// Synopsis:    Function called by the component factory that enables the
//                component to load its state from the given property bag.
//
//////////////////////////////////////////////////////////////////////////
HRESULT CWBEMTaskMgr::InternalInitialize(
                                  /*[in]*/ PPROPERTYBAG pPropertyBag
                                        )
{
    SATraceString("The Task Object Manager is initializing...");

    // Defer to the base class (see wbembase.h...)
    HRESULT hr = CWBEMProvider::InternalInitialize(
                                                    CLASS_WBEM_TASK_FACTORY, 
                                                    PROPERTY_TASK_NAME,
                                                    pPropertyBag
                                                  );
    if ( FAILED(hr) )
    {
        SATraceString("The Task Object Manager failed to initialize...");
    }
    else
    {
        SATraceString("The Task Object Manager was successfully initialized...");
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appsrvcs\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemtaskmgr.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemtaskmgr.h
//
// Project:     Chameleon
//
// Description: WBEM Appliance Task Manager Class 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_TASK_WBEM_OBJECT_MGR_H_
#define __INC_TASK_WBEM_OBJECT_MGR_H_

#include "resource.h"
#include "wbembase.h"

#pragma warning( disable : 4786 )
#include <string>
#include <map>
#include <list>
using namespace std;

#define        CLASS_WBEM_TASK_MGR_FACTORY        L"Microsoft_SA_Task"

//////////////////////////////////////////////////////////////////////////////
class CWBEMTaskMgr :  public CWBEMProvider
{

public:

    CWBEMTaskMgr() { }
    ~CWBEMTaskMgr() { }

BEGIN_COM_MAP(CWBEMTaskMgr)
    COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CWBEMTaskMgr, IWbemServices)

    //////////////////////////////////////////////////////////////////////////
    // IWbemServices Methods (Implemented by the ResourceMgr)
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP GetObjectAsync(
                        /*[in]*/  const BSTR       strObjectPath,
                        /*[in]*/  long             lFlags,
                        /*[in]*/  IWbemContext*    pCtx,        
                        /*[in]*/  IWbemObjectSink* pResponseHandler
                               );

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP CreateInstanceEnumAsync(
                                 /*[in]*/ const BSTR       strClass,
                                 /*[in]*/ long             lFlags,
                                 /*[in]*/ IWbemContext*    pCtx,        
                                 /*[in]*/ IWbemObjectSink* pResponseHandler
                                        );

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP ExecMethodAsync(
                      /*[in]*/ const BSTR        strObjectPath,
                      /*[in]*/ const BSTR        strMethodName,
                      /*[in]*/ long              lFlags,
                      /*[in]*/ IWbemContext*     pCtx,        
                      /*[in]*/ IWbemClassObject* pInParams,
                      /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                );


    //////////////////////////////////////////////////////////////////////////
    // CTaskMgr Methods
    //////////////////////////////////////////////////////////////////////////

    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              ) throw (_com_error);
private:

    CWBEMTaskMgr(const CWBEMTaskMgr& rhs);
    CWBEMTaskMgr& operator = (const CWBEMTaskMgr& rhs);

};


#endif // __INC_TASK_WBEM_OBJECT_MGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appsrvcs\appsrvcs.cpp ===
// appsrvcs.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f appsrvcsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "appsrvcs.h"
#include "appsrvcsimpl.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ApplianceServices, CApplianceServices)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // Can't use ATL 3.0 Stuff
        _Module.Init(ObjectMap, hInstance /* , &LIBID_APPSRVCSLib*/);
        DisableThreadLibraryCalls(hInstance);
    }
    else if ( dwReason == DLL_PROCESS_DETACH )
    {
        _Module.Term();
    }
    return TRUE;    
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    // Can't use ATL 3.0 Yes
    return _Module.UnregisterServer(/*TRUE*/);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appsrvcs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by appsrvcs.rc
//
#define IDS_PROJNAME                    100
#define IDS_APPLIANCESERVICES_DESC      101
#define IDR_ApplianceServices           102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appsrvcs\appsrvcsimpl.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      applianceservices.h
//
// Project:     Chameleon
//
// Description: Appliance Manager Services Class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 12/03/98     TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_APPLIANCE_SERVICES_H_
#define __INC_APPLIANCE_SERVICES_H_

#include "resource.h"       
#include "appsrvcs.h"
#include <applianceobject.h>
#include <wbemcli.h>        
#include <atlctl.h>

typedef struct _OBJECT_CLASS_INFO
{
    SA_OBJECT_TYPE    eType;
    LPCWSTR            szWBEMClass;

} OBJECT_CLASS_INFO, *POBJECT_CLASS_INFO;

#define        BEGIN_OBJECT_CLASS_INFO_MAP(x)                    static OBJECT_CLASS_INFO x[] = {
#define        DEFINE_OBJECT_CLASS_INFO_ENTRY(eType, szClass)    { eType, szClass },
#define        END_OBJECT_CLASS_INFO_MAP()                        { (SA_OBJECT_TYPE)0, NULL } };

#define        CLASS_WBEM_APPMGR_KEY  L"=@";

/////////////////////////////////////////////////////////////////////////////
// CApplianceServices
class ATL_NO_VTABLE CApplianceServices : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CApplianceServices, &CLSID_ApplianceServices>,
    public IDispatchImpl<IApplianceServices, &IID_IApplianceServices, &LIBID_APPSRVCSLib>,
    public IObjectSafetyImpl<CApplianceServices>
{

public:

    CApplianceServices();

    ~CApplianceServices();

DECLARE_REGISTRY_RESOURCEID(IDR_ApplianceServices)

DECLARE_NOT_AGGREGATABLE(CApplianceServices)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CApplianceServices)
    COM_INTERFACE_ENTRY(IApplianceServices)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

    //
    // This interface is implemented to mark the component as safe for scripting
    // IObjectSafety interface methods
    //
    STDMETHOD(SetInterfaceSafetyOptions)
                        (
                        REFIID riid, 
                        DWORD dwOptionSetMask, 
                        DWORD dwEnabledOptions
                        )
    {

        BOOL bSuccess = ImpersonateSelf(SecurityImpersonation);
  
        if (!bSuccess)
        {
            return E_FAIL;

        }

        bSuccess = IsOperationAllowedForClient();

        RevertToSelf();

        return bSuccess? S_OK : E_FAIL;
    }
    //////////////////////////////////////////////////////////////////////////
    // IApplianceServices Interface
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD(Initialize)(void);

    STDMETHOD(InitializeFromContext)(IUnknown* pContext);

    STDMETHOD(ResetAppliance)(
                      /*[in]*/ VARIANT_BOOL bPowerOff
                             );

    STDMETHOD(RaiseAlert)(
                  /*[in]*/ LONG        lAlertType,
                  /*[in]*/ LONG        lAlertId,
                  /*[in]*/ BSTR        bstrAlertLog,
                  /*[in]*/ BSTR        bstrResourceName,
                  /*[in]*/ LONG     lTimeToLive,
                  /*[in]*/ VARIANT* pReplacementStrings,
                  /*[in]*/ VARIANT* pRawData,
         /*[out, retval]*/ LONG*    pAlertCookie
                         );

    STDMETHOD(ClearAlert)(
                 /*[in]*/ LONG lAlertCookie
                         );

    STDMETHOD(ClearAlertAll)(
                    /*[in]*/ LONG  lAlertID,
                    /*[in]*/ BSTR  bstrAlertLog
                            );

    STDMETHOD(ExecuteTask)(
                  /*[in]*/ BSTR      bstrTaskName,
              /*[in/out]*/ IUnknown* pTaskParams
                         );

    STDMETHOD(ExecuteTaskAsync)(
                        /*[in]*/ BSTR      bstrTaskName,
                    /*[in/out]*/ IUnknown* pTaskParams
                                );
                        
    STDMETHOD(EnableObject)(
                    /*[in]*/ LONG   lObjectType,
                    /*[in]*/ BSTR   bstrObjectName
                                    );

    STDMETHOD(DisableObject)(
                     /*[in]*/ LONG   lObjectType,
                     /*[in]*/ BSTR   bstrObjectName
                            );

    STDMETHOD(GetObjectProperty)(
                         /*[in]*/ LONG     lObjectType,
                         /*[in]*/ BSTR     bstrObjectName,
                         /*[in]*/ BSTR     bstrPropertyName,
                /*[out, retval]*/ VARIANT* pPropertyValue
                                );

    STDMETHOD(PutObjectProperty)(
                         /*[in]*/ LONG     lObjectType,
                         /*[in]*/ BSTR     bstrObjectName,
                         /*[in]*/ BSTR     bstrPropertyName,
                         /*[in]*/ VARIANT* pPropertyValue
                                );

    STDMETHOD(RaiseAlertEx)(
                 /*[in]*/ LONG lAlertType, 
                 /*[in]*/ LONG lAlertId, 
                 /*[in]*/ BSTR bstrAlertLog, 
                 /*[in]*/ BSTR bstrAlertSource, 
                 /*[in]*/ LONG lTimeToLive, 
                 /*[in]*/ VARIANT *pReplacementStrings, 
                 /*[in]*/ VARIANT *pRawData, 
                 /*[in]*/ LONG  lAlertFlags,
        /*[out, retval]*/ LONG* pAlertCookie 
                         );

    STDMETHOD(IsAlertPresent)(
                     /*[in]*/ LONG  lAertId, 
                     /*[in]*/ BSTR  bstrAlertLog,
            /*[out, retval]*/ VARIANT_BOOL* pvIsPresent
                             );

private:

    //////////////////////////////////////////////////////////////////////////
    //
    // create an array of BSTRS from an array (or reference to an array) of VARIANTs
    //
    HRESULT CreateBstrArrayFromVariantArray  (
                /*[in]*/        VARIANT* pVariantArray,
                /*[out]*/        VARIANT* pBstrArray,
                /*[out]*/        PDWORD  pdwCreatedArraySize
                );

    //
    //    delete the memory allocated for the BSTR array
    //
    VOID FreeBstrArray (
                /*[in]*/        VARIANT* pVariantArray,
                /*[in]*/        DWORD    dwArraySize
                );


    // Get the WBEM class for a given appliance object
    BSTR GetWBEMClass(SA_OBJECT_TYPE eType);

    HRESULT SavePersistentAlert(
                                 LONG lAlertType, 
                                 LONG lAlertId, 
                                 BSTR bstrAlertLog,
                                 BSTR bstrAlertSource, 
                                 LONG lTimeToLive, 
                                 VARIANT *pReplacementStrings, 
                                 LONG  lAlertFlages
                                );

    HRESULT RaiseAlertInternal(
                 /*[in]*/ LONG lAlertType, 
                 /*[in]*/ LONG lAlertId, 
                 /*[in]*/ BSTR bstrAlertLog, 
                 /*[in]*/ BSTR bstrAlertSource, 
                 /*[in]*/ LONG lTimeToLive, 
                 /*[in]*/ VARIANT *pReplacementStrings, 
                 /*[in]*/ VARIANT *pRawData, 
                 /*[in]*/ LONG  lAlertFlags,
        /*[out, retval]*/ LONG* pAlertCookie 
                            );

    HRESULT IsAlertSingletonPresent(
                     /*[in]*/ LONG  lAlertId, 
                     /*[in]*/ BSTR  bstrAlertLog,
            /*[out, retval]*/ VARIANT_BOOL *pvIsPresent
                                );

    //
    // 
    // IsOperationAllowedForClient - This function checks the token of the 
    // calling thread to see if the caller belongs to the Local System account
    // 
    BOOL IsOperationAllowedForClient (
                                      VOID
                                     );

    // True when we've been initialized 
    bool                        m_bInitialized;

    // Pointer to WM obtained when we initialized as a service
    CComPtr<IWbemServices>        m_pWbemSrvcs;
};

#endif //__INC_APPLIANCE_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appsrvcs\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__09A5FFB1_CB9E_11D2_90C3_00AA00A71DCA__INCLUDED_)
#define AFX_STDAFX_H__09A5FFB1_CB9E_11D2_90C3_00AA00A71DCA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__09A5FFB1_CB9E_11D2_90C3_00AA00A71DCA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemusermgr.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemusermgr.cpp
//
// Project:     Chameleon
//
// Description: WBEM Appliance User Manager Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wbemusermgr.h"
#include <appmgrobjs.h>
#include <appmgrutils.h>

//////////////////////////////////////////////////////////////////////////
// properties common to appliance object and WBEM class instance
//////////////////////////////////////////////////////////////////////////
BEGIN_OBJECT_PROPERTY_MAP(UserProperties)
    DEFINE_OBJECT_PROPERTY(PROPERTY_USER_SAMNAME)
    DEFINE_OBJECT_PROPERTY(PROPERTY_USER_FULLNAME)
    DEFINE_OBJECT_PROPERTY(PROPERTY_USER_ISADMIN)
    DEFINE_OBJECT_PROPERTY(PROPERTY_USER_SID)
    DEFINE_OBJECT_PROPERTY(PROPERTY_USER_CONTROL)
    DEFINE_OBJECT_PROPERTY(PROPERTY_USER_STATUS)
END_OBJECT_PROPERTY_MAP()


CWBEMUserMgr::CWBEMUserMgr()
    : m_pUserRetriever(NULL)
{

}


CWBEMUserMgr::~CWBEMUserMgr()
{
    if ( m_pUserRetriever )
    { delete m_pUserRetriever; }
}


//////////////////////////////////////////////////////////////////////////
// IWbemServices Methods - Task Instance Provider
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetObjectAsync()
//
// Synopsis:    Get a specified instance of a WBEM class
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMUserMgr::GetObjectAsync(
                                  /*[in]*/  const BSTR       strObjectPath,
                                  /*[in]*/  long             lFlags,
                                  /*[in]*/  IWbemContext*    pCtx,        
                                  /*[in]*/  IWbemObjectSink* pResponseHandler
                                         )
{
    // Check parameters (enforce function contract)
    _ASSERT( strObjectPath && pCtx && pResponseHandler );
    if ( strObjectPath == NULL || pCtx == NULL || pResponseHandler == NULL )
    { return WBEM_E_INVALID_PARAMETER; }

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    do 
    {
        // Determine the object's class 
        _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrClass )
        { break; }

        // Retrieve the object's class definition. We'll use this
        // to initialize the returned instance.
        CComPtr<IWbemClassObject> pClassDefintion;
        hr = (::GetNameSpace())->GetObject(bstrClass, 0, pCtx, &pClassDefintion, NULL);
        if ( FAILED(hr) )
        { break; }

        // Get the object's instance key
        _bstr_t bstrKey(::GetObjectKey(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrKey )
        { break; }

        // Create a WBEM instance of the object and initialize it
        CComPtr<IWbemClassObject> pWbemObj;
        hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
        if ( FAILED(hr) )
        { break; }

        // Now try to locate the specified user object
        hr = WBEM_E_NOT_FOUND;
        CComPtr<IApplianceObject> pUserObj;
        if ( FAILED(::LocateResourceObject(
                                            CLASS_WBEM_USER,            // Resource Type
                                              bstrKey,                    // Resource Name
                                           PROPERTY_USER_SAMNAME,    // Resource Name Property
                                           m_pUserRetriever,        // Resource Retriever
                                           &pUserObj
                                          )) )
        { break; }

        hr = CWBEMProvider::InitWbemObject(UserProperties, pUserObj, pWbemObj);
        if ( FAILED(hr) )
        { break; }

        // Tell the caller about the new WBEM object
        pResponseHandler->Indicate(1, &pWbemObj.p);
        hr = WBEM_S_NO_ERROR;
    
    } while (FALSE);

    CATCH_AND_SET_HR

    pResponseHandler->SetStatus(0, hr, NULL, NULL);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemUserMgr::GetObjectAsync() - Failed - Object: '%ls' Result Code: %lx", strObjectPath, hr); }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    CreateInstanceEnumAsync()
//
// Synopsis:    Enumerate the instances of the specified class
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMUserMgr::CreateInstanceEnumAsync( 
                                         /* [in] */ const BSTR         strClass,
                                         /* [in] */ long             lFlags,
                                         /* [in] */ IWbemContext     *pCtx,
                                         /* [in] */ IWbemObjectSink  *pResponseHandler
                                                  )
{
    // Check parameters (enforce contract)
    _ASSERT( strClass && pCtx && pResponseHandler );
    if ( strClass == NULL || pCtx == NULL || pResponseHandler == NULL )
        return WBEM_E_INVALID_PARAMETER;
    
    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    do
    {
        // Retrieve the object's class definition. We'll use this
        // to initialize the returned instances.
        CComPtr<IWbemClassObject> pClassDefintion;
           hr = (::GetNameSpace())->GetObject(strClass, 0, pCtx, &pClassDefintion, NULL);
        if ( FAILED(hr) )
        { break; }
            
        // Get the user object enumerator
        _variant_t vtResourceTypes = CLASS_WBEM_USER;
        CComPtr<IEnumVARIANT> pEnum;
        hr = ::LocateResourceObjects(
                                      &vtResourceTypes,
                                      m_pUserRetriever,
                                      &pEnum
                                    );
        if ( FAILED(hr) )
        { 
            hr = WBEM_E_FAILED;
            break; 
        }

        _variant_t    vtDispatch;
        DWORD        dwRetrieved = 1;

        hr = pEnum->Next(1, &vtDispatch, &dwRetrieved);
        if ( FAILED(hr) )
        { 
            hr = WBEM_E_FAILED;
            break; 
        }

        while ( S_OK == hr )
        {
            {
                CComPtr<IWbemClassObject> pWbemObj;
                hr = pClassDefintion->SpawnInstance(0, &pWbemObj);
                if ( FAILED(hr) )
                { break; }

                CComPtr<IApplianceObject> pUserObj;
                hr = vtDispatch.pdispVal->QueryInterface(IID_IApplianceObject, (void**)&pUserObj);
                if ( FAILED(hr) )
                { 
                    hr = WBEM_E_FAILED;
                    break; 
                }

                hr = CWBEMProvider::InitWbemObject(UserProperties, pUserObj, pWbemObj);
                if ( FAILED(hr) )
                { break; }

                pResponseHandler->Indicate(1, &pWbemObj.p);
            }

            vtDispatch.Clear();
            dwRetrieved = 1;
            hr = pEnum->Next(1, &vtDispatch, &dwRetrieved);
            if ( FAILED(hr) )
            {
                hr = WBEM_E_FAILED;
                break;
            }
        }

        if ( S_FALSE == hr )
        { hr = WBEM_S_NO_ERROR; }

    }
    while ( FALSE );
        
    CATCH_AND_SET_HR

    pResponseHandler->SetStatus(0, hr, 0, 0);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemUserMgr::CreateInstanceEnumAsync() - Failed - Result Code: %lx", hr); }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    ExecMethodAsync()
//
// Synopsis:    Execute the specified method on the specified instance
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CWBEMUserMgr::ExecMethodAsync(
                    /*[in]*/ const BSTR        strObjectPath,
                    /*[in]*/ const BSTR        strMethodName,
                    /*[in]*/ long              lFlags,
                    /*[in]*/ IWbemContext*     pCtx,        
                    /*[in]*/ IWbemClassObject* pInParams,
                    /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                          )
{
    // Check parameters (enforce contract)
    _ASSERT( strObjectPath && strMethodName && pResponseHandler );
    if ( NULL == strObjectPath || NULL == strMethodName || NULL == pResponseHandler )
    { return WBEM_E_INVALID_PARAMETER; }

    HRESULT hr = WBEM_E_FAILED;

    TRY_IT

    do
    {
        // Get the object's instance key (user name)
        _bstr_t bstrKey(::GetObjectKey(strObjectPath), false);
        if ( NULL == (LPCWSTR)bstrKey )
        { break; }

        // Now try to locate the specified service
        hr = WBEM_E_NOT_FOUND;
        CComPtr<IApplianceObject> pUserObj;
        if ( FAILED(::LocateResourceObject(
                                           CLASS_WBEM_USER,            // Resource Type
                                           bstrKey,                    // Resource Name
                                           PROPERTY_USER_SAMNAME,    // Resource Name Property
                                           m_pUserRetriever,        // Resource Retriever
                                           &pUserObj
                                          )) )
        { break; }

        // Service located... get the output parameter object
        // Determine the object's class 
        _bstr_t bstrClass(::GetObjectClass(strObjectPath), false);
        if ( (LPCWSTR)bstrClass == NULL )
        { break; }

        // Retrieve the object's class definition.
        CComPtr<IWbemClassObject> pClassDefinition;
        hr = (::GetNameSpace())->GetObject(bstrClass, 0, pCtx, &pClassDefinition, NULL);
        if ( FAILED(hr) )
        { break; }

        // Get an instance of IWbemClassObject for the output parameter
        CComPtr<IWbemClassObject> pMethodRet;
        hr = pClassDefinition->GetMethod(strMethodName, 0, NULL, &pMethodRet);
        if ( FAILED(hr) )
        { break; }

        CComPtr<IWbemClassObject> pOutParams;
        hr = pMethodRet->SpawnInstance(0, &pOutParams);
        if ( FAILED(hr) )
        { break; }

        _bstr_t bstrReturnValue = L"ReturnValue";

        if ( ! lstrcmp(strMethodName, METHOD_USER_ENABLE_OBJECT) )
        {
            // Attempt to enable the user
            _variant_t vtReturnValue = pUserObj->Enable();

            // Set the method return status
            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if ( FAILED(hr) )
            { break; }

            // Tell the caller what happened
            SATracePrintf("CWbemUserMgr::ExecMethodAsync() - Info - Enabled User: %ls",(LPWSTR)bstrKey);
            pResponseHandler->Indicate(1, &pOutParams.p);    
        }
        else if ( ! lstrcmp(strMethodName, METHOD_USER_DISABLE_OBJECT) )
        {
            // Ensure that the user can be disabled
            _variant_t vtControlValue;
            _bstr_t    bstrControlName = PROPERTY_SERVICE_CONTROL;
            hr = pUserObj->GetProperty(bstrControlName, &vtControlValue);
            if ( FAILED(hr) )
            { break; }

            _variant_t vtReturnValue = (long)WBEM_E_FAILED;
            if ( VARIANT_FALSE != V_BOOL(&vtControlValue) )
            { 
                // User can be disabled...
                vtReturnValue = pUserObj->Disable();
                if ( FAILED(hr) )
                { break; }
            }
            else
            {
                SATracePrintf("CWbemServiceMgr::ExecMethodAsync() - Info - Service '%ls' cannot be disabled...", bstrKey);
            }

            // Set the method return value
            hr = pOutParams->Put(bstrReturnValue, 0, &vtReturnValue, 0);      
            if (FAILED(hr) )
            { break; }

            SATracePrintf("CWbemUserMgr::ExecMethodAsync() - Info - Disabled User: %ls",(LPWSTR)bstrKey);
            pResponseHandler->Indicate(1, &pOutParams.p);    
        }
        else
        {
            // Invalid method!
            SATracePrintf("CWbemUserMgr::ExecMethodAsync() - Failed - Method '%ls' not supported...", (LPWSTR)bstrKey);
            hr = WBEM_E_NOT_FOUND;
            break;
        }

    } while ( FALSE );

    CATCH_AND_SET_HR

    pResponseHandler->SetStatus(0, hr, 0, 0);

    if ( FAILED(hr) )
    { SATracePrintf("CWbemServiceMgr::ExecMethodAsync() - Failed - Method: '%ls' Result Code: %lx", strMethodName, hr); }

    return hr;

}


//////////////////////////////////////////////////////////////////////////
//
// Function:    InternalInitialize()
//
// Synopsis:    Function called by the component factory that enables the
//                component to load its state from the given property bag.
//
//////////////////////////////////////////////////////////////////////////
HRESULT CWBEMUserMgr::InternalInitialize(
                                  /*[in]*/ PPROPERTYBAG pPropertyBag
                                        )
{
    SATraceString("The User Object Manager is initializing...");

    HRESULT hr = S_OK;

    TRY_IT

    PRESOURCERETRIEVER pUserRetriever = new CResourceRetriever(pPropertyBag);
    if ( NULL != pUserRetriever )
    { 
        m_pUserRetriever = pUserRetriever;
        SATraceString("The User Object Manager was successfully initialized...");
    }

    CATCH_AND_SET_HR

    if ( FAILED(hr) )
    {
        SATraceString("The User Object Manager failed to initialize...");
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appsrvcs\appsrvcsimpl.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      applianceservices.cpp
//
// Project:     Chameleon
//
// Description: Appliance Manager Services Class
//
// Log:
//
// When         Who            What
// ----         ---            ----
// 12/03/98     TLP            Initial Version
// 03/21/2001   i-xingj     Update for Persistent Alert
// 03/22/2001   mkarki        Update for variant array in replacement strings for raisealert
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "appsrvcs.h"
#include "appsrvcsimpl.h"
#include <basedefs.h>
#include <atlhlpr.h>
#include <appmgrobjs.h>
#include <satrace.h>
#include <wbemhlpr.h>
#include <taskctx.h>
#include <comdef.h>
#include <comutil.h>
#include <wbemcli.h>
#include <propertybagfactory.h>
#include <varvec.h>

const MAX_ALERTLOG_LENGTH = 128;

///////////////////////////////////////////////////////////////////////////////
// Constructor
///////////////////////////////////////////////////////////////////////////////
CApplianceServices::CApplianceServices()
    : m_bInitialized(false)
{ 

}

///////////////////////////////////////////////////////////////////////////////
// Destructor
///////////////////////////////////////////////////////////////////////////////
CApplianceServices::~CApplianceServices() 
{

}


//////////////////////////////////////////////////////////////////////////////
// Implementation of the IApplianceServices interface
//////////////////////////////////////////////////////////////////////////////
const WCHAR RETURN_VALUE [] = L"ReturnValue";
const WCHAR ALERT_QUERY [] =   L"SELECT * FROM Microsoft_SA_Alert WHERE AlertID=%d AND AlertLog=\"%s\"";
const LONG MaxDataLength = 32;

///////////////////////////////////////////////////////////////////////////////
//
// Function:    Initialize()
//
// Synopsis:    Called the prior to using other component services. Performs
//                component initialization operations.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::Initialize()
{
    CLockIt theLock(*this);

    HRESULT hr = S_OK;
    if ( ! m_bInitialized )
    {
        TRY_IT

        hr = ConnectToWM(&m_pWbemSrvcs);

        SATracePrintf("ConnectToWM return %d", hr);
    
        if ( SUCCEEDED(hr) )
        { 
            m_bInitialized = true; 
        }

        CATCH_AND_SET_HR
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function:    InitializeFromContext()
//
// Synopsis:    Called the prior to using other component services. Performs
//                component initialization operations.
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::InitializeFromContext(
                                               /*[in]*/ IUnknown* pContext
                                                      )
{
    CLockIt theLock(*this);

    if ( NULL == pContext )
    { return E_POINTER; }

    HRESULT hr = S_OK;

    if ( ! m_bInitialized )
    {
        TRY_IT

        hr = pContext->QueryInterface(IID_IWbemServices, (void**)&m_pWbemSrvcs);
        if ( SUCCEEDED(hr) )
        { 
            m_bInitialized = true; 
        }

        CATCH_AND_SET_HR

        if ( FAILED(hr) )
        {
            SATracePrintf("CApplianceServices::InitializeFromContext() - Failed with return: %lx", hr);
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:    ResetAppliance()
//
// Synopsis:    Called to reset the server appliance (perform an
//                orderly shutdown).
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::ResetAppliance(
                                        /*[in]*/ VARIANT_BOOL bPowerOff
                                               )
{
    HRESULT hr = E_UNEXPECTED;

    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        TRY_IT

        do
        {
            // Get a WBEM object for the ResetAppliance method in/out parameters
            CComPtr<IWbemClassObject> pWbemObj;
            _ASSERT( m_pWbemSrvcs );
            _bstr_t bstrPathAppMgr = CLASS_WBEM_APPMGR;
            hr = m_pWbemSrvcs->GetObject(
                                            bstrPathAppMgr,
                                            0,
                                            NULL,
                                            &pWbemObj,
                                            NULL
                                        );
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ResetAppliance() - Failed - IWbemServices::GetObject() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }
            
            CComPtr<IWbemClassObject> pObjIn;
            hr = pWbemObj->GetMethod(METHOD_APPMGR_RESET_APPLIANCE, 0, &pObjIn, NULL);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ResetAppliance() - Failed - IWbemClassObject::GetMethod() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            CComPtr<IWbemClassObject> pInParams;
            hr = pObjIn->SpawnInstance(0, &pInParams);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ResetAppliance() - Failed - IWbemClassObject::SpawnInstance() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            // power off;
            _variant_t vtPropertyValue;
            if ( VARIANT_FALSE == bPowerOff )
            {
                vtPropertyValue = (LONG)FALSE;
            }
            else
            {
                vtPropertyValue = (LONG)TRUE;
            }
            hr = pInParams->Put(PROPERTY_RESET_APPLIANCE_POWER_OFF, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ResetAppliance() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_TYPE);
                hr = E_FAIL;
                break; 
            }

            _bstr_t bstrMethodResetAppliance = METHOD_APPMGR_RESET_APPLIANCE;
            // Execute the ResetAppliance() method
            CComPtr<IWbemClassObject> pOutParams;
            _bstr_t bstrPathAppMgrKey = CLASS_WBEM_APPMGR;
            bstrPathAppMgrKey += CLASS_WBEM_APPMGR_KEY;
            hr = m_pWbemSrvcs->ExecMethod(
                                          bstrPathAppMgrKey,
                                          bstrMethodResetAppliance,
                                          0,
                                          NULL,
                                          pInParams,
                                          &pOutParams,
                                          NULL
                                         );
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ResetAppliance() - Failed - IWbemServices::ExecMethod() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            // Get the method return code
            _variant_t vtReturnValue;
            hr = pOutParams->Get(RETURN_VALUE, 0, &vtReturnValue, 0, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ClearAlert() - Failed - IWbemClassObject::Get() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            hr = V_I4(&vtReturnValue);
    
        } while ( FALSE );

        CATCH_AND_SET_HR
    }
    else
    {
        SATraceString("IApplianceServices::ResetAppliance() - Failed - Did you forget to invoke IApplianceServices::Initialize first?");
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Function:    RaiseAlert()
//
// Synopsis:    Called by to raise an appliance alert condition. (see 
//              applianceservices.idl for a complete interface description).
//
//////////////////////////////////////////////////////////////////////////////
const LONG lDummyCookie = 0;

STDMETHODIMP CApplianceServices::RaiseAlert(
                                    /*[in]*/ LONG      lAlertType,
                                    /*[in]*/ LONG      lAlertId,
                                    /*[in]*/ BSTR      bstrAlertLog,
                                    /*[in]*/ BSTR      bstrAlertSource,
                                    /*[in]*/ LONG     lTimeToLive,
                          /*[in, optional]*/ VARIANT* pReplacementStrings,
                          /*[in, optional]*/ VARIANT* pRawData,
                           /*[out, retval]*/ LONG*    pAlertCookie
                                           )
{
    return RaiseAlertInternal(  lAlertType,
                                lAlertId,
                                bstrAlertLog,
                                bstrAlertSource,
                                lTimeToLive,
                                pReplacementStrings,
                                pRawData,
                                SA_ALERT_FLAG_NONE,
                                pAlertCookie );
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    ClearAlert()
//
// Synopsis:    Called to clear an appliance alert condition.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::ClearAlert(
                                    /*[in]*/ LONG lAlertCookie
                                           )
{
    HRESULT hr = E_UNEXPECTED;

    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        TRY_IT

        do
        {
            // Get a WBEM object for the Clear Alert method in/out parameters
            CComPtr<IWbemClassObject> pWbemObj;
            _ASSERT( m_pWbemSrvcs );
            _bstr_t bstrPathAppMgr = CLASS_WBEM_APPMGR;
            hr = m_pWbemSrvcs->GetObject(
                                         bstrPathAppMgr,
                                         0,
                                         NULL,
                                         &pWbemObj,
                                         NULL
                                        );
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::ClearAlert() - Failed - IWbemServices::GetObject() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }
            CComPtr<IWbemClassObject> pObjIn;
            hr = pWbemObj->GetMethod(METHOD_APPMGR_CLEAR_ALERT, 0, &pObjIn, NULL);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ClearAlert() - Failed - IWbemClassObject::GetMethod() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            CComPtr<IWbemClassObject> pInParams;
            hr = pObjIn->SpawnInstance(0, &pInParams);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ClearAlert() - Failed - IWbemClassObject::SpawnInstance() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            // Initialize the input parameters (alert cookie)
            _variant_t vtPropertyValue = (long)lAlertCookie;
            hr = pInParams->Put(PROPERTY_ALERT_COOKIE, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::ClearAlert() - Failed - IWbemClassObject::Put() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            // Execute the ClearAlert() method - pass the call 
            // to the alert object manager
            CComPtr<IWbemClassObject> pOutParams;
            _bstr_t bstrMethodClearAlert = METHOD_APPMGR_CLEAR_ALERT;
            _bstr_t bstrPathAppMgrKey = CLASS_WBEM_APPMGR;
            bstrPathAppMgrKey += CLASS_WBEM_APPMGR_KEY;
            hr = m_pWbemSrvcs->ExecMethod(
                                          bstrPathAppMgrKey,
                                          bstrMethodClearAlert,
                                          0,
                                          NULL,
                                          pInParams,
                                          &pOutParams,
                                          NULL
                                         );
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ClearAlert() - Failed - IWbemServices::ExecMethod() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }

            // Return the cookie to the caller if the function succeeds
            _variant_t vtReturnValue;
            hr = pOutParams->Get(RETURN_VALUE, 0, &vtReturnValue, 0, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ClearAlert() - Failed - IWbemClassObject::Get() returned %lx...", hr);
                hr = E_FAIL;                
                break; 
            }
            hr = V_I4(&vtReturnValue);
    
        } while ( FALSE );

        CATCH_AND_SET_HR
    }
    else
    {
        SATraceString("IApplianceServices::ExecuteTask() - Failed - Did you forget to invoke IApplianceServices::Initialize first?");
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function:    ClearAlertAll()
//
// Synopsis:    Called by the internal core components to clear
//                all appliance alert conditions that meet specified criteria
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::ClearAlertAll(
                                       /*[in]*/ LONG  lAlertID,
                                       /*[in]*/ BSTR  bstrAlertLog
                                              )
{
    HRESULT hr = E_UNEXPECTED;

    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        TRY_IT

        do
        {
            // Get a WBEM object for the Clear Alert method in/out parameters
            CComPtr<IWbemClassObject> pWbemObj;
            _ASSERT( m_pWbemSrvcs );
            _bstr_t bstrPathAppMgr = CLASS_WBEM_APPMGR;
            hr = m_pWbemSrvcs->GetObject(
                                         bstrPathAppMgr,
                                         0,
                                         NULL,
                                         &pWbemObj,
                                         NULL
                                        );
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::ClearAlertAll() - Failed - IWbemServices::GetObject() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }
            CComPtr<IWbemClassObject> pObjIn;
            hr = pWbemObj->GetMethod(METHOD_APPMGR_CLEAR_ALERT_ALL, 0, &pObjIn, NULL);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ClearAlertAll() - Failed - IWbemClassObject::GetMethod() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            CComPtr<IWbemClassObject> pInParams;
            hr = pObjIn->SpawnInstance(0, &pInParams);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ClearAlertAll() - Failed - IWbemClassObject::SpawnInstance() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            // Initialize the input parameters (alert cookie)
            _variant_t vtPropertyValue = lAlertID;
            hr = pInParams->Put(PROPERTY_ALERT_ID, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::ClearAlertAll() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_ID);
                hr = E_FAIL;
                break; 
            }
            if ( ! lstrlen(bstrAlertLog) )
            {
                vtPropertyValue = DEFAULT_ALERT_LOG;
            }
            else
            {
                vtPropertyValue = bstrAlertLog;
            }
            hr = pInParams->Put(PROPERTY_ALERT_LOG, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::ClearAlertAll() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_LOG);
                hr = E_FAIL;
                break; 
            }
            // Execute the ClearAllAlerts() method - pass the call 
            // to the alert object manager
            CComPtr<IWbemClassObject> pOutParams;
            _bstr_t bstrMethodClearAll = METHOD_APPMGR_CLEAR_ALERT_ALL;
            _bstr_t bstrPathAppMgrKey = CLASS_WBEM_APPMGR;
            bstrPathAppMgrKey += CLASS_WBEM_APPMGR_KEY;
            hr = m_pWbemSrvcs->ExecMethod(
                                          bstrPathAppMgrKey,
                                          bstrMethodClearAll,
                                          0,
                                          NULL,
                                          pInParams,
                                          &pOutParams,
                                          NULL
                                         );
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ClearAlertAll() - Failed - IWbemServices::ExecMethod() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }

            // Return the function return value to the caller.
            _variant_t vtReturnValue;
            hr = pOutParams->Get(RETURN_VALUE, 0, &vtReturnValue, 0, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ClearAlertAll() - Failed - IWbemClassObject::Get() returned %lx...", hr);
                hr = E_FAIL;                
                break; 
            }
            hr = V_I4(&vtReturnValue);
            if ( WBEM_E_NOT_FOUND == hr )
            { hr = DISP_E_MEMBERNOTFOUND; }
    
        } while ( FALSE );

        CATCH_AND_SET_HR
    }
    else
    {
        SATraceString("IApplianceServices::ExecuteTask() - Failed - Did you forget to invoke IApplianceServices::Initialize first?");
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    ExecuteTask()
//
// Synopsis:    Called by the internal core components to execute
//                appliance tasks
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::ExecuteTask(
                                     /*[in]*/ BSTR       bstrTaskName,
                                     /*[in]*/ IUnknown*  pTaskParams
                                            )
{
    HRESULT hr = E_UNEXPECTED;
    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        _ASSERT( NULL != pTaskParams && NULL != bstrTaskName );
        if ( NULL == pTaskParams || NULL == bstrTaskName )
        { 
            SATraceString("IApplianceServices::ExecuteTask() - Failed - NULL argument(s) specified...");
            return E_POINTER; 
        }

        TRY_IT

        do
        {
            // Get the WBEM context object for the task
            CComPtr<ITaskContext> pTaskContext;
            hr = pTaskParams->QueryInterface(IID_ITaskContext, (void**)&pTaskContext);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ExecuteTask() - Failed - IUnknown::QueryInterface() returned %lx...", hr);
                break; 
            }
            _variant_t vtWbemCtx;
            _bstr_t bstrWbemCtx = PROPERTY_TASK_CONTEXT;
            hr = pTaskContext->GetParameter(bstrWbemCtx, &vtWbemCtx);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ExecuteTask() - Failed - ITaskContext::GetParameter() returned %lx for parameter '%ls'...", hr, (LPWSTR)PROPERTY_TASK_CONTEXT);
                break; 
            }
            _ASSERT( V_VT(&vtWbemCtx) == VT_UNKNOWN );
            CComPtr<IWbemContext> pWbemCtx;
            hr = (V_UNKNOWN(&vtWbemCtx))->QueryInterface(IID_IWbemContext, (void**)&pWbemCtx);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ExecuteTask() - Failed - IUnknown::QueryInterface() returned %lx...", hr);
                break; 
            }
            // Now execute the task...
            _bstr_t bstrPath = CLASS_WBEM_TASK;
            bstrPath += L"=\"";
            bstrPath += bstrTaskName;
            bstrPath += L"\"";
            CComPtr<IWbemClassObject> pOutParams;
            _bstr_t bstrMethodExecuteTask = METHOD_APPMGR_EXECUTE_TASK;
            hr = m_pWbemSrvcs->ExecMethod(
                                          bstrPath,
                                          bstrMethodExecuteTask,
                                          0,
                                          pWbemCtx,
                                          NULL,
                                          &pOutParams,
                                          NULL
                                         );
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::ExecuteTask() - Failed - IWbemServices::ExecMethod() returned %lx for method '%ls'...", hr, (BSTR)bstrTaskName);
                hr = E_FAIL;
                break;
            }
            // Return the function result code to the caller
            _variant_t vtReturnValue;
            hr = pOutParams->Get(RETURN_VALUE, 0, &vtReturnValue, 0, 0);
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::ExecuteTask() - Failed - IWbemClassObeject::Get() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }
            hr = V_I4(&vtReturnValue);

        } while ( FALSE );

        CATCH_AND_SET_HR
    }
    else
    {
        SATraceString("IApplianceServices::ExecuteTask() - Failed - Did you forget to invoke IApplianceServices::Initialize first?");
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function:    ExecuteTaskAsync()
//
// Synopsis:    Called by the internal core components to execute
//                appliance tasks asynchronously.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::ExecuteTaskAsync(
                                          /*[in]*/ BSTR       bstrTaskName,
                                          /*[in]*/ IUnknown*  pTaskParams
                                                 )
{
    HRESULT hr = E_UNEXPECTED;
    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        _ASSERT( NULL != pTaskParams && NULL != bstrTaskName );
        if ( NULL == pTaskParams || NULL == bstrTaskName )
        { 
            SATraceString("IApplianceServices::ExecuteTaskAsync() - Failed - NULL argument(s) specified...");
            return E_POINTER; 
        }

        TRY_IT

        do
        {
            // Mark the task as async
            CComPtr<ITaskContext> pTaskContext;
            hr = pTaskParams->QueryInterface(IID_ITaskContext, (void**)&pTaskContext);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ExecuteTaskAsync() - Failed - IUnknown::QueryInterface() returned %lx...", hr);
                break; 
            }
            _variant_t vtAsyncTask = VARIANT_TRUE;
            _bstr_t bstrAsyncTask = PROPERTY_TASK_ASYNC;
            hr = pTaskContext->SetParameter(bstrAsyncTask, &vtAsyncTask);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ExecuteTaskAsync() - Failed - ITaskContext::PutParameter() returned %lx...", hr);
                break; 
            }
            // Get the WBEM context object for the task
            _variant_t vtWbemCtx;
            _bstr_t bstrWbemCtx = PROPERTY_TASK_CONTEXT;
            hr = pTaskContext->GetParameter(bstrWbemCtx, &vtWbemCtx);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ExecuteTaskAsync() - Failed - ITaskContext::GetParameter() returned %lx for parameter '%ls'...", hr, (LPWSTR)PROPERTY_TASK_CONTEXT);
                break; 
            }
            _ASSERT( V_VT(&vtWbemCtx) == VT_UNKNOWN );
            CComPtr<IWbemContext> pWbemCtx;
            hr = (V_UNKNOWN(&vtWbemCtx))->QueryInterface(IID_IWbemContext, (void**)&pWbemCtx);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::ExecuteTaskAsync() - Failed - IUnknown::QueryInterface() returned %lx...", hr);
                break; 
            }
            // Now initiate task execution. Note that task execution will complete asynchronously and
            // we'll never know the final outcome here...
            _bstr_t bstrPath = CLASS_WBEM_TASK;
            bstrPath += L"=\"";
            bstrPath += bstrTaskName;
            bstrPath += L"\"";
            CComPtr<IWbemClassObject> pOutParams;
            _bstr_t bstrMethodExecuteTask = METHOD_APPMGR_EXECUTE_TASK;
            hr = m_pWbemSrvcs->ExecMethod(
                                          bstrPath,
                                          bstrMethodExecuteTask,
                                          0,
                                          pWbemCtx,
                                          NULL,
                                          &pOutParams,
                                          NULL
                                         );
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::ExecuteTaskAsync() - Failed - IWbemServices::ExecMethod() returned %lx for method '%ls'...", hr, (BSTR)bstrTaskName);
                hr = E_FAIL;
                break;
            }
            // Return the function result code to the caller
            _variant_t vtReturnValue;
            hr = pOutParams->Get(RETURN_VALUE, 0, &vtReturnValue, 0, 0);
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::ExecuteTaskAsync() - Failed - IWbemClassObeject::Get() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }
            hr = V_I4(&vtReturnValue);

        } while ( FALSE );

        CATCH_AND_SET_HR
    }
    else
    {
        SATraceString("IApplianceServices::ExecuteTaskAsync() - Failed - Did you forget to invoke IApplianceServices::Initialize first?");
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    EnableObject()
//
// Synopsis:    Used to enable an appliance core object 
//                (task, service, etc.).
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::EnableObject(
                                      /*[in]*/ LONG   lObjectType,
                                      /*[in]*/ BSTR   bstrObjectName
                                             )
{
    HRESULT hr = E_UNEXPECTED;
    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        _ASSERT( NULL != bstrObjectName );
        if ( NULL == bstrObjectName )
        { 
            SATraceString("IApplianceServices::ExecuteTask() - Failed - NULL argument(s) specified...");
            return E_POINTER; 
        }

        TRY_IT

        do
        {
            _bstr_t    bstrPath(GetWBEMClass((SA_OBJECT_TYPE)lObjectType), false);
            if ( NULL == (LPWSTR)bstrPath )
            {
                SATraceString("IApplianceServices::EnableObject() - Failed - Could not get WBEM class...");
                hr = E_FAIL;
                break;
            }

            // Enable the object
            bstrPath += L"=\"";
            bstrPath += bstrObjectName;
            bstrPath += L"\"";
            CComPtr<IWbemClassObject> pOutParams;
            _bstr_t bstrMethodEnable = METHOD_APPMGR_ENABLE_OBJECT;
            hr = m_pWbemSrvcs->ExecMethod(
                                          bstrPath,
                                          bstrMethodEnable,
                                          0,
                                          NULL,
                                          NULL,
                                          &pOutParams,
                                          NULL
                                         );
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::EnableObject() - Failed - IWbemServices::ExecMethod() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }

            // Return the function result code to the caller
            _variant_t vtReturnValue;
            hr = pOutParams->Get(RETURN_VALUE, 0, &vtReturnValue, 0, 0);
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::EnableObject() - Failed - IWbemClassObject::Get() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }
            hr = V_I4(&vtReturnValue);

        } while ( FALSE );

        CATCH_AND_SET_HR
    }
    else
    {
        SATraceString("IApplianceServices::EnableObject() - Failed - Did you forget to invoke IApplianceServices::Initialize first?");
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    DisableObject()
//
// Synopsis:    Used to disable an appliance core object 
//                (task, service, etc.).
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::DisableObject(
                                       /*[in]*/ LONG   lObjectType,
                                       /*[in]*/ BSTR   bstrObjectName
                                              )
{
    HRESULT hr = E_UNEXPECTED;
    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        _ASSERT( NULL != bstrObjectName );
        if ( NULL == bstrObjectName )
        { 
            SATraceString("IApplianceServices::ExecuteTask() - Failed - NULL argument(s) specified...");
            return E_POINTER; 
        }

        TRY_IT

        do
        {
            _bstr_t    bstrPath(GetWBEMClass((SA_OBJECT_TYPE)lObjectType), false);
            if ( NULL == (LPWSTR)bstrPath )
            {
                SATraceString("IApplianceServices::DisableObject() - Failed - Could not get WBEM class...");
                hr = E_FAIL;
                break;
            }

            // Enable the object
            bstrPath += L"=\"";
            bstrPath += bstrObjectName;
            bstrPath += L"\"";
            CComPtr<IWbemClassObject> pOutParams;
            _bstr_t bstrMethodDisable = METHOD_APPMGR_DISABLE_OBJECT;
            hr = m_pWbemSrvcs->ExecMethod(
                                          bstrPath,
                                          bstrMethodDisable,
                                          0,
                                          NULL,
                                          NULL,
                                          &pOutParams,
                                          NULL
                                         );
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::DisableObject() - Failed - IWbemServices::ExecMethod() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }

            // Return the function result code to the caller
            _variant_t vtReturnValue;
            hr = pOutParams->Get(RETURN_VALUE, 0, &vtReturnValue, 0, 0);
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::DisableObject() - Failed - IWbemClassObject::Get() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }
            hr = V_I4(&vtReturnValue);

        } while ( FALSE );

        CATCH_AND_SET_HR
    }
    else
    {
        SATraceString("IApplianceServices::Disable() - Failed - Did you forget to invoke IApplianceServices::Initialize first?");
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    GetObjectProperty()
//
// Synopsis:    Used to retrieve an appliance core object property 
//                (task, service, etc.).
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::GetObjectProperty(
                                           /*[in]*/ LONG     lObjectType,
                                           /*[in]*/ BSTR     bstrObjectName,
                                           /*[in]*/ BSTR     bstrPropertyName,
                                  /*[out, retval]*/ VARIANT* pPropertyValue
                                                  )
{
    HRESULT hr = E_UNEXPECTED;
    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        _ASSERT( NULL != bstrObjectName && NULL != bstrPropertyName && NULL != pPropertyValue );
        if ( NULL == bstrObjectName || NULL == bstrPropertyName || NULL == pPropertyValue )
        {
            SATraceString("IApplianceServices::ExecuteTask() - Failed - NULL argument(s) specified...");
            return E_POINTER;
        }

        TRY_IT

        do
        {
            _bstr_t    bstrPath(GetWBEMClass((SA_OBJECT_TYPE)lObjectType), false);
            if ( NULL == (LPWSTR)bstrPath )
            {
                SATraceString("IApplianceServices::GetObjectProperty() - Failed - Could not get WBEM class...");
                hr = E_FAIL;
                break;
            }

            // Get the underlying WBEM object
            bstrPath += L"=\"";
            bstrPath += bstrObjectName;
            bstrPath += L"\"";
            CComPtr<IWbemClassObject> pWbemObj;
            hr = m_pWbemSrvcs->GetObject(
                                          bstrPath,                          
                                          0,                              
                                          NULL,                        
                                          &pWbemObj,    
                                          NULL
                                        );
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::GetObjectProperty() - Failed - IWbemServices::GetObject() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }

            // Now get the property specified by the caller
            hr = pWbemObj->Get(bstrPropertyName, 0, pPropertyValue, 0, 0);
            if ( FAILED(hr) )
            {
                SATracePrintf("IApplianceServices::GetObjectProperty() - Failed - IWbemClassObject::Get() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }
            hr = S_OK;

        } while ( FALSE );

        CATCH_AND_SET_HR
    }
    else
    {
        SATraceString("IApplianceServices::GetObjectProperty() - Failed - Did you forget to invoke IApplianceServices::Initialize first?");
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    PutObjectProperty()
//
// Synopsis:    Used to update an appliance core object property 
//                (task, service, etc.).
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::PutObjectProperty(
                                           /*[in]*/ LONG     lObjectType,
                                           /*[in]*/ BSTR     bstrObjectName,
                                           /*[in]*/ BSTR     bstrPropertyName,
                                           /*[in]*/ VARIANT* pPropertyValue
                                                  )
{
    HRESULT hr = E_UNEXPECTED;
    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        _ASSERT( NULL != bstrObjectName && NULL != bstrPropertyName && NULL != pPropertyValue );
        if ( NULL == bstrObjectName || NULL == bstrPropertyName || NULL == pPropertyValue )
            return E_POINTER;

        TRY_IT

        hr = E_NOTIMPL;

        CATCH_AND_SET_HR
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_CLASS_INFO_MAP(TypeMap)
    DEFINE_OBJECT_CLASS_INFO_ENTRY(SA_OBJECT_TYPE_SERVICE, CLASS_WBEM_SERVICE)
    DEFINE_OBJECT_CLASS_INFO_ENTRY(SA_OBJECT_TYPE_TASK, CLASS_WBEM_TASK)
    DEFINE_OBJECT_CLASS_INFO_ENTRY(SA_OBJECT_TYPE_USER, CLASS_WBEM_USER)
    DEFINE_OBJECT_CLASS_INFO_ENTRY(SA_OBJECT_TYPE_ALERT, CLASS_WBEM_ALERT)
END_OBJECT_CLASS_INFO_MAP()

//////////////////////////////////////////////////////////////////////////////
//
// Function:    GetWBEMClass()
//
// Synopsis:    Used to retrieve the WBEM class for a given appliance 
//                object type.
//
//////////////////////////////////////////////////////////////////////////////
BSTR CApplianceServices::GetWBEMClass(SA_OBJECT_TYPE eType)
{
    POBJECT_CLASS_INFO    p = TypeMap;
    while ( p->szWBEMClass != NULL )
    {
        if ( p->eType == eType )
        {
            return SysAllocString(p->szWBEMClass);
        }
        p++;
    }
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:    RaiseAlertEx ()
//
// Synopsis:    Called by to raise an appliance alert condition. (see 
//              applianceservices.idl for a complete interface description).
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::RaiseAlertEx (
                                 /*[in]*/    LONG lAlertType, 
                                 /*[in]*/    LONG lAlertId, 
                                 /*[in]*/    BSTR bstrAlertLog, 
                                 /*[in]*/    BSTR bstrAlertSource, 
                                 /*[in]*/    LONG lTimeToLive, 
                                 /*[in]*/    VARIANT *pReplacementStrings, 
                                 /*[in]*/    VARIANT *pRawData, 
                                 /*[in]*/    LONG  lAlertFlags,
                                 /*[out]*/   LONG* pAlertCookie 
                                             )
{
    //BOOL    bNeedRaiseIt = TRUE;    
    HRESULT hr = E_UNEXPECTED;

    SATracePrintf( "Enter RaiseAlertEx  %d", lAlertFlags );

    _ASSERT( m_bInitialized );

    if ( m_bInitialized )
    {
        //
        // Raise the alert.
        //
        hr = RaiseAlertInternal( lAlertType,
                                 lAlertId,
                                 bstrAlertLog,
                                 bstrAlertSource,
                                 lTimeToLive,
                                 pReplacementStrings,
                                 pRawData,
                                 lAlertFlags,
                                 pAlertCookie
                                 );

    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:    IsAlertPresent()
//
// Synopsis:    Called to check the existence of an alert. (see 
//              applianceservices.idl for a complete interface description).
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CApplianceServices::IsAlertPresent(
                                     /*[in]*/ LONG  lAlertId, 
                                     /*[in]*/ BSTR  bstrAlertLog,
                            /*[out, retval]*/ VARIANT_BOOL *pvIsPresent
                                                )
{
    LONG    lStringLen;
    HRESULT hr = E_UNEXPECTED;
    LPTSTR  pstrQueryString = NULL;
    CComPtr<IEnumWbemClassObject> pEnumObjects;

    SATraceString( "Enter IsAlertPresent" );

    *pvIsPresent = VARIANT_FALSE;

    _ASSERT( m_bInitialized );

    if ( m_bInitialized )
    {
        lStringLen = lstrlen(bstrAlertLog) + lstrlen(ALERT_QUERY) 
                     + MaxDataLength;
        
        //
        // Alloc query string.
        //
        pstrQueryString = ( LPTSTR )malloc( sizeof( WCHAR ) * lStringLen );
        if( pstrQueryString == NULL )
        {
            SATraceString( "IsAlertPresent out of memory" );
            return E_OUTOFMEMORY;
        }

        ::wsprintf( pstrQueryString, ALERT_QUERY, 
                    lAlertId, bstrAlertLog );

        _bstr_t bstrWQL = L"WQL";
        //
        // Query instances of Microsoft_SA_Alert class that
        // meet specified criteria.
        //
        hr = m_pWbemSrvcs->ExecQuery( 
                                bstrWQL,
                                CComBSTR(pstrQueryString),
                                WBEM_FLAG_RETURN_IMMEDIATELY,
                                NULL,
                                &pEnumObjects
                                );
        if( FAILED( hr ) )
        {
            SATracePrintf( "IsAlertPresent error %x", hr );
            hr = E_FAIL;
        }
        else
        {
            ULONG ulReturned;
            CComPtr<IWbemClassObject> pClassObject;
            
            //
            // Check if there is any instance.
            //
            hr = pEnumObjects->Next( WBEM_NO_WAIT, 1, &pClassObject, &ulReturned );
            if( hr == WBEM_S_NO_ERROR && ulReturned == 1)
            {
                hr = S_OK;
                *pvIsPresent = VARIANT_TRUE;
            }
            else if( SUCCEEDED( hr ) )
            {
                hr = S_OK;
            }
            else
            {
                SATraceString( "IsAlertPresent pEnumObjects->Next error" );
                hr = E_FAIL;
            }
        }

        free( pstrQueryString );
    }                
    return hr;
}

HRESULT CApplianceServices::IsAlertSingletonPresent(
                                     /*[in]*/ LONG  lAlertId, 
                                     /*[in]*/ BSTR  bstrAlertLog,
                            /*[out, retval]*/ VARIANT_BOOL *pvIsPresent
                                                )
{
    LONG    lStringLen;
    HRESULT hr = E_UNEXPECTED;
    LPTSTR  pstrQueryString = NULL;
    CComPtr<IEnumWbemClassObject> pEnumObjects;

    SATraceString( "Enter IsAlertAlertSingletonPresent" );

    *pvIsPresent = VARIANT_FALSE;

    lStringLen = lstrlen(bstrAlertLog) + lstrlen(ALERT_QUERY) 
                 + MaxDataLength;
    
    //
    // Alloc query string.
    //
    pstrQueryString = ( LPTSTR )malloc( sizeof( WCHAR ) * lStringLen );
    if( pstrQueryString == NULL )
    {
        SATraceString( "IsAlertAlertSingletonPresent out of memory" );
        return E_OUTOFMEMORY;
    }

    ::wsprintf( pstrQueryString, ALERT_QUERY, 
                lAlertId, bstrAlertLog );

    _bstr_t bstrWQL = L"WQL";
    //
    // Query instances of Microsoft_SA_Alert class that
    // meet specified criteria.
    //
    hr = m_pWbemSrvcs->ExecQuery( 
                            bstrWQL,
                            CComBSTR(pstrQueryString),
                            WBEM_FLAG_RETURN_IMMEDIATELY,
                            NULL,
                            &pEnumObjects
                            );
    if( FAILED( hr ) )
    {
        SATracePrintf( "IsAlertAlertSingletonPresent error %x", hr );
        hr = E_FAIL;
    }
    else
    {
        ULONG ulReturned;
        CComPtr<IWbemClassObject> pClassObject;
        CComVariant vtAlertFlags;

        //
        // Check if there is any instance.
        //
        while( ( (hr = pEnumObjects->Next( WBEM_INFINITE, 1, &pClassObject, &ulReturned ))
                ==  WBEM_S_NO_ERROR )&& ( ulReturned == 1 ) )
        {
            hr = pClassObject->Get( PROPERTY_ALERT_FLAGS, 0, &vtAlertFlags, NULL, NULL );
            if( FAILED( hr ) )
            {
                SATracePrintf( 
                    "IsAlertAlertSingletonPresent pClassObject->Get error %x", 
                    hr );
                pClassObject.Release ();
                continue;
            }

            if( V_I4( &vtAlertFlags ) & SA_ALERT_FLAG_SINGLETON )
            {
                hr = S_OK;
                *pvIsPresent = VARIANT_TRUE;
                break;
            }

            //
            // release resources so that the wrappers can be re-used
            //
            vtAlertFlags.Clear ();
            pClassObject.Release ();
        }
        if ((DWORD) hr == WBEM_S_FALSE)
            hr = S_OK;
    }

    free( pstrQueryString );
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Function:    SavePersistentAlert ()
//
// Synopsis:    Private method used to save persistent alert to registry
//
// Arguments:
//              [in] LONG lAlertType  -- Alert type value.
//              [in] LONG lAlertId    -- Alert ID.
//              [in] BSTR bstrAlertLog-- Alert Log
//              [in] LONG lTimeToLive -- Amount of alert lifetime
//              [in] VARIANT *pReplacementStrings -- Array of replace strings
//              [in] LONG  lAlertFlags -- Alert flag value
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CApplianceServices::SavePersistentAlert(
                        /*[in]*/    LONG lAlertType, 
                        /*[in]*/    LONG lAlertId, 
                        /*[in]*/    BSTR bstrAlertLog, 
                        /*[in]*/    BSTR bstrAlertSource, 
                        /*[in]*/    LONG lTimeToLive, 
                        /*[in]*/    VARIANT *pReplacementStrings, 
                        /*[in]*/    LONG  lAlertFlags
                                             )
{
    WCHAR   wstrAlertItem[MAX_PATH];  
    HRESULT hr = S_OK;
    PPROPERTYBAGCONTAINER pObjSubMgrs;


    //
    // Add key name as AlertLog + AlertId.
    //
    ::wsprintf( wstrAlertItem, L"%s%8lX", bstrAlertLog,lAlertId );
    
    //
    // Set location information.
    //
    CLocationInfo LocSubInfo (HKEY_LOCAL_MACHINE, (LPWSTR) SA_ALERT_REGISTRY_KEYNAME);

    //
    // Open the main key as propertybag container.
    //
    pObjSubMgrs =  ::MakePropertyBagContainer(
                            PROPERTY_BAG_REGISTRY,
                            LocSubInfo
                            );
    do
    {
        if ( !pObjSubMgrs.IsValid() )
        {
            SATraceString( "SavePersistentAlert pObjSubMgrs.IsValid" );
            hr = E_FAIL;
            break;
        }

        if ( !pObjSubMgrs->open() )
        {
            SATraceString( "SavePersistentAlert pObjSubMgrs->open" );
            hr = E_FAIL;
            break;
        }

        PPROPERTYBAG pSubBag;
        
        pSubBag = pObjSubMgrs->find( wstrAlertItem );    
        if( !pSubBag.IsValid() || !pObjSubMgrs->open() )
        {
            pSubBag = pObjSubMgrs->add( wstrAlertItem );
        }

        //
        // Add subkey for the alert if it is not exist.
        //
        if ( !pSubBag.IsValid() )
        {
            SATraceString( "SavePersistentAlert pSubBag.IsValid" );
            hr = E_FAIL;
            break;
        }

        if( !pSubBag->open() )
        {
            SATraceString( "SavePersistentAlert pSubBag->open" );
            hr = E_FAIL;
            break;
        }
        
        CComVariant vtValue;
 
        //
        // Add and set AlertID value to the alert key
        //
        vtValue = lAlertId;
        if( !pSubBag->put( PROPERTY_ALERT_ID, &vtValue ) )
        {
            SATraceString( "SavePersistentAlert put AlertID" );
            hr = E_FAIL;
            break;
        }

        //
        // Add and set AlertType value to the alert key
        //
        vtValue = lAlertType;
        if( !pSubBag->put( PROPERTY_ALERT_TYPE, &vtValue ) )
        {
            SATraceString( "SavePersistentAlert put AlertType" );
            hr = E_FAIL;
            break;
        }
        
        //
        // Add and set AlertFlags value to the alert key
        //
        vtValue = lAlertFlags;
        if( !pSubBag->put( PROPERTY_ALERT_FLAGS, &vtValue ) )
        {
            SATraceString( "SavePersistentAlert put AlertFlags" );
            hr = E_FAIL;
            break;
        }

        //
        // Add and set alert lifetime to the alert key
        //
        vtValue = lTimeToLive;
        if( !pSubBag->put( PROPERTY_ALERT_TTL, &vtValue ) )
        {
            SATraceString( "SavePersistentAlert put TimeToLive" );
            hr = E_FAIL;
            break;
        }
    
        vtValue.Clear();

        //
        // Add and set AlertLog value to the alert key
        //
        vtValue = bstrAlertLog;
        if( !pSubBag->put( PROPERTY_ALERT_LOG, &vtValue ) )
        {
            SATraceString( "SavePersistentAlert put AlertLog" );
            hr = E_FAIL;
            break;
        }

        //
        // Add and set AlertLog value to the alert key
        //
        vtValue = bstrAlertSource;
        if( !pSubBag->put( PROPERTY_ALERT_SOURCE, &vtValue ) )
        {
            SATraceString( "SavePersistentAlert put bstrAlertSource" );
            hr = E_FAIL;
            break;
        }

        //
        // Add and set alert replace strings value to the alert key
        //
        if( !pSubBag->put( PROPERTY_ALERT_STRINGS, pReplacementStrings ) )
        {
            SATraceString( "SavePersistentAlert put ReplacementStrings" );
        }

        //
        // Save the properties to registry
        //
        if( !pSubBag->save() )
        {
            SATraceString( "SavePersistentAlert pSubBag->save" );
            hr = E_FAIL;
        }
    }            
    while( FALSE );

    return hr;
}

HRESULT CApplianceServices::RaiseAlertInternal(
                         /*[in]*/ LONG lAlertType, 
                         /*[in]*/ LONG lAlertId, 
                         /*[in]*/ BSTR bstrAlertLog, 
                         /*[in]*/ BSTR bstrAlertSource, 
                         /*[in]*/ LONG lTimeToLive, 
                         /*[in]*/ VARIANT *pReplacementStrings, 
                         /*[in]*/ VARIANT *pRawData, 
                         /*[in]*/ LONG  lAlertFlags,
                /*[out, retval]*/ LONG* pAlertCookie 
                                            )
{
    HRESULT hr = E_UNEXPECTED;
    _ASSERT( m_bInitialized );
    if ( m_bInitialized )
    {
        _ASSERT( NULL != bstrAlertLog && NULL != bstrAlertSource && NULL != pAlertCookie );
        if ( NULL == bstrAlertLog || NULL == bstrAlertSource || NULL == pAlertCookie )
        { 
            SATraceString("IApplianceServices::ExecuteTask() - Failed - NULL argument(s) specified...");
            return E_POINTER; 
        }

        if (wcslen (bstrAlertLog) > MAX_ALERTLOG_LENGTH)
        {
            SATracePrintf ("RaiseAlertInternal failed with invalid log (too big):%ws", bstrAlertLog);
            return (E_INVALIDARG);
        }

        TRY_IT

        do
        {
            VARIANT_BOOL  vIsPresent = VARIANT_FALSE;
            hr = IsAlertSingletonPresent (lAlertId, bstrAlertLog, &vIsPresent);
            if( hr != S_OK )
            {
                SATracePrintf("RaiseAlertInternal IsAlertSingletonPresent error %lx", hr );
                hr = E_FAIL;
                break;
            }
            else if ( VARIANT_TRUE == vIsPresent ) 
            {
                SATraceString("RaiseAlertInternal a singleton alert exist");
                hr = S_FALSE;
                break;
            }

            // Get a WBEM object for the Raise Alert method in/out parameters
            CComPtr<IWbemClassObject> pWbemObj;
            _ASSERT( m_pWbemSrvcs );
            _bstr_t bstrPathAppMgr = CLASS_WBEM_APPMGR;
            hr = m_pWbemSrvcs->GetObject(
                                            bstrPathAppMgr,
                                            0,
                                            NULL,
                                            &pWbemObj,
                                            NULL
                                        );
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemServices::GetObject() returned %lx...", hr);
                hr = E_FAIL;
                break;
            }
            CComPtr<IWbemClassObject> pObjIn;
            hr = pWbemObj->GetMethod(METHOD_APPMGR_RAISE_ALERT, 0, &pObjIn, NULL);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::GetMethod() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            CComPtr<IWbemClassObject> pInParams;
            hr = pObjIn->SpawnInstance(0, &pInParams);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::SpawnInstance() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            // AlertType;
            _variant_t vtPropertyValue = (long)lAlertType;
            hr = pInParams->Put(PROPERTY_ALERT_TYPE, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_TYPE);
                hr = E_FAIL;
                break; 
            }

            // Id
            vtPropertyValue = (long)lAlertId;
            hr = pInParams->Put(PROPERTY_ALERT_ID, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_ID);
                hr = E_FAIL;
                break; 
            }
            // Log
            if ( ! lstrlen(bstrAlertLog) )
            {
                vtPropertyValue = DEFAULT_ALERT_LOG;
            }
            else
            {
                vtPropertyValue = bstrAlertLog;
            }
            hr = pInParams->Put(PROPERTY_ALERT_LOG, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_LOG);
                hr = E_FAIL;
                break; 
            }
            // Source
            if ( ! lstrlen(bstrAlertSource) )
            {
                vtPropertyValue = DEFAULT_ALERT_SOURCE;
            }
            else
            {
                vtPropertyValue = bstrAlertSource;
            }
            hr = pInParams->Put(PROPERTY_ALERT_SOURCE, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_SOURCE);
                hr = E_FAIL;
                break; 
            }
            // TTL
            vtPropertyValue = (long)lTimeToLive;
            hr = pInParams->Put(PROPERTY_ALERT_TTL, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_TTL);
                hr = E_FAIL;
                break; 
            }

            //Alert flags
            vtPropertyValue = (long)lAlertFlags;
            hr = pInParams->Put(PROPERTY_ALERT_FLAGS, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_FLAGS);
                hr = E_FAIL;
                break; 
            }

            bool bCreatedBstrArray = false;
            DWORD dwCreatedArraySize = 0;
            _variant_t vtReplacementStrings;

            // Replacement Strings
            vtPropertyValue = pReplacementStrings;

            if ( VT_EMPTY == V_VT(&vtPropertyValue) )
            { 
                //
                // no replacement strings passed in
                //
                V_VT(&vtPropertyValue) = VT_NULL; 
            }
            else if (
                  (TRUE == (V_VT (&vtPropertyValue) ==  VT_ARRAY + VT_BYREF + VT_VARIANT)) ||
                  (TRUE == (V_VT (&vtPropertyValue) ==  VT_ARRAY + VT_VARIANT)) 
                )
            {
                //
                // array (or reference to array)  of variants passed in
                //
                SATraceString ("IApplianceServices::RaiseAlert () - received array of variants...");
                //
                // convert the array of variant to array of BSTRs as
                // that is the format needed by WMI
                //
                hr = CreateBstrArrayFromVariantArray (
                                    &vtPropertyValue, 
                                    &vtReplacementStrings,
                                    &dwCreatedArraySize
                                    );
                if (FAILED (hr))
                {
                    SATracePrintf(
                        "IApplianceServices::RaiseAlert() - failed on CreateBstrArray with error:%x", hr
                        );
                    hr = E_FAIL;
                    break; 
                }
              
                //
                // we enable this flag to signify we have created a new array and this should be
                // used and then cleaned later
                //
                bCreatedBstrArray = true;
             }
             else if (
                   (TRUE == (V_VT (&vtPropertyValue) ==  VT_ARRAY + VT_BYREF + VT_BSTR)) ||
                  (TRUE == (V_VT (&vtPropertyValue) ==  VT_ARRAY + VT_BSTR)) 
                )
            {
                //
                // array (or reference to array)  of BSTR passed in - we do not need to do
                // any special processing here, WMI can handle it natively
                //
                SATraceString ("IApplianceServices::RaiseAlert () - received array of BSTRS...");

            }
            else
            {
                SATracePrintf (
                    "IApplianceService::RaiseAlert - un-supported replacement string type passed:%x", 
                    V_VT (&vtPropertyValue)
                    );
                hr = E_FAIL;
                break; 
            }


              //
              // add the replacement strings to pass to WMI
              //
            hr = pInParams->Put(
                            PROPERTY_ALERT_STRINGS, 
                            0, 
                            (bCreatedBstrArray) ? &vtReplacementStrings : &vtPropertyValue, 
                            0
                            );

            //
            // check the value from the Put now
            //
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (PWSTR)PROPERTY_ALERT_STRINGS);
                hr = E_FAIL;
                break; 
            }
            
            // Raw Data
            vtPropertyValue = pRawData;
            if ( VT_EMPTY == V_VT(&vtPropertyValue) )
            { 
                V_VT(&vtPropertyValue) = VT_NULL; 
            }
            hr = pInParams->Put(PROPERTY_ALERT_DATA, 0, &vtPropertyValue, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Put() returned %lx for property '%ls'...", hr, (LPWSTR)PROPERTY_ALERT_DATA);
                hr = E_FAIL;
                break; 
            }
            // Execute the RaiseAlert() method - pass the call 
            // to the alert object manager
            CComPtr<IWbemClassObject> pOutParams;
            _bstr_t bstrMethodRaiseAlert = METHOD_APPMGR_RAISE_ALERT;
            _bstr_t bstrPathAppMgrKey = CLASS_WBEM_APPMGR;
            bstrPathAppMgrKey += CLASS_WBEM_APPMGR_KEY;
            hr = m_pWbemSrvcs->ExecMethod(
                                          bstrPathAppMgrKey,
                                          bstrMethodRaiseAlert,
                                          0,
                                          NULL,
                                          pInParams,
                                          &pOutParams,
                                          NULL
                                         );
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemServices::ExecMethod() returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            // Return the cookie to the caller if the function succeeds
            hr = pOutParams->Get(RETURN_VALUE, 0, &vtPropertyValue, 0, 0);
            if ( FAILED(hr) )
            { 
                SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Get(ReturnValue) returned %lx...", hr);
                hr = E_FAIL;
                break; 
            }
            hr = V_I4(&vtPropertyValue);
            if ( SUCCEEDED(hr) )
            {
                hr = pOutParams->Get(PROPERTY_ALERT_COOKIE, 0, &vtPropertyValue, 0, 0);
                if ( FAILED(hr) )
                { 
                    SATracePrintf("IApplianceServices::RaiseAlert() - Failed - IWbemClassObject::Get(Cookie) returned %lx...", hr);
                    hr = E_FAIL;
                    break; 
                }
                *pAlertCookie = V_I4(&vtPropertyValue);
                hr = S_OK;
            }


            if ( lAlertFlags & SA_ALERT_FLAG_PERSISTENT )
            {
                    SavePersistentAlert(
                                     lAlertType, 
                                     lAlertId, 
                                     bstrAlertLog,
                                     bstrAlertSource,
                                     lTimeToLive, 
                                        (bCreatedBstrArray) ? &vtReplacementStrings : pReplacementStrings, 
                                     lAlertFlags
                                     );
            }

            //
            // clean the safe-array if created
            //
            if (bCreatedBstrArray) 
            {
                FreeBstrArray (&vtReplacementStrings, dwCreatedArraySize);                                        
            }


        } while ( FALSE );

        CATCH_AND_SET_HR
    }
    else
    {
        SATraceString("IApplianceServices::ExecuteTask() - Failed - Did you forget to invoke IApplianceServices::Initialize first?");
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:    CreateBstrArrayFromVariantArray ()
//
// Synopsis:    Private method used to create a BSTR array from a VARIANT array of BSTRs
//
// Arguments:
//                [in]  VARIANT* - array (or reference to array) of variants
//                [out] VARIANT* - array of BSTRs
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CApplianceServices::CreateBstrArrayFromVariantArray  (
                /*[in]*/        VARIANT* pVariantArray,
                /*[out]*/        VARIANT* pBstrArray,
                /*[out]*/        PDWORD   pdwCreatedArraySize
                )
{
    HRESULT hr = S_OK;

    CSATraceFunc objTraceFunc ("CApplianceServices::CreateBstrArrayFromVariantArray");

    do
    {
        if ((NULL == pBstrArray) || (NULL == pVariantArray) || (NULL == pdwCreatedArraySize))
        {
            SATraceString ("CreateBstrArrayFromVariantArray - incorrect parameters passed in");
            hr = E_FAIL;
            break;
        }

        LONG lLowerBound = 0;
        //
        // get the number of replacement strings provided
        //
        hr = ::SafeArrayGetLBound (
                                 (V_VT (pVariantArray) & VT_BYREF)
                                    ? *(V_ARRAYREF (pVariantArray))
                                    : (V_ARRAY (pVariantArray)), 
                                   1, 
                                   &lLowerBound
                                   );
         if (FAILED (hr))
        {
            SATracePrintf (
                     "CreateBstrArrayFromVariantArray - can't obtain rep. string array lower bound:%x",
                      hr
                      );
             break;
          }

        LONG lUpperBound = 0;
        hr = ::SafeArrayGetUBound (
                                (V_VT (pVariantArray) & VT_BYREF)
                                ? *(V_ARRAYREF (pVariantArray)) 
                                : (V_ARRAY (pVariantArray)), 
                                   1, 
                                &lUpperBound
                                );
           if (FAILED (hr))
        {
               SATracePrintf (
                    "CreateBstrArrayFromVariantArray - can't obtain rep. string array upper bound:%x",
                    hr
                    );
               break;
           }
                
        DWORD dwTotalStrings = *pdwCreatedArraySize =  lUpperBound - lLowerBound;
       
        //
        // now go through the variant array and copy the strings to the BSTR array
         //
         CVariantVector <BSTR> ReplacementStringVector (pBstrArray, dwTotalStrings);
        for (DWORD dwCount = 0; dwCount < dwTotalStrings; dwCount++)
        {
            if (V_VT (pVariantArray) & VT_BYREF) 
            {
                //
                // reference to array of variants
                //
                ReplacementStringVector [dwCount] =
                 SysAllocString (V_BSTR(&((VARIANT*)(*(V_ARRAYREF (pVariantArray)))->pvData)[dwCount]));
             }
             else
             {
                //
                // array of variants
                //
                ReplacementStringVector [dwCount] = 
                 SysAllocString (V_BSTR(&((VARIANT*)(V_ARRAY (pVariantArray))->pvData)[dwCount]));
             }                
        }    
    }    while (false);

    return (hr);
    
}    //    end of CApplianceServices::CreateBstrArrayFromVariantArray method

//////////////////////////////////////////////////////////////////////////////
//
// Function:    FreeBstrArray ()
//
// Synopsis:    Private method used to free a BSTR array created earlier
//
// Arguments:
//                [in]  VARIANT* - array of BSTRS
//                [in]  DWORD - array size
//
//////////////////////////////////////////////////////////////////////////////
VOID CApplianceServices::FreeBstrArray (
                /*[in]*/        VARIANT* pVariantArray,
                /*[out]*/        DWORD    dwArraySize
                )
{
    CSATraceFunc objTraceFunc ("CApplianceServices::FreeBstrArray");
    
    for (DWORD dwCount = 0; dwCount < dwArraySize; dwCount++)
    {
        SysFreeString (((BSTR*)(V_ARRAY(pVariantArray))->pvData)[dwCount]);
    }
    
}    // end of CApplianceServices::FreeBstrArray method


//**********************************************************************
// 
// FUNCTION:  IsOperationAllowedForClient - This function checks the token of the 
//            calling thread to see if the caller belongs to the Local System account
// 
// PARAMETERS:   none
// 
// RETURN VALUE: TRUE if the caller is an administrator on the local
//            machine.  Otherwise, FALSE.
// 
//**********************************************************************
BOOL 
CApplianceServices::IsOperationAllowedForClient (
            VOID
            )
{

    HANDLE hToken = NULL;
    DWORD  dwStatus  = ERROR_SUCCESS;
    DWORD  dwAccessMask = 0;;
    DWORD  dwAccessDesired = 0;
    DWORD  dwACLSize = 0;
    DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
    PACL   pACL            = NULL;
    PSID   psidLocalSystem  = NULL;
    BOOL   bReturn        =  FALSE;

    PRIVILEGE_SET   ps;
    GENERIC_MAPPING GenericMapping;

    PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    CSATraceFunc objTraceFunc ("CApplianceServices::IsOperationAllowedForClient ");
       
    do
    {
        //
        // we assume to always have a thread token, because the function calling in
        // appliance manager will be impersonating the client
        //
        bReturn  = OpenThreadToken(
                               GetCurrentThread(), 
                               TOKEN_QUERY, 
                               FALSE, 
                               &hToken
                               );
        if (!bReturn)
        {
            SATraceFailure ("CApplianceServices::IsOperationAllowedForClient failed on OpenThreadToken:", GetLastError ());
            break;
        }


        //
        // Create a SID for Local System account
        //
        bReturn = AllocateAndInitializeSid (  
                                        &SystemSidAuthority,
                                        1,
                                        SECURITY_LOCAL_SYSTEM_RID,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        &psidLocalSystem
                                        );
        if (!bReturn)
        {     
            SATraceFailure ("CApplianceServices:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  GetLastError ());
            break;
        }
    
        //
        // get memory for the security descriptor
        //
        psdAdmin = HeapAlloc (
                              GetProcessHeap (),
                              0,
                              SECURITY_DESCRIPTOR_MIN_LENGTH
                              );
        if (NULL == psdAdmin)
        {
            SATraceString ("CApplianceServices::IsOperationForClientAllowed failed on HeapAlloc");
            bReturn = FALSE;
            break;
        }
      
        bReturn = InitializeSecurityDescriptor(
                                            psdAdmin,
                                            SECURITY_DESCRIPTOR_REVISION
                                            );
        if (!bReturn)
        {
            SATraceFailure ("CApplianceServices::IsOperationForClientAllowed failed on InitializeSecurityDescriptor:", GetLastError ());
            break;
        }

        // 
        // Compute size needed for the ACL.
        //
        dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                    GetLengthSid (psidLocalSystem);

        //
        // Allocate memory for ACL.
        //
        pACL = (PACL) HeapAlloc (
                                GetProcessHeap (),
                                0,
                                dwACLSize
                                );
        if (NULL == pACL)
        {
            SATraceString ("CApplianceServices::IsOperationForClientAllowed failed on HeapAlloc2");
            bReturn = FALSE;
            break;
        }

        //
        // Initialize the new ACL.
        //
        bReturn = InitializeAcl(
                              pACL, 
                              dwACLSize, 
                              ACL_REVISION2
                              );
        if (!bReturn)
        {
            SATraceFailure ("CApplianceServices::IsOperationForClientAllowed failed on InitializeAcl", GetLastError ());
            break;
        }


        // 
        // Make up some private access rights.
        // 
        const DWORD ACCESS_READ = 1;
        const DWORD  ACCESS_WRITE = 2;
        dwAccessMask= ACCESS_READ | ACCESS_WRITE;

        //
        // Add the access-allowed ACE to the DACL for Local System
        //
        bReturn = AddAccessAllowedAce (
                                    pACL, 
                                    ACL_REVISION2,
                                    dwAccessMask, 
                                    psidLocalSystem
                                    );
        if (!bReturn)
        {
            SATraceFailure ("CApplianceServices::IsOperationForClientAllowed failed on AddAccessAllowedAce (LocalSystem)", GetLastError ());
            break;
        }
              
        //
        // Set our DACL to the SD.
        //
        bReturn = SetSecurityDescriptorDacl (
                                          psdAdmin, 
                                          TRUE,
                                          pACL,
                                          FALSE
                                          );
        if (!bReturn)
        {
            SATraceFailure ("CApplianceServices::IsOperationForClientAllowed failed on SetSecurityDescriptorDacl", GetLastError ());
            break;
        }

        //
        // AccessCheck is sensitive about what is in the SD; set
        // the group and owner.
        //
        SetSecurityDescriptorGroup(psdAdmin, psidLocalSystem, FALSE);
        SetSecurityDescriptorOwner(psdAdmin, psidLocalSystem, FALSE);

        bReturn = IsValidSecurityDescriptor(psdAdmin);
        if (!bReturn)
        {
            SATraceFailure ("CApplianceServices::IsOperationForClientAllowed failed on IsValidSecurityDescriptorl", GetLastError ());
            break;
        }
     

        dwAccessDesired = ACCESS_READ;

        // 
        // Initialize GenericMapping structure even though we
        // won't be using generic rights.
        // 
        GenericMapping.GenericRead    = ACCESS_READ;
        GenericMapping.GenericWrite   = ACCESS_WRITE;
        GenericMapping.GenericExecute = 0;
        GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;
        BOOL bAccessStatus = FALSE;

        //
        // check the access now
        //
        bReturn = AccessCheck  (
                                psdAdmin, 
                                hToken, 
                                dwAccessDesired, 
                                &GenericMapping, 
                                &ps,
                                &dwStructureSize, 
                                &dwStatus, 
                                &bAccessStatus
                                );

        if (!bReturn || !bAccessStatus)
        {
            SATraceFailure ("CApplianceServices::IsOperationForClientAllowed failed on AccessCheck", GetLastError ());
        } 
        else
        {
            SATraceString ("CApplianceServices::IsOperationForClientAllowed, Client is allowed to carry out operation!");
        }

        //
        // successfully checked 
        //
        bReturn  = bAccessStatus;        
 
    }    
    while (false);

    //
    // Cleanup 
    //
    if (pACL) 
    {
        HeapFree (GetProcessHeap (), 0, pACL);
    }

    if (psdAdmin) 
    {
        HeapFree (GetProcessHeap (), 0, psdAdmin);
    }
          

    if (psidLocalSystem) 
    {
        FreeSid(psidLocalSystem);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return (bReturn);

}// end of CApplianceServices::IsOperationValidForClient method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\appmgr\wbemusermgr.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      wbemusermgr.h
//
// Project:     Chameleon
//
// Description: WBEM Appliance User Manager Class 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_USER_WBEM_OBJECT_MGR_H_
#define __INC_USER_WBEM_OBJECT_MGR_H_

#include "resource.h"
#include "wbembase.h"
#include "resourceretriever.h"

#define    CLASS_WBEM_USER_MGR_FACTORY        L"Microsoft_SA_User"

//////////////////////////////////////////////////////////////////////////////
class CWBEMUserMgr : public CWBEMProvider
{

public:

    CWBEMUserMgr();
    ~CWBEMUserMgr();

BEGIN_COM_MAP(CWBEMUserMgr)
    COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CWBEMUserMgr, IWbemServices)

    //////////////////////////////////////////////////////////////////////////
    // IWbemServices Methods (Implemented by the ResourceMgr)
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP GetObjectAsync(
                        /*[in]*/  const BSTR       strObjectPath,
                        /*[in]*/  long             lFlags,
                        /*[in]*/  IWbemContext*    pCtx,        
                        /*[in]*/  IWbemObjectSink* pResponseHandler
                               );

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP CreateInstanceEnumAsync(
                                 /*[in]*/ const BSTR       strClass,
                                 /*[in]*/ long             lFlags,
                                 /*[in]*/ IWbemContext*    pCtx,        
                                 /*[in]*/ IWbemObjectSink* pResponseHandler
                                        );

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP ExecMethodAsync(
                      /*[in]*/ const BSTR        strObjectPath,
                      /*[in]*/ const BSTR        strMethodName,
                      /*[in]*/ long              lFlags,
                      /*[in]*/ IWbemContext*     pCtx,        
                      /*[in]*/ IWbemClassObject* pInParams,
                      /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                );

    //////////////////////////////////////////////////////////////////////////
    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              );
private:

    CWBEMUserMgr(const CWBEMUserMgr& rhs);
    CWBEMUserMgr& operator = (const CWBEMUserMgr& rhs);

    PRESOURCERETRIEVER    m_pUserRetriever;
};

#endif // __INC_USER_WBEM_OBJECT_MGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\accountnames.cpp ===
// AccountNameHelper.cpp : Implementation of CAccountNames

#include "stdafx.h"
#include "COMhelper.h"
#include "AccountNames.h"
#include <lm.h>
#include <comdef.h>
#include <string>
#undef _ASSERTE // need to use the _ASSERTE from debug.h
#undef _ASSERT // need to use the _ASSERT from debug.h
#include "debug.h"
using namespace std;

// CAccountNames
const wstring ADMINISTRATORS(L"ADMINISTRATORS");
const wstring ADMINISTRATOR(L"ADMINISTRATOR");
const wstring GUEST(L"GUEST");
const wstring GUESTS(L"GUESTS");
const wstring EVERYONE(L"EVERYONE");
const wstring SYSTEM(L"SYSTEM");

const int MAX_STRING = 512;


static BOOL LookupUserGroupFromRid(
        LPWSTR TargetComputer,
        DWORD Rid,
        LPWSTR Name,
        PDWORD cchName );

static BOOL LookupAliasFromRid(
        LPWSTR TargetComputer,
        DWORD Rid, 
        LPWSTR Name, 
        PDWORD cchName );

static BOOL LookupAliasForEveryone(LPWSTR Name, PDWORD cchName );

static BOOL LookupAliasForSystem(LPWSTR Name, PDWORD cchName );


STDMETHODIMP CAccountNames::Everyone(BSTR* pbstrTranslatedName)
{
    SATraceFunction("CAccountNames::Everyone()");
    try
    {
        if ( !VERIFY(pbstrTranslatedName))
        {
            return E_INVALIDARG;
        }
        
        *pbstrTranslatedName = 0;
        
        WCHAR wcBuffer[MAX_STRING];
        DWORD dwBufferSize = MAX_STRING;
        
        BOOL bSuccess = LookupAliasForEveryone(wcBuffer, &dwBufferSize);
        if ( bSuccess && wcslen(wcBuffer) > 0 )
        {
            *pbstrTranslatedName = ::SysAllocString(wcBuffer);
            SATracePrintf("Translated account to: %ws", wcBuffer);
        }
        if ( 0 == *pbstrTranslatedName )
        {
            *pbstrTranslatedName = ::SysAllocString(EVERYONE.c_str());
            return S_OK;
        }
    }
    catch(...)
    {
        SATraceString("Unexpected exception");
    }
    return S_OK;
}


STDMETHODIMP CAccountNames::Administrator(BSTR* pbstrTranslatedName)
{
    SATraceFunction("CAccountNames::Administrator()");
    try
    {
        if ( !VERIFY(pbstrTranslatedName))
        {
            return E_INVALIDARG;
        }
        
        *pbstrTranslatedName = 0;
        
        WCHAR wcBuffer[MAX_STRING];
        DWORD dwBufferSize = MAX_STRING;
        
        BOOL bSuccess = LookupUserGroupFromRid(NULL, DOMAIN_USER_RID_ADMIN, wcBuffer, &dwBufferSize);
        if ( bSuccess && wcslen(wcBuffer) > 0 )
        {
            *pbstrTranslatedName = ::SysAllocString(wcBuffer);
            SATracePrintf("Translated account to: %ws", wcBuffer);
        }
        if ( 0 == *pbstrTranslatedName )
        {
            *pbstrTranslatedName = ::SysAllocString(ADMINISTRATOR.c_str());
            return S_OK;
        }
    }
    catch(...)
    {
        SATraceString("Unexpected exception");
    }
    return S_OK;
}


STDMETHODIMP CAccountNames::Administrators(BSTR* pbstrTranslatedName)
{
    SATraceFunction("CAccountNames::Administrators()");
    try
    {
        if ( !VERIFY(pbstrTranslatedName))
        {
            return E_INVALIDARG;
        }
        
        *pbstrTranslatedName = 0;
        
        WCHAR wcBuffer[MAX_STRING];
        DWORD dwBufferSize = MAX_STRING;
        
        BOOL bSuccess = LookupAliasFromRid(NULL, DOMAIN_ALIAS_RID_ADMINS, wcBuffer, &dwBufferSize);
        if ( bSuccess && wcslen(wcBuffer) > 0 )
        {
            *pbstrTranslatedName = ::SysAllocString(wcBuffer);
            SATracePrintf("Translated account to: %ws", wcBuffer);
        }
        if ( 0 == *pbstrTranslatedName )
        {
            *pbstrTranslatedName = ::SysAllocString(ADMINISTRATORS.c_str());
            return S_OK;
        }
    }
    catch(...)
    {
        SATraceString("Unexpected exception");
    }
    return S_OK;
}


STDMETHODIMP CAccountNames::Guest(BSTR* pbstrTranslatedName)
{
    SATraceFunction("CAccountNames::Guest()");
    try
    {
        if ( !VERIFY(pbstrTranslatedName))
        {
            return E_INVALIDARG;
        }
        
        *pbstrTranslatedName = 0;
        
        WCHAR wcBuffer[MAX_STRING];
        DWORD dwBufferSize = MAX_STRING;
        
        BOOL bSuccess = LookupUserGroupFromRid(NULL, DOMAIN_USER_RID_GUEST, wcBuffer, &dwBufferSize);
        if ( bSuccess && wcslen(wcBuffer) > 0 )
        {
            *pbstrTranslatedName = ::SysAllocString(wcBuffer);
            SATracePrintf("Translated account to: %ws", wcBuffer);
        }
        if ( 0 == *pbstrTranslatedName )
        {
            *pbstrTranslatedName = ::SysAllocString(GUEST.c_str());
            return S_OK;
        }
    }
    catch(...)
    {
        SATraceString("Unexpected exception");
    }
    return S_OK;
}


STDMETHODIMP CAccountNames::Guests(BSTR* pbstrTranslatedName)
{
    SATraceFunction("CAccountNames::Guests()");
    try
    {
        if ( !VERIFY(pbstrTranslatedName))
        {
            return E_INVALIDARG;
        }
        
        *pbstrTranslatedName = 0;
        
        WCHAR wcBuffer[MAX_STRING];
        DWORD dwBufferSize = MAX_STRING;
        
        BOOL bSuccess = LookupAliasFromRid(NULL, DOMAIN_ALIAS_RID_GUESTS, wcBuffer, &dwBufferSize);
        if ( bSuccess && wcslen(wcBuffer) > 0 )
        {
            *pbstrTranslatedName = ::SysAllocString(wcBuffer);
            SATracePrintf("Translated account to: %ws", wcBuffer);
        }
        if ( 0 == *pbstrTranslatedName )
        {
            *pbstrTranslatedName = ::SysAllocString(GUESTS.c_str());
            return S_OK;
        }
    }
    catch(...)
    {
        SATraceString("Unexpected exception");
    }
    return S_OK;
}


STDMETHODIMP CAccountNames::System(BSTR* pbstrTranslatedName)
{
    SATraceFunction("CAccountNames::System()");
    try
    {
        if ( !VERIFY(pbstrTranslatedName))
        {
            return E_INVALIDARG;
        }
        
        *pbstrTranslatedName = 0;
        
        WCHAR wcBuffer[MAX_STRING];
        DWORD dwBufferSize = MAX_STRING;
        
        BOOL bSuccess = LookupAliasForSystem(wcBuffer, &dwBufferSize);
        if ( bSuccess && wcslen(wcBuffer) > 0 )
        {
            *pbstrTranslatedName = ::SysAllocString(wcBuffer);
            SATracePrintf("Translated account to: %ws", wcBuffer);
        }
        if ( 0 == *pbstrTranslatedName )
        {
            *pbstrTranslatedName = ::SysAllocString(SYSTEM.c_str());
            return S_OK;
        }
    }
    catch(...)
    {
        SATraceString("Unexpected exception");
    }
    return S_OK;
}



STDMETHODIMP CAccountNames::Translate(BSTR bstrAccountName, BSTR* pbstrTranslatedName)
{
    SATraceFunction("CAccountNames::Translate()");
    try
    {
        WCHAR wcBuffer[MAX_STRING];
        DWORD dwBufferSize = MAX_STRING;

        bool bNeedsTranslated = false;
        SID_IDENTIFIER_AUTHORITY sidAuthority = SECURITY_NT_AUTHORITY;
        PSID pSID = 0;
        BOOL bSuccess = FALSE;
        
        *pbstrTranslatedName = 0;
        
        // Create temporary copy if AccountName and convert to upper case
        wstring wsAccountName(_wcsupr(_bstr_t(bstrAccountName)));
        

        //
        // --------------------------------------------------------------
        // Built-In Groups
        // --------------------------------------------------------------
        //
        if ( wsAccountName == ADMINISTRATORS )
        {
            bSuccess = LookupAliasFromRid(NULL, DOMAIN_ALIAS_RID_ADMINS, wcBuffer, &dwBufferSize);
        }
        else if ( wsAccountName == GUESTS )
        {
            bSuccess = LookupAliasFromRid(NULL, DOMAIN_ALIAS_RID_GUESTS, wcBuffer, &dwBufferSize);
        }

        //
        // --------------------------------------------------------------
        // Local Users
        // --------------------------------------------------------------
        //
        else if ( wsAccountName == GUEST )
        {
            bSuccess = LookupUserGroupFromRid(NULL, DOMAIN_USER_RID_GUEST, wcBuffer, &dwBufferSize);
        }
        else if ( wsAccountName == ADMINISTRATOR )
        {
            bSuccess = LookupUserGroupFromRid(NULL, DOMAIN_USER_RID_ADMIN, wcBuffer, &dwBufferSize);
        }

        //
        // --------------------------------------------------------------
        // Special Built-in accounts
        // --------------------------------------------------------------
        //
        else if ( wsAccountName == EVERYONE )
        {
            bSuccess = LookupAliasForEveryone(wcBuffer, &dwBufferSize);
        }
        else if ( wsAccountName == SYSTEM )
        {
            bSuccess = LookupAliasForSystem(wcBuffer, &dwBufferSize);
        }
        //
        // Check results of translation
        //
        if ( bSuccess )
        {
            if ( wcslen(wcBuffer) > 0 )
            {
                *pbstrTranslatedName = ::SysAllocString(wcBuffer);
                SATracePrintf("Translated account: %ws to %ws",wsAccountName.c_str(),  wcBuffer);
            }
        }
        
        if ( 0 == *pbstrTranslatedName )
        {
            *pbstrTranslatedName = ::SysAllocString(bstrAccountName);
            return S_OK;
        }
    
    }
    catch(...)
    {
        SATraceString("Unexpected exception");
    }
    return S_OK;
}


static BOOL LookupUserGroupFromRid(
       LPWSTR TargetComputer,
       DWORD Rid,
       LPWSTR Name,
       PDWORD cchName
       )
{
    SATraceFunction("LookupAliasFromRid");
    
    PUSER_MODALS_INFO_2 umi2;
    NET_API_STATUS nas;
    UCHAR SubAuthorityCount;
    PSID pSid;
    SID_NAME_USE snu;
    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE; // assume failure     
    
    // 
    // get the account domain Sid on the target machine
    // note: if you were looking up multiple sids based on the same
    // account domain, only need to call this once.
    //        
    nas = NetUserModalsGet(TargetComputer, 2, (LPBYTE *)&umi2);
    if(nas != NERR_Success) 
    {
        SetLastError(nas);
        return FALSE;
    }
    
    SubAuthorityCount = *GetSidSubAuthorityCount(umi2->usrmod2_domain_id);

    // 
    // allocate storage for new Sid. account domain Sid + account Rid
    //
    pSid = (PSID)HeapAlloc(    GetProcessHeap(), 0, 
                            GetSidLengthRequired((UCHAR)(SubAuthorityCount + 1)));
    if(pSid != NULL) 
    {
        if(InitializeSid(pSid,
                        GetSidIdentifierAuthority(umi2->usrmod2_domain_id),
                        (BYTE)(SubAuthorityCount+1) )) 
        {               
            DWORD SubAuthIndex = 0;

            // 
            // copy existing subauthorities from account domain Sid into
            // new Sid
            //
            for( ; SubAuthIndex < SubAuthorityCount ; SubAuthIndex++) 
            {
                *GetSidSubAuthority(pSid, SubAuthIndex) =
                           *GetSidSubAuthority(umi2->usrmod2_domain_id, SubAuthIndex);
            }

            // 
            // append Rid to new Sid
            //
            *GetSidSubAuthority(pSid, SubAuthorityCount) = Rid;

            bSuccess = LookupAccountSidW(TargetComputer,
                                    pSid,
                                    Name,
                                    cchName,
                                    DomainName,
                                    &cchDomainName,
                                    &snu );
            if ( !bSuccess )
            {
                SATracePrintf("LookupAccountSid failed: %ld", GetLastError());
            }
        }
        HeapFree(GetProcessHeap(), 0, pSid);
    }       
    NetApiBufferFree(umi2);       
    return bSuccess;
}



static BOOL LookupAliasFromRid(LPWSTR TargetComputer,
                   DWORD Rid, LPWSTR Name, PDWORD cchName )
{
    SATraceFunction("LookupAliasFromRid");
    
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid = 0;
    WCHAR DomainName[MAX_STRING];
    DWORD cchDomainName = MAX_STRING;
    BOOL bSuccess = FALSE;

    try
    {
        // Sid is the same regardless of machine, since the well-known
        // BUILTIN domain is referenced.
        //

        if( AllocateAndInitializeSid(
                       &sia,
                       2,
                       SECURITY_BUILTIN_DOMAIN_RID,
                       Rid,
                       0, 0, 0, 0, 0, 0,
                       &pSid
                        ))
        {

            bSuccess = LookupAccountSid(TargetComputer,
                                    pSid,
                                    Name,
                                    cchName,
                                    DomainName,
                                    &cchDomainName,
                                    &snu);
            if ( !bSuccess )
            {
                SATracePrintf("LookupAccountSid failed: %ld", GetLastError());
            }
        }
    }
    catch(...)
    {
    }
    
    if ( pSid ) FreeSid(pSid);
       
    return bSuccess;
}


static BOOL LookupAliasForSystem(LPWSTR Name, PDWORD cchName )
{
    SATraceFunction("LookupAliasForSystem");
    
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid = 0;
    WCHAR DomainName[MAX_STRING];
    DWORD cchDomainName = MAX_STRING;
    BOOL bSuccess = FALSE;

    try
    {
        // Sid is the same regardless of machine, since the well-known
        // BUILTIN domain is referenced.
        //

        if( AllocateAndInitializeSid(
                       &sia,
                       1,
                       SECURITY_LOCAL_SYSTEM_RID,
                       0,
                       0, 0, 0, 0, 0, 0,
                       &pSid
                        ))
        {

            bSuccess = LookupAccountSid(NULL,
                                    pSid,
                                    Name,
                                    cchName,
                                    DomainName,
                                    &cchDomainName,
                                    &snu);
            if ( !bSuccess )
            {
                SATracePrintf("LookupAccountSid failed: %ld", GetLastError());
            }
        }
    }
    catch(...)
    {
    }
    if ( pSid ) FreeSid(pSid);
       
    return bSuccess;
}


static BOOL LookupAliasForEveryone(LPWSTR Name, PDWORD cchName )
{
    SATraceFunction("LookupAliasForEveryone");
    
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid = 0;
    WCHAR DomainName[MAX_STRING];
    DWORD cchDomainName = MAX_STRING;
    BOOL bSuccess = FALSE;

    try
    {
        // Sid is the same regardless of machine, since the well-known
        // BUILTIN domain is referenced.
        //

        if( AllocateAndInitializeSid(
                       &sia,
                       1,
                       0,
                       0,
                       0, 0, 0, 0, 0, 0,
                       &pSid
                        ))
        {

            bSuccess = LookupAccountSid(NULL,
                                    pSid,
                                    Name,
                                    cchName,
                                    DomainName,
                                    &cchDomainName,
                                    &snu);
            if ( !bSuccess )
            {
                SATracePrintf("LookupAccountSid failed: %ld", GetLastError());
            }
                
        }
    }
    catch(...)
    {
    }
    if ( pSid ) FreeSid(pSid);
       
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\accountnames.h ===
#ifndef __ACCOUNTNAMES_H_
#define __ACCOUNTNAMES_H_

#include "resource.h"       // main symbols
#include <ntsecapi.h>

/////////////////////////////////////////////////////////////////////////////
// CAccountNames
class ATL_NO_VTABLE CAccountNames : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CAccountNames, &CLSID_AccountNames>,
    public IDispatchImpl<IAccountNames, &IID_IAccountNames, &LIBID_COMHELPERLib>
{
public:
    
DECLARE_REGISTRY_RESOURCEID(IDR_ACCOUNTNAMES)    

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAccountNames)
    COM_INTERFACE_ENTRY(IAccountNames)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CAccountNames)
END_CATEGORY_MAP()

// IComputer
public:

    CAccountNames() {};
    ~CAccountNames() {} ;

    STDMETHODIMP Translate(BSTR bstrName, BSTR* pbstrName);
    
    STDMETHODIMP Everyone(BSTR* pbstrName);
    STDMETHODIMP Administrator(BSTR* pbstrName);
    STDMETHODIMP Administrators(BSTR* pbstrName);
    STDMETHODIMP Guest(BSTR* pbstrName);
    STDMETHODIMP Guests(BSTR* pbstrName);
    STDMETHODIMP System(BSTR* pbstrName);
    

protected:


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\comhelper.cpp ===
// COMhelper.cpp : Implementation of DLL Exports.
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      aplnutil.cpp
//
//  Description:
//      Contains the implementation of DLL's exports for this in-process server
//
//  Header File:
//      aplnutil.h (MIDL compiler generates)
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f COMhelperps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "COMhelper.h"

#include "NetWorks.h"
#include "Computer.h"
#include "LocalSetting.h"
#include "SystemSetting.h"
#include "Reboot.h"
#include "AccountNames.h"
#include "NetworkTools.h"
#include "CryptRandomObject.h"
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY_NON_CREATEABLE(CNetWorks)
OBJECT_ENTRY_NON_CREATEABLE(CComputer)
OBJECT_ENTRY_NON_CREATEABLE(CLocalSetting)
OBJECT_ENTRY(CLSID_SystemSetting, CSystemSetting)
OBJECT_ENTRY(CLSID_Reboot, CReboot)
OBJECT_ENTRY(CLSID_AccountNames, CAccountNames)
OBJECT_ENTRY(CLSID_NetworkTools, CNetworkTools)
OBJECT_ENTRY(CLSID_CryptRandom, CCryptRandomObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_COMHELPERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\constants.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      constants.h
//
//  Description:
//
//
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

const int nMAX_NUM_NET_COMPONENTS    = 128;
const int nNUMBER_OF_PROTOCOLS       = 7;
const int nMAX_PROTOCOL_LENGTH       = 64;
const int nMAX_COMPUTER_NAME_LENGTH  = 256;

const WCHAR rgProtocolNames[nNUMBER_OF_PROTOCOLS][nMAX_PROTOCOL_LENGTH] = { L"ms_netbeui", L"ms_tcpip", L"ms_appletalk", L"ms_dlc", L"ms_netmon", L"ms_nwipx", L"ms_nwnb" };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\cryptrandom.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//      CryptRandom.cpp
//
//  Description:
//      Implementation of CCryptRandom, which is a thin wrapper class over the
//      CryptoAPI functions for generating cryptographically random strings.
//
//  Implementation File:
//      CryptRandom.cpp
//
//  Maintained By:
//      Tom Marsh (tmarsh) 12-April-2002
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "CryptRandom.h"

CCryptRandom::CCryptRandom
(
)
{
    if (!CryptAcquireContext(&m_hProv,
                             NULL,  // Key container.
                             NULL,  // CSP name (provider)
                             PROV_RSA_FULL,
                             CRYPT_VERIFYCONTEXT))
    {
        m_hProv = NULL;
    }
}

CCryptRandom::~CCryptRandom
(
)
{
    if (NULL != m_hProv)
    {
        CryptReleaseContext(m_hProv, 0);
    }
}

BOOL CCryptRandom::get
(
    BYTE    *pbData,
    DWORD   cbData
)
{
    if (NULL == m_hProv)
    {
        return FALSE;
    }
    return CryptGenRandom(m_hProv, cbData, pbData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\computer.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      computer.cpp
//
//  Description:
//      Implementation file for the CComputer.  Deals with getting and setting
//      the computer's network names.
//
//  Header File:
//      computer.h
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

// Computer.cpp : Implementation of CComputer
#include "stdafx.h"
#include "COMhelper.h"
#include "Computer.h"
#include <winbase.h>
#include <lmwksta.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmjoin.h>
#include <lm.h>
#include <ntsecapi.h>
#include <comutil.h>

/////////////////////////////////////////////////////////////////////////////
// CComputer

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::CComputer
//
//  Description:
//      CComputer ctor.  Determines the initial member variable values by
//      loading the network names from the current system.
//
//--
//////////////////////////////////////////////////////////////////////////////
CComputer::CComputer()
    : m_bRebootNecessary( false )
{

    wcscpy( m_szNewComputerName,                   L"" );
    wcscpy( m_szCurrentComputerName,               L"" );
    wcscpy( m_szNewWorkgroupOrDomainName,          L"" );
    wcscpy( m_szCurrentWorkgroupOrDomainName,      L"" );
    wcscpy( m_szNewFullyQualifiedComputerName,     L"" );
    wcscpy( m_szCurrentFullyQualifiedComputerName, L"" );
    wcscpy( m_szWarningMessageAfterApply,          L"" );
    wcscpy( m_szDomainUserName,                    L"" );
    wcscpy( m_szDomainPasswordName,                L"" );

    m_dwTrustCount    = 0;


} //*** CComputer::CComputer ()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::GetComputerName
//
//  Description:
//      Wraps the GetComputerNameEx Win32 API call.  Should only be called
//      with the ComputerNamePhysicalDnsHostname and ComputerNamePhysicalDnsFullyQualified
//      COMPUTER_NAME_FORMAT enum values.
//
//      Outputted string must be freed with SysFreeString().
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CComputer::GetComputerName( 
    BSTR &               bstrComputerNameOut, 
    COMPUTER_NAME_FORMAT cnfComputerNameSpecifierIn
    )
{

    HRESULT hr = S_OK;
    DWORD dwError;

    try
    {
        unsigned long nMaxComputerNameLength = nMAX_COMPUTER_NAME_LENGTH;
        WCHAR         szComputerName[nMAX_COMPUTER_NAME_LENGTH + 1];

        _ASSERT( cnfComputerNameSpecifierIn == ComputerNamePhysicalDnsHostname || 
                 cnfComputerNameSpecifierIn == ComputerNamePhysicalDnsFullyQualified );

        if ( ! GetComputerNameEx( cnfComputerNameSpecifierIn, 
                                 szComputerName, 
                                 &nMaxComputerNameLength ) )
        {
            dwError = GetLastError();
            ATLTRACE( L"GetComputerNameEx failed with GetLastError returning %d", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: GetComputerNameEx fails

        bstrComputerNameOut = SysAllocString( szComputerName );

        if ( bstrComputerNameOut == NULL )
        {
            hr = E_OUTOFMEMORY;
            throw hr;

        } // if: bstrComputerNameOut == NULL
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::GetComputerName ()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::SetComputerName
//
//  Description:
//      Wraps the SetComputerNameEx Win32 API call.  Should only be called
//      with the ComputerNamePhysicalDnsHostname and ComputerNamePhysicalDnsDomain
//      COMPUTER_NAME_FORMAT enum values.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CComputer::SetComputerName( 
    BSTR                 bstrComputerNameIn, 
    COMPUTER_NAME_FORMAT cnfComputerNameSpecifierIn
    )
{
    HRESULT hr = S_OK;
    DWORD dwError;

    try
    {
        const WCHAR szIllegalChars[] = { L'\"', L'/', L'\\', L'[', L']', L':', L'|', L'<', L'>', L'+', L'=', L';', L',', L'?' };

        unsigned int i;
        unsigned int j;
        unsigned int nIllegalCharCount = sizeof( szIllegalChars ) / sizeof( WCHAR );

        NET_API_STATUS       nas;
        NETSETUP_JOIN_STATUS njsJoinStatus;

        WCHAR szComputerName[ nMAX_COMPUTER_NAME_LENGTH + 1 ];
        WCHAR * pwszDomainName;

        _ASSERT( cnfComputerNameSpecifierIn == ComputerNamePhysicalDnsHostname || 
                 cnfComputerNameSpecifierIn == ComputerNamePhysicalDnsDomain );

        wcsncpy( szComputerName, bstrComputerNameIn, nMAX_COMPUTER_NAME_LENGTH);
        szComputerName[nMAX_COMPUTER_NAME_LENGTH] = L'\0';

        //
        //  Make sure the computer name is not blank
        //

        if ( wcscmp( szComputerName, L"" ) == 0 )
        {
            hr = E_INVALIDARG;
            throw hr;

        } // if: szComputerName is not initialised


        //
        //  Make sure there are no leading or trailing spaces
        //
        if ( szComputerName[0] == L' ' || 
            szComputerName[wcslen( szComputerName )] == L' ' )
        {
            hr = E_INVALIDARG;
            throw hr;

        } // if: szComputerName contains leading or trailing spaces

        //
        //  Make sure there are no illegal chars
        //

        for ( i = 0; i < wcslen( szComputerName ); i++ )
        {

            for ( j = 0; j < nIllegalCharCount; j++ )
            {
                if ( szComputerName[i] == szIllegalChars[j] )
                {
                    hr = E_INVALIDARG;
                    throw hr;

                } // if: szComputerName contains illegal characters

            } // for: each j

        } // for: each i

         

        if ( cnfComputerNameSpecifierIn == ComputerNamePhysicalDnsDomain )
        {
            if ( ! SetComputerNameEx( cnfComputerNameSpecifierIn, szComputerName ) )
            {
                dwError = GetLastError();
                ATLTRACE( L"SetComputerNameEx failed with GetLastError returning %d", dwError );

                hr = HRESULT_FROM_WIN32( dwError );
                throw hr;

            } // if: SetComputerNameEx fails

        } // if: Set the DNS suffix

        else 
        {
            
            nas = NetValidateName( 
                NULL,
                szComputerName,
                NULL,
                NULL,
                NetSetupMachine);

            if ( nas != NERR_Success )
            {
                ATLTRACE( L"Error getting join information : nas error %d.\n", nas );

                hr = HRESULT_FROM_WIN32( nas );  // Check this works !!!!
                throw hr;

            } // if: NetValidateName failed

            nas = NetGetJoinInformation(
                NULL,
                &pwszDomainName,
                &njsJoinStatus );

            if ( nas != NERR_Success )
            {
                ATLTRACE( L"Error getting join information : nas error %d.\n", nas );

                hr = HRESULT_FROM_WIN32( nas );  // Check this works !!!!
                throw hr;

            } // if: NetGetJoinInformation failed

            NetApiBufferFree ( reinterpret_cast<void *>( pwszDomainName ) );

            if ( njsJoinStatus == NetSetupDomainName )
            {

                if ( ( _wcsicmp( m_szDomainUserName, L"" ) == 0 ) &&
                     ( _wcsicmp( m_szDomainPasswordName, L"") == 0 ) )
                {
                    hr = E_FAIL;
                    throw hr;

                } // if: Username and Password are not set
            
                nas = NetRenameMachineInDomain(
                        NULL,/*m_szCurrentComputerName,*/
                        m_szNewComputerName,
                        m_szDomainUserName,
                        m_szDomainPasswordName,
                        NETSETUP_ACCT_CREATE
                        );
                if ( nas != NERR_Success )
                {
                    ATLTRACE( L"Error renaming the computer name : nas error %d.\n", nas);
                    hr = HRESULT_FROM_WIN32( nas );
                    throw hr;

                } // if: NetRenameMachineInDomain failed

            } // if: njsJoinStatus == NetSetupDomainName

            else
            {
        
                if ( ! SetComputerNameEx( cnfComputerNameSpecifierIn, szComputerName ) )
                {
                    dwError = GetLastError();
                    ATLTRACE( L"SetComputerNameEx failed with GetLastError returning %d", dwError );

                    hr = HRESULT_FROM_WIN32( dwError );
                    throw hr;

                } // if: SetComputerNameEx fails

            } // else: njsJoinStatus != NetSetupDomainName
        }

    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::SetComputerName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::ChangeMembership
//
//  Description:
//      Joins the computer to a workgroup or a domain
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CComputer::ChangeMembership(
    BOOL bJoinDomain,    //  TRUE if joining a Domain, FALSE if joining a Workgroup
    BSTR bstrGroupName,  //  the workgroup or domain to join
    BSTR bstrUserName,   //  ignored if joining a workgroup
    BSTR bstrPassword    //  ignored if joining a workgroup
    )
{
    HRESULT hr = S_OK;
    
    try
    {
        DWORD dwJoinOptions    = 0;
        WCHAR * pwszDomainName = NULL;

        NET_API_STATUS       nas;
        NETSETUP_JOIN_STATUS njsJoinStatus;
        

        //
        //  If we are joining a domain
        //

        if ( bJoinDomain )
        {

            dwJoinOptions = NETSETUP_JOIN_DOMAIN | NETSETUP_DOMAIN_JOIN_IF_JOINED | NETSETUP_ACCT_CREATE;

            // BUGBUG: this API call has to be checked to see if it can join to a NT4 PDC
            nas = NetJoinDomain( 
                NULL,
                bstrGroupName,
                NULL,
                bstrUserName,
                bstrPassword,
                dwJoinOptions 
                );

            if ( nas != NERR_Success )
            {
                ATLTRACE( L"Error joining domain: nas error %d.\n", nas );

                hr = HRESULT_FROM_WIN32( nas );
                throw hr;

            } // if: nas != NERR_Success

        } // if: bJoinDomain is true

        else
        {

            nas = NetGetJoinInformation(
                NULL,
                &pwszDomainName,
                &njsJoinStatus );

            if ( nas != NERR_Success )
            {
                ATLTRACE( L"Error getting join information : nas error %d.\n", nas );

                hr = HRESULT_FROM_WIN32( nas );  // Check this works !!!!
                throw hr;

            } // if: NetGetJoinInformation failed

            NetApiBufferFree ( reinterpret_cast<void *>( pwszDomainName ) );

            if ( njsJoinStatus == NetSetupDomainName )
            {
                //
                //  we are joining a workgoup from domain, 
                //  so need to unjoin from domain
                //

                dwJoinOptions = 0;

                nas = NetUnjoinDomain( 
                        NULL,
                        NULL,
                        NULL,
                        dwJoinOptions 
                        );

                if ( nas != NERR_Success )
                {
                    ATLTRACE( L"Error unjoining domain: nas error %d.\n", nas );

                    hr = HRESULT_FROM_WIN32( nas );
                    throw hr;


                } // if: nas != NERR_Success
            }

            dwJoinOptions = 0;

            nas = NetJoinDomain( 
                    NULL,
                    bstrGroupName,
                    NULL,
                    NULL,
                    NULL,
                    dwJoinOptions 
                    );

            if ( nas != NERR_Success )
            {
                ATLTRACE( L"Error joining workgroup: nas error %d.\n", nas );

                hr = HRESULT_FROM_WIN32( nas );
                throw hr;


            } // if: nas != NERR_Success

        } // else: bJoinDomain is false
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} // *** CComputer::ChangeMembership()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::get_ComputerName
//
//  Description:
//      Property accessor method to get the Computer Name.  Assumes the BSTR
//      parameter does not currently point to allocated memory.
//
//      Outputted string must be freed with SysFreeString().
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CComputer::get_ComputerName( 
    BSTR * pVal 
    )
{
    HRESULT hr = S_OK;

    try
    {
        if ( _wcsicmp( m_szCurrentComputerName, L"" ) == 0 )
        {
            BSTR bstrComputerName = NULL;
    
            hr = GetComputerName( bstrComputerName, ComputerNamePhysicalDnsHostname );

            if (( FAILED( hr ) ) || (NULL == bstrComputerName))
            {
                throw hr;

            } // if: FAILED (hr)

            wcscpy( m_szNewComputerName,     bstrComputerName );
            wcscpy( m_szCurrentComputerName, bstrComputerName );

            SysFreeString( bstrComputerName );

        } // if: m_szCurrentComputerName is not set

        *pVal = SysAllocString( m_szNewComputerName );

        if ( *pVal == NULL )
        {
            hr = E_OUTOFMEMORY;
            throw hr;

        } // if: *pVal == NULL
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::get_ComputerName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::put_ComputerName
//
//  Description:
//      Property accessor method to set the Computer Name.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CComputer::put_ComputerName( 
    BSTR newVal 
    )
{
    HRESULT hr = S_OK;

    try
    {
        if ( _wcsicmp( m_szCurrentComputerName, L"" ) == 0 )
        {
            BSTR bstrTemp;
            hr = get_ComputerName( &bstrTemp );
            
            if ( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

            SysFreeString( bstrTemp );

        }

        wcsncpy( m_szNewComputerName, newVal, nMAX_COMPUTER_NAME_LENGTH );
        m_szNewComputerName[nMAX_COMPUTER_NAME_LENGTH] = L'\0';

    } // if: m_szCurrentComputerName is not set

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::put_ComputerName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::get_FullQualifiedComputerName
//
//  Description:
//      Property accessor method to get the Fully Qualified Computer Name.
//      Assumes the BSTR parameter does not currently point to allocated memory.
//
//      Outputted string must be freed with SysFreeString().
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CComputer::get_FullQualifiedComputerName( 
    BSTR * pVal 
    )
{
    HRESULT hr = S_OK;

    try
    {
        if ( _wcsicmp( m_szCurrentFullyQualifiedComputerName, L"" ) == 0 ) 
        {
            BSTR    bstrFullyQualifiedComputerName = NULL;

            hr = GetComputerName( bstrFullyQualifiedComputerName, ComputerNamePhysicalDnsFullyQualified );

            if ((FAILED( hr ) ) || (NULL == bstrFullyQualifiedComputerName))
            {

                throw hr;

            } // if: FAILED (hr)

            wcscpy( m_szNewFullyQualifiedComputerName,     bstrFullyQualifiedComputerName );
            wcscpy( m_szCurrentFullyQualifiedComputerName, bstrFullyQualifiedComputerName );

            SysFreeString( bstrFullyQualifiedComputerName );

        } // if: m_szCurrentFullyQualifiedComputerName is not set

        *pVal = SysAllocString( m_szNewFullyQualifiedComputerName );

        if ( *pVal == NULL )
        {
            hr = E_OUTOFMEMORY;
            throw hr;

        } // if: *pVal == NULL
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::get_FullQualifiedComputerName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::put_FullQualifiedComputerName
//
//  Description:
//      Property accessor method to set the Fully Qualified Computer Name.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CComputer::put_FullQualifiedComputerName( 
    BSTR newVal 
    )
{
    HRESULT hr = S_OK;

    try
    {
        if ( _wcsicmp( m_szCurrentFullyQualifiedComputerName, L"" ) == 0 )
        {
            BSTR bstrTemp;
            hr = get_FullQualifiedComputerName( &bstrTemp );
            
            if ( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

            SysFreeString( bstrTemp );

        }

        wcsncpy( m_szNewFullyQualifiedComputerName, newVal, nMAX_COMPUTER_NAME_LENGTH );
        m_szNewFullyQualifiedComputerName[nMAX_COMPUTER_NAME_LENGTH] = L'\0';

    } // if: m_szCurrentFullyQualifiedComputerName is not set

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::put_FullQualifiedComputerName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::get_WorkgroupName
//
//  Description:
//      Property accessor method to get the Workgroup Name.  Assumes the BSTR
//      parameter does not currently point to allocated memory.
//
//      Outputted string must be freed with SysFreeString().
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CComputer::get_WorkgroupName( 
    BSTR * pVal 
    )
{
    HRESULT hr = S_OK;

    try
    {
        if ( _wcsicmp( m_szCurrentWorkgroupOrDomainName, L"" ) == 0 ) 
        {
            hr = GetDomainOrWorkgroupName();

            if ( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

        } // if: m_szCurrentWorkgroupOrDomainName is not set

        if ( ! m_bJoinDomain )
        {

            *pVal = SysAllocString( m_szNewWorkgroupOrDomainName );

            if ( *pVal == NULL )
            {
                hr = E_OUTOFMEMORY;
                throw hr;

            } // if: *pVal == NULL

        } // if: m_bJoinDomain is false

        else
        {
            hr = E_FAIL;
            throw hr;

        } // else: m_bJoinDomain is true
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::get_WorkgroupName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::put_WorkgroupName
//
//  Description:
//      Property accessor method to set the Workgroup Name.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CComputer::put_WorkgroupName( 
    BSTR newVal 
    )
{
    HRESULT hr = S_OK;

    try
    {
        if ( _wcsicmp( m_szCurrentWorkgroupOrDomainName, L"" ) == 0 )
        {
            BSTR bstrTemp;
            hr = get_WorkgroupName( &bstrTemp );
            
            if ( FAILED( hr ) )
            {
                hr = get_DomainName( &bstrTemp );
                
                if ( FAILED( hr ) )
                {
                    throw hr;
                }

            } // if: FAILED( hr )

            SysFreeString( bstrTemp );

        } // if: m_szCurrentWorkgroupOrDomainName is not set

        m_bJoinDomain = false;

        wcsncpy( m_szNewWorkgroupOrDomainName, newVal, nMAX_COMPUTER_NAME_LENGTH );
        m_szNewWorkgroupOrDomainName[nMAX_COMPUTER_NAME_LENGTH] = L'\0';
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::put_WorkgroupName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::get_DomainName
//
//  Description:
//      Property accessor method to get the Domain Name.  Assumes the BSTR
//      parameter does not currently point to allocated memory.
//
//      Outputted string must be freed with SysFreeString().
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CComputer::get_DomainName( 
    BSTR * pVal 
    )
{
    HRESULT hr = S_OK;

    try
    {
        if ( _wcsicmp( m_szCurrentWorkgroupOrDomainName, L"" ) == 0 ) 
        {
            hr = GetDomainOrWorkgroupName();

            if ( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

        } // if: m_szCurrentWorkgroupOrDomainName is not set

        if ( m_bJoinDomain )
        {

            *pVal = SysAllocString( m_szNewWorkgroupOrDomainName );

            if ( *pVal == NULL )
            {
                hr = E_OUTOFMEMORY;
                throw hr;

            } // if: *pVal == NULL

        } // if: m_bJoinDomain is true

        else
        {
            hr = E_FAIL;
            throw hr;

        } // else: m_bJoinDomain is false
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::get_DomainName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::put_DomainName
//
//  Description:
//      Property accessor method to set the Domain Name.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CComputer::put_DomainName( 
    BSTR newVal 
    )
{
    HRESULT hr = S_OK;

    try
    {
        if ( _wcsicmp( m_szCurrentWorkgroupOrDomainName, L"" ) == 0 )
        {
            BSTR bstrTemp;
            hr = get_DomainName( &bstrTemp );
            
            if ( FAILED( hr ) )
            {
                hr = get_WorkgroupName( &bstrTemp );
                
                if ( FAILED( hr ) )
                {
                    throw hr;
                }

            } // if: FAILED( hr )

            SysFreeString( bstrTemp );

        } // if: m_szCurrentWorkgroupOrDomainName is not set

        m_bJoinDomain = true;

        wcsncpy( m_szNewWorkgroupOrDomainName, newVal, nMAX_COMPUTER_NAME_LENGTH );
        m_szNewWorkgroupOrDomainName[nMAX_COMPUTER_NAME_LENGTH] = L'\0';
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::put_DomainName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::GetDomainOrWorkgroupName
//
//  Description:
//      Used to get the Domain or Workgroup Name of the current system.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CComputer::GetDomainOrWorkgroupName( void )
{
    HRESULT hr = S_OK;
    
    try
    {
        WCHAR *              pwszDomainName;
        NET_API_STATUS       nas;
        NETSETUP_JOIN_STATUS njsJoinStatus;

        nas = NetGetJoinInformation(
            NULL,
            &pwszDomainName,
            &njsJoinStatus );

        if ( nas != NERR_Success )
        {
            ATLTRACE( L"Error getting join information : nas error %d.\n", nas );

            hr = HRESULT_FROM_WIN32( nas );
            throw hr;

        } // if: nas != NERR_Success

        wcscpy( m_szNewWorkgroupOrDomainName,     pwszDomainName );
        wcscpy( m_szCurrentWorkgroupOrDomainName, pwszDomainName );
    
        if ( njsJoinStatus == NetSetupWorkgroupName )
        {
            m_bJoinDomain = false;

        } // if: njsJoinStatus == NetSetupWorkgroupName

        if ( njsJoinStatus == NetSetupDomainName )
        {
            m_bJoinDomain = true;

        } // if: njsJoinStatus == NetSetupDomainName

        NetApiBufferFree ( reinterpret_cast<void *>( pwszDomainName ) );
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::GetDomainOrWorkgroupName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::EnumTrustedDomains
//
//  Description:
//      Enumerates the trusted domains 
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CComputer::EnumTrustedDomains( 
    VARIANT * pvarTDomains 
    )
{
    DWORD     nCount;
    DWORD     dwError;
    SAFEARRAY * psa      = NULL;
    VARIANT   * varArray = NULL;
    HRESULT   hr         = S_OK; 

    try
    {
        m_ppwszTrustList = ( LPWSTR * )HeapAlloc(
            GetProcessHeap(), HEAP_ZERO_MEMORY,
            nMAX_ELEMENT_COUNT * sizeof( LPWSTR )
            );
    
        if ( m_ppwszTrustList == NULL ) 
        {
            ATLTRACE( L"HeapAlloc error!\n" );
            hr = E_OUTOFMEMORY;
            throw hr;

        } // if: m_ppwszTrustList == NULL

        if ( !BuildTrustList(NULL ) )    // NULL defaults to local machine
        {
            dwError = GetLastError();
            ATLTRACE( L"BuildTrustList failed %d\n", dwError );
            
            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: BuildTrustList function fails

        else 
        {
            VariantInit( pvarTDomains );

            SAFEARRAYBOUND bounds = { m_dwTrustCount, 0 };
            psa                   = SafeArrayCreate( VT_VARIANT, 1, &bounds );

            if ( psa == NULL )
            {
                hr = E_OUTOFMEMORY;
                throw hr;
            }
            
            varArray = new VARIANT[ m_dwTrustCount ];
            for ( nCount = 0; nCount < m_dwTrustCount; nCount++ ) 
            {
                VariantInit( &varArray[nCount]);
                V_VT( &varArray[ nCount ] )   = VT_BSTR;
                V_BSTR( &varArray[ nCount ] ) = SysAllocString( m_ppwszTrustList[ nCount ] );

                if ( &varArray[ nCount ] == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    throw hr;
                }
            }

            LPVARIANT rgElems;

            hr = SafeArrayAccessData( psa, reinterpret_cast<void **>( &rgElems ) );

            if ( FAILED( hr ) )
            {
                throw hr;

            } // if: SafeArrayAccessData failed
            
            //
            // Enumerates trust list
            //

            for ( nCount = 0; nCount < m_dwTrustCount; nCount++ ) 
            {
                rgElems[nCount] = varArray[nCount];
            
            } // for: Enumerating nCount of trusted domains

            hr = SafeArrayUnaccessData( psa );

            if ( FAILED( hr ) )
            {
                throw hr;

            } // if: SafeArrayUnaccessData failed

            delete [] varArray;

            V_VT( pvarTDomains ) = VT_ARRAY | VT_VARIANT;
            V_ARRAY( pvarTDomains ) = psa;

        } // else: BuildTrustList function succeeds

        //
        // free trust list
        //
        for ( nCount = 0 ; nCount < m_dwTrustCount ; nCount++ ) 
        {
            if ( m_ppwszTrustList[ nCount ] != NULL )
            {
                HeapFree( GetProcessHeap(), 0, m_ppwszTrustList[nCount] );
            }

        } // for: Freeing the allocated memory

        HeapFree( GetProcessHeap(), 0, m_ppwszTrustList );

    }

    catch( ... )
    {

        if (NULL != m_ppwszTrustList)
        {
            //
            //  Don't let any exceptions leave this function call
            //
            for ( nCount = 0 ; nCount < m_dwTrustCount ; nCount++ ) 
            {
                if ( m_ppwszTrustList[ nCount ] != NULL )
                {
                    HeapFree( GetProcessHeap(), 0, m_ppwszTrustList[nCount] );
                }
            } // for: Freeing the allocated memory

            HeapFree( GetProcessHeap(), 0, m_ppwszTrustList );
        }
        
        if ( varArray != NULL )
        {
            delete [] varArray;
        }

        if ( psa != NULL )
        {
            SafeArrayDestroy( psa );
        }

        return hr;
    }

    return hr;

} //*** CComputer::EnumTrustedDomains()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::Apply
//
//  Description:
//      None of the properties for the CComputer object take effect until
//      this Apply function is called.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CComputer::Apply( void )
{

    HRESULT hr = S_OK;
    HRESULT hrComputerName         = S_OK;
    HRESULT hrNetBiosName          = S_OK;
    HRESULT hrDnsSuffixName        = S_OK;
    HRESULT hrWorkgroupDomainName  = S_OK;
    BSTR    bstrWarningMessage;
    
    try
    {
        
        //
        //  Save the final warning message as to what is causing the reboots
        //

        if ( IsRebootRequired( &bstrWarningMessage ) )
        {
            wcscpy( m_szWarningMessageAfterApply, bstrWarningMessage );

            SysFreeString( bstrWarningMessage );

        } // if: IsRebootRequired returns true

        //
        //  Set the Domain/Workgroup, if necessary
        //

        if ( _wcsicmp( m_szCurrentWorkgroupOrDomainName, m_szNewWorkgroupOrDomainName ) != 0 )
        {

            if ( m_bJoinDomain )
            {
                if ( ( _wcsicmp( m_szDomainUserName, L"" ) == 0 ) &&
                     ( _wcsicmp( m_szDomainPasswordName, L"") == 0 ) )
                {
                    hr = E_FAIL;
                    throw hr;
                }

            } // if: m_bJoinDomain is TRUE

            hrWorkgroupDomainName = ChangeMembership( m_bJoinDomain, 
                                                      _bstr_t  (m_szNewWorkgroupOrDomainName), 
                                                      _bstr_t (m_szDomainUserName), 
                                                      _bstr_t (m_szDomainPasswordName ));

            if ( SUCCEEDED( hrWorkgroupDomainName ) )
            {
                wcscpy( m_szCurrentWorkgroupOrDomainName, m_szNewWorkgroupOrDomainName );

                m_bRebootNecessary = true;

            } // if: ChangeMembership succeeded
        
            else 
            {
                hr = hrWorkgroupDomainName;
                throw hr;

            } // else: ChangeMembership failed

        } // if: m_szCurrentWorkgroupOrDomainName != m_szNewWorkgroupOrDomainName
        
        
        //
        //  Set the computer name, if necessary
        //

        if ( _wcsicmp( m_szCurrentComputerName, m_szNewComputerName ) != 0 )
        {

            hrComputerName = SetComputerName( 
                                _bstr_t (m_szNewComputerName), 
                                ComputerNamePhysicalDnsHostname 
                                );

            if ( SUCCEEDED( hrComputerName ) )
            {
                wcscpy( m_szCurrentComputerName, m_szNewComputerName );

                m_bRebootNecessary = true;

            } // if: SUCCEEDED( hrComputerName )
        
            else
            {
                hr = hrComputerName;
                throw hr;

            } // else: SetComputerName fails

        } // if: m_szCurrentComputerName != m_szNewComputerName

        //
        //  Set the Fully qualified computer name, if necessary
        //

        if ( _wcsicmp( m_szCurrentFullyQualifiedComputerName, m_szNewFullyQualifiedComputerName ) != 0 )
        {

            WCHAR * pBuffer;
            WCHAR szNetBiosName[nMAX_COMPUTER_NAME_LENGTH + 1]    = L"";
            WCHAR szDnsSuffixName[nMAX_COMPUTER_NAME_LENGTH + 1]  = L"";

            pBuffer = m_szNewFullyQualifiedComputerName;

            //
            //  Parse off the computer name and the DNS Suffix
            //

            while ( *pBuffer != L'.' && *pBuffer != L'\0' )
            {
                pBuffer++;

            } // while: each Buffer

            if ( *pBuffer == L'\0' )
            {

                if ( _wcsicmp( m_szCurrentComputerName, m_szNewFullyQualifiedComputerName ) != 0 )
                {
                    hrNetBiosName = SetComputerName( _bstr_t (m_szNewFullyQualifiedComputerName),
                                                     ComputerNamePhysicalDnsHostname );
                    if ( FAILED( hrNetBiosName ) )
                    {
                        hr = hrNetBiosName;
                        throw hr;
                    }
                }
                
                hrDnsSuffixName = SetComputerNameEx( ComputerNamePhysicalDnsDomain, L"" );
                
                if ( FAILED( hrDnsSuffixName ) )
                {
                    hr = hrDnsSuffixName;
                    throw hr;
                }

                if ( SUCCEEDED( hrNetBiosName ) && 
                SUCCEEDED( hrDnsSuffixName ) )
                {
                    wcscpy( m_szCurrentFullyQualifiedComputerName, m_szNewFullyQualifiedComputerName );

                    m_bRebootNecessary = true;

                }

                
            } // if: *pBuffer == L'\0'

            else
            {

                *pBuffer = L'\0';

                wcscpy( szNetBiosName, m_szNewFullyQualifiedComputerName );

                *pBuffer = L'.';

                pBuffer++;

                wcscpy( szDnsSuffixName, pBuffer );

                //
                //  Have to set the computer name twice.  Once to set the NetBIOS name and once to set the DNS Suffix
                //

                if ( _wcsicmp( m_szCurrentComputerName, szNetBiosName ) != 0 )
                {
                    hrNetBiosName = SetComputerName( _bstr_t (szNetBiosName), 
                                                     ComputerNamePhysicalDnsHostname );
                    if ( FAILED( hrNetBiosName ) )
                    {
                        hr = hrNetBiosName;
                        throw hr;

                    } // if: SetComputerName failed in setting computer name

                } // if: m_szCurrentComputerName != szNetBiosName

                hrDnsSuffixName = SetComputerName( _bstr_t (szDnsSuffixName), 
                                                   ComputerNamePhysicalDnsDomain );
                if ( FAILED( hrDnsSuffixName ) )
                {
                    hr = hrDnsSuffixName;
                    throw hr;

                } // if: SetComputerName failed in setting DNS suffix


                if ( SUCCEEDED( hrNetBiosName ) && 
                    SUCCEEDED( hrDnsSuffixName ) )
                {
                    wcscpy( m_szCurrentFullyQualifiedComputerName, m_szNewFullyQualifiedComputerName );

                    m_bRebootNecessary = true;

                } // if: SetComputerName succeeded in setting FullQualifiedComputerName

            } // else: *pBuffer != L'\0'

        } // if: m_szCurrentFullyQualifiedComputerName != m_szNewFullyQualifiedComputerName

    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CComputer::Apply()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::IsRebootRequired
//
//  Description:
//      Determines if the current changes will require a reboot when Apply is
//      called and if so bstrWarningMessageOut tells what causes the need for
//      a the reboot.
//      Assumes bstrWarningMessageOut is not pointing to currently allocated
//      memory.
//
//      Outputted string must be freed with SysFreeString().
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL 
CComputer::IsRebootRequired( 
    BSTR * bstrWarningMessageOut 
    )
{

    BOOL  bReboot    = FALSE;
    WCHAR szWarningMessage[nMAX_WARNING_MESSAGE_LENGTH + 1]  = L"";

    if ( m_bRebootNecessary )
    {
        *bstrWarningMessageOut = SysAllocString( m_szWarningMessageAfterApply );

        if ( *bstrWarningMessageOut == NULL )
        {
            // return E_OUTOFMEMORY;  // BUGBUG: what should I return here?
        }

        bReboot = TRUE;

    } // if: m_bRebootNecessary is true 

    else
    {
        if ( _wcsicmp( m_szCurrentComputerName, m_szNewComputerName ) != 0 )
        {
            bReboot = TRUE;

            wcscat( szWarningMessage, szCOMPUTER_NAME );

        } // if: m_szCurrentComputerName != m_szNewComputerName

        if ( _wcsicmp( m_szCurrentFullyQualifiedComputerName, m_szNewFullyQualifiedComputerName ) != 0 )
        {
            bReboot = TRUE;

            wcscat( szWarningMessage, szFULLY_QUALIFIED_COMPUTER_NAME );

        } // if: m_szCurrentFullyQualifiedComputerName != m_szNewFullyQualifiedComputerName

        if ( _wcsicmp( m_szCurrentWorkgroupOrDomainName, m_szNewWorkgroupOrDomainName ) != 0 )
        {
            bReboot = TRUE;

            wcscat( szWarningMessage, szWORKGROUP_OR_DOMAIN_NAME );

        } // if: m_szCurrentWorkgroupOrDomainName != m_szNewWorkgroupOrDomainName

        *bstrWarningMessageOut = SysAllocString( szWarningMessage );

        if ( *bstrWarningMessageOut == NULL )
        {
            // return E_OUTOFMEMORY;  // BUGBUG: what should I return here?
        }
    }

    return bReboot;

} //*** CComputer::IsRebootRequired()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::BuildTrustList
//
//  Description:
//      None of the properties for the CComputer object take effect until
//      this Apply function is called.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CComputer::BuildTrustList(
    LPWSTR pwszTargetIn     // name of the target system, NULL defaults to local system
    )
{
    LSA_HANDLE     PolicyHandle = INVALID_HANDLE_VALUE;
    NTSTATUS       Status;
    NET_API_STATUS nas      = NERR_Success; // assume success
    BOOL           bSuccess = FALSE;        // assume this function will fail
    
    try
    {
        PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain;
        BOOL                        bDC;

        //
        // open the policy on the specified machine
        //
        Status = OpenPolicy(
            pwszTargetIn,
            POLICY_VIEW_LOCAL_INFORMATION,
            &PolicyHandle
            );

        if ( Status != STATUS_SUCCESS ) 
        {
            SetLastError( LsaNtStatusToWinError( Status ) );
            throw Status;

        } // if: Status != STATUS_SUCCESS

        //
        // obtain the AccountDomain, which is common to all three cases
        //
        Status = LsaQueryInformationPolicy(
            PolicyHandle,
            PolicyAccountDomainInformation,
            reinterpret_cast<void **>( &AccountDomain )
            );

        if ( Status != STATUS_SUCCESS )
        {
            throw Status;

        } // if: Status != STATUS_SUCCESS

        //
        // Note: AccountDomain->DomainSid will contain binary Sid
        //
        AddTrustToList( &AccountDomain->DomainName );

        //
        // free memory allocated for account domain
        //
        LsaFreeMemory( AccountDomain );

        //
        // find out if the target machine is a domain controller
        //
        if ( !IsDomainController( pwszTargetIn, &bDC ) ) 
        {
            throw FALSE;

        } // if: IsDomainController fails

        if ( !bDC ) 
        {
            PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain;
            LPWSTR                      pwszPrimaryDomainName = NULL;
            LPWSTR                      pwszDomainController  = NULL;

            //
            // get the primary domain
            //
            Status = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyPrimaryDomainInformation,
                reinterpret_cast<void **>( &PrimaryDomain )
                );

            if ( Status != STATUS_SUCCESS )
            {
                throw Status;

            } // if: Status != STATUS_SUCCESS

            //
            // if the primary domain Sid is NULL, we are a non-member, and
            // our work is done.
            //
            if ( PrimaryDomain->Sid == NULL ) 
            {
                LsaFreeMemory( PrimaryDomain );
                bSuccess = TRUE;
                throw bSuccess;

            } // if: PrimaryDomain->Sid == NULL

            AddTrustToList( &PrimaryDomain->Name );

            //
            // build a copy of what we just added.  This is necessary in order
            // to lookup the domain controller for the specified domain.
            // the Domain name must be NULL terminated for NetGetDCName(),
            // and the LSA_UNICODE_STRING buffer is not necessarilly NULL
            // terminated.  Note that in a practical implementation, we
            // could just extract the element we added, since it ends up
            // NULL terminated.
            //

            pwszPrimaryDomainName = ( LPWSTR )HeapAlloc(
                GetProcessHeap(), 0,
                PrimaryDomain->Name.Length + sizeof( WCHAR ) // existing length + NULL
                );

            if ( pwszPrimaryDomainName != NULL ) 
            {
                //
                // copy the existing buffer to the new storage, appending a NULL
                //
                wcsncpy(
                    pwszPrimaryDomainName,
                    PrimaryDomain->Name.Buffer,
                    ( PrimaryDomain->Name.Length / sizeof( WCHAR ) ) + 1
                    );

            } // if: pwszPrimaryDomainName != NULL

            LsaFreeMemory( PrimaryDomain );

            if ( pwszPrimaryDomainName == NULL ) 
            {
                throw FALSE;

            } // if: pwszPrimaryDomainName == NULL

            //
            // get the primary domain controller computer name
            //
            nas = NetGetDCName(
                    NULL,
                    pwszPrimaryDomainName,
                    ( LPBYTE * )&pwszDomainController
                    );

            HeapFree( GetProcessHeap(), 0, pwszPrimaryDomainName );

            if ( nas != NERR_Success )
            {
                throw nas;

            } // if: nas != NERR_Success

            //
            // close the policy handle, because we don't need it anymore
            // for the workstation case, as we open a handle to a DC
            // policy below
            //
            LsaClose( PolicyHandle );
            PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

            //
            // open the policy on the domain controller
            //
            Status = OpenPolicy(
                pwszDomainController,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

            //
            // free the domaincontroller buffer
            //
            NetApiBufferFree( pwszDomainController );

            if ( Status != STATUS_SUCCESS )
            {
                throw Status;

            } // if: Status != STATUS_SUCCESS

        } // if: bDC = FALSE

        //
        // build additional trusted domain(s) list and indicate if successful
        //
        bSuccess = EnumerateTrustedDomains( PolicyHandle );
    }


    catch(...)
    {
        //
        // close the policy handle
        //
        if ( PolicyHandle != INVALID_HANDLE_VALUE )
        {
            LsaClose( PolicyHandle );

        } // if: PolicyHandle != INVALID_HANDLE_VALUE

        if ( !bSuccess ) 
        {
            if ( Status != STATUS_SUCCESS )
            {
                SetLastError( LsaNtStatusToWinError( Status ) );

            } // if: Status != STATUS_SUCCESS

            else if ( nas != NERR_Success )
            {
                SetLastError( nas );

            } // else if: nas != NERR_Success

        } // if: bSuccess = FALSE
        return bSuccess;
    }

    return bSuccess;

} //*** CComputer::BuildTrustList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::EnumerateTrustedDomains
//
//  Description:
//      None of the properties for the CComputer object take effect until
//      this Apply function is called.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CComputer::EnumerateTrustedDomains(
    LSA_HANDLE PolicyHandleIn
    )
{
    BOOL bSuccess = TRUE;

    try
    {
        LSA_ENUMERATION_HANDLE lsaEnumHandle = 0;   // start an enum
        PLSA_TRUST_INFORMATION TrustInfo;
        ULONG                  ulReturned;          // number of items returned
        ULONG                  ulCounter;           // counter for items returned
        NTSTATUS               Status;

        do 
        {
            Status = LsaEnumerateTrustedDomains(
                PolicyHandleIn,                             // open policy handle
                &lsaEnumHandle,                             // enumeration tracker
                reinterpret_cast<void **>( &TrustInfo ),    // buffer to receive data
                32000,                                      // recommended buffer size
                &ulReturned                                 // number of items returned
                );
            //
            // get out if an error occurred
            //
            if ( ( Status != STATUS_SUCCESS)      &&
                 ( Status != STATUS_MORE_ENTRIES) &&
                 ( Status != STATUS_NO_MORE_ENTRIES)
               ) 
            {
                SetLastError( LsaNtStatusToWinError( Status ) );
                bSuccess = FALSE;
                throw bSuccess;

            } // if: LsaEnumerateTrustedDomains fails

            //
            // Display results
            // Note: Sids are in TrustInfo[ulCounter].Sid
            //
            for ( ulCounter = 0 ; ulCounter < ulReturned ; ulCounter++ )
            {
                AddTrustToList( &TrustInfo[ ulCounter ].Name );

            } // for: each ulCounter

            //
            // free the buffer
            //
            LsaFreeMemory( TrustInfo );

        } while ( Status != STATUS_NO_MORE_ENTRIES );
    }

    catch(...)
    {
        return bSuccess;
    }

    return bSuccess;

} //*** CComputer::EnumerateTrustedDomains()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::IsDomainController
//
//  Description:
//      None of the properties for the CComputer object take effect until
//      this Apply function is called.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CComputer::IsDomainController(
    LPWSTR pwszServerIn,
    LPBOOL pbDomainControllerOut
    )
{
    BOOL bSuccess = TRUE;

    try
    {
        PSERVER_INFO_101 si101;
        NET_API_STATUS   nas;

        nas = NetServerGetInfo(
            pwszServerIn,
            101,    // info-level
            ( LPBYTE * )&si101
            );

        if ( nas != NERR_Success ) 
        {
            SetLastError(nas);
            bSuccess = FALSE;
            throw bSuccess;

        } // if: nas != NERR_Success

        if ( ( si101->sv101_type & SV_TYPE_DOMAIN_CTRL ) ||
             ( si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL ) ) 
        {
            //
            // we are dealing with a DC
            //
            *pbDomainControllerOut = TRUE;

        } // if: for the domain controller

        else 
        {
            *pbDomainControllerOut = FALSE;

        } // else: not a domain controller

        NetApiBufferFree( si101 );
    }

    catch(...)
    {
        return bSuccess;
    }

    return bSuccess;

} //*** CComputer::IsDomainController()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::AddTrustToList
//
//  Description:
//      None of the properties for the CComputer object take effect until
//      this Apply function is called.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CComputer::AddTrustToList(
    PLSA_UNICODE_STRING pLsaUnicodeStringIn
    )
{
    BOOL bSuccess = TRUE;

    try
    {

        if ( m_dwTrustCount >= nMAX_ELEMENT_COUNT ) 
        {
            bSuccess = FALSE;
            throw bSuccess;

        } // if: m_dwTrustCount >= nMAX_ELEMENT_COUNT

        //
        // allocate storage for array element
        //
        m_ppwszTrustList[ m_dwTrustCount ] = ( LPWSTR )HeapAlloc(
            GetProcessHeap(), 0,
            pLsaUnicodeStringIn->Length + sizeof( WCHAR )  // existing length + NULL
            );

        if ( m_ppwszTrustList[ m_dwTrustCount ] == NULL ) 
        {
            bSuccess = FALSE;
            throw bSuccess;

        } // if: m_ppwszTrustList[ m_dwTrustCount ] == NULL

        //
        // copy the existing buffer to the new storage, appending a NULL
        //
        wcsncpy(
            m_ppwszTrustList[m_dwTrustCount],
            pLsaUnicodeStringIn->Buffer,
            ( pLsaUnicodeStringIn->Length / sizeof( WCHAR ) ) + 1
            );

        m_dwTrustCount++; // increment the trust count
    }

    catch(...)
    {
        return bSuccess;
    }

    return bSuccess;

} //*** CComputer::AddTrustToList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::InitLsaString
//
//  Description:
//      None of the properties for the CComputer object take effect until
//      this Apply function is called.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CComputer::InitLsaString(
    PLSA_UNICODE_STRING pLsaStringOut,
    LPWSTR              pwszStringIn
    )
{
    DWORD dwStringLength;

    if ( pwszStringIn == NULL ) 
    {
        pLsaStringOut->Buffer        = NULL;
        pLsaStringOut->Length        = 0;
        pLsaStringOut->MaximumLength = 0;

        return;

    } // if: String == NULL 

    dwStringLength               = wcslen( pwszStringIn );
    pLsaStringOut->Buffer        = pwszStringIn;
    pLsaStringOut->Length        = ( USHORT ) dwStringLength * sizeof( WCHAR );
    pLsaStringOut->MaximumLength = ( USHORT ) ( dwStringLength + 1 ) * sizeof( WCHAR );

} //*** CComputer::InitLsaString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::OpenPolicy
//
//  Description:
//      None of the properties for the CComputer object take effect until
//      this Apply function is called.
//
//--
//////////////////////////////////////////////////////////////////////////////
NTSTATUS
CComputer::OpenPolicy(
    LPWSTR      pwszServerNameIn,
    DWORD       dwDesiredAccessIn,
    PLSA_HANDLE PolicyHandleOut
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING    ServerString;
    PLSA_UNICODE_STRING   Server;

    //
    // Always initialize the object attributes to all zeroes
    //
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if ( pwszServerNameIn != NULL ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString( &ServerString, pwszServerNameIn );
        Server = &ServerString;

    } // if: ServerName != NULL

    else 
    {
        Server = NULL;

    } // if: ServerName == NULL

    //
    // Attempt to open the policy
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                dwDesiredAccessIn,
                PolicyHandleOut
                );

} //*** CComputer::OpenPolicy()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CComputer::LogonInfo
//
//  Description:
//      Gathers the Logon information for the implementation of ComputerName
//      and DomainName changes. This method is to be invoked before invoking
//      ISystemSetting::Apply method.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CComputer::LogonInfo( 
    BSTR UserName, 
    BSTR Password 
    )
{
    // TODO: Add your implementation code here

    wcscpy( m_szDomainUserName, UserName );
    wcscpy( m_szDomainPasswordName, Password );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\computer.h ===
// Computer.h : Declaration of the CComputer
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      computer.h
//
//  Description:
//        This module deals with getting and setting the computer's network names 
//        and exposes the following.
//            Properties :
//                ComputerName
//                DomainName
//                WorkgroupName
//                FullQualifiedComputerName
//            Methods :
//                ChangeDomainName
//
//  Implementation File:
//      computer.cpp
//
//  Maintained By:
//      Michael Hawkins (a-michaw) 18-Jan-2000
//      Muniswamy Prabu (a-mprabu) 14-Feb-2000
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __COMPUTER_H_
#define __COMPUTER_H_

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_MORE_ENTRIES             ((NTSTATUS)0x00000105L)
#define STATUS_NO_MORE_ENTRIES          ((NTSTATUS)0x8000001AL)
#endif

#include "constants.h"
#include "resource.h"       // main symbols
#include "Setting.h"
#include <ntsecapi.h>

const int   nMAX_DOMAINUSERNAME_LENGTH        = 256;
const int   nMAX_DOMAINUSERPASSWORD_LENGTH    = 256;
const int   nMAX_WARNING_MESSAGE_LENGTH       = 1024;
const WCHAR szCOMPUTER_NAME[]                 = L"Computer Name\n";
const WCHAR szFULLY_QUALIFIED_COMPUTER_NAME[] = L"Fully Qualified Computer Name\n";
const WCHAR szWORKGROUP_OR_DOMAIN_NAME[]      = L"Workgroup or Domain Name\n";
const int   nMAX_ELEMENT_COUNT                = 1024;

/////////////////////////////////////////////////////////////////////////////
// CComputer
class ATL_NO_VTABLE CComputer : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IComputer, &IID_IComputer, &LIBID_COMHELPERLib>,
    public CSetting
{
public:
    
DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComputer)
    COM_INTERFACE_ENTRY(IComputer)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CComputer)
END_CATEGORY_MAP()

// IComputer
public:

    CComputer();
    ~CComputer() {} ;

    HRESULT
    Apply( void );

    BOOL 
    IsRebootRequired( BSTR * bstrWarningMessage );

    STDMETHOD(get_DomainName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_DomainName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_WorkgroupName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_WorkgroupName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_FullQualifiedComputerName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_FullQualifiedComputerName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ComputerName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ComputerName)(/*[in]*/ BSTR newVal);
    STDMETHOD(EnumTrustedDomains)(/*[out,retval]*/ VARIANT * pvarTDomains);
      STDMETHOD(LogonInfo)(/*[in]*/ BSTR UserName, /*[in]*/ BSTR Password);


protected:

    STDMETHODIMP 
    GetComputerName( 
        BSTR &               bstrComputerName, 
        COMPUTER_NAME_FORMAT cnfComputerNameSpecifier 
        );

    STDMETHODIMP 
    SetComputerName( 
        BSTR                 bstrComputerName, 
        COMPUTER_NAME_FORMAT cnfComputerNameSpecifier 
        );

    STDMETHODIMP 
    GetDomainOrWorkgroupName( void );

    STDMETHODIMP 
    ChangeMembership(
        BOOL bJoinDomain,
        BSTR bstrGroupName, 
        BSTR bstrUserName, 
        BSTR bstrPassword 
        );

    //
    // Helper functions for enumerating the trusted domain names
    //
    BOOL
    BuildTrustList(
        LPWSTR pwszTargetIn
        );

    BOOL
    IsDomainController(
        LPWSTR pwszServerIn,
        LPBOOL pbDomainControllerOut
        );

    BOOL
    EnumerateTrustedDomains(
        LSA_HANDLE PolicyHandleIn
        );

    BOOL
    AddTrustToList(
        PLSA_UNICODE_STRING pLsaUnicodeStringIn
        );

    void
    InitLsaString(
        PLSA_UNICODE_STRING pLsaStringOut,
        LPWSTR              pwszStringIn
        );

    NTSTATUS
    OpenPolicy(
        LPWSTR      pwszServerNameIn,
        DWORD       dwDesiredAccessIn,
        PLSA_HANDLE PolicyHandleOut
        );


    WCHAR m_szCurrentComputerName[ nMAX_COMPUTER_NAME_LENGTH + 1 ];
    WCHAR m_szNewComputerName[ nMAX_COMPUTER_NAME_LENGTH + 1 ];

    WCHAR m_szCurrentFullyQualifiedComputerName[ nMAX_COMPUTER_NAME_LENGTH + 1 ];
    WCHAR m_szNewFullyQualifiedComputerName[ nMAX_COMPUTER_NAME_LENGTH + 1 ];

    bool  m_bRebootNecessary;
    WCHAR m_szWarningMessageAfterApply[ nMAX_WARNING_MESSAGE_LENGTH + 1 ];

    LPWSTR * m_ppwszTrustList;    // array of trust elements
    DWORD    m_dwTrustCount;      // number of elements in ppwszTrustList

    //
    //  Last write wins if they choose to both change the workgroup and change the domain
    //
    bool  m_bJoinDomain;
    WCHAR m_szCurrentWorkgroupOrDomainName[ nMAX_COMPUTER_NAME_LENGTH + 1 ];
    WCHAR m_szNewWorkgroupOrDomainName[ nMAX_COMPUTER_NAME_LENGTH + 1 ];

    WCHAR m_szDomainUserName[ nMAX_DOMAINUSERNAME_LENGTH + 1 ];
    WCHAR m_szDomainPasswordName[ nMAX_DOMAINUSERPASSWORD_LENGTH + 1 ];

};

#endif //__COMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\cryptrandomobject.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//      CryptRandomObject.cpp
//
//  Description:
//      Implementation of CCryptRandomObject, which implements a COM wrapper
//      to CryptGenRandom to create cryptographically random strings.
//
//  Header File:
//      CryptCrandomObject.h
//
//  Maintained By:
//      Tom Marsh (tmarsh) 12-April-2002
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "COMHelper.h"
#include "CryptRandomObject.h"

static const long s_clMaxByteLength = 1024;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCryptRandomObject::GetRandomHexString
//
//  Description:
//      Generates the specified number of bytes of cryptographically random
//      data, and hex encodes it.  For example, if the effective byte size is
//      two, and the generated data is 0xFA91, the returned string will be
//      "FA91".  Note that each byte of random data will be represented by
//      four bytes of output data (2 wide characters).
//
//      The effective byte size is currently limited to one kilobyte to avoid
//      excessive memory allocation or execution time.  *pbstrRandomData should
//      not point to an allocated BSTR before this method is called because the
//      BSTR will not be freed.  On success, the caller is responsible for
//      freeing the BSTR returned.
//
//  Parameters:
//      lEffectiveByteSize  ([in] long)
//          the requested effective byte size
//
//      pbstrRandomData     ([out, retval] BSTR *)
//          on success, contains the hex encoded cryptographically random data;
//          on failure, set to NULL
//
//  Errors:
//      S_OK            The string was successfully generated
//      E_INVALIDARG    lEffectiveByteSize < 1 or
//                      lEffectiveByteSize > s_clMaxByteLength
//      E_POINTER       pbstrRandomData == NULL
//      E_OUTOFMEMORY   Could not allocate the BSTR
//      E_FAIL          Could not generate the random data.  Currently, no
//                      specific failure information is provided.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CCryptRandomObject::GetRandomHexString
(
    /*[in]*/        long lEffectiveByteSize,
    /*[out, 
       retval]*/    BSTR *pbstrRandomData
)
{
    //
    // Validate the parameters.
    //
    if (NULL == pbstrRandomData)
    {
        return E_POINTER;
    }
    else
    {
        *pbstrRandomData = NULL;
    }
    if (1 > lEffectiveByteSize || s_clMaxByteLength < lEffectiveByteSize)
    {
        return E_INVALIDARG;
    }

    //
    // Allocate the string.
    //
    long cbRawData = lEffectiveByteSize;
    long cchOutput = cbRawData * 2; // 2 characters to represent a byte

    BSTR bstrTempData = SysAllocStringLen(NULL, cchOutput);
    if (NULL == bstrTempData)
    {
        return E_OUTOFMEMORY;
    }

    if (!m_CryptRandom.get(reinterpret_cast<BYTE *>(bstrTempData), cbRawData))
    {
        SysFreeString(bstrTempData);
        return E_FAIL;
    }

    //
    // Format the string into hex output working backwards.
    //
    long iOutput = cchOutput - 2;   // Start with the last two characters.
    long iInput  = cbRawData - 1;   // Start with the last byte.
    while (-1 < iInput)
    {
        _snwprintf(&(bstrTempData[iOutput]), 2, L"%02X", 
                   reinterpret_cast<BYTE *>(bstrTempData)[iInput]);
        iOutput -= 2;   // Move to the next two characters.
        iInput--;       // Move to the next byte.
    }
                      
    *pbstrRandomData = bstrTempData;

    return S_OK;
} //*** CCryptRandomObject::GetRandomHexString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\cryptrandom.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//      CryptRandom.h
//
//  Description:
//      Header file for CCryptRandom, which is a thin wrapper class over the
//      CryptoAPI functions for generating cryptographically random strings.
//
//  Implementation File:
//      CryptRandom.cpp
//
//  Maintained By:
//      Tom Marsh (tmarsh) 12-April-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <windows.h>
#include <wincrypt.h>

class CCryptRandom
{
public:
    CCryptRandom();
    virtual ~CCryptRandom();
    BOOL get(BYTE *pbData, DWORD cbData);

private:
    HCRYPTPROV m_hProv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\cryptrandomobject.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//      CryptRandomObject.h
//
//  Description:
//      Header file for CCryptRandomObject, which implements a COM wrapper
//      to CryptGenRandom to create cryptographically random strings.
//
//  Implementation File:
//      CryptRandomObject.cpp
//
//  Maintained By:
//      Tom Marsh (tmarsh) 12-April-2002
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "resource.h"       // main symbols
#include "CryptRandom.h"    // Helper class that wraps CryptGenRandom

/////////////////////////////////////////////////////////////////////////////
// CCryptRandomObject
class ATL_NO_VTABLE CCryptRandomObject : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCryptRandomObject, &CLSID_CryptRandom>,
    public IDispatchImpl<ICryptRandom, &IID_ICryptRandom, &LIBID_COMHELPERLib>
{
public:
    CCryptRandomObject()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CRYPTRANDOM)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCryptRandomObject)
    COM_INTERFACE_ENTRY(ICryptRandom)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ICryptRandom
public:

    STDMETHOD(GetRandomHexString)(/*[in]*/             long lEffectiveByteSize,
                                  /*[out, retval]*/    BSTR *pbstrRandomData);

private:
    CCryptRandom    m_CryptRandom;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\localsetting.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      LocalSetting.h
//
//  Description:
//        This module maintains the local settings and exposes 
//        the following.
//            Properties :
//                Language (System default)
//                Time
//                TimeZone
//            Methods :
//                EnumTimeZones
//
//  Implementation Files:
//      LocalSetting.cpp
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __LOCALSETTING_H_
#define __LOCALSETTING_H_

#include "resource.h"       // main symbols
#include "Setting.h"

const int nMAX_LANGUAGE_LENGTH  = 16;
const int nMAX_TIMEZONE_LENGTH  = 256;
const int nMAX_STRING_LENGTH    = 256;
const WCHAR wszLOCAL_SETTING [] = L"System Default Language\n";
const WCHAR wszKeyNT []         = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones";

/////////////////////////////////////////////////////////////////////////////
// CLocalSetting
class ATL_NO_VTABLE CLocalSetting : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ILocalSetting, &IID_ILocalSetting, &LIBID_COMHELPERLib>,
    public CSetting
{
public:
    CLocalSetting();

    ~CLocalSetting() {}
    

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLocalSetting)
    COM_INTERFACE_ENTRY(ILocalSetting)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CLocalSetting)
END_CATEGORY_MAP()

private:
    BOOL  m_bflagReboot;
    WCHAR m_wszLanguageCurrent[ nMAX_LANGUAGE_LENGTH + 1 ];
    WCHAR m_wszLanguageNew[ nMAX_LANGUAGE_LENGTH + 1 ];
    DATE  m_dateTime;
    WCHAR m_wszTimeZoneCurrent[ nMAX_TIMEZONE_LENGTH + 1 ];
    WCHAR m_wszTimeZoneNew[ nMAX_TIMEZONE_LENGTH + 1 ];

// ILocalSetting
public:
    BOOL IsRebootRequired( BSTR * bstrWarningMessageOut );
    HRESULT Apply( void );
    STDMETHOD(EnumTimeZones)(/*[out,retval]*/ VARIANT * pvarTZones);
    STDMETHOD(get_TimeZone)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_TimeZone)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Time)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(put_Time)(/*[in]*/ DATE newVal);
    STDMETHOD(get_Language)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Language)(/*[in]*/ BSTR newVal);
//    BOOL  m_bDeleteFile;
};

typedef struct _REGTIME_ZONE_INFORMATION
{
    LONG       Bias;
    LONG       StandardBias;
    LONG       DaylightBias;
    SYSTEMTIME StandardDate;
    SYSTEMTIME DaylightDate;
}REGTIME_ZONE_INFORMATION, *PREGTIME_ZONE_INFORMATION;

#endif //__LOCALSETTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\localsetting.cpp ===
// LocalSetting.cpp : Implementation of CLocalSetting
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      LocalSetting.cpp
//
//  Description:
//      Implementation file for the CLocalSetting.  Deals with getting and setting
//      the computer's local setting such as Language, Time and TimeZone. Provides 
//		implementation for the method EnumTimeZones. 
//
//  Header File:
//      LocalSetting.h
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "COMhelper.h"
#include "LocalSetting.h"
#include <stdio.h>
#include <shellapi.h>

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::CLocalSetting
//
//  Description:
//      CLocalSetting constructor.  Initializes member variables through
//      retrieving the system default language and timezone from the system.
//
//--
//////////////////////////////////////////////////////////////////////////////

CLocalSetting::CLocalSetting()
{
	m_dateTime    = 0;
	m_bflagReboot = FALSE;
//    m_bDeleteFile = FALSE;

    wcscpy( m_wszLanguageCurrent, L"" );
    wcscpy( m_wszLanguageNew, L"");
    wcscpy( m_wszTimeZoneCurrent, L"");
    wcscpy( m_wszTimeZoneNew, L"");

} //*** CLocalSetting::CLocalSetting()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::get_Language
//
//  Description:
//      Retrieves the system default language.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CLocalSetting::get_Language( 
    BSTR * pVal 
    )
{
	// TODO: Add your implementation code here
	HRESULT hr = S_OK;
    DWORD dwError;

	try
    {
        if ( wcscmp( m_wszLanguageCurrent, L"" ) == 0 )
        {
            if ( GetLocaleInfo(
                    LOCALE_USER_DEFAULT, 
	 		        LOCALE_USE_CP_ACP|LOCALE_ILANGUAGE, 
			        m_wszLanguageCurrent, 
			        sizeof(m_wszLanguageCurrent)
                    ) == 0 )
	        {
                dwError = GetLastError();
                hr = HRESULT_FROM_WIN32( dwError );
		        throw hr;

	        } // if: GetLocaleInfo fails

            wcscpy( m_wszLanguageNew, m_wszLanguageCurrent );

        } // if: m_wszLanguageCurrent is not initialized

        *pVal = SysAllocString( m_wszLanguageNew );

        if ( *pVal == NULL )
        {

            hr = E_OUTOFMEMORY;
            throw hr;

        } // if: SysAllocString fails to allocate memory
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CLocalSetting::get_Language()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::put_Language
//
//  Description:
//      Sets the input string as system default language.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CLocalSetting::put_Language( 
    BSTR newVal 
    )
{
	// TODO: Add your implementation code here
	
    HRESULT hr = S_OK;

    try
    {
        if ( wcscmp( m_wszLanguageCurrent, L"" ) == 0 )
        {
            BSTR bstrTemp;
            hr = get_Language( &bstrTemp);

            if ( FAILED( hr ) )
		    {
			    throw hr;

		    } // if: FAILED( hr )

            SysFreeString( bstrTemp );

        } // if: m_wszLanguageCurrent is not initialized

        if ( ( wcscmp ( newVal, L"0409" ) == 0 ) || // LCID = 0409 English (US)
		     ( wcscmp ( newVal, L"040C" ) == 0 ) || // LCID = 0409 French  (Standard)
		     ( wcscmp ( newVal, L"040c" ) == 0 ) )
	    {
		    wcscpy( m_wszLanguageNew, newVal );

	    } // if: For the valid input value for newVal

	    else
	    {
            hr = E_FAIL;
		    throw hr;

	    } // else: For the invalid input value for newVal
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CLocalSetting::put_Language()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::get_Time
//
//  Description:
//      Retrieves the current system time in DATE format.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CLocalSetting::get_Time( 
    DATE * pVal 
    )
{
	// TODO: Add your implementation code here

	SYSTEMTIME sTime;
	GetLocalTime( &sTime );

    if ( !SystemTimeToVariantTime( &sTime, pVal ) )
    {
        return E_FAIL;
    }

	return S_OK;

} //*** CLocalSetting::get_Time()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::put_Time
//
//  Description:
//      Sets the time input as current system time.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CLocalSetting::put_Time( 
    DATE newVal 
    )
{
	// TODO: Add your implementation code here

	m_dateTime = newVal;
	return S_OK;

} //*** CLocalSetting::put_Time()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::get_TimeZone
//
//  Description:
//      Retrieves the current system timezone.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CLocalSetting::get_TimeZone( 
    BSTR * pVal 
    )
{
	// TODO: Add your implementation code here
    HRESULT hr = S_OK;
    DWORD dwError;
    
	try
    {
        if ( wcscmp( m_wszTimeZoneCurrent, L"" ) == 0 )
        {
            TIME_ZONE_INFORMATION tZone;

	        if ( GetTimeZoneInformation( &tZone ) == TIME_ZONE_ID_INVALID )
	        {

		        dwError = GetLastError();
                hr      = HRESULT_FROM_WIN32( dwError );
                throw hr;

	        } // if: GetTimeZoneInformation fails
	
	        wcscpy( m_wszTimeZoneCurrent, tZone.StandardName );
	        wcscpy( m_wszTimeZoneNew, tZone.StandardName );

        } // if: m_wszTimeZoneCurrent is not initialized

        *pVal = SysAllocString( m_wszTimeZoneNew );

        if( *pVal == NULL )
        {

            hr = E_OUTOFMEMORY;
            throw hr;

        } // if: SysAllocString fails to allocate memory
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

    return hr;

} //*** CLocalSetting::get_TimeZone()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::put_TimeZone
//
//  Description:
//      Sets the timezone input as current system timezone.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CLocalSetting::put_TimeZone( 
    BSTR newVal 
    )
{
	// TODO: Add your implementation code here
	
    HRESULT hr = S_OK;

	try
    {
        if ( wcscmp( m_wszTimeZoneCurrent, L"" ) == 0 )
        {
            BSTR bstrTemp;
        
            hr = get_TimeZone( &bstrTemp);
            if ( FAILED( hr ) )
		    {
			    throw hr;

		    } // if: FAILED( hr )

            SysFreeString( bstrTemp );

        } // if: m_wszTimeZoneCurrent is not initialized

		wcsncpy( m_wszTimeZoneNew, newVal, nMAX_TIMEZONE_LENGTH );
		m_wszTimeZoneNew[nMAX_TIMEZONE_LENGTH] = L'\0';
    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

	return hr;

} //*** CLocalSetting::put_TimeZone()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::EnumTimeZones
//
//  Description:
//      Enumerates the timezones.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CLocalSetting::EnumTimeZones( 
    VARIANT * pvarTZones 
    )
{
	// TODO: Add your implementation code here

	HKEY         hKey          = 0;
    HRESULT      hr            = S_OK;
    SAFEARRAY    * psa         = NULL;
    VARIANT      * varArray    = NULL;

    try
	{
		
		DWORD dwCount;
        DWORD dwError;
		DWORD dwSubKeyMaxLen;
		DWORD dwBufferLen;
	
		dwError = RegOpenKeyEx( 
                    HKEY_LOCAL_MACHINE,     // handle to open key
				    wszKeyNT,               // subkey name
				    0,                      // reserved
				    KEY_ALL_ACCESS,         // security access mask
				    &hKey                   // handle to open key
				    );

        if ( dwError != ERROR_SUCCESS ) 
		{

            ATLTRACE(L"Failed to open %s, Error = 0x%08lx\n", wszKeyNT, dwError);

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

		} // if: Could not open the registry key Time Zones

		dwError = RegQueryInfoKey(
                    hKey,               // handle to key
				    NULL,               // class buffer
				    NULL,               // size of class buffer
				    NULL,               // reserved
				    &dwCount,	        // number of subkeys
				    &dwSubKeyMaxLen,    // longest subkey name
				    NULL,               // longest class string
				    NULL,               // number of value entries
				    NULL,               // longest value name
				    NULL,               // longest value data
				    NULL,               // descriptor length
				    NULL                // last write time
				    );
		if ( dwError != ERROR_SUCCESS ) 
		{

            ATLTRACE(L"RegQueryInfoKey failed, Error = 0x%08lx\n", dwError);

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

		} // if: Could not query for the count of subkeys under the key "Timezones"
	

		VariantInit( pvarTZones );

        SAFEARRAYBOUND bounds = { dwCount, 0 };

		psa = SafeArrayCreate( VT_VARIANT, 1, &bounds );

        if ( psa == NULL )
        {
            hr = E_OUTOFMEMORY;
            throw hr;
        }
		
   		varArray = new VARIANT[ dwCount ];
		WCHAR   tszSubKey[ nMAX_TIMEZONE_LENGTH ];

		dwSubKeyMaxLen = dwSubKeyMaxLen * sizeof( WCHAR ) + sizeof( WCHAR );	
		dwBufferLen    = dwSubKeyMaxLen;

		DWORD nCount;
		for ( nCount = 0; nCount < dwCount; nCount++ ) 
		{
			dwError = RegEnumKeyEx(
                        hKey,               // handle to key to enumerate
					    nCount,             // subkey index
					    tszSubKey,          // subkey name
					    &dwBufferLen,       // size of subkey buffer
					    NULL,               // reserved
					    NULL,               // class string buffer
					    NULL,               // size of class string buffer
					    NULL                // last write time
					    );

			if ( dwError != ERROR_SUCCESS ) 
		    {

                ATLTRACE(L"RegEnumKeyEx failed, Error = 0x%08lx\n", dwError);

                hr = HRESULT_FROM_WIN32( dwError );
                throw hr;

			} // if: Could not enumerate the keys under "Timezones"

			VariantInit( &varArray[ nCount ] );
            V_VT( &varArray[ nCount ] )   = VT_BSTR;
            V_BSTR( &varArray[ nCount ] ) = SysAllocString( tszSubKey );
			dwBufferLen                   = dwSubKeyMaxLen;

            if ( &varArray[ nCount ] == NULL )
            {
                hr = E_OUTOFMEMORY;
                throw hr;
            }
		
		} // for: Enumerating nCount subkeys
		
		::RegCloseKey( hKey );

		LPVARIANT rgElems;

        hr = SafeArrayAccessData( psa, reinterpret_cast<void **>( &rgElems ) );

        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: SafeArrayAccessData failed

        for ( nCount = 0; nCount < dwCount; nCount++ )
        {
            rgElems[ nCount ] = varArray[ nCount ];
        }

        hr = SafeArrayUnaccessData( psa );

        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: SafeArrayUnaccessData failed

        delete [] varArray;

        V_VT( pvarTZones )    = VT_ARRAY | VT_VARIANT;
        V_ARRAY( pvarTZones ) = psa;

	}
	catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //
        if ( hKey != 0 )
        {
            ::RegCloseKey( hKey );
        }

        if ( varArray != NULL )
        {
            delete [] varArray;
        }

        if ( psa != NULL )
        {
            SafeArrayDestroy( psa );
        }

        return hr;
    }

	return hr;

} //*** CLocalSetting::EnumTimeZones()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::Apply
//
//  Description:
//      None of the property changes for the CLocalSetting object take effect
//      until this Apply function is called.
//
//--
//////////////////////////////////////////////////////////////////////////////

HRESULT 
CLocalSetting::Apply( void )
{

	HKEY    hKey             = 0;
	HKEY    hSubKey          = 0;
    HRESULT hr               = S_OK;
    DWORD   dwSize           = sizeof (REGTIME_ZONE_INFORMATION);
    DWORD   dwSizeName;
    DWORD   dwError;
    DWORD   dwCount;
	DWORD   dwSubKeyMaxLen;
	DWORD   dwBufferLen;
    WCHAR   tszSubKey  [ nMAX_TIMEZONE_LENGTH ];
    WCHAR   tszStdName [ nMAX_STRING_LENGTH ];
	WCHAR   tszDltName [ nMAX_STRING_LENGTH ];

    try
	{

        TIME_ZONE_INFORMATION      tZone;
	    REGTIME_ZONE_INFORMATION   tZoneReg;
		//
		//	Applying the Language property
		//

		if ( wcscmp( m_wszLanguageCurrent, m_wszLanguageNew ) != 0)
		{
			FILE  * stream;
			WCHAR tszLang[] = L"Language";

			if ( ( stream = _wfopen ( L"unattend.txt", L"w+" ) ) == NULL)
			{

				hr = E_FAIL;
                throw hr;

			} // if: Could not open the file C:\unattend.txt

            fwprintf( stream, L"[RegionalSettings]\n" );
			fwprintf( 
                stream, 
				L"%s = \"%08s\"", 
				tszLang, 
				m_wszLanguageNew 
                );

//			m_bDeleteFile = TRUE;
            fclose( stream );

			//
			//		rundll32 shell32,Control_RunDLL intl.cpl,,/f:"c:\unattend.txt"
			//

			int nTemp;
			if ( ( nTemp = (int) ShellExecute(
                NULL,
				L"open",
				L"rundll32.exe",
				L"shell32,Control_RunDLL intl.cpl,,/f:\".\\unattend.txt\"",
				NULL,
				0 
                ) ) <= 32 )
			{

				dwError = GetLastError();
                hr      = HRESULT_FROM_WIN32( dwError );
                throw hr;

			} // if: ShellExecute fails to spawn the process

			wcscpy( m_wszLanguageCurrent, m_wszLanguageNew );

			m_bflagReboot = TRUE;

		} // if: m_wszLanguageCurrent is not same as m_wszLanguageNew

		//
		// Applying the Time property
		//

		if ( m_dateTime != 0 )
		{

			SYSTEMTIME sTime;
			VariantTimeToSystemTime( m_dateTime, &sTime );
			if ( !SetLocalTime( &sTime ) )
            {
                dwError = GetLastError();
                hr      = HRESULT_FROM_WIN32( dwError );
                throw hr;

            } // if: SetLocalTime fails

		} // if m_dateTime is set 

		//
		//	Applying the TimeZone property
		//

		if ( wcscmp( m_wszTimeZoneCurrent, m_wszTimeZoneNew ) != 0)
		{

            dwError = RegOpenKeyEx( 
                        HKEY_LOCAL_MACHINE,     // handle to open key
					    wszKeyNT,               // subkey name
					    0,                      // reserved
					    KEY_ALL_ACCESS,         // security access mask
					    &hKey                   // handle to open key
					    );

			if ( dwError != ERROR_SUCCESS ) 
		    {

                ATLTRACE(L"Failed to open %s, Error = 0x%08lx\n", wszKeyNT, dwError);

                hr = HRESULT_FROM_WIN32( dwError );
                throw hr;

			} // if: Could not open the registry key Time Zones

            // latest addition ******

            dwError = RegQueryInfoKey(
                    hKey,               // handle to key
				    NULL,               // class buffer
				    NULL,               // size of class buffer
				    NULL,               // reserved
				    &dwCount,	        // number of subkeys
				    &dwSubKeyMaxLen,    // longest subkey name
				    NULL,               // longest class string
				    NULL,               // number of value entries
				    NULL,               // longest value name
				    NULL,               // longest value data
				    NULL,               // descriptor length
				    NULL                // last write time
				    );
		    if ( dwError != ERROR_SUCCESS ) 
		    {

                ATLTRACE(L"RegQueryInfoKey failed, Error = 0x%08lx\n", dwError);

                hr = HRESULT_FROM_WIN32( dwError );
                throw hr;

		    } // if: Could not query for the count of subkeys under the key "Timezones"

            dwSubKeyMaxLen = dwSubKeyMaxLen * sizeof( WCHAR ) + sizeof( WCHAR );	

		    DWORD nCount;
		    for ( nCount = 0; nCount < dwCount; nCount++ ) 
		    {
			    dwBufferLen    = dwSubKeyMaxLen;

                dwError = RegEnumKeyEx(
                            hKey,               // handle to key to enumerate
					        nCount,             // subkey index
					        tszSubKey,          // subkey name
					        &dwBufferLen,       // size of subkey buffer
					        NULL,               // reserved
					        NULL,               // class string buffer
					        NULL,               // size of class string buffer
					        NULL                // last write time
					        );

			    if ( dwError != ERROR_SUCCESS ) 
		        {

                    ATLTRACE(L"RegEnumKeyEx failed, Error = 0x%08lx\n", dwError);

                    hr = HRESULT_FROM_WIN32( dwError );
                    throw hr;

			    } // if: Could not enumerate the keys under "Timezones"

                dwError = RegOpenKeyEx(
                            hKey, 
					        tszSubKey, 
					        0, 
					        KEY_ALL_ACCESS, 
					        &hSubKey
					        );

			    if ( dwError != ERROR_SUCCESS ) 
		        {

                    ATLTRACE(L"Failed to open %s, Error = 0x%08lx\n", tszSubKey, dwError);

                    hr = HRESULT_FROM_WIN32( dwError );
                    throw hr;

			    } // if: Could not open the registry key under Time Zones

                dwSizeName = nMAX_STRING_LENGTH * 2 + 2;

                dwError = RegQueryValueEx(
                        hSubKey,                                
					    L"Std",                                 
					    NULL, 
					    NULL,
					    reinterpret_cast<LPBYTE>( tszStdName ), 
					    &dwSizeName
					    );

			    if ( dwError != ERROR_SUCCESS ) 
		        {

                    ATLTRACE(L"RegQueryValueEx failed to open Std, Error = 0x%08lx\n", dwError);

                    hr = HRESULT_FROM_WIN32( dwError );
                    throw hr;

			    } // if: Could not query the value of Name "Std"
            
                if ( _wcsicmp( tszStdName, m_wszTimeZoneNew ) == 0 )
                {

			        dwError = RegQueryValueEx(
                                hSubKey,                                // handle to key
					            L"TZI",                                 // value name
					            NULL,                                   // reserved
					            NULL,                                   // type buffer
					            reinterpret_cast<LPBYTE>( &tZoneReg ),  // data buffer
					            &dwSize                                 // size of data buffer
					            );

			        if ( dwError != ERROR_SUCCESS ) 
		            {

                        ATLTRACE(L"RegQueryValueEx failed to open TZI, Error = 0x%08lx\n", dwError);

                        hr = HRESULT_FROM_WIN32( dwError );
                        throw hr;

			        } // if: Could not query the value of Name "TZI"

			        dwSizeName = nMAX_STRING_LENGTH * 2 + 2;

                    dwError = RegQueryValueEx(
                                hSubKey, 
					            L"Dlt", 
					            NULL, 
					            NULL,
					            reinterpret_cast<LPBYTE>( tszDltName ), 
					            &dwSizeName
					            );

			        if ( dwError != ERROR_SUCCESS ) 
		            {

                        ATLTRACE(L"RegQueryValueEx failed to open Dlt, Error = 0x%08lx\n", dwError);

                        hr = HRESULT_FROM_WIN32( dwError );
                        throw hr;

			        } // if: Could not query the value of Name "Dlt"

			        tZone.Bias         = tZoneReg.Bias;
			        tZone.StandardBias = tZoneReg.StandardBias;
			        tZone.DaylightBias = tZoneReg.DaylightBias;
			        tZone.StandardDate = tZoneReg.StandardDate;
			        tZone.DaylightDate = tZoneReg.DaylightDate;

			        wcscpy( tZone.StandardName, tszStdName );
			        wcscpy( tZone.DaylightName, tszDltName );
	        
			        if ( !SetTimeZoneInformation( &tZone ) ) 
			        {

				        dwError = GetLastError();
                        hr      = HRESULT_FROM_WIN32( dwError );
                        throw hr;

			        } // if: Could not set the Time Zone information

                    ::RegCloseKey( hSubKey );
			        ::RegCloseKey( hKey );

			        wcscpy( m_wszTimeZoneCurrent, m_wszTimeZoneNew );

                    break;

                } // if: tszStdName == m_wszTimeZoneNew

                ::RegCloseKey( hSubKey );

            } // for: each nCount
        
            if ( ( nCount < ( dwCount - 1 ) ) && (hSubKey != 0 ) )
            {
                
                ::RegCloseKey( hSubKey );

            }

            ::RegCloseKey( hKey );

        } // if: m_wszTimeZoneCurrent != m_wszTimeZoneNew
        
    }    
            
    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        if ( hSubKey != 0 ) 
        {
            ::RegCloseKey( hSubKey );

        } // if: hSubKey is not closed

        if ( hKey != 0 )
        {
            ::RegCloseKey( hKey );

        } // if: hKey is not closed

        return hr;
    }

	return hr;

} //*** CLocalSetting::Apply()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CLocalSetting::IsRebootRequired
//
//  Description:
//      Determines whether system needs rebooting to take effect of any
//		property change and if so, gives out the warning message as 
//		a reason for the reboot.
//
//--
//////////////////////////////////////////////////////////////////////////////

BOOL 
CLocalSetting::IsRebootRequired( 
    BSTR * bstrWarningMessageOut 
    )
{

	BOOL bFlag             = FALSE;
	*bstrWarningMessageOut = NULL;

	if ( m_bflagReboot )
	{
		bFlag                  = m_bflagReboot;
		*bstrWarningMessageOut = SysAllocString( wszLOCAL_SETTING );

	} // if: m_bflagReboot is set as TRUE

	else if ( wcscmp( m_wszLanguageCurrent, m_wszLanguageNew ) != 0 )
	{

		bFlag                  = TRUE;
		*bstrWarningMessageOut = SysAllocString( wszLOCAL_SETTING );

	} // else if: m_wszLanguageCurrent is not same as m_wszLanguageNew
		
	return bFlag;

} //*** CLocalSetting::IsRebootRequired()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\netcfg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      netcfg.cpp
//
//  Description:
//
//
//  Header File:
//      netcfg.h
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "netcfg.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetCfg::CNetCfg
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
CNetCfg::CNetCfg( bool bLockNetworkSettingsIn )
{

    HRESULT hr;
    DWORD   dwStartTime;
    DWORD   dwCurrentTime;
    LPWSTR  pszwClientDescr  = NULL;
    INetCfgPtr  pTempNetCfg  = NULL;

    hr = CoCreateInstance( CLSID_CNetCfg, 
                           NULL, 
                           CLSCTX_INPROC_SERVER,
                           IID_INetCfg, 
                           reinterpret_cast<void **>(&m_pNetCfg) );

    if( FAILED( hr ) )
    {
        ATLTRACE( L"InitializeNetCfg : CoCreateInstance on CLSID_CNetCfg failed with hr 0x%x.", hr );

        throw hr;
    }

//    m_pNetCfg = pTempNetCfg;

    //
    //  Lock the Network settings for writing
    //

    //
    // Retrieve the write lock for this INetCfg object
    //

    if( bLockNetworkSettingsIn )
    {

        hr = m_pNetCfg->QueryInterface( IID_INetCfgLock, 
                                        reinterpret_cast<void **>(&m_pNetCfgLock) );

        if( FAILED( hr ) )
        {
            ATLTRACE( L"InitializeNetCfg : QueryInterface for INetCfgLock failed with 0x%x.", hr );

            throw hr;
        }

        dwStartTime = GetTickCount();

        dwCurrentTime = dwStartTime;

        hr = S_FALSE;

        while( ( dwCurrentTime - dwStartTime <= nTIMEOUT_PERIOD ) &&
               ( S_OK != hr ) && ( E_ACCESSDENIED != hr ) )
        {
            hr = m_pNetCfgLock->AcquireWriteLock( 1000, L"Server Appliance", &pszwClientDescr );

            dwCurrentTime = GetTickCount();
        }

        if( S_FALSE == hr )
        {
               ATLTRACE( L"InitializeNetCfg: The network lock could not be obtained." );

            throw hr;
        }

        if( FAILED( hr ) )
        {
            ATLTRACE( L"InitializeNetCfg : AcquireWriteLock failed with 0x%x.", hr );

            throw hr;
        }

    }

    //
    // Initialize the INetCfg object
    //

    hr = m_pNetCfg->Initialize( NULL );

    if( FAILED( hr ) )
    {
        ATLTRACE( L"InitializeNetCfg : Initialize failed with 0x%x!", hr );

        //
        //  Only unlock if we have locked it
        //

        if( bLockNetworkSettingsIn )
        {
            m_pNetCfgLock->ReleaseWriteLock();
        }

        throw hr;
    }

}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetCfg::CNetCfg
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
CNetCfg::CNetCfg( const CNetCfg &NetCfgOld )
{

    m_pNetCfg = NetCfgOld.m_pNetCfg;

    m_pNetCfgLock = NetCfgOld.m_pNetCfgLock;

}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetCfg::~CNetCfg
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
CNetCfg::~CNetCfg()
{

    if( m_pNetCfg != NULL )
    {
        ATLTRACE( L"m_pNetCfg is NULL when it should always have a valid ptr" );
    }

    if( m_pNetCfgLock != NULL )
    {
        ATLTRACE( L"m_pNetCfgLock is NULL when it should always have a valid ptr" );
    }


    if( m_pNetCfg != NULL )
    {
        m_pNetCfg->Uninitialize();
    }

    if( m_pNetCfgLock != NULL )
    {
        m_pNetCfgLock->ReleaseWriteLock();
    }

}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetCfg::GetNetCfgClass
//
//  Description:
//      Retrieves INetCfgClass for the specified pGuid
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CNetCfg::GetNetCfgClass( 
    const GUID* pGuid,              //  pointer to GUID representing the class of components represented by the returned pointer
    INetCfgClassPtr &pNetCfgClass
    ) const
{

    HRESULT hr;

    hr = m_pNetCfg->QueryNetCfgClass( pGuid, 
                                      IID_INetCfgClass, 
                                      reinterpret_cast<void **>(&pNetCfgClass) );

    if( FAILED( hr ) )
    {
        ATLTRACE( L"CNetCfg::GetNetCfgClass : m_pNetCfg->QueryNetCfgClass() failed with hr 0x%x.", hr );

        return( hr );
    }

    return S_OK;

}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetCfg::InitializeComInterface
//
//  Description:
//      Obtains the INetCfgClass interface and enumerates all the 
//      components.  Handles cleanup of all interfaces if failure
//      returned.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CNetCfg::InitializeComInterface( 
    const GUID *pGuid,                                        //  pointer to GUID representing the class of components represented by the returned pointer
    INetCfgClassPtr pNetCfgClass,                             //  output parameter pointing to the interface requested by the GUID
    IEnumNetCfgComponentPtr pEnum,                            //  output param that points to an IEnumNetCfgComponent to get to each individual INetCfgComponent
    INetCfgComponentPtr arrayComp[nMAX_NUM_NET_COMPONENTS],   //  array of all the INetCfgComponents that correspond to the the given GUID
    ULONG* pCount                                             //  the number of INetCfgComponents in the array
    ) const
{

    HRESULT hr = S_OK;

    //
    // Obtain the INetCfgClass interface pointer
    //

    GetNetCfgClass( pGuid, pNetCfgClass );

    //
    // Retrieve the enumerator interface
    //

    hr = pNetCfgClass->EnumComponents( &pEnum );

    if( FAILED( hr ) )
    {
        ATLTRACE( L"CNetCfg::InitializeComInterface : pNetCfgClass->EnumComponents() failed with hr 0x%x.", hr );

        return( hr );
    }

    
    hr = pEnum->Next( nMAX_NUM_NET_COMPONENTS, &arrayComp[0], pCount );

    if( FAILED( hr ) )
    {
        ATLTRACE( L"CNetCfg::InitializeComInterface : pEnum->Next() failed with hr 0x%x.", hr );

        return( hr );
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\networktools.h ===
#ifndef __NETWORKTOOLS_H_
#define __NETWORKTOOLS_H_

#include "resource.h"       // main symbols

class ATL_NO_VTABLE CNetworkTools : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CNetworkTools, &CLSID_NetworkTools>,
    public IDispatchImpl<INetworkTools, &IID_INetworkTools, &LIBID_COMHELPERLib>
{
public:
    CNetworkTools()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_NETWORKTOOLS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNetworkTools)
    COM_INTERFACE_ENTRY(INetworkTools)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    STDMETHOD(Ping)(/*[in]*/ BSTR bstrIP, BOOL* pbFoundSystem);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\networks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      networks.cpp
//
//  Description:
//      Implementation file for the CNetWorks.  Allows the user to obtain
//      info about Network cards and protocols and to change protocols bound
//      to network cards.
//
//  Header File:
//      networks.h
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

// NetWorks.cpp : Implementation of CNetWorks
#pragma warning( disable : 4786 )
#include "stdafx.h"
#include "COMhelper.h"
#include "NetWorks.h"
#include "devguid.h"
#include "netcfgx.h"
#include "netcfg.h"
#include <vector>

EXTERN_C const CLSID CLSID_CNetCfg =  {0x5B035261,0x40F9,0x11D1,{0xAA,0xEC,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

/////////////////////////////////////////////////////////////////////////////
// CNetWorks

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetWorks::EnumNics
//
//  Description:
//      Determines how many physical network cards are in the current system
//      and returns their friendly names in the pvarNicNames array.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CNetWorks::EnumNics( 
    VARIANT * pvarNicNames 
    )
{

    SAFEARRAY * psaNicNames      = NULL;
    VARIANT   * varNicNamesArray = NULL;
    HRESULT   hr                 = S_OK;

    try
    {

        unsigned int             i                   = 0;
        ULONG                    iCount              = 0;
		ULONG                    ulStatus            = 0;
		DWORD                    dwCharacteristics   = 0;
		WCHAR                    * pszDisplayName    = NULL;
        IEnumNetCfgComponentPtr  pEnum               = NULL;
        INetCfgClassPtr          pNetCfgClass        = NULL;
        INetCfgComponentPtr      pNetCfgComp         = NULL;
        INetCfgComponentPtr      arrayComp[nMAX_NUM_NET_COMPONENTS];
        std::vector<CComBSTR>    vecNetworkCardNames;
        CNetCfg                  NetCfg( false );


        hr = NetCfg.InitializeComInterface( &GUID_DEVCLASS_NET,
                                            pNetCfgClass,
                                            pEnum,
                                            arrayComp,
                                            &iCount
                                            );

        if( FAILED( hr ) )
        {
            ATLTRACE( L"EnumNics : InitializeComInterface failed with hr 0x%x.", hr );

            throw hr;

        } // if: FAILED( hr )

        for( i = 0; i < iCount; i++ )
        {

            pNetCfgComp = arrayComp[i];

            hr = pNetCfgComp->GetCharacteristics( &dwCharacteristics );

            if( FAILED( hr ) )
            {
                ATLTRACE( L"EnumNics : pNetCfgComp->GetCharacteristics failed with hr 0x%x.", hr );

                throw hr;

            } // if: FAILED( hr )

            //
            //  If this is a physical adapter
            //

            if( dwCharacteristics & NCF_PHYSICAL )  
            {
                //
                //  Get the display name for this adapter
                //

                hr = pNetCfgComp->GetDisplayName( &pszDisplayName );

                if( FAILED( hr ) )
                {
                    ATLTRACE( L"EnumNics : pNetCfgComp->GetDisplayName() failed with hr 0x%x.", hr );
                
                    throw hr;

                } // if: FAILED( hr )
                
                //
                //  For filtering out the phantom net cards, check the return value of 
                //  INetCfgComponent::GetDeviceStatus method
                //
                
                hr = pNetCfgComp->GetDeviceStatus( &ulStatus);

                if ( SUCCEEDED( hr ) )
                {
                    vecNetworkCardNames.push_back( CComBSTR( pszDisplayName ) );

                } // if: SUCCEEDED( hr )

                if( pszDisplayName )
                {
                    CoTaskMemFree( pszDisplayName );

                    pszDisplayName = NULL;

                } // if: pszDisplayName is true

            } // if: dwCharacteristics & NCF_PHYSICAL is true

        } // for: each i

        //
        //  Move all the elements of the vector into the SAFEARRAY
        //


        varNicNamesArray = new VARIANT[ vecNetworkCardNames.size() ];

        VariantInit( pvarNicNames );

        SAFEARRAYBOUND bounds = { vecNetworkCardNames.size(), 0 };
        psaNicNames           = SafeArrayCreate( VT_VARIANT, 1, &bounds );

        if ( psaNicNames == NULL ) 
        {
            hr = E_OUTOFMEMORY;
            throw hr;
        }

        std::vector<CComBSTR>::iterator iter;

        for( i = 0, iter = vecNetworkCardNames.begin();
             iter != vecNetworkCardNames.end();
             i++, iter++ )
        {
            VariantInit( &varNicNamesArray[ i ] );
            V_VT( &varNicNamesArray[ i ] )   = VT_BSTR;
            V_BSTR( &varNicNamesArray[ i ] ) = SysAllocString( (*iter).m_str);

            if ( &varNicNamesArray[ i ] == NULL )
            {
                hr = E_OUTOFMEMORY;
                throw hr;
            }

        } // for: each i
        
        LPVARIANT rgElems;
        hr = SafeArrayAccessData( psaNicNames, reinterpret_cast<void **>( &rgElems ) );
        
        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: SafeArrayAccessData failed

        for( i = 0, iter = vecNetworkCardNames.begin();
             iter != vecNetworkCardNames.end();
             i++, iter++ )
        {
            rgElems[i] = varNicNamesArray[ i ];

        } // for: each i

        hr = SafeArrayUnaccessData( psaNicNames );
        
        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: SafeArrayUnaccessData failed
        
        delete [] varNicNamesArray;

        V_VT( pvarNicNames )    = VT_ARRAY | VT_VARIANT;
        V_ARRAY( pvarNicNames ) = psaNicNames;

    }
    
    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //
        if ( varNicNamesArray != NULL )
        {
            delete [] varNicNamesArray;
        }

        if ( psaNicNames != NULL ) 
        {
            SafeArrayDestroy( psaNicNames );
        }

        return hr;
    }

	return hr;

} //*** CNetWorks::EnumNics()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetWorks::EnumProtocol
//
//  Description:
//      Determines what protocols are bound to the netword card given by the
//      first parameter.  pvarProtocolName and pvarIsBonded are parallel
//      arrays that for each protocol in pvarProtocolName, pvarIsBonded has
//      a bool for it that protocol is bounded or not.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNetWorks::EnumProtocol(
    BSTR      Name,
    VARIANT * pvarProtocolName,
    VARIANT * pvarIsBonded
    )
{
    
    SAFEARRAY * psaProtocolArray = NULL;
    SAFEARRAY * psaIsBondedArray = NULL;
    VARIANT   * varProtocolArray = NULL;
    VARIANT   * varIsBondedArray = NULL;
    HRESULT   hr                 = S_OK;

    try
    {

        int                      i                   = 0;
        INetCfgComponentPtr      pnccNetworkAdapter  = NULL;
        INetCfgComponentPtr      pnccProtocol        = NULL;
		BOOL                     bProtocolBound      = FALSE;
        std::vector<BOOL>        vecProtocolBonded;
        CNetCfg                  NetCfg( false );


        hr = GetNetworkCardInterfaceFromName( NetCfg, Name, pnccNetworkAdapter );

        if( FAILED( hr ) )
        {
            ATLTRACE( L"EnumProtocol : GetNetworkCardInterfaceFromName failed with hr 0x%x.", hr );

            throw hr;

        } // if: FAILED( hr )


        for( i = 0; i < nNUMBER_OF_PROTOCOLS; i++ )
        {

            hr = NetCfg.HrFindComponent( rgProtocolNames[i], &pnccProtocol );

            if( FAILED( hr ) )
            {
                ATLTRACE( L"EnumProtocol : HrFindComponent failed with hr 0x%x.", hr );

                throw hr;

            } // if: FAILED( hr )

            //
            //  If it is not installed, then it is definitely not bound
            //

            if( hr == S_FALSE )
            {
                bProtocolBound = FALSE;

            } // if: hr == S_FALSE

            else
            {

                INetCfgComponentBindingsPtr pncb;

                hr = pnccProtocol->QueryInterface( IID_INetCfgComponentBindings,
                                                   reinterpret_cast<void **>( &pncb ) );

                if( FAILED( hr ) )
                {
                    ATLTRACE( L"EnumProtocol : pnccProtocol->QueryInterface() failed with hr 0x%x.", hr );

                    throw hr;

                } // if: FAILED( hr )

                hr = pncb->IsBoundTo( pnccNetworkAdapter );

                if( FAILED( hr ) )
                {
                    ATLTRACE( L"EnumProtocol : pnccProtocol->IsBoundTo() failed with hr 0x%x.", hr );

                    throw hr;

                } // if: FAILED( hr )

                if( S_OK == hr )
                {
                    bProtocolBound = TRUE;

                } // if: S_OK == hr

                else if( S_FALSE == hr )
                {
                    bProtocolBound = FALSE;

                } // else if: S_FALSE == hr

                else
                {
                    ATLTRACE( L"EnumProtocol : Unknown return value from pnccProtocol->IsBoundTo()" );

                    bProtocolBound = FALSE;

                } // else: Unknown return value

            } // else: hr == S_OK

            vecProtocolBonded.push_back( bProtocolBound );

        } // for: each i

        //
        //  Copy rgProtocolNames and vecProtocolBonded over to the SAFEARRAYs for output
        //

        //
        //  Move all the elements of the vector into the SAFEARRAY
        //

        varProtocolArray = new VARIANT[ vecProtocolBonded.size() ];
        varIsBondedArray = new VARIANT[ vecProtocolBonded.size() ];

        VariantInit( pvarProtocolName );
        VariantInit( pvarIsBonded );

        SAFEARRAYBOUND sabProtocol = { vecProtocolBonded.size(), 0 };
        SAFEARRAYBOUND sabIsBonded = { vecProtocolBonded.size(), 0 };

        psaProtocolArray = SafeArrayCreate( VT_VARIANT, 1, &sabProtocol );

        if ( psaProtocolArray == NULL )
        {
            hr = E_OUTOFMEMORY;
            throw hr;
        }

        psaIsBondedArray = SafeArrayCreate( VT_VARIANT, 1, &sabIsBonded );

        if ( psaIsBondedArray == NULL )
        {
            hr = E_OUTOFMEMORY;
            throw hr;
        }

        std::vector<BOOL>::iterator iter;

        for( i = 0, iter = vecProtocolBonded.begin();
             iter != vecProtocolBonded.end();
             i++, iter++ )
        {
            VariantInit( &varProtocolArray[ i ] );
            V_VT( &varProtocolArray[ i ] )   = VT_BSTR;
            V_BSTR( &varProtocolArray[ i ] ) = SysAllocString( rgProtocolNames[i] );

            if ( &varProtocolArray[ i ] ==  NULL )
            {
                hr = E_OUTOFMEMORY;
                throw hr;
            }

            VariantInit( &varIsBondedArray[ i ] );
            V_VT( &varIsBondedArray[ i ] )   = VT_BOOL;
            V_BOOL( &varIsBondedArray[ i ] ) = (VARIANT_BOOL) (*iter);

            if ( &varIsBondedArray[ i ] == NULL )
            {
                hr = E_OUTOFMEMORY;
                throw hr;
            }


        } // for: each i, iter

        
        LPVARIANT rgElemProtocols;
        LPVARIANT rgElemIsBonded;

        hr = SafeArrayAccessData( 
                psaProtocolArray, 
                reinterpret_cast<void **>( &rgElemProtocols ) 
                );
        
        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: SafeArrayAccessData failed
        
        hr = SafeArrayAccessData( 
                psaIsBondedArray, 
                reinterpret_cast<void **>( &rgElemIsBonded ) 
                );
        
        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: SafeArrayAccessData failed
        

        for( i = 0, iter = vecProtocolBonded.begin();
             iter != vecProtocolBonded.end();
             i++, iter++ )
        {
        
            rgElemProtocols[ i ] = varProtocolArray[ i ];
            rgElemIsBonded[ i ]  = varIsBondedArray[ i ];

        } // for: each i, iter

        hr = SafeArrayUnaccessData( psaProtocolArray );

        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: SafeArrayUnaccessData failed

        hr = SafeArrayUnaccessData( psaIsBondedArray );

        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: SafeArrayUnaccessData failed

        delete [] varProtocolArray;
        delete [] varIsBondedArray;

        V_VT( pvarProtocolName )    = VT_ARRAY | VT_VARIANT;
        V_ARRAY( pvarProtocolName ) = psaProtocolArray;
        
        V_VT( pvarIsBonded )    = VT_ARRAY | VT_VARIANT;
        V_ARRAY( pvarIsBonded ) = psaIsBondedArray;

    }
    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //
        if ( varProtocolArray != NULL )
        {
            delete [] varProtocolArray;
        }

        if ( varIsBondedArray != NULL )
        {
            delete [] varIsBondedArray;
        }

        if ( psaProtocolArray != NULL )
        {
            SafeArrayDestroy( psaProtocolArray );
        }

        if ( psaIsBondedArray != NULL )
        {
            SafeArrayDestroy( psaIsBondedArray );
        }

        return hr;
    }

	return hr;

} //*** CNetWorks::EnumProtocol()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetWorks::SetNicProtocol
//
//  Description:
//      If the bind parameter is set to TRUE, the protocol given is bound to
//      the network card given.  If the bind parameter is FALSE, then the
//      protocol is unbound from the network card given.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CNetWorks::SetNicProtocol(
    BSTR NicName,
    BSTR ProtocolName,
    BOOL bind
    )
{
    HRESULT hr = S_OK;

    try
    {

        int                  i                   = 0;
        INetCfgComponentPtr  pnccProtocol        = NULL;
        INetCfgComponentPtr  pnccNetworkAdapter  = NULL;
        CNetCfg              NetCfg( true );

        //
        //  Make sure they specified a valid protocol
        //

        for( i = 0; i < nNUMBER_OF_PROTOCOLS; i++ )
        {
            if( _wcsicmp( ProtocolName, rgProtocolNames[i] ) == 0 )
            {
                break;

            } // if: ProtocolName == rgProtocolNames[i]

        } // for: each i

        if( i == nNUMBER_OF_PROTOCOLS )
        {
            hr = E_INVALIDARG;
            throw hr;

        } // if: i == nNUMBER_OF_PROTOCOLS


        hr = GetNetworkCardInterfaceFromName( NetCfg, NicName, pnccNetworkAdapter );

        if( FAILED( hr ) )
        {
            ATLTRACE( L"SetNicProtocol : GetNetworkCardInterfaceFromName failed with hr 0x%x.", hr );

            throw hr;

        } // if: FAILED( hr )

        hr = NetCfg.HrFindComponent( rgProtocolNames[i], &pnccProtocol );

        if( FAILED( hr ) )
        {
            ATLTRACE( L"SetNicProtocol : HrFindComponent failed with hr 0x%x.", hr );

            throw hr;

        } // if: FAILED( hr )


        INetCfgComponentBindingsPtr pncb;

        hr = pnccProtocol->QueryInterface( IID_INetCfgComponentBindings,
                                           reinterpret_cast<void **>( &pncb ) );

        if( FAILED( hr ) )
        {
            ATLTRACE( L"SetNicProtocol : pnccProtocol->QueryInterface() failed with hr 0x%x.", hr );

            throw hr;

        } // if: FAILED( hr )

        hr = pncb->IsBoundTo( pnccNetworkAdapter );

        if( FAILED( hr ) )
        {
            ATLTRACE( L"SetNicProtocol : pnccProtocol->IsBoundTo() failed with hr 0x%x.", hr );

            throw hr;

        } // if: FAILED( hr )


        //
        //  If the protocol is bound and we are supposed to unbind it, then unbind it.
        //

        if( ( hr == S_OK ) && ( bind == FALSE ) )
        {

            hr = pncb->UnbindFrom( pnccNetworkAdapter );

            if( FAILED( hr ) )
            {
                ATLTRACE( L"SetNicProtocol : pncb->UnbindFrom() failed with hr 0x%x.", hr );

                throw hr;

            } // if: FAILED( hr )

			hr = NetCfg.HrApply();

			if ( FAILED( hr ) )
			{
				ATLTRACE( L"CNetCfg::HrApply method fails with 0x%x \n", hr );
				
				throw hr;

			} // if: FAILED( hr )

        } // if: ( hr == S_OK ) && ( bind == FALSE )

        else if( ( hr == S_FALSE ) && ( bind == TRUE ) )
        {
            //
            //  If the protocol is not bound and we are supposed to bind it, then bind it.
            //

            hr = pncb->BindTo( pnccNetworkAdapter );

            if( FAILED( hr ) )
            {
                ATLTRACE( L"SetNicProtocol : pncb->BindTo() failed with hr 0x%x.", hr );

                throw hr;

            } // if: FAILED( hr )

			hr = NetCfg.HrApply();

			if ( FAILED( hr ) )
			{
				ATLTRACE( L"CNetCfg::HrApply method fails with 0x%x \n", hr );
				
				throw hr;

			} // if: FAILED( hr )

        } // else if: ( hr == S_FALSE ) && ( bind == TRUE )

    }
    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }

	return hr;

} //*** CNetWorks::SetNicProtocol()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetWorks::GetNetworkCardInterfaceFromName
//
//  Description:
//      From a friendly name for a network card, determines the INetCfgComponent
//      that corresponds to it.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CNetWorks::GetNetworkCardInterfaceFromName(
    const CNetCfg &       NetCfgIn,
    BSTR                  Name,
    INetCfgComponentPtr & pnccNetworkAdapter
    )
{
    HRESULT hr               = S_OK;
    WCHAR   * pszDisplayName = NULL;
    
    try
    {
        int                      i                   = 0;
        ULONG                    iCount              = 0;
		DWORD                    dwCharacteristics   = 0;
        IEnumNetCfgComponentPtr  pEnum               = NULL;
        INetCfgClassPtr          pNetCfgClass        = NULL;
		INetCfgComponentPtr      pNetCfgComp         = NULL;
        INetCfgComponentPtr      arrayComp[nMAX_NUM_NET_COMPONENTS];


        hr = NetCfgIn.InitializeComInterface( &GUID_DEVCLASS_NET,
                                              pNetCfgClass,
                                              pEnum,
                                              arrayComp,
                                              &iCount
                                              );

        if( FAILED( hr ) )
        {
            ATLTRACE( L"GetNetworkCardInterfaceFromName : InitializeComInterface failed with hr 0x%x.", hr );

            throw hr;

        } // if: FAILED( hr )


        for( i = 0; i < iCount; i++ )
        {

            pNetCfgComp = arrayComp[i];

            hr = pNetCfgComp->GetCharacteristics( &dwCharacteristics );

            if( FAILED( hr ) )
            {
                ATLTRACE( L"EnumNics : pNetCfgComp->GetCharacteristics failed with hr 0x%x.", hr );

                throw hr;

            } // if: FAILED( hr )

            //
            //  If this is a physical adapter
            //

            if( dwCharacteristics & NCF_PHYSICAL )
            {
                //
                //  Get the display name for this adapter
                //

                hr = pNetCfgComp->GetDisplayName( &pszDisplayName );

                if( FAILED( hr ) )
                {
                    ATLTRACE( L"EnumNics : pNetCfgComp->GetDisplayName() failed with hr 0x%x.", hr );
        
                    throw hr;

                } // if: FAILED( hr )

                if( _wcsicmp( pszDisplayName, Name ) == 0 )
                {

//                    pnccNetworkAdapter = pNetCfgComp;  // i add this change

                    hr = pNetCfgComp->QueryInterface( & pnccNetworkAdapter );

                    if ( FAILED( hr ) )
                    {
                        ATLTRACE( L"**** QI failed for pnccNetworkAdapter \n" );
                        throw hr;
                    }

                    CoTaskMemFree( pszDisplayName );
                    break;

                } // if: pszDisplayName == Name

                if( pszDisplayName )
                {
                    CoTaskMemFree( pszDisplayName );

                    pszDisplayName = NULL;

                } // if: pszDisplayName != NULL

            } // if: dwCharacteristics & NCF_PHYSICAL are true

        } // for: each i

    }

    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        if( pszDisplayName )
        {
            CoTaskMemFree( pszDisplayName );

            pszDisplayName = NULL;

        } // if: pszDisplayName != NULL

        return hr;
    }

	return hr;

} //*** CNetWorks::GetNetworkCardInterfaceFromName()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetWorks::Apply
//
//  Description:
//      INetWorks does not expose any properties, but exposes only methods.
//      Since Apply function is meant for applying the property changes, it
//      returns S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT CNetWorks::Apply( void )
{
	return S_OK;

} //*** CNetWorks::Apply()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetWorks::IsRebootRequired
//
//  Description:
//      INetWorks does not expose any properties, but exposes only methods.
//      Since there is no property changes to take effect of, it returns false
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL CNetWorks::IsRebootRequired(
    BSTR * bstrWarningMessageOut
    )
{
	*bstrWarningMessageOut = NULL;
	return FALSE;

} //*** CNetWorks::IsRebootRequired()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\netcfg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      netcfg.h
//
//  Description:
//
//
//  Implementation Files:
//      netcfg.cpp
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "smartptr.h"
#include "constants.h"

const int nTIMEOUT_PERIOD = 5000;

class CNetCfg
{

public:

    CNetCfg( bool bLockNetworkSettingsIn );
    CNetCfg( const CNetCfg &NetCfgOld );
    ~CNetCfg();

    HRESULT GetNetCfgClass( 
        const GUID* pGuid,              //  pointer to GUID representing the class of components represented by the returned pointer
        INetCfgClassPtr &pNetCfgClass
    ) const;

    HRESULT InitializeComInterface( 
        const GUID *pGuid,                                        //  pointer to GUID representing the class of components represented by the returned pointer
        INetCfgClassPtr pNetCfgClass,                             //  output parameter pointing to the interface requested by the GUID
        IEnumNetCfgComponentPtr pEnum,                            //  output param that points to an IEnumNetCfgComponent to get to each individual INetCfgComponent
        INetCfgComponentPtr arrayComp[nMAX_NUM_NET_COMPONENTS],   //  array of all the INetCfgComponents that correspond to the the given GUID
        ULONG* pCount                                             //  the number of INetCfgComponents in the array
        ) const;

    HRESULT HrFindComponent( LPCWSTR pszAnswerfileSubSection, INetCfgComponent ** ppnccItem ) const
        { return( m_pNetCfg->FindComponent( pszAnswerfileSubSection, ppnccItem ) ); }

    HRESULT HrGetNetCfgClass( const GUID* pGuidClass, 
                              REFIID riid,
                              void ** ppncclass ) const
        { return( m_pNetCfg->QueryNetCfgClass( pGuidClass, riid, ppncclass ) ); }

    HRESULT HrApply( void ) const
        { return( m_pNetCfg->Apply() ); }

    INetCfg * GetNetCfg( void ) const
        { return( m_pNetCfg.GetInterfacePtr() ); }

protected:

    INetCfgPtr     m_pNetCfg;
    INetCfgLockPtr m_pNetCfgLock;

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\reboot.h ===
// Reboot.h : Declaration of the CReboot
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Reboot.h
//
//  Description:
//      Implementation file for the CReboot.  Deals with shutdown or reboot
//      of the system
//
//  Implementation File:
//      Reboot.cpp
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __REBOOT_H_
#define __REBOOT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CReboot
class ATL_NO_VTABLE CReboot : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CReboot, &CLSID_Reboot>,
    public IDispatchImpl<IReboot, &IID_IReboot, &LIBID_COMHELPERLib>
{
public:
    CReboot()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_REBOOT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CReboot)
    COM_INTERFACE_ENTRY(IReboot)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IReboot
public:

    STDMETHOD(Shutdown)(/*[in]*/ BOOL RebootFlag);
    HRESULT 
    AdjustPrivilege( void );
};

#endif //__REBOOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\reboot.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Reboot.cpp
//
//  Description:
//      Implementation file for the CReboot.  Deals with shutdown or reboot
//      of the system
//
//  Header File:
//      Reboot.h
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 20-April-2000
//
//////////////////////////////////////////////////////////////////////////////

// Reboot.cpp : Implementation of CReboot
#include "stdafx.h"
#include "COMhelper.h"
#include "Reboot.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CReboot::Shutdown
//
//  Description:
//        Shutdowns the system if RebootFlag is set to FALSE, otherwise 
//      reboots the system.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CReboot::Shutdown( BOOL RebootFlag )
{
    // TODO: Add your implementation code here

    HRESULT      hr      = S_OK;
    DWORD        dwError;
//    unsigned int uFlag;

    try
    {
        hr = AdjustPrivilege();

        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: FAILED( hr )
/*
        if ( RebootFlag )
        {
            uFlag = EWX_REBOOT | EWX_FORCEIFHUNG;
        }
        else
        {
            uFlag = EWX_SHUTDOWN | EWX_FORCEIFHUNG;
        }


        if ( !ExitWindowsEx( uFlag, 0 ) )
        {
            dwError = GetLastError();

            ATLTRACE( L"ExitWindowsEx failed, Error = %#d \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: ExitWindowsEx fails

*/
        if ( !InitiateSystemShutdown( 
                NULL,                   // computer name 
                NULL,                   // message to display
                0,                      // length of time to display
                TRUE,                   // force closed option
                RebootFlag              // reboot option
                ) )
        {

            dwError = GetLastError();
            ATLTRACE( L"InitiateSystemShutdown failed, Error = %#d \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: InitiateSystemShutdown fails


    }

    catch ( ... )
    {

        return hr;

    }

    return hr;

} //*** CReboot::Shutdown()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CReboot::AdjustPrivilege
//
//  Description:
//        Attempt to assert SeShutdownPrivilege and SeRemoteShutdownPrivilege. 
//      This privilege is required for the Registry backup process.
//
//--
//////////////////////////////////////////////////////////////////////////////

HRESULT 
CReboot::AdjustPrivilege( void )
{

    HANDLE                   TokenHandle;
    LUID_AND_ATTRIBUTES      LuidAndAttributes;
    LUID_AND_ATTRIBUTES      LuidAndAttributesRemote;
    TOKEN_PRIVILEGES         TokenPrivileges;
    DWORD                    dwError;
    HRESULT                  hr = S_OK;

    try
    {
        // If the client application is ASP, then shutdown privilege for the 
        // thread token needs to be adjusted

        if ( ! OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_ADJUST_PRIVILEGES,
                    TRUE,
                    &TokenHandle
                    ) )
        
        {
            // If the client app is not ASP, then OpenThreadToken fails - the 
            // shutdown privilege for the process token needs to be adjusted 
            // in this case, but not for the thread token.

            if ( ! OpenProcessToken(
                        GetCurrentProcess(),
                        TOKEN_ADJUST_PRIVILEGES,
                        & TokenHandle
                        ) )
            {

            
                dwError = GetLastError();

                ATLTRACE(L"Both OpenThreadToken & OpenProcessToken failed\n" );

                hr = HRESULT_FROM_WIN32( dwError );
                throw hr;

            } // if: OpenProcessToken fails

        } // if: OpenThreadToken fails

        if( !LookupPrivilegeValue( NULL,
                                   SE_SHUTDOWN_NAME, 
                                   &( LuidAndAttributes.Luid ) ) ) 
        {
            
            dwError = GetLastError();
            
            ATLTRACE( L"LookupPrivilegeValue failed, Error = %#d \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: LookupPrivilegeValue fails for SE_SHUTDOWN_NAME

        if( !LookupPrivilegeValue( NULL,
                                   SE_REMOTE_SHUTDOWN_NAME, 
                                   &( LuidAndAttributesRemote.Luid ) ) ) 
        {
            
            dwError = GetLastError();
            
            ATLTRACE( L"LookupPrivilegeValue failed, Error = %#d \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: LookupPrivilegeValue fails for SE_REMOTE_SHUTDOWN_NAME

        LuidAndAttributes.Attributes       = SE_PRIVILEGE_ENABLED;
        LuidAndAttributesRemote.Attributes = SE_PRIVILEGE_ENABLED;
        TokenPrivileges.PrivilegeCount     = 2;
        TokenPrivileges.Privileges[ 0 ]    = LuidAndAttributes;
        TokenPrivileges.Privileges[ 1 ]    = LuidAndAttributesRemote;

        if( !AdjustTokenPrivileges( TokenHandle,
                                    FALSE,
                                    &TokenPrivileges,
                                    0,
                                    NULL,
                                    NULL ) ) 
        {
            
            dwError = GetLastError();

            ATLTRACE( L"AdjustTokenPrivileges failed, Error = %#x \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: AdjustTokenPrivileges fails

    }

    catch ( ... )
    {

        return hr;

    }

    return hr;

} //*** CReboot::AdjustPrivilege()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\networks.h ===
// NetWorks.h : Declaration of the CNetWorks
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      networks.h
//
//  Description:
//        This module deals with providing info about Network cards and protocols 
//        and to change protocols bound to network cards. And exposes the following.
//            Methods :
//                EnumNics
//              EnumProtocol
//              SetNicProtocol
//
//  Implementation File:
//      networks.cpp
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __NETWORKS_H_
#define __NETWORKS_H_

#include "smartptr.h"
#include "netcfg.h"
#include "constants.h"
#include "resource.h"       // main symbols
#include "Setting.h"

/////////////////////////////////////////////////////////////////////////////
// CNetWorks
class ATL_NO_VTABLE CNetWorks : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<INetWorks, &IID_INetWorks, &LIBID_COMHELPERLib>,
    public CSetting
{
public:
    CNetWorks()
    {
    }

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNetWorks)
    COM_INTERFACE_ENTRY(INetWorks)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CNetWorks)
END_CATEGORY_MAP()

// INetWorks
public:
    BOOL IsRebootRequired( BSTR * bstrWarningMessageOut );
    HRESULT Apply( void );
    STDMETHOD(SetNicProtocol)(/*[in]*/ BSTR NicName, /*[in]*/ BSTR ProtocolName, /*[in]*/ BOOL bind);
    STDMETHOD(EnumProtocol)(/*[in]*/ BSTR Name, /*[out]*/ VARIANT * psaProtocolName, /*[out]*/ VARIANT * psaIsBonded);
    STDMETHOD(EnumNics)(/*[out]*/ VARIANT * pvarNicNames);

private:

    HRESULT InitializeComInterface(
        INetCfgPtr & pINetCfg,
        const GUID *pGuid,                                        //  pointer to GUID representing the class of components represented by the returned pointer
        INetCfgClassPtr pNetCfgClass,                             //  output parameter pointing to the interface requested by the GUID
        IEnumNetCfgComponentPtr pEnum,                            //  output param that points to an IEnumNetCfgComponent to get to each individual INetCfgComponent
        INetCfgComponentPtr arrayComp[nMAX_NUM_NET_COMPONENTS],   //  array of all the INetCfgComponents that correspond to the the given GUID
        ULONG* pCount                                             //  the number of INetCfgComponents in the array
        ) const;

protected:

    HRESULT
    CNetWorks::GetNetworkCardInterfaceFromName(
        const CNetCfg & NetCfgIn,
        BSTR Name, 
        INetCfgComponentPtr & pnccNetworkAdapter
        );

};

#endif //__NETWORKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\networktools.cpp ===
// Backup.cpp : Implementation of CBackup
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      Backup.cpp
//
//  Description:
//      Implementation file for the CBackup.  Deals with Backup/Restore of 
//      System state information between main booting partition and backup
//      partition. Also provides the functionality of enumerating and 
//		deleting the backups. 
//
//  Header File:
//      Backup.h
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4786 )

#include "stdafx.h"
#include "COMhelper.h"
#include "NetworkTools.h"
#include <comdef.h>
#include <string>
#include <winsock2.h>
#undef _ASSERTE // need to use the _ASSERTE from debug.h
#undef _ASSERT // need to use the _ASSERT from debug.h
#include "debug.h"
using namespace std;

static BOOL PingTest(LPCSTR lpszHostName, int iPktSize, int iNumAttempts, int iDelay, int *piReplyRecvd);

STDMETHODIMP 
CNetworkTools::Ping( BSTR bstrIP, BOOL* pbFoundSystem )
{
    SATraceFunction("CNetworkTools::Ping");
    
    HRESULT hr = S_OK;
    USES_CONVERSION;

    try
    {
        wstring wsIP(bstrIP);

        if ( 0 == pbFoundSystem )
        {
            return E_INVALIDARG;
        }
        *pbFoundSystem = FALSE;

    
        if ( wsIP.length() <= 0 )
        {
            wsIP = L"127.0.0.1";
        }

        int iReplyRecieved = 0;
    
        PingTest(W2A(wsIP.c_str()), 32, 3, 250, &iReplyRecieved);
        if ( iReplyRecieved > 0 )
        {
            (*pbFoundSystem) = TRUE;            
        }
        
    }
    catch(...)
    {
        SATraceString("Unexpected exception");
    }
    
    return hr;

}



#define ICMP_ECHO 8
#define ICMP_ECHOREPLY 0

#define ICMP_MIN 8 // minimum 8 byte icmp packet (just header)


/* The IP header */
typedef struct iphdr {
	unsigned int h_len:4;          // length of the header
	unsigned int version:4;        // Version of IP
	unsigned char tos;             // Type of service
	unsigned short total_len;      // total length of the packet
	unsigned short ident;          // unique identifier
	unsigned short frag_and_flags; // flags
	unsigned char  ttl; 
	unsigned char proto;           // protocol (TCP, UDP etc)
	unsigned short CheckSum;       // IP CheckSum

	unsigned int sourceIP;
	unsigned int destIP;

}IpHeader;

//
// ICMP header
//
typedef struct _ihdr {
  BYTE i_type;
  BYTE i_code; /* type sub code */
  USHORT i_cksum;
  USHORT i_id;
  USHORT i_seq;
  /* This is not the std header, but we reserve space for time */
  ULONG timestamp;
}IcmpHeader;

#define MAX_PAYLOAD_SIZE 1500
#define MIN_PAYLOAD_SIZE 8

#define MAX_PACKET (MAX_PAYLOAD_SIZE + sizeof(IpHeader) + sizeof(IcmpHeader))

static void   FillIcmpData(char * pcRecvBuf, int iDataSize);
static USHORT CheckSum(USHORT *buffer, int iSize);
static BOOL   DecodeResp(char *buf, int iBytes, struct sockaddr_in *saiFrom);

//+----------------------------------------------------------------------------
//
// Function:  Ping
//
// Synopsis:  ping a host
//
// Arguments: IN lpszHostName - the host name or IP address as a string
//            IN iPktSize     - size of each ping packet
//            IN iNumAttempts - Number of ICMP echo requests to send
//            IN iDelay       - Delay between sending 2 echo requests
//           OUT piReplyRecvd - Number of ICM echo responses received
//            
// Returns:   BOOL
//
// History:   BalajiB Created Header    7 Jan 2000
//
//+----------------------------------------------------------------------------
static BOOL PingTest(LPCSTR lpszHostName, int iPktSize, int iNumAttempts, int iDelay, int *piReplyRecvd)
{
    WSADATA            wsaData;
    SOCKET             sockRaw;
    struct sockaddr_in saiDest,saiFrom;
    struct hostent     *hp = NULL;
    int                iBread, iFromLen = sizeof(saiFrom), iTimeOut;
    char               *pcDestIp=NULL, *pcIcmpData=NULL, *pcRecvBuf=NULL;
    unsigned int       addr=0;
    USHORT             usSeqNo = 0;
    int                i=0;

    SATraceFunction("Ping....");
	ASSERT(piReplyRecvd);

	if (piReplyRecvd == NULL)
	{
		return FALSE;
	}

	(*piReplyRecvd) = 0;

    // check for acceptable packet size
    if ( (iPktSize > MAX_PAYLOAD_SIZE) || (iPktSize < MIN_PAYLOAD_SIZE) )
    {
        SATracePrintf("Pkt size unacceptable in Ping() %ld", iPktSize);
        goto End;
    }

    //
    // add room for the icmp header
    //
    iPktSize += sizeof(IcmpHeader);

    if (WSAStartup(MAKEWORD(2,1),&wsaData) != 0){
        SATracePrintf("WSAStartup failed: %d",GetLastError());
        goto End;
    }

    //
    // WSA_FLAG_OVERLAPPED needed since we want to specify send/recv
    // time out values (SO_RCVTIMEO/SO_SNDTIMEO)
    //
    sockRaw = WSASocket (AF_INET,
                         SOCK_RAW,
                         IPPROTO_ICMP,
                         NULL, 
                         0,
                         WSA_FLAG_OVERLAPPED);
  
    if (sockRaw == INVALID_SOCKET) {
        SATracePrintf("WSASocket() failed: %d",WSAGetLastError());
        goto End;
    }

    //
    // max wait time = 1 sec.
    //
    iTimeOut = 1000;
    iBread = setsockopt(sockRaw,SOL_SOCKET,SO_RCVTIMEO,(char*)&iTimeOut,
                        sizeof(iTimeOut));
    if(iBread == SOCKET_ERROR) {
        SATracePrintf("failed to set recv iTimeOut: %d",WSAGetLastError());
        goto End;
    }

    //
    // max wait time = 1 sec.
    //
    iTimeOut = 1000;
    iBread = setsockopt(sockRaw,SOL_SOCKET,SO_SNDTIMEO,(char*)&iTimeOut,
                        sizeof(iTimeOut));
    if(iBread == SOCKET_ERROR) {
        SATracePrintf("failed to set send iTimeOut: %d",WSAGetLastError());
        goto End;
    }
    memset(&saiDest,0,sizeof(saiDest));

    hp = gethostbyname(lpszHostName);

    // host name must be an IP address
    if (!hp)
    {
        addr = inet_addr(lpszHostName);
    }

    if ((!hp)  && (addr == INADDR_NONE) ) 
    {
        SATracePrintf("Unable to resolve %s",lpszHostName);
        goto End;
    }

    if (hp != NULL)
    {
        memcpy(&(saiDest.sin_addr),hp->h_addr,hp->h_length);
    }
    else
    {
        saiDest.sin_addr.s_addr = addr;
    }

    if (hp)
    {
        saiDest.sin_family = hp->h_addrtype;
    }
    else
    {
        saiDest.sin_family = AF_INET;
    }

    pcDestIp = inet_ntoa(saiDest.sin_addr);

    pcIcmpData = (char *)malloc(MAX_PACKET);
    pcRecvBuf	 = (char *)malloc(MAX_PACKET);

    if (!pcIcmpData) {
        SATraceString("SaAlloc failed for pcIcmpData");
        goto End;  
    }

    if (!pcRecvBuf)
    {
        SATraceString("SaAlloc failed for pcRecvBuf");
        goto End;
    }
  
    memset(pcIcmpData,0,MAX_PACKET);
    FillIcmpData(pcIcmpData,iPktSize);

    i=0;
    while(i < iNumAttempts) 
    {
        int bwrote;

        i++;
	
        ((IcmpHeader*)pcIcmpData)->i_cksum = 0;
        ((IcmpHeader*)pcIcmpData)->timestamp = GetTickCount();

        ((IcmpHeader*)pcIcmpData)->i_seq = usSeqNo++;
        ((IcmpHeader*)pcIcmpData)->i_cksum = CheckSum((USHORT*)pcIcmpData,  iPktSize);

        bwrote = sendto(sockRaw,pcIcmpData,iPktSize,0,(struct sockaddr*)&saiDest, sizeof(saiDest));

        if (bwrote == SOCKET_ERROR)
        {
            if (WSAGetLastError() == WSAETIMEDOUT) 
            {
                SATraceString("timed out");
                continue;
	        }
            SATracePrintf("sendto failed: %d",WSAGetLastError());
            goto End;	
        }

        if (bwrote < iPktSize ) 
        {
            SATracePrintf("Wrote %d bytes",bwrote);
        }

        iBread = recvfrom(sockRaw,pcRecvBuf,MAX_PACKET,0,(struct sockaddr*)&saiFrom, &iFromLen);

        if (iBread == SOCKET_ERROR)
        {
            if (WSAGetLastError() == WSAETIMEDOUT) 
            {
                SATraceString("timed out");
                continue;
            }
            SATracePrintf("recvfrom failed: %d",WSAGetLastError());
            goto End;
        }

        if (DecodeResp(pcRecvBuf,iBread,&saiFrom) == TRUE)
        {
            (*piReplyRecvd)++;
        }

        Sleep(iDelay);
    }

End:
    if (pcRecvBuf)
    {
        free(pcRecvBuf);
    }
    if (pcIcmpData)
    {
        free(pcIcmpData);
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  DecodeResp
//
// Synopsis:  The response is an IP packet. We must decode the IP header to 
//            locate the ICMP data 
//
// Arguments: IN buf     - the response pkt to be decoded
//            IN Bytes   - number of bytes in the pkt
//            IN saiFrom - address from which response was received
//            
// Returns:   BOOL
//
// History:   BalajiB Created Header    7 Jan 2000
//
//+----------------------------------------------------------------------------
BOOL DecodeResp(char *buf, int iBytes, struct sockaddr_in *saiFrom) 
{
    IpHeader *ipHdr;
    IcmpHeader *icmpHdr;
    unsigned short uiIpHdrLen;

	// Input validation
	if (NULL == buf || NULL == saiFrom)
		return FALSE;

    ipHdr = (IpHeader *)buf;

    uiIpHdrLen = ipHdr->h_len * 4 ; // number of 32-bit words *4 = bytes

    if (iBytes  < uiIpHdrLen + ICMP_MIN) {
        SATracePrintf("Too few bytes saiFrom %s",inet_ntoa(saiFrom->sin_addr));
        return FALSE;
    }
    
    icmpHdr = (IcmpHeader*)(buf + uiIpHdrLen);
    
    if (icmpHdr->i_type != ICMP_ECHOREPLY) {
        SATracePrintf("non-echo type %d recvd",icmpHdr->i_type);
        return FALSE;
    }
    if (icmpHdr->i_id != (USHORT)GetCurrentProcessId()) {
        SATraceString("someone else's packet!");
        return FALSE;
    }

    //SATracePrintf("%d bytes saiFrom %s:",iBytes, inet_ntoa(saiFrom->sin_addr));
    //SATracePrintf(" icmp_seq = %d. ",icmphdr->i_seq);
    //SATracePrintf(" time: %d ms ",GetTickCount()-icmphdr->timestamp);
    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  CheckSum
//
// Synopsis:  Calculate checksum for the payload
//
// Arguments: IN buffer  - the data for which chksum is to be calculated
//            IN iSize   - size of data buffer
//            
// Returns:   the calculated checksum
//
// History:   BalajiB Created Header    7 Jan 2000
//
//+----------------------------------------------------------------------------
USHORT CheckSum(USHORT *buffer, int iSize) 
{
    unsigned long ulCkSum=0;

	// Input validation
	if (NULL == buffer)
		return (USHORT) ulCkSum;

    while(iSize > 1) {
        ulCkSum+=*buffer++;
        iSize -=sizeof(USHORT);
    }
  
    if(iSize) {
    ulCkSum += *(UCHAR*)buffer;
    }

    ulCkSum = (ulCkSum >> 16) + (ulCkSum & 0xffff);
    ulCkSum += (ulCkSum >>16);
    return (USHORT)(~ulCkSum);
}


//+----------------------------------------------------------------------------
//
// Function:  CheckSum
//
// Synopsis:  Helper function to fill in various stuff in our ICMP request.
//
// Arguments: IN pcRecvBuf - the data buffer
//            IN iDataSize - buffer size
//            
// Returns:   None
//
// History:   BalajiB Created Header    7 Jan 2000
//
//+----------------------------------------------------------------------------
void FillIcmpData(char * pcRecvBuf, int iDataSize)
{
    IcmpHeader *icmpHdr;
    char *datapart;

    icmpHdr = (IcmpHeader*)pcRecvBuf;

    icmpHdr->i_type = ICMP_ECHO;
    icmpHdr->i_code = 0;
    icmpHdr->i_id = (USHORT)GetCurrentProcessId();
    icmpHdr->i_cksum = 0;
    icmpHdr->i_seq = 0;

    datapart = pcRecvBuf + sizeof(IcmpHeader);
    //
    // Place some junk in the buffer.
    //
    memset(datapart,'E', iDataSize - sizeof(IcmpHeader));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by COMhelper.rc
//
#define IDS_PROJNAME                    100
#define IDR_SYSTEMSETTING               101
#define IDR_LOCALSETTING                102
#define IDR_COMPUTER                    103
#define IDR_NETWORKS                    104
#define IDR_REBOOT                      106
#define IDR_ACCOUNTNAMES               107
#define IDR_NETWORKTOOLS               108
#define IDR_CRYPTRANDOM                 109

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\setting.h ===
#pragma once

// Setting.h : Declaration of the CSetting
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      setting.h
//
//  Description:
//        CSetting is an abstract base class for CComputer, CLocalSetting and
//        CNetWorks. The purpose is to provide an exclusive access to member
//      functions (Apply and IsRebootRequired) of CComputer, CLocalSetting 
//      and CNetWorks from CSystemSetting class. 
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

class CSetting
{
public:
    virtual HRESULT Apply( void ) = 0;
    virtual BOOL IsRebootRequired( BSTR * bstrWarningMessageOut ) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\smartptr.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      smartptr.h
//
//  Description:
//
//
//  Implementation Files:
//      smartptr.cpp
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdlib.h>
#include <winbase.h>
#include <objbase.h>
#include <initguid.h>
#include "ntsecapi.h"
#include "netcfgx.h"
#include "netcfgn.h"
#include <comdef.h>

#pragma once

//
//  _COM_SMARTPTR_TYPEDEF is a Win32 Macro to create a smart pointer template.  The new
//  type created is the Interface name with Ptr appended.  For instance, IFoo becomes
//  IFooPtr.
//

_COM_SMARTPTR_TYPEDEF( INetCfg, __uuidof(INetCfg) );
_COM_SMARTPTR_TYPEDEF( INetCfgLock, __uuidof(INetCfgLock) );
_COM_SMARTPTR_TYPEDEF( INetCfgClass, __uuidof(INetCfgClass) );
_COM_SMARTPTR_TYPEDEF( INetCfgClassSetup, __uuidof(INetCfgClassSetup) );
_COM_SMARTPTR_TYPEDEF( IEnumNetCfgComponent, __uuidof(IEnumNetCfgComponent) );
_COM_SMARTPTR_TYPEDEF( INetCfgComponent, __uuidof(INetCfgComponent) );
_COM_SMARTPTR_TYPEDEF( INetCfgComponentBindings, __uuidof(INetCfgComponentBindings) );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__AC1F8DFA_79A4_4125_9ADA_B213A9E11EB7__INCLUDED_)
#define AFX_STDAFX_H__AC1F8DFA_79A4_4125_9ADA_B213A9E11EB7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED
#include <crtdbg.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AC1F8DFA_79A4_4125_9ADA_B213A9E11EB7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\systemsetting.cpp ===
// SystemSetting.cpp : Implementation of CSystemSetting
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      SystemSetting.cpp
//
//  Description:
//      Implementation file for the CSystemSetting.  Deals with getting 
//      interface pointers of IComputer, ILocalSetting and INetWorks.
//      Provides the implementation for the methods Apply and 
//        IsRebootRequired. CSystemSetting acts as wrapper class for 
//      CComputer, CLocalSetting and CNetWorks. Clients can have access 
//      to IComputer*, ILocalSetting* and INetWorks*, only through
//      ISystemSetting.
//
//  Header File:
//      SystemSetting.h
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "COMhelper.h"
#include "SystemSetting.h"
#import "wbemdisp.tlb" rename_namespace("WbemDrive")
using namespace WbemDrive;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSystemSetting::get_NetWorks
//
//  Description:
//        Retrieves the (INetWorks*)
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CSystemSetting::get_NetWorks( 
    INetWorks ** pVal 
    )
{
    // TODO: Add your implementation code here
    
    HRESULT hr = S_OK;
    
    try
    {
        *pVal = NULL;
        

        if ( m_pNetWorks == NULL )
        {
            hr = CComCreator< CComObject<CNetWorks> >::CreateInstance(
                    NULL,
                    IID_INetWorks, 
                    reinterpret_cast<void **>( pVal ) 
                    );
        
            if( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )
        
            m_pNetWorks = dynamic_cast<CNetWorks*>( *pVal );

            if ( m_pNetWorks == NULL )
            {
                hr = E_POINTER;
                throw hr;

            } // if: m_pNetWorks == NULL

            m_pNetWorks->AddRef();

        } // if: m_pNetWorks is not initialized

        else
        {
            hr = m_pNetWorks->QueryInterface(
                    IID_INetWorks, 
                    reinterpret_cast<void **>( pVal )
                    );

            if( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

        } // else: m_pNetWorks is initialized

    }
    
    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }
    
    return hr;

} //*** CSystemSetting::get_NetWorks()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSystemSetting::get_Computer
//
//  Description:
//        Retrieves the (IComputer*)
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CSystemSetting::get_Computer( 
    IComputer ** pVal 
    )
{
    // TODO: Add your implementation code here
    
    HRESULT hr = S_OK;
    
    try
    {
        *pVal = NULL;
        

        if ( m_pComputer == NULL )
        {

            hr = CComCreator< CComObject<CComputer> >::CreateInstance(
                    NULL,
                    IID_IComputer, 
                    reinterpret_cast<void **>( pVal )
                    );
        
            if( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )
        
            m_pComputer = dynamic_cast<CComputer *>( *pVal );

            if ( m_pComputer == NULL )
            {
                hr = E_POINTER;
                throw hr;

            } // if: m_pComputer == NULL

            m_pComputer->AddRef();


        } // if: m_pComputer is not initialized

        else
        {
            hr = m_pComputer->QueryInterface(
                    IID_IComputer, 
                    reinterpret_cast<void **>( pVal )
                    );

            if( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

        } // else: m_pComputer is initialized

    }
    
    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }
    
    return hr;

} //*** CSystemSetting::get_Computer()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSystemSetting::get_LocalSetting
//
//  Description:
//        Retrieves the (ILocalSetting*)
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CSystemSetting::get_LocalSetting( 
    ILocalSetting ** pVal 
    )
{
    // TODO: Add your implementation code here
    
    HRESULT hr = S_OK;
    
    try
    {
        *pVal = NULL;
        

        if ( m_pLocalSetting == NULL )
        {
            hr = CComCreator< CComObject<CLocalSetting> >::CreateInstance(
                    NULL,
                    IID_ILocalSetting, 
                    reinterpret_cast<void **>( pVal )
                    );
        
            if( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )
        
            m_pLocalSetting = dynamic_cast<CLocalSetting*>( *pVal );

            if ( m_pLocalSetting == NULL )
            {
                hr = E_POINTER;
                throw hr;

            } // if: m_pLocalSetting == NULL

            m_pLocalSetting->AddRef();

        } // if: m_pLocalSetting is not initialized

        else
        {
            hr = m_pLocalSetting->QueryInterface(
                    IID_ILocalSetting, 
                    reinterpret_cast<void **>( pVal )
                    );

            if( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

        } // else: m_pComputer is initialized


    }
    
    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }
    
    return hr;

} //*** CSystemSetting::get_LocalSetting()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSystemSetting::Apply
//
//  Description:
//        None of the property changes for the CComputer, CLocalSetting and 
//      CNetWorks  objects take effect until this Apply function is called.
//      Invokes the member function Apply of CComputer, CLocalSetting and
//      CNetWorks. The parameter bDeferReboot indicates whether to reboot 
//        the system immediately after applying the property changes (FALSE) 
//        or defer the reboot for the value of (TRUE) - the property changes
//        will come into effect only after the reboot.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CSystemSetting::Apply( 
    BOOL bDeferReboot)
{
    // TODO: Add your implementation code here
    
    HRESULT hr = S_OK;

    try
    {
        
        if ( m_pComputer != NULL )
        {
            hr = m_pComputer->Apply();
        
            if( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

        } // if: m_pComputer != NULL
        
        if ( m_pLocalSetting != NULL )
        {
            hr = m_pLocalSetting->Apply();
        
            if( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

//            if ( m_pLocalSetting->m_bDeleteFile )
//            {
//                DeleteFile( L"unattend.txt" );
//            }

        } // if: m_pLocalSetting != NULL
        
        if ( m_pNetWorks != NULL )
        {
            hr = m_pNetWorks->Apply();
        
            if( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

        } // if: m_pNetWorks != NULL

        BOOL    bReboot;
        VARIANT varWarning;

        VariantInit( &varWarning);
        hr = IsRebootRequired( &varWarning, &bReboot );
        VariantClear( &varWarning );
        
        if( FAILED( hr ) )
        {
            throw hr;

        } // if: FAILED( hr )

        if ( bReboot && !bDeferReboot )
        {
            hr = Reboot();

            if ( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )

        } // if: bReboot is set as TRUE and bDeferReboot is set as FALSE

    }
    
    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return hr;
    }
    
    return hr;

} //*** CSystemSetting::Apply()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSystemSetting::IsRebootRequired
//
//  Description:
//      Determines whether system needs rebooting to take effect of any
//        property change and if so, gives out the warning message as 
//        a reason for the reboot. Invokes the member function IsRebootRequired 
//      of CComputer, CLocalSetting and CNetWorks.
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CSystemSetting::IsRebootRequired( 
    VARIANT * WarningMessage,       // Reason for rebooting the system
    BOOL    * Reboot                // TRUE for reboot
    )
{
    // TODO: Add your implementation code here
    try
    {
        BSTR  bstrComputerWarning;
        BSTR  bstrLocalSettingWarning;
        BSTR  bstrNetWorksWarning;
        WCHAR tszWarning[ nMAX_MESSAGE_LENGTH ];

        wcscpy( tszWarning, L"Reboot the system to take effect of following property changes\n" );
        
        if ( m_pComputer != NULL )
        {
            m_bflagReboot |= m_pComputer->IsRebootRequired( &bstrComputerWarning );

            if ( bstrComputerWarning != NULL )
            {

                wcscat( tszWarning, bstrComputerWarning );

            } // if: bstrComputerWarning != NULL

            SysFreeString( bstrComputerWarning );

        } // if: m_pComputer != NULL

        if ( m_pLocalSetting != NULL )
        {
            m_bflagReboot |= m_pLocalSetting->IsRebootRequired( &bstrLocalSettingWarning );

            if ( bstrLocalSettingWarning != NULL )
            {

                wcscat( tszWarning, bstrLocalSettingWarning );

            } // if: bstrLocalSettingWarning != NULL

            SysFreeString( bstrLocalSettingWarning );

        } // if: m_pLocalSetting != NULL

        if ( m_pNetWorks != NULL )
        {
            m_bflagReboot |= m_pNetWorks->IsRebootRequired( &bstrNetWorksWarning );
            
            if ( bstrNetWorksWarning != NULL )
            {
                
                wcscat( tszWarning, bstrNetWorksWarning );
            
            } // if: bstrNetWorksWarning != NULL
            
            SysFreeString( bstrNetWorksWarning );

        } // if: m_pNetWorks != NULL

        *Reboot = m_bflagReboot;

        VariantInit( WarningMessage );

        if ( m_bflagReboot )
        {
            VARIANT var;
            VariantInit( &var );

            V_VT( &var )  = VT_BSTR;
            BSTR bstr     = SysAllocString( tszWarning );
            V_BSTR( &var) = bstr;
            
            HRESULT hrVC = VariantCopy( WarningMessage, &var );
            if (FAILED (hrVC))
            {
                throw hrVC;
            }

            VariantClear( &var );

        } // if: m_bflagReboot == TRUE

        else
        {

            WarningMessage = NULL;

        } // else: m_bflagReboot == FALSE

    }
    catch( ... )
    {
        //
        //  Don't let any exceptions leave this function call
        //

        return E_FAIL;
    }

    return S_OK;

} //*** CSystemSetting::IsRebootRequired()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSystemSetting::Reboot
//
//  Description:
//        Reboots the local machine for the settings to take effect. This 
//        function uses WMI Win32_OperatingSystem class. Rebooting the system 
//      with Win32 API ExitWindowsEx fails in ASP/IIS while opening the process 
//      token for adjusting the token privilege with SE_SHUTDOWN_NAME.
//
//--
//////////////////////////////////////////////////////////////////////////////

HRESULT 
CSystemSetting::Reboot( void )
{

    HRESULT hr      = S_OK;
    DWORD   dwError;

    try
    {
        hr = AdjustPrivilege();

        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: FAILED( hr )
/*
        if ( !ExitWindowsEx( EWX_REBOOT | EWX_FORCEIFHUNG, 0 ) )
        {
            dwError = GetLastError();

            ATLTRACE( L"ExitWindowsEx failed, Error = %#d \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: ExitWindowsEx fails

*/
        if ( !InitiateSystemShutdown( 
                NULL,                   // computer name
                NULL,                   // message to display
                0,                      // length of time to display
                TRUE,                   // force closed option
                TRUE                    // reboot option
                ) )
        {

            dwError = GetLastError();
            ATLTRACE( L"InitiateSystemShutdown failed, Error = %#d \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: InitiateSystemShutdown fails

    }

    catch ( ... )
    {

        return hr;

    }

    return hr;



/*
    IEnumVARIANT * pEnumVARIANT = NULL;
    IUnknown     * pUnknown     = NULL;
    ISWbemObject * pWbemObject;
    HRESULT        hr;

    try
    {
        int  nCount;
        BSTR bstrNamespace = SysAllocString( L"root\\cimv2" );

        ISWbemLocatorPtr   pWbemLocator ;
        ISWbemServicesPtr  pWbemServices;
        ISWbemObjectSetPtr pWbemObjectSet;

        hr = pWbemLocator.CreateInstance( __uuidof( SWbemLocator ) );
        if ( FAILED( hr ) ) 
        {
            throw hr;

        } // if: FAILED( hr )
        
        pWbemLocator->Security_->ImpersonationLevel = wbemImpersonationLevelImpersonate ;
        pWbemLocator->Security_->Privileges->Add( wbemPrivilegeShutdown, -1 );
        pWbemLocator->Security_->Privileges->Add( wbemPrivilegeRemoteShutdown, -1 );

        pWbemServices = pWbemLocator->ConnectServer(
                                            L".",
                                            bstrNamespace,
                                            L"",
                                            L"",
                                            L"",
                                            L"", 
                                            0,
                                            NULL
                                            );

        pWbemObjectSet = pWbemServices->InstancesOf(
                                                L"Win32_OperatingSystem",
                                                0,
                                                NULL
                                                );

        nCount = pWbemObjectSet->Count;
        
        hr = pWbemObjectSet->get__NewEnum( &pUnknown );
        
        if ( FAILED( hr ) )
        {
            throw hr;

        } // if: FAILED( hr )

        hr = pUnknown->QueryInterface( &pEnumVARIANT );
        pUnknown->Release();

        for ( int j = 0; j < nCount; j++ ) 
        {
            VARIANT var;
            VariantInit( &var );
            
            pWbemObject = NULL;

            hr = pEnumVARIANT->Next( 1, &var, NULL );
            
            if ( FAILED( hr ) )
            {
                VariantClear( &var );
                throw hr;

            } // if: FAILED( hr )
            
            hr = var.pdispVal->QueryInterface( &pWbemObject );
            VariantClear( &var );

            if ( FAILED( hr ) )
            {
                throw hr;

            } // if: FAILED( hr )
            
            pWbemObject->ExecMethod_( L"Reboot", NULL, 0, NULL );
            pWbemObject->Release();

        } // for: Enumerating the pWbemObjectSet collection object

        pEnumVARIANT->Release();

    }

    catch ( const _com_error& Err )
    {
        if ( pWbemObject != NULL )
        {
            pWbemObject->Release();

        } // if: pWbemObject != NULL

        if ( pEnumVARIANT != NULL )
        {
            pEnumVARIANT->Release();

        } // if: pEnumVARIANT != NULL

        if ( pUnknown != NULL )
        {
            pUnknown->Release();

        } // if: pUnknown != NULL

        ATLTRACE( L"%s ---- 0x%x \n",Err.ErrorMessage(),Err.Error() );
        return hr;
    }

    return hr;
*/

} //*** CSystemSetting::Reboot()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSystemSetting::AdjustPrivilege
//
//  Description:
//        Attempt to assert SeBackupPrivilege. This privilege is required for 
//      the Registry backup process.
//
//--
//////////////////////////////////////////////////////////////////////////////

HRESULT 
CSystemSetting::AdjustPrivilege( void )
{

    HANDLE                   TokenHandle;
    LUID_AND_ATTRIBUTES      LuidAndAttributes;
    LUID_AND_ATTRIBUTES      LuidAndAttributesRemote;
    TOKEN_PRIVILEGES         TokenPrivileges;
    DWORD                    dwError;
    HRESULT                  hr = S_OK;

    try
    {

        // If the client application is ASP, then shutdown privilege for the 
        // thread token needs to be adjusted

        if ( ! OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_ADJUST_PRIVILEGES,
                    TRUE,
                    &TokenHandle
                    ) )
        
        {
            // If the client app is not ASP, then OpenThreadToken fails - the 
            // shutdown privilege for the process token needs to be adjusted 
            // in this case, but not for the thread token.
/*
            if ( ! OpenProcessToken(
                        GetCurrentProcess(),
                        TOKEN_ADJUST_PRIVILEGES,
                        & TokenHandle
                        ) )
            {
*/
            
                dwError = GetLastError();

                ATLTRACE(L"Both OpenThreadToken & OpenProcessToken failed\n" );

                hr = HRESULT_FROM_WIN32( dwError );
                throw hr;
/*
            } // if: OpenProcessToken fails
*/
        } // if: OpenThreadToken fails

        if( !LookupPrivilegeValue( NULL,
                                   SE_SHUTDOWN_NAME, 
                                   &( LuidAndAttributes.Luid ) ) ) 
        {
            
            dwError = GetLastError();
            
            ATLTRACE( L"LookupPrivilegeValue failed, Error = %#d \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: LookupPrivilegeValue fails for SE_SHUTDOWN_NAME

        if( !LookupPrivilegeValue( NULL,
                                   SE_REMOTE_SHUTDOWN_NAME, 
                                   &( LuidAndAttributesRemote.Luid ) ) ) 
        {
            
            dwError = GetLastError();
            
            ATLTRACE( L"LookupPrivilegeValue failed, Error = %#d \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: LookupPrivilegeValue fails for SE_REMOTE_SHUTDOWN_NAME

        LuidAndAttributes.Attributes       = SE_PRIVILEGE_ENABLED;
        LuidAndAttributesRemote.Attributes = SE_PRIVILEGE_ENABLED;
        TokenPrivileges.PrivilegeCount     = 2;
        TokenPrivileges.Privileges[ 0 ]    = LuidAndAttributes;
        TokenPrivileges.Privileges[ 1 ]    = LuidAndAttributesRemote;

        if( !AdjustTokenPrivileges( TokenHandle,
                                    FALSE,
                                    &TokenPrivileges,
                                    0,
                                    NULL,
                                    NULL ) ) 
        {
            
            dwError = GetLastError();

            ATLTRACE( L"AdjustTokenPrivileges failed, Error = %#x \n", dwError );

            hr = HRESULT_FROM_WIN32( dwError );
            throw hr;

        } // if: AdjustTokenPrivileges fails

    }

    catch ( ... )
    {

        return hr;

    }

    return hr;

} //*** CSystemSetting::AdjustPrivilege()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSystemSetting::Sleep
//
//  Description:
//        Sleep for n MilliSecs 
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP  CSystemSetting::Sleep( DWORD dwMilliSecs )
{
    HRESULT hr = S_OK;
    ::Sleep( dwMilliSecs );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\comhelper\systemsetting.h ===
// SystemSetting.h : Declaration of the CSystemSetting
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SystemSetting.h
//
//  Description:
//        This module exposes the following.
//            Properties :
//                IComputer *
//                ILocalSetting *
//                INetWorks *
//            Methods :
//                Apply
//                IsRebootRequired
//
//  Implementation File:
//      SystemSetting.cpp
//
//  Maintained By:
//      Munisamy Prabu (mprabu) 18-July-2000
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __SYSTEMSETTING_H_
#define __SYSTEMSETTING_H_

#include "resource.h"       // main symbols
#include "Computer.h"
#include "LocalSetting.h"
#include "NetWorks.h"

const int nMAX_MESSAGE_LENGTH = 1024;

/////////////////////////////////////////////////////////////////////////////
// CSystemSetting
class ATL_NO_VTABLE CSystemSetting : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSystemSetting, &CLSID_SystemSetting>,
    public IDispatchImpl<ISystemSetting, &IID_ISystemSetting, &LIBID_COMHELPERLib>
{
public:
    CSystemSetting()
    {
        m_pComputer     = NULL;
        m_pLocalSetting = NULL;
        m_pNetWorks     = NULL;
        m_bflagReboot   = FALSE;
    }

    ~CSystemSetting()
    {
        if ( m_pComputer != NULL )
        {
            m_pComputer->Release();
        }

        if ( m_pLocalSetting != NULL )
        {
            m_pLocalSetting->Release();
        }

        if ( m_pNetWorks != NULL )
        {
            m_pNetWorks->Release();
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SYSTEMSETTING)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSystemSetting)
    COM_INTERFACE_ENTRY(ISystemSetting)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISystemSetting
public:
    STDMETHOD(IsRebootRequired)(/*[out]*/ VARIANT * WarningMessage, /*[out, retval]*/ BOOL* Reboot);
    STDMETHOD(Apply)(/*[in]*/ BOOL bDeferReboot);
    STDMETHOD(get_LocalSetting)(/*[out, retval]*/ ILocalSetting **pVal);
    STDMETHOD(get_Computer)(/*[out, retval]*/ IComputer **pVal);
    STDMETHOD(get_NetWorks)(/*[out, retval]*/ INetWorks **pVal);

    static HRESULT 
    AdjustPrivilege( void );

    static HRESULT 
    Reboot( void );
    STDMETHOD( Sleep )( DWORD dwMilliSecs );

private:
    BOOL            m_bflagReboot;
    CComputer *     m_pComputer;
    CLocalSetting * m_pLocalSetting;
    CNetWorks *     m_pNetWorks;

};

#endif //__SYSTEMSETTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\componentfactory.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      componentfactory.cpp
//
// Project:     Chameleon
//
// Description: Component Factory Implementation
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Original Version
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "componentfactory.h"

// Make sure that in your class map include file 
// you've named the the component factory "TheFactoryMap" 

#include "componentfactorymap.h"

//////////////////////////////////////////////////////////////////////////////
// Global Component Factory Function.
// 
// Note that the interface returned is the interface specified in the
// DECLARE_COMPONENT_FACTORY macro
//
//////////////////////////////////////////////////////////////////////////////
IUnknown* MakeComponent(
                   /*[in]*/ LPCWSTR      pszClassId,
                 /*[in]*/ PPROPERTYBAG pPropertyBag
                       )
{
    IUnknown* pComponent = NULL;
    PCOMPONENT_FACTORY_INFO pFactoryInfo = TheFactoryMap;
    while ( pFactoryInfo->pszClassId )
    {
        if ( 0 == lstrcmpi(pFactoryInfo->pszClassId, pszClassId) )
        {
            _ASSERT ( NULL != pFactoryInfo->pfnFactory );
            pComponent = (pFactoryInfo->pfnFactory)(pPropertyBag);
            break;
        }
        pFactoryInfo++;
    }
    _ASSERT( NULL != pComponent );
    return pComponent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\elementcommon.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      elementcommon.h
//
// Project:     Chameleon
//
// Description: Chameleon ASP UI Element - Common Definitions
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_ELEMENT_COMMON_H_
#define __INC_ELEMENT_COMMON_H_

//////////////////////////////////////////////////////////////////////////////
//
// The following registry structure is assumed:
//
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ElementMgr
//
// WebElementDefinitions
//       |
//        - ElementDefinition1
//       |     |
//       |      - Property1
//       |     |
//       |      - PropertyN
//       |
//        - ElementDefinition2
//       |    |
//       |     - Property1
//       |    |
//       |     - PropertyN
//       |
//        - ElementDefinitionN
//            |
//             - Property1
//            |
//             - PropertyN
//
// Each element definition contains the following properties:
//
// 1) "Container"      - Container that holds this element
// 2) "Merit"          - Order of element in the container starting from 1 (value of 0 means no order specified)
// 3) "IsEmbedded"     - Set to 1 to indicate that the element is embedded - Otherwise element is a link
// 4) "ObjectClass     - Class name of the related WBEM class
// 5) "ObjectKey"      - Instance name of the related WBEM class (optional property)
// 6) "URL"            - URL for the page when the associated link is selected
// 7) "CaptionRID"     - Resource ID for the element caption
// 8) "DescriptionRID" - Resource ID for the element link description
// 9) "ElementGraphic" - Graphic (file) associated with the element (bitmap, icon, etc.)

#define        PROPERTY_ELEMENT_DEFINITION_CONTAINER    L"Container"
#define        PROPERTY_ELEMENT_DEFINITION_MERIT        L"Merit"
#define        PROPERTY_ELEMENT_DEFINITION_EMBEDDED    L"IsEmbedded"
#define        PROPERTY_ELEMENT_DEFINITION_CLASS        L"ObjectClass"
#define        PROPERTY_ELEMENT_DEFINITION_KEY            L"ObjectKey"
#define        PROPERTY_ELEMENT_DEFINITION_URL            L"URL"
#define        PROPERTY_ELEMENT_DEFINITION_CAPTION        L"CaptionRID"
#define        PROPERTY_ELEMENT_DEFINITION_DESCRIPTION    L"DescriptionRID"
#define        PROPERTY_ELEMENT_DEFINITION_GRAPHIC        L"ElementGraphic"

//////////////////////////////////////////////////////////////////////////////
// In code we add an "ElementID"

#define        PROPERTY_ELEMENT_ID                     L"ElementID"


//////////////////////////////////////////////////////////////////////////////
// Element Page Object Transient Properties... User never see's these... Used
// internally when constructing an element page object.

#define        PROPERTY_ELEMENT_WEB_DEFINITION            L"WebDefintion"
#define        PROPERTY_ELEMENT_WBEM_OBJECT            L"WbemObject"

//
// reg. sub-key for elementmgr
//
#define ELEMENT_MANAGER_KEY L"SOFTWARE\\Microsoft\\ServerAppliance\\ElementManager"

//
// regavl that indicates admin web virtual root name
//
#define ELEMENT_MANAGER_VIRTUAL_ROOT L"AdminRoot"


#endif // __INC_ELEMENT_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\componentfactorymap.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      componentfactorymap.h
//
// Project:     Chameleon
//
// Description: Component Factory Class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_COMPONENT_FACTORY_MAP_H_
#define __INC_COMPONENT_FACTORY_MAP_H_

#include "elementdefinition.h"
#include "elementenum.h"
#include "elementobject.h"

//////////////////////////////////////////////////////////////////////////////
BEGIN_COMPONENT_FACTORY_MAP(TheFactoryMap)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_ELEMENT_DEFINITION,  CElementDefinition)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_ELEMENT_OBJECT,      CElementObject)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_ELEMENT_ENUM,        CElementEnum)
END_COMPONENT_FACTORY_MAP()

#endif // __INC_COMPONENT_FACTORY_MAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\elementdefinition.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      elementdefinition.h
//
// Project:     Chameleon
//
// Description: Chameleon ASP UI Element Definition
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_ELEMENT_DEFINITION_H_
#define __INC_ELEMENT_DEFINITION_H_

#include "resource.h"    
#include "elementcommon.h"
#include "elementmgr.h"
#include "componentfactory.h"
#include "propertybag.h"
#include <comdef.h>
#include <comutil.h>

#pragma warning( disable : 4786 )
#include <map>
using namespace std;

#define  CLASS_ELEMENT_DEFINITION    L"CElementDefintion"

/////////////////////////////////////////////////////////////////////////////
// CElementDefinition

class ATL_NO_VTABLE CElementDefinition : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IWebElement, &IID_IWebElement, &LIBID_ELEMENTMGRLib>
{

public:
    
    CElementDefinition() { }
    ~CElementDefinition() { }

BEGIN_COM_MAP(CElementDefinition)
    COM_INTERFACE_ENTRY(IWebElement)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CElementDefinition, IWebElement)

public:

    //////////////////////////////////////////////////////////////////////////
    // IWebElement Interface

    STDMETHOD(GetProperty)(
                   /*[in]*/ BSTR     bstrName, 
                  /*[out]*/ VARIANT* pValue
                          );

    //////////////////////////////////////////////////////////////////////////
    // Initialization function invoked by component factory

    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              ) throw(_com_error);

private:

    typedef wstring        PROPERTY_NAME;
    typedef _variant_t    PROPERTY_VALUE;

    typedef map< PROPERTY_NAME, PROPERTY_VALUE >    PropertyMap;
    typedef PropertyMap::iterator                    PropertyMapIterator;

    PropertyMap                m_Properties;
    CLocationInfo            m_PropertyBagLocation;
};

#endif // __INC_ELEMENT_DEFINITION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\elementdefinition.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      elementdefinition.cpp
//
// Project:     Chameleon
//
// Description: Chameleon ASP UI Element Definition
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Elementmgr.h"
#include "ElementDefinition.h"
#include <satrace.h>


//////////////////////////////////////////////////////////////////////////
// IWebElement Interface Implementation

STDMETHODIMP CElementDefinition::GetProperty(
                                     /*[in]*/ BSTR     bstrName, 
                                    /*[out]*/ VARIANT* pValue
                                            )
{
    HRESULT hr = E_FAIL;

    if ((NULL == bstrName) || (NULL == pValue))
    {
        return (hr);
    }

    try
    {
        PropertyMapIterator p = m_Properties.find(bstrName);
        if ( p == m_Properties.end() )
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            hr = VariantCopy(pValue, &((*p).second));
        }
    }
    catch(_com_error theError)
    {
        hr = theError.Error();
    }
    catch(...)
    {
        hr = E_UNEXPECTED;
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////

typedef struct _STOCKPROPERTY
{
    LPCWSTR        pszName;
    int            iExpectedType;
    bool        bPresent;

} STOCKPROPERTY;

#define    MAX_STOCK_PROPERTIES    6            // Number of stock properties

static LPCWSTR pszStockPropertyNames[MAX_STOCK_PROPERTIES] = 
{
    L"CaptionRID",
    L"Container",
    L"DescriptionRID",
//    L"ElementGraphic",
    L"IsEmbedded",
    L"Merit",
//    L"Source",
    L"URL"
};

static int iStockPropertyTypes[MAX_STOCK_PROPERTIES] =
{
    VT_BSTR,    // CaptionRID
    VT_BSTR,    // Container
    VT_BSTR,    // DescriptionRID
//    VT_BSTR,    // ElementGraphic
    VT_I4,        // IsEmbedded
    VT_I4,        // Merit
//    VT_BSTR,    // Source
    VT_BSTR        // URL
};

//////////////////////////////////////////////////////////////////////////
// Initialization function invoked by component factory

HRESULT CElementDefinition::InternalInitialize(
                                       /*[in]*/ PPROPERTYBAG pProperties
                                              )
{
    HRESULT hr = S_OK;

    try
    {

        _ASSERT( pProperties.IsValid() );
        if ( ! pProperties.IsValid() )
        { throw _com_error(E_FAIL); }

        // Save the location of the properties for use at a later time...
        pProperties->getLocation(m_PropertyBagLocation);
        wchar_t szPropertyName[MAX_PATH + 1];
        if ( MAX_PATH < pProperties->getMaxPropertyName() )
        { throw _com_error(E_FAIL); }

        // Initialize the stock property information array
        STOCKPROPERTY    StockProperties[MAX_STOCK_PROPERTIES];
        int i = 0;
        while ( i < MAX_STOCK_PROPERTIES )
        {
            StockProperties[i].pszName = pszStockPropertyNames[i];
            StockProperties[i].iExpectedType = iStockPropertyTypes[i];
            StockProperties[i].bPresent = false;
            i++;
        }

        // Now index the properties from the property bag...
        pProperties->reset();
        do
        {
            _variant_t vtPropertyValue;
            if ( pProperties->current(szPropertyName, &vtPropertyValue) )
            {
                i = 0;
                while ( i < MAX_STOCK_PROPERTIES )
                {
                    if ( ! lstrcmpi(StockProperties[i].pszName, szPropertyName) )
                    {
                        if ( V_VT(&vtPropertyValue) == StockProperties[i].iExpectedType )
                        {
                            StockProperties[i].bPresent = true;
                            break;
                        }
                        else
                        {
                            SATracePrintf("CElementDefinition::InternalInitialize() - Error - Unexpected type for property '%ls' on element", szPropertyName, pProperties->getName());
                        }
                    }
                    i++;
                }

                pair<PropertyMapIterator, bool> thePair = 
                m_Properties.insert(PropertyMap::value_type(szPropertyName, vtPropertyValue));
                if ( false == thePair.second )
                {
                    m_Properties.erase(m_Properties.begin(), m_Properties.end());
                    throw _com_error(E_FAIL);    
                }
            }
        } while ( pProperties->next());

        // Ensure all stock properties are present
        i = 0;
        while ( i < MAX_STOCK_PROPERTIES )
        {
            if ( ! StockProperties[i].bPresent )
            {
                SATracePrintf("CElementDefinition::InternalInitialize() - Error - Could not locate stock property '%ls' for element '%ls'", StockProperties[i].pszName, pProperties->getName());
                break;
            }
            i++;
        }
        if ( i != MAX_STOCK_PROPERTIES )
        {
            SATracePrintf("CElementDefinition::InternalInitialize() - Error - Could not build an element definition for '%ls'", pProperties->getName());
            throw _com_error(E_FAIL);
        }
    }
    catch(_com_error theError)
    {
        hr = theError.Error();
    }
    catch(...)
    {
        hr = E_FAIL;
    }

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\elementenum.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      elementenum.h
//
// Project:     Chameleon
//
// Description: Chameleon ASP UI Element Enumerator Surrogate
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_ELEMENT_ENUM_H_
#define __INC_ELEMENT_ENUM_H_

#include "resource.h" 
#include "elementcommon.h"
#include "elementmgr.h"     
#include "componentfactory.h"
#include "propertybag.h"
#include <wbemcli.h>
#include <comdef.h>
#include <comutil.h>

#pragma warning( disable : 4786 )
#include <map>
using namespace std;

#define  CLASS_ELEMENT_ENUM        L"CElementEnum"
#define     PROPERTY_ELEMENT_ENUM    L"ElementEnumerator"
#define     PROPERTY_ELEMENT_COUNT    L"ElementCount"

/////////////////////////////////////////////////////////////////////////////
// CElementDefinition

class ATL_NO_VTABLE CElementEnum : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IWebElementEnum, &IID_IWebElementEnum, &LIBID_ELEMENTMGRLib>
{

public:
    
    CElementEnum()
        : m_lCount (0) { }

    ~CElementEnum() { }

BEGIN_COM_MAP(CElementEnum)
    COM_INTERFACE_ENTRY(IWebElementEnum)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CElementEnum, IWebElementEnum)

public:

    //////////////////////////////////////////////////////////////////////////
    // IWebElement Interface
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP get_Count (
            /*[out,retval]*/ LONG *plCount
                           )
    {
        _ASSERT( NULL != plCount );
        if ( NULL == plCount )
            return E_POINTER;

        _ASSERT( (IUnknown*) m_pEnumVARIANT );
        *plCount = m_lCount;
        return S_OK;
    }

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP Item(
              /*[in]*/ VARIANT*    pKey,
      /*[out,retval]*/ IDispatch** ppDispatch
                     )
    {
        _ASSERT( NULL != pKey && NULL != ppDispatch );
        if ( NULL == pKey || NULL == ppDispatch )
        { return E_POINTER; }

        if ( VT_BSTR != V_VT(pKey)  )
        { return E_INVALIDARG; }

        // Locate requested item
        ElementMapIterator p = m_Elements.find(::_wcsupr (V_BSTR(pKey)));
        if ( p != m_Elements.end() )
        {
            (*ppDispatch = (*p).second)->AddRef();
        }
        else
        {
            return DISP_E_MEMBERNOTFOUND;
        }
        return S_OK;
    }

    //////////////////////////////////////////////////////////////////////////
    STDMETHODIMP get__NewEnum(
              /*[out,retval]*/ IUnknown** ppEnumVARIANT
                             )
    {
        _ASSERT( ppEnumVARIANT );
        if ( NULL == ppEnumVARIANT )
            return E_POINTER;

        _ASSERT( (IUnknown*)m_pEnumVARIANT );
        (*ppEnumVARIANT = m_pEnumVARIANT)->AddRef();

        return S_OK;
    }        



    //////////////////////////////////////////////////////////////////////////
    // Initialization function invoked by component factory

    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              ) throw(_com_error)
    {

        // Get the enumeration from the property bag
        _variant_t vtEnum;
        if ( ! pPropertyBag->get(PROPERTY_ELEMENT_ENUM, &vtEnum) )
            throw _com_error(E_FAIL);

        // Get the element count in the enumeration
        _variant_t vtCount;
        if ( ! pPropertyBag->get(PROPERTY_ELEMENT_COUNT, &vtCount) )
            throw _com_error(E_FAIL);

        // Now index the collection 
        CComPtr<IEnumVARIANT> pEnum;
        HRESULT hr = (V_UNKNOWN(&vtEnum))->QueryInterface(IID_IEnumVARIANT, (void**)&pEnum);
        if ( SUCCEEDED(hr) )
        {
            _bstr_t        bstrElementID = PROPERTY_ELEMENT_ID;
            DWORD        dwRetrieved = 1;
            _variant_t    vtDispatch;

            hr = pEnum->Next(1, &vtDispatch, &dwRetrieved);
            while ( S_OK == hr )
            {
                if ( S_OK == hr )
                {
                    CComPtr<IWebElement> pItem;
                    hr = vtDispatch.pdispVal->QueryInterface(IID_IWebElement, (void**)&pItem);
                    if ( FAILED(hr) )
                    { throw _com_error(hr); }

                    _variant_t vtElementID;
                    hr = pItem->GetProperty(bstrElementID, &vtElementID);
                    if ( FAILED(hr) )
                    { throw _com_error(hr); }

                    pair <ElementMapIterator, bool> thePair =  
                    m_Elements.insert (ElementMap::value_type(::_wcsupr (V_BSTR(&vtElementID)), pItem)); 
                    if (false == thePair.second) 
                    { throw _com_error(E_FAIL); }
                }
                vtDispatch.Clear();
                hr = pEnum->Next(1, &vtDispatch, &dwRetrieved);
            }
            if ( S_FALSE == hr )
            {
                pEnum->Reset ();
                m_lCount = V_I4(&vtCount);
                m_pEnumVARIANT = V_UNKNOWN(&vtEnum);
                hr = S_OK;
            }
            else
            {
                ElementMapIterator p = m_Elements.begin();
                while ( p != m_Elements.end() )
                { p = m_Elements.erase(p); }                
            }
        }
        return hr;
    }

private:

    typedef map< wstring, CComPtr<IWebElement> >     ElementMap;
    typedef ElementMap::iterator                     ElementMapIterator;

    CComPtr<IUnknown>        m_pEnumVARIANT;
    LONG                    m_lCount;
    ElementMap                m_Elements;
};

#endif // __INC_ELEMENT_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\elementobject.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      elementobject.cpp
//
// Project:     Chameleon
//
// Description: Chameleon ASP UI Element Object
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "elementmgr.h"
#include "ElementObject.h"

//////////////////////////////////////////////////////////////////////////
// IWebElement Interface Implementation

STDMETHODIMP CElementObject::GetProperty(
                                 /*[in]*/ BSTR     bstrName, 
                                /*[out]*/ VARIANT* pValue
                                        )
{
    // TODO: Add RAS Tracing....
    _ASSERT( bstrName != NULL && pValue != NULL );
    if ( bstrName == NULL || pValue == NULL )
        return E_POINTER;

    HRESULT hr = E_FAIL;
    try
    {
        // Check if we produced the ID ourselves
        if ( ! lstrcmp(bstrName, PROPERTY_ELEMENT_ID) )
        {
            if ( VT_EMPTY != V_VT(&m_vtElementID) )
            {
                hr = VariantCopy(pValue, &m_vtElementID);
                return hr;
            }
        }

        // Because we're dealing with name value pairs, the names of the
        // element definition items cannot collide with the names of the
        // WMI class instance properties associated with the element... 

        hr = m_pWebElement->GetProperty(bstrName, pValue);
        if ( DISP_E_MEMBERNOTFOUND == hr )
        {
            // Not an element definition property so try the Wbem object
            // associated with this element object
            if ( (IWbemClassObject*)m_pWbemObj )
            {
                hr = m_pWbemObj->Get(
                                     bstrName, 
                                     0, 
                                     pValue, 
                                     NULL, 
                                     NULL
                                    );
            }
        }
    }
    catch(_com_error theError)
    {
        hr = theError.Error();
    }
    catch(...)
    {
        hr = E_UNEXPECTED;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// Initialization function invoked by component factory

HRESULT CElementObject::InternalInitialize(
                                   /*[in]*/ PPROPERTYBAG pPropertyBag
                                          )
{
    _ASSERT( pPropertyBag.IsValid() );
    _variant_t vtPropertyValue;

    // Get the element id (if present)
    pPropertyBag->get(PROPERTY_ELEMENT_ID, &m_vtElementID);

    // Get the element definition reference
    if ( ! pPropertyBag->get(PROPERTY_ELEMENT_WEB_DEFINITION, &vtPropertyValue) )
    { throw _com_error(E_FAIL); }

    m_pWebElement = (IWebElement*) V_UNKNOWN(&vtPropertyValue);
    vtPropertyValue.Clear();

    // Get the WBEM object reference (if present)
    if ( pPropertyBag->get(PROPERTY_ELEMENT_WBEM_OBJECT, &vtPropertyValue) )
    {
        if ( VT_EMPTY != V_VT(&vtPropertyValue) && VT_NULL != V_VT(&vtPropertyValue) )
        { m_pWbemObj = (IWbemClassObject*) V_UNKNOWN(&vtPropertyValue); }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\elementobject.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      elementobject.h
//
// Project:     Chameleon
//
// Description: Chameleon ASP UI Element Object
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_ELEMENT_OBJECT_H_
#define __INC_ELEMENT_OBJECT_H_

#include "resource.h" 
#include "elementcommon.h"
#include "elementmgr.h"     
#include "componentfactory.h"
#include "propertybag.h"
#include <wbemcli.h>
#include <comdef.h>
#include <comutil.h>

#pragma warning( disable : 4786 )
#include <map>
using namespace std;

#define        CLASS_ELEMENT_OBJECT    L"CElementObject"

/////////////////////////////////////////////////////////////////////////////
// CElementDefinition

class ATL_NO_VTABLE CElementObject : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IWebElement, &IID_IWebElement, &LIBID_ELEMENTMGRLib>
{

public:
    
    CElementObject() { }
    ~CElementObject() { }

BEGIN_COM_MAP(CElementObject)
    COM_INTERFACE_ENTRY(IWebElement)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CElementObject, IWebElement)

public:

    //////////////////////////////////////////////////////////////////////////
    // IWebElement Interface

    STDMETHOD(GetProperty)(
                   /*[in]*/ BSTR     bstrName, 
                  /*[out]*/ VARIANT* pValue
                          );

    //////////////////////////////////////////////////////////////////////////
    // Initialization function invoked by component factory

    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              ) throw(_com_error);

private:

    typedef enum { INVALID_KEY_VALUE = 0xfffffffe };

    _variant_t                    m_vtElementID;
    CComPtr<IWebElement>        m_pWebElement;
    CComPtr<IWbemClassObject>    m_pWbemObj;
};

#endif // __INC_ELEMENT_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by elementmgr.rc
//
#define IDS_SERVICENAME                 100
#define IDR_Elementmgr                  100
#define IDR_ELEMENTDEFINITION           101
#define IDR_ELEMENTRETRIEVER            102
#define IDS_ELEMENTOBJECT_DESC          103
#define IDR_ElementObject               104
#define IDS_SERVICENICENAME             106

//
// function stub IDs
//
#define IDS_HTML_FUNCTION_START         256
#define IDS_ERROR_FUNCTION_START        257
#define IDS_HTML_FUNCTION_END           258
#define IDS_ERROR_FUNCTION_END          259

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\elementretriever.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      elementretriever.h
//
// Project:     Chameleon
//
// Description: Chameleon ASP UI Element Retriever
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_ELEMENT_RETRIEVER_H_
#define __INC_ELEMENT_RETRIEVER_H_

#include "resource.h"
#include "elementcommon.h"
#include <comdef.h>
#include <comutil.h>
#include <wbemcli.h>
#include <atlctl.h>

#pragma warning( disable : 4786 )
#include <string>
#include <list>
#include <vector>
#include <map>
using namespace std;

class SortByProperty;    // Forward declaration

/////////////////////////////////////////////////////////////////////////////
// CElementRetriever

class ATL_NO_VTABLE CElementRetriever : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CElementRetriever, &CLSID_ElementRetriever>,
    public IDispatchImpl<IWebElementRetriever, &IID_IWebElementRetriever, &LIBID_ELEMENTMGRLib>,
    public IObjectSafetyImpl<CElementRetriever>
{
public:

    CElementRetriever(); 

    ~CElementRetriever();

DECLARE_CLASSFACTORY_SINGLETON(CElementRetriever)

DECLARE_REGISTRY_RESOURCEID(IDR_ELEMENTRETRIEVER)

DECLARE_NOT_AGGREGATABLE(CElementRetriever)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CElementRetriever)
    COM_INTERFACE_ENTRY(IWebElementRetriever)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

    //
    // This interface is implemented to mark the component as safe for scripting
    // IObjectSafety interface methods
    //
    STDMETHOD(SetInterfaceSafetyOptions)
                        (
                        REFIID riid, 
                        DWORD dwOptionSetMask, 
                        DWORD dwEnabledOptions
                        )
    {
        HRESULT hr = CoImpersonateClient();
  
        if (FAILED(hr))
        {
            return hr;

        }

        BOOL bSuccess = IsOperationAllowedForClient();

        return bSuccess? S_OK : E_FAIL;
    }

    /////////////////////////////////
    // IWebElementRetriever Interface
    /////////////////////////////////

    STDMETHOD(GetElements)(
                   /*[in]*/ LONG        lWebElementType,
                   /*[in]*/ BSTR        bstrContainerName, 
          /*[out, retval]*/ IDispatch** ppElementEnum
                          );

    STDMETHOD (Initialize) ()
    {
        HRESULT hr = S_OK;
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();
        }
        return (hr);
    }

    STDMETHOD (Shutdown)  ()
    {
        return (S_OK);
    }
    

private:

    friend class SortByProperty;

    // Dissallow copy and assignment

    CElementRetriever(const CElementRetriever& rhs);
    CElementRetriever& operator = (const CElementRetriever& rhs);

    //////////////////////////////////////////////////////////////////////////
    typedef vector<_variant_t>                     ElementList;
    typedef list<IWebElement*>                     EmbeddedElementList;
    typedef map< wstring, EmbeddedElementList >  EmbeddedElementMap;
    typedef EmbeddedElementMap::iterator         EmbeddedElementMapIterator;

    //////////////////////////////////////////////////////////////////////////
    HRESULT InternalInitialize(void);

    bool    GetWMIConnection(
                     /*[in]*/ IWbemServices** ppWbemServcies
                            );

    HRESULT BuildElementDefinitions(void);

    void    FreeElementDefinitions(void);

    HRESULT GetPageElements(
                    /*[in]*/ LPCWSTR      szContainer,
                    /*[in]*/ ElementList& theElements
                           ) throw (_com_error);

    HRESULT GetElementDefinitions(
                          /*[in]*/ LPCWSTR        szContainer,
                          /*[in]*/ ElementList& TheElements
                                 ) throw (_com_error);

    //
    // 
    // IsOperationAllowedForClient - This function checks the token of the 
    // calling thread to see if the caller belongs to the Local System account
    // 
    BOOL IsOperationAllowedForClient (
                                      VOID
                                     );

    //////////////////////////////////////////////////////////////////////////////
    // Element Definition Map

    typedef map< wstring, CComPtr<IWebElement> >     ElementMap;
    typedef ElementMap::iterator                     ElementMapIterator;

    //////////////////////////////////////////////////////////////////////////////
    // Member Data

    typedef enum { WMI_CONNECTION_MONITOR_POLL_INTERVAL = 5000 };

    // Element definition sort properties
    static _bstr_t            m_bstrSortProperty;

    // Element retriever state
    bool                    m_bInitialized;

    // Pointer to WMI services (WMI Connection)
    CComPtr<IWbemServices>    m_pWbemSrvcs;

    // Element Definitions
    ElementMap                m_ElementDefinitions;
};


// here we have the sorting class which is used to sort
// the element objects being returned to the user in
// acending order of the "Merit" property
//
class SortByMerit 
{

public:

    bool operator()(
                const  VARIANT& lhs,
                const  VARIANT& rhs
                )
    {
        IWebElement *pLhs = static_cast <IWebElement*> (V_DISPATCH (&lhs));
        IWebElement *pRhs = static_cast <IWebElement*> (V_DISPATCH (&rhs));

        _variant_t vtLhsMerit;
        HRESULT hr = pLhs->GetProperty (
                            _bstr_t (PROPERTY_ELEMENT_DEFINITION_MERIT), 
                            &vtLhsMerit
                            );
        if (FAILED (hr)){throw _com_error (hr);}

        _variant_t vtRhsMerit;
        hr = pRhs->GetProperty (
                            _bstr_t (PROPERTY_ELEMENT_DEFINITION_MERIT), 
                            &vtRhsMerit
                            );
        if (FAILED (hr)){throw _com_error (hr);}
                        

        return (V_I4 (&vtLhsMerit) < V_I4 (&vtRhsMerit));
    }

};   //  end of SortByMerit class

// here we have the sorting class which is used to sort
// the element objects being returned to the user in
// acending order by a specified property
//
//////////////////////////////////////////////////////////////////////////////
class SortByProperty 
{

public:

    bool operator()(
                     const  VARIANT& lhs,
                     const  VARIANT& rhs
                   )
    {
        bool bRet = false;
        VARTYPE vtSortType;

        IWebElement *pLhs = static_cast <IWebElement*> (V_DISPATCH (&lhs));
        IWebElement *pRhs = static_cast <IWebElement*> (V_DISPATCH (&rhs));

        _variant_t vtLhsValue;
        HRESULT hr = pLhs->GetProperty (
                                        CElementRetriever::m_bstrSortProperty, 
                                        &vtLhsValue
                                       );
        if ( FAILED (hr) ) 
        {
            throw _com_error (hr);
        }
        vtSortType = V_VT(&vtLhsValue);

        _variant_t vtRhsValue;
        hr = pRhs->GetProperty (
                                CElementRetriever::m_bstrSortProperty, 
                                &vtRhsValue
                               );
        if ( FAILED (hr) ) 
        { 
            throw _com_error (hr);
        }
        _ASSERT( V_VT(&vtRhsValue) == vtSortType );
        if ( V_VT(&vtRhsValue) != vtSortType )
        {
            throw _com_error(E_UNEXPECTED);
        }

        switch ( vtSortType )
        {
            case VT_UI1:
                bRet = ( V_UI1(&vtLhsValue) < V_UI1(&vtRhsValue) );
                break;

            case VT_I4:    
                bRet = ( V_I4(&vtLhsValue) < V_I4(&vtRhsValue) );
                break;
            
            case VT_R4:
                bRet = ( V_R4(&vtLhsValue) < V_R4(&vtRhsValue) );
                break;

            case VT_R8:
                bRet = ( V_R8(&vtLhsValue) < V_R8(&vtRhsValue) );
                break;

            case VT_BSTR:
                if ( 0 > lstrcmpi(V_BSTR(&vtLhsValue), V_BSTR(&vtRhsValue)) )
                {
                    bRet = true;
                }
                break;

            default:
                throw _com_error(E_UNEXPECTED);
                break;
        };

        return bRet;
    }

};   //  end of SortByProperty class




#endif // __INC_ELEMENT_RETRIEVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\elementretriever.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      elementretriever.cpp
//
// Project:     Chameleon
//
// Description: Chameleon ASP UI Element Retriever
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "elementmgr.h"
#include "elementretriever.h"
#include "elementobject.h"
#include "elementdefinition.h"
#include "elementenum.h"
#include "appmgrobjs.h"
#include <propertybagfactory.h>
#include <componentfactory.h>
#include <atlhlpr.h>
#include <wbemhlpr.h>
#include <algorithm>

//
// reg. sub-key for the location of Server Appliance Web Element
// definitions
//
const WCHAR WEB_DEFINITIONS_KEY[] =
 L"SOFTWARE\\Microsoft\\ServerAppliance\\ElementManager\\WebElementDefinitions";


//
// this is the registry subkey for the WWW root on the machine
//
const WCHAR W3SVC_VIRTUALROOTS_KEY[] =
 L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots";

//
// registry key value names
//
const WCHAR ASP_PATH_NAME[] = L"PathName";

//
// default web root path, used when we can not get value from registry
//
const WCHAR DEFAULT_WEB_ROOT_PATH [] =
                 L"\\ServerAppliance\\Web,,5";

//
// maximum length of the buffers
//
const DWORD MAX_BUFFER_LENGTH  = 1024;

//
// every asp file created should have this appended at the end
//
const WCHAR ASP_NAME_END [] = L"_embed.asp";

//
// HTML function name
//
const CHAR HTML_FUNCTION_START[] = "\t\tGetEmbedHTML = GetHTML_";
const CHAR HTML_FUNCTION_END[] = "(Element,ErrCode)";

//
// Error function anme
//
const CHAR ERROR_FUNCTION_NAME[] = "HandleError()";

//
// case statement string
//
const CHAR CASE_STRING [] = "\tCase";

//
// delimter between tokens
//
const CHAR SPACE[] = " ";

//
// double quotation
//
const CHAR DOUBLEQUOTE[] = "\"";


//
// File name delimiter
//
const CHAR DASH[] = "_";


//
// new line marker
//
const CHAR NEWLINE[] = "\r\n";



//////////////////////////////////////////////////////////////////////////////
//
// Function:    CElementRetriever
//
// Synopsis:    Constructor
//
//////////////////////////////////////////////////////////////////////////////
CElementRetriever::CElementRetriever()
: m_bInitialized(false)
{

}


//////////////////////////////////////////////////////////////////////////////
//
// Function:    ~CElementRetriever
//
// Synopsis:    Destructor
//
//////////////////////////////////////////////////////////////////////////////
CElementRetriever::~CElementRetriever()
{
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    InternalInitialize()
//
// Synopsis:    Element Retriever initialization function
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CElementRetriever::InternalInitialize()
{
    HRESULT hr = E_FAIL;
    _ASSERT ( ! m_bInitialized );

    SATraceString ("The Element Retriever is initializing...");

    try
    {
        do
        {
            // Start the WMI connection monitoring thread
            SATraceString ("The Element Retriever is building the element definitions...");
            hr = BuildElementDefinitions();
            if ( FAILED(hr) )
            {
                SATracePrintf ("CElementRetriever::InternalInitialize() - Failed - BuildElementDefinitions() returned: %lx", hr);
                break;     
            }
        } while ( FALSE );

        SATraceString ("The Element Retriever successfully initialized...");
    }
    catch(_com_error theError)
    {
        hr = theError.Error();
    }
    catch(...)
    {
        hr = E_FAIL;
    }
    
    if ( FAILED(hr) )
    {
        SATraceString ("The Element Retriever failed to initialize...");
        FreeElementDefinitions();
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Function:    GetWMIConnection
//
// Synopsis:    Retrieve a reference to our WMI connection. Works in 
//                conjunction with the WMIConnectionMonitor function
//
//////////////////////////////////////////////////////////////////////////////
bool
CElementRetriever::GetWMIConnection(
                            /*[in]*/ IWbemServices** ppWbemServices
                                   )
{
    HRESULT hr;
    CLockIt theLock(*this);
    if ( NULL == (IUnknown*) m_pWbemSrvcs )
    {
        hr = ConnectToWM(&m_pWbemSrvcs);
        if ( FAILED(hr) )
        {
            SATracePrintf("CElementRetriever::GetWMIConnection() - Failed - ConnectToWM() returned: %lx", hr);
            return false;
        }
    }
    else
    {
        // Ping...
        static _bstr_t bstrPathAppMgr = CLASS_WBEM_APPMGR;
        CComPtr<IWbemClassObject> pWbemObj;
        hr = m_pWbemSrvcs->GetObject(
                                        bstrPathAppMgr,
                                        0,
                                        NULL,
                                        &pWbemObj,
                                        NULL
                                    );
        if ( FAILED(hr) )
        {
            // Reestablish connection
            hr = ConnectToWM(&m_pWbemSrvcs);
            if ( FAILED(hr) )
            {
                SATracePrintf("CElementRetriever::GetWMIConnection() - Failed - ConnectToWM() returned: %lx", hr);
                return false;
            }
        }
    }
    *ppWbemServices = (IWbemServices*) m_pWbemSrvcs;
    return true;
}


//////////////////////////////////////////////////////////////////////////////
//
// The following registry structure is assumed:
//
// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ServerAppliance\ElementManager
//
// WebElementDefinitions
//       |
//        - ElementDefinition1
//       |     |
//       |      - Property1
//       |     |
//       |      - PropertyN
//       |
//        - ElementDefinition2
//       |    |
//       |     - Property1
//       |    |
//       |     - PropertyN
//       |
//        - ElementDefinitionN
//            |
//             - Property1
//            |
//             - PropertyN
//
// Each element definition contains the following properties:
//
// 1) "Container"      - Container that holds this element
// 2) "Merit"          - Order of element in the container starting from 1 (value of 0 means no order specified)
// 3) "IsEmbedded"     - Set to 1 to indicate that the element is embedded - Otherwise element is a link
// 4) "ObjectClass     - Class name of the related WBEM class
// 5) "ObjectKey"      - Instance name of the related WBEM class (optional property)
// 6) "URL"            - URL for the page when the associated link is selected
// 7) "CaptionRID"     - Resource ID for the element caption
// 8) "DescriptionRID" - Resource ID for the element link description
// 9) "ElementGraphic" - Graphic (file) associated with the element (bitmap, icon, etc.)
//
//////////////////////////////////////////////////////////////////////////////

// Element Manager registry key location
const wchar_t szWebDefinitions[] = L"SOFTWARE\\Microsoft\\ServerAppliance\\ElementManager\\WebElementDefinitions";

//////////////////////////////////////////////////////////////////////////
//
// Function:    BuildElementDefinitions()
//
// Synopsis:    Construct the collection of element definitions
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CElementRetriever::BuildElementDefinitions()
{
    do
    {
      // Create the collection of element definitions
        CLocationInfo LocInfo(HKEY_LOCAL_MACHINE, szWebDefinitions);
        PPROPERTYBAGCONTAINER pBagC = ::MakePropertyBagContainer(
                                                                 PROPERTY_BAG_REGISTRY,
                                                                 LocInfo
                                                                );
        if ( ! pBagC.IsValid() )
        { throw _com_error(E_FAIL); }

        if ( ! pBagC->open() )
        { throw _com_error(E_FAIL); }

        pBagC->reset();

        do
        {
            PPROPERTYBAG pBag = pBagC->current();
            if ( ! pBag.IsValid() )
            { throw _com_error(E_FAIL); }

            if ( ! pBag->open() )
            { throw _com_error(E_FAIL); }

            // For element definitions, the name and the key are synonomous since the
            // definition exists for the life of the service. For element page objects
            // the key is generated when the object is created.

            _variant_t vtElementKey = pBag->getName();
            if ( NULL == V_BSTR(&vtElementKey) )
            { throw _com_error(E_FAIL); }

            if ( ! pBag->put(PROPERTY_ELEMENT_ID, &vtElementKey) )
            { throw _com_error(E_FAIL); }
                
            CComPtr<IWebElement> pElement = (IWebElement*) ::MakeComponent(
                                                                             CLASS_ELEMENT_DEFINITION,
                                                                            pBag
                                                                          );
            if ( NULL != (IWebElement*)pElement )
            { 
                pair<ElementMapIterator, bool> thePair = 
                m_ElementDefinitions.insert(ElementMap::value_type(pBag->getName(), pElement));
                if ( false == thePair.second )
                { throw _com_error(E_FAIL); }
            }

        } while ( pBagC->next() );

        m_bInitialized = true;

    } while ( FALSE );

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    FreeElementDefinitions()
//
// Synopsis:    Free the collection of element definitions
//
//////////////////////////////////////////////////////////////////////////////
void CElementRetriever::FreeElementDefinitions()
{
    ElementMapIterator p = m_ElementDefinitions.begin();
    while ( p != m_ElementDefinitions.end() )
    { p = m_ElementDefinitions.erase(p); }
}

///////////////////////////////////////////////////////////////////////////////
//
// Function:    GetElements()
//
// Synopsis:    IWebElementRetriever interface implmentation
//
//////////////////////////////////////////////////////////////////////////////

_bstr_t CElementRetriever::m_bstrSortProperty;

STDMETHODIMP CElementRetriever::GetElements(
                                    /*[in]*/ LONG        lElementType,
                                    /*[in]*/ BSTR        bstrContainerName, 
                                   /*[out]*/ IDispatch** ppElementEnum
                                           )
{
    _ASSERT( bstrContainerName && ppElementEnum );
    if ( NULL == bstrContainerName || NULL == ppElementEnum )
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    
    CLockIt theLock(*this);

    try
    {
        do
        {
            // TODO: Speed this up and use an STL list...
            vector<_variant_t> TheElements; // With apologies to Euclid...
            // Load the element definitions the first time someone calls GetElements
            // TODO: Change this mechanism if it ends up being a performance issue.
            if ( ! m_bInitialized )
            {
                hr = InternalInitialize();
                if ( FAILED(hr) )
                    break;
            }

            //CHAR szContainerName[MAX_PATH];
            //::wcstombs (szContainerName, bstrContainerName, MAX_PATH);
             
            // Get the requested definitions or objects
            SATracePrintf("lElementType = %ld", lElementType);
            if ( WEB_ELEMENT_TYPE_DEFINITION == lElementType )
            {
                SATracePrintf ("Get Elements called for definition with container name: %s", 
                            (const char*)_bstr_t(bstrContainerName));

                hr = GetElementDefinitions(bstrContainerName, TheElements);
                if ( FAILED(hr) )
                { break; }
            }
            else if ( WEB_ELEMENT_TYPE_PAGE_OBJECT == lElementType )
            {
                SATracePrintf ("Get Elements called for page elements with container name: %s", 
                            (const char*)_bstr_t(bstrContainerName));

                hr = GetPageElements(bstrContainerName, TheElements);
                if ( FAILED(hr) )
                { break; }
            }
            else
            { 
                _ASSERT(FALSE);
                hr = E_INVALIDARG;
                break;
            }

            // Create the element component enumerator
            auto_ptr <EnumVARIANT> newEnum (new CComObject<EnumVARIANT>);
            if ( newEnum.get() == NULL )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            
            // Sort the elements in the vector by merit (declaritive) value
            std::sort (TheElements.begin (), TheElements.end (), SortByMerit());
            
            hr = newEnum->Init(
                               TheElements.begin(),
                               TheElements.end(),
                               static_cast<IUnknown*>(this),
                               AtlFlagCopy
                              );
            if ( FAILED(hr) )
            { break; }
            
            CLocationInfo LocInfo;
            PPROPERTYBAG pBag = ::MakePropertyBag(
                                                   PROPERTY_BAG_REGISTRY,
                                                   LocInfo
                                                 );
            if ( ! pBag.IsValid() )
            { 
                hr = E_FAIL;
                break;
            }

            SATracePrintf ("Total number of elements / definitions found: %d", (LONG)TheElements.size());

            // Put the element count in the property bag
            _variant_t vtCount ((LONG) TheElements.size());
            if ( ! pBag->put( PROPERTY_ELEMENT_COUNT, &vtCount) )
            {
                hr = E_FAIL;
                break;
            }
            
            // put the enumaration as a property in the propertybag
            _variant_t vtEnum = static_cast <IEnumVARIANT*> (newEnum.release());
            if ( ! pBag->put( PROPERTY_ELEMENT_ENUM, &vtEnum) )
            {
                hr = E_FAIL;
                break;
            }

            // Make the  ElementEnum object
            CComPtr<IDispatch> pEnum = (IDispatch*) ::MakeComponent(
                                                                       CLASS_ELEMENT_ENUM,
                                                                      pBag
                                                                   );
            if ( NULL == pEnum.p )
            {
                hr = E_FAIL;
                break;
            }
            (*ppElementEnum = pEnum)->AddRef();

        } while ( FALSE );
    }
    catch(_com_error theError)
    {
        hr = theError.Error();
    }
    catch(...)
    {
        hr = E_FAIL;
    }

    if (FAILED (hr))
    {
        SATracePrintf ("Unable to retrieve the request elements:%x",hr);
    }

    return hr;
}


const _bstr_t bstrElemDefContainer = PROPERTY_ELEMENT_DEFINITION_CONTAINER;
const _bstr_t bstrElemDefClass = PROPERTY_ELEMENT_DEFINITION_CLASS;
const _bstr_t bstrElemDefKey = PROPERTY_ELEMENT_DEFINITION_KEY;
const _bstr_t bstrElementID = PROPERTY_ELEMENT_ID;

///////////////////////////////////////////////////////////////////////////////
//
// Function:    GetPageElements()
//
// Synopsis:    Retrieve the set of page element components whose container
//                property matches the given container 
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CElementRetriever::GetPageElements(
                                   /*[in]*/ LPCWSTR         szContainer,
                                   /*[in]*/ ElementList& TheElements
                                          )
{
    // FOR each matching page element definition DO
    //     Create a property bag
    //     Put the IWebElement interface pointer of the matching element into the property bag
    //     IF a WMI class is specified but no instance key THEN
    //          FOR each instance returned by WMI DO
    //              Put the IWbemClassObject interface for the instance into the property bag
    //                Create an element object
    //                Add the element object to the list
    //          END DO
    //     ELSE IF both a WMI class and instance key are specified
    //            Get the specified instance from WMI
    //          Put the IWbemClassObject interface for the instance into the property bag
    //            Create an element object
    //            Add the element object to the list
    //     ELSE (no associated WMI object)
    //            Create an element object
    //            Add the element object to the list
    //     END IF
    // END DO

    wchar_t szKey[64];

    ElementMapIterator p = m_ElementDefinitions.begin();
    while ( p != m_ElementDefinitions.end() )
    {
        {
            // Get the container for the current definition
            _variant_t vtPropertyValue;
            HRESULT hr = ((*p).second)->GetProperty(bstrElemDefContainer, &vtPropertyValue);
            if ( FAILED(hr) )
            { throw _com_error(hr); }

            // Is it the container we're looking for?
            if ( ! lstrcmpi(szContainer, V_BSTR(&vtPropertyValue)) )
            {
                // Yes... Create a property bag and put a reference to the
                // definition in the property bag. We'll use the property
                // bag when creating the element page component below...
                CLocationInfo LocationInfo;
                PPROPERTYBAG pBag = ::MakePropertyBag(PROPERTY_BAG_REGISTRY, LocationInfo);
                if ( ! pBag.IsValid() )
                { throw _com_error(E_FAIL); }

                _variant_t vtWebElement = (IUnknown*)((*p).second);
                if ( ! pBag->put(PROPERTY_ELEMENT_WEB_DEFINITION, &vtWebElement) )
                { throw _com_error(E_FAIL); }

                // Does the element have an associated WMI object?
                vtPropertyValue.Clear();
                hr = ((*p).second)->GetProperty(bstrElemDefClass, &vtPropertyValue);
                if ( FAILED(hr) && DISP_E_MEMBERNOTFOUND != hr )
                { throw _com_error(hr); }

                if ( DISP_E_MEMBERNOTFOUND != hr )
                {
                    // Yes... Get our WMI connection
                    IWbemServices* pWbemSrvcs;
                    if ( ! GetWMIConnection(&pWbemSrvcs) )
                    { throw _com_error(E_FAIL); }
                            
                    // Was a specific WMI object identified?
                    _bstr_t bstrObjPath = V_BSTR(&vtPropertyValue);
                    vtPropertyValue.Clear();
                    hr = ((*p).second)->GetProperty(bstrElemDefKey, &vtPropertyValue);
                    if ( FAILED(hr) && DISP_E_MEMBERNOTFOUND != hr )
                    { throw _com_error(hr); }

                    if ( DISP_E_MEMBERNOTFOUND == hr )
                    {
                        // No... a specific WMI object was not identified so enum 
                        // each occurrence of the specified WMI class and
                        // for each class found create an element page component 

                        // Variables used to produce a unique ID for each page component
                        int     i = 0;
                        wchar_t szID[32];

                        _variant_t vtElementID;
                        hr = ((*p).second)->GetProperty(bstrElementID, &vtElementID);
                        if ( FAILED(hr) )
                        { throw _com_error(hr); }

                        CComPtr<IEnumWbemClassObject> pWbemEnum;
                        hr = pWbemSrvcs->CreateInstanceEnum(
                                                             bstrObjPath, 
                                                             0,
                                                             NULL,
                                                             &pWbemEnum
                                                           );
                        if ( FAILED(hr) )
                        { throw _com_error(hr); }

                        ULONG ulReturned;
                        CComPtr <IWbemClassObject> pWbemObj;
                        hr = pWbemEnum->Next(
                                             WBEM_INFINITE,
                                             1,
                                             &pWbemObj,
                                             &ulReturned
                                            );

                        while ( WBEM_S_NO_ERROR == hr )
                        {
                            {
                                // Create the element page component. Note that each component 
                                // is associated with an element definition and possibly 
                                // with a WMI object instance.

                                _variant_t vtInstance = (IUnknown*)pWbemObj;
                                if ( ! pBag->put(PROPERTY_ELEMENT_WBEM_OBJECT, &vtInstance) )
                                { throw _com_error(E_FAIL); }

                                // Generate the unique element ID 
                                _bstr_t bstrUniqueID = V_BSTR(&vtElementID);
                                bstrUniqueID += L"_";
                                bstrUniqueID += _itow(i, szID, 10);
                                _variant_t vtUniqueID = bstrUniqueID;
                                // Next unique ID
                                i++;

                                if ( ! pBag->put(PROPERTY_ELEMENT_ID, &vtUniqueID) )
                                { throw _com_error(E_FAIL); }

                                CComPtr<IWebElement> pElement = (IWebElement*) ::MakeComponent(
                                                                                               CLASS_ELEMENT_OBJECT, 
                                                                                               pBag
                                                                                              );
                                if ( NULL == pElement.p )
                                { throw _com_error(E_OUTOFMEMORY); }

                                // Add the newly created element page component to the list 
                                TheElements.push_back(pElement.p);
                                pWbemObj.Release();

                                hr = pWbemEnum->Next(
                                                     WBEM_INFINITE,
                                                     1,
                                                     &pWbemObj,
                                                     &ulReturned
                                                    );
                            }
                        }
                        if ( FAILED(hr) )
                        { throw _com_error(hr); }
                    }
                    else
                    {
                        // Yes... a specific WMI object was identified... Ask WMI for 
                        // the object... If the object cannot be found then return an error
                        bstrObjPath += L"=\"";
                        bstrObjPath += V_BSTR(&vtPropertyValue);
                        bstrObjPath += L"\"";
                        CComPtr<IWbemClassObject> pWbemObj;
                        hr = pWbemSrvcs->GetObject(
                                                    bstrObjPath,
                                                    0,
                                                    NULL,
                                                    &pWbemObj,
                                                    NULL
                                                  );
                        if ( SUCCEEDED(hr) )
                        {
                            // Create a new page element component.
                            _variant_t vtInstance = (IUnknown*)pWbemObj;
                            if ( ! pBag->put(PROPERTY_ELEMENT_WBEM_OBJECT, &vtInstance) )
                            { throw _com_error(E_FAIL); }

                            CComPtr<IWebElement> pElement = (IWebElement*) ::MakeComponent(
                                                                                           CLASS_ELEMENT_OBJECT, 
                                                                                           pBag
                                                                                          );
                            if ( NULL == pElement.p )
                            { throw _com_error(E_OUTOFMEMORY); }

                            TheElements.push_back(pElement.p);
                        }
                    }
                }
                else
                {
                    // No WMI object is associated with the current element definition...
                    _variant_t vtInstance; // VT_EMPTY
                    if ( ! pBag->put(PROPERTY_ELEMENT_WBEM_OBJECT, &vtInstance) )
                        throw _com_error(E_FAIL);

                    CComPtr<IWebElement> pElement = (IWebElement*) ::MakeComponent(
                                                                                   CLASS_ELEMENT_OBJECT, 
                                                                                   pBag
                                                                                  );
                    if ( NULL == pElement.p )
                        throw _com_error(E_OUTOFMEMORY);

                    TheElements.push_back(pElement.p);
                }
            }
        }
        p++;
    }
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function:    GetPageElementDefinitions()
//
// Synopsis:    Retrieve the set of element defintion components whose 
//                container property matches the given container 
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CElementRetriever::GetElementDefinitions(
                                         /*[in]*/ LPCWSTR       szContainer,
                                         /*[in]*/ ElementList& TheElements
                                                )
{
    // FOR each matching page element definition DO
    //     Create an element object
    //       Add the element object to the list
    // END DO

    ElementMapIterator p = m_ElementDefinitions.begin();
    _bstr_t bstrPropertyName = PROPERTY_ELEMENT_DEFINITION_CONTAINER;
    while ( p != m_ElementDefinitions.end() )
    {
        _variant_t vtPropertyValue;
        HRESULT hr = ((*p).second)->GetProperty(bstrPropertyName, &vtPropertyValue);
        if ( FAILED(hr)) 
        { throw _com_error(hr); }

        if ( ! lstrcmpi(szContainer, V_BSTR(&vtPropertyValue)) )
        { TheElements.push_back((IUnknown*)((*p).second).p); }
        
        p++;
    }
    return S_OK;
}

//**********************************************************************
// 
// FUNCTION:  IsOperationAllowedForClient - This function checks the token of the 
//            calling thread to see if the caller belongs to the Local System account
// 
// PARAMETERS:   none
// 
// RETURN VALUE: TRUE if the caller is an administrator on the local
//            machine.  Otherwise, FALSE.
// 
//**********************************************************************
BOOL 
CElementRetriever::IsOperationAllowedForClient (
            VOID
            )
{

    HANDLE hToken = NULL;
    DWORD  dwStatus  = ERROR_SUCCESS;
    DWORD  dwAccessMask = 0;;
    DWORD  dwAccessDesired = 0;
    DWORD  dwACLSize = 0;
    DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
    PACL   pACL            = NULL;
    PSID   psidLocalSystem  = NULL;
    BOOL   bReturn        =  FALSE;

    PRIVILEGE_SET   ps;
    GENERIC_MAPPING GenericMapping;

    PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    CSATraceFunc objTraceFunc ("CElementRetriever::IsOperationAllowedForClient ");
       
    do
    {
        //
        // we assume to always have a thread token, because the function calling in
        // appliance manager will be impersonating the client
        //
        bReturn  = OpenThreadToken(
                               GetCurrentThread(), 
                               TOKEN_QUERY, 
                               TRUE, 
                               &hToken
                               );
        if (!bReturn)
        {
            SATraceFailure ("CElementRetriever::IsOperationAllowedForClient failed on OpenThreadToken:", GetLastError ());
            break;
        }


        //
        // Create a SID for Local System account
        //
        bReturn = AllocateAndInitializeSid (  
                                        &SystemSidAuthority,
                                        1,
                                        SECURITY_LOCAL_SYSTEM_RID,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        &psidLocalSystem
                                        );
        if (!bReturn)
        {     
            SATraceFailure ("CElementRetriever:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  GetLastError ());
            break;
        }
    
        //
        // get memory for the security descriptor
        //
        psdAdmin = HeapAlloc (
                              GetProcessHeap (),
                              0,
                              SECURITY_DESCRIPTOR_MIN_LENGTH
                              );
        if (NULL == psdAdmin)
        {
            SATraceString ("CElementRetriever::IsOperationForClientAllowed failed on HeapAlloc");
            bReturn = FALSE;
            break;
        }
      
        bReturn = InitializeSecurityDescriptor(
                                            psdAdmin,
                                            SECURITY_DESCRIPTOR_REVISION
                                            );
        if (!bReturn)
        {
            SATraceFailure ("CElementRetriever::IsOperationForClientAllowed failed on InitializeSecurityDescriptor:", GetLastError ());
            break;
        }

        // 
        // Compute size needed for the ACL.
        //
        dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                    GetLengthSid (psidLocalSystem);

        //
        // Allocate memory for ACL.
        //
        pACL = (PACL) HeapAlloc (
                                GetProcessHeap (),
                                0,
                                dwACLSize
                                );
        if (NULL == pACL)
        {
            SATraceString ("CElementRetriever::IsOperationForClientAllowed failed on HeapAlloc2");
            bReturn = FALSE;
            break;
        }

        //
        // Initialize the new ACL.
        //
        bReturn = InitializeAcl(
                              pACL, 
                              dwACLSize, 
                              ACL_REVISION2
                              );
        if (!bReturn)
        {
            SATraceFailure ("CElementRetriever::IsOperationForClientAllowed failed on InitializeAcl", GetLastError ());
            break;
        }


        // 
        // Make up some private access rights.
        // 
        const DWORD ACCESS_READ = 1;
        const DWORD  ACCESS_WRITE = 2;
        dwAccessMask= ACCESS_READ | ACCESS_WRITE;

        //
        // Add the access-allowed ACE to the DACL for Local System
        //
        bReturn = AddAccessAllowedAce (
                                    pACL, 
                                    ACL_REVISION2,
                                    dwAccessMask, 
                                    psidLocalSystem
                                    );
        if (!bReturn)
        {
            SATraceFailure ("CElementRetriever::IsOperationForClientAllowed failed on AddAccessAllowedAce (LocalSystem)", GetLastError ());
            break;
        }
              
        //
        // Set our DACL to the SD.
        //
        bReturn = SetSecurityDescriptorDacl (
                                          psdAdmin, 
                                          TRUE,
                                          pACL,
                                          FALSE
                                          );
        if (!bReturn)
        {
            SATraceFailure ("CElementRetriever::IsOperationForClientAllowed failed on SetSecurityDescriptorDacl", GetLastError ());
            break;
        }

        //
        // AccessCheck is sensitive about what is in the SD; set
        // the group and owner.
        //
        SetSecurityDescriptorGroup(psdAdmin, psidLocalSystem, FALSE);
        SetSecurityDescriptorOwner(psdAdmin, psidLocalSystem, FALSE);

        bReturn = IsValidSecurityDescriptor(psdAdmin);
        if (!bReturn)
        {
            SATraceFailure ("CElementRetriever::IsOperationForClientAllowed failed on IsValidSecurityDescriptorl", GetLastError ());
            break;
        }
     

        dwAccessDesired = ACCESS_READ;

        // 
        // Initialize GenericMapping structure even though we
        // won't be using generic rights.
        // 
        GenericMapping.GenericRead    = ACCESS_READ;
        GenericMapping.GenericWrite   = ACCESS_WRITE;
        GenericMapping.GenericExecute = 0;
        GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;
        BOOL bAccessStatus = FALSE;

        //
        // check the access now
        //
        bReturn = AccessCheck  (
                                psdAdmin, 
                                hToken, 
                                dwAccessDesired, 
                                &GenericMapping, 
                                &ps,
                                &dwStructureSize, 
                                &dwStatus, 
                                &bAccessStatus
                                );

        if (!bReturn || !bAccessStatus)
        {
            SATraceFailure ("CElementRetriever::IsOperationForClientAllowed failed on AccessCheck", GetLastError ());
        } 
        else
        {
            SATraceString ("CElementRetriever::IsOperationForClientAllowed, Client is allowed to carry out operation!");
        }

        //
        // successfully checked 
        //
        bReturn  = bAccessStatus;        
 
    }    
    while (false);

    //
    // Cleanup 
    //
    if (pACL) 
    {
        HeapFree (GetProcessHeap (), 0, pACL);
    }

    if (psdAdmin) 
    {
        HeapFree (GetProcessHeap (), 0, psdAdmin);
    }
          

    if (psidLocalSystem) 
    {
        FreeSid(psidLocalSystem);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return (bReturn);

}// end of CElementRetriever::IsOperationValidForClient method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\elementmgr.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      elementmgr.cpp
//
// Project:     Chameleon
//
// Description: Chameleon ASP UI Element Manager Service
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "elementmgr.h"
#include <stdio.h>
#include "ElementRetriever.h"
#include <satrace.h>

//
// prototypes of the initialize/shutdown methods
//
VOID DoElementMgrInitialize ();

VOID DoElementMgrShutdown();

// forward declaration for API to set Security 
//
DWORD
SetAclForComObject ( 
    /*[in]*/    PSECURITY_DESCRIPTOR pSD,
    /*[out]*/   PACL                *ppacl 
    );

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ElementRetriever, CElementRetriever)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

#define SERVICE_NAME            L"elementmgr"

#define EVENT_LOG_KEY            L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" SERVICE_NAME

#define    EVENT_SOURCE_EXTENSION    L"dll"

//////////////////////////////////////////////////////////////////////////////
inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    do
    {
        // Remove any previous service since it may point to
        // the incorrect file
        // Uninstall();

        // Add service entries
        UpdateRegistryFromResource(IDR_Elementmgr, TRUE);

        // Adjust the AppID for Local Server or Service
        CRegKey keyAppID;
        LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRes);
            break;
        }

        CRegKey key;
        lRes = key.Open(keyAppID, _T("{FEC47821-C444-11D2-90BA-00AA00A71DCA}"), KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRes);
            break;
        }

        key.DeleteValue(_T("LocalService"));
    
        if (bService)
        {
            key.SetValue(SERVICE_NAME, _T("LocalService"));
            key.SetValue(_T("-Service"), _T("ServiceParameters"));

            // Create the event message file registry entry. Assume the name of
            // the event message file is the same as the name of the service
            // executable except we replace the ".exe" extension by ".dll".
            WCHAR szFilePath[_MAX_PATH +1];
            DWORD dwResult = ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);
            if (0 == dwResult)
            {
                hr = HRESULT_FROM_WIN32(GetLastError ());
                break;
            }
            szFilePath[_MAX_PATH] = L'\0';

            WCHAR* pszExtension = wcschr(szFilePath, L'.');
            pszExtension++;
            lstrcpy(pszExtension, EVENT_SOURCE_EXTENSION);
            CRegKey EventLogKey;
            DWORD dwError = EventLogKey.Create(
                                                HKEY_LOCAL_MACHINE,
                                                 EVENT_LOG_KEY,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_SET_VALUE
                                              );
            if ( ERROR_SUCCESS != dwError) 
            {
                hr = HRESULT_FROM_WIN32(dwError);
                break;
            }
            dwError = EventLogKey.SetValue(szFilePath, L"EventMessageFile");
            if ( ERROR_SUCCESS != dwError ) 
            { 
                hr = HRESULT_FROM_WIN32(dwError);
                break;
            }

            // Create service
            Install();
        }

        // Add object entries
        hr = CComModule::RegisterServer(bRegTypeLib);

    } while ( FALSE );

    CoUninitialize();
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_Elementmgr, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer(&CLSID_ElementRetriever); //TRUE);
    CoUninitialize();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    CComModule::Init(p, h); //, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));
    LoadString(h, IDS_SERVICENICENAME, m_szServiceNiceName, sizeof(m_szServiceNiceName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

//////////////////////////////////////////////////////////////////////////////
LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}

//////////////////////////////////////////////////////////////////////////////
BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

//////////////////////////////////////////////////////////////////////////////
inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH +1];
    DWORD dwResult = ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);
    if (0 == dwResult)
    {
        return (FALSE);
    }
    szFilePath[_MAX_PATH] = L'\0';

    SC_HANDLE hService = ::CreateService(
        hSCM, m_szServiceName, m_szServiceNiceName,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, 
        SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Logging functions
///////////////////////////////////////////////////////////////////////////////

void CServiceModule::LogEvent(
                             /*[in]*/ WORD        wMsgType,
                             /*[in]*/ LONG        lMsgID,
                             /*[in]*/ DWORD        dwMsgParamCount,
                             /*[in]*/ LPCWSTR*    pszMsgParams,
                             /*[in]*/ DWORD        dwDataSize,
                             /*[in]*/ BYTE*        pData
                              )
{
    if ( m_bService )
    {
        // Get a handle to use with ReportEvent().
        HANDLE hEventSource = RegisterEventSource( NULL, m_szServiceName );
        if ( NULL != hEventSource )
        {
            // Write to event log.
            ReportEvent(
                         hEventSource, 
                         wMsgType, 
                         0, 
                         lMsgID, 
                         NULL, 
                         dwMsgParamCount, 
                         dwDataSize, 
                         pszMsgParams, 
                         pData
                       );

            // Free the event source
            DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        wchar_t szMsg[128] = L"Logged Event: ";
        wchar_t szEventID[16];
        lstrcat(szMsg, _itow(lMsgID, szEventID, 16));
        _putts(szMsg);
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

//////////////////////////////////////////////////////////////////////////////
inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
    {
        SATraceString ("Element Manager Service registration failed.");
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);
    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();
}

//////////////////////////////////////////////////////////////////////////////
inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    default:
        _ASSERT(FALSE);
    }
}

//////////////////////////////////////////////////////////////////////////////
void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}

//////////////////////////////////////////////////////////////////////////////
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}

//////////////////////////////////////////////////////////////////////////////
void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

//////////////////////////////////////////////////////////////////////////////
void CServiceModule::Run()
{
    _Module.dwThreadID = GetCurrentThreadId();

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    _ASSERTE(SUCCEEDED(hr));
    if ( SUCCEEDED(hr) )
    {
        // This provides a NULL DACL which will allow access to everyone.
        CSecurityDescriptor sd;
        sd.InitializeFromThreadToken();

        PACL pacl = NULL;
        //
        // 
        // Add ACLs to the SD using the builtin RIDs.
        //
        DWORD dwRetVal =  SetAclForComObject  ( 
                      (PSECURITY_DESCRIPTOR) sd.m_pSD,
                        &pacl        
                       );    
        if (ERROR_SUCCESS != dwRetVal)      {return;}

        hr = ::CoInitializeSecurity(
                                    sd, 
                                    -1, 
                                    NULL, 
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                                    RPC_C_IMP_LEVEL_IDENTIFY, 
                                    NULL, 
                                    EOAC_NONE, 
                                    NULL
                                   );
        _ASSERTE(SUCCEEDED(hr));
        if ( SUCCEEDED(hr) )
        {
            hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
            _ASSERTE(SUCCEEDED(hr));
            if (SUCCEEDED(hr) )
            {
                DoElementMgrInitialize ();

                if (m_bService) 
                {
                    SetServiceStatus(SERVICE_RUNNING);
                }

                MSG msg;
                while (GetMessage(&msg, 0, 0, 0))
                {
                    DispatchMessage(&msg);
                }

                SetServiceStatus(SERVICE_STOP_PENDING);
                DoElementMgrShutdown ();
                SetServiceStatus(SERVICE_STOPPED);
            }

            _Module.RevokeClassObjects();
        }

        //
        // cleanup
        //
        if (pacl) {LocalFree (pacl);}
        
        CoUninitialize();
    }
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(
                HINSTANCE hInstance, 
                HINSTANCE /*hPrevInstance*/, 
                LPTSTR lpCmdLine, 
                int /*nShowCmd*/
                )
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_ELEMENTMGRLib);
    _Module.m_bService = TRUE;

    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);
        
        // Register as Service
        if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);
        
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{FEC47821-C444-11D2-90BA-00AA00A71DCA}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    DoElementMgrInitialize()
//
// Synopsis:    Initialize the Element manager service
//
//////////////////////////////////////////////////////////////////////////////
void DoElementMgrInitialize(void)
{
    SATraceString ("Creating the Element Retriever...");

    // Appliance manager is a singleton so all the following code 
    // does is get a reference to the single instance 
    CComPtr<IWebElementRetriever> pElementRetriever;
    HRESULT hr =     ::CoCreateInstance(
                                        __uuidof (ElementRetriever),
                                        NULL,
                                        CLSCTX_LOCAL_SERVER,
                                        __uuidof (IWebElementRetriever),
                                        (PVOID*)&pElementRetriever
                                       );
    _ASSERT ( SUCCEEDED(hr) );
    if (SUCCEEDED(hr)) 
    {
         SATraceString ("Created Element Retriever (not initalized..");
        // hr = pElementRetriever->Initialize();
    }
    _ASSERT ( SUCCEEDED(hr) );
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    DoElementMgrShutdown()
//
// Synopsis:    Shutdown the appliance manager service
//
//////////////////////////////////////////////////////////////////////////////
void DoElementMgrShutdown(void)
{
    // ElementManager is a singleton so all the following code 
    // does is get a reference to the single instance 
    CComPtr<IWebElementRetriever> pElementRetriever;
    HRESULT hr = ::CoCreateInstance(
                                    __uuidof (ElementRetriever),
                                    NULL,
                                    CLSCTX_LOCAL_SERVER,
                                    __uuidof (IWebElementRetriever),
                                    (PVOID*)&pElementRetriever
                                   );
    if ( SUCCEEDED(hr) ) 
    {
        SATraceString ("Shutting down Element Retriever...");
        // pElementRetriever->Shutdown();
    }
    _ASSERT ( SUCCEEDED(hr) );
}

//++--------------------------------------------------------------
//
//  Function:   SetAclForComObject
//
//  Synopsis: method for providing only the Local System and Admins rights 
//             to access the COM object
//
//  Arguments:  none
//
//  Returns:    HRESULT
//
//  History:    MKarki      11/15/2001    Created
//			MKarki	 04/16/2002    Copied to Element Manager
//
//----------------------------------------------------------------
DWORD
SetAclForComObject ( 
    /*[in]*/    PSECURITY_DESCRIPTOR pSD,
    /*[out]*/   PACL                *ppacl 
    )
{    
    DWORD              dwError = ERROR_SUCCESS;
        int                         cbAcl = 0;
        PACL                    pacl = NULL;
        PSID                    psidLocalSystemSid = NULL;
     PSID                    psidAdminSid = NULL;
       SID_IDENTIFIER_AUTHORITY siaLocalSystemSidAuthority = SECURITY_NT_AUTHORITY;

    do
    {
        if (NULL == pSD)
        {
            SATraceString ("SetAclFromComObject - invalid parameter passed in");
            dwError = ERROR_INVALID_PARAMETER;
            break;
        }
            
        //
        // Create a SID for Local System account
        //
            BOOL bRetVal = AllocateAndInitializeSid (  
                            &siaLocalSystemSidAuthority,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0,
                            0,
                            0,
                            0,
                            0,
                          0,
                            0,
                            &psidLocalSystemSid 
                            );
        if (!bRetVal)
        {     
            dwError = GetLastError ();
                SATraceFailure ("SetAclFromComObject:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  dwError);
                break;
            }

        //
            // Create a SID for Admin group
            //
            bRetVal = AllocateAndInitializeSid (  
                            &siaLocalSystemSidAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &psidAdminSid
                            );
        if (!bRetVal)
        {      
            dwError = GetLastError ();
                SATraceFailure ("SetAclFromComObject:AllocateAndInitializeSid (Admin) failed",  dwError);
                break;
            }

        //
            // Calculate the length of required ACL buffer
            // with 2 ACEs.
            //
            cbAcl =     sizeof (ACL)
                            +   2 * sizeof (ACCESS_ALLOWED_ACE)
                            +   GetLengthSid( psidAdminSid )
                            +   GetLengthSid( psidLocalSystemSid );

            pacl = (PACL) LocalAlloc ( 0, cbAcl );
            if (NULL == pacl) 
            {
                dwError = ERROR_OUTOFMEMORY;
                SATraceFailure ("SetAclFromComObject::LocalAlloc failed:", dwError);
            break;
            }

        //
        // initialize the ACl now
        //
            bRetVal =InitializeAcl ( 
                        pacl,
                                cbAcl,
                                ACL_REVISION2
                                );
            if (!bRetVal)
            {
                 dwError = GetLastError();
            SATraceFailure ("SetAclFromComObject::InitializeAcl failed:", dwError);
                break;
            }

        //
            // Add ACE with EVENT_ALL_ACCESS for Local System account
            //
            bRetVal = AddAccessAllowedAce ( 
                            pacl,
                                        ACL_REVISION2,
                                        COM_RIGHTS_EXECUTE,
                                        psidLocalSystemSid
                                        );
        if (!bRetVal)
        {
                dwError = GetLastError();
                SATraceFailure ("SetAclFromComObject::AddAccessAllowedAce (LOCAL SYSTEM)  failed:", dwError);
            break;
        }

        //
            // Add ACE with EVENT_ALL_ACCESS for Admin Group
            //
            bRetVal = AddAccessAllowedAce ( 
                            pacl,
                                        ACL_REVISION2,
                                        COM_RIGHTS_EXECUTE,
                                        psidAdminSid
                                        );
        if (!bRetVal)
        {
                dwError = GetLastError();
                     SATraceFailure ("SetAclFromComObject::AddAccessAllowedAce (ADMIN) failed:", dwError);
            break;
        }

        //
            // Set the ACL which allows EVENT_ALL_ACCESS for all users and
            // Local System to the security descriptor.
            bRetVal = SetSecurityDescriptorDacl (   
                            pSD,
                                            TRUE,
                                            pacl,
                                            FALSE 
                                            );
        if (!bRetVal)
        {
                dwError = GetLastError();
                     SATraceFailure ("SetAclFromComObject::SetSecurityDescriptorDacl failed:", dwError);
            break;
        }
    
        //
        // success
        //
    }
    while (false);

    //
    // in case of error, cleanup
    //
     if (dwError) 
     {
            if ( pacl ) 
            {
                   LocalFree ( pacl );
            }
        }
        else 
        {
            *ppacl = pacl;
        }
        
    //
    // free up resources now
    //
    if ( psidLocalSystemSid ) {FreeSid ( psidLocalSystemSid );}
    if ( psidAdminSid ) {FreeSid ( psidAdminSid );}

        return (dwError);
        
}//End of SetAclFromComObject method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\gentask\gentask.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "gentask.h"

#include "appliancetask.h"
#include "taskctx.h"
#include "gentask_i.c"
#include "worker.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAGenTask, CWorker)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\elementmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__08E8ABB1_C445_11D2_90BA_00AA00A71DCA__INCLUDED_)
#define AFX_STDAFX_H__08E8ABB1_C445_11D2_90BA_00AA00A71DCA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

// #define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
    HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
    HRESULT UnregisterServer();
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
    LONG Unlock();
    void LogEvent(
                 /*[in]*/ WORD        wMsgType,
                 /*[in]*/ LONG        lMsgID,
                 /*[in]*/ DWORD        dwMsgParamCount,
                 /*[in]*/ LPCWSTR*    pszMsgParams,
                 /*[in]*/ DWORD        dwDataSize,
                 /*[in]*/ BYTE*        pData
                 );
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    TCHAR m_szServiceNiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
    BOOL m_bService;
};

extern CServiceModule _Module;
#include <atlcom.h>
#include <satrace.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__08E8ABB1_C445_11D2_90BA_00AA00A71DCA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\gentask\resource.h ===
#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_SAGenTask                   100
#define IDR_SAGenTask                   101

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\gentask\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

//#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
//#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\initsrvc\appboot.h ===
//#--------------------------------------------------------------
//        
//  File:       appboot.h
//        
//  Synopsis:   holds function declarations for CAppBoot class
//              
//
//  History:     6/02/2000  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifndef _APPBOOT_H_
#define _APPBOOT_H_

//
// this class is  responsible for getting the boot information
//
class CAppBoot 
{
public:

    CAppBoot () :
        m_dwBootCount (0),
        m_bInitialized (false),
        m_bSignaled (false)
    {
    }

    ~CAppBoot () 
    {
    }

    //
    // method to check if this was the first boot of the appliance
    //
    bool IsFirstBoot ();

    //
    // method to check if this was the second boot of the appliance
    //
    bool IsSecondBoot ();

    //
    // method to check if this is really a boot
    //
    bool IsBoot ();

    //
    // increment the boot counter of the appliance
    //
    bool IncrementBootCount ();

private:

    VOID Initialize ();

    DWORD m_dwBootCount;

    bool  m_bInitialized;

    bool  m_bSignaled;
    
};


#endif // _APPBOOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\gentask\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_)
#define AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#if !defined(_WIN64) && !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif
//#define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#include "gentask.h"
#include "comdef.h"

#include <satrace.h>


#endif // !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\gentask\worker.cpp ===
//#--------------------------------------------------------------
//
//  File:        worker.cpp
//
//  Synopsis:   Implementation of CWorker class methods
//
//
//  History:    
//
//    Copyright (c) Microsoft Corporation.  All rights reserved.
//
//----------------------------------------------------------------
#include "stdafx.h"
#include <initguid.h>
#include "gentask.h"
#include "worker.h"
#include "appmgrobjs.h"
#include "sagenmsg.h"
#include "sacom.h"
#include "sacomguid.h"
#include  <string>

//
// specify namespace for wstring
//
using namespace std;

//
// Appliance Services PROGID
//
const WCHAR APPLIANCE_SERVICES_PROGID [] = L"Appsrvcs.ApplianceServices.1";

//
// Alert Log Name
//
const WCHAR SA_CORE_ALERT_LOG [] = L"MSSAKitCore";

//
// Well-known boot counters
//
const long PRISTINE_DISK = 0x0;
const long CORRUPT_DISK  = 0xF;

//
// Max number of boot counters
//
const long MAX_BOOT_COUNTER = 4;

const WCHAR APPLICATION_NAME [] = L"Appmgr";

//++--------------------------------------------------------------
//
//  Function:   OnTaskComplete
//
//  Synopsis:   This is the IApplianceTask interface method 
//
//  Arguments:  [in]    
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     06/06/2000
//
//  Called By: 
//
//----------------------------------------------------------------
STDMETHODIMP 
CWorker::OnTaskComplete(
        /*[in]*/    IUnknown *pTaskContext, 
        /*[in]*/    LONG lTaskResult
        )
{
    CSATraceFunc objTrace ("CWorker::OnTaskComplete");
    return S_OK;


}   // end of CWorker::OnTaskComplete method

//++--------------------------------------------------------------
//
//  Function:   OnTaskExecute
//
//  Synopsis:   This is the IApplianceTask interface method 
//
//  Arguments:  [in]    
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     06/06/2000
//
//  Called By: 
//
//----------------------------------------------------------------
STDMETHODIMP 
CWorker::OnTaskExecute (
    /*[in]*/ IUnknown *pTaskContext
    )
{
    CSATraceFunc objTrace ("GenericTask::OnTaskExecute");

    _ASSERT (pTaskContext);  

    HRESULT hr = S_OK;
    try
    {
        do
        {
            if (NULL == pTaskContext)
            {
                SATraceString (
                    "GenericTask-OnTaskExecute passed invalid parameter"
                    );
                hr = E_POINTER;
                break;
            }

            CComPtr <ITaskContext> pTaskParameters;
            //
            // get the task parameters from the context
            //
            hr = pTaskContext->QueryInterface(
                                    IID_ITaskContext,
                                    (PVOID*)&pTaskParameters
                                    );
            if (FAILED (hr))
            {
                SATracePrintf (
                    "GenericTask-OnTaskExecute failed to query "
                    " TaskContext:%x",
                     hr
                    );
                break;
            }
    

            GENTASK eTask = NO_TASK;
            //
            // Check which Task is being executed and call that method
            //
            hr = GetMethodName(pTaskParameters, &eTask);
            if (FAILED (hr)) {break;}
    
            //
            // initiate the appropriate task now
            //
            switch (eTask)
            {
            case SYSTEM_INIT:
                hr = InitTask (pTaskParameters);
                break;

            default:
                SATracePrintf (
                    "GenericTask-OnTaskExecute passed unknown task type:%d",
                    eTask
                    );
                hr = E_INVALIDARG;
                break;
            }
        }
        while (false);
    }
    catch (...)
    {
        SATraceString (
            "GenericTask-OnTaskExecute caught unknown exception"
            );
        hr = E_FAIL;
    }

    return (hr);

}   // end of CWorker::OnTaskExecute method

//++--------------------------------------------------------------
//
//  Function:   GetMethodName
//
//  Synopsis:   This is the CUpdateTask private method to obtain
//              the method that the user wants to execute
//
//  Arguments:  [in]  ITaskContext* - task context
//              [out] PGENTASK      - task to execute
//
//  Returns:    HRESULT
//
//  History:    
//
//  Called By: 
//
//----------------------------------------------------------------
HRESULT
CWorker::GetMethodName (
    /*[in]*/    ITaskContext *pTaskParameter,
    /*[out]*/   PGENTASK     peTask
    )
{
    CSATraceFunc objTraceFunc ("CWorker:GetMethodName");

    _ASSERT(pTaskParameter && peTask);
    
    HRESULT hr = S_OK;
    try
    {
        do
        {
            CComVariant vtValue;
            CComBSTR    bstrParamName (L"MethodName");
            //
            // get the methodname parameter out of the Context
            //
            hr = pTaskParameter->GetParameter(
                                bstrParamName,
                                &vtValue
                                );
            if (FAILED(hr))
            {
                SATracePrintf (
                  "Generic Task failed on ITaskParameter::GetParameter "
                   "with error:%x",
                   hr
                );
                break;
            }

            if (V_VT(&vtValue) != VT_BSTR)
            {
                SATracePrintf (
                    "Generic Task did not receive a string parameter "
                    " for method name:%d", 
                    V_VT(&vtValue)
                    );
                hr = E_INVALIDARG;
                break;
            }

            //
            // check the task now
            //
            if (0 == ::_wcsicmp (V_BSTR (&vtValue), APPLIANCE_INITIALIZATION_TASK))
            {
                *peTask = SYSTEM_INIT;
            }
            else
            {
                SATracePrintf (
                    "Generic Task was requested an unknown task:%ws",
                     V_BSTR (&vtValue)
                    );
                hr = E_INVALIDARG;  
                break;
            }

            //
            // succeeded
            //
        }
        while (false);

    }
    catch (...)
    {
        SATraceString (
            "Generic Task caught unknown exception in GetMethodName"
            );
        hr = E_FAIL;
    }
    
    if (FAILED(hr)) {*peTask = NO_TASK;}

    return (hr);

}   //  end of CWorker::GetMethodName method


//++--------------------------------------------------------------
//
//  Function:   InitTask
//
//  Synopsis:   This is the CUpdateTask private method which
//              is responsible for carrying out the initialization task
//
//  Arguments:  [in]  ITaskContext*
//
//  Returns:    HRESULT
//
//  History:    MKarki      06/06/2000    Created
//
//  Called By:  OnTaskComplete/OnTaskExecute methods of IApplianceTask 
//              interface
//
//----------------------------------------------------------------
HRESULT
CWorker::InitTask (
    /*[in]*/    ITaskContext *pTaskParameter
    )
{
    CSATraceFunc objTrace ("CWorker::InitTask");

    _ASSERT (pTaskParameter);

    HRESULT hr = S_OK;
    try
    {
        do
        {
            //
            // check if we are in backup OS
            //
            if ( IsBackupOS ())
            {

                SATraceString (
                        "Generic Task found that we are in Backup OS"
                        );

                //
                // raise alert for primary drive failure
                //
                CComVariant vtRepStrings;
                RaiseAlert (    
                       SA_PRIMARY_OS_FAILED_ALERT,
                       SA_ALERT_TYPE_FAILURE, 
                       &vtRepStrings
                       );
                
                //
                // generate event log
                //
                GenerateEventLog (
                              SA_PRIMARY_OS_FAILED_EVENTLOG_ENTRY
                              );

             }

            //
            // suceess
            //
        }
        while (false);
    }
    catch  (...)
    {
        SATraceString (
            "Gemeric Task failed while doing init task method "
            "with unknown exception"
            );
    }

    return (hr);

}   //  end of CWorker::InitTask method


//++--------------------------------------------------------------
//
//  Function:   RaiseAlert
//
//  Synopsis:   This is the CWorker private method which
//              is responsible for raising the appropriate alert
//
//  Arguments:  
//              [in]    DWORD - Alert ID
//              [in]    SA_ALERT_TYPE - type of alert to generate
//              [in]    VARIANT* - replacement strings 
//
//  Returns:    HRESULT
//
//  History:    MKarki      06/06/2000    Created
//
//----------------------------------------------------------------
HRESULT 
CWorker::RaiseAlert (
    /*[in]*/    DWORD           dwAlertId,
    /*[in]*/    SA_ALERT_TYPE   eAlertType,
    /*[in]*/    VARIANT*        pvtReplacementStrings
    )
{
    CSATraceFunc objTraceFunc ("CWorker::RaiseAlert");
    
    SATracePrintf ("Generic Task raising alert:%x...", dwAlertId);

    _ASSERT (pvtReplacementStrings);

    HRESULT hr = S_OK;
    do
    {
        //
        // get the CLSID for the Appliance Services
        //
        CLSID clsid;
        hr =  ::CLSIDFromProgID (
                    APPLIANCE_SERVICES_PROGID,
                    &clsid
                    );
        if (FAILED (hr))
        {
            SATracePrintf (
                "Generic Task failed to get PROGID of Appsrvcs:%x",
                hr
                );
            break;
        }
            
        CComPtr <IApplianceServices> pAppSrvcs;
        //
        // create the Appliance Services COM object
        //
        hr = ::CoCreateInstance (
                        clsid,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        __uuidof (IApplianceServices),
                        (PVOID*) &pAppSrvcs
                        );
        if (FAILED (hr))
        {
            SATracePrintf (
                "Generic Task failed to create Appsrvcs COM object:%x",
                hr
                );
            break;
        }

        //
        // initialize the COM object now
        //
        hr = pAppSrvcs->Initialize ();
        if (FAILED (hr))
        {
            SATracePrintf (
                "Generic Task failed to initialize Appsrvcs object:%x",
                hr
                );
            break;
        }

        LONG lCookie = 0;
        CComBSTR bstrAlertLog (SA_CORE_ALERT_LOG);
        CComBSTR bstrAlertSource (L"");
        CComVariant vtRawData;
        //
        // raise the alert now
        //
        hr = pAppSrvcs->RaiseAlert (
                                eAlertType,
                                dwAlertId,
                                bstrAlertLog,
                                bstrAlertSource,
                                INFINITE,
                                pvtReplacementStrings,
                                &vtRawData,
                                &lCookie
                                );
        if (FAILED (hr))
        {
            SATracePrintf (
                "Generic Task failed to raise alert in Appsrvcs:%x",
                hr
                );
            break;
        }

        //
        // sucess
        //
        SATracePrintf ("Generic Task successfully raised alert:%x...", dwAlertId);
    }
    while (false);

    return (hr);

}   //  end of CWorker::RaiseAlert method

//++--------------------------------------------------------------
//
//  Function:   IsBackupOS
//
//  Synopsis:   This is the CWorker private method which
//              is responsible for determining if we are running
//              in BackupOS
//
//  Arguments:  
//
//  Returns:    HRESULT
//
//  History:    MKarki      01/25/2001   Created
//              serdarun    04/26/2002   Modify
//              Use nvram boot counters to determine failover 
//
//----------------------------------------------------------------
bool
CWorker::IsBackupOS (
    VOID
    )
{
    CSATraceFunc objTraceFunc ("CWorker::IsBackupOS");

    //
    // pointer nvram helper object
    //
    CComPtr<ISaNvram> pSaNvram;

    bool bIsBackupOS = false;

    HRESULT hr = CoCreateInstance(
                            CLSID_SaNvram,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ISaNvram,
                            (void**)&pSaNvram
                            );
    if (FAILED(hr))
    {
        SATracePrintf("CWorker::IsBackupOS failed on CoCreateInstance, %d",hr);
        return bIsBackupOS;
    }


    //
    // Failover detection logic: 
    // If any of the boot counters for partition 2-4 is different than
    //    PRISTINE_DISK(0) or CORRUPT_DISK(0xF)
    //    we are in backup OS
    //
    long lCounter = 2;
    long lBootCount = 0;

    while (lCounter <= MAX_BOOT_COUNTER)
    {
        hr = pSaNvram->get_BootCounter(lCounter,&lBootCount);

        if (FAILED(hr))
        {
            SATracePrintf("CWorker::IsBackupOS failed on get_BootCounter, %x",hr);
            return bIsBackupOS;
        }
        else
        {
            if ( !((lBootCount == PRISTINE_DISK) || (lBootCount == CORRUPT_DISK)) )
            {
                SATraceString("CWorker::IsBackupOS, we are in backup OS");
                bIsBackupOS = true;
                return bIsBackupOS;
            }
        }
        lCounter++;
    }
           
    return (bIsBackupOS);

}   //  end of  CWorker::IsBackupOS method

//++--------------------------------------------------------------
//
//  Function:   GenerateEventLog
//
//  Synopsis:   This is the CWorker private method which
//              is responsible for generating event log
//
//  Arguments:  
//              [in]    DWORD - EventID
//
//  Returns:    HRESULT
//
//  History:    serdarun      05/07/2002    Created
//
//----------------------------------------------------------------
HRESULT CWorker::GenerateEventLog (
                /*[in]*/    DWORD           dwEventId
                )
{

    CSATraceFunc objTraceFunc ("CWorker::GenerateEventLog");

    HANDLE hHandle = NULL;
    HRESULT hr = S_OK;

    hHandle = RegisterEventSource(
                               NULL,       // uses local computer 
                               APPLICATION_NAME  // source name 
                               );
    if (hHandle == NULL) 
    {
        SATraceFailure("CWorker::GenerateEventLog failed on RegisterEventSource",GetLastError());
        hr = E_FAIL;
    }
    else
    {
        //
        // event log strings array
        //
        LPWSTR  lpszStrings = 0;
 
        if (!ReportEvent(
                hHandle,                    // event log handle 
                EVENTLOG_ERROR_TYPE,        // event type 
                0,                          // category zero 
                dwEventId,                  // event identifier 
                NULL,                       // no user security identifier 
                0,                          // one substitution string 
                0,                          // no data 
                (LPCWSTR *) &lpszStrings,   // pointer to string array 
                NULL))                      // pointer to data 
        {
            SATraceFailure("CWorker::GenerateEventLog failed on ReportEvent",GetLastError());
            hr = E_FAIL;
        }
    }

    //
    // cleanup
    //
    if (hHandle)
    {
        DeregisterEventSource(hHandle);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\initsrvc\appboot.cpp ===
//#--------------------------------------------------------------
//
//  File:       appboot.cpp
//
//  Synopsis:   This file holds the definitions  of the
//                CAppBoot class
//
//
//  History:     06/02/2000
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#include "stdafx.h"
#include "comdef.h"
#include "satrace.h"
#include "appboot.h"
#include "getvalue.h"
#include <appmgrobjs.h>

const WCHAR BOOT_COUNT_REGISTRY_PATH [] =
            L"SOFTWARE\\Microsoft\\ServerAppliance\\ApplianceManager\\ObjectManagers\\Microsoft_SA_Service\\InitializationService";

const WCHAR BOOT_COUNT_REGISTRY_VALUE [] = L"BootCount";    

//++--------------------------------------------------------------
//
//  Function:   IsFirstBoot
//
//  Synopsis:   function for checking if this is the first boot
//                of the appliance
//
//  Arguments:  none
//
//    Returns:     true (yes), false (no)
//
//  History:    MKarki      Created     06/02/2000
//
//----------------------------------------------------------------
bool
CAppBoot::IsFirstBoot (
    VOID
    )
{
    CSATraceFunc objTraceFunction ("CAppBoot::IsFirstBoot");

    //
    // initialize the class object if it has not been initialized
    //
    if (!m_bInitialized) 
    {
        Initialize ();
    }

    return ((!m_bSignaled) && (1 == m_dwBootCount));

}    //    end of CAppBoot::IsFirstBoot method

//++--------------------------------------------------------------
//
//  Function:   IsSecondBoot
//
//  Synopsis:   function for checking if this is the second boot
//                of the appliance
//
//  Arguments:  none
//
//    Returns:     true (yes), false (no)
//
//  History:    MKarki      Created     06/02/2000
//
//----------------------------------------------------------------
bool
CAppBoot::IsSecondBoot (
    VOID
    )
{
    CSATraceFunc objTraceFunction ("CAppBoot::IsSecondBoot");

    //
    // initialize the class object if it has not been initialized
    //
    if (!m_bInitialized) 
    {
        Initialize ();
    }

    return ((!m_bSignaled) && (2 == m_dwBootCount));

}    //    end of CAppBoot::IsFirstBoot method

//++--------------------------------------------------------------
//
//  Function:   IsBoot
//
//  Synopsis:   function for checking if this is really an appliance
//                boot
//
//  Arguments:  none
//
//    Returns:     true (yes), false (no)
//
//  History:    MKarki      Created     06/02/2000
//
//----------------------------------------------------------------
bool
CAppBoot::IsBoot (
    VOID
    )
{
    CSATraceFunc objTraceFunction ("CAppBoot::IsBoot");

    //
    // initialize the class object if it has not been initialized
    //
    if (!m_bInitialized) 
    {
        Initialize ();
    }

    return (!m_bSignaled);

}    //    end of CAppBoot::IsBoot method

//++--------------------------------------------------------------
//
//  Function:   IncrementBootCount
//
//  Synopsis:   function for increment the appliance boot count
//
//  Arguments:  none
//
//    Returns:     HRESULT - status
//
//  History:    MKarki      Created     06/02/2000
//
//----------------------------------------------------------------
bool
CAppBoot::IncrementBootCount (
    VOID
    )
{
    bool bRetVal = true;

    CSATraceFunc objTraceFunction ("CAppBoot::IncrementBootCount");

    do
    {
        //
        // initialize the class object if it has not been initialized
        //
        if (!m_bInitialized)
        {
            Initialize ();
        }

        //
        // we only increment the  boot count if this is the first or second
        // boot, or we are have not actually booted up
        //
        if ((m_dwBootCount > 2) || (m_bSignaled))  {break;}

        _variant_t vtNewBootCount ((LONG)(m_dwBootCount +1));
        //
        //    set the value in the registry now
        //
        bRetVal = SetObjectValue (
                        BOOT_COUNT_REGISTRY_PATH,
                        BOOT_COUNT_REGISTRY_VALUE,
                        &vtNewBootCount
                        );
        if (bRetVal)
        {
            //
            // we have the value, now store this away
            //
            m_dwBootCount = V_I4(&vtNewBootCount);
        }
        else
        {
            SATraceString ("CAppBoot::Initialize failed on SetObjectValue call");
        }
    }
    while (false);

    return (bRetVal);
    
}    //    end of CAppBoot::IsFirstBoot method

//++--------------------------------------------------------------
//
//  Function:   Initialize
//
//  Synopsis:   function for checking responsible for initializing
//                the class object
//
//  Arguments:  none
//
//    Returns:     none
//
//  History:    MKarki      Created     06/02/2000
//
//----------------------------------------------------------------
VOID
CAppBoot::Initialize (
    VOID
    )
{
    CSATraceFunc objTraceFunction ("CAppBoot::Initialize");
    
    if (m_bInitialized) {return;}

    HANDLE hEvent = NULL;
    do
    {

        _variant_t vtValue;
        //
        // get the boot count from the registry now
        //
        bool bRetVal = GetObjectValue (
                        BOOT_COUNT_REGISTRY_PATH,
                        BOOT_COUNT_REGISTRY_VALUE,
                        &vtValue,
                        VT_I4
                        );
        if (bRetVal)
        {
            //
            // we have the value, now store this away
            //
            m_dwBootCount = V_I4(&vtValue);
        }
        else
        {
            SATraceString ("CAppBoot::Initialize failed on GetObjectValue call");
            break;
        }

        //
        // we also need to verify that we are actully being called at boot
        // time and not when the service is being started by the appliance
        // monitor
        //
    
        //
        // open the event handle
        //
        hEvent = OpenEvent (
                           SYNCHRONIZE,        // access type
                           FALSE,
                           SA_STOPPED_SERVICES_EVENT
                           );
        if (NULL == hEvent)
        { 
            SATraceFailure ("OpenEvent", GetLastError ());
            break;
        }

        //
        // check the state of the event now
        //
        DWORD dwRetVal = WaitForSingleObject (hEvent, 0);
        if (WAIT_FAILED == dwRetVal)
        {
            SATraceFailure ("WaitForSingleObject", GetLastError ());
            break;
        }
        else if (WAIT_OBJECT_0 == dwRetVal)
        {
            //
            // appmon has signaled this event
            //
            SATraceString ("CAppBoot::Initialize found WAIT SIGNALED");
            m_bSignaled = true;
        }

        //
        // success
        //
        m_bInitialized = true;
    }
    while (false);

    //
    // cleanup
    //
    if (hEvent) {CloseHandle (hEvent);}

    return;
            

}    //    end of CAppBoot::Initialize method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\initsrvc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\gentask\worker.h ===
//#--------------------------------------------------------------
//
//  File:       worker.h
//
//  Synopsis:   This file holds the declarations of the
//                SAGenTask COM class
//
//
//  History:     6/06/2000 
//
//    Copyright (c) Microsoft Corporation.  All rights reserved.
//
//#--------------------------------------------------------------
#ifndef __WORKER_H_
#define __WORKER_H_

#include "resource.h"       // main symbols
#include "taskctx.h"
#include "appsrvcs.h"

class ATL_NO_VTABLE CWorker: 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CWorker, &CLSID_SAGenTask>,
    public IDispatchImpl<IApplianceTask, &IID_IApplianceTask, &LIBID_GenTaskLib>
{
public:

    CWorker() {}

    ~CWorker() {}

DECLARE_REGISTRY_RESOURCEID(IDR_SAGenTask)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWorker)
    COM_INTERFACE_ENTRY(IApplianceTask)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    //
    // IApplianceTask interface methods
    //
    STDMETHOD(OnTaskExecute)(
                     /*[in]*/ IUnknown* pTaskContext
                            );

    STDMETHOD(OnTaskComplete)(
                      /*[in]*/ IUnknown* pTaskContext, 
                      /*[in]*/ LONG      lTaskResult
                             );    
private:

    typedef enum
    {
        NO_TASK,
        SYSTEM_INIT

    }    GENTASK, *PGENTASK;   

    // 
    //
    // supporting methods for the tasks;
    //
    HRESULT GetMethodName(
                /*[in]*/ ITaskContext *pTaskParameter,
                /*[out]*/   PGENTASK  pSuChoice
                );

    HRESULT    InitTask (
                /*[in]*/    ITaskContext *pTaskParameter
                );

    HRESULT RaiseAlert (
                /*[in]*/    DWORD           dwAlertId,
                /*[in]*/    SA_ALERT_TYPE   eAlertType,
                /*[in]*/    VARIANT*        pvtReplacementStrings
                );

    HRESULT GenerateEventLog (
                /*[in]*/    DWORD           dwEventId
                );

    bool IsBackupOS ();

};

#endif //_WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\initsrvc\initservice.cpp ===
// InitService.cpp : Implementation of CInitService class

#include "stdafx.h"
#include "initsrvc.h"
#include "InitService.h"
#include <basedefs.h>
#include <satrace.h>
#include <atlhlpr.h>
#include <appmgrobjs.h>
#include <taskctx.h>
#include <appsrvcs.h>
#include <comdef.h>
#include <comutil.h>
#include "appboot.h"

///////////////////////////////////////////////////////////////////////////////
// IApplianceObject Interface Implmentation - see ApplianceObject.idl
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CInitService::GetProperty(
                            /*[in]*/ BSTR     pszPropertyName, 
                   /*[out, retval]*/ VARIANT* pPropertyValue
                                   )
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CInitService::PutProperty(
                            /*[in]*/ BSTR     pszPropertyName, 
                            /*[in]*/ VARIANT* pPropertyValue
                                   )
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CInitService::SaveProperties(void)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CInitService::RestoreProperties(void)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CInitService::LockObject(
                  /*[out, retval]*/ IUnknown** ppLock
                                  )
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CInitService::Initialize(void)
{
    HRESULT hr = S_OK;

    CLockIt theLock(*this);

    TRY_IT
    
    if ( ! m_bInitialized )
    {
        SATraceString("CInitService::Initialize() - INFO - Performing initialization time tasks");
        m_bInitialized = AutoTaskRestart();
        if ( ! m_bInitialized )
        { 
            hr = E_FAIL;
        }
    }

    CATCH_AND_SET_HR

    return hr;

}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CInitService::Shutdown(void)
{
    CLockIt theLock(*this);
    if ( m_bInitialized )
    {
        SATraceString("CInitService::Initialize() - INFO - Performing shutdown time operations");
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CInitService::Enable(void)
{
    CLockIt theLock(*this);
    if ( m_bInitialized )
    {
        return S_OK;
    }
    return E_UNEXPECTED;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CInitService::Disable(void)
{
    CLockIt theLock(*this);
    if ( m_bInitialized )
    {
        return S_OK;
    }
    return E_UNEXPECTED;
}


///////////////////////////////////////////////////////////////////////////////
bool
CInitService::AutoTaskRestart(void)
{
    bool bRet = false;
    do
    {
        // Create a restartable task 
        // (appliance initialization task)
        CComPtr<ITaskContext> pTaskCtx; 
        HRESULT hr = CoCreateInstance(
                                      CLSID_TaskContext,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_ITaskContext,
                                      (void**)&pTaskCtx
                                     );
        if ( FAILED(hr) )
        { 
            SATracePrintf("CInitService::AutoTaskRestart() - ERROR - CoCreateInstance(TaskContext) returned %lx", hr);
            break; 
        }

        //
        // create appliance services now
        CComPtr<IApplianceServices> pAppSrvcs; 
        hr = CoCreateInstance(
                                      CLSID_ApplianceServices,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_IApplianceServices,
                                      (void**)&pAppSrvcs
                                       );
        if ( FAILED(hr) )
        { 
            SATracePrintf("CInitService::AutoTaskRestart() - ERROR - CoCreateInstance(ApplianceServices) returned %lx", hr);
            break; 
        }

        //
        // initialize appliance services now
        hr = pAppSrvcs->Initialize ();
        if ( FAILED(hr) )
        { 
            SATracePrintf("CInitService::AutoTaskRestart() - ERROR - Initiialize (ApplianceServices) returned %lx", hr);
            break; 
        }


        _bstr_t bstrMethodName;
        CAppBoot appboot;
        //
        // run the task depending on our current boot count
        //
        if (appboot.IsFirstBoot ())
        {
            SATraceString ("Initialization Service starting FIRST boot task...");
            
            bstrMethodName = APPLIANCE_FIRSTBOOT_TASK;
            //
            // execute the first boot task asynchronously now
            //
            hr = pAppSrvcs->ExecuteTaskAsync (bstrMethodName, pTaskCtx);
            if (FAILED(hr))
            {
                SATracePrintf("CInitService::AutoTaskRestart() - ERROR - IApplianceServices::ExecuteTaskAsync[FIRST_BOO_TASK] () returned %lx",hr);
                //
                // continue - there might not be any task to execute
                //
            }
        }
        else if (appboot.IsSecondBoot ())
        {
            SATraceString ("Initialization Service starting SECOND boot task...");

            bstrMethodName = APPLIANCE_SECONDBOOT_TASK;
            //
            // execute the second boot task asynchronously now
            //
            hr = pAppSrvcs->ExecuteTaskAsync (bstrMethodName, pTaskCtx);
            if (FAILED(hr))
            {
                SATracePrintf("CInitService::AutoTaskRestart() - ERROR - IApplianceServices::ExecuteTaskAsync[SECOND_BOOT_TASK] () returned %lx",hr);
                //
                // continue - there might not be any task to execute
                //
            }
        }
        else if (appboot.IsBoot ())
        {
            //
            // if this is really a boot 
            //
            SATraceString ("Initialization Service starting EVERY boot task...");
            bstrMethodName = APPLIANCE_EVERYBOOT_TASK;
            //
            // execute the second boot task asynchronously now
            //
            hr = pAppSrvcs->ExecuteTaskAsync (bstrMethodName, pTaskCtx);
            if (FAILED(hr))
            {
                SATracePrintf("CInitService::AutoTaskRestart() - ERROR - IApplianceServices::ExecuteTaskAsync[EVERY_BOOT_TASK] () returned %lx",hr);
                //
                // continue - there might not be any task to execute
                //
            }
        }

        SATraceString ("Initialization Service starting INITIALIZATION task...");

        bstrMethodName = APPLIANCE_INITIALIZATION_TASK; 
        //
        // execute the async task now
        hr = pAppSrvcs->ExecuteTaskAsync (bstrMethodName, pTaskCtx);
        if ( FAILED(hr) )
        {
            SATracePrintf("CInitService::AutoTaskRestart() - ERROR - IApplianceServices::ExecuteTaskAsync [INITIALIZATION_TASK]() returned %lx", hr);
            //
            // continue - there might not be any task to execute
            //
        }

        //
        //SATraceString ("Initialization Service RESTARTING tasks...");
        //
        //
        // Now restart any paritally completed transactions 
        // Security Review change - no task restarts allowed - MKarki 04/25/2002
        //
        // CSATaskTransaction::RestartTasks();

        SATraceString ("Initialization Service INCREMENTING BOOT COUNT...");

        //
        // increment our boot count now
        //
        if (!appboot.IncrementBootCount ())
        {
            SATraceString ("CInitService::AutoTaskRestart - ERROR - unable to increment boot count");
            hr = E_FAIL;
            break;
        }
            
        bRet = true;
    
    } while ( FALSE );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\initsrvc\initservice.h ===
// TestService.h: Definition of the CTestService class
//
//////////////////////////////////////////////////////////////////////

#if !defined __INC_INIT_SERVICE_H_
#define __INC_INIT_SERVICE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"            // main symbols
#include "applianceobject.h"

/////////////////////////////////////////////////////////////////////////////
// CTestService

class CInitService : 
    public IDispatchImpl<IApplianceObject, &IID_IApplianceObject, &LIBID_INITSRVCLib>, 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CInitService,&CLSID_InitService>
{
public:
    CInitService()
    : m_bInitialized(false) { }

BEGIN_COM_MAP(CInitService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IApplianceObject)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CInitService) 

DECLARE_REGISTRY_RESOURCEID(IDR_INITSRVC)

// IApplianceObject

    //////////////////////////////////////////////////////////////////////////
    // IApplianceObject Interface
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD(GetProperty)(
                   /*[in]*/ BSTR     pszPropertyName, 
          /*[out, retval]*/ VARIANT* pPropertyValue
                          );

    STDMETHOD(PutProperty)(
                   /*[in]*/ BSTR     pszPropertyName, 
                   /*[in]*/ VARIANT* pPropertyValue
                          );

    STDMETHOD(SaveProperties)(void);

    STDMETHOD(RestoreProperties)(void);

    STDMETHOD(LockObject)(
         /*[out, retval]*/ IUnknown** ppLock
                         );

    STDMETHOD(Initialize)(void);

    STDMETHOD(Shutdown)(void);

    STDMETHOD(Enable)(void);

    STDMETHOD(Disable)(void);

private:

    bool    AutoTaskRestart(void);

    bool    m_bInitialized;
};

#endif // __INC_INIT_SERVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\initsrvc\initsrvc.cpp ===
// initsrvc.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f testsrvcps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "initsrvc.h"
#include "initService.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_InitService, CInitService)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance /*, &LIBID_TESTSRVCLib*/);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(/*TRUE*/);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\initsrvc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A7F98AA9_CB61_11D2_BF24_00105A1F3461__INCLUDED_)
#define AFX_STDAFX_H__A7F98AA9_CB61_11D2_BF24_00105A1F3461__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A7F98AA9_CB61_11D2_BF24_00105A1F3461__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\kitmsg\makefile.inc ===
samsg.rc: msg00001.bin

samsg.h msg00001.bin: samsg.mc
    mc -v samsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\initsrvc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by initsrvc.rc
//
#define IDS_PROJNAME                    100
#define IDS_INITSERVICE_DESC            101
#define IDR_INITSRVC                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\event.h ===
#ifndef _EVENT_H_

#define _EVENT_H_

#include "windows.h"
#include "debug.h"
#include "mem.h"

DWORD CreateLangChangeEvent(HANDLE *phEvent);

#endif  _EVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

//#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
//#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\locinfo.cpp ===
//#--------------------------------------------------------------
//
//  File:        locinfo.cpp
//
//  Synopsis:   Implementation of CSALocInfo class methods
//
//
//  History:    2/16/99  MKarki Created
//                4/3/01   MKarki Modified  
//                             added IsValidLanguageDirectory method
//
//    Copyright (C) 1999-2001 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "stdafx.h"
#include "locinfo.h"
#include <appmgrobjs.h>
#include <getvalue.h>
#include "common.cpp"

#include "mem.h"

#include <initguid.h>

const WCHAR  DEFAULT_SAMSG_DLL[]   = L"sakitmsg.dll";

const DWORD  MAX_MESSAGE_LENGTH    = 1023;

const DWORD  MAX_STRINGS_SUPPORTED = 64;


//++--------------------------------------------------------------
//
//  Function:   GetString
//
//  Synopsis:   This is the ISALocInfo interface method 
//              for getting the string information from the
//              Localization Manager
//
//  Arguments: 
//              [in]    BSTR    -   String Resource Source 
//              [in]    LONG    -   Message Id
//              [in]    VARIANT*-   Replacement strings
//              [out]   BSTR*   -   Message String 
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Created     2/1/99
//
//----------------------------------------------------------------
STDMETHODIMP 
CSALocInfo::GetString (
                /*[in]*/        BSTR        szSourceId,
                /*[in]*/        LONG        lMessageId,
                /*[in]*/        VARIANT*    pvtRepStr,   
                /*[out,retval]*/BSTR        *pszMessage
                )
{
    CSATraceFunc objTraceFunc ("CSALocInfo::GetString");
    //
    // grab the critical section
    //
    CLock objLock(&m_hCriticalSection);

    HRESULT hr = S_OK;
    PWCHAR  StringArray[MAX_STRINGS_SUPPORTED];

    _ASSERT (pszMessage);

    if (!pszMessage) {return (E_INVALIDARG);}

    SATracePrintf ("Localization Manager called for message:%x", lMessageId);

    try
    {
        do
        {
            //
            // initialize the component if not initialized
            //
            if (!m_bInitialized) 
            {
                hr = InternalInitialize ();
                if (FAILED (hr))
                { 
                    SATracePrintf (
                        "Localization Manager Initialization failed:%x",
                        hr
                        );
                    break;
                }
            }

            CModInfo cm;

            //
            // get the module ID from the map
            //
            hr = GetModuleID (szSourceId, cm);
            if (FAILED (hr)) {break;}

            DWORD dwTotalStrings = 0;
            //  
            // check that we have actually been passed an array
            //
            if ((pvtRepStr) && 
               !(VT_EMPTY == V_VT(pvtRepStr)) &&
               !(VT_NULL  == V_VT(pvtRepStr))
                )
            {
                bool bByRef = false;
                //      
                // we expect an array of variants
                //
                if (
                    (TRUE == (V_VT (pvtRepStr) ==  VT_ARRAY + VT_BYREF + VT_VARIANT)) ||
                    (TRUE == (V_VT (pvtRepStr) ==  VT_ARRAY + VT_BYREF + VT_BSTR)) 
                    )
                {
                    SATraceString (
                        "Localization Manager received array by-reference"
                        );
                    bByRef = true;

                }
                else if (
                    (TRUE == (V_VT (pvtRepStr) ==  VT_ARRAY + VT_VARIANT)) ||
                    (TRUE == (V_VT (pvtRepStr) ==  VT_ARRAY + VT_BSTR)) 
                    )
                {
                    SATraceString (
                        "Localization Manager received array by-value"
                        );
                }
                else
                {
                    SATraceString (
                        "Incorrect format of replacement string array"
                        );
                    hr = E_INVALIDARG;
                    break;
                }

                LONG lLowerBound = 0;
                //
                // get the number of replacement strings provided
                //
                hr = ::SafeArrayGetLBound (
                                    (bByRef) 
                                    ? *(V_ARRAYREF (pvtRepStr)) 
                                    : (V_ARRAY (pvtRepStr)), 
                                    1, 
                                    &lLowerBound
                                    );
                if (FAILED (hr))
                {
                    SATracePrintf (
                        "Loc. Mgr can't obtain rep. string array size:%x",
                        hr
                        );
                    break;
                }

                LONG lUpperBound = 0;
                hr = ::SafeArrayGetUBound (
                                    (bByRef) 
                                    ? *(V_ARRAYREF (pvtRepStr)) 
                                    : (V_ARRAY (pvtRepStr)), 
                                    1,
                                    &lUpperBound
                                    );
                if (FAILED (hr))
                {
                    SATracePrintf (
                        "Loc. Mgr can't obtain rep. string array size:%x",
                        hr
                        );
                    break;
                }
                
                dwTotalStrings = lUpperBound - lLowerBound + 1;
                if (dwTotalStrings > MAX_STRINGS_SUPPORTED)
                {
                    SATracePrintf (
                        "Localization Manager-too many replacement strings:%d",
                        dwTotalStrings 
                        );
                    hr = E_INVALIDARG;
                    break;
                }
            
                //
                // put the string pointer in the array
                //
                for (DWORD dwCount = 0; dwCount < dwTotalStrings; dwCount++)
                {
                    if (V_VT (pvtRepStr) == VT_ARRAY + VT_VARIANT) 
                    {
                        //
                        // array of variants
                        //
                        StringArray [dwCount] =  
                             V_BSTR(&((VARIANT*)(V_ARRAY(pvtRepStr))->pvData)[dwCount]);
                    }
                    else if (V_VT (pvtRepStr) == VT_ARRAY + VT_BYREF + VT_VARIANT) 
                    {
                        //
                        // reference to array of variants
                        //
                        StringArray [dwCount] =  
                             V_BSTR(&((VARIANT*)(*(V_ARRAYREF(pvtRepStr)))->pvData)[dwCount]);

                    }
                    else if (V_VT (pvtRepStr) == VT_ARRAY + VT_BSTR) 
                    {
                        //
                        // array of BSTRS
                        //
                        StringArray [dwCount] =  
                            ((BSTR*)(V_ARRAY(pvtRepStr))->pvData)[dwCount];

                    }
                    else if (V_VT (pvtRepStr) == VT_ARRAY + VT_BYREF + VT_BSTR) 
                    {
                        //
                        // reference to array of BSTRs
                        //
                        StringArray [dwCount] =  
                            ((BSTR*)(*(V_ARRAYREF(pvtRepStr)))->pvData)[dwCount];
                    }
                }
            }

            SATracePrintf (
                "Localization Manager was given %d replacement strings",
                 dwTotalStrings
                );

            WCHAR  wszMessage[MAX_MESSAGE_LENGTH +1];

            //
            // format the message now
            //
            DWORD dwBytesWritten = 0;

            switch (cm.m_rType)
            {
                case CModInfo::UNKNOWN:
                    SATracePrintf("resrc type unknown for \'%ws\'",
                                   szSourceId);
                    dwBytesWritten = GetMcString(
                          cm.m_hModule, 
                          lMessageId, 
                          cm.m_dwLangId,
                          wszMessage, 
                          MAX_MESSAGE_LENGTH,
                          (va_list*)((dwTotalStrings)?StringArray:NULL)
                                                );
                    if (dwBytesWritten > 0) 
                    {
                        cm.m_rType = CModInfo::MC_FILE;
                        SetModInfo (szSourceId, cm);
                    }
                    else
                    {
                        dwBytesWritten = GetRcString(
                                           cm.m_hModule,
                                           lMessageId,
                                           wszMessage,
                                           MAX_MESSAGE_LENGTH
                                                    );
                        if (dwBytesWritten > 0) 
                        {
                            cm.m_rType = CModInfo::RC_FILE;
                            SetModInfo (szSourceId, cm);
                        }
                        else
                        {
                            hr = E_FAIL;
                            SATracePrintf(
                                 "MsgId %X not found in module %ws",
                                 lMessageId,
                                 szSourceId
                                         );
                        }
                    }
                    break;

                case CModInfo::MC_FILE:
                    dwBytesWritten = GetMcString(
                          cm.m_hModule, 
                          lMessageId, 
                          cm.m_dwLangId,
                          wszMessage, 
                          MAX_MESSAGE_LENGTH,
                          (va_list*)((dwTotalStrings)?StringArray:NULL)
                                                );
                    if (dwBytesWritten <= 0)
                    {
                        hr = E_FAIL;
                    }
                    break;

                case CModInfo::RC_FILE:
                    dwBytesWritten = GetRcString(
                                           cm.m_hModule,
                                           lMessageId,
                                           wszMessage,
                                           MAX_MESSAGE_LENGTH
                                                );
                    if (dwBytesWritten <= 0)
                    {
                        hr = E_FAIL;
                    }
                    break;
            }

            if ( (dwBytesWritten > 0) &&
                 SUCCEEDED(hr) )
            {
                //
                // allocate memory to return the BSTR value
                //
                *pszMessage = ::SysAllocString  (wszMessage);
                if (NULL == *pszMessage)
                {
                    SATraceString (
                        "Localization Manager unable to alocate string"
                                  );
                    hr = E_OUTOFMEMORY;
                    break;
                }            

                SATracePrintf (
                    "Localization Manager obtained string:'%ws'...",  
                    wszMessage
                              );
            }
                
        }
        while (false);
    }
    catch (...)
    {
        SATraceString ("Localization Manager - unknown exception");
    }

    if (SUCCEEDED (hr))
    {
          SATracePrintf (
            "Localization Manager succesfully obtaining string for message:%x",
            lMessageId
           );
    }
    return (hr);
    
}   //  end of CSALocInfo::GetString method

//++--------------------------------------------------------------
//
//  Function:   GetLanguages
//
//  Synopsis:   This is the ISALocInfo interface method 
//              for getting the currently supported languages on the
//                server appliance
//
//  Arguments: 
//              [out]     VARIANT*     -    Display images of the langs 
//              [out]    VARIANT*    -   ISO Names of the langs
//              [out]    VARIANT*    -    Char-Set of the langs
//              [out]    VARIANT*    -    Char-Set of the langs
//              [out]    VARIANT*    -    Char-Set of the langs
//              [out/retval] unsigned long*    -    lang index
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Modified     04/21/01 - added thread safety
//
//----------------------------------------------------------------
STDMETHODIMP 
CSALocInfo::GetLanguages(
                  /*[out]*/        VARIANT       *pvstrLangDisplayImages,
                  /*[out]*/        VARIANT       *pvstrLangISONames,
                  /*[out]*/        VARIANT       *pvstrLangCharSets,
                  /*[out]*/        VARIANT       *pviLangCodePages,
                  /*[out]*/        VARIANT       *pviLangIDs,
                  /*[out,retval]*/ unsigned long *pulCurLangIndex
                    )
{
    CSATraceFunc objTraceFunc ("CSALocInfo::GetLanguages");
    //
    // grab the critical section
    //
    CLock objLock(&m_hCriticalSection);

    CRegKey           crKey;
    DWORD             dwErr, dwCurLangID=0; 
    LONG              lCount=0;
    HRESULT           hr=S_OK;
    LANGSET::iterator itrList;
    SAFEARRAYBOUND    sabBounds;
    SAFEARRAY         *psaDisplayImageArray = NULL;
    SAFEARRAY         *psaISONameArray = NULL;
    SAFEARRAY         *psaCharSetsArray = NULL;
    SAFEARRAY         *psaCodePagesArray = NULL;
    SAFEARRAY         *psaIDArray = NULL;
    CLang             clBuf;
    TCHAR             szLangID[10];
    VARIANT           vtLangDisplayImage;
    VARIANT           vtLangISOName;
    VARIANT           vtLangCharSet;
    VARIANT           vtLangCodePage;
    VARIANT           vtLangID;


    try
    {
        _ASSERT(pvstrLangDisplayImages);
        _ASSERT(pvstrLangISONames);
        _ASSERT(pvstrLangCharSets);
        _ASSERT(pviLangCodePages);
        _ASSERT(pviLangIDs);
        _ASSERT(pulCurLangIndex);

        if ( (NULL==pvstrLangDisplayImages)||(NULL==pvstrLangISONames) ||
             (NULL==pvstrLangCharSets) || (NULL==pviLangCodePages) ||
             (NULL==pviLangIDs) || (NULL==pulCurLangIndex) )
        {
            return E_INVALIDARG;
        }

        //
        // initialize the component if not initialized
        //
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();
            if (FAILED (hr))
            { 
                SATracePrintf (
                    "Localization Manager Initialization failed in GetLanguages:%x",
                    hr
                    );
                goto End;
            }
        }

        (*pulCurLangIndex) = 0;
        VariantInit(pvstrLangDisplayImages);
        VariantInit(pvstrLangISONames);
        VariantInit(pvstrLangCharSets);
        VariantInit(pviLangCodePages);
        VariantInit(pviLangIDs);

        dwErr = crKey.Open(HKEY_LOCAL_MACHINE, 
                           RESOURCE_REGISTRY_PATH,
                           KEY_READ);
        if (ERROR_SUCCESS != dwErr)
        {
            SATracePrintf("RegOpen failed %ld in GetLanguages", dwErr);
            hr = HRESULT_FROM_WIN32(dwErr);
            goto End;
        }
        crKey.QueryValue(dwCurLangID, LANGID_VALUE);

        itrList = m_LangSet.begin();
        while (itrList != m_LangSet.end())
        {
            lCount++;
            itrList++;
        }

        SATracePrintf("--->LangCount %ld", lCount);
        sabBounds.cElements = lCount;
        sabBounds.lLbound   = 0;
        psaDisplayImageArray = SafeArrayCreate(VT_VARIANT, 1, &sabBounds);
        if (NULL == psaDisplayImageArray)
        {
            SATracePrintf("SafeArrayCreate(DisplayImageArray) failed %ld in GetLanguage");
            hr = E_OUTOFMEMORY;
            goto End;
        }

        psaISONameArray = SafeArrayCreate(VT_VARIANT, 1, &sabBounds);
        if (NULL == psaISONameArray)
        {
            SATracePrintf("SafeArrayCreate(ISONameArray) failed %ld in GetLanguage");
            hr = E_OUTOFMEMORY;
            goto End;
        }

        psaCharSetsArray = SafeArrayCreate(VT_VARIANT, 1, &sabBounds);
        if (NULL == psaCharSetsArray)
        {
            SATracePrintf("SafeArrayCreate(CharSetsArray) failed %ld in GetLanguage");
            hr = E_OUTOFMEMORY;
            goto End;
        }

        psaCodePagesArray = SafeArrayCreate(VT_VARIANT, 1, &sabBounds);
        if (NULL == psaCodePagesArray)
        {
            SATracePrintf("SafeArrayCreate(CodePagesArray) failed %ld in GetLanguage");
            hr = E_OUTOFMEMORY;
            goto End;
        }

        psaIDArray   = SafeArrayCreate(VT_VARIANT, 1, &sabBounds);
        if (NULL==psaIDArray)
        {
            SATracePrintf("SafeArrayCreate(IDArray) failed %ld in GetLanguage");
            hr = E_OUTOFMEMORY;
            goto End;
        }

        itrList = m_LangSet.begin();
        lCount=0;
        VariantInit(&vtLangDisplayImage);
        VariantInit(&vtLangISOName);
        VariantInit(&vtLangID);
        while (itrList != m_LangSet.end())
        {
            clBuf = (*itrList);
            V_VT(&vtLangDisplayImage)   = VT_BSTR;
            V_BSTR(&vtLangDisplayImage) = SysAllocString(clBuf.m_strLangDisplayImage.data());
            SATracePrintf("---->Adding %ws", clBuf.m_strLangDisplayImage.data());
            hr = SafeArrayPutElement(psaDisplayImageArray, 
                                     &lCount, 
                                     &vtLangDisplayImage);
            if (FAILED(hr))
            {
                SATracePrintf("PutElement(DisplayImageArray, %ld) failed %X in GetLanguage",
                              lCount, hr);
                goto End;
            }
            VariantClear(&vtLangDisplayImage);

            V_VT(&vtLangISOName)   = VT_BSTR;
            V_BSTR(&vtLangISOName) = SysAllocString(clBuf.m_strLangISOName.data());
            hr = SafeArrayPutElement(psaISONameArray, 
                                     &lCount, 
                                     &vtLangISOName);
            if (FAILED(hr))
            {
                SATracePrintf("PutElement(ISONameArray, %ld) failed %X in GetLanguage",
                              lCount, hr);
                goto End;
            }
            VariantClear(&vtLangISOName);

            V_VT(&vtLangCharSet)   = VT_BSTR;
            V_BSTR(&vtLangCharSet) = SysAllocString(clBuf.m_strLangCharSet.data());
            hr = SafeArrayPutElement(psaCharSetsArray, 
                                     &lCount, 
                                     &vtLangCharSet);
            if (FAILED(hr))
            {
                SATracePrintf("PutElement(CharSetsArray, %ld) failed %X in GetLanguage",
                              lCount, hr);
                goto End;
            }
            VariantClear(&vtLangCharSet);

            V_VT(&vtLangCodePage)   = VT_I4;
            V_I4(&vtLangCodePage)   = clBuf.m_dwLangCodePage;
            hr = SafeArrayPutElement(psaCodePagesArray, 
                                     &lCount, 
                                     &vtLangCodePage);
            if (FAILED(hr))
            {
                SATracePrintf("PutElement(CodePagesArray, %ld) failed %X in GetLanguage",
                              lCount, hr);
                goto End;
            }
            VariantClear(&vtLangCodePage);

            if (clBuf.m_dwLangID == dwCurLangID)
            {
                (*pulCurLangIndex) = lCount;
            }
            V_VT(&vtLangID)   = VT_I4;
            V_I4(&vtLangID)   = clBuf.m_dwLangID;
            hr = SafeArrayPutElement(psaIDArray, 
                                     &lCount, 
                                     &vtLangID);
            if (FAILED(hr))
            {
                SATracePrintf("PutElement(IDArray, %ld) failed %X in GetLanguage",
                              lCount, hr);
                goto End;
            }
            VariantClear(&vtLangID);

            lCount++;
            itrList++;
        }
        V_VT(pvstrLangDisplayImages) = VT_ARRAY | VT_VARIANT;
        V_VT(pvstrLangISONames)     = VT_ARRAY | VT_VARIANT;
        V_VT(pvstrLangCharSets)     = VT_ARRAY | VT_VARIANT;
        V_VT(pviLangCodePages)    = VT_ARRAY | VT_VARIANT;
        V_VT(pviLangIDs)          = VT_ARRAY | VT_VARIANT;

        V_ARRAY(pvstrLangDisplayImages) = psaDisplayImageArray;
        V_ARRAY(pvstrLangISONames)     = psaISONameArray;
        V_ARRAY(pvstrLangCharSets)     = psaCharSetsArray;
        V_ARRAY(pviLangCodePages)    = psaCodePagesArray;
        V_ARRAY(pviLangIDs)          = psaIDArray;
    }
    catch(...)
    {
        SATraceString("Exception caught in GetLanguages()");
    }

End:
    if (FAILED(hr))
    {
        if (psaDisplayImageArray)
        {
            SafeArrayDestroy(psaDisplayImageArray);
        }
        if (psaISONameArray)
        {
            SafeArrayDestroy(psaISONameArray);
        }
        if (psaCharSetsArray)
        {
            SafeArrayDestroy(psaCharSetsArray);
        }
        if (psaCodePagesArray)
        {
            SafeArrayDestroy(psaCodePagesArray);
        }
        if (psaIDArray)
        {
            SafeArrayDestroy(psaIDArray);
        }
        VariantClear(&vtLangDisplayImage);
        VariantClear(&vtLangISOName);
        VariantClear(&vtLangCharSet);
        VariantClear(&vtLangCodePage);
        VariantClear(&vtLangID);
    }
    return hr;

}    //    end of CSALocInfo::GetLanguages method


//++--------------------------------------------------------------
//
//  Function:   SetLangChangCallback
//
//  Synopsis:   This is the ISALocInfo interface method 
//              used to set callback when the language
//
//  Arguments: 
//              [in] IUnknown*    -    callback interface
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Modified     04/21/01 - added try/catch block
//
//----------------------------------------------------------------
STDMETHODIMP 
CSALocInfo::SetLangChangeCallBack(
                /*[in]*/    IUnknown *pLangChange
                )
{
    CSATraceFunc objTraceFunc("CSALocInfo::SetLangChangeCallBack");

    HRESULT hr = S_OK;
    
    _ASSERT(pLangChange);

    try
    {

        if (NULL==pLangChange)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = pLangChange->QueryInterface(
                           IID_ISALangChange, 
                           (void **)&m_pLangChange
                           );
            if (FAILED(hr))
            {
                SATracePrintf(
                    "QI for ISALangChange failed %X in SetLangChangeCallBack",
                     hr
                     );
                m_pLangChange = NULL;
                hr =  E_NOINTERFACE;
            }
        }
    }
    catch (...)
    {
        SATraceString ("SetLangChangeCallback caught unhandled exception");
        hr = E_FAIL;
    }
    
    return (hr);

}    //    end of CSALocInfo::SetLangChangeCallBack method


//++--------------------------------------------------------------
//
//  Function:   get_fAutoConfigDone
//
//  Synopsis:   This is the ISALocInfo interface method 
//              used to indicate if Auto Configuration of the language
//                has been done on this appliance
//
//  Arguments: 
//              [out,retval ] VARIANT_BOOL*        -    done (TRUE)
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Modified     04/21/01 - added try/catch block
//
//----------------------------------------------------------------
STDMETHODIMP 
CSALocInfo::get_fAutoConfigDone(
                /*[out,retval]*/VARIANT_BOOL *pvAutoConfigDone)
{
    CSATraceFunc    objTraceFunc ("CSALocInfo::get_fAutoConfigDone");

    CRegKey crKey;
    DWORD   dwErr, dwAutoConfigDone=0;
    HRESULT hr = S_OK;
    
    _ASSERT(pvAutoConfigDone);

    try
    {
        if (NULL == pvAutoConfigDone)
        {
            return E_INVALIDARG;
        }

        dwErr = crKey.Open(HKEY_LOCAL_MACHINE, 
                       RESOURCE_REGISTRY_PATH,
                       KEY_READ);
        if (ERROR_SUCCESS != dwErr)
        {
            SATracePrintf("RegOpen failed %ld in get_fAutoConfigDone", dwErr);
            return HRESULT_FROM_WIN32(dwErr);
        }
        crKey.QueryValue(dwAutoConfigDone, REGVAL_AUTO_CONFIG_DONE);

        (*pvAutoConfigDone) = ( (dwAutoConfigDone==1) ? VARIANT_TRUE : VARIANT_FALSE);
    }
    catch (...)
    {
        SATraceString ("get_fAutoConfigDone caught unhandled exception");
        hr = E_FAIL;
    }

    return (hr);

}    //    end of CSALocInfo::get_fAutoConfigDone method

//++--------------------------------------------------------------
//
//  Function:   get_CurrentCharSet
//
//  Synopsis:   This is the ISALocInfo interface method 
//              used to get the current character set
//
//  Arguments: 
//              [out,retval] BSTR*    -    Character Set
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Modified     04/21/01 - added thread-safety
//
//----------------------------------------------------------------
STDMETHODIMP 
CSALocInfo::get_CurrentCharSet(
                /*[out,retval]*/BSTR *pbstrCharSet
                )
{
    CSATraceFunc objTraceFunc ("CSALocInfo::get_CurrentCharSet");
    //
    // grab the critical section
    //
    CLock objLock(&m_hCriticalSection);

    LANGSET::iterator itrList;
    CLang             clBuf;
    DWORD             dwErr, dwCurLangID=0;
    CRegKey           crKey;
    HRESULT           hr = S_OK;

    _ASSERT(pbstrCharSet);

    try
    {
        if (NULL == pbstrCharSet)
        {
            return E_INVALIDARG;
        }

        //
        // initialize the component if not initialized
        //
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();
            if (FAILED (hr))
            { 
                SATracePrintf (
                  "LocMgr Initialization failed %x in get_CurrentCharSet",
                  hr
                  );
                return hr;
            }
        }

        dwErr = crKey.Open(HKEY_LOCAL_MACHINE, 
                       RESOURCE_REGISTRY_PATH,
                       KEY_READ);
        if (ERROR_SUCCESS != dwErr)
        {
            SATracePrintf("RegOpen failed %ld in get_CurrentCharSet", dwErr);
            hr = HRESULT_FROM_WIN32(dwErr);
            return hr;
        }
        crKey.QueryValue(dwCurLangID, LANGID_VALUE);

        itrList = m_LangSet.begin();

        while (itrList != m_LangSet.end())
        {
            clBuf = (*itrList);
            if (clBuf.m_dwLangID == dwCurLangID)
            {
                *pbstrCharSet = ::SysAllocString(clBuf.m_strLangCharSet.data());
                if (NULL == *pbstrCharSet)
                {
                        SATraceString (
                        "LocMgr unable to allocate string in get_CurrentCharSet"
                         );
                    hr = E_OUTOFMEMORY;
                }
                break;
            }
            itrList++;
        }
    }
    catch (...)
    {
        SATraceString ("get_CurrentCharSet caught unhandled exception");
        hr = E_FAIL;
    }

    return hr;

}    //    end of CSALocInfo::get_CurrentCharSet method

//++--------------------------------------------------------------
//
//  Function:   get_CurrentCodePage
//
//  Synopsis:   This is the ISALocInfo interface method 
//              used to get the current code page on the appliance
//
//  Arguments: 
//              [out,retval] VARIANT*    -    Code page
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Modified     04/21/01 - added thread-safety
//
//----------------------------------------------------------------
STDMETHODIMP 
CSALocInfo::get_CurrentCodePage(
                /*[out,retval]*/VARIANT *pvtiCodePage
                )
{
    CSATraceFunc objTraceFunc ("CSALocInfo::get_CurrentCodePage");
    //
    // grab the critical section
    //
    CLock objLock(&m_hCriticalSection);

    LANGSET::iterator itrList;
    CLang             clBuf;
    DWORD             dwErr, dwCurLangID=0;
    CRegKey           crKey;
    HRESULT           hr = S_OK;

    _ASSERT(pvtiCodePage);

    try
    {
        if (NULL == pvtiCodePage)
        {
            return E_INVALIDARG;
        }

        //
        // initialize the component if not initialized
        //
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();
            if (FAILED (hr))
            { 
                SATracePrintf (
                  "LocMgr Initialization failed %x in get_CurrentCodePage",
                  hr
                  );
                return hr;
            }
        }

        dwErr = crKey.Open(HKEY_LOCAL_MACHINE, 
                       RESOURCE_REGISTRY_PATH,
                       KEY_READ);
        if (ERROR_SUCCESS != dwErr)
        {
            SATracePrintf("RegOpen failed %ld in get_CurrentCodePage", dwErr);
            hr = HRESULT_FROM_WIN32(dwErr);
            return hr;
        }
        crKey.QueryValue(dwCurLangID, LANGID_VALUE);

        itrList = m_LangSet.begin();
        while (itrList != m_LangSet.end())
        {
            clBuf = (*itrList);
            if (clBuf.m_dwLangID == dwCurLangID)
            {
                V_VT(pvtiCodePage) = VT_I4;
                V_I4(pvtiCodePage) = clBuf.m_dwLangCodePage;
                break;
            }
            itrList++;
        }
    }
    catch (...)
    {
        SATraceString ("get_CurrentCodePage caught unhandled exception");
        hr = E_FAIL;
    }
    
    return hr;

}    //    end of CSALocInfo::get_CurrentCodePage method

//++--------------------------------------------------------------
//
//  Function:   get_CurrentLangID
//
//  Synopsis:   This is the ISALocInfo interface method 
//              used to get the current language ID on the appliance
//
//  Arguments: 
//              [out,retval] VARIANT*    -    language ID
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Modified     04/21/01 - added thread-safety
//
//----------------------------------------------------------------
STDMETHODIMP 
CSALocInfo::get_CurrentLangID(
                /*[out,retval]*/VARIANT *pvtiLangID)
{
    CSATraceFunc objTraceFunc ("CSALocInfo::get_CurrentLangID");
    //
    // grab the critical section
    //
    CLock objLock(&m_hCriticalSection);

    DWORD             dwErr, dwCurLangID=0;
    CRegKey           crKey;
    HRESULT           hr = S_OK;

    _ASSERT(pvtiLangID);

    try
    {
        if (NULL == pvtiLangID)
        {
                return E_INVALIDARG;
        }

        //
        // initialize the component if not initialized
        //
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();
            if (FAILED (hr))
            { 
                SATracePrintf (
                  "LocMgr Initialization failed %x in get_CurrentLangID",
                  hr
                  );
                return hr;
            }
        }

        dwErr = crKey.Open(HKEY_LOCAL_MACHINE, 
                       RESOURCE_REGISTRY_PATH,
                       KEY_READ);
        if (ERROR_SUCCESS != dwErr)
        {
            SATracePrintf("RegOpen failed %ld in get_CurrentLangID", dwErr);
            hr = HRESULT_FROM_WIN32(dwErr);
            return hr;
        }
        crKey.QueryValue(dwCurLangID, LANGID_VALUE);
        V_VT(pvtiLangID) = VT_I4;
        V_I4(pvtiLangID) = dwCurLangID;
    }
    catch (...)
    {
        SATraceString ("get_CurrentLangID caught unhandled exception");
        hr = E_FAIL;
    }

    return hr;

}    //    end of CSALocInfo::get_CurrentLangID method


//++--------------------------------------------------------------
//
//  Function:   GetModuleID
//
//  Synopsis:   This is the CSALocInfo class object private
//              method used to return the module handle to the
//              resource binary we are currently using
//
//  Arguments:  
//              [in]    BSTR     -   Resource File Name
//              [out]   HMODULE& -   module handle to return
//              
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Created     7/7/99
//
//----------------------------------------------------------------
HRESULT
CSALocInfo::GetModuleID (
        /*[in]*/    BSTR         bstrResourceFile,
        /*[out]*/   CModInfo&    cm
                        )
{
    CSATraceFunc objTraceFunc ("CSALocInfo::GetModuleID");
    
    _ASSERT (bstrResourceFile);
    if (bstrResourceFile == NULL)
    {
        return E_POINTER;
    }
    
    HRESULT hr = S_OK;
    do
    {
        //
        // make the resource file name all lowercase
        //
        WCHAR wszLowerName[MAX_PATH];
        if ( (wcslen(bstrResourceFile)+1) > MAX_PATH)
        {
            SATraceString("CSALocInfo::GetModuleID failed, input string is longer than expected");
            hr = E_INVALIDARG;
            break;
        }

        ::wcscpy (wszLowerName, bstrResourceFile);

        if (::_wcsicmp(wszLowerName, DEFAULT_ALERT_LOG) == 0)
        {
            ::wcscpy(wszLowerName, DEFAULT_SAMSG_DLL);
        }
        ::_wcslwr (wszLowerName);

        //
        // try to find the module in the map
        //
        MODULEMAP::iterator itr = m_ModuleMap.find (wszLowerName);

        SATracePrintf("Looking for module matching %s", 
                      (const char*)_bstr_t(wszLowerName));

        if (itr == m_ModuleMap.end ())
        {
            //
            // the module is not present in the map 
            // we will load it now
            //

            //
            // complete the full path
            //
            WCHAR wszFullName [MAX_PATH];
            if ( (wcslen(m_wstrResourceDir.data())+wcslen(DELIMITER)+
                 wcslen(wszLowerName)+1) > MAX_PATH )
            {
                SATraceString("CSALocInfo::GetModuleID failed, input string is longer than expected");
                hr = E_INVALIDARG;
                break;
            }

            ::wcscpy (wszFullName, m_wstrResourceDir.data());
            ::wcscat (wszFullName, DELIMITER);
            ::wcscat (wszFullName, wszLowerName);

            SATracePrintf (
                "Localization Manager loading resource file:'%ws'...",
                bstrResourceFile
                );

            cm.m_hModule = ::LoadLibraryEx (
                                        wszFullName,
                                        NULL,
                                        LOAD_LIBRARY_AS_DATAFILE
                                        ); 
            if (NULL == cm.m_hModule)
            {
                SATracePrintf(
                    "Localization Manager failed to load resource file %ld, trying Default Language....",
                    GetLastError ()
                    );
                    hr = E_FAIL;
                    break;
            }
            else
            {
                cm.m_dwLangId = this->m_dwLangId;
            }
            cm.m_rType = CModInfo::UNKNOWN;

            //
            // insert this module in the map
            //
            m_ModuleMap.insert (
                MODULEMAP::value_type (_bstr_t (wszLowerName), cm)
                );
        }
        else
        {
            SATracePrintf (
                "Localization Manager found res. file handle:'%ws' in map...",
                bstrResourceFile
                );
            //
            // we already have the module in the map
            //
            cm = (*itr).second;
        }
    }
    while (false);

    return (hr);
        
}   //  end of CSALocInfo::GetModuleID method

//++--------------------------------------------------------------
//
//  Function:   SetModInfo
//
//  Synopsis:   This is the private method of CSALocInfo class 
//              which is used to set the resource module info.
//
//  Arguments: 
//              [in]    BSTR    - Resource File Name
//                [out]    CModInfo& - Module Info
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Modified     04/21/01 - added comments
//
//----------------------------------------------------------------
void
CSALocInfo::SetModInfo (
        /*[in]*/    BSTR             bstrResourceFile,
        /*[out]*/   const CModInfo&  cm
                        )
{
    SATraceFunction("CSALocInfo::SetModInfo");

    WCHAR wszLowerName[MAX_PATH];
    if ( (wcslen(bstrResourceFile)+1) > MAX_PATH)
    {
        SATraceString("CSALocInfo::SetModInfo failed, input string is longer than expected");
        return;
    }

    ::wcscpy(wszLowerName, bstrResourceFile);
    if (::_wcsicmp(wszLowerName, DEFAULT_ALERT_LOG) == 0)
    {
        ::wcscpy(wszLowerName, DEFAULT_SAMSG_DLL);
    }
    ::_wcslwr (wszLowerName);

    SATracePrintf("Adding \'%ws\' to map", wszLowerName);

    _bstr_t bstrName(wszLowerName);
    m_ModuleMap.erase(bstrName);
    m_ModuleMap.insert(
        MODULEMAP::value_type(bstrName,  cm)
                      );

}    //    end of CSALocInfo::SetModInfo method

//++--------------------------------------------------------------
//
//  Function:   InternalInitialize
//
//  Synopsis:   This is the CSALocInfo class object internal 
//              initialization method
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Created     7/7/99
//
//----------------------------------------------------------------
HRESULT 
CSALocInfo::InternalInitialize (
                VOID
                )
{ 
    CSATraceFunc    objTraceFunc ("CSALocInfo::InternalInitialize");
    
    DWORD        dwExitCode, dwErr;
    bool         fRestartThread = false;
    unsigned int uThreadID;
    HANDLE       hCurrentThreadToken, hChildThreadToken;

    InitLanguagesAvailable();

    SetLangID();

    //
    // get the resource dll directory
    //
    HRESULT hr = GetResourceDirectory (m_wstrResourceDir);
    if (FAILED (hr)) {return (hr);}
    
    //
    // our own resource binary entry is always present
    // It is sakitmsg.dll
    //
    // HMODULE hModule =  _Module.GetModuleInstance ();

    CModInfo cm;
    hr = GetModuleID (_bstr_t(DEFAULT_SAMSG_DLL), cm);
    if (FAILED(hr)) {return (E_FAIL);}

    do
    {
        if (m_hThread)
        {
            if (GetExitCodeThread(m_hThread, &dwExitCode) == 0)
            {
                SATracePrintf("GetExitCodeThread failed %ld", GetLastError());
                break;
            }
            fRestartThread = ((dwExitCode == STILL_ACTIVE) ? false : true);
            if (true == fRestartThread)
            {
                SATracePrintf("Thread exited with code %ld", dwExitCode);
            }
        }

        if ( (NULL == m_hThread) || (true == fRestartThread) )
        {
            if ((m_hThread = (HANDLE)_beginthreadex(NULL,
                                                    0,
                                                    WaitForLangChangeThread,
                                                    this,
                                                    CREATE_SUSPENDED,
                                                    &uThreadID)) == NULL)
             {
                 SATracePrintf("ForkThread failed %ld", GetLastError());
                 break;
             }
             if (OpenThreadToken(GetCurrentThread(), 
                                 TOKEN_DUPLICATE | TOKEN_IMPERSONATE, 
                                 TRUE, 
                                 &hCurrentThreadToken) == 0)
             {
                 dwErr = GetLastError();
                 if (ERROR_NO_TOKEN == dwErr)
                 {
                     if (OpenProcessToken(GetCurrentProcess(), 
                                          TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                                          &hCurrentThreadToken) == 0)
                     {
                         SATracePrintf("OpenProcessToken failed %ld", GetLastError());
                         break;
                     }
                 }
                 else
                 {
                     SATracePrintf("OpenThreadToken Error %ld", GetLastError());
                     break;
                 }
             }

             if (DuplicateToken(hCurrentThreadToken, 
                                SecurityImpersonation, 
                                &hChildThreadToken) == 0)
             {
                 SATracePrintf("DuplicateToken Error %ld", GetLastError());
                 break;
             }

             if (SetThreadToken(&m_hThread, hChildThreadToken) == 0)
             {
                 SATracePrintf("SetThreadToken Error %ld", GetLastError());
                 break;
             }
             if (ResumeThread(m_hThread) == -1)
             {
                 SATracePrintf("ResumeThread Error %ld", GetLastError());
                 break;
             }
        }

    } while (FALSE);

    m_bInitialized = true;
    return (S_OK);

}   //  end of CSALocInfo::InternalInitialize method

//++--------------------------------------------------------------
//
//  Function:   InitLanguagesAvailable
//
//  Synopsis:   This is the CSALocInfo class object private method
//                to determine the languages available on this appliance
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Modified  04/21/01 - comments added
//
//----------------------------------------------------------------
HRESULT CSALocInfo::InitLanguagesAvailable(void)
{
    CSATraceFunc    objTraceFunc ("CSALocInfo::InitLanguagesAvailable");
    
    CRegKey            crKey;
    DWORD              dwErr, dwBufLen;
    wstring            wstrDir;
    _variant_t         vtPath;
    WIN32_FIND_DATA    wfdBuf;
    HANDLE             hFile = INVALID_HANDLE_VALUE;
    HRESULT            hr=S_OK;
    BOOL               bRetVal;
    CLang              lBuf;
    LANGSET::iterator  itr;
    TCHAR              szLangData[MAX_PATH];
    LPTSTR             lpszExStr=NULL;
    DWORD              dwTemp=0;
    wstring            wstrCodePage;
    wstring               wstrSearchDir;


    //
    // get resource path from the registry
    //
    dwErr = crKey.Open(HKEY_LOCAL_MACHINE, 
                       RESOURCE_REGISTRY_PATH,
                       KEY_READ);
    if (ERROR_SUCCESS != dwErr)
    {
        SATracePrintf("RegOpen failed %ld in InitLanguagesAvailable", dwErr);
        hr = HRESULT_FROM_WIN32(dwErr);
        goto End;
    }

    //
    // get the resource path from the registry
    //
    bRetVal = ::GetObjectValue (
                            RESOURCE_REGISTRY_PATH,
                            RESOURCE_DIRECTORY,
                            &vtPath,
                            VT_BSTR
                               );
    if (!bRetVal)
    {
        SATraceString ("GetObjectValue failed in InitLangaugesAvailable");
        wstrDir.assign (DEFAULT_DIRECTORY);
    }
    else
    {
        wstrDir.assign (V_BSTR (&vtPath)); 
    }

    hr = ExpandSz(wstrDir.data(), &lpszExStr);
    if (FAILED(hr))
    {
        wstrDir.assign (DEFAULT_EXPANDED_DIRECTORY);
    }
    else
    {
        wstrDir.assign(lpszExStr);
        SaFree(lpszExStr);
        lpszExStr = NULL;
    }

    //
    // create a search directory 
    //
    wstrSearchDir.assign (wstrDir);
    wstrSearchDir.append (DELIMITER);
    wstrSearchDir.append (WILDCARD);

    //
    // skip . 
    //
    hFile = FindFirstFile(wstrSearchDir.data(), &wfdBuf);
    if (hFile==INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        SATracePrintf("FindFirstFile failed %ld", dwErr);
        hr = HRESULT_FROM_WIN32(dwErr);
        goto End;
    }

    //
    // skip ..
    //
    if (FindNextFile(hFile, &wfdBuf) == 0)
    {
        dwErr = GetLastError();
        SATracePrintf("FindNextFile failed %ld first time!", dwErr);
        hr = HRESULT_FROM_WIN32(dwErr);
        goto End;
    }

    while (1)
    {
        if (FindNextFile(hFile, &wfdBuf) == 0)
        {
            dwErr = GetLastError();
            if (ERROR_NO_MORE_FILES != dwErr)
            {
                SATracePrintf("FindNextFile failed %ld", dwErr);
                hr = HRESULT_FROM_WIN32(dwErr);
                goto End;
            }
            break;
        }
        SATracePrintf("FileName is %ws", wfdBuf.cFileName);
        dwBufLen = MAX_PATH;
        dwErr = crKey.QueryValue(szLangData, 
                                 wfdBuf.cFileName, 
                                 &dwBufLen);
        if (ERROR_SUCCESS != dwErr)
        {
            SATracePrintf("Lang %ws not in registry, ignoring (error %ld)", 
                          wfdBuf.cFileName,
                          dwErr);
            continue;
        }


        //
        // check if this is a valid language directory
        //
        if (!IsValidLanguageDirectory ((PWSTR) wstrDir.data (), wfdBuf.cFileName))
        {
            SATracePrintf (
                "CSALocInfo::InitLanguagesAvailable found that '%ws' is not a valid lang directory, ignoring...",
                wfdBuf.cFileName
                );
            continue;
        }
        
        //
        // get the first part of the REG_MULTI_SZ 
        // (date of the form {"DisplayImage", "ISOName", "Charset", "CodePage"}
        //
        lBuf.m_strLangDisplayImage.assign(szLangData);


        //
        // get the 2nd string in the REG_MULTI_SZ
        //
        lBuf.m_strLangISOName.assign(szLangData + wcslen(szLangData) + 1);
        
        //
        // get the 3rd string in the REG_MULTI_SZ
        //
        lBuf.m_strLangCharSet.assign(szLangData + 
                                     lBuf.m_strLangDisplayImage.size() +
                                     lBuf.m_strLangISOName.size() +
                                     2);

        //
        // get the 4th string in the REG_MULTI_SZ
        //
        wstrCodePage.assign(szLangData + 
                            lBuf.m_strLangDisplayImage.size() +
                            lBuf.m_strLangISOName.size() + 
                            lBuf.m_strLangCharSet.size() + 
                            3);
                           
        lBuf.m_dwLangCodePage = _wtoi(wstrCodePage.data());

        //
        // The directory name is the Lang ID
        //
        //swscanf(wfdBuf.cFileName, TEXT("%X"), &lBuf.m_dwLangID);
        lBuf.m_dwLangID = wcstoul (wfdBuf.cFileName, NULL, 16);

        SATracePrintf("Adding DisplayImage \'%ws\' ISO Name \'%ws\' CharSet \'%ws\' CodePage \'%ld\' ID \'%ld\'", 
                      lBuf.m_strLangDisplayImage.data(), 
                      lBuf.m_strLangISOName.data(), 
                      lBuf.m_strLangCharSet.data(), 
                      lBuf.m_dwLangCodePage,
                      lBuf.m_dwLangID);

        m_LangSet.insert(lBuf);
    }

End:
    if (hFile != INVALID_HANDLE_VALUE)
    {
        FindClose(hFile);
    }
    return hr;

}    //    end of CSALocInfo::InitLanguagesAvailable method

//++--------------------------------------------------------------
//
//  Function:   Cleanup
//
//  Synopsis:   This is the CSALocInfo class object private method
//              used to cleanup the object resources 
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     7/7/99
//
//----------------------------------------------------------------
VOID
CSALocInfo::Cleanup (
                VOID
                )
{
    CSATraceFunc objTraceFunc ("CSALocInfo::Cleanup");
    
    MODULEMAP::iterator itr = m_ModuleMap.begin ();
    while (itr != m_ModuleMap.end ())
    {
        SATracePrintf (
            "Localization Manager unloading:'%ws'...",
            (PWCHAR)((*itr).first)
            );

        //
        // free the module now
        //
        ::FreeLibrary ((*itr).second.m_hModule);
        itr = m_ModuleMap.erase(itr);
    }

    LANGSET::iterator itrList = m_LangSet.begin();

    while (itrList != m_LangSet.end())
    {
        itrList = m_LangSet.erase(itrList);
    }

    m_bInitialized = false;
    return;
}   //  end of CSALocInfo::Cleanup method

//++--------------------------------------------------------------
//
//  Function:   GetResourceDirectory
//
//  Synopsis:   This is the CSALocInfo class object private method
//              used to get the directory where the resource dlls are
//              present
//
//  Arguments:  [out]    wstring&    -   directory path
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     7/7/99
//
//----------------------------------------------------------------
HRESULT
CSALocInfo::GetResourceDirectory (
        /*[out]*/   wstring&    m_wstrResourceDir
        )
{
    CSATraceFunc    objTraceFunc ("CSALocInfo::GetResourceDirectory");
    
    TCHAR  szLangId[10];
    LPTSTR lpszExStr=NULL;

    HRESULT hr = S_OK;
    do
    {

        CComVariant vtPath;
        //
        // get the resource path from the registry
        //
        BOOL bRetVal = ::GetObjectValue (
                                    RESOURCE_REGISTRY_PATH,
                                    RESOURCE_DIRECTORY,
                                    &vtPath,
                                    VT_BSTR
                                    );
        if (!bRetVal)
        {
            SATraceString (
                "Localization manager unable to obtain resource dir path"
                );
            m_wstrResourceDir.assign (DEFAULT_DIRECTORY);
        }
        else
        {
            m_wstrResourceDir.assign (V_BSTR (&vtPath)); 
        }

        hr = ExpandSz(m_wstrResourceDir.data(), &lpszExStr);
        if (FAILED(hr))
        {
            m_wstrResourceDir.assign (DEFAULT_EXPANDED_DIRECTORY);
        }
        else
        {
            m_wstrResourceDir.assign(lpszExStr);
            SaFree(lpszExStr);
            lpszExStr = NULL;
        }

        m_wstrResourceDir.append (DELIMITER);

        wsprintf(szLangId, TEXT("%04X"), m_dwLangId);

        m_wstrResourceDir.append (szLangId);
        
        SATracePrintf ("Localization Manager has set LANGID to:%d", m_dwLangId);


        //
        // success
        //
        SATracePrintf (
            "Localization Manager determined resource directory:'%ws'",
            m_wstrResourceDir.data ()
            );
            
    }
    while (false);

    return (hr);

}   //  end of CSALocInfo::GetResourceDirectory method

//++--------------------------------------------------------------
//
//  Function:   WaitForLangChangeThread
//
//  Synopsis:   This is the CSALocInfo class static private method
//              in which the thread used to do carry out change language
//                functionality runs
//
//  Arguments:  [in]    PVOID   -   pointer to CSALocInfo object
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Modified     04/21/01     - added thread safety
//----------------------------------------------------------------

unsigned int __stdcall CSALocInfo::WaitForLangChangeThread(void *pvThisObject)
{
    CSALocInfo *pObject = (CSALocInfo *)pvThisObject;
    DWORD      dwErr, dwLangID, dwMaxPath;
    CRegKey    crKey;
    HANDLE     hEvent;
    HRESULT    hr;

    SATraceFunction("CSALocInfo::WaitForLangChangeThread");

    dwErr = CreateLangChangeEvent(&hEvent);
    if (NULL == hEvent)
    {
        SATracePrintf("CreateEvent failed %ld", dwErr);
        return dwErr;
    }

    while (1)
    {
        SATraceString ("Worker thread going to sleep...");
        WaitForSingleObject(hEvent, INFINITE);
        SATraceString("Event Signalled, doing language change...");
        //
        // let the object do the work
        //
        pObject->DoLanguageChange ();
    }

    //
    // cleanup
    //
    CloseHandle(hEvent);

    return 0;

}    //    end of CSALocInfo::WaitForLangChangeThread method

//++--------------------------------------------------------------
//
//  Function:   ExpandSz
//
//  Synopsis:   This is the CSALocInfo class object private method
//                used to expand the environment variables passed in
//
//  Arguments:  
//                [in]    TCHAR*    - in string
//                [out]    LPTSTR*    - out string
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Modified  04/21/01 - comments added
//
//----------------------------------------------------------------
HRESULT
CSALocInfo::ExpandSz(
    IN const TCHAR *lpszStr, 
    OUT LPTSTR *ppszStr
    )
{
    CSATraceFunc objTraceFunc ("CSALocInfo::ExpandSz");
    
    DWORD  dwBufSize = 0;

    _ASSERT(lpszStr);
    _ASSERT(ppszStr);
    _ASSERT(NULL==(*ppszStr));

    if ((NULL==lpszStr) || (NULL==ppszStr) ||
        (NULL != (*ppszStr)))
    {
        return E_INVALIDARG;
    }

    dwBufSize = ExpandEnvironmentStrings(lpszStr,
                                         (*ppszStr),
                                         dwBufSize);
    _ASSERT(0 != dwBufSize);
    (*ppszStr) = (LPTSTR)SaAlloc(dwBufSize * sizeof(TCHAR) );
    if (NULL == (*ppszStr))
    {
        SATraceString("MemAlloc failed in ExpandSz");
        return E_OUTOFMEMORY;
    }
    ExpandEnvironmentStrings(lpszStr,
                             (*ppszStr),
                             dwBufSize);
    SATracePrintf("Expanded string is \'%ws\'", (*ppszStr));
    return S_OK;
}

//++--------------------------------------------------------------
//
//  Function:   GetMcString
//
//  Synopsis:   This is the CSALocInfo class object private method
//                used to get strings specfied through a message file
//  Arguments:  
//                [in]    HMODULE     -     module name
//                [in]    LONG        -    Message ID
//                [in]    DWROD        -     language ID
//                [out]    LPWSTR        -    returned message
//                [in]    LONG        -    buffer size
//                [in]    va_list*    -    arguments 
//
//  Returns:    DWORD - bytes written
//
//
//  History:    MKarki      Modified  04/21/01 - comments added
//
//----------------------------------------------------------------
DWORD 
CSALocInfo::GetMcString(
            IN     HMODULE     hModule, 
            IN        LONG     lMessageId, 
            IN       DWORD     dwLangId,
            IN OUT  LPWSTR     lpwszMessage, 
            IN        LONG     lBufSize,
            IN        va_list  *pArgs)
{
    CSATraceFunc    objTraceFunc ("CSALocInfo::GetMcString");
    
    DWORD dwBytesWritten = 0;

    dwBytesWritten = ::FormatMessage (
                          FORMAT_MESSAGE_FROM_HMODULE|
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          hModule,
                          lMessageId,
                          dwLangId,
                          lpwszMessage,
                          lBufSize,
                          pArgs
                                      );
    if (0 == dwBytesWritten)
    {
        SATracePrintf(
              "GetMcString failed(%ld) on FormatMessage for id  %X",
               GetLastError(),
               lMessageId
                     );
    }
    else
    { 
        //
        // remove the carriage-return/line-feed
        // from the end of the string
        //
        lpwszMessage[::wcslen (lpwszMessage) - 2] = L'\0';
    }

    return dwBytesWritten;

}    //    end of CSALocInfo::GetMcString method

//++--------------------------------------------------------------
//
//  Function:   GetRcString
//
//  Synopsis:   This is the CSALocInfo class object private method
//                used to get strings specfied through a message file
//  Arguments:  
//                [in]    HMODULE     -     module name
//                [in]    LONG        -    Message ID
//                [in]    DWROD        -     language ID
//                [out]    LPWSTR        -    returned message
//                [in]    LONG        -    buffer size
//                [in]    va_list*    -    arguments 
//
//  Returns:    DWORD - bytes written
//
//
//  History:    MKarki      Modified  04/21/01 - comments added
//
//----------------------------------------------------------------

DWORD
CSALocInfo::GetRcString(
            IN     HMODULE     hModule, 
            IN        LONG     lMessageId, 
            IN OUT  LPWSTR     lpwszMessage, 
            IN        LONG     lBufSize
                       )
{
    CSATraceFunc     objTracFunc ("CSALocInfo::GetRcString");
    
    DWORD dwBytesWritten = 0;

    dwBytesWritten = LoadString(hModule,
                                lMessageId,
                                lpwszMessage,
                                lBufSize
                               );
    if (0 == dwBytesWritten)
    {
        SATracePrintf(
            "GetRcString failed(%ld) on LoadString for id %X",
            GetLastError(),
            lMessageId
                     );
    }
    return dwBytesWritten;

}    //    end of CSALocInfo::GetRcString method

//++--------------------------------------------------------------
//
//  Function:   SetLangID
//
//  Synopsis:   This is the CSALocInfo class object private method
//                used to set the language ID in the registry
//
//  Arguments:  none
//                
//
//  Returns:    void
//
//
//  History:    MKarki      Modified  04/21/01 - comments added
//
//----------------------------------------------------------------
void 
CSALocInfo::SetLangID(void)
{
    CSATraceFunc objTraceFunc ("CSALocInfo::SetLangID");
    
    DWORD   dwErr, dwNewLangID, dwCurLangID;
    CRegKey crKey;

    dwErr = crKey.Open(HKEY_LOCAL_MACHINE, RESOURCE_REGISTRY_PATH);
    if (dwErr != ERROR_SUCCESS)
    {
        SATracePrintf("RegOpen(2) failed %ld in SetLangID", dwErr);
        return;
    }

    dwCurLangID = 0;
    dwErr = crKey.QueryValue(dwCurLangID, LANGID_VALUE);
    if (ERROR_SUCCESS != dwErr)
    {
        SATracePrintf("QueryValue(CUR_LANGID_VALUE) failed %ld in SetLangID", dwErr);
        return;
    }
    else
    {
        m_dwLangId = dwCurLangID;
        dwNewLangID = 0;
        dwErr = crKey.QueryValue(dwNewLangID, NEW_LANGID_VALUE);
        if (ERROR_SUCCESS != dwErr)
        {
            SATracePrintf("QueryValue(CUR_LANGID_VALUE) failed %ld in SetLangID", dwErr);
            return;
        }
        if (dwNewLangID == dwCurLangID)
        {
            SATraceString("NewLangID = CurLangID in SetLangID");
            return;
        }
        else
        {
            LANGSET::iterator itrList = m_LangSet.begin();
            CLang clBuf;
    
            bool fLangPresent = false;
            while (itrList != m_LangSet.end())
            {
                clBuf = (*itrList);
                if (clBuf.m_dwLangID == dwNewLangID)
                {
                    fLangPresent = true;
                    break;
                }
                itrList++;
            }
            if (true == fLangPresent)
            {
                crKey.SetValue(dwNewLangID, LANGID_VALUE);
                m_dwLangId = dwNewLangID;
            }
            else
            {
                SATracePrintf("NewLangId(%ld) not valid, ignoring..",
                              dwNewLangID);
            }
        }
    }

}    //    end of CSALocInfo::SetLangID method


//++--------------------------------------------------------------
//
//  Function:   IsValidLanguageDirectory
//
//  Synopsis:   This is CSALocInfo private method which checks
//                that the language directory specified is valid - 
//                this verified by checking if it has the DEFAULT_SAMSG_DLL
//                present in it. We need to do this because the SDK installation
//                creates directories for languages which are not installed by
//                the SA Kit.
//
//  Arguments: 
//              [in]    PWSTR    -  Directory Path 
//              [in]    PWSTR    -  Directory Name
//
//  Returns:    bool (true/false)
//
//  History:    MKarki      Created     4/3/2001
//
//----------------------------------------------------------------
bool
CSALocInfo::IsValidLanguageDirectory (
    /*[in]*/    PWSTR    pwszDirectoryPath,
    /*[in]*/    PWSTR    pwszDirectoryName
    )
{
    CSATraceFunc objTraceFunc ("CSALocInfo::IsValidLanguageDirectory");
    
    bool bRetVal = true;

    do
    {
        if ((NULL == pwszDirectoryPath) || (NULL == pwszDirectoryName))
        {
            SATraceString ("IsValidLanguageDirectory - passed in incorrect arguments");
            bRetVal = false;
            break;
        }

        //
        // build up the complete name of the default message DLL
        //
        wstring wstrFullName (pwszDirectoryPath);
        wstrFullName.append (DELIMITER);
        wstrFullName.append (pwszDirectoryName);
        wstrFullName.append (DELIMITER);
        wstrFullName.append (DEFAULT_SAMSG_DLL);

        WIN32_FIND_DATA    wfdBuffer;
        //
        // look for the existence of this file
        // if it exists than we have a valid language directory
        //
        HANDLE hFile = FindFirstFile (wstrFullName.data(), &wfdBuffer);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            SATracePrintf (
                "IsValidLanguageDirectory failed on FindFirstFile for:'%ws',%d",
                wstrFullName.data (), GetLastError ()
                );
            bRetVal = false;
            break;
        }

        //
        // success
        //

    }while (false);

    return (bRetVal);
    
}    //    end of CSALocInfo::IsValidLanguageDirectory method

//++--------------------------------------------------------------
//
//  Function:   DoLanguageChange 
//
//  Synopsis:   This is CSALocInfo private method which is caled
//                from the worker thread and used to carry out the
//                language change
//
//  Arguments:     none
//
//  Returns:    void
//
//  History:    MKarki      Created     4/21/2001
//
//----------------------------------------------------------------
VOID    
CSALocInfo::DoLanguageChange (
    VOID
    )
{
    CSATraceFunc objTraceFunc ("CSALocInfo::DoLanguageChange");
    //
    // grab the critical section
    //
    CLock objLock (&m_hCriticalSection);

    HRESULT hr = S_OK;
    
    try
    {
        _bstr_t bstrLangDisplayImage, bstrLangISOName;

        //
        // initialize the component if not initialized
        //
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();
            if (FAILED (hr))
            { 
                SATracePrintf (
                    "DoLanguageChange failed:%x on InternalInitialize",
                    hr
                    );
            }
        }
        else
        {
            //
            // InternalInitialize will set the Lang ID; 
            // so it needn't be called if InternalInitalize 
            // is called
            //
            SetLangID();
        }

        LANGSET::iterator itrList = m_LangSet.begin();
        CLang clBuf;
    
        while (itrList != m_LangSet.end())
        {
            clBuf = (*itrList);
            if (clBuf.m_dwLangID == m_dwLangId)
            {
                bstrLangDisplayImage = clBuf.m_strLangDisplayImage.data();
                bstrLangISOName = clBuf.m_strLangISOName.data();
                Cleanup();
                if (m_pLangChange)
                {
                    hr = m_pLangChange->InformChange(
                                      bstrLangDisplayImage,
                                      bstrLangISOName,
                                      (unsigned long) m_dwLangId
                                                             );
                    if (FAILED(hr))
                    {
                        SATracePrintf(
                    "InformChange failed %X in DoLanguageChange",
                                      hr);
                    }
                }

                //
                // do the initialization again
                //
                if (!m_bInitialized) 
                {
                    hr = InternalInitialize ();
                    if (FAILED (hr))
                    { 
                        SATracePrintf (
                            "DoLanguageChange failed:%x on InternalInitialize second call",
                            hr
                            );
                    }
                }

                break;
            }
            itrList++;
        }
    }
    catch (...)
    {
        SATraceString ("DoLanguageChange caught unhandled exception");
    }

    return;

}    //    end of CSALocInfo::DoLanguageChange method

//**********************************************************************
// 
// FUNCTION:  IsOperationAllowedForClient - This function checks the token of the 
//            calling thread to see if the caller belongs to the Local System account
// 
// PARAMETERS:   none
// 
// RETURN VALUE: TRUE if the caller is an administrator on the local
//            machine.  Otherwise, FALSE.
// 
//**********************************************************************
BOOL 
CSALocInfo::IsOperationAllowedForClient (
            VOID
            )
{

    HANDLE hToken = NULL;
    DWORD  dwStatus  = ERROR_SUCCESS;
    DWORD  dwAccessMask = 0;;
    DWORD  dwAccessDesired = 0;
    DWORD  dwACLSize = 0;
    DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
    PACL   pACL            = NULL;
    PSID   psidLocalSystem  = NULL;
    BOOL   bReturn        =  FALSE;

    PRIVILEGE_SET   ps;
    GENERIC_MAPPING GenericMapping;

    PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    CSATraceFunc objTraceFunc ("CSALocInfo::IsOperationAllowedForClient ");
       
    do
    {
        //
        // we assume to always have a thread token, because the function calling in
        // appliance manager will be impersonating the client
        //
        bReturn  = OpenThreadToken(
                               GetCurrentThread(), 
                               TOKEN_QUERY, 
                               FALSE, 
                               &hToken
                               );
        if (!bReturn)
        {
            SATraceFailure ("CSALocInfo::IsOperationAllowedForClient failed on OpenThreadToken:", GetLastError ());
            break;
        }


        //
        // Create a SID for Local System account
        //
        bReturn = AllocateAndInitializeSid (  
                                        &SystemSidAuthority,
                                        1,
                                        SECURITY_LOCAL_SYSTEM_RID,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        &psidLocalSystem
                                        );
        if (!bReturn)
        {     
            SATraceFailure ("CSALocInfo:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  GetLastError ());
            break;
        }
    
        //
        // get memory for the security descriptor
        //
        psdAdmin = HeapAlloc (
                              GetProcessHeap (),
                              0,
                              SECURITY_DESCRIPTOR_MIN_LENGTH
                              );
        if (NULL == psdAdmin)
        {
            SATraceString ("CSALocInfo::IsOperationForClientAllowed failed on HeapAlloc");
            bReturn = FALSE;
            break;
        }
      
        bReturn = InitializeSecurityDescriptor(
                                            psdAdmin,
                                            SECURITY_DESCRIPTOR_REVISION
                                            );
        if (!bReturn)
        {
            SATraceFailure ("CSALocInfo::IsOperationForClientAllowed failed on InitializeSecurityDescriptor:", GetLastError ());
            break;
        }

        // 
        // Compute size needed for the ACL.
        //
        dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                    GetLengthSid (psidLocalSystem);

        //
        // Allocate memory for ACL.
        //
        pACL = (PACL) HeapAlloc (
                                GetProcessHeap (),
                                0,
                                dwACLSize
                                );
        if (NULL == pACL)
        {
            SATraceString ("CSALocInfo::IsOperationForClientAllowed failed on HeapAlloc2");
            bReturn = FALSE;
            break;
        }

        //
        // Initialize the new ACL.
        //
        bReturn = InitializeAcl(
                              pACL, 
                              dwACLSize, 
                              ACL_REVISION2
                              );
        if (!bReturn)
        {
            SATraceFailure ("CSALocInfo::IsOperationForClientAllowed failed on InitializeAcl", GetLastError ());
            break;
        }


        // 
        // Make up some private access rights.
        // 
        const DWORD ACCESS_READ = 1;
        const DWORD  ACCESS_WRITE = 2;
        dwAccessMask= ACCESS_READ | ACCESS_WRITE;

        //
        // Add the access-allowed ACE to the DACL for Local System
        //
        bReturn = AddAccessAllowedAce (
                                    pACL, 
                                    ACL_REVISION2,
                                    dwAccessMask, 
                                    psidLocalSystem
                                    );
        if (!bReturn)
        {
            SATraceFailure ("CSALocInfo::IsOperationForClientAllowed failed on AddAccessAllowedAce (LocalSystem)", GetLastError ());
            break;
        }
              
        //
        // Set our DACL to the SD.
        //
        bReturn = SetSecurityDescriptorDacl (
                                          psdAdmin, 
                                          TRUE,
                                          pACL,
                                          FALSE
                                          );
        if (!bReturn)
        {
            SATraceFailure ("CSALocInfo::IsOperationForClientAllowed failed on SetSecurityDescriptorDacl", GetLastError ());
            break;
        }

        //
        // AccessCheck is sensitive about what is in the SD; set
        // the group and owner.
        //
        SetSecurityDescriptorGroup(psdAdmin, psidLocalSystem, FALSE);
        SetSecurityDescriptorOwner(psdAdmin, psidLocalSystem, FALSE);

        bReturn = IsValidSecurityDescriptor(psdAdmin);
        if (!bReturn)
        {
            SATraceFailure ("CSALocInfo::IsOperationForClientAllowed failed on IsValidSecurityDescriptorl", GetLastError ());
            break;
        }
     

        dwAccessDesired = ACCESS_READ;

        // 
        // Initialize GenericMapping structure even though we
        // won't be using generic rights.
        // 
        GenericMapping.GenericRead    = ACCESS_READ;
        GenericMapping.GenericWrite   = ACCESS_WRITE;
        GenericMapping.GenericExecute = 0;
        GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;
        BOOL bAccessStatus = FALSE;

        //
        // check the access now
        //
        bReturn = AccessCheck  (
                                psdAdmin, 
                                hToken, 
                                dwAccessDesired, 
                                &GenericMapping, 
                                &ps,
                                &dwStructureSize, 
                                &dwStatus, 
                                &bAccessStatus
                                );

        if (!bReturn || !bAccessStatus)
        {
            SATraceFailure ("CSALocInfo::IsOperationForClientAllowed failed on AccessCheck", GetLastError ());
        } 
        else
        {
            SATraceString ("CSALocInfo::IsOperationForClientAllowed, Client is allowed to carry out operation!");
        }

        //
        // successfully checked 
        //
        bReturn  = bAccessStatus;        
 
    }    
    while (false);

    //
    // Cleanup 
    //
    if (pACL) 
    {
        HeapFree (GetProcessHeap (), 0, pACL);
    }

    if (psdAdmin) 
    {
        HeapFree (GetProcessHeap (), 0, psdAdmin);
    }
          

    if (psidLocalSystem) 
    {
        FreeSid(psidLocalSystem);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return (bReturn);

}// end of CSALocInfo::IsOperationValidForClient method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\event.cpp ===
#include "stdafx.h"
#include "event.h"
#include "common.cpp"

DWORD CreateLangChangeEvent(HANDLE *phEvent)
{
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    PACL                paclBuf=NULL;
    DWORD               dwErr = 0, dwAclBufLen=0;
    PSID                pAdminSid = NULL;
    SID_IDENTIFIER_AUTHORITY siaValue = SECURITY_NT_AUTHORITY;
    HANDLE hEvent;

    ASSERT(phEvent);
    if (NULL == phEvent)
    {
        SATraceString("Event parameter NULL in CreateLangChangeEvent");
        return ERROR_INVALID_PARAMETER;
    }

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = &sd;

    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) 
    {
        SATracePrintf("unable to InitializeSecurityDescriptor, err == %d\n", GetLastError());
    }

    dwErr = AllocateAndInitializeSid(&siaValue, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                        DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pAdminSid );
    if (dwErr == 0)
    {
        dwErr = GetLastError();
        SATracePrintf("AllocateAndInitializeSid failed %ld in CreateLangChangeEvent", dwErr);
        goto End;
    }

    dwAclBufLen = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(pAdminSid);

    paclBuf = (PACL)SaAlloc(dwAclBufLen);
    if (paclBuf == NULL)
    {
        SATraceString("SaAlloc for paclBuf failed in CreateLangChangeEvent()");
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto End;
    }

    dwErr = InitializeAcl(paclBuf,
                          dwAclBufLen,
                          ACL_REVISION);
    if (dwErr == 0)
    {
        dwErr = GetLastError();
        SATracePrintf("InitializeAcl failed %ld in CreateLangChangeEvent", dwErr);
        goto End;
    }

    dwErr = AddAccessAllowedAce(paclBuf,
                                ACL_REVISION2,
                                FILE_ALL_ACCESS,
                                pAdminSid);
    if (dwErr == 0)
    {
        dwErr = GetLastError();
        SATracePrintf("AddAccessAllowedAce failed %ld in CreateLangChangeEvent", dwErr);
        goto End;
    }

    if(!SetSecurityDescriptorDacl(&sd, TRUE, paclBuf, FALSE)) 
    {
        SATracePrintf("unable to SetSecurityDescriptorDacl, err == %d\n", GetLastError());
    }

    (*phEvent) = NULL;
    hEvent = CreateEvent(&sa,   // everyone full access
                             TRUE,  // manual reset so that PulseEvent
                                    // wakes up all waiting threads
                             FALSE, // initial state is non-signalled
                             LANG_CHANGE_EVENT);
    if (NULL == hEvent)
    {
        dwErr = GetLastError();
        SATracePrintf("CreateEvent failed %ld", dwErr);
    }
    (*phEvent) = hEvent;

End:
    if (paclBuf)
    {
        SaFree(paclBuf);
    }
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\resource.h ===
//#--------------------------------------------------------------
//
//  File:       resource.h
//
//  Synopsis:   This file holds the resource string IDs for the
//                Localization Manager COM class
//
//
//  History:     2/16/99  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
//
//
#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_LocalizationManager         101
#define IDR_LocalizationManager         102
#define IDR_LocalizationManagerTasks    103

//
// alert Messages from  256 to 511
//
#define NETWORK_ALERT_MESSAGE           256


//
// alert action  from 512 to  767
//
#define NETWORK_ALERT_ACTION            512


//
// clear message from 768 to 1023
//
#define NETWORK_ALERT_CLEAR             768

//
// add new strings here starting from 1024

#endif // ifndef _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\macroutils.h ===
#ifndef _MACRO_UTILS_H_
#define _MACRO_UTILS_H_

#define CHECK_ERROR1(pszFmt, errVal, hr) \
                                      if (errVal == 0)\
                                      {\
                                          errVal = GetLastError();\
                                          TRACE1(pszFmt, errVal);\
                                          hr = E_FAIL;\
                                          goto End;\
                                      }

#define CHECK_MEM_ALLOC(pszFmt, pMem, hr) \
                                      if (pMem == NULL)\
                                      {\
                                          TRACE1(pszFmt, hr);\
                                          hr = E_OUTOFMEMORY;\
                                          goto End;\
                                      }

#define CHECK_HR_ERROR1(pszFmt, hr)  if (FAILED(hr)) \
                                            {\
                                                TRACE1(pszFmt, hr);\
                                                goto End;\
                                            }


#define FREE_SIMPLE_SA_MEMORY(pMem)     if (pMem) \
                                     {\
                                         SaFree(pMem);\
                                         pMem = NULL;\
                                     }

#define FREE_SIMPLE_BSTR_MEMORY(pMem)     if (pMem) \
                                     {\
                                         SysFreeString(pMem);\
                                         pMem = NULL;\
                                     }

#endif _MACRO_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\locinfo.h ===
//#--------------------------------------------------------------
//
//  File:       locinfo.h
//
//  Synopsis:   This file holds the declarations of the
//                LocalizationManager COM class
//
//
//  History:     2/16/99  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _LOCINFO_H_
#define _LOCINFO_H_

#include <salocmgr.h>
#include <resource.h>
#include <string>
#include <atlctl.h>

#include <process.h>
#include <event.h>

#include "salangchange.h"

//
// this is needed for supporting STL maps
//
#pragma warning (disable : 4786)
#include <map>
#include <set>
using namespace std;

class CModInfo
{
public:
    CModInfo() : m_hModule(NULL), 
                 m_rType(UNKNOWN),
                 m_dwLangId(0)
    {
    }

    //
    // copy constructor used by list during
    // insert operation
    //
    CModInfo(const CModInfo &cm)
    {
        m_hModule  = cm.m_hModule;
        m_rType    = cm.m_rType;
        m_dwLangId = cm.m_dwLangId;
    }

    ~CModInfo()
    {
    }

    typedef enum
    {
        MC_FILE,
        RC_FILE,
        UNKNOWN
    } RESOURCE_TYPE;

    HMODULE       m_hModule;
    RESOURCE_TYPE m_rType;

    //
    // lang id of the DLL referenced by m_hModule
    //
    DWORD         m_dwLangId;

};

class CLang
{
public:
    CLang()
    {
    }

    //
    // copy constructor used by list during
    // insert operation
    //
    CLang(const CLang &cl)
    {
        m_dwLangID            = cl.m_dwLangID;
        m_strLangDisplayImage = cl.m_strLangDisplayImage;
        m_strLangISOName      = cl.m_strLangISOName;
        m_strLangCharSet      = cl.m_strLangCharSet;
        m_dwLangCodePage      = cl.m_dwLangCodePage;
    }

    ~CLang()
    {
    }

    bool operator==(CLang &cl)
    {
        if (m_dwLangID == cl.m_dwLangID)
        {
            return true;
        }
        return false;
    }

    const bool operator<(const CLang &cl) const
    {
        if (m_dwLangID < cl.m_dwLangID)
        {
            return true;
        }
        return false;
    }

    wstring m_strLangDisplayImage;
    wstring m_strLangISOName;
    wstring m_strLangCharSet;
    DWORD   m_dwLangCodePage;
    DWORD   m_dwLangID;
};

//
// declaration of the CSALocInfo class
//
class ATL_NO_VTABLE CSALocInfo:
    public IDispatchImpl<
                        ISALocInfo,
                        &IID_ISALocInfo,
                        &LIBID_SALocMgrLib
                        >,
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSALocInfo,&CLSID_LocalizationManager>,
    public IObjectSafetyImpl<CSALocInfo>
{
public:

//
// registry declaration for the Localization Manager
//
DECLARE_REGISTRY_RESOURCEID (IDR_LocalizationManager)

//
// this COM Component is not aggregatable
//
DECLARE_NOT_AGGREGATABLE(CSALocInfo)

//
// this COM component is a singleton
//
DECLARE_CLASSFACTORY_SINGLETON (CSALocInfo)

//
// MACROS for ATL required methods
//
BEGIN_COM_MAP(CSALocInfo)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISALocInfo)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

    //
    // constructor doesn't do much
    //
    CSALocInfo () 
         :m_bInitialized (false),
          m_dwLangId (0),
          m_pLangChange(NULL),
          m_hThread(NULL)
        {
            unsigned uThreadID;

            InitializeCriticalSection (&m_hCriticalSection);

        }

    //
    // nor does the destructor
    //
    ~CSALocInfo () 
    {
        Cleanup ();
        if (m_pLangChange)
        {
            m_pLangChange->Release();
        }

        DeleteCriticalSection (&m_hCriticalSection);
    }

    //
    // This interface is implemented to mark the component as safe for scripting
    // IObjectSafety interface methods
    //
    STDMETHOD(SetInterfaceSafetyOptions)
                        (
                        REFIID riid, 
                        DWORD dwOptionSetMask, 
                        DWORD dwEnabledOptions
                        )
    {
        BOOL bSuccess = ImpersonateSelf(SecurityImpersonation);
  
        if (!bSuccess)
        {
            return E_FAIL;

        }

        bSuccess = IsOperationAllowedForClient();

        RevertToSelf();

        return bSuccess? S_OK : E_FAIL;
    }

    //
    // --------ISALocInfo interface methods----- 
    //

    //
    // Get the string information
    //
    STDMETHOD (GetString)(
                    /*[in]*/        BSTR        szSourceId,
                    /*[in]*/        LONG        lMessageId,
                    /*[in]*/        VARIANT*    pReplacementStrings,   
                    /*[out,retval]*/BSTR        *pszMessage
                    );


    //
    // get the current locale
    //
    STDMETHOD (GetLanguages)(
                  /*[out]*/        VARIANT       *pvstrLangDisplayImages,
                  /*[out]*/        VARIANT       *pvstrLangISONames,
                  /*[out]*/        VARIANT       *pvstrLangCharSets,
                  /*[out]*/        VARIANT       *pviLangCodePages,
                  /*[out]*/        VARIANT       *pviLangIDs,
                  /*[out,retval]*/ unsigned long *pulCurLangIndex
                    );

    //
    // set the language 
    //

    STDMETHOD (SetLangChangeCallBack)(
                /*[in]*/    IUnknown *pLangChange
                );

    STDMETHOD (get_fAutoConfigDone)(
                /*[out,retval]*/VARIANT_BOOL *pvAutoConfigDone);

    STDMETHOD (get_CurrentCharSet)(
                /*[out,retval]*/BSTR *pbstrCharSet);

    STDMETHOD (get_CurrentCodePage)(
                /*[out,retval]*/VARIANT *pvtiCodePage);

    STDMETHOD (get_CurrentLangID)(
                /*[out,retval]*/VARIANT *pvtiLangID);

private:

    //
    // private initialization method
    //
    HRESULT InternalInitialize ();

    //
    // internal cleanup routine
    //
    VOID Cleanup ();

    //
    // detect lang ID on start up 
    //
    VOID SetLangID ();

    //
    // method to carry out language change from worker thread
    //
    VOID    DoLanguageChange ();

    //
    // method gets the resource module needed from 
    // the map
    //
    HRESULT GetModuleID (
                /*[in]*/    BSTR        bstrResourceFile,
                /*[out]*/   CModInfo&   cm
                );

    void    SetModInfo  (
                /*[in]*/    BSTR               bstrResourceFile,
                /*[out]*/   const CModInfo&    cm
                );

    //
    // get the resource directory from the registry
    //
    HRESULT GetResourceDirectory (
                /*[out]*/   wstring&    m_wstrResourceDir
                );

    //
    // 
    // IsOperationAllowedForClient - This function checks the token of the 
    // calling thread to see if the caller belongs to the Local System account
    // 
    BOOL IsOperationAllowedForClient (
                                      VOID
                                     );

    bool    m_bInitialized;

    wstring m_wstrResourceDir;

    DWORD   m_dwLangId;

    //
    // map of module handles
    //
    typedef map <_bstr_t, CModInfo> MODULEMAP;
    MODULEMAP   m_ModuleMap;

    static unsigned int __stdcall WaitForLangChangeThread(void *pvThisObject);

    CRITICAL_SECTION  m_hCriticalSection;
    HANDLE   m_hThread;

    class CLock
    {
    public:
        CLock(LPCRITICAL_SECTION phCritSect) : m_phCritSect (phCritSect)
        {
            if (m_phCritSect)
            {
                EnterCriticalSection (m_phCritSect);
            }
        }

        ~CLock()
        {
            if (m_phCritSect)
            {
                  LeaveCriticalSection (m_phCritSect);
              }
        }

    private:

 	
        LPCRITICAL_SECTION m_phCritSect;
    };


    HRESULT InitLanguagesAvailable(void);
    
    typedef set<CLang, less<CLang> >      LANGSET;
    LANGSET                               m_LangSet;
    ISALangChange                         *m_pLangChange;

    HRESULT ExpandSz(IN const TCHAR *lpszStr, OUT LPTSTR *ppszStr);
    DWORD   GetMcString(
            IN     HMODULE     hModule, 
            IN        LONG     lMessageId, 
            IN       DWORD     dwLangId,
            IN OUT  LPWSTR     lpwszMessage, 
            IN        LONG     lBufSize,
            IN        va_list  *pArgs);

    DWORD   GetRcString(
            IN     HMODULE     hModule, 
            IN        LONG     lMessageId, 
            IN OUT  LPWSTR     lpwszMessage, 
            IN        LONG     lBufSize
                       );
       //
       // checks if a directory is a valid language dir
       //
       bool     IsValidLanguageDirectory (
                /*[in]*/    PWSTR    pwszDirectoryPath,
                /*[in]*/    PWSTR    pwszDirectoryName
                );


};  // end of CSALocInfo method


#endif // !define  _LOCINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\common.cpp ===
//
// registry path where the resource information is stored
//
const WCHAR RESOURCE_REGISTRY_PATH [] = 
            L"SOFTWARE\\Microsoft\\ServerAppliance\\LocalizationManager\\Resources";

//
// language ID value
//
const WCHAR LANGID_VALUE [] = L"LANGID";

//
// resource directory 
//
const WCHAR RESOURCE_DIRECTORY [] = L"ResourceDirectory";

const WCHAR NEW_LANGID_VALUE []       = L"NewLANGID";

//
// delimiter
//
const WCHAR DELIMITER [] = L"\\";
const WCHAR WILDCARD  [] = L"*.*";

//
// here is the default value of resource path and language
//
//const WCHAR DEFAULT_LANGID[]             = L"0409";
//const WCHAR DEFAULT_LANG_DISPLAY_IMAGE[] = L"images/english.gif";
//const WCHAR DEFAULT_LANG_ISO_NAME[]      = L"en";
//const WCHAR DEFAULT_LANG_CHAR_SET[]      = L"iso-8859-1";
//const WCHAR DEFAULT_LANG_CODE_PAGE[]     = L"1252";
const WCHAR REGVAL_AUTO_CONFIG_DONE[]    = L"AutoConfigDone";

const WCHAR DEFAULT_DIRECTORY [] = 
                L"%systemroot%\\system32\\ServerAppliance\\mui";

const WCHAR DEFAULT_EXPANDED_DIRECTORY [] = 
                L"C:\\winnt\\system32\\ServerAppliance\\mui";

const WCHAR LANG_CHANGE_EVENT[] = 
                L"Microsoft.ServerAppliance.LangChangeTask";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\salocmgr.cpp ===
//#--------------------------------------------------------------
//        
//  File:       locmgr.cpp
//        
//  Synopsis:   this is the main Source File for the Server Appliance
//               Localization Manager in-proc COM Server component 
//              
//
//  History:     1/16/99  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

//
// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f radprotops.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "salocmgr.h"
#include "tasks.h"
#include "locinfo.h"

#include <initguid.h>
#include "locmgrtasks.h"
#include "locmgrtasks_i.c"
#include <appliancetask.h>
#include <taskctx.h>


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(LocalizationManager), CSALocInfo)
    OBJECT_ENTRY(CLSID_LocMgrTasks, CLocMgrTasks)
END_OBJECT_MAP()

//++--------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Disabling thread calls
//
//  Arguments:  [in]    HINSTANCE - module handle
//              [in]    DWORD     - reason for call
//              reserved 
//
//  Returns:    BOOL    -   sucess/failure
//
//
//  History:    MKarki      Created     2/1/99
//
//----------------------------------------------------------------
extern "C" BOOL WINAPI 
DllMain(
    HINSTANCE   hInstance, 
    DWORD       dwReason, 
    LPVOID      lpReserved
    )
{

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }

    return (TRUE);

}   //  end of DllMain method

//++--------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Used to determine if the DLL can be unloaded
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     2/1/99
//
//----------------------------------------------------------------
STDAPI 
DllCanUnloadNow(
            VOID
            )
{
    return ((_Module.GetLockCount()==0) ? S_OK : S_FALSE);
}   //  end of DllCanUnloadNow method

//++--------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Returns a class factory to create an object 
//              of the requested type
//
//  Arguments: [in]  REFCLSID  
//             [in]  REFIID    
//             [out] LPVOID -   class factory
//              
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     2/1/99
//
//----------------------------------------------------------------
STDAPI 
DllGetClassObject(
            REFCLSID rclsid, 
            REFIID riid, 
            LPVOID* ppv
            )
{
    return (_Module.GetClassObject(rclsid, riid, ppv));

}   //  end of DllGetClassObject method

//++--------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Add entries to the system registry
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     2/1/99
//
//----------------------------------------------------------------
STDAPI DllRegisterServer(
            VOID
            )
{
    //
    // registers object, typelib and all interfaces in typelib
    //
    return (_Module.RegisterServer(TRUE));

}   //  end of DllRegisterServer method

//++--------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Removes entries from the system registry
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     2/1/99
//
//----------------------------------------------------------------
STDAPI DllUnregisterServer(
        VOID
        )
{
    _Module.UnregisterServer();
    return (S_OK);

}   //  end of DllUnregisterServer method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_)
#define AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#include "salocmgr.h"
#include "comdef.h"

#include <satrace.h>

#endif // !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\tasks.h ===
// NetTasks.h : Declaration of the CLocMgrTasks

#ifndef __LOCMGRTASKS_H_
#define __LOCMGRTASKS_H_

#include "stdafx.h"
#include <comdef.h>
#include "locmgrtasks.h"
#include "taskctx.h"

#include "resource.h"       // main symbols



/////////////////////////////////////////////////////////////////////////////
// CLocMgrTasks
class ATL_NO_VTABLE CLocMgrTasks : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CLocMgrTasks, &CLSID_LocMgrTasks>,
    public IDispatchImpl<IApplianceTask, &IID_IApplianceTask, &LIBID_LOCMGRTASKSLib>
{
public:
    CLocMgrTasks()
    {
    }


DECLARE_REGISTRY_RESOURCEID(IDR_LocalizationManagerTasks)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLocMgrTasks)
    COM_INTERFACE_ENTRY(IApplianceTask)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//
// IApplianceTask
//
public:
    HRESULT STDMETHODCALLTYPE OnTaskComplete(IUnknown *pMethodContext,
                                             LONG lTaskResult);

    HRESULT STDMETHODCALLTYPE OnTaskExecute(IUnknown *pMethodContext);

private:
    typedef HRESULT (CLocMgrTasks::*PTASK_EXECUTE)(IN ITaskContext *pTaskParams);
    typedef HRESULT (CLocMgrTasks::*PTASK_COMPLETE)(IN ITaskContext *pTaskParams, LONG lTaskComplete);
    struct METHOD_INFO
    {
        const TCHAR    *szName;
        PTASK_EXECUTE  pMethodExecute;
        PTASK_COMPLETE pMethodComplete;
    };
    static METHOD_INFO m_miTaskTable[];
    #define NUM_TASKS  (sizeof(m_miTaskTable)/sizeof(m_miTaskTable[0]))

    HRESULT ChangeLangOnTaskExecute(ITaskContext *pTaskParams);
    HRESULT ChangeLangOnTaskComplete(ITaskContext *pTaskParams, LONG lTaskComplete);
    void GetTaskName(IN ITaskContext *pTaskParams, OUT LPTSTR *ppszTaskName);
    HRESULT STDMETHODCALLTYPE GetChangeLangParameters(
                                       IN ITaskContext *pTaskContext, 
                                      OUT DWORD        *pdwLangId,
                                      OUT bool         *pfAutoConfigTask);

};

#endif //__LOCMGRTASKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\consumer.h ===
//#--------------------------------------------------------------
//
//  File:       consumer.h
//
//  Synopsis:   This file holds the declarations of the
//                NT Event Filter Consumer Sink COM object
//
//
//  History:     3/8/2000  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _CONSUMER_H_
#define _CONSUMER_H_

#include <resource.h>
#include <wbemprov.h>
#include <sacls.h>
#include <satrace.h>
#include <string>
#include "appsrvcs.h"

#include <map>
using namespace std;

//
// declaration of the CConsumer class
//
class ATL_NO_VTABLE CConsumer:
    public CComObjectRootEx<CComMultiThreadModel>,
    public IWbemUnboundObjectSink,
    public CSACountable
{
public:

//
// MACROS for ATL required methods
//
BEGIN_COM_MAP(CConsumer)
    COM_INTERFACE_ENTRY(IWbemUnboundObjectSink)
END_COM_MAP()

    //
    // constructor doesn't do much
    //
    CConsumer (
        )
        :m_bInitialized (false)
    {
        SATraceString ("NT Event Filter WMI consumer being constructed...");
        InternalAddRef ();
    }

    //
    // destructor
    //
    ~CConsumer ();

    //
    // initialize the object
    //
    HRESULT Initialize (
                /*[in]*/    IWbemServices   *pWbemServices
                );

    //
    // ---------IWbemUnboundObjectSink interface methods----------
    //
    STDMETHOD(IndicateToConsumer) (
                    /*[in]*/    IWbemClassObject    *pLogicalConsumer,
                    /*[in]*/    LONG                lObjectCount,
                    /*[in]*/    IWbemClassObject    **ppObjArray
                    );
    
private:

    //
    // struct storing the alert information in the
    // EVENTIDMAP 
    //
    typedef struct _sa_alertinfo_
    {
        LONG            lAlertId;
        LONG            lTTL;
        _bstr_t         bstrAlertSource;
        _bstr_t         bstrAlertLog; 
        bool            bAlertTypePresent;
        SA_ALERT_TYPE   eAlertType;
        bool            bFormatInfo;
        bool            bClearAlert;
    } 
    SA_ALERTINFO, *PSA_ALERTINFO;

    //
    // method to load event information from the registry
    //
    HRESULT LoadRegInfo ();

    //
    // method used to check if we are intrested in a particular
    // event
    //
    bool IsEventInteresting (
                /*[in]*/    LPWSTR              lpszSourceName,
                /*[in]*/    DWORD               dwEventId,
                /*[in/out]*/SA_ALERTINFO&       SAAlertInfo
                );

    //
    // method used to raise Server Appliance alert 
    //
    HRESULT RaiseSAAlert (
                /*[in]*/   LONG     lAlertId,
                /*[in]*/   LONG     lAlertType,             
                /*[in]*/   LONG     lTimeToLive,
                /*[in]*/   BSTR     bstrAlertSource,
                /*[in]*/   BSTR     bstrAlertLog,
                /*[in]*/   VARIANT* pvtReplacementStrings,
                /*[in]*/   VARIANT* pvtRawData
                );

    //
    // method used to clear Server Appliance alert
    //
    HRESULT
    ClearSAAlert (
        /*[in]*/   LONG     lAlertId,
        /*[in]*/   BSTR     bstrAlertLog
        );

    //
    // method to format the information for generic alerts
    //
    HRESULT    FormatInfo (
        /*[in]*/    VARIANT*    pvtEventType,
        /*[in]*/    VARIANT*    pvtDateTime,
        /*[in]*/    VARIANT*    pvtEventSource,
        /*[in]*/    VARIANT*    pvtMessage,
        /*[out]*/    VARIANT*    pvtReplacementStrings
        );

    //
    // method to format the event messages into web format
    //
    wstring    
    CConsumer::WebFormatMessage (
        /*[in]*/    wstring&    wstrInString
        );

    //
    // private method to cleanup maps
    //
    VOID Cleanup ();

    //
    // flag indicating the consumer is initialized
    //
    bool m_bInitialized;


    //
    // map to hold the event ids for each source
    //
    typedef map <DWORD, SA_ALERTINFO>  EVENTIDMAP;
    typedef EVENTIDMAP::iterator EVENTIDITR;
 
    //
    // map to hold the event source information
    //
    typedef  map <_bstr_t, EVENTIDMAP>  SOURCEMAP;
    typedef SOURCEMAP::iterator  SOURCEITR;

    //
    //  this the map holding the source information
    //
    SOURCEMAP m_SourceMap;

    //
    // we need to hold on to the Appliance Services interface
    //
    CComPtr <IApplianceServices> m_pAppSrvcs;
    

};  // end of CConsumer class declaration

//
// this is for creating CConsumer class object
// through new
//
typedef CComObjectNoLock<CConsumer> SA_NTEVENTFILTER_CONSUMER_OBJ;

#endif // !define  _CONSUMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\consumer.cpp ===
//#--------------------------------------------------------------
//
//  File:        consumer.cpp
//
//  Synopsis:   Implementation of CConsumer class methods
//
//
//  History:    02/08/2000  MKarki Created
//                09/26/2000  MKarki - Extending to support filtering without
//                            without event ID
//                01/06/2000 MKarki  - Extending to support clearing of alerts
//                            on NT Events
//
//    Copyright (C) 1999-2001 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "stdafx.h"
#include <atlhlpr.h>
#include <varvec.h>
#include "consumer.h"
#include "datetime.h"
#include "propertybagfactory.h"
#include "appmgrobjs.h"

/////////////////////////////////////////////////////////////////////////
// here is the registry key structure for resources and alerts
//
// HKLM\Software\Microsoft\ServerAppliance\EventFilter
//                     |
//                     -- Events
//                  
//                              |
//                              -- "NewEvent1"  
//                              |             Source
//                              |             EventType
//                              |             EventId
//                              |             AlertId
//                              |
//                              -- "NewEvent2"  
//                                            Source
//                                            EventType
//                                            EventId
//                                            AlertId
//                                            
/////////////////////////////////////////////////////////////////////// 

//
// registry key path and sub-keys
//
const WCHAR EVENT_FILTER_KEY [] = L"SOFTWARE\\Microsoft\\ServerAppliance\\EventFilter";
const WCHAR DELIMITER [] = L"\\";
const WCHAR EVENTS [] = L"Events";

//
// these are registry key values
//
const WCHAR EVENT_SOURCENAME_VALUE [] = L"EventSource";
const WCHAR ALERT_ID_VALUE [] = L"AlertId";
const WCHAR ALERT_TYPE_VALUE [] = L"AlertType";
const WCHAR ALERT_SOURCE_VALUE [] = L"AlertSource";
const WCHAR ALERT_LOG_VALUE [] = L"AlertLog";
const WCHAR ALERT_TTL_VALUE [] = L"TimeToLive";
const WCHAR EVENT_ABSOLUTE_ID_VALUE [] = L"AbsoluteEventId";
const WCHAR EVENT_TYPE_VALUE [] = L"EventType";
const WCHAR EVENT_ID_VALUE [] = L"EventId";
const WCHAR ADD_STRINGS_VALUE [] = L"AddEventStrings";
const WCHAR CLEAR_ALERT_VALUE [] = L"ClearAlert";

//
// these are the different event type we are interested in
//
const WCHAR INFORMATIONAL_TYPE [] = L"Information";
const WCHAR ERROR_TYPE [] = L"Error";
const WCHAR WARNING_TYPE [] = L"Warning";
const WCHAR UNKNOWN_TYPE [] = L"Unknown";


//
// these are WMI property names in the event object received
//
const WCHAR WMI_TARGET_INSTANCE_PROPERTY [] = L"TargetInstance";
const WCHAR WMI_EVENT_SOURCE_NAME_PROPERTY [] = L"SourceName";
const WCHAR WMI_EVENT_MESSAGE_PROPERTY [] = L"Message";
const WCHAR WMI_EVENT_ID_PROPERTY [] = L"EventIdentifier";
const WCHAR WMI_EVENT_REPLACEMENTSTRINGS_PROPERTY [] = L"InsertionStrings";
const WCHAR WMI_EVENT_RAWDATA_PROPERTY [] = L"Data";
const WCHAR WMI_EVENT_TYPE_PROPERTY [] = L"Type";
const WCHAR WMI_EVENT_DATETIME_PROPERTY [] = L"TimeGenerated";

//
// name of the generic source
//
const WCHAR GENERIC_SOURCE [] = L"GenericSource";

//++--------------------------------------------------------------
//
//  Function:   Initialize
//
//  Synopsis:   This is the Initialize method for the CConsumer
//              class object
//
//  Arguments:  [in] IWbemServices*
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    MKarki      Created     2/8/99
//
//  Called By:  CController::Initialize method
//
//----------------------------------------------------------------
HRESULT
CConsumer::Initialize (
            /*[in]*/    IWbemServices *pWbemServices
            )
{
    _ASSERT (pWbemServices);

    HRESULT hr = S_OK;

    SATraceString ("Initializing NT Event WMI consumer...");

    do
    {
        if (m_bInitialized)  {break;}
    
        //
        // load the registry information
        //
        hr = LoadRegInfo ();
        if (FAILED (hr))
        {
            SATracePrintf (
                "NT Event WMI consumer failed to load registry info:%x",
                hr
                );
            break;
        }

        //
        // create appliance services COM object
        //
        hr = ::CoCreateInstance (
                        CLSID_ApplianceServices,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        __uuidof (IApplianceServices),
                        (PVOID*) &(m_pAppSrvcs.p)
                        );
        if (FAILED (hr))
        {
            SATracePrintf (
                "NT Event WMI consumer failed to create appliance services COM object:%x",
                hr
                );
            break;
        }

        //
        // intialize the appliance services now
        //
        hr = m_pAppSrvcs->InitializeFromContext (pWbemServices);
        if (FAILED (hr))
        {
            SATracePrintf (
                "NT Event WMI consumer failed to initialize appliance services COM object:%x",
                hr
                );
            break;
        }

        //
        // successfully initialized
        //
        m_bInitialized = true;
            
    }   
    while (false);

    return (hr);

}   //  end of CConsumer::Initialize method

//++--------------------------------------------------------------
//
//  Function:   IndicateToConsumer
//
//  Synopsis:   This is the IWbemUnboundObjectSink interface method 
//              through which WBEM calls back to provide the 
//              event objects
//
//  Arguments:  
//              [in]    IWbemClassObject*  -  logical consumers
//              [in]    LONG               -  number of events
//              [in]    IWbemClassObject** -  array of events
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     2/8/99
//
//  Called By:  WBEM 
//
//----------------------------------------------------------------
STDMETHODIMP
CConsumer::IndicateToConsumer (
                    /*[in]*/    IWbemClassObject    *pLogicalConsumer,
                    /*[in]*/    LONG                lObjectCount,
                    /*[in]*/    IWbemClassObject    **ppObjArray
                    )
{   
    CSACounter <CSACountable> (*this);

    _ASSERT (ppObjArray && (0 != lObjectCount));


    if ((!ppObjArray) || (0 == lObjectCount)) 
    {
        return (WBEM_E_INVALID_PARAMETER);
    }

    
    SATracePrintf ("NT Event WMI Consumer received events:%d...", lObjectCount);

    HRESULT hr = WBEM_S_NO_ERROR;
    try
    {
        //
        // go through each WBEM event receive and process it
        //
        for (LONG lCount = 0; lCount < lObjectCount; lCount++)
        {

            CComVariant vtInstance;
            CIMTYPE     vtType;

            //
            // Get the object referred to by the 
            // "TargetInstance" property - this is a pointer 
            //  to a Win32_NTLogEvent object that contains the real data
            // 
            hr = ppObjArray[lCount]->Get( 
                                        CComBSTR (WMI_TARGET_INSTANCE_PROPERTY),
                                        0, 
                                        &vtInstance,
                                        &vtType, 
                                        0
                                        );
            if (FAILED (hr))
            {
                SATracePrintf (
                       "NT Event WMI Consumer unable to get instance type from event object:%x", hr);

                break; 
            }
        
            //
            // check the type returned
            //
            if (VT_UNKNOWN != vtType)
            {
                SATracePrintf (
                       "NT Event WMI Consumer got wrong type of TargetInstance object : %d", vtType);

                hr = E_INVALIDARG;
                break; 
            }

            IUnknown* pIUnknown = V_UNKNOWN (&vtInstance);
            if (NULL == pIUnknown)
            {
                SATraceString ("NT Event WMI Consumer failed to get IUnknown interface from the target instance");
                hr = E_FAIL;
                break; 
            }

            CComPtr <IWbemClassObject> pIEvtLogEvent;
            hr =  pIUnknown->QueryInterface ( 
                                        IID_IWbemClassObject,
                                        (PVOID*) &(pIEvtLogEvent.p)
                                        );
            if (FAILED (hr))
            {
                SATracePrintf ("NT Event WMI Consumer failed on QueryInterface for IWbemClassObject: %x", hr);
                    break; 
            }

            CComVariant vtSource;
            //
            // Retrieve the source of the event log message 
            //
            hr = pIEvtLogEvent->Get( 
                                CComBSTR (WMI_EVENT_SOURCE_NAME_PROPERTY),
                                0,
                                &vtSource,
                                &vtType,
                                0 
                                );
            if (FAILED (hr))
            {
                SATracePrintf ("NT Event WMI Consumer failed to get event log message source: %x", hr);
                break;
            }

            if (VT_BSTR != vtType)
            {
                SATracePrintf (
                    "NT Event WMI Consumer found event source has "
                    " wrong type:%d", 
                    vtType
                    );
                hr = E_INVALIDARG;
                break; 
            }

            SATracePrintf (
                "NT Event WMI Consumer found event source:'%ws'",
                V_BSTR (&vtSource)
                );

            CComVariant vtEventId;
            //
            // Retrieve the event id
            //
            hr = pIEvtLogEvent->Get ( 
                                    CComBSTR (WMI_EVENT_ID_PROPERTY),
                                    0,
                                    &vtEventId,
                                    &vtType,
                                    0
                                    );
            if (FAILED (hr))
            {
                SATracePrintf (
                    "NT Event WMI Consumer failed to get event ID:%x",
                    hr
                    );
                break; 
            }

            if (VT_UI4 != vtType)
            {
                SATracePrintf (
                    "NT Event WMI Consumer get event ID with wrong type:%x",
                    hr
                    );
                hr = E_INVALIDARG;
                break; 
            }

            SATracePrintf (
                "NT Event WMI Consumer found Event ID:%x",
                V_UI4 (&vtEventId)
                );

            CComVariant vtRawData;
            //
            // Retrieve the rawdata
            //
            hr = pIEvtLogEvent->Get ( 
                                    CComBSTR (WMI_EVENT_RAWDATA_PROPERTY),
                                    0,
                                    &vtRawData,
                                    &vtType,
                                    0
                                    );
            if (FAILED (hr))
            {
                SATracePrintf (
                    "NT Event WMI Consumer failed to get raw data:%x",
                    hr
                    );
                break; 
            }

            CComVariant vtEventType;
            //
            // Retrieve the event type
            //
            hr = pIEvtLogEvent->Get ( 
                                    CComBSTR (WMI_EVENT_TYPE_PROPERTY),
                                    0,
                                    &vtEventType,
                                    &vtType,
                                    0
                                    );
            if (FAILED (hr))
            {
                SATracePrintf (
                    "NT Event WMI Consumer failed to get raw data:%x",
                    hr
                    );
                break; 
            }

            if (VT_BSTR != vtType)
            {
                SATracePrintf (
                    "NT Event WMI Consumer found event type has "
                    " wrong type:%d", 
                    vtType
                    );
                hr = E_INVALIDARG;
                break; 
            }

            SATracePrintf (
                "NT Event WMI Consumer found event type:'%ws'",
                V_BSTR (&vtEventType)
                );

            SA_ALERTINFO SAAlertInfo;
            //
            // check if we support the following event
            //
            if (!IsEventInteresting (
                            _wcslwr (V_BSTR (&vtSource)),
                            V_UI4 (&vtEventId),
                            SAAlertInfo
                            )) 
            {
                SATracePrintf (
                    "NT Event WMI Consumer did not find event:%x interesting",
                    V_UI4 (&vtEventId)
                    );
                break;
            }

            //
            // check if we want to clear alert
            //
            if (SAAlertInfo.bClearAlert)
            {
                //
                // clear the alert and we are done
                // we don't propogate the error back, just a trace
                // statements as clearing the alert is not critical
                //
                ClearSAAlert (
                        SAAlertInfo.lAlertId,
                        SAAlertInfo.bstrAlertLog
                        );

                //
                // in all cases we are done processing this event
                //
                break;
               }

            SA_ALERT_TYPE eAlertType = SA_ALERT_TYPE_ATTENTION;
            //
            // see if the alert type was specfied in the registry
            // if not, we will base the alert type on the event type
            //
            if (SAAlertInfo.bAlertTypePresent)
            {
                eAlertType = SAAlertInfo.eAlertType;
            }
            else if (0 ==_wcsicmp(INFORMATIONAL_TYPE, V_BSTR (&vtEventType)))
            {
                eAlertType = SA_ALERT_TYPE_ATTENTION;
            }
            else if (0 ==_wcsicmp(ERROR_TYPE, V_BSTR (&vtEventType)))
            {
                eAlertType = SA_ALERT_TYPE_FAILURE;
            }
            else if (0 ==_wcsicmp(WARNING_TYPE, V_BSTR (&vtEventType)))
            {
                eAlertType = SA_ALERT_TYPE_MALFUNCTION;
            }
            else
            {
                SATracePrintf (
                    "NT Event WMI Consumer got unknown event type:'%ws'",
                    V_BSTR (&vtEventType)
                            );
            }

            CComVariant vtRepStrings;
            //
            // if we need to format the replacement strings do it here
            // else get the replacement strings from the event
            //
            if (SAAlertInfo.bFormatInfo)
            {


                CComVariant vtDateTime;
                //
                // Retrieve the date & time of event generation
                //
                hr = pIEvtLogEvent->Get ( 
                                    CComBSTR (WMI_EVENT_DATETIME_PROPERTY),
                                    0,
                                    &vtDateTime,
                                    &vtType,
                                    0
                                    );
                if (FAILED (hr))
                {
                    SATracePrintf (
                        "NT Event WMI Consumer failed to get date:%x",
                        hr
                        );
                    break; 
                }

                if (CIM_DATETIME != vtType)
                {
                    SATracePrintf (
                        "NT Event WMI Consumer got date with wrong type:%x",
                        vtType
                        );
                    hr = E_INVALIDARG;
                    break; 
                }


                SATracePrintf (
                    "NT Event WMI Consumer found date/time :'%ws'",
                    V_BSTR (&vtDateTime)
                    );

                CComVariant vtMessage;
                //
                // Retrieve the date & time of event generation
                //
                hr = pIEvtLogEvent->Get ( 
                                    CComBSTR (WMI_EVENT_MESSAGE_PROPERTY),
                                    0,
                                    &vtMessage,
                                    &vtType,
                                    0
                                    );
                if (FAILED (hr))
                {
                    SATracePrintf (
                            "NT Event WMI Consumer failed to get message:%x",
                        hr
                        );
                    break; 
                }

                if (VT_BSTR != vtType)
                {
                    SATracePrintf (
                        "NT Event WMI Consumer get message with wrong type:%x",
                        vtType
                        );
                    hr = E_INVALIDARG;
                    break; 
                }

                SATracePrintf (
                    "NT Event WMI Consumer found message:'%ws'",
                    V_BSTR (&vtMessage)
                    );

                //
                // fomat the replacement string info now
                //
                hr = FormatInfo (
                            &vtEventType, 
                            &vtDateTime, 
                            &vtSource, 
                            &vtMessage, 
                            &vtRepStrings
                            );
                if (FAILED (hr))
                {
                    SATraceString ("NT Event WMI Consumer failed to format replacement strings");
                      break;
                }
            }
            else
            {
                //
                // Retrieve the replacement strings
                //
                    hr = pIEvtLogEvent->Get ( 
                                    CComBSTR (WMI_EVENT_REPLACEMENTSTRINGS_PROPERTY),
                                    0,
                                    &vtRepStrings,
                                    &vtType,
                                    0
                                    );
                if (FAILED (hr))
                {
                    SATracePrintf (
                        "NT Event WMI Consumer failed to get replacement strings:%x",
                            hr
                        );
                    break; 
                }
            }

            
            //
            // we want to raise an alert if an interesting event was found
            //
            hr = RaiseSAAlert (
                        SAAlertInfo.lAlertId,
                        eAlertType,
                        SAAlertInfo.lTTL,
                        SAAlertInfo.bstrAlertSource,
                        SAAlertInfo.bstrAlertLog,
                        &vtRepStrings,
                        &vtRawData
                        );
            if (FAILED (hr))
            {
                SATracePrintf (
                    "NT Event WMI Consumer failed to raise alert:%x",
                    hr
                    );
                break; 
            }

            SATracePrintf (
                "NT EVent WMI Consumer finished processing event:%x...",
                V_I4(&vtEventId)
                );
        }
    }
    catch (...)
    {
        SATraceString(
            "NT Event WMI Consumer exception in IWbemObjectSink::IndicateConsumer"
            );
        hr = E_FAIL;
    }

    return (hr);

}   //  end of CConsumer::IndicateToConsumer method

//++--------------------------------------------------------------
//
//  Function:   LoadRegInfo
//
//  Synopsis:   This is the private method of CConsumer
//              which is used to obtain the event
//              information from the registry 
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     3/9/2000
//
//  Called By:  CConsumer::Initialize method
//
//----------------------------------------------------------------
HRESULT
CConsumer::LoadRegInfo ()
{
    HRESULT hr = S_OK;

    SATraceString ("NT Event WMI Consumer loading registry info...");

    try
    {
        do
        {
            wstring wszRegPath (EVENT_FILTER_KEY);
            wszRegPath.append (DELIMITER);
            wszRegPath.append (EVENTS);
            CLocationInfo LocInfo(HKEY_LOCAL_MACHINE, wszRegPath.data());
            //
            // make a property bag container from the registry resource
            // entry
            //
            PPROPERTYBAGCONTAINER 
            pObjMgrs = ::MakePropertyBagContainer(
                                        PROPERTY_BAG_REGISTRY,
                                        LocInfo
                                        );
            if (!pObjMgrs.IsValid()) 
            {
                SATraceString (
                    "NT Event WMI Provider unable to create main propertybag container"
                    );
                hr = E_FAIL;
                break;
            }

            if (!pObjMgrs->open())  
            {
                SATraceString (
                    "NT Event WMI Provider -no event registry information present"
                    );
                break;
            }

            pObjMgrs->reset();

            //
            // go through each entry in the propertybag container
            //
            do
            {
                PPROPERTYBAG pObjBag = pObjMgrs->current();
                if (!pObjBag.IsValid())
                {
                    //
                    // its OK not to have resources registered
                    //
                    SATraceString (
                        "Display Controller-no event registry info. present"
                        );
                    break;
                }

                if (!pObjBag->open()) 
                {
                    SATraceString (
                        "NT Event WMI consumer unable to open propertybag"
                        );
                    hr = E_FAIL;
                    break;
                }

                pObjBag->reset ();

                //
                // get the event source name
                //
                CComVariant vtSourceName;
                if (!pObjBag->get (EVENT_SOURCENAME_VALUE, &vtSourceName)) 
                {
                    SATraceString (
                        "NT EVENT WMI Consumer - no Event Source name in registry, assuming all sources"
                        );
                   //
                   // put the generic source name here
                   //
                   vtSourceName = GENERIC_SOURCE;
                }

                //
                // get the Alert Id
                //
                CComVariant vtAlertId;
                if (!pObjBag->get (ALERT_ID_VALUE, &vtAlertId))
                {
                    SATraceString (
                        "NT EVENT WMI Consumer - no Alert Id in registry, ignoring event subkey"
                        );
                    continue;
                }


                //
                // check if this alert has to be cleared
                //
                CComVariant vtClearAlert;
                if (
                    (pObjBag->get (CLEAR_ALERT_VALUE, &vtClearAlert)) &&
                    (1 == V_UI4 (&vtClearAlert))
                   )
                {
                    SATracePrintf (
                        "NT EVENT WMI Consumer - found that Clear Alert is indicated for alert:%x",
                        V_I4 (&vtAlertId)
                        );
                }
                else
                {
                    //
                    // by default we want to raise the alert
                    //
                    V_UI4 (&vtClearAlert) = 0;
                }


                SA_ALERTINFO SAAlertInfo;

                SAAlertInfo.bAlertTypePresent = true;
                //
                // get the Alert type
                //
                CComVariant vtAlertType;
                if (!pObjBag->get (ALERT_TYPE_VALUE, &vtAlertType))
                {
                    SATraceString (
                        "NT EVENT WMI Consumer - no Alert type in registry"
                        );
                    SAAlertInfo.bAlertTypePresent = false;
                }
                else
                {
                    //
                    // we have alert type information, check if this
                    // is one of the value alert types
                    //
                    if (0 ==_wcsicmp(INFORMATIONAL_TYPE, V_BSTR (&vtAlertType)))
                    {
                        SATraceString ("NT Event WMI consumer found alert type:Informational");
                        SAAlertInfo.eAlertType = SA_ALERT_TYPE_ATTENTION;
                    }
                    else if (0 ==_wcsicmp(ERROR_TYPE, V_BSTR (&vtAlertType)))
                    {
                        SATraceString ("NT Event WMI consumer found alert type:Error");
                        SAAlertInfo.eAlertType = SA_ALERT_TYPE_FAILURE;
                    }
                    else if (0 ==_wcsicmp(WARNING_TYPE, V_BSTR (&vtAlertType)))
                    {
                        SATraceString ("NT Event WMI consumer found alert type:Warning");
                        SAAlertInfo.eAlertType = SA_ALERT_TYPE_MALFUNCTION;
                    }
                    else
                    {
                        SATracePrintf (
                            "NT Event WMI Consumer got unknown alert type in the registry:'%ws', ignoring event subkey",
                            V_BSTR (&vtAlertType)
                            );
                        continue;
                    }
                }

                //
                // get the Alert Source
                //
                CComVariant vtAlertSource;
                if (!pObjBag->get (ALERT_SOURCE_VALUE, &vtAlertSource))
                {
                    SATraceString (
                        "NT EVENT WMI Consumer - no Alert source registry, using default"
                        );
                    SAAlertInfo.bstrAlertSource =  DEFAULT_ALERT_SOURCE;
                }
                else
                {
                    SAAlertInfo.bstrAlertSource =  V_BSTR  (&vtAlertSource);
                }

                //
                // get the Alert Log
                //
                CComVariant vtAlertLog;
                if (!pObjBag->get (ALERT_LOG_VALUE, &vtAlertLog))
                {
                    SATraceString (
                        "NT EVENT WMI Consumer - no Alert Log registry, using default"
                        );
                    SAAlertInfo.bstrAlertLog =  DEFAULT_ALERT_LOG;
                }
                else
                {
                    SAAlertInfo.bstrAlertLog =  V_BSTR  (&vtAlertLog);
                }

                LONG lTTL = 0;
                //
                // get the Alert duration
                //
                CComVariant vtTTL;
                if (!pObjBag->get (ALERT_TTL_VALUE, &vtTTL))
                {
                    SATraceString (
                        "NT EVENT WMI Consumer - no TTL Id in registry, using SA_ALERT_DURATION_ETERNAL"
                        );
                    lTTL = SA_ALERT_DURATION_ETERNAL;
                }
                else
                {
                    lTTL = V_I4 (&vtTTL);
                }

                //
                // by default we don't format event info into string 
                //
                SAAlertInfo.bFormatInfo = false;

                //
                // check if we need to add the event messages to alert
                //
                CComVariant vtAddStrings;
                if (!pObjBag->get (ADD_STRINGS_VALUE, &vtAddStrings))
                {
                    SATraceString (
                        "NT EVENT WMI Consumer - no Add String info in registry, ignoring"
                        );
                    lTTL = SA_ALERT_DURATION_ETERNAL;
                }
                else
                {
                    SAAlertInfo.bFormatInfo = V_I4 (&vtAddStrings) ? true :false; 
                }
                //
                // get the Absolute Event Id
                //
                DWORD dwEventId = 0;
                CComVariant vtAbsoluteEventId;
                if (!pObjBag->get (EVENT_ABSOLUTE_ID_VALUE, &vtAbsoluteEventId))
                {
                    SATraceString (
                        "NT EVENT WMI Consumer - no Absolute Event Id in registry - trying to get the partial ID"
                        );

                    //
                    // get the Event Type
                    //
                    CComVariant vtEventType;
                    if (!pObjBag->get (EVENT_TYPE_VALUE, &vtEventType))
                    {
                        SATraceString (
                            "NT EVENT WMI Consumer - no Event Type in registry, ignoring event subkey"
                            );
                           //
                           // we will assume that this is of unknown type
                           //
                         vtEventType    = UNKNOWN_TYPE;
                    }

                    //
                    // get the partial Event Id
                    //
                    CComVariant vtEventId;
                    if (!pObjBag->get (EVENT_ID_VALUE, &vtEventId))
                    {
                        SATraceString (
                            "NT EVENT WMI Consumer - no partial Event Id in registry, ignoring event subkey"
                            );
                        //
                        // if no ID present than the user wants to show alerts with all events
                        // from this resource file
                        //
                        V_UI4 (&vtEventId) = 0;
                        //
                        // we want to format the event info into a string before we
                        // raise the alert
                        //
                        SAAlertInfo.bFormatInfo = true;
                    }


                    //
                    // converting partial ID to complete ID
                    //

                    if (0 ==_wcsicmp(INFORMATIONAL_TYPE, V_BSTR (&vtEventType)))
                    {
                        SATraceString ("NT Event WMI consumer found event type:Informational");
                        dwEventId = 0x40000000 + V_UI4 (&vtEventId);
                    }
                    else if (0 ==_wcsicmp(ERROR_TYPE, V_BSTR (&vtEventType)))
                    {
                        SATraceString ("NT Event WMI consumer found event type:Error");
                        dwEventId = 0xC0000000 + V_UI4 (&vtEventId);
                    }
                    else if (0 ==_wcsicmp(WARNING_TYPE, V_BSTR (&vtEventType)))
                    {
                        SATraceString ("NT Event WMI consumer found event type:Warning");
                        dwEventId = 0x80000000 + V_UI4 (&vtEventId);
                    }
                    else if (0 == _wcsicmp (UNKNOWN_TYPE, V_BSTR (&vtEventType)))
                    {
                           //
                        // in this case we don't care what the type is we always
                        // show if the ID matches
                        //
                        SATraceString ("NT Event WMI Consumer did not receive an event type, ignoring...");
                        dwEventId = V_UI4 (&vtEventId);
                    }
                    else
                    {
                        SATracePrintf (
                            "NT Event WMI Consumer got unknown event type:'%ws', ignoring event sub key",
                            V_BSTR (&vtEventType)
                            );
                        continue;
                    }
                }
                else
                {
                    //
                    // found an absolute event id
                    //
                    dwEventId = V_I4 (&vtAbsoluteEventId);
                }

                SATracePrintf (
                    "NT Event  WMI Consumer Event ID found in registry:%x", 
                    dwEventId
                    );

                SATracePrintf (
                    "NT Event  WMI Consumer Event Source found in registry:'%ws'", 
                    V_BSTR (&vtSourceName)
                    );

                //
                // set up the alert information
                //
                SAAlertInfo.lAlertId = V_I4 (&vtAlertId);
                SAAlertInfo.lTTL = lTTL;
                SAAlertInfo.bClearAlert = (1 == V_UI4 (&vtClearAlert)) ? true : false;

                //
                // convert the string to lowercase
                //
                //wstring wstrSourceName (_wcslwr (V_BSTR (&vtSourceName)));
            
                //
                // lets find if a EVENTIDMAP exists for this source
                //
                SOURCEITR SourceItr;
                if (
                   (false == m_SourceMap.empty ()) &&
                   ((SourceItr = m_SourceMap.find ( _wcslwr (V_BSTR (&vtSourceName)))) != m_SourceMap.end())
                    )
                {
                    //
                    // found the source in the map, now insert the 
                    // event information into the event id map
                    //
                    ((*SourceItr).second).insert (
                                EVENTIDMAP::value_type (dwEventId, SAAlertInfo)
                                );
                }
                else
                {
                    EVENTIDMAP EventIdMap;
                    //
                    // add the alert id into the event id map
                    //
                    EventIdMap.insert (
                                EVENTIDMAP::value_type (dwEventId, SAAlertInfo)
                                );

                    //
                    // add the event id map to the source map now
                    //
                    m_SourceMap.insert (
                                SOURCEMAP::value_type (_wcslwr (V_BSTR (&vtSourceName)), EventIdMap)
                                );
                }

            } while (pObjMgrs->next());

        } while (false);
    }
    catch(_com_error theError)
    {
        SATraceString ("NT Event WMI provider raised COM exception");
        hr = theError.Error();
    }
    catch(...)
    {
        SATraceString ("NT Event WMI provider raised unknown exception");
        hr = E_FAIL;
    }

    return (hr);

}   //  end of CConsumer::LoadRegInfo method

//++--------------------------------------------------------------
//
//  Function:  IsEventInteresting
//
//  Synopsis:   This is the private method of CConsumer class
//              which is used to check if an event is interesting.
//              If it is then the corresponding alert id is returned
//
//  Arguments:  
//              [in]    LPWSTR -   Event Source
//              [in]    DWORD  -   Event ID
//              [in/out]SA_ALERTINFO
//
//  Returns:    bool - yes(true)/no(false)
//
//  History:    MKarki      Created     3/9/2000
//
//  Called By:  CConsumer::IndicateToConsumer method
//
//----------------------------------------------------------------
bool
CConsumer::IsEventInteresting (
        /*[in]*/    LPWSTR              lpszSourceName,
        /*[in]*/    DWORD               dwEventId,
        /*[in/out]*/SA_ALERTINFO&       SAAlertInfo        
        )
{
    bool bRetVal = true;

    _ASSERT (lpszSourceName);

    CLockIt (*this);

    do
    {
           SATracePrintf (
            "NT Event WMI Consumer checking if source:'%ws' is supported",
            lpszSourceName
            );
        //
        // find a resource map corresponding to this source
        //
            SOURCEITR SourceItr = m_SourceMap.find (lpszSourceName);
        if (m_SourceMap.end () == SourceItr)
        {
            SATracePrintf (
                "NT Event WMI Consumer found source:'%ws' not present using default",
                lpszSourceName
                );


            CComVariant vtSource (GENERIC_SOURCE);
            //
            // if source not present, then check in generic source
            //
            SourceItr = m_SourceMap.find (_wcslwr (V_BSTR (&vtSource)));
            if (m_SourceMap.end () == SourceItr)
            {
                SATracePrintf (
                    "NT Event WMI Consumer unable to find generic source, ignoring event"
                    );
                bRetVal = false;
                break;
            }
        }
        
        EVENTIDITR TempItr =  ((*SourceItr).second).begin ();
        for (DWORD dwCount = 0; dwCount < ((*SourceItr).second).size (); ++dwCount)
        {
            SATracePrintf ("Event Id:%x, Alert Id:%x",
                            (*TempItr).first,
                            (*TempItr).second
                            );
            ++TempItr;
        }

        SATracePrintf ("Event ID map has :%d elements",((*SourceItr).second).size());

        SATracePrintf (
            "NT Event WMI Consumer checking if complete ID:%x is supported",
            dwEventId
            );

        //
        // we have values corresponding to this source
        // in the map, get the SA_RESOURCEINFO corresponding
        // to the alert ID provided
        //
        EVENTIDITR EventIdItr = ((*SourceItr).second).find (dwEventId);
        if (((*SourceItr).second).end () != EventIdItr)
        {
            SAAlertInfo = (*EventIdItr).second;
            break;
        }
       

        // check if we have a relative event id
        // mask the facility code, we are not interested in them
        //
        //
        DWORD dwTempEventId = dwEventId & 0xc000ffff;

        SATracePrintf (
               "NT Event WMI Consumer checking if partial ID:%x is supported",
                dwTempEventId
                );

        EventIdItr = ((*SourceItr).second).find (dwTempEventId);
        if (((*SourceItr).second).end () != EventIdItr)
        {
            SAAlertInfo = (*EventIdItr).second;
            break;
        }


        //
        // check if relative event ID without the event type is supported
        //
           dwTempEventId = dwEventId & 0x0000ffff;

        SATracePrintf (
               "NT Event WMI Consumer checking if partial ID:%x without type is supported",
                dwTempEventId
                );

        EventIdItr = ((*SourceItr).second).find (dwTempEventId);
        if (((*SourceItr).second).end () != EventIdItr)
        {
            SAAlertInfo = (*EventIdItr).second;
             break;
         }

           //
        // check if any event with this event type is supported
        //
           dwTempEventId = dwEventId & 0xc0000000;

        SATracePrintf (
               "NT Event WMI Consumer checking if type:%x is supported",
                dwTempEventId
                );

        EventIdItr = ((*SourceItr).second).find (dwTempEventId);
        if (((*SourceItr).second).end () != EventIdItr)
        {
            SAAlertInfo = (*EventIdItr).second;
             break;
        }

        //
          // check if all events of this source type are supported
        //
           dwTempEventId = dwEventId & 0x00000000;

        SATraceString ("NT Event WMI Consumer checking for ANY event");

        EventIdItr = ((*SourceItr).second).find (dwTempEventId);
        if (((*SourceItr).second).end () != EventIdItr)
        {
            SAAlertInfo = (*EventIdItr).second;
             break;
        }

        //
        // we failed to get an alert type
        //
        bRetVal = false;
         
    }
    while (false);
    

    return (bRetVal);

}   //  end of CConsumer::IsEventInteresting method

//++--------------------------------------------------------------
//
//  Function:  RaiseSAAlert 
//
//  Synopsis:   This is the private method of CConsumer class
//              which is used to raise a Server Appliance alert
//              when an interesting event is found
//
//  Arguments:  
//              [in]   DWORD -   Alert ID
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     3/9/2000
//
//  Called By:  CConsumer::IndicateToConsumer method
//
//----------------------------------------------------------------
HRESULT
CConsumer::RaiseSAAlert (
        /*[in]*/   LONG     lAlertId,
        /*[in]*/   LONG     lAlertType,             
        /*[in]*/   LONG     lTimeToLive,
        /*[in]*/   BSTR     bstrAlertSource,
        /*[in]*/   BSTR     bstrAlertLog,
        /*[in]*/   VARIANT* pvtRepStrings,
        /*[in]*/   VARIANT* pvtRawData
        )
{
    _ASSERT (pvtRepStrings && pvtRawData);

    LONG        lCookie = 0;
    HRESULT     hr = S_OK;

    do
    {
        //
        // 
        // give the right privileges to be able to call the
        // method
        //
        BOOL bRetVal =  ImpersonateSelf (SecurityImpersonation);
        if (FALSE == bRetVal)
        {
            SATraceFailure (
                "NT Event Filter failed on ImpersonateSelf",
                GetLastError ()
                );
            hr = E_FAIL;
            break;
        }
        
        //
        // raise the alert now
        //     
        hr = m_pAppSrvcs->RaiseAlert (
                            lAlertType,
                            lAlertId,
                            bstrAlertLog,
                            bstrAlertSource,
                            lTimeToLive,
                            pvtRepStrings,
                            pvtRawData,
                            &lCookie
                            );
        if (SUCCEEDED (hr))
        {
            SATracePrintf (
                "NT Event successfully raised alert:%x and log:'%ws' with cookie:%x", 
                lAlertId, 
                bstrAlertLog,
                lCookie
                );
        }
        else
        {
            SATracePrintf (
                "NT Event failed to raised alert:%x with error:%x",
                lAlertId,
                hr
                );
        }

        //
        // revert back to privelege granted to this thread
        //
        bRetVal = RevertToSelf ();
        if (FALSE == bRetVal)
        {
            SATraceFailure (
                "NT Event Filter failed on RevertToSelf",
                GetLastError ()
                );
            hr = E_FAIL;
        }
    }
    while (false);

    return (hr);

}   //  end of CConsumer::RaiseSAAlert method

//++--------------------------------------------------------------
//
//  Function:  ClearSAAlert 
//
//  Synopsis:   This is the private method of CConsumer class
//              which is used to clear a Server Appliance alert
//              when an interesting event is found
//
//  Arguments:  
//              [in]   DWORD -   Alert ID
//                [in]   BSTR  -     Alert Log
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     01/06/2001
//
//  Called By:  CConsumer::IndicateToConsumer method
//
//----------------------------------------------------------------
HRESULT
CConsumer::ClearSAAlert (
        /*[in]*/   LONG     lAlertId,
        /*[in]*/   BSTR     bstrAlertLog
        )
{
    HRESULT     hr = S_OK;

    do
    {
        SATracePrintf (
            "NT Event Filter called ClearSAAlert for alert:%x and log:'%ws'",
            lAlertId,
            bstrAlertLog
            );
        //
        // 
        // give the right privileges to be able to call the
        // method
        //
        BOOL bRetVal =  ImpersonateSelf (SecurityImpersonation);
        if (FALSE == bRetVal)
        {
            SATraceFailure (
                "NT Event Filter failed on ImpersonateSelf",
                GetLastError ()
                );
            hr = E_FAIL;
            break;
        }
        
        //
        // clear the alert now
        //     
        hr = m_pAppSrvcs->ClearAlertAll (
                            lAlertId,
                            bstrAlertLog
                            );
        if (SUCCEEDED (hr))
        {
            SATracePrintf (
                "NT Event successfully cleared alert:%x and log:'%ws'",
                lAlertId,
                bstrAlertLog
               );
        }
        else
        {
            SATracePrintf (
                "NT Event failed to clear alert:%x with error:%x",
                lAlertId,
                hr
                );
        }

        //
        // revert back to privelege granted to this thread
        //
        bRetVal = RevertToSelf ();
        if (FALSE == bRetVal)
        {
            SATraceFailure (
                "NT Event Filter failed on RevertToSelf",
                GetLastError ()
                );
            hr = E_FAIL;
        }
    }
    while (false);

    return (hr);

}   //  end of CConsumer::RaiseSAAlert method

//++--------------------------------------------------------------
//
//  Function:   Cleanup
//
//  Synopsis:   This is the private method of CConsumer class
//              which is called to cleanup the maps at shutdown time
//
//  Arguments:   none
//
//  Returns:     VOID
//
//  History:    MKarki      Created     3/15/2000
//
//  Called By:  CConsumer::~Consumer (Destructor)
//
//----------------------------------------------------------------
VOID
CConsumer::Cleanup (
    VOID
    )
{
    SATraceString ("NT Event Filter Consumer cleaning up maps...");
    //
    // cleanup the maps
    //
    SOURCEITR SourceItr = m_SourceMap.begin ();
    while (m_SourceMap.end () != SourceItr)
    {
        EVENTIDITR EventItr = ((*SourceItr).second).begin ();
        while (((*SourceItr).second).end () != EventItr)
        {
            EventItr = ((*SourceItr).second).erase (EventItr);
        }
        SourceItr = m_SourceMap.erase (SourceItr);
    } 

    return;

}   //  end of CConsumer::Cleanup method

//++--------------------------------------------------------------
//
//  Function:   ~CConsumer
//
//  Synopsis:   This is the CConsumer class destructor
//              It waits till all the WBEM calls have been processed
//              before it starts the cleanup
//
//  Arguments:   none
//
//  Returns:     
//
//  History:    MKarki      Created     3/15/2000
//
//  Called By:  CConsumer::Release ();
//
//----------------------------------------------------------------
CConsumer::~CConsumer (
    VOID
    )
{
    SATraceString ("NT Event Filter WMI consumer being destroyed...");
    //
    // consumer sleeps for 100 milliseconds if
    // WMI threads are around
    //
    // while (CSACountable::m_lCount) {::Sleep (CONSUMER_SLEEP_TIME);}

    Cleanup ();

}   //  end of CConsumer::~CConsumer method


//++--------------------------------------------------------------
//
//  Function:   FormatInfo
//
//  Synopsis:   This is the private method of CConsumer
//              which is used to format the alert information that
//                goes in for generic alerts
//
//  Arguments:  
//                [in] PWSTR - Event Type
//                [in] PWSTR - DateTime
//                [in] PWSTR - Event Source
//                [in] PWSTR - Message
//                [out] variant* - replacement strings
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     10/02/2000
//
//  Called By:  CConsumer::IndicateToConsumer method
//
//----------------------------------------------------------------
HRESULT
CConsumer::FormatInfo (
    /*[in]*/    VARIANT*    pvtEventType,
    /*[in]*/    VARIANT*    pvtDateTime,
    /*[in]*/    VARIANT*    pvtEventSource,
    /*[in]*/    VARIANT*    pvtMessage,
    /*[out]*/    VARIANT*    pvtReplacementStrings
    )
{

    CSATraceFunc objTraceFunc ("CConsumer::FormatInfo");
    
    HRESULT hr = E_FAIL;

    do
    {
           CDateTime objDateTime;
           if (!objDateTime.Insert (V_BSTR (pvtDateTime))) {break;}

        CVariantVector<BSTR> ReplacementStrings (pvtReplacementStrings, 5);
        ReplacementStrings[0] = SysAllocString (V_BSTR (pvtEventType));
        ReplacementStrings[1] = SysAllocString (objDateTime.GetDate());
        ReplacementStrings[2] = SysAllocString (objDateTime.GetTime());
        ReplacementStrings[3] = SysAllocString (V_BSTR (pvtEventSource));

        //
        // replace the new line characters with <br> characters
        //
        wstring wstrWebMessage = WebFormatMessage (wstring (V_BSTR (pvtMessage)));
        
        ReplacementStrings[4] = SysAllocString (wstrWebMessage.data ());

        //
        //     success
        //
        hr = S_OK;

    }while (false);

    return (hr);
    
}    //    end of CConsumer::FormatInfo method

//++--------------------------------------------------------------
//
//  Function:   WebFormatMessage
//
//  Synopsis:   This is the private method of CConsumer
//              which is used to format the message for the web
//                i.e replace the newline characters with <br>
//
//  Arguments:  
//                [in] PWSTR - Message
//                
//
//  Returns:    none
//
//  History:    MKarki      Created     10/11/2000
//
//  Called By:  CConsumer::FormatInfo method
//
//----------------------------------------------------------------
wstring
CConsumer::WebFormatMessage (
    /*[in]*/    wstring&    wstrInString
    )
{
    wstring wstrOutString;
    PWCHAR pTempStart = NULL;
    PWCHAR pTempCurrent = NULL;

    pTempStart = pTempCurrent = (PWSTR) wstrInString.data ();
    //
    // go through the in string and remove the new lines with <br>
    //
    while  (pTempCurrent = wcsstr (pTempCurrent, L"\r\n"))
    {
        *pTempCurrent = '\0';
        pTempCurrent+=2;
        wstrOutString.append (pTempStart);
        wstrOutString.append (L"<br>");
        pTempStart = pTempCurrent;
    }

    //
    // add the rest of the input string in now
    //
    wstrOutString.append (pTempStart);

    return (wstrOutString);
    
}    //    end of CConsumer::WebFormatMessage method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\locmgr\src\tasks.cpp ===
#include "stdafx.h"
#include "tasks.h"
#include "debug.h"
#include "mem.h"
#include "MacroUtils.h"
#include "event.h"
#include "common.cpp"

CLocMgrTasks::METHOD_INFO CLocMgrTasks::m_miTaskTable[] =
{
    {TEXT("ChangeLanguage"), ChangeLangOnTaskExecute, ChangeLangOnTaskComplete}
};

//+----------------------------------------------------------------------------
//
// Function:  CLocMgrTasks::OnTaskExecute
//
// Synopsis:  This is the routine called by the framework for the Reset
//            tasks. This routine pulls out the actual task being called
//            by the framework from pTaskContext and routes the call to 
//            the correct routine which implements the task.
//
// Arguments: pMethodContext - a <name,value> pair containing the
//            parameters for the task called. The "MethodName" parameter
//            indicates the actual task being called.
//
// Returns:   HRESULT
//
// History:   sgasch Created   1-Mar-99
//
//+----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CLocMgrTasks::OnTaskExecute(IUnknown *pMethodContext)
{
    CComPtr<ITaskContext> pTaskParameters;
    int                   i;
    PTASK_EXECUTE         pMethodExecute=NULL;
    HRESULT               hr;
    LPTSTR                lpszTaskName=NULL;

    try
    {
        SATraceFunction("CLocMgrTasks::OnTaskExecute");

        //ASSERT(pMethodContext);

        if (NULL==pMethodContext)
        {
            return E_INVALIDARG;
        }

        //
        // Get the task context by querying the IUnknown interface we
        // got.
        //
        hr = pMethodContext->QueryInterface(IID_ITaskContext,
                                            (void **)&pTaskParameters);
        if (FAILED(hr))
        {
            TRACE1("OnTaskExecute failed at QueryInterface(ITaskContext), %x", hr);
            return(hr);
        }

        GetTaskName(pTaskParameters, &lpszTaskName);
        for (i=0; i<NUM_TASKS; i++)
        {
            if (!lstrcmpi(m_miTaskTable[i].szName, lpszTaskName))
            {
                pMethodExecute = m_miTaskTable[i].pMethodExecute;
                if (NULL==pMethodExecute)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = (this->*pMethodExecute)(pTaskParameters);
                }
            }
        }
    }
    catch (...)
    {
        FREE_SIMPLE_SA_MEMORY(lpszTaskName);
        TRACE("Exception caught in CLocMgrTasks::OnTaskExecute");
        return E_FAIL;
    }
    FREE_SIMPLE_SA_MEMORY(lpszTaskName);
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CClientAlertTasks::OnTaskComplete
//
// Synopsis:  This is the rollback routine which gets a result for the task.
//            So, if one of the other task executables failed, this routine
//            can perform clean up operations. However, not all operations can
//            be undone. This is the routine called by the framework for all 
//            the ClientAlert tasks. This routine pulls out the actual rollback  
//            task being called by the framework from pTaskContext and routes 
//            the call to the correct routine which implements the rollback. 
//            Each of these routines decides if it can rollback or not. 
//            If the task had succeeded, no action is taken and non of the
//            rollback routines is called.
//
// Arguments: pTaskContext - a <name,value> pair containing the parameters for
//            the task called. The "MethodName" parameter indicates the actual
//            task being called
//            lTaskResult - indicates if the OnTaskExecute()s of each of the
//            TaskExecutables succeeded. lTaskResult contains a failure code
//            if even one of the TaskExecutables failed. It contains no 
//            information about which of the TaskExecutables failed.
//
// Returns:   HRESULT
//
// History:   Created   02/19/99
//
//+----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CLocMgrTasks::OnTaskComplete(IUnknown *pMethodContext,
                                                        LONG lTaskResult)
{
    CComPtr<ITaskContext> pTaskParameters;
    int                   i;
    PTASK_COMPLETE        pMethodComplete=NULL;
    HRESULT               hr;
    LPTSTR                lpszTaskName=NULL;

    try
    {
        SATraceFunction("CLocMgrTasks::OnTaskComplete");

        //ASSERT(pMethodContext);

        if (NULL==pMethodContext)
        {
            return E_INVALIDARG;
        }

        //
        // Get the task context by querying the IUnknown interface we
        // got.
        //
        hr = pMethodContext->QueryInterface(IID_ITaskContext,
                                            (void **)&pTaskParameters);
        if (FAILED(hr))
        {
            TRACE1("OnTaskComplete failed at QueryInterface(ITaskContext), %x", hr);
            return(hr);
        }

        GetTaskName(pTaskParameters, &lpszTaskName);
        for (i=0; i<NUM_TASKS; i++)
        {
            if (!lstrcmpi(m_miTaskTable[i].szName, lpszTaskName))
            {
                pMethodComplete = m_miTaskTable[i].pMethodComplete;
                if (NULL==pMethodComplete)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = (this->*pMethodComplete)(pTaskParameters, lTaskResult);
                }
            }
        }
    }
    catch (...)
    {
        FREE_SIMPLE_SA_MEMORY(lpszTaskName);
        TRACE("Exception caught in CLocMgrTasks::OnTaskComplete");

        //
        // Do not return failure code in OnTaskComplete
        //
        return S_OK;
    }
    FREE_SIMPLE_SA_MEMORY(lpszTaskName);
    return S_OK;
}

HRESULT CLocMgrTasks::ChangeLangOnTaskExecute(ITaskContext *pTaskParams)
{
    CRegKey crKey;
    DWORD   dwErr, dwLangId, dwAutoConfigVal=0;
    bool    fAutoConfigTask=false;
    HRESULT hr=S_OK;
    HANDLE  hEvent;

    SATraceFunction("CLocMgrTasks::ChangeLangOnTaskExecute");

    dwErr = crKey.Open(HKEY_LOCAL_MACHINE, RESOURCE_REGISTRY_PATH);
    if (dwErr != ERROR_SUCCESS)
    {
        SATracePrintf("RegOpen for resource dir failed %ld in ChangeLangOnTaskExecute",
                      dwErr);
        return HRESULT_FROM_WIN32(dwErr);
    }

    hr = GetChangeLangParameters(pTaskParams,
                                 &dwLangId,
                                 &fAutoConfigTask);
    if (FAILED(hr))
    {
        SATracePrintf("GetChangeLangParameters failed %X in ChangeLangOnTaskExecute",
                      hr);
        return hr;
    }

    if (true == fAutoConfigTask)
    {
        dwErr = crKey.QueryValue(dwAutoConfigVal, REGVAL_AUTO_CONFIG_DONE);
        if ( (ERROR_SUCCESS == dwErr) && (1==dwAutoConfigVal) )
        {
            //
            // auto config has already been done; so ignore this
            // request. however, return success to the caller
            //
            return S_OK;
        }
    }

    dwErr = CreateLangChangeEvent(&hEvent);
    if (0 == dwErr)
    {
        SATracePrintf("CreateEvent failed %ld", dwErr);
        return HRESULT_FROM_WIN32(dwErr);
    }

    dwErr = crKey.SetValue(dwLangId, NEW_LANGID_VALUE);
    if (dwErr != ERROR_SUCCESS)
    {
        SATracePrintf("RegSetValue for new lang id failed %ld in ChangeLangOnTaskExecute",
                      dwErr);
        goto End;
    }

    crKey.SetValue((DWORD)1, REGVAL_AUTO_CONFIG_DONE);

End:
    if (dwErr == ERROR_SUCCESS)
    {
        if (PulseEvent(hEvent) == 0)
        {
            SATracePrintf("PulseEvent failed %ld", GetLastError());
        }
        CloseHandle(hEvent);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    return hr;
}

HRESULT CLocMgrTasks::ChangeLangOnTaskComplete(ITaskContext *pTaskParams, LONG lTaskResult)
{
    SATraceFunction("CLocMgrTasks::ChangeLangOnTaskComplete");
    return S_OK;
}

void CLocMgrTasks::GetTaskName(IN ITaskContext *pTaskParams, OUT LPTSTR *ppszTaskName)
{
    _variant_t vtTaskName;
    HRESULT    hr;
    _bstr_t    bstrParamName("MethodName");

    ASSERT(ppszTaskName);
    ASSERT(pTaskParams);

    if ( (NULL==ppszTaskName) || (NULL==pTaskParams))
    {
        return;
    }

    (*ppszTaskName) = NULL;
    hr = pTaskParams->GetParameter(bstrParamName, &vtTaskName);
    if (FAILED(hr))
    {
        TRACE1("GetParameter(taskname) failed %X in GetTaskName", hr);
        return;
    }
    (*ppszTaskName) = (LPTSTR)SaAlloc((lstrlen(V_BSTR(&vtTaskName))+1)*sizeof(TCHAR));
    if (NULL == (*ppszTaskName))
    {
        TRACE("MemAlloc failed for task name in GetTaskName");
        return;
    }
    lstrcpy((*ppszTaskName), V_BSTR(&vtTaskName));
}

STDMETHODIMP CLocMgrTasks::GetChangeLangParameters(
                                       IN ITaskContext *pTaskContext, 
                                       OUT DWORD       *pdwLangId,
                                       OUT bool        *pfAutoConfigTask)
{
    BSTR    bstrParamLangId         = SysAllocString(TEXT("LanguageID"));
    BSTR    bstrParamAutoConfigTask = SysAllocString(TEXT("AutoConfig"));
    HRESULT hr = S_OK;
    VARIANT varValue;
    int iConversion = 0;

    ASSERT(pTaskContext);
    ASSERT(pdwLangId);
    ASSERT(pfAutoConfigTask);

    if ((NULL == pTaskContext) || (NULL == pdwLangId) || (NULL==pfAutoConfigTask))
    {
         hr = E_POINTER;
         goto End;
    }

    CHECK_MEM_ALLOC("MemAlloc ParamLangId CSAUserTasks::GetChangeLangParameters",
                    bstrParamLangId, hr);

    (*pdwLangId)    = 0;
    (*pfAutoConfigTask) = false;

    
    VariantInit(&varValue);

    // get the lang id
    hr = pTaskContext->GetParameter(bstrParamLangId,
                                    &varValue);
    CHECK_HR_ERROR1(("GetParameter for LangId failed in CSAUserTasks::GetChangeLangParameters %X"), hr);

    if (V_VT(&varValue) != VT_BSTR)
    {
        TRACE1(("Non-string(%X) parameter received LangId in GetParameter in CSAUserTasks::GetChangeLangParameters"), V_VT(&varValue));
        hr = E_INVALIDARG;
        goto End;
    }
    iConversion = swscanf(V_BSTR(&varValue), TEXT("%X"), pdwLangId); 
    VariantClear(&varValue);

    if (iConversion != 1)
    {
        hr = E_FAIL;
        goto End;
    }

    // get the auto config task parameter
    hr = pTaskContext->GetParameter(bstrParamAutoConfigTask,
                                    &varValue);
    if ( (FAILED(hr)) || 
         (V_VT(&varValue)!=VT_BSTR) 
       )
    {
        SATraceString("AutoConfigParam detected false in GetChangeLangParameters");
    }
    else
    {
        if (lstrcmpi( V_BSTR(&varValue), TEXT("y") ) == 0)  
        {
            (*pfAutoConfigTask) = true;
        }
    }
    VariantClear(&varValue);

    hr = S_OK;

End:
    FREE_SIMPLE_BSTR_MEMORY(bstrParamLangId); 
    FREE_SIMPLE_BSTR_MEMORY(bstrParamAutoConfigTask); 
    VariantClear(&varValue);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\datetime.h ===
//#--------------------------------------------------------------
//
//  File:       datetime.h
//
//  Synopsis:   This file holds the declarations of the
//                helper class which parses the CIM_DATETIME
//                information into differents strings
//
//  History:     10/03/2000  MKarki Created
//
//    Copyright (C) 2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _DATETIME_H_
#define _DATETIME_H_

class CDateTime
{
public:

CDateTime (){}

~CDateTime (){}

bool Insert (
        /*[in]*/    PWSTR    pwszCIM_DATETIME
        );
PWSTR GetTime () {return (m_wszTime);}
PWSTR GetDate () {return (m_wszDate);}
    
private:

WCHAR  m_wszDate [MAX_PATH];

WCHAR  m_wszTime [MAX_PATH];

};

#endif // _DATETIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

//#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
//#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\consumerprovider.h ===
//#--------------------------------------------------------------
//
//  File:       consumer.h
//
//  Synopsis:   This file holds the declarations of the
//                Event Consumer Provider COM object
//
//  History:     3/8/2000  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _CONSUMER_PROVIDER_H_
#define _CONSUMER_PROVIDER_H_

#include "stdafx.h"
#include "wbemidl.h"
#include "resource.h"
#include "wbemcli.h"
#include "wbemprov.h"
#include "consumer.h"

//
// declaration of CConsumerProvider class
//
class ATL_NO_VTABLE CConsumerProvider : 
        public IWbemProviderInit,
        public IWbemEventConsumerProvider,
        public CComObjectRootEx<CComMultiThreadModel>,
        public CComCoClass<CConsumerProvider, &CLSID_ConsumerProvider>
{
public:

//
// macros for ATL required methods
//
BEGIN_COM_MAP(CConsumerProvider)
    COM_INTERFACE_ENTRY(IWbemProviderInit)
    COM_INTERFACE_ENTRY(IWbemEventConsumerProvider)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CConsumerProvider)

DECLARE_REGISTRY_RESOURCEID(IDR_ConsumerProvider)

    //
    // constructor does nothing
    //
    CConsumerProvider() 
    {
        SATraceString ("NT Event Filter Consumer Provider being constructed...");
    };

    //
    // destructor does nothing
    //
    ~CConsumerProvider() 
    {
        SATraceString ("NT Event Filter Consumer Provider being destroyed...");
    };


    //
    //------------- IWbemProviderInit Interface------------
    //

    STDMETHOD(Initialize)(
                    /*[in, unique, string]*/    LPWSTR  wszUser,
                    /*[in]*/                    LONG    lFlags,
                    /*[in, string]*/            LPWSTR  wszNamespace,
                    /*[in, unique, string]*/    LPWSTR  wszLocale,
                    /*[in]*/                    IWbemServices*  pNamespace,
                    /*[in]*/                    IWbemContext*          pCtx,
                    /*[in]*/                    IWbemProviderInitSink* pInitSink    
                         );

    
    //
    //------------- IWbemEventConsumerProvider Interface-----
    //
    STDMETHOD(FindConsumer)(
                IWbemClassObject* pLogicalConsumer,
                IWbemUnboundObjectSink** ppConsumer
                );

private:

    //
    // we need to hold on to the IWbemServices interface
    //
    CComPtr <IWbemServices> m_pWbemServices;
};

#endif  _CONSUMER_PROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\consumerprovider.cpp ===
//#--------------------------------------------------------------
//
//  File:       consumerprovider.cpp
//
//  Synopsis:   This file implements the methods of the
//                Event Consumer Provider COM object
//
//  History:     3/8/2000  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#include <stdafx.h>
#include "consumerprovider.h"
#include "consumer.h"
#include "satrace.h"

//++--------------------------------------------------------------
//
//  Function:   Initialize
//
//  Synopsis:   This is the Initialize method of the IWbemProviderInit
//              COM interface
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     3/8/2000
//
//----------------------------------------------------------------
STDMETHODIMP  
CConsumerProvider::Initialize (
    /*[in]*/    LPWSTR          wszUser,
    /*[in]*/    LONG            lFlags,
    /*[in]*/    LPWSTR          wszNamespace,
    /*[in]*/    LPWSTR          wszLocale,
    /*[in]*/    IWbemServices*  pNamespace,
    /*[in]*/    IWbemContext*   pCtx,
    /*[in]*/    IWbemProviderInitSink* pInitSink    
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    SATraceString ("NT EventLog filter event consumer initialization called...");
    //
    // save the IWbemServices interface
    //
    m_pWbemServices = pNamespace;

    //
    // there is no initialization that we want to do here
    //
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);

    return (hr);

}   //  end of CConsumerProvider::Initialize method


/////////////////////////////////////
// IWbemEventConsumerProvider Methods
//++--------------------------------------------------------------
//
//  Function:   FindConsumer
//
//  Synopsis:   This is the FindConsumer method of the 
//              IWbemEventConsumerProvider COM interface
//
//  Arguments: 
//              [in]    IWbemClassObject* - logical consumer
//              [out]   IWbemUnboundObjectSink** - return consumer here
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     3/8/2000
//
//----------------------------------------------------------------
STDMETHODIMP 
CConsumerProvider::FindConsumer (
    /*[in]*/    IWbemClassObject*        pLogicalConsumer,
    /*[out]*/   IWbemUnboundObjectSink** ppConsumer
    )
{
    HRESULT hr = S_OK;

    SATraceString ("NT Event Log Filter Event Consumer Provider FindConsumer called...");

    try
    {
        //
        // create a consumer sink object now
        //
        SA_NTEVENTFILTER_CONSUMER_OBJ *pConsumerObject
                                    = new  SA_NTEVENTFILTER_CONSUMER_OBJ;
        //
        // initialize the consumer object now
        //
        hr = pConsumerObject->Initialize (m_pWbemServices.p);
        if (SUCCEEDED (hr))
        {
            *ppConsumer = (IWbemUnboundObjectSink*) pConsumerObject;
            SATraceString  ("NT Event Log Filter Event Consumer Provider successfully created sink object...");
        }
    }
    catch (const std::bad_alloc&)
    {
        SATraceString (
            "NT Event Log Filter Event consumer Provider unable to allocate"
             "memory for consumer sink object on FindConsumer call"
            );
        hr = E_OUTOFMEMORY;
    }
    catch (...)
    {
        SATraceString (
            "NT Event Log Filter Event consumer Provider caught"
             "unhandled exception on FindConsumer call"
            );
              
        hr = E_FAIL;
    }

    return (hr);

}   // end of CConsumerProvider::FindConsumer method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\datetime.cpp ===
//#--------------------------------------------------------------
//
//  File:        datetime.cpp
//
//  Synopsis:   Implementation of CDateTime class methods
//
//
//  History:    10/03/2000  MKarki Created
//
//    Copyright (C) 2000 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "stdafx.h"
#include "datetime.h"

//++--------------------------------------------------------------
//
//  Function:   Insert
//
//  Synopsis:   This is the method which is used to parse the 
//                date time string provided in CIM_DATETIME format
//
//  Arguments:  [in] PWSTR - datetime
//
//  Returns:    bool - success/failure
//
//
//  History:    MKarki      Created     10/03/2000
//
//
//----------------------------------------------------------------
bool
CDateTime::Insert (
    /*in]*/    PWSTR    pwszDateTime
    )
{
    CSATraceFunc objTraceFunc ("CDateTime::Insert");
    
    bool bRetVal = false;

    do
    {
        if (NULL == pwszDateTime)
        {
            SATracePrintf ("DateTime-passed invalid parameters");
            break;
        }

        SATracePrintf ("DateTime called with input:'%ws'", pwszDateTime);
        
        bool bFormat = true;
        for (DWORD dwCount = 0; (dwCount < 14) && (bFormat); dwCount++)
        {
            if (!isdigit (pwszDateTime[dwCount])) 
            {
                bFormat = false;
            }
        }

        if (!bFormat)
        {
            SATraceString ("DateTime - given input of incorrect format");
            break;
        }

        //
        //    get the month
        //
        wcsncpy  (m_wszDate, pwszDateTime+4, 2);
        m_wszDate[2] = '\0';
        wcscat (m_wszDate, L"/");
        //
        // get the day
        //
        wcsncat (m_wszDate, pwszDateTime+6, 2);
        m_wszDate[5] = '\0';
        wcscat (m_wszDate, L"/");
        //
        // get the year
        //
        wcsncat (m_wszDate, pwszDateTime, 4);
        m_wszDate[10] = '\0';

        //
        // get the hour
        //
        wcsncpy (m_wszTime, pwszDateTime+8, 2);
        m_wszTime[2] = '\0';
        wcscat (m_wszTime,L":");
        //
        // get the minutes
        //
        wcsncat (m_wszTime, pwszDateTime+10, 2);
        m_wszTime[5] = '\0';
        wcscat (m_wszTime, L":");
        //
        // get the seconds
        //
        wcsncat (m_wszTime, pwszDateTime+12, 2);

        //
        // done
        //
        bRetVal = true;

        SATracePrintf ("Date:'%ws'", m_wszDate);
        SATracePrintf ("Time:'%ws'", m_wszTime);
    }            
    while (false);

    return (bRetVal);
    
}    // end of CDateTime::Insert method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\sacls.h ===
//#--------------------------------------------------------------
//
//  File:       sacls.h
//
//  Synopsis:   This file holds the declarations for the lock
//              class which can be used to serialize access
//                to a lockable class
//
//
//  History:     2/9/99  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _SACLS_H_
#define _SACLS_H_

//
// the class T should have members method Lock() and UnLock defined
//
template <class T> 
class CSALock 
{
public:
    explicit CSALock (const T& lock)  throw ()
        :m_Lockable (const_cast <T&> (lock))
    {
        m_Lockable.Lock ();
    }

    ~CSALock () throw ()
    {
        m_Lockable.UnLock ();
    }

protected:
    T&  m_Lockable;
};

//
// this is the class implmenting the Lock () and UnLock methods from
// which the Serve Appliance classes needing locking can derive
//

class CSALockable 
{

public:

    CSALockable () throw ()
    {
        ::InitializeCriticalSection (&m_SACritSect);
    }

    ~CSALockable () throw ()
    {
        ::DeleteCriticalSection (&m_SACritSect);
    }

    VOID Lock () throw () 
    {
        ::EnterCriticalSection (&m_SACritSect);
    }

    VOID UnLock () throw () 
    {
        ::LeaveCriticalSection (&m_SACritSect);
    }

protected:

    //
    // critical section that actual does the guarding
    //
    CRITICAL_SECTION m_SACritSect;

};  //  end of CSALockable class declaration

//
// the class T should have members method Increment() and Decrement defined
//
template <class T> 
class CSACounter
{
public:
    explicit CSACounter (const T& countable)  throw ()
        :m_Countable (const_cast <T&> (countable))
    {
        m_Countable.Increment();
    }

    ~CSACounter () throw ()
    {
        m_Countable.Decrement();
    }

protected:
    T&  m_Countable;
};

//
// this is the class implmenting the Increment() and Decrement methods from
// which the Serve Appliance classes needing counting can derive
//

class CSACountable
{

public:

    CSACountable () throw ()
        :m_lCount (0) 
        {}

    ~CSACountable () throw () {}

    LONG Increment () throw () 
    {
        return InterlockedIncrement (&m_lCount);
    }

    VOID Decrement () throw () 
    {
        ::InterlockedDecrement (&m_lCount);
    }

protected:

   LONG m_lCount;

};  //  end of CSALockable class declaration
   
#endif //_SACLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\resource.h ===
#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_ConsumerProvider        101
#define IDR_ConsumerProvider        102

#endif // ifndef _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\sagenmsg\makefile.inc ===
sagenmsg.rc: msg00001.bin

sagenmsg.h msg00001.bin: sagenmsg.mc
    mc -v sagenmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_)
#define AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#if !defined(_WIN64) && !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif
//#define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#include "saevfltr.h"
#include "comdef.h"

#include <satrace.h>


#endif // !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\ntevents\saevfltr.cpp ===
//#--------------------------------------------------------------
//        
//  File:       saevfltr.cpp
//        
//  Synopsis:   this is the main Source File for the Server Appliance
//               NT Event Filter Event Consumer component
//              
//
//  History:     3/8/2000  MKarki Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

//
// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f radprotops.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "saevfltr.h"
#include "saevfltr_i.c"
#include "consumerprovider.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(ConsumerProvider), CConsumerProvider)
END_OBJECT_MAP()

//++--------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Disabling thread calls
//
//  Arguments:  [in]    HINSTANCE - module handle
//              [in]    DWORD     - reason for call
//              reserved 
//
//  Returns:    BOOL    -   sucess/failure
//
//
//  History:    MKarki      Created     3/8/2000
//
//----------------------------------------------------------------
extern "C" BOOL WINAPI 
DllMain(
    HINSTANCE   hInstance, 
    DWORD       dwReason, 
    LPVOID      lpReserved
    )
{

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }

    return (TRUE);

}   //  end of DllMain method

//++--------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Used to determine if the DLL can be unloaded
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     3/8/2000
//
//----------------------------------------------------------------
STDAPI 
DllCanUnloadNow(
            VOID
            )
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

}   //  end of DllCanUnloadNow method

//++--------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Returns a class factory to create an object 
//              of the requested type
//
//  Arguments: [in]  REFCLSID  
//             [in]  REFIID    
//             [out] LPVOID -   class factory
//              
//
//  Returns:    HRESULT
//
//
//  History:    MKarki      Created     3/8/2000
//
//----------------------------------------------------------------
STDAPI 
DllGetClassObject(
            REFCLSID rclsid, 
            REFIID riid, 
            LPVOID* ppv
            )
{
    return (_Module.GetClassObject(rclsid, riid, ppv));

}   //  end of DllGetClassObject method

//++--------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Add entries to the system registry
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     3/8/2000
//
//----------------------------------------------------------------
STDAPI DllRegisterServer(
            VOID
            )
{
    //
    // registers object, typelib and all interfaces in typelib
    //
    return (_Module.RegisterServer(TRUE));

}   //  end of DllRegisterServer method

//++--------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Removes entries from the system registry
//
//  Arguments:  NONE
//
//  Returns:    HRESULT
//
//  History:    MKarki      Created     3/8/2000
//
//----------------------------------------------------------------
STDAPI DllUnregisterServer(
        VOID
        )
{
    _Module.UnregisterServer();
    return (S_OK);

}   //  end of DllUnregisterServer method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\sahelper\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

//#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
//#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\componentfactory.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1997-1998 Microsoft Corporation all rights reserved.
//
// Module:      componentfactory.cpp
//
// Project:     Chameleon
//
// Description: Component Factory Implementation
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Original Version
//
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "componentfactory.h"

// Make sure that in your class map include file 
// you've named the the component factory "TheFactoryMap" 

#include "componentfactorymap.h"

//////////////////////////////////////////////////////////////////////////////
// Global Component Factory Function.
// 
// Note that the interface returned is the interface specified in the
// DECLARE_COMPONENT_FACTORY macro
//
//////////////////////////////////////////////////////////////////////////////
IUnknown* MakeComponent(
                   /*[in]*/ LPCWSTR      pszClassId,
                 /*[in]*/ PPROPERTYBAG pPropertyBag
                       )
{
    IUnknown* pComponent = NULL;
    bool      bFound = false;
    PCOMPONENT_FACTORY_INFO pFactoryInfo = TheFactoryMap;
    while ( pFactoryInfo->pszClassId )
    {
        if ( 0 == lstrcmpi(pFactoryInfo->pszClassId, pszClassId) )
        {
            _ASSERT ( NULL != pFactoryInfo->pfnFactory );
            bFound = true;
            pComponent = (pFactoryInfo->pfnFactory)(pPropertyBag);
            // Ref count of new component pointed at by pComponent is 0 at this point...
            break;
        }
        pFactoryInfo++;
    }
    if ( NULL == pComponent )
    {    
        if ( bFound )
        { 
            SATracePrintf("::MakeComponent() - Failed - Component of type '%ls' was not created...", pszClassId); 
        }
        else
        { 
            SATracePrintf("::MakeComponent() - Failed - Component of type '%ls' was not found...", pszClassId); 
            _ASSERT( FALSE ); /* Should never happens - signifies error in our static factory map */ 
        }
    }    
    return pComponent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\sahelper\resource.h ===
#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_SAHelper                    100
#define IDR_SAHelper                    101

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\sahelper\cab_dll.h ===
/* cab_dll.h -- CABINET.DLL high-level APIs */

#ifndef _CAB_DLL_H_INCLUDED
#define _CAB_DLL_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

// File Name List
//
// used as pFilesToExtract to track files in the CAB we need extracted
//
// or a pFileList in PSESSION
//
// We keep track of all files that are in a cabinet
// keeping their names in a list and when the download
// is complete we use this list to delete temp files

struct sFNAME {
    LPWSTR               pszFilename;
    struct sFNAME       *pNextName;
    DWORD               status; /* out */
};

typedef struct sFNAME FNAME;
typedef FNAME *PFNAME;


// SFNAME.status: success is 0 or non-zero error code in extraction
#define SFNAME_INIT         1
#define SFNAME_EXTRACTED    0

/***    ERRF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 *
 *  Identical to an FCI/FDI ERF, but renamed to avoid collision.
 */

typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERRF;

//
// Master State Information for File Extraction: used by extract.c
//

typedef struct {
    UINT        cbCabSize;
    ERRF        erf;
    PFNAME      pFileList;              // List of Files in CAB
    UINT        cFiles;
    DWORD       flags;                  // flags: see below for list
    WCHAR        achLocation[MAX_PATH];  // Dest Dir
    WCHAR        achFile[MAX_PATH];      // Current File
    WCHAR        achCabPath[MAX_PATH];   // Current Path to cabs
    PFNAME      pFilesToExtract;        // files to extract;null=enumerate only

} SESSION, *PSESSION;

typedef enum {
    SESSION_FLAG_NONE           = 0x0,
    SESSION_FLAG_ENUMERATE      = 0x1,
    SESSION_FLAG_EXTRACT_ALL    = 0x2,
    SESSION_FLAG_EXTRACTED_ALL  = 0x4
} SESSION_FLAGS;


typedef struct
{
    DWORD   cbStruct;
    DWORD   dwReserved1;
    DWORD   dwReserved2;
    DWORD   dwFileVersionMS;
    DWORD   dwFileVersionLS;

} CABINETDLLVERSIONINFO, *PCABINETDLLVERSIONINFO;


/* export definitions */

typedef LPWSTR WINAPI FN_GETDLLVERSION(VOID);
typedef FN_GETDLLVERSION *PFN_GETDLLVERSION;

typedef VOID WINAPI FN_DLLGETVERSION(PCABINETDLLVERSIONINFO);
typedef FN_DLLGETVERSION *PFN_DLLGETVERSION;

typedef HRESULT WINAPI FN_EXTRACT(PSESSION,LPWSTR);
typedef FN_EXTRACT *PFN_EXTRACT;

typedef VOID WINAPI FN_DELETEEXTRACTEDFILES(PSESSION);
typedef FN_DELETEEXTRACTEDFILES *PFN_DELETEEXTRACTEDFILES;

#ifdef __cplusplus
}
#endif

#endif // _CAB_DLL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\sahelper\helper.h ===
//#--------------------------------------------------------------
//
//  File:       helper.h
//
//  Synopsis:   This file holds the declarations of the SAHelper COM class
//
//  History:     05/24/99 
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef __SAHELPER_H_
#define __SAHELPER_H_

#define MYDEBUG 0

#include "stdafx.h"            //ATL_NO_VTABLE, _ASSERT, SATrace
#include "cab_dll.h"        //PFNAME, PSESSION
#include <setupapi.h>        //Setup API, HINF, INFCONTEXT
#include "resource.h"        //IDR_SAHELPER
#include <vector>
#include <string>
#include <iptypes.h>
#include <Iphlpapi.h>
#include "netcfgp.h"
#include <winsock.h>
#include <lm.h>
#include <atlctl.h>
#include "salocmgr.h"
#include <Sddl.h>

class ATL_NO_VTABLE CHelper: 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CHelper , &CLSID_SAHelper>,
    public IDispatchImpl<ISAHelper, &IID_ISAHelper, &LIBID_SAHelperLib>,
    public IObjectSafetyImpl<CHelper>
{
public:
    CHelper () {}
    ~CHelper () {}

DECLARE_REGISTRY_RESOURCEID(IDR_SAHelper)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHelper)
    COM_INTERFACE_ENTRY(ISAHelper)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

    //
    // This interface is implemented to mark the component as safe for scripting
    // IObjectSafety interface methods
    //
    STDMETHOD(SetInterfaceSafetyOptions)
                        (
                        REFIID riid, 
                        DWORD dwOptionSetMask, 
                        DWORD dwEnabledOptions
                        )
    {
        BOOL bSuccess = ImpersonateSelf(SecurityImpersonation);
  
        if (!bSuccess)
        {
            return E_FAIL;

        }

        bSuccess = IsOperationAllowedForClient();

        RevertToSelf();

        return bSuccess? S_OK : E_FAIL;
    }
    //
    // ISAHelper interface methods
    //
    STDMETHOD (ExpandFiles)
                        (
                        /*[in]*/    BSTR    bstrCabFileName,
                        /*[in]*/    BSTR    bstrDestDir,
                        /*[out]*/    BSTR    bstrExtractFile
                        );

    STDMETHOD (VerifySignature) 
                        (
                        /*[in]*/    BSTR        bstrCabFileName
                        );

    STDMETHOD (UploadFile) 
                        (
                        /*[in]*/    BSTR        bstrSrcFile,
                        /*[in]*/    BSTR        bstrDestFile
                        );

    STDMETHOD (GetFileSectionKeyValue)
                        (
                        /*[in]*/    BSTR bstrFileName, 
                        /*[in]*/    BSTR bstrSectionName, 
                        /*[in]*/    BSTR bstrKeyName, 
                        /*[out]*/    BSTR *pbstrKeyValue
                        );

    STDMETHOD (VerifyDiskSpace) ( );

    STDMETHOD (VerifyInstallSpace) ( );

    STDMETHOD (IsWindowsPowered) 
                        (
                        /*[out]*/   VARIANT_BOOL *pvbIsWindowsPowered
                        );

    //
    // get the value from the HKEY_LOCAL_MACHINE registry hive
    //
    STDMETHOD (GetRegistryValue) 
                        (
                        /*[in]*/    BSTR        bstrObjectPathName,
                        /*[in]*/    BSTR        bstrValueName,
                        /*[out]*/   VARIANT*    pValue,
                        /*[in]*/    UINT        ulExpectedType
                        ); 
    //
    // set the value in the HKEY_LOCAL_MACHINE registry hive
    //
    STDMETHOD (SetRegistryValue) 
                        (
                        /*[in]*/    BSTR        bstrObjectPathName,
                        /*[in]*/    BSTR        bstrValueName,
                        /*[out]*/   VARIANT*    pValue
                        );
    //
    // check if the boot partition mirroring is OK
    //
    STDMETHOD (IsBootPartitionReady) (
                        VOID 
                        );
    //
    // are we running primary or alternate OS
    //
    STDMETHOD (IsPrimaryOS) (
                    VOID
                    );

    //
    // sets static ip on default network interface
    //
    STDMETHOD (SetStaticIp)
                (
                /*[in]*/BSTR bstrIp,
                /*[in]*/BSTR bstrMask,
                /*[in]*/BSTR bstrGateway
                );

    //
    // obtains dynamic ip from DHCP
    //
    STDMETHOD (SetDynamicIp)();

    //
    // gets the default gateway
    //
    STDMETHOD (get_DefaultGateway)
                (
                /*[out, retval]*/ BSTR *pVal
                );

    //
    // gets the subnet mask
    //
    STDMETHOD (get_SubnetMask)
                (
                /*[out, retval]*/ BSTR *pVal
                );

    //
    // gets the ip address
    //
    STDMETHOD (get_IpAddress)
                (
                /*[out, retval]*/ BSTR *pVal
                );

    //
    // gets the machine name
    //
    STDMETHOD (get_HostName)
                (
                /*[out, retval]*/ BSTR *pVal
                );

    //
    // sets the machine name
    //
    STDMETHOD (put_HostName)
                (
                /*[in]*/ BSTR newVal
                );

    //
    // resets the admin password to 123
    //
    STDMETHOD (ResetAdministratorPassword)
                (
                /*[out,retval]*/VARIANT_BOOL   *pvbSuccess
                );

    //
    // checks if the machine name exists in the network
    //
    STDMETHOD (IsDuplicateMachineName)
                (
                /*[in]*/BSTR bstrMachineName,
                /*[out,retval]*/VARIANT_BOOL   *pvbDuplicate
                );

    //
    // checks if the machine is part of a domain
    //
    STDMETHOD (IsPartOfDomain)
                (
                /*[out,retval]*/VARIANT_BOOL   *pvbDomain
                );
    //
    // checks if the machine has dynamic ip currently
    //
    STDMETHOD (IsDHCPEnabled)
                (
                /*[out,retval]*/VARIANT_BOOL   *pvbDHCPEnabled
                );

    //
    // generates a random password length of first parameter
    //
    STDMETHOD (GenerateRandomPassword)
                (
                /*[in]*/ LONG lLength,
                /*[out,retval]*/ BSTR   *pValPassword
                );

    //
    // enables or disables the privelege for the current access token
    //
    STDMETHOD (SAModifyUserPrivilege)
                (
                /*[in]*/ BSTR bstrPrivilegeName,
                /*[in]*/ VARIANT_BOOL vbEnable,
                /*[out,retval]*/ VARIANT_BOOL * pvbModified
                );

private:

    //
    // gets specific ip information based on dwType
    //
    HRESULT GetIpInfo
                (
                /*[in]*/DWORD dwType,
                /*[out]*/BSTR * pVal
                );

    //
    // gets the default adapter guid
    //
    BOOL GetDefaultAdapterGuid
                (
                /*[out]*/GUID * pGuidAdapter
                );

    //
    // sets static or dynamic ip on guidAdapter
    //
    HRESULT SetAdapterInfo
                (
                /*[in]*/GUID guidAdapter, 
                /*[in]*/WCHAR * szOperation, 
                /*[in]*/WCHAR * szIp, 
                /*[in]*/WCHAR * szMask,
                /*[in]*/WCHAR * szGateway
                );

    //
    // copies ip info
    //
    HRESULT CopyIPInfo
                (
                /*[in]*/REMOTE_IPINFO * pIPInfo, 
                /*[in/out]*/REMOTE_IPINFO * destIPInfo
                );

    //
    // validates ip address format
    //
    BOOL _IsValidIP 
                (
                /*[in]*/LPCWSTR szIPAddress
                );

    //
    // private data here
    //
    static UINT __stdcall ExpandFilesCallBackFunction( 
                            /*[in]*/            PVOID pvExtractFileContext, 
                            /*[in]*/            UINT uinotifn, 
                            /*[in]*/            UINT uiparam1, 
                            /*[in]*/            UINT uiparam2 
                            );

    //
    // method used to validate the digital signature on the file
    //
    HRESULT ValidateCertificate (
                            /*[in]*/    BSTR    bstrFilePath
                            );

    //
    // method used to validate the owner of digital signature
    // on the file
    //
    HRESULT ValidateCertOwner (
                            /*[in]*/    BSTR    bstrFilePath
                            );

    typedef std::vector <std::wstring> STRINGVECTOR;

    HRESULT  GetValidOwners (
                            /*[in/out]*/    STRINGVECTOR&   vectorSubject
                            );

    //
    // 
    // IsOperationAllowedForClient - This function checks the token of the 
    // calling thread to see if the caller belongs to the Local System account
    // 
    BOOL IsOperationAllowedForClient (
                                      VOID
                                     );

};

#endif //__SAHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\sahelper\netcfgp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Tue Nov 30 14:26:53 1999
 */
/* Compiler settings for netcfgp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netcfgp_h__
#define __netcfgp_h__

/* Forward Declarations */ 

#ifndef __IIpxAdapterInfo_FWD_DEFINED__
#define __IIpxAdapterInfo_FWD_DEFINED__
typedef interface IIpxAdapterInfo IIpxAdapterInfo;
#endif     /* __IIpxAdapterInfo_FWD_DEFINED__ */


#ifndef __ITcpipProperties_FWD_DEFINED__
#define __ITcpipProperties_FWD_DEFINED__
typedef interface ITcpipProperties ITcpipProperties;
#endif     /* __ITcpipProperties_FWD_DEFINED__ */


#ifndef __INetCfgInternalSetup_FWD_DEFINED__
#define __INetCfgInternalSetup_FWD_DEFINED__
typedef interface INetCfgInternalSetup INetCfgInternalSetup;
#endif     /* __INetCfgInternalSetup_FWD_DEFINED__ */


#ifndef __INetCfgComponentPrivate_FWD_DEFINED__
#define __INetCfgComponentPrivate_FWD_DEFINED__
typedef interface INetCfgComponentPrivate INetCfgComponentPrivate;
#endif     /* __INetCfgComponentPrivate_FWD_DEFINED__ */


#ifndef __INetInstallQueue_FWD_DEFINED__
#define __INetInstallQueue_FWD_DEFINED__
typedef interface INetInstallQueue INetInstallQueue;
#endif     /* __INetInstallQueue_FWD_DEFINED__ */


#ifndef __INetCfgSpecialCase_FWD_DEFINED__
#define __INetCfgSpecialCase_FWD_DEFINED__
typedef interface INetCfgSpecialCase INetCfgSpecialCase;
#endif     /* __INetCfgSpecialCase_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "netcfgx.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_netcfgp_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif
STDAPI
SvchostChangeSvchostGroup (
    LPCWSTR pszService,
    LPCWSTR pszNewGroup
    );








extern RPC_IF_HANDLE __MIDL_itf_netcfgp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netcfgp_0000_v0_0_s_ifspec;

#ifndef __IIpxAdapterInfo_INTERFACE_DEFINED__
#define __IIpxAdapterInfo_INTERFACE_DEFINED__

/* interface IIpxAdapterInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIpxAdapterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133270-4B20-11D1-AB01-00805FC1270E")
    IIpxAdapterInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameTypesForAdapter( 
            /* [string][in] */ LPCWSTR pszwAdapterBindName,
            /* [in] */ DWORD cFrameTypesMax,
            /* [length_is][size_is][out] */ DWORD __RPC_FAR *anFrameTypes,
            /* [ref][out] */ DWORD __RPC_FAR *pcFrameTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualNetworkNumber( 
            /* [out] */ DWORD __RPC_FAR *pdwVNetworkNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVirtualNetworkNumber( 
            /* [in] */ DWORD dwVNetworkNumber) = 0;
        
    };
    
#else     /* C style interface */

    typedef struct IIpxAdapterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IIpxAdapterInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IIpxAdapterInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IIpxAdapterInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFrameTypesForAdapter )( 
            IIpxAdapterInfo __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszwAdapterBindName,
            /* [in] */ DWORD cFrameTypesMax,
            /* [length_is][size_is][out] */ DWORD __RPC_FAR *anFrameTypes,
            /* [ref][out] */ DWORD __RPC_FAR *pcFrameTypes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVirtualNetworkNumber )( 
            IIpxAdapterInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwVNetworkNumber);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVirtualNetworkNumber )( 
            IIpxAdapterInfo __RPC_FAR * This,
            /* [in] */ DWORD dwVNetworkNumber);
        
        END_INTERFACE
    } IIpxAdapterInfoVtbl;

    interface IIpxAdapterInfo
    {
        CONST_VTBL struct IIpxAdapterInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIpxAdapterInfo_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIpxAdapterInfo_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IIpxAdapterInfo_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IIpxAdapterInfo_GetFrameTypesForAdapter(This,pszwAdapterBindName,cFrameTypesMax,anFrameTypes,pcFrameTypes)    \
    (This)->lpVtbl -> GetFrameTypesForAdapter(This,pszwAdapterBindName,cFrameTypesMax,anFrameTypes,pcFrameTypes)

#define IIpxAdapterInfo_GetVirtualNetworkNumber(This,pdwVNetworkNumber)    \
    (This)->lpVtbl -> GetVirtualNetworkNumber(This,pdwVNetworkNumber)

#define IIpxAdapterInfo_SetVirtualNetworkNumber(This,dwVNetworkNumber)    \
    (This)->lpVtbl -> SetVirtualNetworkNumber(This,dwVNetworkNumber)

#endif /* COBJMACROS */


#endif     /* C style interface */



HRESULT STDMETHODCALLTYPE IIpxAdapterInfo_GetFrameTypesForAdapter_Proxy( 
    IIpxAdapterInfo __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszwAdapterBindName,
    /* [in] */ DWORD cFrameTypesMax,
    /* [length_is][size_is][out] */ DWORD __RPC_FAR *anFrameTypes,
    /* [ref][out] */ DWORD __RPC_FAR *pcFrameTypes);


void __RPC_STUB IIpxAdapterInfo_GetFrameTypesForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIpxAdapterInfo_GetVirtualNetworkNumber_Proxy( 
    IIpxAdapterInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwVNetworkNumber);


void __RPC_STUB IIpxAdapterInfo_GetVirtualNetworkNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIpxAdapterInfo_SetVirtualNetworkNumber_Proxy( 
    IIpxAdapterInfo __RPC_FAR * This,
    /* [in] */ DWORD dwVNetworkNumber);


void __RPC_STUB IIpxAdapterInfo_SetVirtualNetworkNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif     /* __IIpxAdapterInfo_INTERFACE_DEFINED__ */


#ifndef __ITcpipProperties_INTERFACE_DEFINED__
#define __ITcpipProperties_INTERFACE_DEFINED__

/* interface ITcpipProperties */
/* [unique][uuid][object][local] */ 

typedef struct tagREMOTE_IPINFO
    {
    DWORD dwEnableDhcp;
    WCHAR __RPC_FAR *pszwIpAddrList;
    WCHAR __RPC_FAR *pszwSubnetMaskList;
    WCHAR __RPC_FAR *pszwOptionList;
    }    REMOTE_IPINFO;


EXTERN_C const IID IID_ITcpipProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133271-4B20-11D1-AB01-00805FC1270E")
    ITcpipProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIpInfoForAdapter( 
            /* [in] */ const GUID __RPC_FAR *pguidAdapter,
            /* [out] */ REMOTE_IPINFO __RPC_FAR *__RPC_FAR *ppInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIpInfoForAdapter( 
            /* [in] */ const GUID __RPC_FAR *pguidAdapter,
            /* [in] */ REMOTE_IPINFO __RPC_FAR *pInfo) = 0;
        
    };
    
#else     /* C style interface */

    typedef struct ITcpipPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITcpipProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITcpipProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITcpipProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIpInfoForAdapter )( 
            ITcpipProperties __RPC_FAR * This,
            /* [in] */ const GUID __RPC_FAR *pguidAdapter,
            /* [out] */ REMOTE_IPINFO __RPC_FAR *__RPC_FAR *ppInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIpInfoForAdapter )( 
            ITcpipProperties __RPC_FAR * This,
            /* [in] */ const GUID __RPC_FAR *pguidAdapter,
            /* [in] */ REMOTE_IPINFO __RPC_FAR *pInfo);
        
        END_INTERFACE
    } ITcpipPropertiesVtbl;

    interface ITcpipProperties
    {
        CONST_VTBL struct ITcpipPropertiesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITcpipProperties_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITcpipProperties_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define ITcpipProperties_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define ITcpipProperties_GetIpInfoForAdapter(This,pguidAdapter,ppInfo)    \
    (This)->lpVtbl -> GetIpInfoForAdapter(This,pguidAdapter,ppInfo)

#define ITcpipProperties_SetIpInfoForAdapter(This,pguidAdapter,pInfo)    \
    (This)->lpVtbl -> SetIpInfoForAdapter(This,pguidAdapter,pInfo)

#endif /* COBJMACROS */


#endif     /* C style interface */



HRESULT STDMETHODCALLTYPE ITcpipProperties_GetIpInfoForAdapter_Proxy( 
    ITcpipProperties __RPC_FAR * This,
    /* [in] */ const GUID __RPC_FAR *pguidAdapter,
    /* [out] */ REMOTE_IPINFO __RPC_FAR *__RPC_FAR *ppInfo);


void __RPC_STUB ITcpipProperties_GetIpInfoForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITcpipProperties_SetIpInfoForAdapter_Proxy( 
    ITcpipProperties __RPC_FAR * This,
    /* [in] */ const GUID __RPC_FAR *pguidAdapter,
    /* [in] */ REMOTE_IPINFO __RPC_FAR *pInfo);


void __RPC_STUB ITcpipProperties_SetIpInfoForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif     /* __ITcpipProperties_INTERFACE_DEFINED__ */


#ifndef __INetCfgInternalSetup_INTERFACE_DEFINED__
#define __INetCfgInternalSetup_INTERFACE_DEFINED__

/* interface INetCfgInternalSetup */
/* [unique][uuid][object][local] */ 

typedef 
enum tagCI_FILTER_COMPONENT
    {    FC_LAN    = 0,
    FC_RASSRV    = FC_LAN + 1,
    FC_RASCLI    = FC_RASSRV + 1,
    FC_ATM    = FC_RASCLI + 1
    }    CI_FILTER_COMPONENT;

typedef struct tagCI_FILTER_INFO
    {
    CI_FILTER_COMPONENT eFilter;
    INetCfgComponent __RPC_FAR *pIComp;
    void __RPC_FAR *pvReserved;
    }    CI_FILTER_INFO;


EXTERN_C const IID IID_INetCfgInternalSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133276-4B20-11D1-AB01-00805FC1270E")
    INetCfgInternalSetup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginBatchOperation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitBatchOperation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectWithFilterAndInstall( 
            /* [in] */ HWND hwndParent,
            /* [in] */ const GUID __RPC_FAR *pClassGuid,
            /* [in] */ OBO_TOKEN __RPC_FAR *pOboToken,
            /* [in] */ const CI_FILTER_INFO __RPC_FAR *pcfi,
            /* [out] */ INetCfgComponent __RPC_FAR *__RPC_FAR *ppIComp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratedComponentInstalled( 
            /* [in] */ PVOID pComponent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratedComponentUpdated( 
            /* [in] */ LPCWSTR pszPnpId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateNonEnumeratedComponent( 
            /* [in] */ INetCfgComponent __RPC_FAR *pIComp,
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFromBuildNo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratedComponentRemoved( 
            /* [in] */ LPCWSTR pszPnpId) = 0;
        
    };
    
#else     /* C style interface */

    typedef struct INetCfgInternalSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INetCfgInternalSetup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INetCfgInternalSetup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INetCfgInternalSetup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginBatchOperation )( 
            INetCfgInternalSetup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommitBatchOperation )( 
            INetCfgInternalSetup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectWithFilterAndInstall )( 
            INetCfgInternalSetup __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ const GUID __RPC_FAR *pClassGuid,
            /* [in] */ OBO_TOKEN __RPC_FAR *pOboToken,
            /* [in] */ const CI_FILTER_INFO __RPC_FAR *pcfi,
            /* [out] */ INetCfgComponent __RPC_FAR *__RPC_FAR *ppIComp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumeratedComponentInstalled )( 
            INetCfgInternalSetup __RPC_FAR * This,
            /* [in] */ PVOID pComponent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumeratedComponentUpdated )( 
            INetCfgInternalSetup __RPC_FAR * This,
            /* [in] */ LPCWSTR pszPnpId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateNonEnumeratedComponent )( 
            INetCfgInternalSetup __RPC_FAR * This,
            /* [in] */ INetCfgComponent __RPC_FAR *pIComp,
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFromBuildNo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumeratedComponentRemoved )( 
            INetCfgInternalSetup __RPC_FAR * This,
            /* [in] */ LPCWSTR pszPnpId);
        
        END_INTERFACE
    } INetCfgInternalSetupVtbl;

    interface INetCfgInternalSetup
    {
        CONST_VTBL struct INetCfgInternalSetupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgInternalSetup_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgInternalSetup_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define INetCfgInternalSetup_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define INetCfgInternalSetup_BeginBatchOperation(This)    \
    (This)->lpVtbl -> BeginBatchOperation(This)

#define INetCfgInternalSetup_CommitBatchOperation(This)    \
    (This)->lpVtbl -> CommitBatchOperation(This)

#define INetCfgInternalSetup_SelectWithFilterAndInstall(This,hwndParent,pClassGuid,pOboToken,pcfi,ppIComp)    \
    (This)->lpVtbl -> SelectWithFilterAndInstall(This,hwndParent,pClassGuid,pOboToken,pcfi,ppIComp)

#define INetCfgInternalSetup_EnumeratedComponentInstalled(This,pComponent)    \
    (This)->lpVtbl -> EnumeratedComponentInstalled(This,pComponent)

#define INetCfgInternalSetup_EnumeratedComponentUpdated(This,pszPnpId)    \
    (This)->lpVtbl -> EnumeratedComponentUpdated(This,pszPnpId)

#define INetCfgInternalSetup_UpdateNonEnumeratedComponent(This,pIComp,dwSetupFlags,dwUpgradeFromBuildNo)    \
    (This)->lpVtbl -> UpdateNonEnumeratedComponent(This,pIComp,dwSetupFlags,dwUpgradeFromBuildNo)

#define INetCfgInternalSetup_EnumeratedComponentRemoved(This,pszPnpId)    \
    (This)->lpVtbl -> EnumeratedComponentRemoved(This,pszPnpId)

#endif /* COBJMACROS */


#endif     /* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_BeginBatchOperation_Proxy( 
    INetCfgInternalSetup __RPC_FAR * This);


void __RPC_STUB INetCfgInternalSetup_BeginBatchOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_CommitBatchOperation_Proxy( 
    INetCfgInternalSetup __RPC_FAR * This);


void __RPC_STUB INetCfgInternalSetup_CommitBatchOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_SelectWithFilterAndInstall_Proxy( 
    INetCfgInternalSetup __RPC_FAR * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ const GUID __RPC_FAR *pClassGuid,
    /* [in] */ OBO_TOKEN __RPC_FAR *pOboToken,
    /* [in] */ const CI_FILTER_INFO __RPC_FAR *pcfi,
    /* [out] */ INetCfgComponent __RPC_FAR *__RPC_FAR *ppIComp);


void __RPC_STUB INetCfgInternalSetup_SelectWithFilterAndInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_EnumeratedComponentInstalled_Proxy( 
    INetCfgInternalSetup __RPC_FAR * This,
    /* [in] */ PVOID pComponent);


void __RPC_STUB INetCfgInternalSetup_EnumeratedComponentInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_EnumeratedComponentUpdated_Proxy( 
    INetCfgInternalSetup __RPC_FAR * This,
    /* [in] */ LPCWSTR pszPnpId);


void __RPC_STUB INetCfgInternalSetup_EnumeratedComponentUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_UpdateNonEnumeratedComponent_Proxy( 
    INetCfgInternalSetup __RPC_FAR * This,
    /* [in] */ INetCfgComponent __RPC_FAR *pIComp,
    /* [in] */ DWORD dwSetupFlags,
    /* [in] */ DWORD dwUpgradeFromBuildNo);


void __RPC_STUB INetCfgInternalSetup_UpdateNonEnumeratedComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgInternalSetup_EnumeratedComponentRemoved_Proxy( 
    INetCfgInternalSetup __RPC_FAR * This,
    /* [in] */ LPCWSTR pszPnpId);


void __RPC_STUB INetCfgInternalSetup_EnumeratedComponentRemoved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif     /* __INetCfgInternalSetup_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentPrivate_INTERFACE_DEFINED__
#define __INetCfgComponentPrivate_INTERFACE_DEFINED__

/* interface INetCfgComponentPrivate */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgComponentPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133273-4B20-11D1-AB01-00805FC1270E")
    INetCfgComponentPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryNotifyObject( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyUpperEdgeConfigChange( void) = 0;
        
    };
    
#else     /* C style interface */

    typedef struct INetCfgComponentPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INetCfgComponentPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INetCfgComponentPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INetCfgComponentPrivate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryNotifyObject )( 
            INetCfgComponentPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDirty )( 
            INetCfgComponentPrivate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyUpperEdgeConfigChange )( 
            INetCfgComponentPrivate __RPC_FAR * This);
        
        END_INTERFACE
    } INetCfgComponentPrivateVtbl;

    interface INetCfgComponentPrivate
    {
        CONST_VTBL struct INetCfgComponentPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentPrivate_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentPrivate_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentPrivate_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentPrivate_QueryNotifyObject(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryNotifyObject(This,riid,ppvObject)

#define INetCfgComponentPrivate_SetDirty(This)    \
    (This)->lpVtbl -> SetDirty(This)

#define INetCfgComponentPrivate_NotifyUpperEdgeConfigChange(This)    \
    (This)->lpVtbl -> NotifyUpperEdgeConfigChange(This)

#endif /* COBJMACROS */


#endif     /* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentPrivate_QueryNotifyObject_Proxy( 
    INetCfgComponentPrivate __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB INetCfgComponentPrivate_QueryNotifyObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPrivate_SetDirty_Proxy( 
    INetCfgComponentPrivate __RPC_FAR * This);


void __RPC_STUB INetCfgComponentPrivate_SetDirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPrivate_NotifyUpperEdgeConfigChange_Proxy( 
    INetCfgComponentPrivate __RPC_FAR * This);


void __RPC_STUB INetCfgComponentPrivate_NotifyUpperEdgeConfigChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif     /* __INetCfgComponentPrivate_INTERFACE_DEFINED__ */


#ifndef __INetInstallQueue_INTERFACE_DEFINED__
#define __INetInstallQueue_INTERFACE_DEFINED__

/* interface INetInstallQueue */
/* [unique][uuid][object] */ 

typedef 
enum tagNC_INSTALL_TYPE
    {    NCI_INSTALL    = 0,
    NCI_UPDATE    = NCI_INSTALL + 1,
    NCI_REMOVE    = NCI_UPDATE + 1
    }    NC_INSTALL_TYPE;

typedef struct NIQ_INFO
    {
    NC_INSTALL_TYPE eType;
    GUID ClassGuid;
    GUID InstanceGuid;
    DWORD dwCharacter;
    LPCWSTR pszPnpId;
    LPCWSTR pszInfId;
    DWORD dwDeipFlags;
    }    NIQ_INFO;


EXTERN_C const IID IID_INetInstallQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98133274-4B20-11D1-AB01-00805FC1270E")
    INetInstallQueue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ const NIQ_INFO __RPC_FAR *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessItems( void) = 0;
        
    };
    
#else     /* C style interface */

    typedef struct INetInstallQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INetInstallQueue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INetInstallQueue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INetInstallQueue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            INetInstallQueue __RPC_FAR * This,
            /* [in] */ const NIQ_INFO __RPC_FAR *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessItems )( 
            INetInstallQueue __RPC_FAR * This);
        
        END_INTERFACE
    } INetInstallQueueVtbl;

    interface INetInstallQueue
    {
        CONST_VTBL struct INetInstallQueueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetInstallQueue_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetInstallQueue_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define INetInstallQueue_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define INetInstallQueue_AddItem(This,pInfo)    \
    (This)->lpVtbl -> AddItem(This,pInfo)

#define INetInstallQueue_ProcessItems(This)    \
    (This)->lpVtbl -> ProcessItems(This)

#endif /* COBJMACROS */


#endif     /* C style interface */



HRESULT STDMETHODCALLTYPE INetInstallQueue_AddItem_Proxy( 
    INetInstallQueue __RPC_FAR * This,
    /* [in] */ const NIQ_INFO __RPC_FAR *pInfo);


void __RPC_STUB INetInstallQueue_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetInstallQueue_ProcessItems_Proxy( 
    INetInstallQueue __RPC_FAR * This);


void __RPC_STUB INetInstallQueue_ProcessItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif     /* __INetInstallQueue_INTERFACE_DEFINED__ */


#ifndef __INetCfgSpecialCase_INTERFACE_DEFINED__
#define __INetCfgSpecialCase_INTERFACE_DEFINED__

/* interface INetCfgSpecialCase */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgSpecialCase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE95-306E-11D1-AACF-00805FC1270E")
    INetCfgSpecialCase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAdapterOrder( 
            /* [out] */ DWORD __RPC_FAR *pcAdapters,
            /* [out] */ INetCfgComponent __RPC_FAR *__RPC_FAR *__RPC_FAR *papAdapters,
            /* [out] */ BOOL __RPC_FAR *pfWanAdaptersFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAdapterOrder( 
            /* [in] */ DWORD cAdapters,
            /* [in] */ INetCfgComponent __RPC_FAR *__RPC_FAR *apAdapters,
            /* [in] */ BOOL fWanAdaptersFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWanAdaptersFirst( 
            /* [out] */ BOOL __RPC_FAR *pfWanAdaptersFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWanAdaptersFirst( 
            /* [in] */ BOOL fWanAdaptersFirst) = 0;
        
    };
    
#else     /* C style interface */

    typedef struct INetCfgSpecialCaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INetCfgSpecialCase __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INetCfgSpecialCase __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INetCfgSpecialCase __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAdapterOrder )( 
            INetCfgSpecialCase __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcAdapters,
            /* [out] */ INetCfgComponent __RPC_FAR *__RPC_FAR *__RPC_FAR *papAdapters,
            /* [out] */ BOOL __RPC_FAR *pfWanAdaptersFirst);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAdapterOrder )( 
            INetCfgSpecialCase __RPC_FAR * This,
            /* [in] */ DWORD cAdapters,
            /* [in] */ INetCfgComponent __RPC_FAR *__RPC_FAR *apAdapters,
            /* [in] */ BOOL fWanAdaptersFirst);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWanAdaptersFirst )( 
            INetCfgSpecialCase __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfWanAdaptersFirst);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWanAdaptersFirst )( 
            INetCfgSpecialCase __RPC_FAR * This,
            /* [in] */ BOOL fWanAdaptersFirst);
        
        END_INTERFACE
    } INetCfgSpecialCaseVtbl;

    interface INetCfgSpecialCase
    {
        CONST_VTBL struct INetCfgSpecialCaseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgSpecialCase_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgSpecialCase_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define INetCfgSpecialCase_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define INetCfgSpecialCase_GetAdapterOrder(This,pcAdapters,papAdapters,pfWanAdaptersFirst)    \
    (This)->lpVtbl -> GetAdapterOrder(This,pcAdapters,papAdapters,pfWanAdaptersFirst)

#define INetCfgSpecialCase_SetAdapterOrder(This,cAdapters,apAdapters,fWanAdaptersFirst)    \
    (This)->lpVtbl -> SetAdapterOrder(This,cAdapters,apAdapters,fWanAdaptersFirst)

#define INetCfgSpecialCase_GetWanAdaptersFirst(This,pfWanAdaptersFirst)    \
    (This)->lpVtbl -> GetWanAdaptersFirst(This,pfWanAdaptersFirst)

#define INetCfgSpecialCase_SetWanAdaptersFirst(This,fWanAdaptersFirst)    \
    (This)->lpVtbl -> SetWanAdaptersFirst(This,fWanAdaptersFirst)

#endif /* COBJMACROS */


#endif     /* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_GetAdapterOrder_Proxy( 
    INetCfgSpecialCase __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcAdapters,
    /* [out] */ INetCfgComponent __RPC_FAR *__RPC_FAR *__RPC_FAR *papAdapters,
    /* [out] */ BOOL __RPC_FAR *pfWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_GetAdapterOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_SetAdapterOrder_Proxy( 
    INetCfgSpecialCase __RPC_FAR * This,
    /* [in] */ DWORD cAdapters,
    /* [in] */ INetCfgComponent __RPC_FAR *__RPC_FAR *apAdapters,
    /* [in] */ BOOL fWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_SetAdapterOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_GetWanAdaptersFirst_Proxy( 
    INetCfgSpecialCase __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_GetWanAdaptersFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSpecialCase_SetWanAdaptersFirst_Proxy( 
    INetCfgSpecialCase __RPC_FAR * This,
    /* [in] */ BOOL fWanAdaptersFirst);


void __RPC_STUB INetCfgSpecialCase_SetWanAdaptersFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif     /* __INetCfgSpecialCase_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\sahelper\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_)
#define AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#if !defined(_WIN64) && !defined (_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif
//#define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#include "sahelper.h"
#include "comdef.h"

#include <satrace.h>


#endif // !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\sahelper\helper.cpp ===
//check other expand files for special cases, checking for error conditions, etc.
    //if file not in this cab - modify SPFILEEXTRACTED
    //global bstr
    //replace LPWSTR by LPCWSTR wherever applicable
    //prevent use after deletion, de-allocation
    //check again for memory leaks, and use SAAlloc and SAFree everywhere...
    //remove UploadFile(), SATrace1()
    //resetup build env
    //check all exit paths
    //check network share acceptability
    //getwindows or system directory instead of L"C:\\"
    //backslashes at the ends of directory paths, and registry paths
    
    #include <stdafx.h>
    #include <winioctl.h>
    #include "helper.h"
    #include <getvalue.h>
    #include <wintrust.h>
    #include <softpub.h>
    #include <wincrypt.h>
    #include <appmgrobjs.h>
    #include <propertybagfactory.h>

//
// registry key for software update
//
const WCHAR SOFTWARE_UPDATE_KEY [] = L"SOFTWARE\\Microsoft\\ServerAppliance\\SoftwareUpdate\\";

//
// registry value name for upload directory
//
const WCHAR UPLOAD_FILE_DIRECTORY_VAL [] = L"UploadFileDirectory";

//
// default value of upload directory
//
const WCHAR DEFAULT_UPLOAD_DIRECTORY [] = L"Z:\\OS_DATA\\Software Update\\";

//
// information required for Digital Signature
//

//
// registry key for software update
//
const WCHAR SUBJECTS_KEY [] =  
            L"SOFTWARE\\Microsoft\\ServerAppliance\\Subjects";

//
// name of registry key value
//
const WCHAR SUBJECT_NAME [] = L"KeyName";

//
// Microsoft subject names
//
const WCHAR MICROSOFT_SUBJECT_NAME[] = L"Microsoft Corporation";

const WCHAR MICROSOFT_EUROPE_SUBJECT_NAME[] = L"Microsoft Corporation (Europe)";

//
// if the VER_SUITE_SERVERAPPLIANCE is not defined we will need to define it
// here
//
#ifndef VER_SUITE_SERVERAPPLIANCE
    #define VER_SUITE_SERVERAPPLIANCE        0x00000400
#endif

//
// password categories
//
enum {STRONG_PWD_UPPER=0, 
      STRONG_PWD_LOWER, 
      STRONG_PWD_NUM, 
      STRONG_PWD_PUNC};

//
// useful definitions used in GenerateRandomPassword method
//
#define STRONG_PWD_CATS (STRONG_PWD_PUNC + 1)
#define NUM_LETTERS 26
#define NUM_NUMBERS 10
#define MIN_PWD_LEN 8


    //++--------------------------------------------------------------
    //
    //  Function:   UploadFile
    //
    //  Synopsis:   This is the ISAHelper interface method  used to
    //              copy files from a source to a destination
    //
    //  Arguments:  
    //              [in]    BSTR -  Source File
    //              [out]   BSTR -  Destination File
    //
    //  Returns:    HRESULT - success/failure
    //
    //  History:    mitulk      Created     5/26/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    STDMETHODIMP
    CHelper::UploadFile (
                /*[in]*/           BSTR        bstrSrcFile,
                /*[in]*/           BSTR        bstrDestFile
                )
    {
        return (E_NOTIMPL);

    }   //  end of CHelper::UploadFile method
    
    //++--------------------------------------------------------------
    //
    //  Function:   GetRegistryValue
    //
    //  Synopsis:   This is the ISAHelper interface method used to
    //              get a value from the HKEY_LOCAL_MACHINE registry
    //              hive
    //
    //  Arguments:  
    //              [in]    BSTR -      Object Path    
    //              [in]    BSTR -      Value Name
    //              [out]   VARIANT* -  Value to be returned    
    //              [in]    UINT     -  expected value type   
    //
    //  Returns:    HRESULT - success/failure
    //
    //  History:    MKarki  Created     6/04/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    STDMETHODIMP 
    CHelper::GetRegistryValue (
                    /*[in]*/    BSTR        bstrObjectPathName,
                    /*[in]*/    BSTR        bstrValueName,
                    /*[out]*/   VARIANT*    pValue,
                    /*[in]*/    UINT        ulExpectedType
                    ) 
    {
        CSATraceFunc objTraceFunc ("CHelper::GetRegistryValue");
    
        _ASSERT (bstrObjectPathName && bstrValueName && pValue);
    
        SATracePrintf (
            "Helper COM object getting reg value for path:'%ws' "
            "value name:'%ws'",
            bstrObjectPathName,
            bstrValueName
            );
    
        HRESULT hr = S_OK;
        try
        {
            do  
            {
                //
                // check to see that valid parameters have been passed in
                //
                if (
                    (NULL == bstrObjectPathName) ||
                    (NULL == bstrValueName) ||
                    (NULL == pValue)
                    )
                {
                    SATraceString (
                        "ISAHelper::GetRegistryValue called with invalid params"
                        );
                    hr = E_INVALIDARG;
                    break;
                }
    
                //
                // call the sacommon.lib method to get the value
                //
                BOOL bRetVal = ::GetObjectValue (
                                    bstrObjectPathName,
                                    bstrValueName,
                                    pValue,
                                    ulExpectedType
                                    );
                if (!bRetVal)
                {
                    SATraceString (
                       "ISAHelper::GetRegistryValue called failed on GetValue call"
                       );
                    hr = E_FAIL;
                    break;
                }
            }
            while (FALSE);
        }
        catch (...)
        {
            SATraceString (
                "ISAHelper::GetRegistryValue encountered unknown exception"
                );
            hr = E_FAIL;
        }
    
        return (hr);
    
    }   //  end of CHelper::GetRegistryValue method
    
    //++--------------------------------------------------------------
    //
    //  Function:   SetRegistryValue
    //
    //  Synopsis:   This is the ISAHelper interface method used to
    //              set a value in the HKEY_LOCAL_MACHINE registry
    //              hive
    //
    //  Arguments:  
    //              [in]    BSTR -      Object Path    
    //              [in]    BSTR -      Value Name
    //              [in]    VARIANT* -   Value to be set
    //
    //  Returns:    HRESULT - success/failure
    //
    //  History:    MKarki  Created     6/04/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    STDMETHODIMP 
    CHelper::SetRegistryValue (
                            /*[in]*/    BSTR        bstrObjectPathName,
                            /*[in]*/    BSTR        bstrValueName,
                            /*[out]*/   VARIANT*    pValue
                            )
    {
    
        _ASSERT (bstrObjectPathName && bstrValueName && pValue);
    
        SATracePrintf (
            "Helper COM object getting reg value for path:'%ws' "
            "value name:'%ws'",
            bstrObjectPathName,
            bstrValueName
            );
    
        HRESULT hr = S_OK;
        try
        {
            do  
            {
                //
                // check to see that valid parameters have been passed
                // in
                if (
                    (NULL == bstrObjectPathName) ||
                    (NULL == bstrValueName) ||
                    (NULL == pValue)
                    )
                {
                    SATraceString (
                        "ISAHelper::SetRegistryValue called with invalid params"
                        );
                    hr = E_INVALIDARG;
                    break;
                }
    
                //
                // call the sacommon.lib method to get the value
                //
                BOOL bRetVal = ::SetObjectValue (
                                    bstrObjectPathName,
                                    bstrValueName,
                                    pValue
                                    );
                if (!bRetVal)
                {
                    SATraceString (
                       "ISAHelper::SetRegistryValue called failed on GeValue call"
                       );
                    hr = E_FAIL;
                    break;
                }
            }
            while (FALSE);
        }
        catch (...)
        {
            
            SATraceString (
                "ISAHelper::SetRegistryValue encountered unknown exception"
                );
            hr = E_FAIL;
        }
    
        return (hr);
    
    }   //  end of CHelper::SetRegistryValue method
    
    //++--------------------------------------------------------------
    //
    //  Function:    GetFileSectionKeyValue
    //
    //  Synopsis:   This is the ISAHelper interface method used to
    //              get the value from a specified key in a 
    //                specified section in a specified .INF file
    //
    //  Arguments:  
    //              [in]    BSTR -        Name of .INF File
    //              [in]    BSTR -        Name of Section in .INF File
    //              [in]    BSTR -        Name of Key in Section
    //              [out]    BSTR -        String Value of Key, should be a NULL pointer
    //
    //  Returns:    HRESULT - success/failure
    //
    //  History:    mitulk  Created     6/08/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    STDMETHODIMP
    CHelper::GetFileSectionKeyValue (
                                    /*[in]*/    BSTR bstrFileName, 
                                    /*[in]*/    BSTR bstrSectionName, 
                                    /*[in]*/    BSTR bstrKeyName, 
                                    /*[out]*/    BSTR *pbstrKeyValue
                                    )
    {
        HRESULT hr = S_OK;
    
        _ASSERT (bstrFileName && bstrSectionName && bstrKeyName && pbstrKeyValue);
    
        SATraceString ("Helper COM object called to get file section key...");
    
        try
        {
            do
            {
                //
                // check to see that valid parameters have been passed in
                //
                if (
                    (NULL == bstrFileName)    ||
                    (NULL == bstrSectionName)    ||
                    (NULL == bstrKeyName)    ||
                    (NULL == pbstrKeyValue)
                    )
                {
                    SATraceString (
                        "ISAHelper::GetFileSectionKeyValue called with invalid params"
                        );
                    hr = E_INVALIDARG;
                    break;
                }
        
                //
                // open the .INF file 
                //
                HINF hinf1 = NULL;
                
                //
                // Changed to use new Win95/NT file format. Needed to
                // do this to properly support [Strings] sections for 
                // localization changes. JKountz May 22, 2000
                hinf1 = SetupOpenInfFile (
                                        LPWSTR(bstrFileName),
                                        NULL,                            //optional
                                        INF_STYLE_WIN4,                //INF File Style
                                        NULL                            //optional
                                        );
                if (    
                    (NULL == hinf1)    ||    
                    (INVALID_HANDLE_VALUE == hinf1)    
                    )
                {
                    SATraceString(LPSTR(bstrFileName));
                    SATraceFailure (
                            "ISAHelper::GetFileSectionKeyValue call failed on SetupOpenInfFile",
                            GetLastError ()
                            );
                    hr = E_FAIL;
                    break;
                }
    
                //
                //get the line for the given key
                //
    
                INFCONTEXT infcontext1;
    
                BOOL bRetVal1 = FALSE;
                bRetVal1 = SetupFindFirstLine(
                                            hinf1,
                                            (LPWSTR)bstrSectionName,
                                            (LPWSTR)bstrKeyName,
                                            &infcontext1
                                            );
                if (FALSE == bRetVal1)
                {
                    SATraceFailure (
                            "ISAHelper::GetFileSectionKeyValue call failed on SetupFindFirstLine",
                            GetLastError ()
                            );
                    hr = E_FAIL;
                    break;
                }
    
    //
    // as COM clients like VB and ASP scripts can not take BSTR as an out
    // parameter this out paramter has to be BSTR*, as a result memory
    // needs to be allocated here for the BSTR to be returned
    //
    #if 0
                //
                //from this line get the required string value
                //
    
                DWORD dwRequiredSize = 0;
    
                BOOL bRetVal2 = FALSE;
                bRetVal2 = SetupGetStringField(
                                            &infcontext1,
                                            DWORD(1),                        //field index
                                            NULL,                            //which is NULL
                                            DWORD(0),                        //which is zero
                                                                            //when specified thus, required size will be passed back
                                            &dwRequiredSize
                                            );
                if (FALSE == bRetVal2)
                {
                    SATraceFailure (
                            "ISAHelper::GetFileSectionKeyValue call failed on SetupGetStringField",
                            GetLastError ()
                            );
                    hr = E_FAIL;
                    break;
                }
    
                if (dwRequiredSize > (DWORD)wcslen((LPWSTR)bstrKeyValue))
                {
                    SATraceFailure (
                            "ISAHelper::GetFileSectionKeyValue call on SetupGetStringField required larger buffer than provided",
                            GetLastError ()
                            );
                    hr = E_FAIL;
                    break;
                }
    #endif
    
            
                WCHAR wszKeyValue [MAX_PATH];
                DWORD dwRequiredSize = MAX_PATH;
    
                BOOL bRetVal3 = FALSE;
                bRetVal3 = SetupGetStringField(
                                            &infcontext1,
                                            DWORD(1),                        //field index
                                            (LPWSTR)wszKeyValue,
                                            dwRequiredSize,                    //passed by value
                                            &dwRequiredSize                    //passed by reference
                                            );
                if (FALSE == bRetVal3)
                {
                    SATraceFailure (
                            "ISAHelper::GetFileSectionKeyValue call failed on SetupGetStringField",
                            GetLastError ()
                            );
                    hr = E_FAIL;
                    break;
                }
    
    
                //
                // now allocate out buffer to put this value into
                //
                *pbstrKeyValue = ::SysAllocString (wszKeyValue);
                if (NULL == *pbstrKeyValue)
                {
                    SATraceString (
                        "Helper COM object failed in GetFileSectionKeyValue to "
                        "allocate dynamic memory"
                        );
                    hr = E_FAIL;
                    break;
                }
    
                //
                // close the .INF file 
                //
                _ASSERT(hinf1);
                SetupCloseInfFile (
                                hinf1
                                );
    
            }
            while (FALSE);
        }
        catch (...)
        {
            SATraceString (
                "ISAHelper::GetFileSectionKeyValue encountered unknown exception"
                );
            hr = E_FAIL;
        }
    
        return (hr);
    
    }   //  end of CHelper::GetFileSectionKeyValue method
    
    //++--------------------------------------------------------------
    //
    //  Function:    VerifyDiskSpace
    //
    //  Synopsis:   This is the ISAHelper interface method used to
    //              verify if there is enough space on disk for 
    //                EXTRACTION of the CAB file
    //
    //  Arguments:  NONE
    //
    //  Returns:    HRESULT - success/failure
    //
    //  History:    mitulk  Created     6/08/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    STDMETHODIMP 
    CHelper::VerifyDiskSpace(
                            )
    {
        return E_NOTIMPL;
#if 0
        HRESULT hr = E_FAIL;
    
        SATraceString ("Helper COM object called to verify disk space");
    
        try
        {
            do
            {
                WCHAR   wszDestFilePath[MAX_PATH]; 
                CComVariant vtDestFilePath;
                //
                // get the path of the upload file directory
                // 
                bool bRegValue = ::GetObjectValue (
                                    SOFTWARE_UPDATE_KEY,
                                    UPLOAD_FILE_DIRECTORY_VAL,
                                    &vtDestFilePath,
                                    VT_BSTR
                                    );
                if (!bRegValue)
                {
                    SATraceString (
                        "Helper COM Object did not find upload file dir in registry"
                        );
                    ::wcscpy (wszDestFilePath, DEFAULT_UPLOAD_DIRECTORY);
                }
                else
                {
                    ::wcscpy (wszDestFilePath, V_BSTR (&vtDestFilePath));
                }

SATraceString(LPSTR(wszDestFilePath));
                
                if (*(wszDestFilePath + ::wcslen(wszDestFilePath) -1) != L'\\')
                {
                    ::wcscat (wszDestFilePath, L"\\");
                }

SATraceString(LPSTR(wszDestFilePath));

                ULARGE_INTEGER uliAvail_Bytes;
                ULARGE_INTEGER uliNeeded_Bytes;
                ULARGE_INTEGER uliTotal_Bytes;
    
                //
                //intialize longlong member of ULARGE_INTEGER structure 
                //
                uliAvail_Bytes.QuadPart = 0;
                uliNeeded_Bytes.QuadPart = 0;
                uliTotal_Bytes.QuadPart = 0;
    
                //
                // construct full path of the info.inf file
                //
                WCHAR wszInfoFilePath [MAX_PATH];
                ::wcscpy (wszInfoFilePath, wszDestFilePath);
                ::wcscat (wszInfoFilePath, L"info.inf");

SATraceString(LPSTR(wszDestFilePath));
SATraceString((LPSTR)wszInfoFilePath);

                BSTR bstrKeyValue;
                //
                //read the disk space key from Info.inf
                //
                HRESULT hr1 = E_FAIL;
                hr1 = GetFileSectionKeyValue(
                                        wszInfoFilePath,
                                        L"Info",
                                        L"DiskSpace",
                                        &bstrKeyValue
                                        );
    
                if (S_OK != hr1)
                {
                    SATraceFailure (
                            "ISAHelper::VerifyDiskSpace call failed on GetFileSectionKeyValue",
                            GetLastError ()
                            );
                    break;
                }
    
                //
                //convert to longlong
                //
                uliNeeded_Bytes.QuadPart = _wtoi64(bstrKeyValue);
    
                //
                // free the bstr now
                //
                ::SysFreeString (bstrKeyValue);
    
                BOOL bRetVal = FALSE;
                bRetVal = GetDiskFreeSpaceEx(
                                            wszDestFilePath,
                                            &uliAvail_Bytes, 
                                            &uliTotal_Bytes, 
                                            NULL
                                            ); 
                if (FALSE == bRetVal)
                {
                    SATraceFailure (
                            "ISAHelper::VerifyDiskSpace call failed on GetDiskFreeSpaceEx",
                            GetLastError ()
                            );
                    break;
                }
                
                if (uliAvail_Bytes.QuadPart < uliNeeded_Bytes.QuadPart) 
                {
                    SATraceFailure (
                            "ISAHelper::VerifyDiskSpace call determined lack of space",
                            GetLastError ()
                            );
                  //better return value for hr?
                    break;
                }
                else
                {
                    hr = S_OK;
                }
    
            }
            while (FALSE);
        }
        catch (...)
        {
            SATraceString (
                "ISAHelper::VerifyDiskSpace encountered unknown exception"
                );
            hr = E_FAIL;
        }
    
        return (hr);
#endif
    
    }   //  end of CHelper::VerifyDiskSpace method
    
    //++--------------------------------------------------------------
    //
    //  Function:    VerifyInstallSpace
    //
    //  Synopsis:   This is the ISAHelper interface method used to
    //              verify if there is enough space on disk for 
    //                INSTALLATION of the CAB file
    //
    //  Arguments:  NONE
    //
    //  Returns:    HRESULT - success/failure
    //
    //  History:    mitulk  Created     6/08/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    STDMETHODIMP 
    CHelper::VerifyInstallSpace(
                            )
    {
        return E_NOTIMPL;
#if 0
        HRESULT hr = E_FAIL;
    
        SATraceString ("Helper COM object called to verify install space");
    
        try
        {
            do
            {
                WCHAR   wszDestFilePath[MAX_PATH]; 
                CComVariant vtDestFilePath;
                //
                // get the path of the upload file directory
                // 
                bool bRegValue = ::GetObjectValue (
                                    SOFTWARE_UPDATE_KEY,
                                    UPLOAD_FILE_DIRECTORY_VAL,
                                    &vtDestFilePath,
                                    VT_BSTR
                                    );
                if (!bRegValue)
                {
                    SATraceString (
                        "Helper COM Object did not find upload file dir in registry"
                        );
                    ::wcscpy (wszDestFilePath, DEFAULT_UPLOAD_DIRECTORY);
                }
                else
                {
                    ::wcscpy (wszDestFilePath, V_BSTR (&vtDestFilePath));
                }

SATraceString(LPSTR(wszDestFilePath));

                if (*(wszDestFilePath + ::wcslen(wszDestFilePath) -1) != L'\\')
                {
                    ::wcscat (wszDestFilePath, L"\\");
                }

SATraceString(LPSTR(wszDestFilePath));

                ULARGE_INTEGER uliAvail_Bytes;
                ULARGE_INTEGER uliNeeded_Bytes;
                ULARGE_INTEGER uliTotal_Bytes;
    
                //
                //intialize longlong member of ULARGE_INTEGER structure 
                //
                uliAvail_Bytes.QuadPart = 0;
                uliNeeded_Bytes.QuadPart = 0;
                uliTotal_Bytes.QuadPart = 0;
    
                //
                // construct full path of the info.inf file
                //
                WCHAR wszInfoFilePath [MAX_PATH];
                ::wcscpy (wszInfoFilePath, wszDestFilePath);
                ::wcscat (wszInfoFilePath, L"INFO.INF");

SATraceString(LPSTR(wszDestFilePath));
SATraceString((LPSTR)wszInfoFilePath);

                BSTR bstrKeyValue;
                //
                //read the disk space key from Info.inf
                //
                HRESULT hr1 = E_FAIL;
                hr1 = GetFileSectionKeyValue(
                                        wszInfoFilePath,
                                        L"Info",
                                        L"InstallSpace",
                                        &bstrKeyValue
                                        );
    
                if (S_OK != hr1)
                {
                    SATraceFailure (
                            "ISAHelper::VerifyInstallSpace call failed on GetFileSectionKeyValue",
                            GetLastError ()
                            );
                    break;
                }
    
                //
                //convert to longlong
                //
                uliNeeded_Bytes.QuadPart = _wtoi64(bstrKeyValue);
    
                //
                // free the bstr now
                //
                ::SysFreeString (bstrKeyValue);
    
                WCHAR wszSystemDir [MAX_PATH];
                //
                // get the system directory
                //
                DWORD   dwRetVal = ::GetSystemDirectory (
                                        wszSystemDir,
                                        MAX_PATH
                                        );
                if (0 == dwRetVal)
                {
                    SATraceFailure (
                            "ISAHelper::VerifyInstallSpace call failed on GetSystemDirectory",
                        GetLastError ()
                        );
                    break;
                }
            
                if (*(wszSystemDir + ::wcslen(wszSystemDir) -1) != L'\\')
                {
                    ::wcscat (wszSystemDir, L"\\");
                }

                //
                // got the first "\" in the system directory name
                //
                PWCHAR pwszDirPath = ::wcschr (wszSystemDir, '\\');
    
                _ASSERT (pwszDirPath);
    
                //
                // before the first "\" is the system drive letter
                //
                *pwszDirPath = '\0';
    
                BOOL bRetVal = FALSE;
                bRetVal = GetDiskFreeSpaceEx(
                                              wszSystemDir,
                                            &uliAvail_Bytes, 
                                            &uliTotal_Bytes, 
                                            NULL
                                            ); 
                if (FALSE == bRetVal)
                {
                    SATraceFailure (
                            "ISAHelper::VerifyInstallSpace call failed on GetDiskFreeSpaceEx",
                            GetLastError ()
                            );
                    break;
                }
                
                if (uliAvail_Bytes.QuadPart < uliNeeded_Bytes.QuadPart) 
                {
                    SATraceFailure (
                            "ISAHelper::VerifyInstallSpace call determined lack of space",
                            GetLastError ()
                            );
                    //better return value for hr?
                    break;
                }
                else
                {
                    hr = S_OK;
                }
    
            }
            while (FALSE);
        }
        catch (...)
        {
            SATraceString (
                "ISAHelper::VerifyInstallSpace encountered unknown exception"
                );
            hr = E_FAIL;
        }
    
        return (hr);
#endif    
    }   //  end of CHelper::VerifyInstallSpace method
    
    BSTR g_bstrDestDir;
     
    //++--------------------------------------------------------------
    //
    //  Function:   ExpandFilesCallBackFunction
    //
    //  Synopsis:   This is a callback function used by ExpandFiles
    //
    //  Arguments:  
    //              [in]    PVOID        -    Extract File Context
    //                                        used between ExpandFiles() and this callback
    //              [in]    UINT        -    Notification Message
    //                                        value specified by SetupIterateCabinet
    //              [in]    UINT        -    Parameter 1
    //                                        value specified by SetupIterateCabinet
    //              [in]    UINT        -    Parameter 1
    //                                        value specified by SetupIterateCabinet
    //
    //  Returns:    UINT    -    error code
    //
    //  History:    mitulk      Created     5/26/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    
    UINT __stdcall CHelper::ExpandFilesCallBackFunction( 
                                               /*[in]*/            PVOID pvExtractFileContext, 
                                               /*[in]*/            UINT uinotifn, 
                                               /*[in]*/            UINT uiparam1, 
                                               /*[in]*/            UINT uiparam2 )
    {
        switch(
            uinotifn
            )
        {
    
        case SPFILENOTIFY_FILEEXTRACTED:
    
          if (MYDEBUG) SATraceString(
              "SPFILENOTIFY_FILEEXTRACTED"
                );
    
            return(NO_ERROR); //No error was encountered, continue processing the cabinet
    
            break;
    
        case SPFILENOTIFY_FILEINCABINET:
    
          if (MYDEBUG) SATraceString(
              "SPFILENOTIFY_FILEINCABINET"
                );
    
            //Param1 = (UINT) address of FILE_IN_CABINET_INFO structure
            //Param2 = (UINT) pointer to null-terminated string containing .CAB file name
    
            if (NULL == pvExtractFileContext) //all files to extract
            {
                PFILE_IN_CABINET_INFO pficinfo = (PFILE_IN_CABINET_INFO)uiparam1;
    
              if (MYDEBUG) SATracePrintf ("%ws",
                  pficinfo->NameInCabinet
                    );
    
                wcscpy(
                    (LPWSTR)pficinfo->FullTargetName,
                    g_bstrDestDir
                    );
                wcscat(        
                    (LPWSTR)pficinfo->FullTargetName,    
                    L"\\"
                    );
                wcscat(        
                    (LPWSTR)pficinfo->FullTargetName,    
                    (LPWSTR)pficinfo->NameInCabinet
                    );
    
              if (MYDEBUG) SATracePrintf ("%ws", g_bstrDestDir);
              if (MYDEBUG) SATracePrintf("%ws", (PWSTR)pficinfo->FullTargetName );
    
                return (FILEOP_DOIT); //full target path provided as needed
            }
    
            else //(NULL != pvExtractFileContext) //file specified
            {
                PFILE_IN_CABINET_INFO pficinfo = (PFILE_IN_CABINET_INFO)uiparam1;
    
              if (MYDEBUG) SATracePrintf ("%ws",pficinfo->NameInCabinet);
    
                if (
                    _wcsicmp(    
                        (LPWSTR)pficinfo->NameInCabinet,    
                        (LPWSTR)pvExtractFileContext
                        )
                        ==0)
                {
                    wcscpy(        
                        (LPWSTR)pficinfo->FullTargetName,    
                        g_bstrDestDir
                        );
                      wcscat(        
                        (LPWSTR)pficinfo->FullTargetName,    
                        L"\\"
                        );
                    wcscat(        
                        (LPWSTR)pficinfo->FullTargetName,    
                        (LPWSTR)pficinfo->NameInCabinet
                        );
    
                  if (MYDEBUG) SATracePrintf ("%ws", g_bstrDestDir);
                   if (MYDEBUG) SATracePrintf ("%ws", pficinfo->FullTargetName );
    
                    return (FILEOP_DOIT); //full target path provided as needed
                }
                else
                    return (FILEOP_SKIP);
            }
    
            break;
    
        case SPFILENOTIFY_NEEDNEWCABINET:
    
            //only one cabinet file - to be extended for possibility
          if (MYDEBUG) SATraceString(
              "SPFILENOTIFY_NEEDNEWCABINET"
                );
    
            return(ERROR_FILE_NOT_FOUND); 
            //An error of the specified type occurred. 
            //The SetupIterateCabinet function will return FALSE,
            //and the specified error code will be returned by a call to GetLastError. 
            break;
    
        case SPFILENOTIFY_CABINETINFO:
    
          if (MYDEBUG) SATraceString(
              "SPFILENOTIFY_CABINETINFO"
                );
            return(ERROR_SUCCESS);
    
            break;
    
        default:
    
          //if (MYDEBUG) SATraceInt(uinotifn);
          if (MYDEBUG) SATraceString(
              "Unexpected Notification from ExpandFiles"
                );
            return(1);
    
            break;
    
        }
    }
    
    //++--------------------------------------------------------------
    //
    //  Function:   ExpandFiles
    //
    //  Synopsis:   This is the ISAHelper interface method  used to
    //              extract files from a .CAB file
    //
    //  Arguments:  
    //              [in]    BSTR        -    .CAB file name
    //                                        path must be fully qualified
    //              [in]    BSTR        -    expansion destination DIRECTORY
    //                                        path must be fully qualified
    //              [in]    BSTR        -    name of file to extract
    //                                        NULL to extract all files
    //
    //  Returns:    HRESULT - success/failure
    //
    //  History:    mitulk      Created     5/26/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    STDMETHODIMP
    CHelper::ExpandFiles(
                     /*[in]*/        BSTR bstrCabFileName, 
                     /*[in]*/        BSTR bstrDestDir, 
                     /*[in]*/        BSTR bstrExtractFile
                     )
    {

        SATraceFunction("CHelper::ExpandFiles");
        try {
            
            SATracePrintf (
                "Helper COM object called to expand file:%ws",
                bstrCabFileName
                );
        
            DWORD dwReserved(0);
    
              if (bstrExtractFile) SATracePrintf ("%ws",bstrExtractFile);
    
            PVOID pvExtractFileContext = bstrExtractFile; //pointer assignment intended
    
            g_bstrDestDir = bstrDestDir; //pointer assignment intended
    
            PSP_FILE_CALLBACK pExpandFilesCallBackFunction = &ExpandFilesCallBackFunction;
    
            BOOL bRetVal = SetupIterateCabinet(
                        (LPWSTR)bstrCabFileName, 
                        dwReserved, 
                        pExpandFilesCallBackFunction, 
                        pvExtractFileContext
                        );
    
            if (FALSE == bRetVal) 
            {
                  SATraceFailure("Expansion failed on the Cabinet File", 
                                    GetLastError()
                                    );
                return (E_FAIL);
            }
            else 
            {
                SATraceString("ExpandFiles completed successfully");
                return (S_OK);
            }
        }
        catch(_com_error& err){
            SATracePrintf( "Encountered Exception: %x", err.Error());
            return (err.Error());
        }
        catch(...){
            SATraceString("Unexpected Exception");
            return (E_FAIL);
        }
    }
    
    //++--------------------------------------------------------------
    //
    //  Function:   IsBootPartitionReady
    //
    //  Synopsis:   This is the ISAHelper interface method which
    //              verifies that the Boot Partition is ready for
    //              Software Update i.e it should note be in a 
    //              mirror initializing state
    //
    //  Arguments:  none
    //
    //  Returns:    HRESULT 
    //                      S_OK -    yes, primary OS
    //                      S_FALSE - no alternate OS
    //                      else - failure
    //
    //  History:    MKarki  Created     6/11/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    STDMETHODIMP 
    CHelper::IsBootPartitionReady (
                VOID 
                )
    {
        SATraceString ("Helper COM object called to deterime if primary OS...");
    
    return S_OK;

    /***
    ** OBSOLETE JKountz May 22, 2000 Per Mukesh this function
    ** is no longer needed. Allways return success
    **
        HRESULT hr = E_FAIL;
        try
        {
            do
            {
                WCHAR wszSystemDir [MAX_PATH];
                //
                // get the system directory
                //
                DWORD   dwRetVal = ::GetSystemDirectory (
                                        wszSystemDir,
                                        MAX_PATH
                                        );
                if (0 == dwRetVal)
                {
                    SATraceFailure (
                        "Software Helper failed to get system directory",
                        GetLastError ()
                        );
                    break;
                }
            
                //
                // got the first "\" in the system directory name
                //
                PWCHAR pwszDirPath = ::wcschr (wszSystemDir, '\\');
    
                _ASSERT (pwszDirPath);
    
                //
                // before the first "\" is the system drive letter
                //
                *pwszDirPath = '\0';
    
                WCHAR wszDeviceName[MAX_PATH];
                //
                // get the device name for the current OS
                //
                dwRetVal = ::QueryDosDevice (
                                    wszSystemDir,
                                    wszDeviceName,
                                    MAX_PATH
                                    );
                if (0 == dwRetVal)
                {
                    SATraceFailure (
                        "Software Update Helper failed to obtain disk and partition info",
                        GetLastError ()
                        );
                    break;
                }
    
                //
                // break this information into Disk and Partition
                //
    
                //
                // second last character is partition number
                //
                PWCHAR pwszPartitionStart =
                         wszDeviceName + wcslen(wszDeviceName) -1;
            
                while (::isdigit(*pwszPartitionStart)) 
                {
                    _ASSERT (wszDeviceName < pwszPartitionStart);
                    --pwszPartitionStart;
                }
    
                ++pwszPartitionStart;
    
                _ASSERT (*pwszPartitionStart != '\0');
    
                //
                // get the partition number now
                //
                DWORD dwSrcPartitionId = ::wcstol (pwszPartitionStart, NULL, 10);
    
                //
                // got the last "\" in the string
                //
                PWCHAR pwszDiskStart = wcsrchr (wszDeviceName, '\\');
    
                _ASSERT (pwszDiskStart);
    
                *pwszDiskStart = '\0';
    
                _ASSERT (wszDeviceName < pwszDiskStart);
    
                --pwszDiskStart;
    
                while (::isdigit(*pwszDiskStart)) 
                {
                    _ASSERT (wszDeviceName < pwszDiskStart);
                    --pwszDiskStart;
                }
    
                ++pwszDiskStart;
    
                _ASSERT (*pwszDiskStart != '\0');
    
                //
                // get the disk number now
                //
                DWORD dwSrcDiskId = ::wcstol (pwszDiskStart, NULL, 10);
    
                DWORD dwDestDiskId = 0;
                DWORD dwDestPartitionId = 0;
                //
                // check if there is mirroring between the primary and mirror
                // drive
                //
                bool bRetVal = ::GetShadowPartition (
                                            dwSrcDiskId,
                                            dwSrcPartitionId,
                                            dwDestDiskId,
                                            dwDestPartitionId
                                            );
                if (bRetVal)
                {
                    //
                    // we actually have a valid mirror
                    //
            
                    MIRROR_STATUS eStatus;
                    //
                    // get the status of this mirror set
                    //
                    bRetVal = ::StatusMirrorSet (
                                    dwSrcDiskId,
                                    dwSrcPartitionId,
                                    dwDestDiskId,
                                    dwDestPartitionId,
                                    eStatus
                                    );
                    if (!bRetVal)
                    {
                        SATraceString (
                            "Software Update Helper failed to get staus of mirror set"
                            );
                        break;
                    }
    
                    //
                    // if mirror set is healthy then software update can proceed
                    // else not
                    //
                    hr = (MIRROR_STATUS_HEALTHY == eStatus) ? S_OK : S_FALSE;
                }
                else
                {       
                    //
                    // not having a mirror set is OK
                    //
                    hr = S_OK;
                }
            }
            while (false);
        }
        catch (...)
        {
            SATraceString (
                "Software Update  Helper  caught exception while checking boot "
                "partition"
                );
        }
    
        return (hr);
    **
    ****/
        
    }   //  end of CHelper::IsBootPartitionReady method
    
    //++--------------------------------------------------------------
    //
    //  Function:   IsPrimaryOS
    //
    //  Synopsis:   This is the ISAHelper interface method which
    //              checks if this the primary OS
    //
    //  Arguments:  none
    //
    //  Returns:    HRESULT 
    //                      S_OK -    yes, primary OS
    //                      S_FALSE - no alternate OS
    //                      else - failure
    //
    //  History:    MKarki  Created     6/11/99
    //
    //  Called By:  Automation Clients
    //
    //----------------------------------------------------------------
    HRESULT
    CHelper::IsPrimaryOS (
        VOID
        )
    {
        return (E_FAIL);
    
    }   //  end of CHelper::IsPrimaryOS method

    //++--------------------------------------------------------------
    //
    //  Function:   VerifySignature
    //
    //  Synopsis:   This is the ISAHelper interface method used to 
    //                verify the signature of a Cabinet file
    //
    //  Arguments:  [in]    BSTR -    Cabinet File
    //
    //  Returns:    HRESULT - success/failure
    //                currently returns E_NOTIMPL
    //
    //  History:    mitulk      Created     5/26/99
    //
    //  Called By: 
    //
    //----------------------------------------------------------------
    
    STDMETHODIMP 
    CHelper::VerifySignature (
                            /*[in]*/        BSTR        bstrFilePath
                            )
    {
        _ASSERT (bstrFilePath);
        
       if (NULL == bstrFilePath)
       {
            SATraceString ("CheckTrust provided invalid file path");
            return (E_INVALIDARG);
       }

        SATracePrintf (
                "Verifying Signature in file:'%ws'...",
                bstrFilePath
                );

        HRESULT hr = E_FAIL;
        try
        {
            //
            // verify the validity of the certificate
            //
            hr = ValidateCertificate (bstrFilePath);
            if (SUCCEEDED (hr))
            {
                //
                // verify that the owner of the certificate
                //
                hr = ValidateCertOwner (bstrFilePath);
            }
        }
        catch (...)
        {
            SATraceString (
                "ISAHelper::VerifySignature encountered unknown exception"
                );
            hr = E_FAIL;
        }
                 
        return (hr);
    
    }   //  end of CHelper::VerifySignature method

    //++--------------------------------------------------------------
    //
    //  Function:   ValidateCertificate
    //
    //  Synopsis:   This is the CHelper private method which
    //              is used to verify the digital signature on a
    //              file 
    //
    //  Arguments:  [in]    BSTR    -  full file path 
    //
    //  Returns:    HRESULT 
    //
    //  History:    MKarki  Created     10/01/99
    //
    //  Called By:  CHelper::VerifySignature public method
    //
    //----------------------------------------------------------------
    HRESULT 
    CHelper::ValidateCertificate (
        /*[in]*/    BSTR    bstrFilePath
        )
    {
        HINSTANCE hInst = NULL;
        HRESULT hr = E_FAIL;

        SATraceString ("Validating Certificate....");

        WINTRUST_DATA       winData;
        WINTRUST_FILE_INFO  winFile;
        GUID                guidAction = WINTRUST_ACTION_GENERIC_VERIFY_V2;   

        //
        // set up the information to call the API
        //
        winFile.cbStruct       = sizeof(WINTRUST_FILE_INFO);
        winFile.hFile          = INVALID_HANDLE_VALUE;
        winFile.pcwszFilePath  = bstrFilePath;
        winFile.pgKnownSubject = NULL;

        winData.cbStruct            = sizeof(WINTRUST_DATA);
        winData.pPolicyCallbackData = NULL;
        winData.pSIPClientData      = NULL;
        winData.dwUIChoice          = WTD_UI_NONE;  //no UI this is for SA
        winData.fdwRevocationChecks = 0;
        winData.dwUnionChoice       = 1;
        winData.dwStateAction       = 0;
        winData.hWVTStateData       = 0;
        winData.dwProvFlags         = 0x00000010;
        winData.pFile               = &winFile;

        hr =  WinVerifyTrust((HWND)0, &guidAction, &winData);
        if (FAILED (hr)) 
        {
            SATracePrintf (
                  "Unable to verify digital signature on file:'%ws', reason:%x",
                  bstrFilePath,
                  hr
                  );
        }
                  
        return (hr);

    }   //  end of CHelper::ValidateCertificate method

    //++--------------------------------------------------------------
    //
    //  Function:   ValidateCertOwner
    //
    //  Synopsis:   This is the CHelper private method which
    //              is used to validate the owner of the certificate
    //              on the file
    //
    //  Arguments:  [in]    BSTR    -  full file path 
    //
    //  Returns:    HRESULT 
    //
    //  History:    MKarki  Created     10/01/99
    //
    //  Called By:  CHelper::ValidateCertOwner private method
    //
    //----------------------------------------------------------------
    HRESULT 
    CHelper::ValidateCertOwner (
        /*[in]*/    BSTR    bstrFilePath
        )
    {
        return E_NOTIMPL;
#if 0
        HINSTANCE hInst;
        HRESULT hr = E_FAIL;
        do
        {
            SATraceString ("Validating Certificate Owner....");

            HCERTSTORE      hCertStore      = NULL;
            PCCERT_CONTEXT  pCertContext    = NULL;
            DWORD           dwEncodingType  = 0;
            DWORD           dwContentType   = 0;
            DWORD           dwFormatType    = 0;
            DWORD           dwErr           = 0;

            //
            // Open cert store from the file
            //
            BOOL bRetVal = CryptQueryObject(
                                    CERT_QUERY_OBJECT_FILE,
                                    bstrFilePath,
                                    CERT_QUERY_CONTENT_FLAG_ALL,
                                    CERT_QUERY_FORMAT_FLAG_ALL,
                                    0,
                                    &dwEncodingType,
                                    &dwContentType,
                                    &dwFormatType,
                                    &hCertStore,
                                    NULL,
                                    (const void **)&pCertContext
                                    );

            if (bRetVal && hCertStore)
            {
                STRINGVECTOR vectorSubject;
                //
                // get the subjects, this will not fail
                // because we always add the default MS values
                //
                GetValidOwners (vectorSubject);
                
                //
                //  go through all the subjects to see if any
                //  matches the owner of the certificate on the file
                //
                for (
                    STRINGVECTOR::iterator itr = vectorSubject.begin ();
                    (vectorSubject.end () != itr); 
                    ++itr
                    )
                {
                    //
                    // verify that the certificate has the company name 
                    // present
                    //
                    pCertContext = CertFindCertificateInStore (
                                        hCertStore,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        0,
                                        CERT_FIND_SUBJECT_STR,
                                        (*itr).data (), 
                                        NULL
                                        );
                    if (pCertContext) 
                    {
                        //
                        // get the size of buffer to use
                        // for converting certificate name to string
                        //
                        DWORD dwSize = CertNameToStr(
                                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                            &pCertContext->pCertInfo->Subject,
                                            CERT_X500_NAME_STR,
                                            NULL,
                                            0);

                        if (0 != dwSize )
                        {
                            PWCHAR pwszCN = NULL;
                            PWCHAR pwszSubjectName = 
                                (PWCHAR) _alloca ((dwSize+2)*sizeof(WCHAR));
                            if (pwszSubjectName)
                            {
                                //
                                // convert the certificate name to a string
                                //
                                CertNameToStr(
                                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                            &pCertContext->pCertInfo->Subject,
                                            CERT_X500_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
                                            pwszSubjectName,
                                            dwSize
                                            );
                    
                                //
                                // add \r\n to catch case where CN is the last
                                // item in the list
                                //
                                wcscat(pwszSubjectName, L"\r\n");

                                SATracePrintf ("Subject name in Certificate:'%ws'", pwszSubjectName); 
                    
                                //
                                // create the current subject name in X.500 form
                                //
                                std::wstring wstrCurrentName (L"CN=");
                                wstrCurrentName.append (*itr);
                                wstrCurrentName.append (L"\r\n");

                                //
                                // check if the current subject is in cert
                                //
                                if (pwszCN = wcsstr(pwszSubjectName, wstrCurrentName.data())) 
                               {
                                        //
                                        // found the current subject in cert
                                        // now verify that the name is an
                                        // element on its own and not a 
                                        // part of another string, this
                                        // is just an extra precaution
                                        //
                                    if (
                                        (pwszCN == pwszSubjectName) ||
                                        ((*(pwszCN-2) == '\r') && (*(pwszCN-1) == '\n')) 
                                        )
                                    {
                                        hr = S_OK;
                                        CertFreeCertificateContext(pCertContext);
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                SATraceString (
                                    "Failed to allocate dynamic memory"
                                    );
                                hr = E_OUTOFMEMORY;
                                CertFreeCertificateContext(pCertContext);
                                break;
                            }
                        }
                        else
                        {
                            SATraceFailure ("CertNameToStr", GetLastError ());
                        }
                            
    
                        //
                        // free the context now
                        //
                        CertFreeCertificateContext(pCertContext);
                    }
                    else
                    {
                        SATraceFailure ("CertFindCertificateInStore", GetLastError ());
                    }
                }

                //
                // clean the vector now
                //
                itr = vectorSubject.begin ();
                while (vectorSubject.end () != itr)
                {
                    itr = vectorSubject.erase (itr);
                }

                //
                // close the certificate store after use
                //
                CertCloseStore(hCertStore, 0);
            } 
            else
            {
                SATraceFailure ("CryptQueryObject", GetLastError ());
            }
        }
        while (false);

        return (hr);
#endif

    }   //  end of CHelper::VaildateCertOwner method

    //++--------------------------------------------------------------
    //
    //  Function:   GetValidOwners 
    //
    //  Synopsis:   This is the CHelper private method which
    //              is used to get the name of the certificate owners
    //              that are supported
    //
    //  Arguments:  [in/out]    vector& - reference to the vector holding
    //                                    the names 
    //
    //  Returns:    HRESULT 
    //
    //  History:    MKarki  Created     10/02/99
    //
    //  Called By:  CHelper::ValidateCertOwner private method
    //
    //----------------------------------------------------------------
    HRESULT 
    CHelper::GetValidOwners (
        /*[in/out]*/    STRINGVECTOR&   vectorSubject
        )
    {
        HRESULT hr = S_OK;

        try
        {

            do
            {
                std::wstring wstrPathName (SUBJECTS_KEY);
                CLocationInfo LocInfo (HKEY_LOCAL_MACHINE, wstrPathName.data());

                //
                // create the property bag container
                //
                PPROPERTYBAGCONTAINER    
                pObjMgrs = ::MakePropertyBagContainer (
                                        PROPERTY_BAG_REGISTRY,  
                                        LocInfo
                                        );
                if (!pObjMgrs.IsValid())
                {
                    hr = E_FAIL;
                    break;
                }

                if (!pObjMgrs->open())  
                {
                    //
                    // its OK not to have any value
                    //
                    SATraceString (
                            "No Subject information in the registry"
                            );
                    break;
                }

                pObjMgrs->reset();

                //
                // go through each entry in the propertybag container
                //
                do
                {
                    PPROPERTYBAG pObjBag = pObjMgrs->current();
                    if (!pObjBag.IsValid())
                    {
                        //
                        // its OK not to have any value
                        //
                        SATraceString (
                            "No subject information in the registry"
                            );
                        break;
                    }

                    if (!pObjBag->open()) 
                    {
                        hr = E_FAIL;
                        break;
                    }

                    pObjBag->reset ();

                    //
                    // get the entries out of this bag and
                    // add to our collection
                    //
                    CComVariant vtSubjectName;
                    if (!pObjBag->get (SUBJECT_NAME, &vtSubjectName))
                    {
                        SATraceString (
                            "Unable to obtain the subject name"
                            );
                        hr = E_FAIL;
                        break;
                    }

                    //
                    // add this name to the vector
                    //
                    vectorSubject.push_back (wstring (V_BSTR (&vtSubjectName)));

                } while (pObjMgrs->next());


            } while (false);

            //
            // now we will add the Microsoft Subject names
            //
            vectorSubject.push_back (wstring (MICROSOFT_SUBJECT_NAME));
            vectorSubject.push_back (wstring (MICROSOFT_EUROPE_SUBJECT_NAME));
            hr = S_OK;
        }
        catch(_com_error theError)
        {
            SATraceString ("GetValidOwners caught unknown COM exception");
            hr = theError.Error();
        }
        catch(...)
        {
            SATraceString ("GetValidOwners caught unknown exception");
            hr = E_FAIL;
        }

        return (hr);

    }   //  end of CHelper::GetValidOwners method


    //
    // if the OS_SERVERAPPLIANCE is not defined we will need to define it
    // here
    //
    #ifndef OS_SERVERAPPLIANCE
        #define OS_SERVERAPPLIANCE    21        //Server Appliance based on Windows 2000 advanced Server
    #endif
    
    //++--------------------------------------------------------------
    //
    //  Function:   IsWindowsPowered 
    //
    //  Synopsis:   This is the CHelper public method which
    //              is used to check if we are running on Windows Powered
    //                Operating System
    //
    //  Arguments:  [ouit] BOOL* - Yes/No 
    //
    //  Returns:    HRESULT 
    //
    //  History:    MKarki  Created     07/21/2000
    //
    //----------------------------------------------------------------
    STDMETHODIMP 
    CHelper::IsWindowsPowered (
                    /*[out]*/   VARIANT_BOOL *pvbIsWindowsPowered
                    )
      {
          CSATraceFunc objSATrace ("CHelper::IsWindowsPowered");
          
        HRESULT hr = S_OK;

        _ASSERT (pvbIsWindowsPowered);
        
        try
        {
            do
            {
                if (NULL == pvbIsWindowsPowered)
                {
                    SATraceString (
                        "CHelper::IsWindowsPowered failed, invalid parameter passed in"
                        );
                    hr = E_INVALIDARG;
                    break;
                }
    
                OSVERSIONINFOEX OSInfo;
                memset (&OSInfo, 0, sizeof (OSVERSIONINFOEX));
                OSInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);

                //
                // get the version info now
                //
                BOOL bRetVal = GetVersionEx ((LPOSVERSIONINFO) &OSInfo);
                if (FALSE == bRetVal)
                {
                    SATraceFailure (
                        "CHelper::IsWindowsPowered-GetVesionEx failed with",
                        GetLastError ()
                        );
                    hr = E_FAIL;
                    break;
                }

                SATracePrintf ("CHelper::IsWindowsPowered got suitemask:%x", OSInfo.wSuiteMask);
                SATracePrintf ("CHelper::IsWindowsPowered got  producttype:%x", OSInfo.wProductType);

                //
                // check for windows powered now
                //
                if( 
                    (VER_SUITE_SERVERAPPLIANCE & OSInfo.wSuiteMask) && 
                    (VER_NT_SERVER == OSInfo.wProductType)
                )
                { 
                    *pvbIsWindowsPowered = VARIANT_TRUE; 
                    SATraceString ("OS found IS Windows Powered");
                }
                else
                {
                    *pvbIsWindowsPowered = VARIANT_FALSE;
                    SATraceString ("OS is NOT Windows Powered");
                }
            }
            while (false);
        }
        catch (...)
        {

        }

        return (hr);

      }    //    end of CHelper::IsWindowsPowered method


    const DWORD dwIpType = 0;
    const DWORD dwMaskType = 1;
    const DWORD dwGatewayType = 2;

    //++--------------------------------------------------------------
    //
    //  Function:   get_HostName 
    //
    //  Synopsis:   This is the CHelper public method which
    //              gets the hostname of the machine
    //
    //  Arguments:  [out] BSTR *pVal
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    STDMETHODIMP CHelper::get_HostName(BSTR *pVal)
    {

        BOOL bSuccess;
        WCHAR wstrHostName[256];
        DWORD dwLength = 256;

        //
        // make sure we have a valid pointer
        //
        if (NULL == pVal)
            return E_POINTER;

        //
        // get the host name
        //

        bSuccess = GetComputerNameEx(
                                ComputerNamePhysicalDnsHostname,  // name type
                                wstrHostName,                    // name buffer
                                &dwLength                             // size of name buffer
                                );

        if (!bSuccess)
        {
            SATraceFailure("get_HostName failed on GetComputerNameEx", GetLastError());
            return E_FAIL;
        }

        //
        // Allocate string and return
        //
        *pVal = SysAllocString(wstrHostName);
        if (*pVal != NULL)
            return S_OK;

        return E_OUTOFMEMORY;

    }    //    end of CHelper::get_HostName method


    //++--------------------------------------------------------------
    //
    //  Function:   put_HostName 
    //
    //  Synopsis:   This is the CHelper public method which
    //              sets the hostname of the machine
    //
    //  Arguments:  [in] BSTR newVal
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    STDMETHODIMP CHelper::put_HostName(BSTR newVal)
    {
        
        BOOL bSuccess;

        //
        // Set the hostname
        //
        bSuccess = SetComputerNameEx(ComputerNamePhysicalDnsHostname,
                                    newVal);

        if (!bSuccess)
            return E_FAIL;

        return S_OK;
    }    //    end of CHelper::put_HostName method


    //++--------------------------------------------------------------
    //
    //  Function:   get_IpAddress 
    //
    //  Synopsis:   This is the CHelper public method which
    //              gets the ip address for default adapter
    //
    //  Arguments:  [out] BSTR *pVal
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    STDMETHODIMP CHelper::get_IpAddress(BSTR *pVal)
    {

        return GetIpInfo(dwIpType,pVal);

    }    //    end of CHelper::put_HostName method



    //++--------------------------------------------------------------
    //
    //  Function:   get_SubnetMask 
    //
    //  Synopsis:   This is the CHelper public method which
    //              gets the subnet mask for default adapter
    //
    //  Arguments:  [out] BSTR *pVal
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    STDMETHODIMP CHelper::get_SubnetMask(BSTR *pVal)
    {

        return GetIpInfo(dwMaskType,pVal);

    }    //    end of CHelper::put_HostName method


    //++--------------------------------------------------------------
    //
    //  Function:   get_DefaultGateway 
    //
    //  Synopsis:   This is the CHelper public method which
    //              sets the default gateway of the machine
    //
    //  Arguments:  [out] BSTR *pVal
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    STDMETHODIMP CHelper::get_DefaultGateway(BSTR *pVal)
    {

        return GetIpInfo(dwGatewayType,pVal);

    }    //    end of CHelper::get_DefaultGateway method



    //++--------------------------------------------------------------
    //
    //  Function:   SetDynamicIp 
    //
    //  Synopsis:   This is the CHelper public method which
    //              dynamically sets ip using DHCP
    //
    //  Arguments:  none
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    STDMETHODIMP CHelper::SetDynamicIp()
    {
        GUID GuidAdapter;

        //
        // gets the deafult adapter name
        //
        if (!GetDefaultAdapterGuid(&GuidAdapter))
            return E_FAIL;

        //
        // get dynamic ip using the helper method
        //
        return SetAdapterInfo(GuidAdapter, 
                              L"DYNAMIC", 
                              0, 
                              0,
                              0);

    }     //    end of CHelper::SetDynamicIp method


    //++--------------------------------------------------------------
    //
    //  Function:   SetStaticIp 
    //
    //  Synopsis:   This is the CHelper public method which
    //              sets the hostname of the machine
    //
    //  Arguments:  [in] BSTR bstrIp
    //                [in] BSTR bstrMask
    //                [in] BSTR bstrGateway
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    STDMETHODIMP CHelper::SetStaticIp(BSTR bstrIp, BSTR bstrMask, BSTR bstrGateway)
    {

        GUID GuidAdapter;

        //
        // gets the deafult adapter name
        //
        if (!GetDefaultAdapterGuid(&GuidAdapter))
        {
            SATraceString("SAhelper::SetStaticIp, GetDefaultAdapterGuid failed");
            return E_FAIL;
        }
        //
        // set static ip using the helper method
        //
        return SetAdapterInfo(GuidAdapter, 
                              L"STATIC", 
                              bstrIp, 
                              bstrMask,
                              bstrGateway);
    }     //    end of CHelper::SetStaticIp method



    //++--------------------------------------------------------------
    //
    //  Function:   GetIpInfo 
    //
    //  Synopsis:   This is the CHelper private method which
    //              gets specific ip information
    //
    //  Arguments:  [in] DWORD dwType 
    //                [out] BSTR *pVal
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    HRESULT CHelper::GetIpInfo(DWORD dwType, BSTR *pVal)
    {

        HRESULT hr = E_FAIL;
        IP_ADAPTER_INFO * pAI = NULL;

        if (!pVal)
        {
            return E_INVALIDARG;
        }

        *pVal = NULL;

        ULONG * pOutBufLen = new ULONG;             


        if (pOutBufLen == NULL)
        {
            return E_OUTOFMEMORY;
        }

        try
        {
            //
            // get all of the adapters for the machine
            //
            hr = GetAdaptersInfo ((IP_ADAPTER_INFO*) pAI, pOutBufLen);
    
            //
            // allocate enough storage for adapters
            //
            if (hr == ERROR_BUFFER_OVERFLOW) 
            {
        
                pAI = new IP_ADAPTER_INFO[*pOutBufLen];

                if (pAI == NULL) 
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = GetAdaptersInfo (pAI, pOutBufLen);
                    IP_ADAPTER_INFO * p = pAI;

                    //
                    // get the information from first(default) adapter
                    //
                    if ((SUCCEEDED(hr)) && p)
                    {
                        USES_CONVERSION;
                        //
                        // Ip Address
                        //
                        if (dwType == dwIpType)
                        {
                            *pVal = SysAllocString(A2T ( ( (p->IpAddressList).IpAddress).String ) );
                        }
                        //
                        // Subnet Mask
                        //
                        else if (dwType == dwMaskType)
                        {
                            *pVal = SysAllocString(A2T ( ( (p->IpAddressList).IpMask).String ) );
                        }
                        //
                        // Default Gateway
                        //
                        else if (dwType == dwGatewayType)
                        {
                            *pVal = SysAllocString(A2T ( ( (p->GatewayList).IpAddress).String ) );
                        }


                    }
                }

                if (pAI)
                {
                    delete [] pAI;
                }

                delete pOutBufLen;
        
            }
        }
        catch(...)
        {
            SATraceString("Exception occured in CHelper::GetIpInfo method");
            return E_FAIL;
        }

        if (FAILED(hr))
            return hr;

        if (*pVal)
            return S_OK;
        else
            return E_OUTOFMEMORY;

    }     //    end of CHelper::GetIpInfo method



    //++--------------------------------------------------------------
    //
    //  Function:   GetDefaultAdapterGuid 
    //
    //  Synopsis:   This is the CHelper private method which
    //              gets the guid for default adapter
    //
    //  Arguments:  [out] GUID * pGuidAdapter
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    BOOL CHelper::GetDefaultAdapterGuid(GUID * pGuidAdapter)
    {

        if (!pGuidAdapter)
        {
            return FALSE;
        }

        BOOL bFound = FALSE;

        IP_ADAPTER_INFO * pAI = NULL;

        ULONG * pOutBufLen = new ULONG;                  

        if (pOutBufLen == NULL)
            return FALSE;
        
        try
        {
            //
            // get all of the adapters for the machine
            //
            HRESULT hr = GetAdaptersInfo ((IP_ADAPTER_INFO*) pAI, pOutBufLen);
    
            //
            // allocate enough storage for adapters
            //
            if (hr == ERROR_BUFFER_OVERFLOW) 
            {
        
                pAI = new IP_ADAPTER_INFO[*pOutBufLen];

                if (!pAI) 
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {

                    hr = GetAdaptersInfo (pAI, pOutBufLen);
                    IP_ADAPTER_INFO * p = pAI;

                    if ((SUCCEEDED(hr)) && p) 
                    {
                        USES_CONVERSION;
                        hr = CLSIDFromString (A2W(p->AdapterName), (CLSID*)pGuidAdapter);

                        if (SUCCEEDED(hr))
                        {
                            bFound = TRUE;
                        }
                    } 
                }
                if (pAI)
                {
                    delete [] pAI;
                }

                delete pOutBufLen;
        
            }
        }
        catch(...)
        {
            SATraceString("Exception occured in CHelper::GetDefaultAdapterGuid method");
            return FALSE;
        }

        return bFound;
    }     //    end of CHelper::GetDefaultAdapterGuid method



    //++--------------------------------------------------------------
    //
    //  Function:   SetAdapterInfo 
    //
    //  Synopsis:   This is the CHelper public method which
    //              sets the ip information
    //
    //  Arguments:  [in] GUID guidAdapter
    //                [in] WCHAR * szOperation (static or dynamic)
    //                [in] WCHAR * szIp (ip address)
    //                [in] WCHAR * szMask (subnet mask)
    //                [in] WCHAR * szGateway (default gateway)
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    HRESULT CHelper::SetAdapterInfo(GUID guidAdapter, 
                                          WCHAR * szOperation, 
                                          WCHAR * szIp, 
                                          WCHAR * szMask,
                                          WCHAR * szGateway)
    {
        DWORD dwResult = ERROR_SUCCESS;
        HRESULT hr = S_OK;
        USES_CONVERSION;

                SATraceString("SAhelper::Entering SetAdapterInfo");
        //
        // Check input parameter
        //
        if (!szOperation)
            return E_POINTER;

        //
        // For staic ip, check ip information
        //
        if (!wcscmp(szOperation, L"STATIC")) 
        {
            if ((!szIp) || (!szMask) || (!szGateway))
                return E_POINTER;

            if (!_IsValidIP(szIp) || !_IsValidIP(szMask) || !_IsValidIP(szGateway))
            {
                SATraceString("SAhelper::SetAdapterInfo, not a valid ipnum");
                return E_FAIL;
            }

            //
            //make sure it is not duplicate
            //

            WSADATA wsad;
            WSAStartup(0x0101,&wsad);
            ULONG ulTmp;

            try
            {
                ulTmp = inet_addr(W2A(szIp));
            }
            catch(...)
            {
                SATraceString("Exception occured in CHelper::SetAdapterInfo method");
                return E_FAIL;
            }

            if ( gethostbyaddr((LPSTR)&ulTmp, 4, PF_INET) )
            {
                //
                // make sure it is not the current ip for the machien
                //
                BSTR bstrCurrentIp;
                hr = get_IpAddress(&bstrCurrentIp);

                if (wcscmp(szIp,bstrCurrentIp))
                {
                    hr = E_FAIL;
                }
                WSACleanup();
                ::SysFreeString(bstrCurrentIp);

                //
                // Ip address belongs to another machine
                //
                if (FAILED(hr))
                {
                    SATraceString("SAhelper::SetAdapterInfo, ip address exists on network");
                    return E_FAIL;
                }
            }

            WSACleanup();

        }

        //
        // Create network configuration component
        //
        CComPtr<INetCfg> spNetCfg = NULL;
        hr = CoCreateInstance(CLSID_CNetCfg,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              __uuidof(INetCfg),
                              (void **)&spNetCfg);

        if (FAILED(hr))
        {
            SATracePrintf("SAhelper::SetAdapterInfo, failed on CoCreateInstance for CLSID_CNetCfg, %x",hr);
            return hr;
        }
        //
        // Get the lock interface
        //
        CComPtr<INetCfgLock> spNetCfgLock = NULL;

        hr = spNetCfg->QueryInterface (__uuidof(INetCfgLock), (void**)&spNetCfgLock);

        if (FAILED(hr))
        {
            SATracePrintf("SAhelper::SetAdapterInfo, failed on QueryInterface for INetCfgLock, %x",hr);
            return hr;
        }

        LPWSTR szwLockOwner = NULL;

        //
        // Obtain a lock for writing
        //
        hr = spNetCfgLock->AcquireWriteLock (10,  
                                            L"LocalUINetworkConfigTask",
                                            &szwLockOwner);


        //
        // some one else owns the lock
        //
        if (szwLockOwner)
        {
            SATracePrintf("SAhelper::SetAdapterInfo, NetCfg lock owner, %ws",szwLockOwner);
        }

        if (hr != S_OK) 
        {
            SATracePrintf("SAhelper::SetAdapterInfo, failed on AcquireWriteLock, %x",hr);
            CoTaskMemFree (szwLockOwner);
            return E_ACCESSDENIED;
        }

        //
        // we got a lock: now we can initialize INetCfg
        //
        void * pv = NULL;

        hr = spNetCfg->Initialize (pv);

        if (FAILED(hr))
        {
            SATracePrintf("SAhelper::SetAdapterInfo, failed on Initialize, %x",hr);
            spNetCfgLock->ReleaseWriteLock ();
            return hr;
        }

        //
        // get the component that does the TCPIP stuff
        //
        CComPtr<INetCfgComponent> spNetCfgComponent = NULL;

        hr = spNetCfg->FindComponent (L"ms_tcpip", &spNetCfgComponent);

        if (FAILED(hr))
        {
            SATracePrintf("SAhelper::SetAdapterInfo, failed on FindComponent for ms_tcpip, %x",hr);
            spNetCfg->Uninitialize ();
            spNetCfgLock->ReleaseWriteLock ();
            return hr;
        }
        
        //
        // get the private interface of the TCPIP component
        //
        CComPtr<INetCfgComponentPrivate> spNetCfgComponentPrivate = NULL;

        hr = spNetCfgComponent->QueryInterface (__uuidof(INetCfgComponentPrivate),
                                                (void**)&spNetCfgComponentPrivate);

        if (FAILED(hr))
        {
            SATracePrintf("SAhelper::SetAdapterInfo, failed on QueryInterface for INetCfgComponentPrivate, %x",hr);
            spNetCfg->Uninitialize ();
            spNetCfgLock->ReleaseWriteLock ();
            return hr;
        }
        
        //
        // query for the notify object
        //
        CComPtr<ITcpipProperties> spTcpipProperties = NULL;

        hr = spNetCfgComponentPrivate->QueryNotifyObject (__uuidof(ITcpipProperties), 
                                                        (void**)&spTcpipProperties);
        if (FAILED(hr))
        {
            SATracePrintf("SAhelper::SetAdapterInfo, failed on QueryNotifyObject for ITcpipProperties, %x",hr);
            spNetCfg->Uninitialize ();
            spNetCfgLock->ReleaseWriteLock ();
            return hr;
        }

        REMOTE_IPINFO * pIpInfo = NULL;
        REMOTE_IPINFO IPInfo2;
        
        //
        // Get ipinfo for our adapter
        //
        hr = spTcpipProperties->GetIpInfoForAdapter (&guidAdapter, &pIpInfo);
    
        if (FAILED(hr))
        {
            SATracePrintf("SAhelper::SetAdapterInfo, failed on GetIpInfoForAdapter, %x",hr);
            spNetCfg->Uninitialize ();
            spNetCfgLock->ReleaseWriteLock ();
            return hr;
        }

        //
        // get a backup of previous values
        //
        hr = CopyIPInfo(pIpInfo, &IPInfo2);
        if (FAILED(hr))
        {
            SATracePrintf("SAhelper::SetAdapterInfo, failed on CopyIPInfo, %x",hr);
            spNetCfg->Uninitialize ();
            spNetCfgLock->ReleaseWriteLock ();
            return hr;
        }


        WCHAR * szTempOptionList = NULL;

        //
        // dynamic ip setting
        // enable dhcp
        // set ip address and mask to 0.0.0.0
        //
        if (!wcscmp(szOperation, L"DYNAMIC")) 
        {
            IPInfo2.dwEnableDhcp = 1;
            delete IPInfo2.pszwIpAddrList;
            IPInfo2.pszwIpAddrList = new WCHAR[8];
            wcscpy(IPInfo2.pszwIpAddrList, L"0.0.0.0");
            delete IPInfo2.pszwSubnetMaskList;
            IPInfo2.pszwSubnetMaskList = new WCHAR[8];
            wcscpy(IPInfo2.pszwSubnetMaskList, L"0.0.0.0");
        }
        //
        // static ip setting
        // set ip address and mask to input values
        //
        else if (!wcscmp(szOperation, L"STATIC")) 
        {
            IPInfo2.dwEnableDhcp = 0;

            //
            // set the ip address
            //
            delete IPInfo2.pszwIpAddrList;
            IPInfo2.pszwIpAddrList = new WCHAR[wcslen(szIp) + 1];
            if (IPInfo2.pszwIpAddrList == NULL)
            {
                dwResult = 1;
            }
            else
            {
                wcscpy(IPInfo2.pszwIpAddrList, szIp);
            }

            //
            // set the subnet mask
            //
            delete IPInfo2.pszwSubnetMaskList;
            IPInfo2.pszwSubnetMaskList = new WCHAR[wcslen(szMask) + 1];
            if (IPInfo2.pszwSubnetMaskList == NULL)
            {
                dwResult = 1;
            }
            else
            {
                wcscpy(IPInfo2.pszwSubnetMaskList, szMask);
            }


            //
            //if the user wants to set the default gateway
            //
            if (wcscmp(L"0.0.0.0",szGateway))
            {

                //
                //set the default gateway  - allocate an extra WCHAR as we might have to add a comma to the string
                //
                DWORD dwOptionListSize = wcslen(IPInfo2.pszwOptionList) + wcslen(szGateway) + 1 + 1;

                WCHAR szEqual[2] = L"=";
                WCHAR szSemicolon[2] = L";";
                WCHAR * tempCursor; 
                WCHAR * tempIndex;
                WCHAR * tempGatewayEnds;
                WCHAR * tempMarker;
                BOOL bInTheList = FALSE;
                //
                // allocate space for the new gateway
                //
                szTempOptionList = new WCHAR[dwOptionListSize];

                if (szTempOptionList == NULL)
                {
                    dwResult = 1;
                }
                else
                {
                    wcscpy(szTempOptionList, L"");

                    tempCursor = tempIndex = NULL;

                    //
                    // find the default gateway tag
                    //
                    tempCursor = wcsstr(IPInfo2.pszwOptionList, L"DefGw=");
                    if (tempCursor == NULL) 
                    {
                        delete [] szTempOptionList;
                        dwResult = 1;
                    }
                    else
                    {
                        tempGatewayEnds = tempCursor;
                        //
                        // check if dfgateway is already in th elist
                        //
                        while ( (*tempGatewayEnds != ';') && (*tempGatewayEnds != 0) )
                        {
                            tempGatewayEnds++;
                        }

                        tempMarker = wcsstr(tempCursor,szGateway);
                        
                        if (tempMarker != NULL)
                        {
                            if (tempMarker < tempGatewayEnds)
                            {
                                bInTheList = TRUE;
                            }
                        }

                        tempIndex = IPInfo2.pszwOptionList;

                        DWORD i = 0;
                        //
                        // copy until the default gateway tag
                        //
                        while (tempIndex != tempCursor)
                        {
                            szTempOptionList[i] = *tempIndex;
                            tempIndex++;
                            i++;
                        }
                        
                        //
                        // copy the default gateway tag
                        //
                        while (*tempCursor != szEqual[0]) 
                        {
                            szTempOptionList[i] = *tempCursor;
                            i++;
                            tempCursor++;
                        }
                        
                        if (*tempCursor == szEqual[0]) 
                        {
                            szTempOptionList[i] = *tempCursor;
                            i++;
                            tempCursor++;
                        }
                        szTempOptionList[i] = 0;

                        //
                        // add a , if there are more than one gateway
                        //
                        if (bInTheList == FALSE)
                        {
                            wcscat(szTempOptionList, szGateway);

                            if (*tempCursor != szSemicolon[0])
                                wcscat(szTempOptionList, L",");
                        }

                        wcscat(szTempOptionList, tempCursor);
                        

                    }
                }
            }

        }

        //
        // Apply the changes
        //
        if (dwResult == ERROR_SUCCESS) 
        {
            if (szTempOptionList) 
            {
                delete IPInfo2.pszwOptionList;
                IPInfo2.pszwOptionList = szTempOptionList;
            }
            hr = spTcpipProperties->SetIpInfoForAdapter (&guidAdapter, &IPInfo2);
            if (hr == S_OK) 
            {
                hr = spNetCfg->Apply ();
            }
        }
                                        

        //
        // delete unnecessary allocations
        //
        CoTaskMemFree (pIpInfo);

        spNetCfg->Uninitialize ();
        spNetCfgLock->ReleaseWriteLock ();
    
        if (dwResult != ERROR_SUCCESS)
        {
            return E_FAIL;
        }

        return hr;
    }     //    end of CHelper::SetAdapterInfo method


    //++--------------------------------------------------------------
    //
    //  Function:   CopyIPInfo 
    //
    //  Synopsis:   This is the CHelper private method which
    //              copies ip info from source to dest
    //
    //  Arguments:  [in] REMOTE_IPINFO * pIPInfo
    //                [in,out] REMOTE_IPINFO * destIPInfo
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    HRESULT CHelper::CopyIPInfo(REMOTE_IPINFO * pIPInfo, REMOTE_IPINFO * destIPInfo)
    {

        //
        // Allocate new structure and copy source values
        //
        destIPInfo->dwEnableDhcp = pIPInfo->dwEnableDhcp;

        destIPInfo->pszwIpAddrList = new WCHAR[wcslen(pIPInfo->pszwIpAddrList) + 1];

        if (destIPInfo->pszwIpAddrList == NULL)
            return E_POINTER;

        wcscpy(destIPInfo->pszwIpAddrList, pIPInfo->pszwIpAddrList);

        destIPInfo->pszwSubnetMaskList = new WCHAR[wcslen(pIPInfo->pszwSubnetMaskList) + 1];
        if (destIPInfo->pszwSubnetMaskList == NULL)
            return E_POINTER;

        wcscpy(destIPInfo->pszwSubnetMaskList, pIPInfo->pszwSubnetMaskList);

        destIPInfo->pszwOptionList = new WCHAR[wcslen(pIPInfo->pszwOptionList) + 1];
        if (destIPInfo->pszwOptionList == NULL)
            return E_POINTER;

        wcscpy(destIPInfo->pszwOptionList, pIPInfo->pszwOptionList);

        return S_OK;

    }     //    end of CHelper::CopyIPInfo method


    //++--------------------------------------------------------------
    //
    //  Function:   _IsValidIP 
    //
    //  Synopsis:   This is the CHelper private method which
    //              converts a string containing an (Ipv4) Internet 
    //                Protocol dotted address into a proper address 
    //
    //  Arguments:  [in] LPCWSTR szIPAddress
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     12/14/2000
    //
    //----------------------------------------------------------------
    BOOL CHelper::_IsValidIP (LPCWSTR szIPAddress)
    {
    
        WCHAR szDot[2] = L".";
        WCHAR * t;
        if (!(t = wcschr (szIPAddress, szDot[0])))
            return FALSE;
        if (!(t = wcschr (++t, szDot[0])))
            return FALSE;
        if (!(t = wcschr (++t, szDot[0])))
            return FALSE;

        //
        // inet_addr converts IP Address to DWORD format
        //
        USES_CONVERSION;
        ULONG ulTmp;

        try
        {
            ulTmp = inet_addr(W2A(szIPAddress));
        }
        catch(...)
        {
            SATraceString("Exception occured in CHelper::_IsValidIP method");
            return FALSE;
        }

        return (INADDR_NONE != ulTmp);

    }     //    end of CHelper::_IsValidIP method


    //++--------------------------------------------------------------
    //
    //  Function:   ResetAdministratorPassword 
    //
    //  Synopsis:   This is the CHelper public method which
    //              resets the admin password to "ABc#123&dEF" 
    //
    //  Arguments:  [out,retval] VARIANT_BOOL   *pvbSuccess
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     01/28/2001
    //              serdarun Modify       04/08/2002
    //              removing method due to security considerations
    //
    //----------------------------------------------------------------
    HRESULT CHelper::ResetAdministratorPassword(
                            /*[out,retval]*/VARIANT_BOOL   *pvbSuccess
                            )
    {


        return E_NOTIMPL;

    }     //    end of CHelper::ResetAdministratorPassword method


    //++--------------------------------------------------------------
    //
    //  Function:   IsDuplicateMachineName 
    //
    //  Synopsis:   This is the CHelper public method which
    //              checks if the machine name exists in the network 
    //
    //  Arguments:        [in] BSTR bstrMachineName
    //                    [out,retval] VARIANT_BOOL   *pvbDuplicate
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     01/28/2001
    //
    //----------------------------------------------------------------
    HRESULT CHelper::IsDuplicateMachineName    (
                        /*[in]*/BSTR bstrMachineName,
                        /*[out,retval]*/VARIANT_BOOL   *pvbDuplicate
                        )
    {

        USES_CONVERSION;

        HRESULT hr;
          int iStatus;

        WSADATA wsad;
        hostent * ptrHostent = NULL;

        BSTR bstrCurrentMachineName;

        //
        // Get the current name for the machine and compare 
        // If they are the same, we consider it duplicate
        //
        hr = get_HostName(&bstrCurrentMachineName);

        if (FAILED(hr))
        {
            SATracePrintf("CHelper::IsDuplicateMachineName, failed on get_HostName: %x", hr);
            ::SysFreeString(bstrMachineName);
            return hr;
        }

        if (0 == _wcsicmp(bstrCurrentMachineName,bstrMachineName))
        {
            *pvbDuplicate = VARIANT_TRUE;
            ::SysFreeString(bstrCurrentMachineName);
            ::SysFreeString(bstrMachineName);
            return S_OK;
        }

        //
        // free the current machine name
        //
        ::SysFreeString(bstrCurrentMachineName);

        //
        // Search for a machine with this hostname
        //
        iStatus = WSAStartup(0x0101,&wsad);

        if (iStatus != 0)
        {
            SATraceString("CHelper::IsDuplicateMachineName, failed on WSAStartup");
            ::SysFreeString(bstrMachineName);
            return S_OK;
        }

        //
        // ptrHostent points to the machine info struct
        //
        try
        {
            ptrHostent = gethostbyname(W2A(bstrMachineName));
        }
        catch(...)
        {
            SATraceString("Exception occured in CHelper::IsDuplicateMachineName method");
            return E_FAIL;
        }

        //
        // someone replied
        //
        if (NULL != ptrHostent)
        {
            //
            // get the ip address for current machine and compare it with the one replied
            //
            BSTR bstrIpAddress;
            hr = get_IpAddress(&bstrIpAddress);

            if (FAILED(hr))
            {
                SATracePrintf("CHelper::IsDuplicateMachineName, failed on get_IpAddress: %x", hr);
                ::SysFreeString(bstrMachineName);
                return hr;
            }

            //
            // ip address of the machine that replied
            //
            ULONG lIpAddress = *(ULONG*)(ptrHostent->h_addr_list[0]);

            SATracePrintf("CHelper::IsDuplicateMachineName, ip address of the machine that replied %x",lIpAddress);
            

            //
            // convert the current ip address contained in bstrIpAddress to long
            //
            WCHAR * szIndex = bstrIpAddress;
            
            ULONG lCurrentIpAddress = 0;

            int iIndex = 0;
            int iDotCount = 0;

            //
            // convert the string to integer and add to lCurrentIpAddress
            // every time you find a dot
            //
            while ( bstrIpAddress[iIndex] != 0)
            {
                if (bstrIpAddress[iIndex] == '.')
                {
                    bstrIpAddress[iIndex] = 0;
                    iIndex++;
                    lCurrentIpAddress += ((ULONG)_wtoi(szIndex)) << (8*iDotCount);
                    iDotCount++;
                    szIndex = bstrIpAddress + iIndex;
                }
                iIndex++;
            }

            lCurrentIpAddress += ((ULONG)_wtoi(szIndex)) << (8*iDotCount);

            SATracePrintf("CHelper::IsDuplicateMachineName, current ip address is %x",lCurrentIpAddress);

            
            ::SysFreeString(bstrMachineName);
            ::SysFreeString(bstrIpAddress);

            //
            // check if this belongs to the machine
            //
            if (lCurrentIpAddress == lIpAddress)
            {
                *pvbDuplicate = VARIANT_FALSE;
            }
            else
            {
                *pvbDuplicate = VARIANT_TRUE;
            }

            WSACleanup(); 
            return S_OK;
        }
        //
        // no machine with that name replied, it is not duplicate
        //
        else
        {
            int iWsaError = WSAGetLastError();
            SATracePrintf("CHelper::IsDuplicateMachineName failed in gethostbyname %x",WSAGetLastError());
            *pvbDuplicate = VARIANT_FALSE;
            ::SysFreeString(bstrMachineName);
            WSACleanup(); 
            return S_OK;
        }
    
        WSACleanup(); 

        return E_FAIL;

    }     //    end of CHelper::IsDuplicateMachineName method

    //++--------------------------------------------------------------
    //
    //  Function:   IsPartOfDomain 
    //
    //  Synopsis:   This is the CHelper public method which
    //              checks if the machine is part of a domain 
    //
    //  Arguments:  [out,retval] VARIANT_BOOL   *pvbDomain
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     01/28/2001
    //
    //----------------------------------------------------------------
    HRESULT CHelper::IsPartOfDomain    (
                            /*[out,retval]*/VARIANT_BOOL   *pvbDomain
                                )
    {
        LPWSTR lpNameBuffer = NULL;
        NETSETUP_JOIN_STATUS joinStatus;

        NET_API_STATUS netapiStatus = NetGetJoinInformation(
                                                        NULL,
                                                        &lpNameBuffer,
                                                        &joinStatus
                                                        );

        if (NERR_Success == netapiStatus)
        {
            NetApiBufferFree(lpNameBuffer);
            if ( (joinStatus == NetSetupWorkgroupName) || (joinStatus == NetSetupUnjoined) )
            {
                *pvbDomain = VARIANT_FALSE;
                return S_OK;
            }
            else if (joinStatus == NetSetupDomainName)
            {
                *pvbDomain = VARIANT_TRUE;
                return S_OK;
            }
            else
            {
                return E_FAIL;
            }
        }
        else
        {
            return E_FAIL;
        }        

        return S_OK;
    }     //    end of CHelper::IsPartOfDomain method


    //++--------------------------------------------------------------
    //
    //  Function:   IsDHCPEnabled 
    //
    //  Synopsis:   This is the CHelper public method which
    //              checks if the machine has dynamic IP 
    //
    //  Arguments:  [out,retval] VARIANT_BOOL   *pvbDHCPEnabled
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     02/03/2001
    //
    //----------------------------------------------------------------
    HRESULT CHelper::IsDHCPEnabled(
                            /*[out,retval]*/VARIANT_BOOL   *pvbDHCPEnabled
                            )
    {

        IP_ADAPTER_INFO * pAI = NULL;

        ULONG * pOutBufLen = new ULONG;             

        if (pOutBufLen == NULL)
            return E_OUTOFMEMORY;
        //
        // get all of the adapters for the machine
        //
        HRESULT hr = GetAdaptersInfo ((IP_ADAPTER_INFO*) pAI, pOutBufLen);
    
        //
        // allocate enough storage for adapters
        //
        if (hr == ERROR_BUFFER_OVERFLOW) 
        {
        
            pAI = new IP_ADAPTER_INFO[*pOutBufLen];

            if (pAI == NULL) 
            {
                delete pOutBufLen;
                return E_OUTOFMEMORY;
            }

            hr = GetAdaptersInfo (pAI, pOutBufLen);
            IP_ADAPTER_INFO * p = pAI;

            if (hr != ERROR_SUCCESS) 
            {
                delete pOutBufLen;
                delete [] pAI;
                return hr;
            }

            //
            // get the information from first(default) adapter
            //
            if (p)
            {
                USES_CONVERSION;
                //
                // Check if DHCP is enabled
                //
                if ( (p->DhcpEnabled) == 0 )
                {
                    *pvbDHCPEnabled = VARIANT_FALSE;
                }
                else
                {
                    *pvbDHCPEnabled = VARIANT_TRUE;
                }

            }
                    
            delete [] pAI;
            delete pOutBufLen;
        
        }

        return S_OK;
        
        
    }       //    end of CHelper::IsDHCPEnabled method

    //++--------------------------------------------------------------
    //
    //  Function:   GenerateRandomPassword 
    //
    //  Synopsis:   This is the CHelper public method which
    //                generates a random password length of first argument
    //
    //  Arguments:  *[in]*/ LONG lLength, length of the password
    //                [out,retval] BSTR   *pValPassword
    //
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     04/16/2001
    //
    //----------------------------------------------------------------
    HRESULT CHelper::GenerateRandomPassword(
                                    /*[in]*/ LONG lLength,
                                    /*[out,retval]*/ BSTR   *pValPassword
                                    )
    {

        SATraceString("Entering CHelper::GenerateRandomPassword");
        //
        // password can not be shorter than MIN_PWD_LEN
        //
        if (lLength < MIN_PWD_LEN)
        {
            return E_INVALIDARG;
        }

        HCRYPTPROV hProv;
        DWORD dwErr = 0;

        if (CryptAcquireContext(
                                &hProv,
                                NULL,
                                NULL,
                                PROV_RSA_FULL,
                                CRYPT_VERIFYCONTEXT) == FALSE) 
        {        
            SATraceFailure("CHelper::GenerateRandomPassword failed on, CryptAcquireContext",GetLastError());
            return E_FAIL;
        }

    
        //
        // it will contain the password
        //
        BYTE * szPwd = new BYTE[lLength+1];

        if (szPwd == NULL)
        {
            SATraceFailure("CHelper::GenerateRandomPassword failed on, memory allocation",GetLastError());
            CryptReleaseContext(hProv,0);
            return E_OUTOFMEMORY;
        }

        //
        // zero it out and decrement the size to allow for trailing '\0'
        //
        ZeroMemory(szPwd,lLength+1);
        lLength;

        // generate a pwd pattern, each byte is in the range 
        // (0..255) mod STRONG_PWD_CATS
        // this indicates which character pool to take a char from

        BYTE *pPwdPattern = new BYTE[lLength];

        if (pPwdPattern == NULL)
        {
            SATraceFailure("CHelper::GenerateRandomPassword failed on, memory allocation",GetLastError());
            //
            // release resources
            //
            delete [] szPwd;
            CryptReleaseContext(hProv,0);
            return E_OUTOFMEMORY;
        }


        BOOL fFound[STRONG_PWD_CATS];

        do {

            if (!CryptGenRandom(hProv,lLength,pPwdPattern))
            {
                SATraceFailure("CHelper::GenerateRandomPassword failed on, CryptGenRandom",GetLastError());
                //
                // release resources
                //
                delete [] szPwd;
                delete [] pPwdPattern;
                CryptReleaseContext(hProv,0);
                return E_FAIL;
            }

            fFound[STRONG_PWD_UPPER] = 
            fFound[STRONG_PWD_LOWER] =
            fFound[STRONG_PWD_PUNC] =
            fFound[STRONG_PWD_NUM] = FALSE;

            for (DWORD i=0; i < lLength; i++) 
                fFound[pPwdPattern[i] % STRONG_PWD_CATS] = TRUE;


        //
        // check that each character category is in the pattern
        //
        } while (!fFound[STRONG_PWD_UPPER] || 
                    !fFound[STRONG_PWD_LOWER] || 
                    !fFound[STRONG_PWD_PUNC] || 
                    !fFound[STRONG_PWD_NUM]);
        //
        // populate password with random data 
        // this, in conjunction with pPwdPattern, is
        // used to determine the actual data
        //
        if (!CryptGenRandom(hProv,lLength,szPwd))
        {
            SATraceFailure("CHelper::GenerateRandomPassword failed on, CryptGenRandom",GetLastError());
            //
            // release resources
            //
            delete [] szPwd;
            delete [] pPwdPattern;
            CryptReleaseContext(hProv,0);
            return E_FAIL;
        }

        for (DWORD i=0; i < lLength; i++) 
        { 
            BYTE bChar = 0;
            //
            // there is a bias in each character pool because of the % function
            //
            switch (pPwdPattern[i] % STRONG_PWD_CATS) 
            {

                case STRONG_PWD_UPPER : bChar = 'A' + szPwd[i] % NUM_LETTERS;
                                        break;

                case STRONG_PWD_LOWER : bChar = 'a' + szPwd[i] % NUM_LETTERS;
                                        break;

                case STRONG_PWD_NUM :   bChar = '0' + szPwd[i] % NUM_NUMBERS;
                                        break;

                case STRONG_PWD_PUNC :
                default:                char *szPunc="!@#$%^&*()_-+=[{]};:\'\"<>,./?\\|~`";
                                        DWORD dwLenPunc = strlen(szPunc);
                                        bChar = szPunc[szPwd[i] % dwLenPunc];
                                        break;
            }

            szPwd[i] = bChar;

        }

        //
        // copy the generated password to bstr
        //
        CComBSTR bstrPassword;

        bstrPassword = (LPCSTR)szPwd;
        
        *pValPassword = bstrPassword.Detach();

        //
        // release resources
        //
        delete [] pPwdPattern;

        delete [] szPwd;

        if (hProv != NULL) 
        {
            CryptReleaseContext(hProv,0);
        }

         SATraceString("Leaving CHelper::GenerateRandomPassword");
        return S_OK;
    }

    //++--------------------------------------------------------------
    //
    //  Function:   SAModifyUserPrivilege 
    //
    //  Synopsis:   This is the CHelper public method which
    //                modifies the privilege for the current access token
    //
    //  Arguments:  [in] BSTR bstrPrivilegeName, privelege to be modifies
    //                [in] VARIANT_BOOL, 
    //                         TRUE     enable privilege
    //                         FALSE    disable privilege
    //  Returns:    HRESULT 
    //
    //  History:    serdarun  Created     11/14/2001
    //
    //----------------------------------------------------------------
    HRESULT CHelper::SAModifyUserPrivilege(
                                    /*[in]*/ BSTR bstrPrivilegeName,
                                    /*[in]*/ VARIANT_BOOL vbEnable,
                                       /*[out,retval]*/ VARIANT_BOOL * pvbModified
                                    )
    {
        HRESULT hr;

        // win32 error value
        DWORD dwError = ERROR_SUCCESS;

        // handle to access token
        HANDLE  hAccessToken;

        BOOL    bStatus;
        BOOL bFoundPrivilege = FALSE;


        // buffer for user privileges
        ULONG   ulUserPrivBufferSize;
        PVOID   pvUserPrivBuffer = NULL;

        //token privileges
        PTOKEN_PRIVILEGES pTokenPriv = NULL;

        // privilege counter
        DWORD  dwPrivCount = 0;


         SATraceString("Entering CHelper::SAModifyUserPrivilege");

        //
        // validate the input arguments
        //
        if (pvbModified == NULL)
        {
             SATraceString("Leaving CHelper::SAModifyUserPrivilege, invalid arguments");
            return E_POINTER;
        }

        *pvbModified = VARIANT_FALSE;

        //
        //  Open a handle to the impersonated token's thread
        //
        if( !OpenThreadToken( GetCurrentThread(),
                              MAXIMUM_ALLOWED,
                              FALSE,
                              &hAccessToken ) ) 
        {

            dwError = GetLastError();
            SATracePrintf("OpenThreadToken() failed. Error = %d", dwError );
        
            //
            // it might not be an impersonation token, try process token
            //
            if( !OpenProcessToken (
                                GetCurrentProcess (),
                                MAXIMUM_ALLOWED,
                                &hAccessToken ) ) 
            {

                dwError = GetLastError();

                SATracePrintf("OpenProcessToken() failed. Error = %d", dwError );
                goto error0;
            }
        }



        //
        // Find out the buffer size for the Token Privileges
        //

        bStatus = GetTokenInformation( hAccessToken,
                                         TokenPrivileges,
                                         NULL,
                                         0,
                                         &ulUserPrivBufferSize );
        dwError = GetLastError();
        if( !bStatus &&
            dwError != ERROR_INSUFFICIENT_BUFFER ) 
        {
            SATracePrintf("GetTokenInformation() failed for Token Priviliges. Error = %d \n", dwError );
            goto error1;
        }
        dwError = ERROR_SUCCESS;
        //
        //  Allocate memory for the Token Priveleges
        //
        pvUserPrivBuffer = HeapAlloc(GetProcessHeap(), 0, ulUserPrivBufferSize );
        if( pvUserPrivBuffer == NULL ) 
        {
            dwError = ERROR_OUTOFMEMORY;
            SATracePrintf("Out of memory.");
            goto error0;
        }
        //
        //  Retrieve the Token Priveleges
        //
        bStatus = GetTokenInformation( hAccessToken,
                                     TokenPrivileges,
                                     pvUserPrivBuffer,
                                     ulUserPrivBufferSize,
                                     &ulUserPrivBufferSize );
        if( !bStatus ) 
        {
            dwError = GetLastError();
            SATracePrintf("GetTokenInformation() failed for Token Priviliges. Error = %d \n", dwError );
            goto error1;
        }

        pTokenPriv = (PTOKEN_PRIVILEGES)pvUserPrivBuffer;


        //
        // build the privileges structure
        //
        //
        // go through priveleges and enable them
        //
        while (dwPrivCount < pTokenPriv->PrivilegeCount)
        {
            WCHAR wszPriv[MAX_PATH];

            DWORD dwSize= sizeof(wszPriv);

            bStatus = LookupPrivilegeName(
                                      NULL,                                         // system name
                                      &((pTokenPriv->Privileges[dwPrivCount]).Luid),// locally unique identifier
                                      wszPriv,                                      // privilege name
                                      &dwSize                                       // name size
                                        );

            if( !bStatus ) 
            {
                dwError = GetLastError();
                SATracePrintf("LookupPrivilegeName failed. Error = %d \n", dwError );
                goto error1;
            }



            if ( ((pTokenPriv->Privileges[dwPrivCount]).Attributes) & SE_PRIVILEGE_ENABLED )
            {
                SATracePrintf("Privilege = %ws, is enabled",wszPriv);
            }
            
            else
            {
                SATracePrintf("Privilege = %ws, is disabled",wszPriv);
            }
            //
            // if this is the privilege we are modifying
            // and its state is different than new state
            //
            if  (_wcsicmp(wszPriv,bstrPrivilegeName) == 0)
            {

                bFoundPrivilege = TRUE;
                SATracePrintf("Found the privilege, Name = %ws",wszPriv);

                //
                // new privilege state information
                //
                TOKEN_PRIVILEGES NewTokPriv;
                NewTokPriv.PrivilegeCount = 1;
                
                
                //
                // we want to disable it and it is currently enabled
                //
                if ( (vbEnable == VARIANT_FALSE) &&
                     ( ((pTokenPriv->Privileges[dwPrivCount]).Attributes) & SE_PRIVILEGE_ENABLED ) )
                {
                    SATraceString("Disable the privilege");
                    NewTokPriv.Privileges[0].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;
                }

                //
                // we want to enable it and it is currently disabled
                //
                else if ( (vbEnable == VARIANT_TRUE) &&
                     !( ((pTokenPriv->Privileges[dwPrivCount]).Attributes) & SE_PRIVILEGE_ENABLED ) )
                {
                    SATraceString("Enable the privilege");
                    NewTokPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
                }
                //
                // we don't need to change it
                //
                else
                {
                    SATraceString("Privilege is already in correct state");
                    break;
                }

                //
                // get the LUID of the shutdown privilege
                //
                bStatus =  LookupPrivilegeValue( 
                                       NULL, 
                                       wszPriv, 
                                       &NewTokPriv.Privileges[0].Luid    
                                       );
                if (!bStatus)                    
                {
                    dwError = GetLastError();
                    SATracePrintf("LookupPrivilegeValue failed for privilige %ws Error = %d", wszPriv,dwError);
                }
                else
                {
                    //
                    // enable the privileges 
                    //
                    bStatus = AdjustTokenPrivileges(
                                                   hAccessToken,    
                                                   FALSE,             
                                                   &NewTokPriv,          
                                                   0,                
                                                   NULL,             
                                                   NULL              
                                                 );
                    dwError = GetLastError();
                    if (dwError != ERROR_SUCCESS)
                    {
                        SATraceFailure ("AdjustTokenPrivileges failed %d", dwError); 
                    }
                    else
                    {
                        *pvbModified = VARIANT_TRUE;
                        SATraceString ("AdjustTokenPrivileges modified the privilege"); 
                    }

                    break;
                }
            }
        
            dwPrivCount++;
        }




    error1:
        HeapFree(GetProcessHeap(), 0, pvUserPrivBuffer);
        CloseHandle( hAccessToken );

    error0:
  



        if (dwError != ERROR_SUCCESS)
        {
            return( HRESULT_FROM_WIN32(dwError) );
        }

        if (!bFoundPrivilege)
        {
            SATracePrintf("User does not have %ws privilege",bstrPrivilegeName);
            return E_FAIL;
        }

        return S_OK;
    }

//**********************************************************************
// 
// FUNCTION:  IsOperationAllowedForClient - This function checks the token of the 
//            calling thread to see if the caller belongs to the Local System account
// 
// PARAMETERS:   none
// 
// RETURN VALUE: TRUE if the caller is an administrator on the local
//            machine.  Otherwise, FALSE.
// 
//**********************************************************************
BOOL 
CHelper::IsOperationAllowedForClient (
            VOID
            )
{

    HANDLE hToken = NULL;
    DWORD  dwStatus  = ERROR_SUCCESS;
    DWORD  dwAccessMask = 0;;
    DWORD  dwAccessDesired = 0;
    DWORD  dwACLSize = 0;
    DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
    PACL   pACL            = NULL;
    PSID   psidLocalSystem  = NULL;
    BOOL   bReturn        =  FALSE;

    PRIVILEGE_SET   ps;
    GENERIC_MAPPING GenericMapping;

    PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    CSATraceFunc objTraceFunc ("CHelper::IsOperationAllowedForClient ");
       
    do
    {
        //
        // we assume to always have a thread token, because the function calling in
        // appliance manager will be impersonating the client
        //
        bReturn  = OpenThreadToken(
                               GetCurrentThread(), 
                               TOKEN_QUERY, 
                               FALSE, 
                               &hToken
                               );
        if (!bReturn)
        {
            SATraceFailure ("CHelper::IsOperationAllowedForClient failed on OpenThreadToken:", GetLastError ());
            break;
        }


        //
        // Create a SID for Local System account
        //
        bReturn = AllocateAndInitializeSid (  
                                        &SystemSidAuthority,
                                        1,
                                        SECURITY_LOCAL_SYSTEM_RID,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        &psidLocalSystem
                                        );
        if (!bReturn)
        {     
            SATraceFailure ("CHelper:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  GetLastError ());
            break;
        }
    
        //
        // get memory for the security descriptor
        //
        psdAdmin = HeapAlloc (
                              GetProcessHeap (),
                              0,
                              SECURITY_DESCRIPTOR_MIN_LENGTH
                              );
        if (NULL == psdAdmin)
        {
            SATraceString ("CHelper::IsOperationForClientAllowed failed on HeapAlloc");
            bReturn = FALSE;
            break;
        }
      
        bReturn = InitializeSecurityDescriptor(
                                            psdAdmin,
                                            SECURITY_DESCRIPTOR_REVISION
                                            );
        if (!bReturn)
        {
            SATraceFailure ("CHelper::IsOperationForClientAllowed failed on InitializeSecurityDescriptor:", GetLastError ());
            break;
        }

        // 
        // Compute size needed for the ACL.
        //
        dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                    GetLengthSid (psidLocalSystem);

        //
        // Allocate memory for ACL.
        //
        pACL = (PACL) HeapAlloc (
                                GetProcessHeap (),
                                0,
                                dwACLSize
                                );
        if (NULL == pACL)
        {
            SATraceString ("CHelper::IsOperationForClientAllowed failed on HeapAlloc2");
            bReturn = FALSE;
            break;
        }

        //
        // Initialize the new ACL.
        //
        bReturn = InitializeAcl(
                              pACL, 
                              dwACLSize, 
                              ACL_REVISION2
                              );
        if (!bReturn)
        {
            SATraceFailure ("CHelper::IsOperationForClientAllowed failed on InitializeAcl", GetLastError ());
            break;
        }


        // 
        // Make up some private access rights.
        // 
        const DWORD SA_ACCESS_READ = 1;
        const DWORD  SA_ACCESS_WRITE = 2;
        dwAccessMask= SA_ACCESS_READ | SA_ACCESS_WRITE;

        //
        // Add the access-allowed ACE to the DACL for Local System
        //
        bReturn = AddAccessAllowedAce (
                                    pACL, 
                                    ACL_REVISION2,
                                    dwAccessMask, 
                                    psidLocalSystem
                                    );
        if (!bReturn)
        {
            SATraceFailure ("CHelper::IsOperationForClientAllowed failed on AddAccessAllowedAce (LocalSystem)", GetLastError ());
            break;
        }
              
        //
        // Set our DACL to the SD.
        //
        bReturn = SetSecurityDescriptorDacl (
                                          psdAdmin, 
                                          TRUE,
                                          pACL,
                                          FALSE
                                          );
        if (!bReturn)
        {
            SATraceFailure ("CHelper::IsOperationForClientAllowed failed on SetSecurityDescriptorDacl", GetLastError ());
            break;
        }

        //
        // AccessCheck is sensitive about what is in the SD; set
        // the group and owner.
        //
        SetSecurityDescriptorGroup(psdAdmin, psidLocalSystem, FALSE);
        SetSecurityDescriptorOwner(psdAdmin, psidLocalSystem, FALSE);

        bReturn = IsValidSecurityDescriptor(psdAdmin);
        if (!bReturn)
        {
            SATraceFailure ("CHelper::IsOperationForClientAllowed failed on IsValidSecurityDescriptorl", GetLastError ());
            break;
        }
     

        dwAccessDesired = SA_ACCESS_READ;

        // 
        // Initialize GenericMapping structure even though we
        // won't be using generic rights.
        // 
        GenericMapping.GenericRead    = SA_ACCESS_READ;
        GenericMapping.GenericWrite   = SA_ACCESS_WRITE;
        GenericMapping.GenericExecute = 0;
        GenericMapping.GenericAll     = SA_ACCESS_READ | SA_ACCESS_WRITE;
        BOOL bAccessStatus = FALSE;

        //
        // check the access now
        //
        bReturn = AccessCheck  (
                                psdAdmin, 
                                hToken, 
                                dwAccessDesired, 
                                &GenericMapping, 
                                &ps,
                                &dwStructureSize, 
                                &dwStatus, 
                                &bAccessStatus
                                );

        if (!bReturn || !bAccessStatus)
        {
            SATraceFailure ("CHelper::IsOperationForClientAllowed failed on AccessCheck", GetLastError ());
        } 
        else
        {
            SATraceString ("CHelper::IsOperationForClientAllowed, Client is allowed to carry out operation!");
        }

        //
        // successfully checked 
        //
        bReturn  = bAccessStatus;        
 
    }    
    while (false);

    //
    // Cleanup 
    //
    if (pACL) 
    {
        HeapFree (GetProcessHeap (), 0, pACL);
    }

    if (psdAdmin) 
    {
        HeapFree (GetProcessHeap (), 0, psdAdmin);
    }
          

    if (psidLocalSystem) 
    {
        FreeSid(psidLocalSystem);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return (bReturn);

}// end of CHelper::IsOperationValidForClient method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\componentfactorymap.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      componentfactory.h
//
// Project:     Chameleon
//
// Description: Component Factory Class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_COMPONENT_FACTORY_MAP_H_
#define __INC_COMPONENT_FACTORY_MAP_H_

#include "servicewrapper.h"

//////////////////////////////////////////////////////////////////////////////
BEGIN_COMPONENT_FACTORY_MAP(TheFactoryMap)
    DEFINE_COMPONENT_FACTORY_ENTRY(CLASS_SERVICE_WRAPPER_FACTORY, CServiceWrapper)
END_COMPONENT_FACTORY_MAP()

#endif // __INC_COMPONENT_FACTORY_MAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\sahelper\sahelper.cpp ===
// sahelper.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f sasu.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "sahelper.h"
#include "sahelper_i.c"
#include "helper.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAHelper, CHelper)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\exceptionfilter.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      ExceptionFilter.h
//
// Project:     Chameleon
//
// Description: Exception Filter Class Defintion
//
// Log: 
//
// Who     When            What
// ---     ----         ----
// TLP       05/14/1999    Original Version
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __MY_EXCEPTION_FILTER_H_
#define __MY_EXCEPTION_FILTER_H_

#include "resource.h"       // main symbols

#define        APPLIANCE_SURROGATE_EXCEPTION    0x12345678

typedef LONG (WINAPI *PFNEXCEPTIONHANDLER)(PEXCEPTION_POINTERS);

/////////////////////////////////////////////////////////////////////////////
// CExceptionFilter

class CExceptionFilter
{

public:

    CExceptionFilter();

    ~CExceptionFilter();

    void 
    SetExceptionHandler(
                /*[in]*/ PFNEXCEPTIONHANDLER pfnExceptionHandler
                       );
private:

    // Disallow copy and assignment
    CExceptionFilter(const CExceptionFilter& rhs);
    CExceptionFilter& operator = (const CExceptionFilter& rhs);

    // Default exception handler
    static LONG 
    DefaultExceptionHandler(
                    /*[in]*/ PEXCEPTION_POINTERS pExecptionInfo
                           );

    // My unhandled exception filter
    static LONG WINAPI 
    MyUnhandledExceptionFilter(
                       /*[in]*/ PEXCEPTION_POINTERS pExecptionInfo
                              );

    // Exception handler
    static PFNEXCEPTIONHANDLER                m_pExceptionHandler;

    // Previous unhandled exception filter
    static LPTOP_LEVEL_EXCEPTION_FILTER        m_pPreviousFilter;
};

#endif // __MY_EXCEPTION_FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\exceptionfilter.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      exceptionfilter.cpp
//
// Project:     Chameleon
//
// Description: Exception Filter Class Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/26/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "exceptionfilter.h"
#include <satrace.h>

// Declare this processes unhandled exception filter
CExceptionFilter    g_ProcessUEF;

// Static class members
LPTOP_LEVEL_EXCEPTION_FILTER    CExceptionFilter::m_pPreviousFilter = NULL;
PFNEXCEPTIONHANDLER                CExceptionFilter::m_pExceptionHandler = NULL;

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CExceptionFilter()
//
// Synopsis: Constructor
//
/////////////////////////////////////////////////////////////////////////////
CExceptionFilter::CExceptionFilter()
{
    m_pPreviousFilter = SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: ~CExceptionFilter()
//
// Synopsis: Destructor
//
/////////////////////////////////////////////////////////////////////////////
CExceptionFilter::~CExceptionFilter()
{
    SetUnhandledExceptionFilter(m_pPreviousFilter);
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: SetExceptionHandler()
//
// Synopsis: Specify the exception handler to call in the event of an
//           exception. If an exception handler is not specified then
//             DefaultExceptionHandler() handles the exception. 
//
/////////////////////////////////////////////////////////////////////////////
void
CExceptionFilter::SetExceptionHandler(
                              /*[in]*/ PFNEXCEPTIONHANDLER pfnExceptionHandler
                                     )
{
    _ASSERT( pfnExceptionHandler );
    m_pExceptionHandler = pfnExceptionHandler;
}


/////////////////////////////////////////////////////////////////////////////
// 
// Function: DefaultExceptionHandler()
//
// Synopsis: Default exception handler for processes.
//
/////////////////////////////////////////////////////////////////////////////
LONG
CExceptionFilter::DefaultExceptionHandler(
                                  /*[in]*/ PEXCEPTION_POINTERS pExceptionInfo
                                         )
{
    return EXCEPTION_EXECUTE_HANDLER; 
}

    
/////////////////////////////////////////////////////////////////////////////
// 
// Function: MyExceptionFilter()
//
// Synopsis: Exception filter for processes - called by Win32 subsystem.
//
/////////////////////////////////////////////////////////////////////////////
LONG WINAPI 
CExceptionFilter::MyUnhandledExceptionFilter(
                                 /*[in]*/ PEXCEPTION_POINTERS pExceptionInfo
                                            )
{
    if ( CExceptionFilter::m_pExceptionHandler )
    {
        return (CExceptionFilter::m_pExceptionHandler)(pExceptionInfo);
    }
    
    return CExceptionFilter::DefaultExceptionHandler(pExceptionInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by servicesurrogate.rc
//
#define IDS_SERVICENAME                 100
#define IDR_Servicesurrogate            100
#define IDR_SERVICESURROGATE1           101
#define IDS_SERVICENICENAME             103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\exceptioninfo.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      exceptioninfo.h
//
// Project:     Chameleon
//
// Description: Exception Information Class Definition
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/12/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __SA_EXCEPTIONINFO_H_
#define __SA_EXCEPTIONINFO_H_

// #include "resource.h"       

/////////////////////////////////////////////////////////////////////////////
// 
// Name: CExceptionInfo
//
// What: Exception information class
//
/////////////////////////////////////////////////////////////////////////////
class CExceptionInfo 
{
    
public:

    CExceptionInfo(
           /*[in]*/ DWORD              dwProcessID,
           /*[in]*/ PEXCEPTION_RECORD pER
                  );

    ~CExceptionInfo() { }

    void Spew(void);

    void Report(void);

private:

    // No assignment
    CExceptionInfo& operator = (const CExceptionInfo& rhs);

    /////////////////////////////////////////////
    // Private member data

    typedef enum 
    { 
        MAX_MODULE_NAME = 256,
        MAX_SYMBOL_NAME = 256            
    };

    typedef enum _ACCESS_TYPE
    {
        UNKNOWN_ACCESS = 0,
        READ_ACCESS,
        WRITE_ACCESS

    } ACCESS_TYPE;

    // Process where the exception occurred
    WCHAR        m_szProcessName[MAX_MODULE_NAME + 1];

    // Full path of the module where the exception occurred
    WCHAR        m_szModuleName[MAX_MODULE_NAME + 1];

    // Virtual address where exception occurred
    PVOID        m_pExceptionAddress;

    // Type of exception (see WaitForDebugEvent()
    DWORD        m_dwExceptionCode; 

    // Time and date (UTC Time - Number of seconds since midnight Jan 1 1970) of exception
    LONG        m_lTimeDateStamp;

    // Set to true if the exception was an access violation
    bool        m_bAccessViolation;

    // Used if m_bAccessViolation is set to true 
    ACCESS_TYPE    m_eAccessType;

    // Used if m_bAccessViolation is set to true 
    DWORD        m_dwVirtualAddressAccessed;

    // Process handle
    DWORD        m_dwProcessID;

    // Successfully initialized (constructed)
    bool        m_bInitialized;
};


#endif __SA_EXCEPTIONINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\servicesurrogateimpl.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      ServiceSurrogateImpl.h
//
// Project:     Chameleon
//
// Description: Appliance Service Surrogate Class Defintion
//
// Log: 
//
// Who     When            What
// ---     ----         ----
// TLP       06/14/1999    Original Version
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __SERVICE_SURROGATE_IMPL_H_
#define __SERVICE_SURROGATE_IMPL_H_

#include "resource.h"       // main symbols

#pragma warning( disable : 4786 )
#include <map>
#include <string>
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CServiceSurrogate

class ATL_NO_VTABLE CServiceSurrogate : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CServiceSurrogate, &CLSID_ServiceSurrogate>,
    public IDispatchImpl<IApplianceObject, &IID_IApplianceObject, &LIBID_SERVICESURROGATELib>
{

public:

    CServiceSurrogate();

    ~CServiceSurrogate();

DECLARE_CLASSFACTORY_SINGLETON(CServiceSurrogate)

DECLARE_REGISTRY_RESOURCEID(IDR_SERVICESURROGATE1)

DECLARE_NOT_AGGREGATABLE(CServiceSurrogate)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CServiceSurrogate)
    COM_INTERFACE_ENTRY(IApplianceObject)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:

    //////////////////////////////////////////////////////////////////////
    // IApplianceObject methods

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(GetProperty)(
                   /*[in]*/ BSTR     pszPropertyName, 
          /*[out, retval]*/ VARIANT* pPropertyValue
                          );

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(PutProperty)(
                   /*[in]*/ BSTR     pszPropertyName, 
                   /*[in]*/ VARIANT* pPropertyValue
                          );

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(SaveProperties)(void);

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(RestoreProperties)(void);

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(LockObject)(
         /*[out, retval]*/ IUnknown** ppLock
                         );

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(Initialize)(void);

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(Shutdown)(void);

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(Enable)(void);

    //////////////////////////////////////////////////////////////////////////
    STDMETHOD(Disable)(void);


private:

    // Initialization / Shutdown helper functions

    HRESULT 
    CreateServiceWrappers(void);

    void 
    ReleaseServiceWrappers(void);
    
    // Provider Class ID to Service Name map
    typedef map< wstring, wstring >        WMIClassMap;
    typedef WMIClassMap::iterator        WMIClassMapIterator;

    // Service Name to Service Wrapper Object Map
    typedef map< wstring, CComPtr<IApplianceObject> > ServiceWrapperMap;
    typedef ServiceWrapperMap::iterator                  ServiceWrapperMapIterator;

    // Service surrogate state. Set to true after 
    // IApplianceObject::Initialize() has completed.
    bool                m_bInitialized;

    // WMI Provider Class ID to Service Name map
    WMIClassMap            m_WMIClassMap;

    // Service Name to Service Wrapper map
    ServiceWrapperMap    m_ServiceWrapperMap;
};

#endif // __SERVICE_SURROGATE_IMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\exceptioninfo.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      exceptioninfo.cpp
//
// Project:     Chameleon
//
// Description: Exception Information Class Implementation
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/12/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "exceptioninfo.h"
#include <time.h>
#include <psapi.h>
#include <comdef.h>
#include <comutil.h>
#include <varvec.h>
#include <satrace.h>

wchar_t szUnknown[] = L"Unknown";

/////////////////////////////////////////////////////////////////////////////
// 
// Name: CExceptionInfo
//
// What: Class constructor 
//
/////////////////////////////////////////////////////////////////////////////
CExceptionInfo::CExceptionInfo(
                       /*[in]*/ DWORD              dwProcessID,
                       /*[in]*/ PEXCEPTION_RECORD pER
                              )
                              : m_dwProcessID(dwProcessID),
                                m_pExceptionAddress(NULL),
                                m_lTimeDateStamp(0),
                                m_dwExceptionCode(0),
                                m_bAccessViolation(false),
                                m_eAccessType(UNKNOWN_ACCESS),
                                m_dwVirtualAddressAccessed(0)
{
    // Object initialization
    lstrcpy(m_szProcessName, szUnknown);
    lstrcpy(m_szModuleName, szUnknown);

    // Get the process handle
    HANDLE hProcess = OpenProcess(
                                  PROCESS_ALL_ACCESS,
                                  FALSE,
                                  m_dwProcessID
                                 );
    if ( NULL == hProcess )
    {
        SATracePrintf("CExceptionInfo::CExceptionInfo() - OpenProcess(%d) failed with error: %lx", m_dwProcessID, GetLastError());
    }
    else
    {
        // Save the current time (approximate time of exception)
        time_t ltime;
        m_lTimeDateStamp = time(&ltime);
        // Get the process name
        HMODULE hMod;
        DWORD cbNeeded;
        if ( EnumProcessModules( 
                                hProcess, 
                                &hMod, 
                                sizeof(hMod), 
                                &cbNeeded) 
                               )
        {
            GetModuleBaseName( 
                                hProcess, 
                                hMod, 
                                m_szProcessName, 
                                MAX_MODULE_NAME
                             );
        }
        // Glean exception information from the debug event structure
        m_dwExceptionCode = pER->ExceptionCode;
        m_pExceptionAddress = pER->ExceptionAddress;
        MEMORY_BASIC_INFORMATION mbi;
        if ( VirtualQueryEx( 
                             hProcess, 
                             (void *)m_pExceptionAddress, 
                             &mbi, 
                             sizeof(mbi) 
                           ) )
        {
            hMod = (HMODULE)(mbi.AllocationBase);
            if ( ! GetModuleFileNameEx( 
                                        hProcess,
                                        (HMODULE)hMod, 
                                        m_szModuleName, 
                                        MAX_MODULE_NAME
                                      ) )
            {
                SATracePrintf("CExceptionInfo::CExceptionInfo() - GetModuleFileName() failed with last error: %d", GetLastError());
            }
        }
        else
        {
            SATracePrintf("CExceptionInfo::CExceptionInfo() - VirtualQueryEx() failed with last error: %d", GetLastError());
        }
        if ( EXCEPTION_ACCESS_VIOLATION == m_dwExceptionCode )
        {
            m_bAccessViolation = true;
            if ( pER->ExceptionInformation[0] )
            {
                m_eAccessType = WRITE_ACCESS;
            }
            else
            {
                m_eAccessType = READ_ACCESS;
            }
        }

        CloseHandle(hProcess);
    }
}


/////////////////////////////////////////////////////////////////////////////
// 
// Name: Spew
//
// What: Output exception information to trace log
//
/////////////////////////////////////////////////////////////////////////////

wchar_t* pszAccessType[] = 
{
    L"Unknown Access",
    L"Read Access",
    L"Write Access"
};

void
CExceptionInfo::Spew()
{

    SATraceString("CExceptionInfo::Spew() - Exception Info:");
    SATraceString("------------------------------------------------------------");
    SATracePrintf("Process Name:             %ls", m_szProcessName);
    SATracePrintf("Process ID:               %d",  m_dwProcessID);
    SATracePrintf("Module Location:          %ls", m_szModuleName);
    SATracePrintf("Exception Address:        %lx", m_pExceptionAddress);
    SATracePrintf("Exception Code:           %lx", m_dwExceptionCode);
    LPWSTR pszTime = _wctime(&m_lTimeDateStamp);
    *(wcschr(pszTime, '\n')) = ' ';
    SATracePrintf("Timestamp:                %ls", pszTime);
    if ( m_bAccessViolation )
    {
        SATraceString("Is Access Violation:      Yes");
    }
    else
    {
        SATraceString("Is Access Violation:      No");
    }
    SATracePrintf("Access Type:              %ls", pszAccessType[m_eAccessType]);
    SATracePrintf("Virtual Address Accessed: %lx", m_dwVirtualAddressAccessed);
    SATraceString("------------------------------------------------------------");

    // So I can veiw the the spew...
    // Sleep(15000);
}


wchar_t szProcessResourceType[] = L"{b4c08260-1869-11d3-bf7f-00105a1f3461}";

/////////////////////////////////////////////////////////////////////////////
// 
// Name: Report
//
// What: Report the exception to the appliance monitor
//
/////////////////////////////////////////////////////////////////////////////
void CExceptionInfo::Report()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\servicesurrogate.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      servicesurrogate.cpp
//
// Project:     Chameleon
//
// Description: WinMain() and COM Local Server Scaffolding.
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 06/14/1999   TLP    Initial Version (Mostly produced by Dev Studio)
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "servicesurrogate.h"
#include "servicesurrogateimpl.h"
#include "exceptioninfo.h"
#include "exceptionfilter.h"
#include <satrace.h>
// #include <stdio.h>

CServiceModule _Module;

//
// method to set ACLs
//
DWORD
SetAclForComObject  ( 
    /*[in]*/            PSECURITY_DESCRIPTOR pSD,
    /*[out]*/   PACL                *ppacl 
        );


//////////////////////////////////////////////////////////////////////////////
// Change these for a new service...

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ServiceSurrogate, CServiceSurrogate)
END_OBJECT_MAP()

const DWORD   dwServiceIDR = IDR_Servicesurrogate;
const wchar_t szServiceAppID[] = L"{51DA63F4-24D9-11D3-BF9E-00105A1F3461}";


/////////////////////////////////////////////////////////////////////////////
extern CExceptionFilter    g_ProcessUEF;

//////////////////////////////////////////////////////////////////////////////
// 
// Function: ServiceUEF()
//
// Synopsis: Process wide unhandled exception handler
//
//////////////////////////////////////////////////////////////////////////////
LONG WINAPI
ServiceUEF(
  /*[in]*/ PEXCEPTION_POINTERS pExceptionInfo
          )  
{
    DWORD dwProcessId = GetCurrentProcessId();
    HANDLE hProcess = GetCurrentProcess();
    if ( EXCEPTION_BREAKPOINT == pExceptionInfo->ExceptionRecord->ExceptionCode )
    {
        if (  APPLIANCE_SURROGATE_EXCEPTION == pExceptionInfo->ExceptionRecord->ExceptionInformation[0] )
        {
            SATracePrintf("ServiceUEF() for: '%ls' - Terminating process: %d due to a resource constraint violation", _Module.m_szServiceName, dwProcessId);
            TerminateProcess(hProcess, 1);
        }
    }
    else
    {
        SATracePrintf("ServiceUEF() for: '%ls' - Unhandled exception in process %d", _Module.m_szServiceName, dwProcessId);
        _Module.RevokeClassObjects();
        CExceptionInfo cei(dwProcessId, pExceptionInfo->ExceptionRecord);
        cei.Spew();
        cei.Report();
        TerminateProcess(hProcess, 1);
    }
    return EXCEPTION_EXECUTE_HANDLER; 
}

//////////////////////////////////////////////////////////////////////////////
// 
// Function: StartMyService()
//
// Synopsis: Perform service specific startup functions
//
//////////////////////////////////////////////////////////////////////////////
bool StartMyService()
{
    g_ProcessUEF.SetExceptionHandler(ServiceUEF);
    return true;
}

//////////////////////////////////////////////////////////////////////////////
// 
// Function: StopMyService()
//
// Synopsis: Perform service specific shutdown functions
//
//////////////////////////////////////////////////////////////////////////////
bool StopMyService()
{
    return true;
}


///////////////////////////////////////////////////////////////////////////////
LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// Although some of these functions are big they are declared inline 
// since they are only used once
///////////////////////////////////////////////////////////////////////////////

#define SERVICE_NAME            L"srvcsurg"

#define EVENT_LOG_KEY            L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" SERVICE_NAME

#define    EVENT_SOURCE_EXTENSION    L"dll"

///////////////////////////////////////////////////////////////////////////////
inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if ( FAILED(hr) )
    {
        return hr;
    }

    do
    {
        // Remove any previous service since it may point to
        // the incorrect file
        // Uninstall();

        // Add service entries
        UpdateRegistryFromResource(dwServiceIDR, TRUE);

        // Adjust the AppID for Local Server or Service
        CRegKey keyAppID;
        LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRes);
            break;
        }

        CRegKey key;
        lRes = key.Open(keyAppID, szServiceAppID, KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRes);
            break;
        }

        key.DeleteValue(_T("LocalService"));
    
        if (bService)
        {
            key.SetValue(SERVICE_NAME, _T("LocalService"));
            key.SetValue(_T("-Service"), _T("ServiceParameters"));

            // Create the event message file registry entry. Assume the name of
            // the event message file is the same as the name of the service
            // executable except we replace the ".exe" extension by ".dll".
            WCHAR szFilePath[_MAX_PATH +1];
            DWORD dwResult = ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);
            if (0 == dwResult)
            {
                hr = HRESULT_FROM_WIN32(GetLastError ());
                break;
            }
            szFilePath [MAX_PATH] = L'\0';
    
            WCHAR* pszExtension = wcschr(szFilePath, L'.');
            pszExtension++;
            lstrcpy(pszExtension, EVENT_SOURCE_EXTENSION);
            CRegKey EventLogKey;
            DWORD dwError = EventLogKey.Create(
                                                HKEY_LOCAL_MACHINE,
                                                 EVENT_LOG_KEY,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_SET_VALUE
                                              );
            if ( ERROR_SUCCESS != dwError) 
            {
                hr = HRESULT_FROM_WIN32(dwError);
                break;
            }
            dwError = EventLogKey.SetValue(szFilePath, L"EventMessageFile");
            if ( ERROR_SUCCESS != dwError ) 
            { 
                hr = HRESULT_FROM_WIN32(dwError);
                break;
            }

            // Create the NT service
            Install();
        }

        // Add object entries
        hr = CComModule::RegisterServer(bRegTypeLib);

    } while ( FALSE );

    CoUninitialize();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(dwServiceIDR, FALSE);

    // Remove service
    Uninstall();
    // Remove object entries

    // ToddP - Below is the only code that is not generic in this module.
    // TLP - No ATL 3.0...
    CComModule::UnregisterServer(&CLSID_ServiceSurrogate /* TRUE */ );
    // CComModule::UnregisterServer(TRUE);
    // ToodP - End of non-generic code...

    CoUninitialize();
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    // TLP - No ATL 3.0...
    CComModule::Init(p, h /*, plibid */ );
    // CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));
    LoadString(h, IDS_SERVICENICENAME, m_szServiceNiceName, sizeof(m_szServiceNiceName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}


///////////////////////////////////////////////////////////////////////////////
LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}


///////////////////////////////////////////////////////////////////////////////
BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH +1];
    DWORD dwResult = ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);
    if (0 == dwResult)
    {
        return (FALSE);
    }
    szFilePath [MAX_PATH] = L'\0';

    SC_HANDLE hService = ::CreateService(
                                          hSCM, 
                                          m_szServiceName, 
                                          m_szServiceNiceName,
                                          SERVICE_ALL_ACCESS, 
                                          SERVICE_WIN32_OWN_PROCESS,
                                          SERVICE_DEMAND_START, 
                                          SERVICE_ERROR_NORMAL,
                                          szFilePath, 
                                          NULL, 
                                          NULL, 
                                          _T("RPCSS\0"), // Requires RPC Service
                                          NULL, 
                                          NULL
                                        );

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// Logging functions
///////////////////////////////////////////////////////////////////////////////

void CServiceModule::LogEvent(
                             /*[in]*/ WORD        wMsgType,
                             /*[in]*/ LONG        lMsgID,
                             /*[in]*/ DWORD        dwMsgParamCount,
                             /*[in]*/ LPCWSTR*    pszMsgParams,
                             /*[in]*/ DWORD        dwDataSize,
                             /*[in]*/ BYTE*        pData
                              )
{
    if ( m_bService )
    {
        // Get a handle to use with ReportEvent().
        HANDLE hEventSource = RegisterEventSource( NULL, m_szServiceName );
        if ( NULL != hEventSource )
        {
            // Write to event log.
            ReportEvent(
                         hEventSource, 
                         wMsgType, 
                         0, 
                         lMsgID, 
                         NULL, 
                         dwMsgParamCount, 
                         dwDataSize, 
                         pszMsgParams, 
                         pData
                       );

            // Free the event source
            DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        wchar_t szMsg[128] = L"Logged Event: ";
        wchar_t szEventID[16];
        lstrcat(szMsg, _itow(lMsgID, szEventID, 16));
        _putts(szMsg);
    }
}


///////////////////////////////////////////////////////////////////////////////
// Service startup and registration
///////////////////////////////////////////////////////////////////////////////

inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };

    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
    {
        Run();
    }
}

///////////////////////////////////////////////////////////////////////////////
inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler 

    // TODO: ToddP - Why would this fail? If so what action can we take?
    //       Currently the watchdog timer would eventually cause a system reboot.

    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    
    if (m_hServiceStatus == NULL)
    {
        SATraceString ("Service Surrogate failed to register as a service");
        return;
    }

    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();
}


///////////////////////////////////////////////////////////////////////////////
inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            // Post a thread quit message - picked up inside of the Run() function
            PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
            break;

        case SERVICE_CONTROL_PAUSE:
            break;

        case SERVICE_CONTROL_CONTINUE:
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        default:

            // ToddP - Just ignore the unrecognized request. Should never
            //         happen if practice.
            _ASSERT(FALSE);
            // LogEvent(_T("Bad service request"));
    }
}


///////////////////////////////////////////////////////////////////////////////
void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}


///////////////////////////////////////////////////////////////////////////////
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}


///////////////////////////////////////////////////////////////////////////////
void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}


///////////////////////////////////////////////////////////////////////////////
void CServiceModule::Run()
{
    _Module.dwThreadID = GetCurrentThreadId();

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( SUCCEEDED(hr) )
    {
        // Initialize security for the service process

        // RPC_C_AUTHN_LEVEL_CONNECT 
        // Authenticates the credentials of the client only when the client 
        // establishes a relationship with the server. 
        // Datagram transports always use RPC_AUTHN_LEVEL_PKT instead. 

        // RPC_C_IMP_LEVEL_IMPERSONATE 
        // The server process can impersonate the client's security
        // context while acting on behalf of the client. This level of
        // impersonation can be used to access local resources such as files. 
        // When impersonating at this level, the impersonation token can only 
        // be passed across one machine boundary. 
        // In order for the impersonation token to be passed, you must use 
        // Cloaking, which is available in Windows NT 5.0. 

        CSecurityDescriptor sd;
        sd.InitializeFromThreadToken();

        PACL pacl = NULL;
           //
            // 
            // Add ACLs to the SD using the builtin RIDs.
            //
            DWORD dwRetVal =  SetAclForComObject  ( 
                        (PSECURITY_DESCRIPTOR) sd.m_pSD,
                        &pacl        
                            );    
                if (ERROR_SUCCESS != dwRetVal)      {return;}

        //
        // do initialize security now
        //
        hr = CoInitializeSecurity(
                                    sd, 
                                    -1, 
                                    NULL, 
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                                    RPC_C_IMP_LEVEL_IDENTIFY, 
                                    NULL, 
                                    EOAC_NONE, 
                                    NULL
                                 );
        _ASSERTE(SUCCEEDED(hr));
        if ( SUCCEEDED(hr) )
        {

            // Register the class with COM
            hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
            _ASSERTE(SUCCEEDED(hr));
            if ( SUCCEEDED(hr) )
            {
                // Do service specific startup
                if ( StartMyService() )
                {
                    // Now allow COM clients to connect
                    CoResumeClassObjects();

                    SetServiceStatus(SERVICE_RUNNING);
                    MSG msg;
                    while (GetMessage(&msg, 0, 0, 0))
                        DispatchMessage(&msg);

                    SetServiceStatus(SERVICE_STOP_PENDING);

                    // Now do service specific shutdown
                    StopMyService();

                    SetServiceStatus(SERVICE_STOPPED);
                }

                _Module.RevokeClassObjects();
            }
        }

        //
        // cleanup
        //
        if (pacl) {LocalFree (pacl);}
        
        CoUninitialize();
    }
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    // ToddP - Below is the only code that is not generic in this module.
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_SERVICESURROGATELib);
    // ToddP - End of non-eneric code...

    _Module.m_bService = TRUE;

    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);
        
        // Register as Service
        if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);
        
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, szServiceAppID, KEY_READ);

    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}

//
// method for providing only the Local System and Admins rights 
// to access the COM object
//
DWORD
SetAclForComObject ( 
    /*[in]*/    PSECURITY_DESCRIPTOR pSD,
    /*[out]*/   PACL                *ppacl 
    )
{    
    DWORD              dwError = ERROR_SUCCESS;
        int                         cbAcl = 0;
        PACL                    pacl = NULL;
        PSID                    psidLocalSystemSid = NULL;
     PSID                    psidAdminSid = NULL;
       SID_IDENTIFIER_AUTHORITY siaLocalSystemSidAuthority = SECURITY_NT_AUTHORITY;

    do
    {
        if (NULL == pSD)
        {
            SATraceString ("SetAclFromComObject - invalid parameter passed in");
            dwError = ERROR_INVALID_PARAMETER;
            break;
        }
            
        //
        // Create a SID for Local System account
        //
            BOOL bRetVal = AllocateAndInitializeSid (  
                            &siaLocalSystemSidAuthority,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0,
                            0,
                            0,
                            0,
                            0,
                          0,
                            0,
                            &psidLocalSystemSid 
                            );
        if (!bRetVal)
        {     
            dwError = GetLastError ();
                SATraceFailure ("SetAclFromComObject:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  dwError);
                break;
            }

        //
            // Create a SID for Admin group
            //
            bRetVal = AllocateAndInitializeSid (  
                            &siaLocalSystemSidAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &psidAdminSid
                            );
        if (!bRetVal)
        {      
            dwError = GetLastError ();
                SATraceFailure ("SetAclFromComObject:AllocateAndInitializeSid (Admin) failed",  dwError);
                break;
            }

        //
            // Calculate the length of required ACL buffer
            // with 2 ACEs.
            //
            cbAcl =     sizeof (ACL)
                            +   2 * sizeof (ACCESS_ALLOWED_ACE)
                            +   GetLengthSid( psidAdminSid )
                            +   GetLengthSid( psidLocalSystemSid );

            pacl = (PACL) LocalAlloc ( 0, cbAcl );
            if (NULL == pacl) 
            {
                dwError = ERROR_OUTOFMEMORY;
                SATraceFailure ("SetAclFromComObject::LocalAlloc failed:", dwError);
            break;
            }

        //
        // initialize the ACl now
        //
            bRetVal =InitializeAcl ( 
                        pacl,
                                cbAcl,
                                ACL_REVISION2
                                );
            if (!bRetVal)
            {
                 dwError = GetLastError();
            SATraceFailure ("SetAclFromComObject::InitializeAcl failed:", dwError);
                break;
            }

        //
            // Add ACE with EVENT_ALL_ACCESS for Local System account
            //
            bRetVal = AddAccessAllowedAce ( 
                            pacl,
                                        ACL_REVISION2,
                                        COM_RIGHTS_EXECUTE,
                                        psidLocalSystemSid
                                        );
        if (!bRetVal)
        {
                dwError = GetLastError();
                SATraceFailure ("SetAclFromComObject::AddAccessAllowedAce (LOCAL SYSTEM)  failed:", dwError);
            break;
        }

        //
            // Add ACE with EVENT_ALL_ACCESS for Admin Group
            //
            bRetVal = AddAccessAllowedAce ( 
                            pacl,
                                        ACL_REVISION2,
                                        COM_RIGHTS_EXECUTE,
                                        psidAdminSid
                                        );
        if (!bRetVal)
        {
                dwError = GetLastError();
                     SATraceFailure ("SetAclFromComObject::AddAccessAllowedAce (ADMIN) failed:", dwError);
            break;
        }

        //
            // Set the ACL which allows EVENT_ALL_ACCESS for all users and
            // Local System to the security descriptor.
            bRetVal = SetSecurityDescriptorDacl (   
                            pSD,
                                            TRUE,
                                            pacl,
                                            FALSE 
                                            );
        if (!bRetVal)
        {
                dwError = GetLastError();
                     SATraceFailure ("SetAclFromComObject::SetSecurityDescriptorDacl failed:", dwError);
            break;
        }
    
        //
        // success
        //
    }
    while (false);

    //
    // in case of error, cleanup
    //
     if (dwError) 
     {
            if ( pacl ) 
            {
                   LocalFree ( pacl );
            }
        }
        else 
        {
            *ppacl = pacl;
        }
        
    //
    // free up resources now
    //
    if ( psidLocalSystemSid ) {FreeSid ( psidLocalSystemSid );}
    if ( psidAdminSid ) {FreeSid ( psidAdminSid );}

        return (dwError);
        
}//End of SetAclFromComObject method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\servicesurrogateimpl.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      ServiceSurrogateImpl.cpp
//
// Project:     Chameleon
//
// Description: Appliance Service Surrogate Class Defintion
//
// Log: 
//
// Who     When            What
// ---     ----         ----
// TLP       06/14/1999    Original Version
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Servicesurrogate.h"
#include "ServiceSurrogateImpl.h"
#include "servicewrapper.h"
#include <componentfactory.h>
#include <appmgrobjs.h>
#include <propertybagfactory.h>
#include <atlhlpr.h>
#include <comdef.h>
#include <comutil.h>
#include <satrace.h>

// The service surrogate process provides a context for Chameleon services.
// It hosts the service control component (component that exports the
// IApplianceObject interface) as well as the WMI provider that exposes 
// service resources (if present).

// Chameleon services are isolated from other Chameleon components so the
// impact of an unhandled exception or other component misbehavior is
// isolated to this process. The surrogate process contains an unhandled
// exception filter which, by default, notifies the appliance monitor that
// a resource failure has occured before terminating the process.

// The surrogate process may be monitored for termination and automatically
// restarted upon termination. In this case, component misbehavior may not
// impact the end user if Chameleon services are automatically restarted
// by the process termination monitor. 

/////////////////////////////////////////////////////////////////////////////
// CServiceSurrogate Class Implmentation

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CServiceSurrogate()
//
// Synopsis: Constructor
//
/////////////////////////////////////////////////////////////////////////////
CServiceSurrogate::CServiceSurrogate() 
: m_bInitialized(false)
{ 

}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: ~CServiceSurrogate()
//
// Synopsis: Destructor
//
/////////////////////////////////////////////////////////////////////////////
CServiceSurrogate::~CServiceSurrogate()
{
    ReleaseServiceWrappers();
}

//////////////////////////////////////////////////////////////////////
// IApplianceObject Interface Implementation

const _bstr_t    bstrProcessId = L"SurrogateProcessId";

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceSurrogate::GetProperty(
                       /*[in]*/ BSTR     bstrPropertyName, 
              /*[out, retval]*/ VARIANT* pPropertyValue
                              )
{
    _ASSERT( NULL != bstrPropertyName && NULL != pPropertyValue );
    if ( NULL == bstrPropertyName || NULL == pPropertyValue )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = E_FAIL;

    CLockIt theLock(*this);

    TRY_IT
    
    if ( m_bInitialized )
    {
        // Is the caller asking for the surrogate process id?
        if ( ! lstrcmpi(bstrPropertyName, (BSTR)bstrProcessId) )
        {
            // Yes... 
            V_I4(pPropertyValue) = (LONG)GetCurrentProcessId();
            V_VT(pPropertyValue) = VT_I4;
            hr = S_OK;
         }
        else
        {
            // No... the caller must be asking for the primary interface
            // IApplianceObject on one of the service wrappers. First 
            // check to see if the name is resolved via the WMI class map.
            // if not then use it directly since its supposed to be a 
            // service name in this case.
            ServiceWrapperMapIterator q;
            WMIClassMapIterator p = m_WMIClassMap.find(bstrPropertyName);
            if ( p != m_WMIClassMap.end() )
            {
                q = m_ServiceWrapperMap.find((*p).second.c_str());
            }
            else
            {
                q = m_ServiceWrapperMap.find(bstrPropertyName);
            }
            if ( q != m_ServiceWrapperMap.end() )
            {
                V_VT(pPropertyValue) = VT_UNKNOWN;
                V_UNKNOWN(pPropertyValue) = (IUnknown*)((*q).second);
                (V_UNKNOWN(pPropertyValue))->AddRef();
                hr = S_OK;
            }
            else
            {
                SATracePrintf("CServiceSurrogate::GetProperty() - Failed - Could not locate property '%ls'", bstrPropertyName);
            }
        }
    }
    else
    {
        SATraceString("CServiceSurrogate::GetProperty() - Surrogate is not initialized...");
    }

    CATCH_AND_SET_HR

    return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceSurrogate::PutProperty(
                        /*[in]*/ BSTR     pszPropertyName, 
                        /*[in]*/ VARIANT* pPropertyValue
                              )
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceSurrogate::SaveProperties(void)
{
    return E_NOTIMPL;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceSurrogate::RestoreProperties(void)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceSurrogate::LockObject(
             /*[out, retval]*/ IUnknown** ppLock
                             )
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceSurrogate::Initialize(void)
{
    HRESULT hr = S_OK;
    
    CLockIt theLock(*this);

    TRY_IT
    
    if ( ! m_bInitialized )
    {
        SATraceString("The Service Surrogate is initializing...");
        hr = CreateServiceWrappers();        
        if ( SUCCEEDED(hr) )
        {
            m_bInitialized = true;
            SATraceString("The Service Surrogate was succuessfully initialized...");
        }
    }

    CATCH_AND_SET_HR
    return hr;

}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceSurrogate::Shutdown(void)
{
    HRESULT hr = S_OK;
    
    CLockIt theLock(*this);

    TRY_IT
    
    if ( m_bInitialized )
    {
        SATraceString("The Service Surrogate is shutting down...");
        ReleaseServiceWrappers();        
        m_bInitialized = false;
        SATraceString("The Service Surrogate was shutdown...");
    }

    CATCH_AND_SET_HR
    return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceSurrogate::Enable(void)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceSurrogate::Disable(void)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// Private Methods
//////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
// The following registry structure is assumed:
//
// HKLM\SYSTEM\CurrentControlSet\Services\ApplianceManager
//
// ObjectManagers
//       |
//        - Microsoft_SA_Service
//       |     |
//       |      - ServiceX
//       |     |  (ServiceX Properties - 'ProgID' and 'WMIProviderCLSID'
//       |     |  .
//         |     |  .
//       |     |  .
//       |      - ServiceY
//       |     |  (ServiceY Properties - 'ProgID and 'WMIProviderCLSID'
//       |

// ObjectManagers registry key location
const wchar_t szObjectManagers[] = L"SOFTWARE\\Microsoft\\ServerAppliance\\ApplianceManager\\ObjectManagers\\";

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CreateServiceWrappers()
//
// Synopsis: Creates the container of service wrapper object references
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CServiceSurrogate::CreateServiceWrappers()
{
    HRESULT hr = E_FAIL;

    try
    {
        SATraceString("The Service Surrogate is creating the Chameleon services...");

        wchar_t szServicesPath[MAX_PATH + 1];
        lstrcpy( szServicesPath, szObjectManagers);
        lstrcat( szServicesPath, CLASS_WBEM_SERVICE);

        CLocationInfo LocInfo(HKEY_LOCAL_MACHINE, szServicesPath);
        PPROPERTYBAGCONTAINER pServices = ::MakePropertyBagContainer(
                                                                      PROPERTY_BAG_REGISTRY,
                                                                      LocInfo
                                                                    );
        do
        {
            if ( ! pServices.IsValid() )
            { 
                SATraceString("CServiceSurrogate::CreateServiceWrappers() - Failed - Invalid property bag container");
                break;
            }
            if ( ! pServices->open() )
            { 
                SATraceString("CServiceSurrogate::CreateServiceWrappers() - Failed - Could not open services property bag container");
                break;
            }
            if ( pServices->count() )
            {
                pServices->reset();
                do
                {
                    hr = E_FAIL;

                    PPROPERTYBAG pCurSrvc = pServices->current();
                    if ( ! pCurSrvc.IsValid() )
                    { 
                        SATraceString("CServiceSurrogate::CreateServiceWrappers() - Failed - Invalid property bag");
                        break;
                    }
                    if ( ! pCurSrvc->open() )
                    {
                        SATraceString("CServiceSurrogate::CreateServiceWrappers() - Failed - Could not open property bag");
                        break;
                    }
                    _variant_t vtServiceName;
                    if ( ! pCurSrvc->get(PROPERTY_SERVICE_NAME, &vtServiceName) )
                    {
                        SATracePrintf("CServiceSurrogate::CreateServiceWrapper() - Failed - Could not get property '%ls' for service: '%ls'", PROPERTY_SERVICE_NAME, pCurSrvc->getName());
                        break;
                    }
                    if ( VT_BSTR != V_VT(&vtServiceName) )
                    {
                        SATracePrintf("CServiceSurrogate::CreateServiceWrapper() - Failed - Unexpected type for property '%ls'", PROPERTY_SERVICE_NAME);
                        break;
                    }
                    CComPtr<IApplianceObject> pAppObj = (IApplianceObject*) ::MakeComponent(
                                                                                             CLASS_SERVICE_WRAPPER_FACTORY,
                                                                                             pCurSrvc
                                                                                           );
                    if ( NULL == (IApplianceObject*)pAppObj )
                    { 
                        SATracePrintf("CServiceSurrogate::CreateServiceWrapper() - Failed - Could not create wrapper for service: '%ls'", V_BSTR(&vtServiceName));
                        break;
                    }
                    pair<ServiceWrapperMapIterator, bool> thePair = 
                    m_ServiceWrapperMap.insert(ServiceWrapperMap::value_type(V_BSTR(&vtServiceName), pAppObj));
                    if ( false == thePair.second )
                    { 
                        SATracePrintf("CServiceSurrogate::CreateServiceWrapper() - Failed - Map insert failed for service: '%ls'", V_BSTR(&vtServiceName));
                        break;
                    }
                    _variant_t vtWMIProviderCLSID;
                    if ( pCurSrvc->get(PROPERTY_SERVICE_PROVIDER_CLSID, &vtWMIProviderCLSID) )
                    {
                        if ( VT_BSTR != V_VT(&vtWMIProviderCLSID) )
                        {
                            SATracePrintf("CServiceSurrogate::CreateServiceWrapper() - Failed - Unexpected type for property '%ls'", PROPERTY_SERVICE_PROVIDER_CLSID);
                            break;
                        }
                        _wcsupr(V_BSTR(&vtWMIProviderCLSID));
                        pair<WMIClassMapIterator, bool> thePair1 = 
                        m_WMIClassMap.insert(WMIClassMap::value_type(V_BSTR(&vtWMIProviderCLSID), V_BSTR(&vtServiceName)));
                        if ( false == thePair1.second )
                        { 
                            SATracePrintf("CServiceSurrogate::CreateServiceWrapper() - Failed - Map insert failed for WMI CLSID: '%ls'", V_BSTR(&vtWMIProviderCLSID));
                            break;
                        }
                        else
                        {
                            SATracePrintf("CServiceSurrogate::CreateServiceWrapper() - Info - WMI Provider '%ls' added to the map...", V_BSTR(&vtWMIProviderCLSID));
                        }
                    }
                    else
                    {
                        SATracePrintf("CServiceSurrogate::CreateServiceWrapper() - Info - No WMI provider was defined for service '%ls'", V_BSTR(&vtServiceName));
                    }

                    SATracePrintf("The Service Surrogate successfully created service '%ls'", V_BSTR(&vtServiceName));

                    hr = S_OK;

                } while ( pServices->next() );
            }
            else
            {
                hr = S_OK;
                SATraceString("CServiceSurrogate::CreateServiceWrapper() - Info - No services defined (empty container)");
            }

        } while ( FALSE );
    }
    catch(...)
    {
        SATraceString("CServiceSurrogate::CreateServiceWrapper() - Failed - Caught unhandled exception");
        hr = E_FAIL;
    }

    if ( FAILED(hr) )
    {
        ReleaseServiceWrappers();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// 
// Function: ReleaseServiceWrappers()
//
// Synopsis: Creates the container of service wrapper object references
//
/////////////////////////////////////////////////////////////////////////////
void
CServiceSurrogate::ReleaseServiceWrappers()
{
    ServiceWrapperMapIterator p = m_ServiceWrapperMap.begin();
    while ( p != m_ServiceWrapperMap.end() )
    {
        p = m_ServiceWrapperMap.erase(p);
    }

    WMIClassMapIterator q = m_WMIClassMap.begin();
    while (    q != m_WMIClassMap.end() )
    {
        q = m_WMIClassMap.erase(q);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\exceptionfilter.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      exceptionfilter.cpp
//
// Project:     Chameleon
//
// Description: Exception Filter Class Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/26/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "exceptionfilter.h"
#include <satrace.h>

// Declare this processes unhandled exception filter
CExceptionFilter    g_ProcessUEF;

// Static class members
LPTOP_LEVEL_EXCEPTION_FILTER    CExceptionFilter::m_pPreviousFilter = NULL;
PFNEXCEPTIONHANDLER                CExceptionFilter::m_pExceptionHandler = NULL;

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CExceptionFilter()
//
// Synopsis: Constructor
//
/////////////////////////////////////////////////////////////////////////////
CExceptionFilter::CExceptionFilter()
{
    m_pPreviousFilter = SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: ~CExceptionFilter()
//
// Synopsis: Destructor
//
/////////////////////////////////////////////////////////////////////////////
CExceptionFilter::~CExceptionFilter()
{
    SetUnhandledExceptionFilter(m_pPreviousFilter);
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: SetExceptionHandler()
//
// Synopsis: Specify the exception handler to call in the event of an
//           exception. If an exception handler is not specified then
//             DefaultExceptionHandler() handles the exception. 
//
/////////////////////////////////////////////////////////////////////////////
void
CExceptionFilter::SetExceptionHandler(
                              /*[in]*/ PFNEXCEPTIONHANDLER pfnExceptionHandler
                                     )
{
    _ASSERT( pfnExceptionHandler );
    m_pExceptionHandler = pfnExceptionHandler;
}


/////////////////////////////////////////////////////////////////////////////
// 
// Function: DefaultExceptionHandler()
//
// Synopsis: Default exception handler for processes.
//
/////////////////////////////////////////////////////////////////////////////
LONG
CExceptionFilter::DefaultExceptionHandler(
                                  /*[in]*/ PEXCEPTION_POINTERS pExceptionInfo
                                         )
{
    return EXCEPTION_EXECUTE_HANDLER; 
}

    
/////////////////////////////////////////////////////////////////////////////
// 
// Function: MyExceptionFilter()
//
// Synopsis: Exception filter for processes - called by Win32 subsystem.
//
/////////////////////////////////////////////////////////////////////////////
LONG WINAPI 
CExceptionFilter::MyUnhandledExceptionFilter(
                                 /*[in]*/ PEXCEPTION_POINTERS pExceptionInfo
                                            )
{
    if ( CExceptionFilter::m_pExceptionHandler )
    {
        return (CExceptionFilter::m_pExceptionHandler)(pExceptionInfo);
    }
    
    return CExceptionFilter::DefaultExceptionHandler(pExceptionInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\exceptioninfo.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      exceptioninfo.cpp
//
// Project:     Chameleon
//
// Description: Exception Information Class Implementation
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/12/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "exceptioninfo.h"
#include <time.h>
#include <psapi.h>
#include <comdef.h>
#include <comutil.h>
#include <varvec.h>
#include <satrace.h>

wchar_t szUnknown[] = L"Unknown";

/////////////////////////////////////////////////////////////////////////////
// 
// Name: CExceptionInfo
//
// What: Class constructor 
//
/////////////////////////////////////////////////////////////////////////////
CExceptionInfo::CExceptionInfo(
                       /*[in]*/ DWORD              dwProcessID,
                       /*[in]*/ PEXCEPTION_RECORD pER
                              )
                              : m_dwProcessID(dwProcessID),
                                m_pExceptionAddress(NULL),
                                m_lTimeDateStamp(0),
                                m_dwExceptionCode(0),
                                m_bAccessViolation(false),
                                m_eAccessType(UNKNOWN_ACCESS),
                                m_dwVirtualAddressAccessed(0)
{
    // Object initialization
    lstrcpy(m_szProcessName, szUnknown);
    lstrcpy(m_szModuleName, szUnknown);

    // Get the process handle
    HANDLE hProcess = OpenProcess(
                                  PROCESS_ALL_ACCESS,
                                  FALSE,
                                  m_dwProcessID
                                 );
    if ( NULL == hProcess )
    {
        SATracePrintf("CExceptionInfo::CExceptionInfo() - OpenProcess(%d) failed with error: %lx", m_dwProcessID, GetLastError());
    }
    else
    {
        // Save the current time (approximate time of exception)
        time_t ltime;
        m_lTimeDateStamp = time(&ltime);
        // Get the process name
        HMODULE hMod;
        DWORD cbNeeded;
        if ( EnumProcessModules( 
                                hProcess, 
                                &hMod, 
                                sizeof(hMod), 
                                &cbNeeded) 
                               )
        {
            GetModuleBaseName( 
                                hProcess, 
                                hMod, 
                                m_szProcessName, 
                                MAX_MODULE_NAME
                             );
        }
        // Glean exception information from the debug event structure
        m_dwExceptionCode = pER->ExceptionCode;
        m_pExceptionAddress = pER->ExceptionAddress;
        MEMORY_BASIC_INFORMATION mbi;
        if ( VirtualQueryEx( 
                             hProcess, 
                             (void *)m_pExceptionAddress, 
                             &mbi, 
                             sizeof(mbi) 
                           ) )
        {
            hMod = (HMODULE)(mbi.AllocationBase);
            if ( ! GetModuleFileNameEx( 
                                        hProcess,
                                        (HMODULE)hMod, 
                                        m_szModuleName, 
                                        MAX_MODULE_NAME
                                      ) )
            {
                SATracePrintf("CExceptionInfo::CExceptionInfo() - GetModuleFileName() failed with last error: %d", GetLastError());
            }
        }
        else
        {
            SATracePrintf("CExceptionInfo::CExceptionInfo() - VirtualQueryEx() failed with last error: %d", GetLastError());
        }
        if ( EXCEPTION_ACCESS_VIOLATION == m_dwExceptionCode )
        {
            m_bAccessViolation = true;
            if ( pER->ExceptionInformation[0] )
            {
                m_eAccessType = WRITE_ACCESS;
            }
            else
            {
                m_eAccessType = READ_ACCESS;
            }
        }

        CloseHandle(hProcess);
    }
}


/////////////////////////////////////////////////////////////////////////////
// 
// Name: Spew
//
// What: Output exception information to trace log
//
/////////////////////////////////////////////////////////////////////////////

wchar_t* pszAccessType[] = 
{
    L"Unknown Access",
    L"Read Access",
    L"Write Access"
};

void
CExceptionInfo::Spew()
{

    SATraceString("CExceptionInfo::Spew() - Exception Info:");
    SATraceString("------------------------------------------------------------");
    SATracePrintf("Process Name:             %ls", m_szProcessName);
    SATracePrintf("Process ID:               %d",  m_dwProcessID);
    SATracePrintf("Module Location:          %ls", m_szModuleName);
    SATracePrintf("Exception Address:        %lx", m_pExceptionAddress);
    SATracePrintf("Exception Code:           %lx", m_dwExceptionCode);
    LPWSTR pszTime = _wctime(&m_lTimeDateStamp);
    *(wcschr(pszTime, '\n')) = ' ';
    SATracePrintf("Timestamp:                %ls", pszTime);
    if ( m_bAccessViolation )
    {
        SATraceString("Is Access Violation:      Yes");
    }
    else
    {
        SATraceString("Is Access Violation:      No");
    }
    SATracePrintf("Access Type:              %ls", pszAccessType[m_eAccessType]);
    SATracePrintf("Virtual Address Accessed: %lx", m_dwVirtualAddressAccessed);
    SATraceString("------------------------------------------------------------");

    // So I can veiw the the spew...
    // Sleep(15000);
}


wchar_t szProcessResourceType[] = L"{b4c08260-1869-11d3-bf7f-00105a1f3461}";

/////////////////////////////////////////////////////////////////////////////
// 
// Name: Report
//
// What: Report the exception to the appliance monitor
//
/////////////////////////////////////////////////////////////////////////////
void CExceptionInfo::Report()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\exceptionfilter.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      ExceptionFilter.h
//
// Project:     Chameleon
//
// Description: Exception Filter Class Defintion
//
// Log: 
//
// Who     When            What
// ---     ----         ----
// TLP       05/14/1999    Original Version
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __MY_EXCEPTION_FILTER_H_
#define __MY_EXCEPTION_FILTER_H_

#include "resource.h"       // main symbols

#define        APPLIANCE_SURROGATE_EXCEPTION    0x12345678

typedef LONG (WINAPI *PFNEXCEPTIONHANDLER)(PEXCEPTION_POINTERS);

/////////////////////////////////////////////////////////////////////////////
// CExceptionFilter

class CExceptionFilter
{

public:

    CExceptionFilter();

    ~CExceptionFilter();

    void 
    SetExceptionHandler(
                /*[in]*/ PFNEXCEPTIONHANDLER pfnExceptionHandler
                       );
private:

    // Disallow copy and assignment
    CExceptionFilter(const CExceptionFilter& rhs);
    CExceptionFilter& operator = (const CExceptionFilter& rhs);

    // Default exception handler
    static LONG 
    DefaultExceptionHandler(
                    /*[in]*/ PEXCEPTION_POINTERS pExecptionInfo
                           );

    // My unhandled exception filter
    static LONG WINAPI 
    MyUnhandledExceptionFilter(
                       /*[in]*/ PEXCEPTION_POINTERS pExecptionInfo
                              );

    // Exception handler
    static PFNEXCEPTIONHANDLER                m_pExceptionHandler;

    // Previous unhandled exception filter
    static LPTOP_LEVEL_EXCEPTION_FILTER        m_pPreviousFilter;
};

#endif // __MY_EXCEPTION_FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\servicewrapper.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      servicewrapper.cpp
//
// Project:     Chameleon
//
// Description: Service Wrapper Class Implemenation.
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 06/14/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "servicewrapper.h"

// Currently the only "value add"  of the service wrapper is that it 
// disallows WMI calls if the associated Chameleon service is disabled
// or shutdown. However, additional filtering or front end processing
// capabilities can be added if needed.

// There is a one to one correspondence between instances of the 
// service wrapper class and Chameleon services.

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CServiceWrapper()
//
// Synopsis: Constructor
//
/////////////////////////////////////////////////////////////////////////////
CServiceWrapper::CServiceWrapper()
: m_clsProviderInit(this),
  m_bAllowWMICalls(false)
{

}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: ~CServiceWrapper()
//
// Synopsis: Destructor
//
/////////////////////////////////////////////////////////////////////////////
CServiceWrapper::~CServiceWrapper()
{

}


//////////////////////////////////////////////////////////////////////////////
// IWbemProviderInit Interface

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::CProviderInit::Initialize(
                                   /*[in]*/ LPWSTR                 wszUser,
                                   /*[in]*/ LONG                   lFlags,
                                   /*[in]*/ LPWSTR                 wszNamespace,
                                   /*[in]*/ LPWSTR                 wszLocale,
                                   /*[in]*/ IWbemServices*         pNamespace,
                                   /*[in]*/ IWbemContext*          pCtx,
                                   /*[in]*/ IWbemProviderInitSink* pInitSink    
                                         )
{
    // WMI will serialize the calls to Initialize as long as specified to
    // do so in the .mof file. The default provider setting is seralize
    // calls to initialize.
    HRESULT hr = WBEM_E_FAILED;
    IWbemProviderInit* pProviderInit;
    if ( m_pSW->GetIWbemProviderInit(&pProviderInit) )
    {
        hr = pProviderInit->Initialize(
                                        wszUser,
                                        lFlags,
                                        wszNamespace,
                                        wszLocale,
                                        pNamespace,
                                        pCtx,
                                        pInitSink
                                      );
            
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IWbemEventProvider Interface

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::ProvideEvents(
                        /*[in]*/ IWbemObjectSink *pSink,
                        /*[in]*/ LONG lFlags
                               )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemEventProvider* pEventProvider;
    if ( GetIWbemEventProvider(&pEventProvider) )
    {
        hr = pEventProvider->ProvideEvents(
                                            pSink,
                                            lFlags
                                          );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IWbemEventConsumerProvider Interface

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::FindConsumer(
                      /*[in]*/ IWbemClassObject       *pLogicalConsumer,
                     /*[out]*/ IWbemUnboundObjectSink **ppConsumer
                             )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemEventConsumerProvider* pEventConsumer;
    if ( GetIWbemEventConsumerProvider(&pEventConsumer) )
    {
        hr = pEventConsumer->FindConsumer(
                                            pLogicalConsumer,
                                            ppConsumer
                                          );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IWbemServices Interface

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::OpenNamespace(
                        /*[in]*/  const BSTR        strNamespace,
                        /*[in]*/  long              lFlags,
                        /*[in]*/  IWbemContext*     pCtx,
             /*[out, OPTIONAL]*/  IWbemServices**   ppWorkingNamespace,
             /*[out, OPTIONAL]*/  IWbemCallResult** ppResult
                               )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->OpenNamespace(
                                        strNamespace,
                                        lFlags,
                                        pCtx,
                                        ppWorkingNamespace,
                                        ppResult
                                     );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::CancelAsyncCall(
                          /*[in]*/ IWbemObjectSink* pSink
                                 )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->CancelAsyncCall(
                                         pSink
                                       );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::QueryObjectSink(
                          /*[in]*/    long              lFlags,
                         /*[out]*/ IWbemObjectSink** ppResponseHandler
                                 )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->QueryObjectSink(
                                         lFlags,
                                         ppResponseHandler
                                       );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::GetObject(
                    /*[in]*/ const BSTR         strObjectPath,
                    /*[in]*/ long               lFlags,
                    /*[in]*/ IWbemContext*      pCtx,
         /*[out, OPTIONAL]*/ IWbemClassObject** ppObject,
         /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                           )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->GetObject(
                                    strObjectPath,
                                    lFlags,
                                    pCtx,
                                    ppObject,
                                    ppCallResult
                                 );
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::GetObjectAsync(
                         /*[in]*/  const BSTR       strObjectPath,
                         /*[in]*/  long             lFlags,
                         /*[in]*/  IWbemContext*    pCtx,        
                         /*[in]*/  IWbemObjectSink* pResponseHandler
                                )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->GetObjectAsync(
                                        strObjectPath,
                                        lFlags,
                                        pCtx,        
                                        pResponseHandler
                                      );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::PutClass(
                   /*[in]*/ IWbemClassObject* pObject,
                   /*[in]*/ long              lFlags,
                   /*[in]*/ IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                          )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->PutClass(
                                    pObject,
                                    lFlags,
                                    pCtx,
                                    ppCallResult
                                );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::PutClassAsync(
                        /*[in]*/ IWbemClassObject* pObject,
                        /*[in]*/ long              lFlags,
                        /*[in]*/ IWbemContext*     pCtx,        
                        /*[in]*/ IWbemObjectSink*  pResponseHandler
                               )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->PutClassAsync(
                                        pObject,
                                        lFlags,
                                        pCtx,        
                                        pResponseHandler
                                     );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::DeleteClass(
                      /*[in]*/ const BSTR        strClass,
                      /*[in]*/ long              lFlags,
                      /*[in]*/ IWbemContext*     pCtx,        
           /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                             )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->DeleteClass(
                                    strClass,
                                    lFlags,
                                    pCtx,
                                    ppCallResult
                                   );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::DeleteClassAsync(
                           /*[in]*/ const BSTR       strClass,
                           /*[in]*/ long             lFlags,
                           /*[in]*/ IWbemContext*    pCtx,        
                           /*[in]*/ IWbemObjectSink* pResponseHandler
                                  )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->DeleteClassAsync(
                                         strClass,
                                         lFlags,
                                         pCtx,        
                                         pResponseHandler
                                        );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::CreateClassEnum(
                          /*[in]*/ const BSTR             strSuperclass,
                          /*[in]*/ long                   lFlags,
                          /*[in]*/ IWbemContext*          pCtx,        
                         /*[out]*/ IEnumWbemClassObject** ppEnum
                                 )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->CreateClassEnum(
                                         strSuperclass,
                                         lFlags,
                                         pCtx,
                                         ppEnum
                                       );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::CreateClassEnumAsync(
                               /*[in]*/  const BSTR       strSuperclass,
                               /*[in]*/  long             lFlags,
                               /*[in]*/  IWbemContext*    pCtx,        
                               /*[in]*/  IWbemObjectSink* pResponseHandler
                                      )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->CreateClassEnumAsync(
                                             strSuperclass,
                                             lFlags,
                                             pCtx,        
                                             pResponseHandler
                                            );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::PutInstance(
                      /*[in]*/ IWbemClassObject* pInst,
                      /*[in]*/ long              lFlags,
                      /*[in]*/ IWbemContext*     pCtx,        
           /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                             )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->PutInstance(
                                     pInst,
                                     lFlags,
                                     pCtx,
                                     ppCallResult
                                   );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::PutInstanceAsync(
                           /*[in]*/ IWbemClassObject* pInst,
                           /*[in]*/ long              lFlags,
                           /*[in]*/ IWbemContext*     pCtx,        
                           /*[in]*/ IWbemObjectSink*  pResponseHandler
                                  )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->PutInstanceAsync(
                                         pInst,
                                         lFlags,
                                         pCtx,        
                                         pResponseHandler
                                        );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::DeleteInstance(
                         /*[in]*/   const BSTR        strObjectPath,
                         /*[in]*/   long              lFlags,
                         /*[in]*/   IWbemContext*     pCtx,        
              /*[out, OPTIONAL]*/   IWbemCallResult** ppCallResult        
                                )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->DeleteInstance(
                                        strObjectPath,
                                        lFlags,
                                        pCtx,        
                                        ppCallResult        
                                      );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::DeleteInstanceAsync(
                              /*[in]*/ const BSTR       strObjectPath,
                              /*[in]*/ long             lFlags,
                              /*[in]*/ IWbemContext*    pCtx,        
                              /*[in]*/ IWbemObjectSink* pResponseHandler
                                     )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->DeleteInstanceAsync(
                                             strObjectPath,
                                             lFlags,
                                             pCtx,        
                                             pResponseHandler
                                           );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::CreateInstanceEnum(
                             /*[in]*/ const BSTR             strClass,
                             /*[in]*/ long                   lFlags,
                             /*[in]*/ IWbemContext*          pCtx,        
                            /*[out]*/ IEnumWbemClassObject** ppEnum
                                    )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->CreateInstanceEnum(
                                            strClass,
                                            lFlags,
                                            pCtx,        
                                            ppEnum
                                          );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::CreateInstanceEnumAsync(
                                  /*[in]*/ const BSTR       strClass,
                                  /*[in]*/ long             lFlags,
                                  /*[in]*/ IWbemContext*    pCtx,        
                                  /*[in]*/ IWbemObjectSink* pResponseHandler
                                         )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->CreateInstanceEnumAsync(
                                                 strClass,
                                                 lFlags,
                                                 pCtx,        
                                                 pResponseHandler
                                               );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::ExecQuery(
                    /*[in]*/ const BSTR             strQueryLanguage,
                    /*[in]*/ const BSTR             strQuery,
                    /*[in]*/ long                   lFlags,
                    /*[in]*/ IWbemContext*          pCtx,        
                   /*[out]*/ IEnumWbemClassObject** ppEnum
                           )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->ExecQuery(
                                    strQueryLanguage,
                                    strQuery,
                                    lFlags,
                                    pCtx,        
                                    ppEnum
                                 );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::ExecQueryAsync(
                         /*[in]*/ const BSTR       strQueryLanguage,
                         /*[in]*/ const BSTR       strQuery,
                         /*[in]*/ long             lFlags,
                         /*[in]*/ IWbemContext*    pCtx,        
                         /*[in]*/ IWbemObjectSink* pResponseHandler
                                )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->ExecQueryAsync(
                                        strQueryLanguage,
                                        strQuery,
                                        lFlags,
                                        pCtx,        
                                        pResponseHandler
                                      );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::ExecNotificationQuery(
                                /*[in]*/ const BSTR             strQueryLanguage,
                                /*[in]*/ const BSTR             strQuery,
                                /*[in]*/ long                   lFlags,
                                /*[in]*/ IWbemContext*          pCtx,        
                               /*[out]*/ IEnumWbemClassObject** ppEnum
                                       )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->ExecNotificationQuery(
                                                strQueryLanguage,
                                                strQuery,
                                                lFlags,
                                                pCtx,        
                                                ppEnum
                                             );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::ExecNotificationQueryAsync(
                                     /*[in]*/ const BSTR       strQueryLanguage,
                                     /*[in]*/ const BSTR       strQuery,
                                     /*[in]*/ long             lFlags,
                                     /*[in]*/ IWbemContext*    pCtx,        
                                     /*[in]*/ IWbemObjectSink* pResponseHandler
                                            )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->ExecNotificationQueryAsync(
                                                    strQueryLanguage,
                                                    strQuery,
                                                    lFlags,
                                                    pCtx,        
                                                    pResponseHandler
                                                  );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::ExecMethod(
        /*[in]*/            const BSTR         strObjectPath,
        /*[in]*/            const BSTR         strMethodName,
        /*[in]*/            long               lFlags,
        /*[in]*/            IWbemContext*      pCtx,        
        /*[in]*/            IWbemClassObject*  pInParams,
        /*[out, OPTIONAL]*/ IWbemClassObject** ppOutParams,
        /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                            )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->ExecMethod(
                                    strObjectPath,
                                    strMethodName,
                                    lFlags,
                                    pCtx,        
                                    pInParams,
                                    ppOutParams,
                                    ppCallResult
                                   );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CServiceWrapper::ExecMethodAsync(
                          /*[in]*/ const BSTR        strObjectPath,
                          /*[in]*/ const BSTR        strMethodName,
                          /*[in]*/ long              lFlags,
                          /*[in]*/ IWbemContext*     pCtx,        
                          /*[in]*/ IWbemClassObject* pInParams,
                          /*[in]*/ IWbemObjectSink*  pResponseHandler     
                                 )
{
    HRESULT hr = WBEM_E_FAILED;
    IWbemServices* pServices;
    if ( GetIWbemServices(&pServices) )
    {
        hr = pServices->ExecMethodAsync(
                                        strObjectPath,
                                        strMethodName,
                                        lFlags,
                                        pCtx,        
                                        pInParams,
                                        pResponseHandler     
                                       );
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// IApplianceObject Interface

// Note that the service wrapper is not created if the underlying
// Chameleon service component cannot be instantiated. 
//
// Thus m_pServiceControl should always be valid in the IApplianceObject
// interface methods.
// 
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceWrapper::GetProperty(
                     /*[in]*/ BSTR     bstrPropertyName, 
            /*[out, retval]*/ VARIANT* pPropertyValue
                               )
{
    _ASSERT( (IUnknown*)m_pServiceControl );
    return m_pServiceControl->GetProperty(bstrPropertyName, pPropertyValue);
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceWrapper::PutProperty(
                     /*[in]*/ BSTR     bstrPropertyName, 
                     /*[in]*/ VARIANT* pPropertyValue
                            )
{
    _ASSERT( (IUnknown*)m_pServiceControl );
    return m_pServiceControl->PutProperty(bstrPropertyName, pPropertyValue);
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceWrapper::SaveProperties(void)
{
    _ASSERT( (IUnknown*)m_pServiceControl );
    return m_pServiceControl->SaveProperties();
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceWrapper::RestoreProperties(void)
{
    _ASSERT( (IUnknown*)m_pServiceControl );
    return m_pServiceControl->RestoreProperties();
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceWrapper::LockObject(
           /*[out, retval]*/ IUnknown** ppLock
                           )
{
    _ASSERT( (IUnknown*)m_pServiceControl );
    return m_pServiceControl->LockObject(ppLock);
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceWrapper::Initialize(void)
{
    _ASSERT( (IUnknown*)m_pServiceControl );
    HRESULT hr = m_pServiceControl->Initialize();
    CLockIt theLock(*this);
    if ( SUCCEEDED(hr) )
    {
        // Allow WMI calls since the service is initialized
        m_bAllowWMICalls = true;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceWrapper::Shutdown(void)
{
    _ASSERT( (IUnknown*)m_pServiceControl );
    HRESULT hr = m_pServiceControl->Shutdown();
    CLockIt theLock(*this);
    if ( SUCCEEDED(hr) )
    {
        // Disallow WMI calls since the service is shutdown
        m_bAllowWMICalls = false;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceWrapper::Enable(void)
{
    _ASSERT( (IUnknown*)m_pServiceControl );
    HRESULT hr = m_pServiceControl->Enable();
    CLockIt theLock(*this);
    if ( SUCCEEDED(hr) )
    {
        // Allow WMI calls since the service is enabled
        m_bAllowWMICalls = true;
    }
    return hr;

}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CServiceWrapper::Disable(void)
{
    _ASSERT( (IUnknown*)m_pServiceControl );
    HRESULT hr = m_pServiceControl->Disable();
    CLockIt theLock(*this);
    if ( SUCCEEDED(hr) )
    {
        // Disallow WMI calls since the service is disabled
        m_bAllowWMICalls = false;
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT 
CServiceWrapper::InternalInitialize(
                            /*[in]*/ PPROPERTYBAG pPropertyBag
                                   )
{
    HRESULT hr = E_FAIL;
    CLSID    clsid;

    TRY_IT

    do
    {
        // Create the hosted service components (InProc Servers) and obtain
        // references to the appropriate component interfaces.

        _variant_t vtProperty;
        if ( ! pPropertyBag->get(PROPERTY_SERVICE_PROGID, &vtProperty) )
        {
            SATraceString("CServiceWrapper::InternalInitialize() - Failed - could not get service progID property");
            break;
        }
        if ( VT_BSTR != V_VT(&vtProperty) )
        {
            hr = E_FAIL;
            SATraceString("CServiceWrapper::InternalInitialize() - Failed - Unexpected type for service progID property");
            break;
        }
        hr = CLSIDFromProgID(V_BSTR(&vtProperty), &clsid);
        if ( FAILED(hr) )
        {
            SATracePrintf("CServiceWrapper::InternalInitialize() - Failed - CLSIDFromProgID() returned: %lx", hr);
            break;
        }
        hr = CoCreateInstance(
                              clsid,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IApplianceObject,
                              (void**)&m_pServiceControl
                             );
        if ( FAILED(hr) )
        {
            SATracePrintf("CServiceWrapper::InternalInitialize() - Failed - CoCreateInstance(Service) returned: %lx", hr);
            break;
        }
        vtProperty.Clear();
        if ( ! pPropertyBag->get(PROPERTY_SERVICE_PROVIDER_CLSID, &vtProperty) )
        {
            // OK - No WMI provider associated with this service
            break;
        }
        if ( VT_BSTR != V_VT(&vtProperty) )
        {
            hr = E_FAIL;
            SATraceString("CServiceWrapper::InternalInitialize() - Failed - Unexpected type for WMI Provider CLSID property");
            break;
        }
        hr = CLSIDFromString(V_BSTR(&vtProperty), &clsid);
        if ( FAILED(hr) )
        {
            SATracePrintf("CServiceWrapper::InternalInitialize() - Failed - CLSIDFromString() returned: %lx", hr);
            break;
        }
        CComPtr<IUnknown> pUnknown;
        hr = CoCreateInstance(
                              clsid,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IUnknown,
                              (void**)&pUnknown
                             );
        if ( FAILED(hr) )
        {
            m_pServiceControl.Release();
            SATracePrintf("CServiceWrapper::InternalInitialize() - Failed - CoCreateInstance(Provider) returned: %lx", hr);
            break;
        }
        if ( FAILED(pUnknown->QueryInterface(IID_IWbemProviderInit, (void**)&m_pProviderInit)) )
        {
            SATracePrintf("CServiceWrapper::InternalInitialize() - Info - WMI provider for service '%ls' does not support IWbemProviderInit", pPropertyBag->getName()); 
        }
        if ( FAILED(pUnknown->QueryInterface(IID_IWbemEventProvider, (void**)&m_pEventProvider)) )
        {
            SATracePrintf("CServiceWrapper::InternalInitialize() - Info - WMI provider for service '%ls' does not support IWbemEventProvider", pPropertyBag->getName()); 
        }
        if ( FAILED(pUnknown->QueryInterface(IID_IWbemEventConsumerProvider, (void**)&m_pEventConsumer)) )
        {
            SATracePrintf("CServiceWrapper::InternalInitialize() - Info - WMI provider for service '%ls' does not support IWbemEventConsumerProvider", pPropertyBag->getName()); 
        }
        if ( FAILED(pUnknown->QueryInterface(IID_IWbemServices, (void**)&m_pServices)) )
        {
            SATracePrintf("CServiceWrapper::InternalInitialize() - Info - WMI provider for service '%ls' does not support IWbemServices", pPropertyBag->getName()); 
        }

    } while ( FALSE );

    CATCH_AND_SET_HR

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Private methods

//////////////////////////////////////////////////////////////////////////////
bool 
CServiceWrapper::GetIWbemProviderInit(
                             /*[out]*/ IWbemProviderInit** ppIntf
                                     )
{
    CLockIt theLock(*this);
    if ( m_bAllowWMICalls )
    {
        if ( NULL !=  (IWbemProviderInit*) m_pProviderInit )
        {
            *ppIntf = (IWbemProviderInit*) m_pProviderInit;
            return true;
        }
        *ppIntf = NULL;
    }
    return false;
}

//////////////////////////////////////////////////////////////////////////////
bool
CServiceWrapper::GetIWbemEventProvider(
                              /*[out]*/ IWbemEventProvider** ppIntf
                                      )
{
    CLockIt theLock(*this);
    if ( m_bAllowWMICalls )
    {
        if ( NULL != (IWbemEventProvider*) m_pEventProvider )
        {
            *ppIntf = (IWbemEventProvider*) m_pEventProvider;
            return true;
        }
        *ppIntf = NULL;
    }
    return false;
}

//////////////////////////////////////////////////////////////////////////////
bool
CServiceWrapper::GetIWbemEventConsumerProvider(
                                      /*[out]*/ IWbemEventConsumerProvider** ppIntf
                                              )
{
    CLockIt theLock(*this);
    if ( m_bAllowWMICalls )
    {
        if ( NULL != (IWbemEventConsumerProvider*) m_pEventConsumer )
        {
            *ppIntf = (IWbemEventConsumerProvider*) m_pEventConsumer;
            return true;
        }
        *ppIntf = NULL;
    }
    return false;
}


//////////////////////////////////////////////////////////////////////////////
bool 
CServiceWrapper::GetIWbemServices(
                         /*[out]*/ IWbemServices** ppIntf
                                 )
{
    CLockIt theLock(*this);
    if ( m_bAllowWMICalls )
    {
        if ( NULL != (IWbemServices*) m_pServices )
        {
            *ppIntf = (IWbemServices*) m_pServices;
            return true;
        }
        *ppIntf = NULL;
    }
    return false;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI 
CServiceWrapper::QueryInterfaceRaw(
                                   void*     pThis,
                                   REFIID    riid,
                                   LPVOID*   ppv,
                                   DWORD_PTR dw
                                 )
{
    if ( InlineIsEqualGUID(riid, IID_IWbemProviderInit) )
    {
        *ppv = &(static_cast<CServiceWrapper*>(pThis))->m_clsProviderInit;
    }
    else
    {
        _ASSERT(FALSE);
        return E_NOTIMPL;
    }
    ((LPUNKNOWN)*ppv)->AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\exceptioninfo.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1998-1999 Microsoft Corporation all rights reserved.
//
// Module:      exceptioninfo.h
//
// Project:     Chameleon
//
// Description: Exception Information Class Definition
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/12/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __SA_EXCEPTIONINFO_H_
#define __SA_EXCEPTIONINFO_H_

// #include "resource.h"       

/////////////////////////////////////////////////////////////////////////////
// 
// Name: CExceptionInfo
//
// What: Exception information class
//
/////////////////////////////////////////////////////////////////////////////
class CExceptionInfo 
{
    
public:

    CExceptionInfo(
           /*[in]*/ DWORD              dwProcessID,
           /*[in]*/ PEXCEPTION_RECORD pER
                  );

    ~CExceptionInfo() { }

    void Spew(void);

    void Report(void);

private:

    // No assignment
    CExceptionInfo& operator = (const CExceptionInfo& rhs);

    /////////////////////////////////////////////
    // Private member data

    typedef enum 
    { 
        MAX_MODULE_NAME = 256,
        MAX_SYMBOL_NAME = 256            
    };

    typedef enum _ACCESS_TYPE
    {
        UNKNOWN_ACCESS = 0,
        READ_ACCESS,
        WRITE_ACCESS

    } ACCESS_TYPE;

    // Process where the exception occurred
    WCHAR        m_szProcessName[MAX_MODULE_NAME + 1];

    // Full path of the module where the exception occurred
    WCHAR        m_szModuleName[MAX_MODULE_NAME + 1];

    // Virtual address where exception occurred
    PVOID        m_pExceptionAddress;

    // Type of exception (see WaitForDebugEvent()
    DWORD        m_dwExceptionCode; 

    // Time and date (UTC Time - Number of seconds since midnight Jan 1 1970) of exception
    LONG        m_lTimeDateStamp;

    // Set to true if the exception was an access violation
    bool        m_bAccessViolation;

    // Used if m_bAccessViolation is set to true 
    ACCESS_TYPE    m_eAccessType;

    // Used if m_bAccessViolation is set to true 
    DWORD        m_dwVirtualAddressAccessed;

    // Process handle
    DWORD        m_dwProcessID;

    // Successfully initialized (constructed)
    bool        m_bInitialized;
};


#endif __SA_EXCEPTIONINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__51DA63F6_24D9_11D3_BF9E_00105A1F3461__INCLUDED_)
#define AFX_STDAFX_H__51DA63F6_24D9_11D3_BF9E_00105A1F3461__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

// #define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>

class CServiceModule : public CComModule
{
public:
    HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
    HRESULT UnregisterServer();
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
    LONG Unlock();
    void LogEvent(
                 /*[in]*/ WORD        wMsgType,
                 /*[in]*/ LONG        lMsgID,
                 /*[in]*/ DWORD        dwMsgParamCount,
                 /*[in]*/ LPCWSTR*    pszMsgParams,
                 /*[in]*/ DWORD        dwDataSize,
                 /*[in]*/ BYTE*        pData
                 );
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    TCHAR m_szServiceNiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
    BOOL m_bService;
};

extern CServiceModule _Module;

#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__51DA63F6_24D9_11D3_BF9E_00105A1F3461__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\servicesurrogate\servicewrapper.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      servicewrapper.h
//
// Project:     Chameleon
//
// Description: Service Wrapper Class
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 06/14/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_SERVICE_WRAPPER_H_
#define __INC_SERVICE_WRAPPER_H_

#include "resource.h"
#include "servicesurrogate.h"
#include <satrace.h>
#include <componentfactory.h>
#include <propertybagfactory.h>
#include <appmgrobjs.h>
#include <atlhlpr.h>
#include <comdef.h>
#include <comutil.h>
#include <applianceobject.h>
#include <wbemprov.h>

#define        CLASS_SERVICE_WRAPPER_FACTORY    L"CServiceWrapper"

//////////////////////////////////////////////////////////////////////////////
class CServiceWrapper : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IApplianceObject, &IID_IApplianceObject, &LIBID_SERVICESURROGATELib>,
    public IWbemEventProvider,
    public IWbemEventConsumerProvider,
    public IWbemServices
{

public:

    CServiceWrapper();
    ~CServiceWrapper();

BEGIN_COM_MAP(CServiceWrapper)
    COM_INTERFACE_ENTRY(IApplianceObject)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IWbemEventProvider)
    COM_INTERFACE_ENTRY(IWbemEventConsumerProvider)
    COM_INTERFACE_ENTRY(IWbemServices)
    COM_INTERFACE_ENTRY_FUNC(IID_IWbemProviderInit, 0, &CServiceWrapper::QueryInterfaceRaw)
END_COM_MAP()

DECLARE_COMPONENT_FACTORY(CServiceWrapper, IApplianceObject)

    //////////////////////////////////////////////////////////////////////////
    // CProviderInit - Nested class implements IWbemProviderInit
    //////////////////////////////////////////////////////////////////////////

    class CProviderInit : public IWbemProviderInit
    {
        // Outer unknown
        CServiceWrapper*      m_pSW;

    public:

        CProviderInit(CServiceWrapper* pSW)
            : m_pSW(pSW) { }
        
        ~CProviderInit() { }

        ////////////////////////////////////////////////
        // IUnknown methods - delegate to outer IUnknown
        
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv)
        { return (dynamic_cast<IApplianceObject*>(m_pSW))->QueryInterface(riid, ppv); }

        STDMETHOD_(ULONG,AddRef)(void)
        { return (dynamic_cast<IApplianceObject*>(m_pSW))->AddRef(); }

        STDMETHOD_(ULONG,Release)(void)
        { 
            return (dynamic_cast<IApplianceObject*>(m_pSW))->Release(); 
        }

        ////////////////////////////
        // IWbemProviderInit methods
    
        STDMETHOD(Initialize)(
        /*[in, unique, string]*/ LPWSTR                 wszUser,
                        /*[in]*/ LONG                   lFlags,
                /*[in, string]*/ LPWSTR                 wszNamespace,
        /*[in, unique, string]*/ LPWSTR                 wszLocale,
                        /*[in]*/ IWbemServices*         pNamespace,
                        /*[in]*/ IWbemContext*          pCtx,
                        /*[in]*/ IWbemProviderInitSink* pInitSink    
                             );
    };

    //////////////////////////////
    // IApplianceObject Interface

    STDMETHOD(GetProperty)(
                   /*[in]*/ BSTR     pszPropertyName, 
          /*[out, retval]*/ VARIANT* pPropertyValue
                          );

    STDMETHOD(PutProperty)(
                   /*[in]*/ BSTR     pszPropertyName, 
                   /*[in]*/ VARIANT* pPropertyValue
                          );

    STDMETHOD(SaveProperties)(void);

    STDMETHOD(RestoreProperties)(void);

    STDMETHOD(LockObject)(
         /*[out, retval]*/ IUnknown** ppLock
                         );

    STDMETHOD(Initialize)(void);

    STDMETHOD(Shutdown)(void);

    STDMETHOD(Enable)(void);

    STDMETHOD(Disable)(void);

    ///////////////////////////////
    // IWbemEventProvider Interface

    STDMETHOD(ProvideEvents)(
                     /*[in]*/ IWbemObjectSink *pSink,
                     /*[in]*/ LONG lFlags
                            );

    ///////////////////////////////////////
    // IWbemEventConsumerProvider Interface

    STDMETHOD(FindConsumer)(
                    /*[in]*/ IWbemClassObject       *pLogicalConsumer,
                   /*[out]*/ IWbemUnboundObjectSink **ppConsumer
                           );

    ///////////////////////////////
    // IWbemServices Interface

    STDMETHOD(OpenNamespace)(
        /*[in]*/             const BSTR        strNamespace,
        /*[in]*/             long              lFlags,
        /*[in]*/             IWbemContext*     pCtx,
        /*[out, OPTIONAL]*/  IWbemServices**   ppWorkingNamespace,
        /*[out, OPTIONAL]*/  IWbemCallResult** ppResult
                           );

    STDMETHOD(CancelAsyncCall)(
                      /*[in]*/ IWbemObjectSink* pSink
                              );

    STDMETHOD(QueryObjectSink)(
                       /*[in]*/    long              lFlags,
                      /*[out]*/ IWbemObjectSink** ppResponseHandler
                              );

    STDMETHOD(GetObject)(
                /*[in]*/    const BSTR         strObjectPath,
                /*[in]*/    long               lFlags,
                /*[in]*/    IWbemContext*      pCtx,
        /*[out, OPTIONAL]*/ IWbemClassObject** ppObject,
        /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                        );

    STDMETHOD(GetObjectAsync)(
                     /*[in]*/  const BSTR       strObjectPath,
                     /*[in]*/  long             lFlags,
                     /*[in]*/  IWbemContext*    pCtx,        
                     /*[in]*/  IWbemObjectSink* pResponseHandler
                             );

    STDMETHOD(PutClass)(
               /*[in]*/ IWbemClassObject* pObject,
               /*[in]*/ long              lFlags,
               /*[in]*/ IWbemContext*     pCtx,        
    /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                       );

    STDMETHOD(PutClassAsync)(
                    /*[in]*/ IWbemClassObject* pObject,
                    /*[in]*/ long              lFlags,
                    /*[in]*/ IWbemContext*     pCtx,        
                    /*[in]*/ IWbemObjectSink*  pResponseHandler
                           );

    STDMETHOD(DeleteClass)(
        /*[in]*/            const BSTR        strClass,
        /*[in]*/            long              lFlags,
        /*[in]*/            IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                          );

    STDMETHOD(DeleteClassAsync)(
                       /*[in]*/ const BSTR       strClass,
                       /*[in]*/ long             lFlags,
                       /*[in]*/ IWbemContext*    pCtx,        
                       /*[in]*/ IWbemObjectSink* pResponseHandler
                               );

    STDMETHOD(CreateClassEnum)(
                      /*[in]*/ const BSTR             strSuperclass,
                      /*[in]*/ long                   lFlags,
                      /*[in]*/ IWbemContext*          pCtx,        
                     /*[out]*/ IEnumWbemClassObject** ppEnum
                             );

    STDMETHOD(CreateClassEnumAsync)(
                           /*[in]*/  const BSTR       strSuperclass,
                           /*[in]*/  long             lFlags,
                           /*[in]*/  IWbemContext*    pCtx,        
                           /*[in]*/  IWbemObjectSink* pResponseHandler
                                  );

    STDMETHOD(PutInstance)(
        /*[in]*/            IWbemClassObject* pInst,
        /*[in]*/            long              lFlags,
        /*[in]*/            IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/ IWbemCallResult** ppCallResult
                          );

    STDMETHOD(PutInstanceAsync)(
                       /*[in]*/ IWbemClassObject* pInst,
                       /*[in]*/ long              lFlags,
                       /*[in]*/ IWbemContext*     pCtx,        
                       /*[in]*/ IWbemObjectSink*  pResponseHandler
                              );

    STDMETHOD(DeleteInstance)(
        /*[in]*/              const BSTR        strObjectPath,
        /*[in]*/              long              lFlags,
        /*[in]*/              IWbemContext*     pCtx,        
        /*[out, OPTIONAL]*/   IWbemCallResult** ppCallResult        
                            );

    STDMETHOD(DeleteInstanceAsync)(
                          /*[in]*/ const BSTR       strObjectPath,
                          /*[in]*/ long             lFlags,
                          /*[in]*/ IWbemContext*    pCtx,        
                          /*[in]*/ IWbemObjectSink* pResponseHandler
                                 );

    STDMETHOD(CreateInstanceEnum)(
                         /*[in]*/ const BSTR             strClass,
                         /*[in]*/ long                   lFlags,
                         /*[in]*/ IWbemContext*          pCtx,        
                        /*[out]*/ IEnumWbemClassObject** ppEnum
                                );

    STDMETHOD(CreateInstanceEnumAsync)(
                              /*[in]*/ const BSTR       strClass,
                              /*[in]*/ long             lFlags,
                              /*[in]*/ IWbemContext*    pCtx,        
                              /*[in]*/ IWbemObjectSink* pResponseHandler
                                     );

    STDMETHOD(ExecQuery)(
                 /*[in]*/ const BSTR             strQueryLanguage,
                 /*[in]*/ const BSTR             strQuery,
                 /*[in]*/ long                   lFlags,
                 /*[in]*/ IWbemContext*          pCtx,        
                /*[out]*/ IEnumWbemClassObject** ppEnum
                        );

    STDMETHOD(ExecQueryAsync)(
                     /*[in]*/ const BSTR       strQueryLanguage,
                     /*[in]*/ const BSTR       strQuery,
                     /*[in]*/ long             lFlags,
                     /*[in]*/ IWbemContext*    pCtx,        
                     /*[in]*/ IWbemObjectSink* pResponseHandler
                            );


    STDMETHOD(ExecNotificationQuery)(
                            /*[in]*/ const BSTR             strQueryLanguage,
                            /*[in]*/ const BSTR             strQuery,
                            /*[in]*/ long                   lFlags,
                            /*[in]*/ IWbemContext*          pCtx,        
                           /*[out]*/ IEnumWbemClassObject** ppEnum
                                    );

    STDMETHOD(ExecNotificationQueryAsync)(
                                 /*[in]*/ const BSTR       strQueryLanguage,
                                 /*[in]*/ const BSTR       strQuery,
                                 /*[in]*/ long             lFlags,
                                 /*[in]*/ IWbemContext*    pCtx,        
                                 /*[in]*/ IWbemObjectSink* pResponseHandler
                                        );


    STDMETHOD(ExecMethod)(
        /*[in]*/            const BSTR         strObjectPath,
        /*[in]*/            const BSTR         strMethodName,
        /*[in]*/            long               lFlags,
        /*[in]*/            IWbemContext*      pCtx,        
        /*[in]*/            IWbemClassObject*  pInParams,
        /*[out, OPTIONAL]*/ IWbemClassObject** ppOutParams,
        /*[out, OPTIONAL]*/ IWbemCallResult**  ppCallResult
                         );

    STDMETHOD(ExecMethodAsync)(
                      /*[in]*/ const BSTR        strObjectPath,
                      /*[in]*/ const BSTR        strMethodName,
                      /*[in]*/ long              lFlags,
                      /*[in]*/ IWbemContext*     pCtx,        
                      /*[in]*/ IWbemClassObject* pInParams,
                      /*[in]*/ IWbemObjectSink*  pResponseHandler     
                              );


    //////////////////////////////////////////////////////////////////////////
    HRESULT InternalInitialize(
                       /*[in]*/ PPROPERTYBAG pPropertyBag
                              );

private:

    friend class CProviderInit;

    bool GetIWbemProviderInit(
                     /*[out]*/ IWbemProviderInit** ppIntf
                             );

    bool GetIWbemEventProvider(
                      /*[out]*/ IWbemEventProvider** ppIntf
                              );

    bool GetIWbemEventConsumerProvider(
                              /*[out]*/ IWbemEventConsumerProvider** ppIntf
                                      );

    bool GetIWbemServices(
                 /*[out]*/ IWbemServices** ppIntf
                         );

    // Called when someone queries for any of the object's interfaces
    // implemented by nested classes
    static HRESULT WINAPI QueryInterfaceRaw(
                                             void*     pThis,
                                             REFIID    riid,
                                             LPVOID*   ppv,
                                             DWORD_PTR dw
                                            );

    // Pointers to interfaces on the hosted components
    CComPtr<IApplianceObject>            m_pServiceControl;
    CComPtr<IWbemProviderInit>            m_pProviderInit;
    CComPtr<IWbemEventProvider>            m_pEventProvider;
    CComPtr<IWbemEventConsumerProvider> m_pEventConsumer;
    CComPtr<IWbemServices>                m_pServices;

    // Instance of class that implements IWbemProviderInit - The reason
    // that this is a nested class is that both IWbemProviderInit and
    // IApplianceObject expose an Initialize() method
    CProviderInit                m_clsProviderInit;

    // WMI method filter state. If set to TRUE then WMI method
    // calls are dissallowed. 
    bool                        m_bAllowWMICalls;
};


#endif // __INC_SERVICE_WRAPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by taskcoordinator.rc
//
#define IDS_PROJNAME                    100
#define IDR_Taskcoordinator             100
#define IDR_TASKCOORDINATORIMPL         101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\asynctaskmanager.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      AsyncTaskManager.h
//
// Project:     Chameleon
//
// Description: Appliance Async Task Manager Class Definition
//
// Log: 
//
// Who     When            What
// ---     ----         ----
// TLP       06/03/1999    Original Version
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ASYNC_TASK_MANAGER_H_
#define __ASYNC_TASK_MANAGER_H_

#include "resource.h"       // main symbols
#include <basedefs.h>
#include <taskctx.h>
#include <workerthread.h>

#pragma warning( disable : 4786 )
#include <list>
using namespace std;


// Task execution function prototype
typedef HRESULT (*PFNTASKEXECUTE)(ITaskContext* pTaskCtx);

class CAsyncTaskManager; // Forward declaration

//////////////////////////////////////////////////////////////////////////////
// CAsyncTask

class CAsyncTask
{

public:

    ~CAsyncTask();

private:

    // Only the Async Task Manager can create an async task object
    friend CAsyncTaskManager;
    CAsyncTask(PFNTASKEXECUTE pfnExecute);

    CAsyncTask(const CAsyncTask& rhs);
    CAsyncTask& operator = (const CAsyncTask& rhs);

    //////////////////////////////////////////////////////////////////////////
    bool Execute(
         /*[in]*/ bool             bIsSingleton,
         /*[in]*/ ITaskContext*  pTaskCtx
                );

    //////////////////////////////////////////////////////////////////////////
    bool Terminate(void);

    //////////////////////////////////////////////////////////////////////////
    void AsyncTaskProc(void);

    //////////////////////////////////////////////////////////////////////////
    bool IsSingleton(void)
    { return m_bIsSingleton; }

    //////////////////////////////////////////////////////////////////////////
    ITaskContext* GetContext(void)
    { return (ITaskContext*) m_pTaskCtx; }

    // Singleton flag
    bool                    m_bIsSingleton;

    // Task execution function
    PFNTASKEXECUTE            m_pfnExecute;

    // Task context (parameters)
    CComPtr<ITaskContext>    m_pTaskCtx;

    // Task execution thread
    typedef enum { TERMINATE_WAIT_INTERVAL = 100 }; // 100 ms
    Callback*                m_pCallback;
    CTheWorkerThread        m_Thread;
};

typedef CHandle<CAsyncTask>       PASYNCTASK;
typedef CMasterPtr<CAsyncTask> MPASYNCTASK;


//////////////////////////////////////////////////////////////////////////////
// CAsyncTaskManager

class CAsyncTaskManager
{

public:

    CAsyncTaskManager();

    ~CAsyncTaskManager();

    bool Initialize(void);

    bool RunAsyncTask(
              /*[in]*/ bool              bIsSingleton,
              /*[in]*/ PFNTASKEXECUTE pfnExecute,
              /*[in]*/ ITaskContext*  pTaskContext
                     );

    bool IsBusy(void);

    void Shutdown(void);

private:

    CAsyncTaskManager(const CAsyncTaskManager& rhs);
    CAsyncTaskManager operator = (CAsyncTaskManager& rhs);

    // Task Manager state
    CRITICAL_SECTION    m_CS;
    bool                m_bInitialized;

    // Async task list
    typedef list< PASYNCTASK >  TaskList;
    typedef TaskList::iterator    TaskListIterator;

    TaskList            m_TaskList;

    // Garbage collector (thread reclaimation) run interval (2 seconds)
    typedef enum { GARBAGE_COLLECTION_RUN_INTERVAL = 2000 };

    // Thread reclaimation function
    void GarbageCollector(void);

    // Garbage collection thread
    typedef enum { EXIT_WAIT_INTERVAL = 100 }; // (100 ms)
    Callback*            m_pCallback;
    CTheWorkerThread    m_Thread;
};


#endif // __ASYNC_TASK_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\processmonitor.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      ProcessMonitor.h
//
// Project:     Chameleon
//
// Description: Process Monitor Class Defintion
//
// Log: 
//
// Who     When            What
// ---     ----         ----
// TLP       05/14/1999    Original Version
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __MY_PROCESS_MONITOR_H_
#define __MY_PROCESS_MONITOR_H_

#include "resource.h"       // main symbols
#include <workerthread.h>

#define        DO_NOT_MONITOR        0xFFFFFFFF

class CProcessMonitor
{

public:

    CProcessMonitor(
            /*[in]*/ DWORD dwMaxExecutionTime = DO_NOT_MONITOR,
            /*[in]*/ DWORD dwMaxPrivateBytes = DO_NOT_MONITOR,
            /*[in]*/ DWORD dwMaxThreads = DO_NOT_MONITOR,
            /*[in]*/ DWORD dwMaxHandles = DO_NOT_MONITOR
                   );

    ~CProcessMonitor();

    bool Start(void);

private:

    // No copy or assignment
    CProcessMonitor(CProcessMonitor& rhs);
    CProcessMonitor& operator = (CProcessMonitor& rhs);

    // Process monitoring function
    void MonitorFunc(void);

    // Resource utilization checks
    void CheckMaxPrivateBytes(void);
    void CheckMaxHandles(void);
    void CheckMaxThreads(void);
    void CheckMaxExecutionTime(void);

    // Process Monitor Thread
    Callback*            m_pCallback;
    CTheWorkerThread    m_MonitorThread;

    // Monitoring Variables
    DWORD                m_dwRemainingExecutionTime;
    DWORD                m_dwMaxExecutionTime;
    DWORD                m_dwMaxPrivateBytes;
    DWORD                m_dwMaxThreads;
    DWORD                m_dwMaxHandles;
};

#endif    // __MY_PROCESS_MONITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\processmonitor.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      processmonitor.cpp
//
// Project:     Chameleon
//
// Description: Process Monitor Class Implementation 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/26/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "processmonitor.h"
#include <satrace.h>

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CProcessMonitor()
//
// Synopsis: Constructor
//
/////////////////////////////////////////////////////////////////////////////
CProcessMonitor::CProcessMonitor(
                         /*[in]*/ DWORD dwMaxExecutionTime,    // In seconds
                         /*[in]*/ DWORD dwMaxPrivateBytes,
                         /*[in]*/ DWORD dwMaxThreads,
                         /*[in]*/ DWORD dwMaxHandles
                                )
: m_dwMaxPrivateBytes(dwMaxPrivateBytes),
  m_dwMaxThreads(dwMaxThreads),
  m_dwMaxHandles(dwMaxHandles),
  m_pCallback(NULL)
{
    if ( DO_NOT_MONITOR != dwMaxExecutionTime )
    {
        m_dwMaxExecutionTime = dwMaxExecutionTime * 1000;
        m_dwRemainingExecutionTime = dwMaxExecutionTime * 1000;
    }
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: ~CProcessMonitor()
//
// Synopsis: Destructor
//
/////////////////////////////////////////////////////////////////////////////
CProcessMonitor::~CProcessMonitor()
{
    m_MonitorThread.End(INFINITE, false);
    delete m_pCallback;
}

// TODO: Make poll interval a parameter of the class constructor...
#define MonitorFuncPollInterval 1000 // 1 second

/////////////////////////////////////////////////////////////////////////////
// 
// Function: Start()
//
// Synopsis: Starts the process monitor
//
/////////////////////////////////////////////////////////////////////////////
bool 
CProcessMonitor::Start()
{
    bool bReturn = false;

    // Allocate a callback object
    m_pCallback = MakeCallback(this, &CProcessMonitor::MonitorFunc);
    if ( NULL != m_pCallback )
    {
        // Start the command processor thread
        if ( m_MonitorThread.Start(MonitorFuncPollInterval, m_pCallback) ) 
        {
            bReturn = true;
        }
    }

    return bReturn;
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: MonitorFunc()
//
// Synopsis: Monitor function (performs process monitoring)
//
/////////////////////////////////////////////////////////////////////////////
void
CProcessMonitor::MonitorFunc()
{
    static bool bFirstPoll = true;

    // I'm compensating for the fact that our first call will be
    // recevied almost immediately. Thereafter the call rate will
    // be MonitorFuncPollInterval...

    if ( bFirstPoll )
    {
        bFirstPoll = false;
    }
    else
    {
        // Perform process resource constraint checks. Note we 
        // can do something fancier if we wish to order the 
        // checks differently on a per process basis.

        CheckMaxPrivateBytes();
        CheckMaxHandles();
        CheckMaxThreads();
        CheckMaxExecutionTime();
    }
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CheckMaxPrivateBytes()
//
// Synopsis: Ensure the process has not exceeded its quota of private bytes
//
/////////////////////////////////////////////////////////////////////////////
void 
CProcessMonitor::CheckMaxPrivateBytes()
{
    if ( DO_NOT_MONITOR != m_dwMaxPrivateBytes )
    {
        // Check amount of private bytes...
    }
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CheckMaxHandles()
//
// Synopsis: Ensure the process has not exceeded its quota of object handles
//
/////////////////////////////////////////////////////////////////////////////
void 
CProcessMonitor::CheckMaxHandles()
{
    if ( DO_NOT_MONITOR != m_dwMaxHandles )
    {
        // Check use of handles... 
    }
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CheckMaxThreads()
//
// Synopsis: Ensure the process has not exceeded its quota of threads
//
/////////////////////////////////////////////////////////////////////////////
void 
CProcessMonitor::CheckMaxThreads()
{
    if ( DO_NOT_MONITOR != m_dwMaxThreads )
    {
        // Check the number of threads...
    }
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CheckMaxExecutionTime()
//
// Synopsis: Ensure the process does not run past a maximum execution time 
//
/////////////////////////////////////////////////////////////////////////////
void 
CProcessMonitor::CheckMaxExecutionTime()
{
    if ( DO_NOT_MONITOR != m_dwMaxExecutionTime )
    {
        if ( m_dwRemainingExecutionTime < MonitorFuncPollInterval )
        {
            m_dwRemainingExecutionTime = 0;
        }
        else
        {
            m_dwRemainingExecutionTime -= MonitorFuncPollInterval;
        }
        if ( 0 == m_dwRemainingExecutionTime )
        {
            // Cause an exception if we've violated a constraint. 
            // The expectation is that the processes exception filter 
            // (exceptionfilter.cpp) will deal with the problem.
            SATracePrintf("CProcessMonitor::CheckMaxExecutionTime() - Execution time exceeded for process: %d", GetCurrentProcessId());
            DebugBreak();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskctx\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3A205C94_0C7E_11D3_BF75_00105A1F3461__INCLUDED_)
#define AFX_STDAFX_H__3A205C94_0C7E_11D3_BF75_00105A1F3461__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

// #define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
    LONG Unlock();
    DWORD dwThreadID;
    HANDLE hEventShutdown;
    void MonitorShutdown();
    bool StartMonitor();
    bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3A205C94_0C7E_11D3_BF75_00105A1F3461__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\asynctaskmanager.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      AsyncTaskManager.cpp
//
// Project:     Chameleon
//
// Description: Appliance Async Task Manager Class Implementation
//
// Log: 
//
// Who     When            What
// ---     ----         ----
// TLP       06/03/1999    Original Version
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "asynctaskmanager.h"
#include "exceptionfilter.h"
#include <appsrvcs.h>
#include <appmgrobjs.h>
#include <kitmsg.h>
#include <comdef.h>
#include <comutil.h>
#include <satrace.h>
#include <varvec.h>

/////////////////////////////////////////////////////////////////////////////
// 
// Function: GetTaskName()
//
// Synopsis: Get a task name given a task context component interface
//
/////////////////////////////////////////////////////////////////////////////
void GetTaskName(
         /*[in]*/ ITaskContext* pTaskCtx,
        /*[out]*/ VARIANT*      pTaskName
                )
{
    static _bstr_t bstrMethodName = PROPERTY_TASK_METHOD_NAME;
    if ( FAILED(pTaskCtx->GetParameter(bstrMethodName, pTaskName)) )
    {
        _ASSERT( FALSE );
        SATraceString("GetTaskName() - ERROR - Could not get task name...");
    }
}


/////////////////////////////////////////////////////////////////////////////
// CAsyncTaskManager

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CAsyncTaskManager
//
// Synopsis: Constructor
//
/////////////////////////////////////////////////////////////////////////////
CAsyncTaskManager::CAsyncTaskManager()
: m_bInitialized(false),
  m_pCallback(NULL)
{
    InitializeCriticalSection(&m_CS);
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: ~CAsyncTaskManager
//
// Synopsis: Destructor
//
/////////////////////////////////////////////////////////////////////////////
CAsyncTaskManager::~CAsyncTaskManager()
{
    Shutdown();
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: Initialize()
//
// Synopsis: Initializes the task manager. Must be called prior to
//             running async tasks
//
/////////////////////////////////////////////////////////////////////////////
bool CAsyncTaskManager::Initialize(void)
{
    bool bResult = true;
    EnterCriticalSection(&m_CS);
    if ( ! m_bInitialized )
    {
        m_pCallback = MakeCallback(this, &CAsyncTaskManager::GarbageCollector);
        if ( NULL != m_pCallback )
        {
            if ( m_Thread.Start(GARBAGE_COLLECTION_RUN_INTERVAL, m_pCallback) ) 
            {
                m_bInitialized = true;
                bResult = true;
            }
            else
            {
                SATraceString("CAsyncTaskManager::Initialize() - Failed - Could not start the garbage collector");
                delete m_pCallback;
                m_pCallback = NULL;
            }
        }
        else
        {
            SATraceString("CAsyncTaskManager::Initialize() - Failed - Could not allocate a Callback");
        }
    }
    LeaveCriticalSection(&m_CS);
    return bResult;
}

DWORD MPASYNCTASK::m_dwInstances = 0;

/////////////////////////////////////////////////////////////////////////////
// 
// Function: RunAsyncTask()
//
// Synopsis: Runs an asyncronous task
//
/////////////////////////////////////////////////////////////////////////////
bool CAsyncTaskManager::RunAsyncTask(
                             /*[in]*/ bool             bIsSingleton,
                             /*[in]*/ PFNTASKEXECUTE pfnExecute,
                             /*[in]*/ ITaskContext*  pTaskCtx
                                    )
{
    _ASSERT( NULL != pfnExecute && NULL != pTaskCtx );

    bool bResult = false;
    EnterCriticalSection(&m_CS);
    if ( m_bInitialized )
    {
        try
        {
            bool bIsAvailable = true;

            // singleton async task support
            if ( bIsSingleton )
            {
                _variant_t vtTaskName;
                GetTaskName(pTaskCtx, &vtTaskName);
                TaskListIterator p = m_TaskList.begin();
                while ( p != m_TaskList.end() )
                {
                    if ( (*p)->IsSingleton() )
                    {
                        _variant_t vtCurTaskName;
                        GetTaskName((*p)->GetContext(), &vtCurTaskName);
                        if ( ! lstrcmpi(V_BSTR(&vtTaskName), V_BSTR(&vtCurTaskName)) )
                        {
                            bIsAvailable = false;
                            break;
                        }
                    }
                    p++;
                }
            }

            if ( bIsAvailable )
            {
                // execute the async task (asynchronously)
                CAsyncTask* pAT = new CAsyncTask(pfnExecute);
                PASYNCTASK pATH((MPASYNCTASK*) new MPASYNCTASK(pAT));
                if ( pATH->Execute(bIsSingleton, pTaskCtx) )
                {
                    m_TaskList.push_back(pATH);
                    bResult = true;
                }                
            }
        }        
        catch(...)
        {
            SATraceString("CAsyncTaskManager::RunAsyncTask() - Failed - Caught bad allocation exception");
        }
    }
    else
    {
        SATraceString("CAsyncTaskManager::RunAsyncTask() - Failed - Task Manager is not initialized");
    }
    LeaveCriticalSection(&m_CS);
    return bResult;
}    


/////////////////////////////////////////////////////////////////////////////
// 
// Function: IsBusy()
//
// Synopsis: Determines if the task manager is busy (has outstanding tasks)
//
/////////////////////////////////////////////////////////////////////////////
bool CAsyncTaskManager::IsBusy(void)
{
    bool bResult = false;
    EnterCriticalSection(&m_CS);
    if ( m_bInitialized )
    {
        bResult = ! m_TaskList.empty();
    }
    LeaveCriticalSection(&m_CS);
    return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// 
// Function: Shutdown()
//
// Synopsis: Shutdown the task manager
//
/////////////////////////////////////////////////////////////////////////////
void CAsyncTaskManager::Shutdown(void)
{
    EnterCriticalSection(&m_CS);
    if ( m_bInitialized )
    {
        DWORD dwExceptionParam = APPLIANCE_SURROGATE_EXCEPTION;
        if ( ! m_Thread.End(EXIT_WAIT_INTERVAL, true) )
        {
            RaiseException(
                            EXCEPTION_BREAKPOINT,        
                            EXCEPTION_NONCONTINUABLE,    
                            1,                            
                            &dwExceptionParam                        
                          );
        }
        else
        {
            delete m_pCallback;
            m_pCallback = NULL;
            // If we have any tasks still outstanding then raise an exception
            // This causes the process to terminate without reporting a critical
            // error to the appliance monitor.
            if ( ! m_TaskList.empty() )
            {
                RaiseException(
                                EXCEPTION_BREAKPOINT,        
                                EXCEPTION_NONCONTINUABLE,    
                                1,                            
                                &dwExceptionParam                        
                              );
            }                
        }
    }
    LeaveCriticalSection(&m_CS);
}



/////////////////////////////////////////////////////////////////////////////
// 
// Function: GarbageCollector()
//
// Synopsis: Cleans up the async task thread list
//
/////////////////////////////////////////////////////////////////////////////
void CAsyncTaskManager::GarbageCollector(void)
{
    EnterCriticalSection(&m_CS);
    try
    {
        TaskListIterator p = m_TaskList.begin();
        while ( p != m_TaskList.end() )
        {
            if ( (*p)->Terminate() )
            {
                p = m_TaskList.erase(p);
            }
            else
            {
                p++;
            }
        }
    }
    catch(...)
    {
        SATraceString("CAsyncTaskManager::GarbageCollector() caught unhandled exception");
    }
    LeaveCriticalSection(&m_CS);
}



/////////////////////////////////////////////////////////////////////////////
// CAsyncTask


/////////////////////////////////////////////////////////////////////////////
// 
// Function: CAsyncTask()
//
// Synopsis: Constructor
//
/////////////////////////////////////////////////////////////////////////////
CAsyncTask::CAsyncTask(PFNTASKEXECUTE pfnExecute)
: m_bIsSingleton(false),
  m_pCallback(NULL),
  m_pfnExecute(pfnExecute)

{
    _ASSERT(pfnExecute);
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: ~CAsyncTask()
//
// Synopsis: Destructor
//
/////////////////////////////////////////////////////////////////////////////
CAsyncTask::~CAsyncTask()
{
    m_Thread.End(0, true);
    m_pTaskCtx.Release();
    if ( m_pCallback )
    {
        delete m_pCallback;
    }    
}


/////////////////////////////////////////////////////////////////////////////
// 
// Function: Execute
//
// Synopsis: Execute the specified task
//
/////////////////////////////////////////////////////////////////////////////
bool CAsyncTask::Execute(
                 /*[in]*/ bool            bIsSingleton,
                 /*[in]*/ ITaskContext* pTaskCtx
                        )
{
    bool bResult = false;
    m_pCallback = MakeCallback(this, &CAsyncTask::AsyncTaskProc);
    if ( NULL != m_pCallback )
    {
        m_pTaskCtx = pTaskCtx;
        m_bIsSingleton = bIsSingleton;
        if ( m_Thread.Start(0, m_pCallback) ) 
        {
            bResult = true;
        }
        else
        {
            m_pTaskCtx.Release();
            delete m_pCallback;
            m_pCallback = NULL;
        }
    }
    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: Terminate
//
// Synopsis: Attempt to terminate the task
//
/////////////////////////////////////////////////////////////////////////////
bool CAsyncTask::Terminate(void)
{
    bool bResult = false;
    if ( m_Thread.End(TERMINATE_WAIT_INTERVAL, false) )
    {
        m_pTaskCtx.Release();
        if ( m_pCallback )
        {
            delete m_pCallback;
            m_pCallback = NULL;
            bResult = true;
        }
    }
    return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// 
// Function: AsyncTaskProc()
//
// Synopsis: Task execution thread proc
//
/////////////////////////////////////////////////////////////////////////////

_bstr_t bstrTaskName = PROPERTY_TASK_METHOD_NAME;
_bstr_t bstrTaskNiceName = PROPERTY_TASK_NICE_NAME;
_bstr_t bstrTaskURL = PROPERTY_TASK_URL;

void CAsyncTask::AsyncTaskProc(void)
{
    if ( FAILED((m_pfnExecute)(m_pTaskCtx)) )
    {
        // Async task execution failed. Handle this by raising an alert.
        // Note that we pass the task nice name and task URL as alert
        // message parameters. 

        do
        {
            _variant_t vtTaskName;
            HRESULT hr = m_pTaskCtx->GetParameter(bstrTaskName, &vtTaskName);
            if ( FAILED(hr) )
            {
                SATracePrintf("CAsyncTask::AsyncTaskProc() - INFO - ITaskContext::GetParameter(TaskName) returned: %lx... Cannot raise alert", hr);
                break;
            }
            SATracePrintf("CAsyncTask::AsyncTaskProc() - Async task '%ls' failed...", V_BSTR(&vtTaskName));

            _variant_t vtNiceName;
            hr = m_pTaskCtx->GetParameter(bstrTaskNiceName, &vtNiceName);
            if ( FAILED(hr) )
            {
                SATracePrintf("CAsyncTask::AsyncTaskProc() - INFO - ITaskContext::GetParameter(NiceName) returned: %lx... Cannot raise alert", hr);
                break;
            }
            _variant_t vtURL;
            hr = m_pTaskCtx->GetParameter(bstrTaskURL, &vtURL);
            if ( FAILED(hr) )
            {
                SATracePrintf("CAsyncTask::AsyncTaskProc() - INFO - ITaskContext::GetParameter(URL) returned: %lx... Cannot raise alert", hr);
                break;
            }
            CComPtr<IApplianceServices> pAppSrvcs;
            hr = CoCreateInstance(
                                    CLSID_ApplianceServices,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IApplianceServices,
                                    (void**)&pAppSrvcs
                                 );
            if ( FAILED(hr) )
            {
                SATracePrintf("CAsyncTask::AsyncTaskProc() - INFO - CoCreateInstance(CLSID_ApplianceServices) returned: %lx... Cannot raise alert", hr);
                break;
            }
            hr = pAppSrvcs->Initialize();
            if ( FAILED(hr) )
            {
                SATracePrintf("CAsyncTask::AsyncTaskProc() - INFO - IApplianceServices::Initialize() returned: %lx... Cannot raise alert", hr);                        
                break;
            }

            static _bstr_t    bstrAlertSource = L"";                 // Default alert source 
            static _bstr_t    bstrAlertLog = L"MSSAKitCore";        // Framework alert log
            _variant_t          vtReplacementStrings;
            static _variant_t vtRawData;
            long              lCookie;

            CVariantVector<BSTR> theMsgParams(&vtReplacementStrings, 2);
            theMsgParams[0] = SysAllocString(V_BSTR(&vtNiceName));
            theMsgParams[1] = SysAllocString(V_BSTR(&vtURL));

            if ( NULL == theMsgParams[0] || NULL == theMsgParams[1] )
            {
                SATracePrintf("CAsyncTask::AsyncTaskProc() - INFO - SysAllocString() failed... Cannot raise alert", hr);                        
                break;
            }

            hr = pAppSrvcs->RaiseAlert(
                                        SA_ALERT_TYPE_FAILURE,
                                        SA_ASYNC_TASK_FAILED_ALERT,
                                        bstrAlertLog,
                                        bstrAlertSource,
                                        SA_ALERT_DURATION_ETERNAL,        
                                        &vtReplacementStrings,
                                        &vtRawData,
                                        &lCookie
                                      );
            if ( FAILED(hr) )
            {
                SATracePrintf("CAsyncTask::AsyncTaskProc() - INFO - IApplianceServices::RaiseAlert() returned: %lx... Cannot raise alert", hr);                        
                break;
            }

        } while ( FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\taskcoordinator.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      taskcoordinator.cpp
//
// Project:     Chameleon
//
// Description: WinMain() and COM Local Server Scaffolding.
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/26/1999   TLP    Initial Version (Mostly produced by Dev Studio)
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "taskcoordinator.h"
#include "asynctaskmanager.h"
#include "exceptioninfo.h"
#include "exceptionfilter.h"
#include "taskcoordinatorimpl.h"
#include <satrace.h>

CAsyncTaskManager gTheTaskManager;

const DWORD dwActivityCheck = 15000;
const DWORD dwPause = 1000;

//
// forward declaration of the SetAclFromComObject function
//
DWORD
SetAclForComObject ( 
    /*[in]*/    PSECURITY_DESCRIPTOR pSD,
    /*[out*/    PACL             *ppacl
    );

// Process Activity Monitor 
//////////////////////////////////////////////////////////////////////////////
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    return l;
}

//Monitors the shutdown event
//////////////////////////////////////////////////////////////////////////////
void CExeModule::MonitorShutdown()
{
    while (true)
    {
        // Suspend
        Sleep(dwActivityCheck);
        // Check our activity status
        if ( m_nLockCnt == 0 && ! gTheTaskManager.IsBusy() ) 
        {
            // No activity so dissallow new client connections
            CoSuspendClassObjects();
            if ( m_nLockCnt == 0 && ! gTheTaskManager.IsBusy() )
            { 
                break; 
            }
            else
            { 
                CoResumeClassObjects(); 
            }
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

//////////////////////////////////////////////////////////////////////////////
bool CExeModule::StartMonitor()
{
    // Create the activity monitoring thread
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TaskCoordinator, CTaskCoordinator)
END_OBJECT_MAP()


//////////////////////////////////////////////////////////////////////////////
LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}


extern CExceptionFilter    g_ProcessUEF;

/////////////////////////////////////////////////////////////////////////////
LONG WINAPI
TaskCoordinatorUEF(
           /*[in]*/ PEXCEPTION_POINTERS pExceptionInfo
                  )  
{
    DWORD dwProcessId = GetCurrentProcessId();
    HANDLE hProcess = GetCurrentProcess();
    if ( EXCEPTION_BREAKPOINT == pExceptionInfo->ExceptionRecord->ExceptionCode )
    {
        if (  APPLIANCE_SURROGATE_EXCEPTION == pExceptionInfo->ExceptionRecord->ExceptionInformation[0] )
        {
            SATracePrintf("TaskCoordinatorUEF() - Surrogate is terminating process: %d due to a resource constraint violation", dwProcessId);
            TerminateProcess(hProcess, 1);
        }
    }
    else
    {
        SATracePrintf("TaskCoordinatorUEF() - Unhandled exception in process %d", dwProcessId);
        _Module.RevokeClassObjects();
        CExceptionInfo cei(dwProcessId, pExceptionInfo->ExceptionRecord);
        cei.Spew();
        cei.Report();
        TerminateProcess(hProcess, 1);
    }
    return EXCEPTION_EXECUTE_HANDLER; 
}

/////////////////////////////////////////////////////////////////////////////
extern "C" int WINAPI _tWinMain(
                                HINSTANCE hInstance, 
                                HINSTANCE /*hPrevInstance*/, 
                                LPTSTR lpCmdLine, 
                                int /*nShowCmd*/
                               )
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    _ASSERTE(SUCCEEDED(hRes));

        // Initialize security for the service process

        // RPC_C_AUTHN_LEVEL_CONNECT 
        // Authenticates the credentials of the client only when the client 
        // establishes a relationship with the server. 
        // Datagram transports always use RPC_AUTHN_LEVEL_PKT instead. 

        // RPC_C_IMP_LEVEL_IMPERSONATE 
        // The server process can impersonate the client's security
        // context while acting on behalf of the client. This level of
        // impersonation can be used to access local resources such as files. 
        // When impersonating at this level, the impersonation token can only 
        // be passed across one machine boundary. 
        // In order for the impersonation token to be passed, you must use 
        // Cloaking, which is available in Windows NT 5.0. 

        CSecurityDescriptor sd;
        sd.InitializeFromThreadToken();
        PACL pacl = NULL;
        //
        // 
        // Add ACLs to the SD using the builtin RIDs.
        //
        DWORD dwRetVal =  SetAclForComObject  ( 
                                     (PSECURITY_DESCRIPTOR) sd.m_pSD,
                                       &pacl
                                    );    
           if (ERROR_SUCCESS != dwRetVal)      {return -1;}
            
        HRESULT hr = CoInitializeSecurity(
                                    sd, 
                                    -1, 
                                    NULL, 
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                                    RPC_C_IMP_LEVEL_IDENTIFY, 
                                    NULL, 
                                    EOAC_NONE, 
                                    NULL
                                 );
        if (FAILED (hr))
        {
            SATraceFailure ("CoInitializeSecurity:%x", hr);
        }

        //
        // Register the class with COM
        //
        //
        


    // TLP - No ATL 3.0...
    _Module.Init(ObjectMap, hInstance /*&LIBID_TASKCOORDINATORLib*/);
    //_Module.Init(ObjectMap, hInstance, &LIBID_TASKCOORDINATORLib);

    _Module.dwThreadID = GetCurrentThreadId();

    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Taskcoordinator, FALSE);
            // TLP - No ATL 3.0...
            nRet = _Module.UnregisterServer(&CLSID_TaskCoordinator /* TRUE */ );
            // nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Taskcoordinator, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        g_ProcessUEF.SetExceptionHandler(TaskCoordinatorUEF);

        if ( gTheTaskManager.Initialize() )
        {
            _Module.StartMonitor();
    
            hRes = _Module.RegisterClassObjects(
                                                CLSCTX_LOCAL_SERVER, 
                                                REGCLS_MULTIPLEUSE
                                               );
            _ASSERTE(SUCCEEDED(hRes));
            if ( SUCCEEDED(hRes) )
            {
                MSG msg;
                while (GetMessage(&msg, 0, 0, 0))
                    DispatchMessage(&msg);
            }

            _Module.RevokeClassObjects();

            gTheTaskManager.Shutdown();

            // Wait for any threads to finish
            Sleep(dwPause); 
        }
    }

    _Module.Term();

    //
    // cleanup
    //
    if (pacl) {LocalFree (pacl);}

    CoUninitialize();

    return nRet;
}

//++--------------------------------------------------------------
//
//  Function:   SetAclForComObject
//
//  Synopsis: method for providing only the Local System and Admins rights 
//             to access the COM object
//
//  Arguments:  none
//
//  Returns:    HRESULT
//
//  History:    MKarki      11/15/2001    Created
//
//----------------------------------------------------------------
DWORD
SetAclForComObject ( 
    /*[in]*/    PSECURITY_DESCRIPTOR pSD,
    /*[out*/    PACL             *ppacl
    )
{    
    DWORD              dwError = ERROR_SUCCESS;
    int                         cbAcl = 0;
    PACL                    pacl = NULL;
    PSID                    psidEveryoneSid = NULL;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    CSATraceFunc objTraceFunc ("SetAclFromComObject");

    do
    {
        if (NULL == pSD)
        {
            SATraceString ("SetAclFromComObject - invalid parameter passed in");
            dwError = ERROR_INVALID_PARAMETER;
            break;
        }
            
        //
        // Create a SID for Local System account
        //
            BOOL bRetVal = AllocateAndInitializeSid (  
                            &siaWorldSidAuthority,
                            1,
                            SECURITY_WORLD_RID,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &psidEveryoneSid
                            );
        if (!bRetVal)
        {     
            dwError = GetLastError ();
                SATraceFailure ("SetAclFromComObject:AllocateAndInitializeSid (EveryOne) failed",  dwError);
                break;
            }

            //
            // Calculate the length of required ACL buffer
            // with 1 ACE.
            //
            cbAcl =     sizeof (ACL)
                            +   sizeof (ACCESS_ALLOWED_ACE)
                            +   GetLengthSid( psidEveryoneSid );

            pacl = (PACL) LocalAlloc ( 0, cbAcl );
            if (NULL == pacl) 
            {
                dwError = ERROR_OUTOFMEMORY;
                SATraceFailure ("SetAclFromComObject::LocalAlloc failed:", dwError);
            break;
            }

            //
            // initialize the ACl now
            //
            bRetVal =InitializeAcl ( 
                        pacl,
                                cbAcl,
                                ACL_REVISION2
                                );
            if (!bRetVal)
            {
                 dwError = GetLastError();
            SATraceFailure ("SetAclFromComObject::InitializeAcl failed:", dwError);
                break;
            }

        //
            // Add ACE with EVENT_ALL_ACCESS for Local System account
            //
            bRetVal = AddAccessAllowedAce ( 
                            pacl,
                                        ACL_REVISION2,
                                        COM_RIGHTS_EXECUTE,
                                        psidEveryoneSid
                                        );
        if (!bRetVal)
        {
                dwError = GetLastError();
                SATraceFailure ("SetAclFromComObject::AddAccessAllowedAce (Everyone)  failed:", dwError);
            break;
        }

        //
        // Set the ACL which allows EVENT_ALL_ACCESS for all users 
        //
            bRetVal = SetSecurityDescriptorDacl (   
                            pSD,
                                            TRUE,
                                            pacl,
                                            FALSE 
                                            );
        if (!bRetVal)
        {
                dwError = GetLastError();
                     SATraceFailure ("SetAclFromComObject::SetSecurityDescriptorDacl failed:", dwError);
            break;
        }
    
        //
        // success
        //
    }
    while (false);
    
       //
    // in case of error, cleanup
    //
     if (dwError) 
     {
            if ( pacl ) 
            {
                   LocalFree ( pacl );
            }
        }
        else 
        {
            *ppacl = pacl;
        }


    //
    // free up resources now
    //
    if ( psidEveryoneSid ) {FreeSid ( psidEveryoneSid );}

        return (dwError);
}//End of SetAclFromComObject method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\taskcoordinatorimpl.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      taskcoordinatorimpl.cpp
//
// Project:     Chameleon
//
// Description: Task Coordinator Class Implementation
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 05/26/1999   TLP    Initial Version 
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Taskcoordinator.h"
#include "TaskCoordinatorImpl.h"
#include "asynctaskmanager.h"
#include "processmonitor.h"
#include <appmgrobjs.h>
#include <basedefs.h>
#include <atlhlpr.h>
#include <appsrvcs.h>
#include <comdef.h>
#include <comutil.h>
#include <satrace.h>

extern CAsyncTaskManager gTheTaskManager;

/////////////////////////////////////////////////////////////////////////////
// CTaskCoordinator

/////////////////////////////////////////////////////////////////////////////
// 
// Function: CTaskCoordinator
//
// Synopsis: Constructor
//
/////////////////////////////////////////////////////////////////////////////
CTaskCoordinator::CTaskCoordinator()
{
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: ~CTaskCoordinator
//
// Synopsis: Destructor
//
/////////////////////////////////////////////////////////////////////////////
CTaskCoordinator::~CTaskCoordinator()
{
}


_bstr_t    bstrAsyncTask = PROPERTY_TASK_ASYNC;
_bstr_t bstrTaskConcurrency = PROPERTY_TASK_CONCURRENCY;

/////////////////////////////////////////////////////////////////////////////
// 
// Function: OnTaskExecute()
//
// Synopsis: Task execution logic
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CTaskCoordinator::OnTaskExecute(
                            /*[in]*/ IUnknown* pTaskContext
                               )
{
    _ASSERT( NULL != pTaskContext );
    if ( NULL == pTaskContext )
    {
        return E_POINTER;
    }

    HRESULT hr = E_FAIL;

    TRY_IT

    do
    {
        CComPtr<ITaskContext> pTaskCtx;
        hr = pTaskContext->QueryInterface(IID_ITaskContext, (void**)&pTaskCtx);
        if ( FAILED(hr) )
        {
            SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could not get task context interface...");
            break; 
        }

        // Get the task concurrency setting

        _variant_t vtTaskConcurrency;
        if ( FAILED(pTaskCtx->GetParameter(bstrTaskConcurrency, &vtTaskConcurrency)) )
        { 
            SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could not get task concurrency setting...");
            break; 
        }
        _ASSERT( VT_I4 == V_VT(&vtTaskConcurrency) );
        if ( FAILED(pTaskCtx->RemoveParameter(bstrTaskConcurrency)) )
        {
            SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could not remove task concurrency setting...");
            break; 
        }

        // Determine if task execution should be performed
        // synchronously or asynchronously

        _variant_t    vtAsyncTask;
        hr = pTaskCtx->GetParameter(
                                      bstrAsyncTask,
                                      &vtAsyncTask
                                   );
        if ( SUCCEEDED(hr) )
        {
            hr = pTaskCtx->RemoveParameter(bstrAsyncTask);
            if ( FAILED(hr) )
            {
                SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could not remove IsAsync parameter...");
                break;
            }
            // Asyncronous task execution
            CComPtr<IUnknown> pTaskCtxUnkn;
            if ( SUCCEEDED(pTaskCtx->Clone(&pTaskCtxUnkn)) )
            {
                CComPtr<ITaskContext> pTaskCtxClone;
                hr = pTaskCtxUnkn->QueryInterface(IID_ITaskContext, (void**)&pTaskCtxClone);
                if ( SUCCEEDED(hr) )
                {
                    CLockIt theLock(*this);

                    bool bIsSingleton = V_BOOL(&vtTaskConcurrency) == VARIANT_FALSE ? false : true;
                    if ( ! gTheTaskManager.RunAsyncTask(
                                                        bIsSingleton,
                                                        CTaskCoordinator::Execute, 
                                                        pTaskCtxClone
                                                       ) )
                    {
                        hr = E_FAIL;
                    }
                }
            }
        }
        else
        {
            // Synchronous task execution
            hr = Execute(pTaskCtx);
            if ( SUCCEEDED(hr) )
            {
                // pTaskCtx->End();
            }
        }
    
    } while ( FALSE );
    
    CATCH_AND_SET_HR

    if ( FAILED(hr) )
    {
        // pTaskCtx->End();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// Function: OnTaskComplete()
//
// Synopsis: Not implemented by a task coordinator
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTaskCoordinator::OnTaskComplete(
                         /*[in]*/ IUnknown* pTaskContext, 
                         /*[in]*/ LONG      lTaskResult
                                )
{
    return E_NOTIMPL;
}


_bstr_t bstrMethodName = PROPERTY_TASK_METHOD_NAME;
_bstr_t bstrExecutables = PROPERTY_TASK_EXECUTABLES;
_bstr_t bstrMaxExecutionTime = PROPERTY_TASK_MET;

/////////////////////////////////////////////////////////////////////////////
// 
// Function: Execute()
//
// Synopsis: Function that performs task execution
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskCoordinator::Execute(
                  /*[in]*/ ITaskContext* pTaskCtx
                         )
{
    HRESULT hr = E_FAIL;

    TaskList  m_TaskExecutables;

    do
    {
        _variant_t vtTaskName;
        if ( FAILED(pTaskCtx->GetParameter(bstrMethodName, &vtTaskName)) )
        { 
            SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could not get task name...");
            break; 
        }
        _ASSERT( VT_BSTR == V_VT(&vtTaskName) );
        _variant_t vtTaskExecutables;
        if ( FAILED(pTaskCtx->GetParameter(bstrExecutables, &vtTaskExecutables)) )
        { 
            SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could not get task executables...");
            break; 
        }
        _ASSERT( VT_BSTR == V_VT(&vtTaskExecutables) );
        if ( FAILED(pTaskCtx->RemoveParameter(bstrExecutables)) )
        {
            SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could not remove task executables...");
            break; 
        }
        _variant_t vtMET;
        if ( FAILED(pTaskCtx->GetParameter(bstrMaxExecutionTime, &vtMET)) )
        { 
            SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could not get task max execution time...");
            break; 
        }
        _ASSERT( VT_I4 == V_VT(&vtMET) );
        if ( FAILED(pTaskCtx->RemoveParameter(bstrMaxExecutionTime)) )
        {
            SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could not remove task max execution time...");
            break; 
        }

        // Set the max execution time 
        if ( 0 == V_I4(&vtMET) )
        {
            V_I4(&vtMET) = DO_NOT_MONITOR;
        }
        // Instantiate a process monitor (does not do anything until started)
        // I'll move the process monitor logic outside OnTaskExecute() method if we 
        // decide to have a single task coordinator process act as a task 
        // execution surrogate. Note that when the task completes (end of this function)
        // the process monitor is destroyed.
        CProcessMonitor MyProcMonitor( 
                                      V_I4(&vtMET),     // Max execution time
                                      DO_NOT_MONITOR,    // Private Bytes - not monitored
                                      DO_NOT_MONITOR,    // Number of Threads - not monitored
                                      DO_NOT_MONITOR    // Number of Handles - not monitored
                                     );
        if ( DO_NOT_MONITOR != V_I4(&vtMET) )
        {
            if ( ! MyProcMonitor.Start() )
            {
                SATraceString("CTaskCoordinator::OnTaskExecute() - ERROR - Could start process monitor");
                break;
            }
        }

        // Create the list of task executables responsible for implementing this task. We
        // do this by scanning the string of ProgIDs inside vtTaskExecutables and 
        // instantiating each task executable from its ProgID.
        CScanIt theScanner(' ', V_BSTR(&vtTaskExecutables));
        CLSID clsid;
        IApplianceTask* pTaskExecutable = NULL;
        wchar_t szProgID[MAX_PATH + 1];
        while ( theScanner.NextToken(MAX_PATH, szProgID) )
        {
            hr = CLSIDFromProgID(szProgID, &clsid);
            if ( FAILED(hr) )
            { 
                SATracePrintf("CTaskCoordinator::OnTaskExecute() - ERROR - Could not get CLSID for %ls...", szProgID);
                hr = E_FAIL;
                break; 
            }
            hr = CoCreateInstance(
                                  clsid,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IApplianceTask,
                                  (void**)&pTaskExecutable
                                 );
            if ( FAILED(hr) )
            { 
                SATracePrintf("CTaskCoordinator::OnTaskExecute() - ERROR - Could not create task executable for %ls...", szProgID);
                hr = E_FAIL;
                break; 
            }

            m_TaskExecutables.push_back(pTaskExecutable);
        }

        // If we cannot instantiate all task executables then assume the task
        // is unusable. If this occurs all that is left to do is clean up and exit.
        if ( FAILED(hr) )
        {
            SATracePrintf("CTaskCoordinator::OnTaskExecute() - Releasing the executables for task: '%ls'", V_BSTR(&vtTaskName));
            TaskListIterator p = m_TaskExecutables.begin();
            while ( p != m_TaskExecutables.end() )
            {  
                try
                {
                    (*p)->Release();
                }
                catch(...)
                {
                    SATraceString("CTaskCoordinator::OnTaskExecute() - Caught unhandled exception in IUnkown::Release()");
                }
                p = m_TaskExecutables.erase(p); 
            }
        }
        else
        {
            int i = 0;    // Index into task executable list
            SATracePrintf("Task Coordinator is executing task: '%ls'", V_BSTR(&vtTaskName));

            // Execute the task. This is accomplished by invoking
            // OnTaskExecute() for each executable in the list or
            // until a task executable reports an error.
            TaskListIterator p = m_TaskExecutables.begin();

            //
            // we are no longer going to do a task transaction because
            // we don't access to the client credential on boot
            // MKarki - 11/15/2001
            //
            // CSATaskTransaction theTrans(false, pTaskCtx);
            //if ( theTrans.Commit() )
            //
            {
                while ( p != m_TaskExecutables.end() )
                { 
                    try
                    {
                        SATracePrintf("CTaskCoordinator::Execute() - OnTaskExecute() called on executable: %d for task '%ls'", i, V_BSTR(&vtTaskName));
                        hr = (*p)->OnTaskExecute(pTaskCtx);
                        SATracePrintf("CTaskCoordinator::Execute() - OnTaskExecute() returned from executable: %d for task '%ls'", i, V_BSTR(&vtTaskName));
                    }
                    catch(...)
                    {
                        SATraceString("CTaskCoordinator::Execute() - Caught unhandled exception in IApplianceTask::OnTaskExecute()");
                        hr = E_UNEXPECTED;
                    }
                    if ( FAILED(hr) )
                    { 
                        SATracePrintf("CTaskCoordinator::Execute() - INFO - Task Executable Failed for Task %ld...", i);
                        break; 
                    }
                    i++;
                    p++;
                }

                // Execute task postprocessing. Give the executables a
                // chance to rollback in the event of a failure.
                while ( p != m_TaskExecutables.begin() )
                {
                    i--;
                    p--;
                    try
                    {
                        SATracePrintf("CTaskCoordinator::Execute() - OnTaskComplete() called on executable: %d for task '%ls'", i, V_BSTR(&vtTaskName));
                        (*p)->OnTaskComplete(pTaskCtx, (LONG)hr);
                        SATracePrintf("CTaskCoordinator::Execute() - OnTaskComplete() returned from executable: %d for task '%ls'", i, V_BSTR(&vtTaskName));
                    }
                    catch(...)
                    {
                        SATraceString("CTaskCoordinator::Execute() - Caught unhandled exception in IApplianceTask::OnTaskComplete()");
                    }
                }
            }
            //else
            //{
            //    SATraceString("CTaskCoordinator::Execute() - ERROR - Could not commit task parameters... task execution failed");
            //    hr = E_UNEXPECTED;
            //}

            // Now release the task executables...
            i = 0;
            p = m_TaskExecutables.begin();
            while ( p != m_TaskExecutables.end() )
            {  
                try
                {
                    SATracePrintf("CTaskCoordinator::OnTaskExecute() - Releasing executable: %d for task: '%ls'", i, V_BSTR(&vtTaskName));
                    (*p)->Release();
                    SATracePrintf("CTaskCoordinator::OnTaskExecute() - Released executable: %d for task: '%ls'", i, V_BSTR(&vtTaskName));
                }
                catch(...)
                {
                    SATraceString("CTaskCoordinator::OnTaskExecute() - Caught unhandled exception in IUnkown::Release()");
                }
                p = m_TaskExecutables.erase(p); 
                i++;
            }
            if ( SUCCEEDED(hr) )
            {
                SATracePrintf("Task '%ls' completed successfully", V_BSTR(&vtTaskName));
            }
        }
    
    } while ( FALSE );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskctx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by taskctx.rc
//
#define IDS_PROJNAME                    100
#define IDS_TASKCONTEXT_DESC            101
#define IDR_TaskContext                 102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskcoordinator\taskcoordinatorimpl.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      TaskCoordinatorImpl.h
//
// Project:     Chameleon
//
// Description: Appliance Task Coordinator Class Defintion
//
// Log: 
//
// Who     When            What
// ---     ----         ----
// TLP       05/14/1999    Original Version
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __TASKCOORDINATORIMPL_H_
#define __TASKCOORDINATORIMPL_H_

#include "resource.h"       // main symbols
#include <taskctx.h>
#include <workerthread.h>

#pragma warning( disable : 4786 )
#include <list>
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CTaskCoordinatorImpl

class ATL_NO_VTABLE CTaskCoordinator : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTaskCoordinator, &CLSID_TaskCoordinator>,
    public IDispatchImpl<IApplianceTask, &IID_IApplianceTask, &LIBID_TASKCOORDINATORLib>
{

public:
    
    CTaskCoordinator();

    ~CTaskCoordinator();

DECLARE_CLASSFACTORY_SINGLETON(CTaskCoordinator)

DECLARE_REGISTRY_RESOURCEID(IDR_TASKCOORDINATORIMPL)

DECLARE_NOT_AGGREGATABLE(CTaskCoordinator)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTaskCoordinator)
    COM_INTERFACE_ENTRY(IApplianceTask)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    //////////////////////////////////////////////////////////////////////////
    // IApplianceTask Interface
        
    STDMETHOD(OnTaskExecute)(
                              /*[in]*/ IUnknown* pTaskContext
                            );

    STDMETHOD(OnTaskComplete)(
                               /*[in]*/ IUnknown* pTaskContext, 
                               /*[in]*/ LONG      lTaskResult
                             );

    // Task exeuction function (does all the real work)
    static HRESULT Execute(
                   /*[in]*/ ITaskContext* pTaskCtx
                          );

private:
    
    // List of task executables

    typedef list< IApplianceTask* >  TaskList;
    typedef TaskList::iterator         TaskListIterator;
};

#endif //__TASKCOORDINATORIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskctx\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__84DA87F6_CB46_11D2_BF23_00105A1F3461__INCLUDED_)
#define AFX_STDAFX_H__84DA87F6_CB46_11D2_BF23_00105A1F3461__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__84DA87F6_CB46_11D2_BF23_00105A1F3461__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\display.cpp ===
//#--------------------------------------------------------------
//
//  File:        display.cpp
//
//  Synopsis:   Implementation of CDisplay class methods
//
//
//  History:   MKarki Created  5/27/99
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "stdafx.h"
#include "display.h"
#include <satrace.h>



//++--------------------------------------------------------------
//
//  Function:   Shutdown
//
//  Synopsis:   This is the  CDipslay class public method which is 
//              used to send the Shutdown message
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     5/27/99
//
//----------------------------------------------------------------
HRESULT 
CDisplay::Shutdown (
            VOID
            )
{
    SATraceString ("LocalUI display showing 'Shutdown' message...");

    HRESULT hr = S_OK;
    do
    {
        //
        // check if the display object is initialized
        //
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();

            if (FAILED (hr)) {break;}
        }

        //
        // display the shutdown message on the LCD now
        //      
        hr = m_pSaDisplay->ShowRegistryBitmap (SA_DISPLAY_SHUTTING_DOWN);
        if (FAILED (hr)) {break;}

        //
        // success
        //
    }   
    while (false);

    return (hr);

}   //  end of CDisplay::Shutdown method

//++--------------------------------------------------------------
//
//  Function:   Busy
//
//  Synopsis:   This is the  CDisplay class public method which is 
//              used to sends the busy message bitmap 
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     5/27/99
//
//----------------------------------------------------------------
HRESULT 
CDisplay::Busy (
            VOID
            )
{
    SATraceString ("LocalUI display class showing 'Busy' message...");

    HRESULT hr = S_OK;
    do
    {
        //
        // check if the display object is initialized
        //
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();
            if (FAILED (hr)) {break;}
        }
    
        //
        // display the busy on the LCD now
        //      
        hr = m_pSaDisplay->ShowRegistryBitmap (SA_DISPLAY_CHECK_DISK);
        if (FAILED (hr)) {break;}
        
        //
        // success
        //
    }   
    while (false);

    return (hr);

}   //  end of CDisplay::Busy method

//++--------------------------------------------------------------
//
//  Function:   Lock
//
//  Synopsis:   This is the  CDisplay class public method which is 
//              used to lock the localui display 
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     7/3/99
//
//----------------------------------------------------------------
HRESULT 
CDisplay::Lock (
            VOID
            )
{
    SATraceString ("LocalUI locking driver ...");

    HRESULT hr = S_OK;
    do
    {
        //
        // check if the display object is initialized
        //
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();
            if (FAILED (hr)) {break;}
        }
    
        //
        // lock the driver now
        //      
        hr = m_pSaDisplay->Lock();
        if (FAILED (hr)) {break;}
        
        //
        // success
        //
    }   
    while (false);

    return (hr);

}   //  end of CDisplay::Lock method

//++--------------------------------------------------------------
//
//  Function:   UnLock
//
//  Synopsis:   This is the  CDisplay class public method which is 
//              used to unlock the localui display 
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     7/3/99
//
//----------------------------------------------------------------
HRESULT 
CDisplay::Unlock (
            VOID
            )
{
    SATraceString ("Localui Display class unlocking driver ...");

    HRESULT hr = S_OK;
    do
    {
        //
        // check if the display object is initialized
        //
        if (!m_bInitialized) 
        {
            hr = InternalInitialize ();
            if (FAILED (hr)) {break;}
        }
    
        //
        // unlock the driver now
        //      
        hr = m_pSaDisplay->UnLock();
        if (FAILED (hr)) {break;}
        
        //
        // success
        //
    }   
    while (false);

    return (hr);

}   //  end of CDisplay::Unlock method
//++--------------------------------------------------------------
//
//  Function:   InternalInitialize
//
//  Synopsis:   This is the  CDisplay class private method which is 
//              initializes the CDisplay class object
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     6/10/99
//
//  Called By:  CDisplay public methods
//
//----------------------------------------------------------------
HRESULT 
CDisplay::InternalInitialize (
    VOID
    )
{
    CSATraceFunc ("CDisplay::InternalInitialize");

    HRESULT hr = S_OK;
    do
    {
        hr = CoInitialize(NULL);
        if (FAILED(hr)) {break;}

        //
        // create the display helper component
        //
        hr = CoCreateInstance(
                            CLSID_SaDisplay,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ISaDisplay,
                            (void**)&m_pSaDisplay
                            );
        if (FAILED(hr))
        {
            SATracePrintf("CDisplay::InternalInitialize failed on CoCreateInstance, %d",hr);
            break;
        }
        m_bInitialized = TRUE;
    }
    while (false);

    return (hr);

}   // end of CDisplay::InternalInitialize method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskctx\taskctx.cpp ===
// taskctx.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f taskctxps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "taskctx.h"
#include "TaskContext.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TaskContext, CTaskContext)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance /*, &LIBID_TASKCTXLib*/);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(/*TRUE*/);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\display.h ===
//#--------------------------------------------------------------
//
//  File:       display.h
//
//  Synopsis:   This file holds the declarations of the
//                CDisplay class .The class is responsible
//              for displaying the appropriate bitmap on
//              the local display
//
//  History:     5/28/99 
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef __DISPLAY_H_
#define __DISPLAY_H_

#include "sacom.h"

#define SA_DISPLAY_SHUTTING_DOWN            0x00000002    // OS is shutting down
#define SA_DISPLAY_CHECK_DISK               0x00000010    // autochk.exe is running

class CDisplay
{
public:

    //
    // constructor
    //
    CDisplay ()
        :m_bInitialized (false),
         m_pSaDisplay (NULL)
    {
    }

    //
    // destructor
    //
    ~CDisplay ()
    {
        m_pSaDisplay = NULL;
    }
    

    //
    // send the shutting down message to the local display
    // a member 
    //
    HRESULT Shutdown ();
    //
    // send the busy message to the local display
    // a member 
    //
    HRESULT Busy ();

    //
    // lock the driver to prevent writes
    //
    HRESULT Lock ();

    //
    // Unlock the driver to allow writes
    //
    HRESULT Unlock ();
    

private:

    //
    // method to carry out the initialization
    //
    HRESULT InternalInitialize (VOID);


    //
    // signifies initialized
    //
    bool    m_bInitialized;

    //
    // handle to helper object
    //
    CComPtr<ISaDisplay> m_pSaDisplay;

};   // end of CDisplay class declaration

#endif __DISPLAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskctx\taskcontext.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      taskcontext.cpp
//
// Project:     Chameleon
//
// Description: Appliance Task Context Class Implementation
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "taskctx.h"
#include "TaskContext.h"
#include <appmgrobjs.h>
#include <propertybagfactory.h>
#include <satrace.h>
#include <comdef.h>
#include <comutil.h>

//////////////////////////////////////////////////////////////////////////
//
// Function:    InternalInitialize()
//
// Synopsis:    Initialize the context object and make it ready for
//                subsequent use.
//
//////////////////////////////////////////////////////////////////////////
HRESULT CTaskContext::InternalInitialize(VARIANT* pWbemContext)
{
    HRESULT hr = E_FAIL;

    if ( pWbemContext )
    {
        hr = (V_UNKNOWN(pWbemContext))->QueryInterface(IID_IWbemContext, (void**)&m_pWbemCtx);
        if ( SUCCEEDED(hr) )
        { m_bInitialized = true; }
    }
    else
    {
        CComPtr<IWbemContext> pCtx;
        hr = CoCreateInstance(
                              CLSID_WbemContext,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IWbemContext,
                              (void**)&pCtx
                             );
        if ( SUCCEEDED(hr) )
        { 
            m_pWbemCtx = pCtx;
            m_bInitialized = true; 
        }
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    GetParameter()
//
// Synopsis:    Get a task parameter (from the underlying wbem context)
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CTaskContext::GetParameter(
                                /*[in]*/ BSTR        bstrName,
                       /*[out, retval]*/ VARIANT*    pValue
                                       )
{
    _ASSERT( NULL != bstrName && NULL != pValue );
    if ( NULL == bstrName || NULL == pValue )
    { return E_POINTER; }

    CLockIt theLock(*this);

    HRESULT hr;

    TRY_IT

    if ( ! m_bInitialized )
    {
        hr = InternalInitialize(NULL);
        if ( FAILED(hr) )
        { return hr; }
    }
    _ASSERT( m_pWbemCtx );
    if ( ! lstrcmpi(bstrName, PROPERTY_TASK_CONTEXT) )
    {
        _variant_t vtWbemCtx = (IUnknown*)((IWbemContext*)m_pWbemCtx);
        hr = VariantCopy(pValue, &vtWbemCtx);
    }
    else
    {
        hr = m_pWbemCtx->GetValue(bstrName, 0, pValue);
        if ( FAILED(hr) )
        {
            if ( WBEM_E_NOT_FOUND == hr )
            {
                hr = DISP_E_MEMBERNOTFOUND;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    
    CATCH_AND_SET_HR

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    SetParameter()
//
// Synopsis:    Set a task parameter (into the underlying wbem context)
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CTaskContext::SetParameter(
                                /*[in]*/ BSTR      bstrName,
                                /*[in]*/ VARIANT* pValue
                                       )
{
    _ASSERT( NULL != bstrName && NULL != pValue );
    if ( NULL == bstrName || NULL == pValue )
    { return E_POINTER; }

    CLockIt theLock(*this);

    HRESULT hr = E_FAIL;

    TRY_IT

    if ( ! m_bInitialized )
    {
        // One shot initialization...
        if ( ! lstrcmpi(bstrName, PROPERTY_TASK_CONTEXT) )
        {
            _ASSERT( VT_UNKNOWN == V_VT(pValue) );
            hr = InternalInitialize(pValue);
            { return hr; }
        }
        else
        {
            hr = InternalInitialize(NULL);
            if ( FAILED(hr) )
            { return hr; }
        }
    }
    _ASSERT( m_pWbemCtx );
    hr = m_pWbemCtx->SetValue(bstrName, 0, pValue);
    if ( FAILED(hr) )
    { hr = E_FAIL; }

    CATCH_AND_SET_HR

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    SaveParameters()
//
// Synopsis:    Save task parameters (state) into the 
//                given data store object
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CTaskContext::SaveParameters(
                                  /*[in]*/ BSTR  bstrObjectPath
                                         )
{
    _ASSERT( NULL != bstrObjectPath );
    if ( NULL == bstrObjectPath )
    { return E_POINTER; }

    CLockIt theLock(*this);

    HRESULT hr;

    TRY_IT

    if ( ! m_bInitialized )
    {
        hr = InternalInitialize(NULL );
        if ( FAILED(hr) )
            return hr;
    }
    if ( Save(bstrObjectPath) )
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }
    
    CATCH_AND_SET_HR

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Function:    RestoreParameter()
//
// Synopsis:    Restore task parameters (state) from the 
//                given data store object
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CTaskContext::RestoreParameters(
                                     /*[in]*/ BSTR  bstrObjectPath
                                            )
{
    _ASSERT( NULL != bstrObjectPath );
    if ( NULL == bstrObjectPath )
    { return E_POINTER; }

    CLockIt theLock(*this);

    HRESULT hr;

    TRY_IT

    if ( ! m_bInitialized )
    {
        hr = InternalInitialize(NULL);
        if ( FAILED(hr) )
            return hr;
    }

    if ( Load(bstrObjectPath) )
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    CATCH_AND_SET_HR

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Function:    Clone()
//
// Synopsis:    Make a replica of the task context object
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CTaskContext::Clone(
                         /*[in]*/ IUnknown** ppTaskContext
                                )
{
    _ASSERT( NULL != ppTaskContext );
    if ( NULL == ppTaskContext )
    { return E_POINTER; }

    CLockIt theLock(*this);

    HRESULT hr = E_FAIL;

    TRY_IT

    if ( ! m_bInitialized )
    {
        hr = InternalInitialize(NULL);
        if ( FAILED(hr) )
            return hr;
    }

    hr = CoCreateInstance(
                          CLSID_TaskContext,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void**)ppTaskContext
                         );
    if ( SUCCEEDED(hr) )
    { 
        CComPtr<ITaskContext> pTaskCtx;
        hr = (*ppTaskContext)->QueryInterface(IID_ITaskContext, (void**)&pTaskCtx);
        if ( SUCCEEDED(hr) )
        {
            hr = m_pWbemCtx->BeginEnumeration(0);
            if ( SUCCEEDED(hr) )
            {
                while ( SUCCEEDED(hr) )
                {
                    {
                        BSTR       bstrValueName;
                        _variant_t vtValue;

                        hr = m_pWbemCtx->Next(0, &bstrValueName, &vtValue);
                        if ( FAILED(hr) )
                        {
                            hr = E_FAIL;
                            break;
                        }
                        else if ( WBEM_S_NO_MORE_DATA == hr )
                        {
                            hr = S_OK;
                            break;
                        }
                        else
                        {
                            hr = pTaskCtx->SetParameter(bstrValueName, &vtValue);
                            SysFreeString(bstrValueName);
                            if ( FAILED(hr) )
                            {
                                break;
                            }
                        }
                    }
                }

                m_pWbemCtx->EndEnumeration();
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    if ( FAILED(hr) )
    {
        *ppTaskContext = NULL;
    }

    CATCH_AND_SET_HR

    return hr;
}    


//////////////////////////////////////////////////////////////////////////
//
// Function:    SetParameter()
//
// Synopsis:    Set a task parameter (into the underlying wbem context)
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP CTaskContext::RemoveParameter(
                                   /*[in]*/ BSTR  bstrName
                                          )
{
    _ASSERT( NULL != bstrName );
    if ( NULL == bstrName )
    { return E_POINTER; }

    CLockIt theLock(*this);

    HRESULT hr = E_FAIL;

    TRY_IT

    if ( ! m_bInitialized )
    {
        // One shot initialization...
        hr = InternalInitialize(NULL);
        if ( FAILED(hr) )
        { return hr; }
    }

    _ASSERT( m_pWbemCtx );
    hr = m_pWbemCtx->DeleteValue(bstrName, 0);
    if ( FAILED(hr) )
    { hr = E_FAIL; }

    CATCH_AND_SET_HR

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
const wchar_t g_szChkSum[] = L"CheckSum";
const DWORD   g_dwChkSumSeed = 0xf0f0f0f0;

//////////////////////////////////////////////////////////////////////////////
//
// Function: Load()
//
// Synopsis: This function is responsible for loading the task context 
//             parameters from the persistent store.
//
//////////////////////////////////////////////////////////////////////////////
bool
CTaskContext::Load(
                   /*[in]*/ BSTR bstrObjectPath
                  )
{
    bool bRet = false;

    do
    {
        CLocationInfo LocInfo(HKEY_LOCAL_MACHINE, bstrObjectPath);
        PPROPERTYBAG pBag = ::MakePropertyBag(
                                               PROPERTY_BAG_REGISTRY,
                                               LocInfo
                                             );
        if ( ! pBag.IsValid() )
        {
            SATracePrintf("CTaskContext::Load() - ERROR - Could not locate data store object '%ls'", bstrObjectPath);
            break;
        }
        if ( ! pBag->open() )
        {
            SATracePrintf("CTaskContext::Load() - ERROR - Could not open data store object '%ls'", bstrObjectPath);
            break;
        }

        _variant_t vtChkSum;
        if ( ! pBag->get(g_szChkSum, &vtChkSum) )
        {
            SATraceString("CTaskContext::Load() - ERROR - Could not retrieve checksum property");
            break;
        }

        DWORD        dwChkSum = g_dwChkSumSeed;
        wchar_t        szName[MAX_PATH];
        bool        bErr = false;

        m_pWbemCtx->DeleteAll();
        pBag->reset();

        while ( pBag->next() )
        {
            {
                _variant_t    vtValue;
                if ( pBag->current(szName, &vtValue) )
                {
                    if ( lstrcmpi(szName, g_szChkSum) )
                    {
                        VARTYPE vt = V_VT(&vtValue) & ~VT_ARRAY;
                        switch ( vt )
                        {
                            case VT_UI1:
                            case VT_I2:
                            case VT_BOOL:
                            case VT_I4:
                            case VT_R4:
                            case VT_R8:
                            case VT_CY:
                            case VT_DATE:
                            case VT_ERROR:
                            case VT_BSTR:
                                {
                                    dwChkSum ^= lstrlen(szName);
                                    _bstr_t bstrName = szName;
                                    HRESULT hr = m_pWbemCtx->SetValue(bstrName, 0, &vtValue);
                                    if ( FAILED(hr) )
                                    {
                                        SATracePrintf("CTaskContext::Load() - ERROR - IWbemContext::SetValue() returned %lx", hr);
                                        bErr = true;
                                    }
                                }
                                break;

                            default:
                                SATracePrintf("CTaskContext::Load() - ERROR - Cannot restore type %lx", vt);
                                bErr = true;
                                break;
                        };
                    }
                }
                else
                {
                    SATraceString("CTaskContext::Load() - ERROR - Property bag malfunction");
                    bErr = true;
                    break;
                }
            }
        }

        if ( bErr )
        {
            m_pWbemCtx->DeleteAll();
        }
        else
        {
            if ( dwChkSum == V_I4(&vtChkSum) )
            {
                bRet = true;
            }
            else
            {
                SATraceString("CTaskContext::Load() - ERROR - Invalid checksum");
                m_pWbemCtx->DeleteAll();
            }
        }

    } while (FALSE);

    return bRet;
}


//////////////////////////////////////////////////////////////////////////////
//
// Function: Save()
//
// Synopsis: This function is responsible for saving the task context 
//             parameters to the persistent store.
//
//////////////////////////////////////////////////////////////////////////////
bool
CTaskContext::Save(
                   /*[in]*/ BSTR bstrObjectPath
                  )
{
    bool bRet = false;

    do
    {
        CLocationInfo LocInfo(HKEY_LOCAL_MACHINE, bstrObjectPath);
        PPROPERTYBAG pBag = ::MakePropertyBag(
                                               PROPERTY_BAG_REGISTRY,
                                               LocInfo
                                             );
        if ( ! pBag.IsValid() )
        {
            SATracePrintf("CTaskContext::Load() - ERROR - Could not locate data store object '%ls'", bstrObjectPath);
            break;
        }
        if ( ! pBag->open() )
        {
            SATracePrintf("CTaskContext::Save() - ERROR - Could not open data store object '%ls'", bstrObjectPath);
            break;
        }

        HRESULT hr = m_pWbemCtx->BeginEnumeration(0);
        if ( FAILED(hr) )
        {
            SATracePrintf("CTaskContext::Save() - ERROR - IWbemContext::BeginEnumeration() returned: %lx", hr);
            break;
        }

        DWORD dwChkSum = g_dwChkSumSeed;

        while ( SUCCEEDED(hr) )
        {
            {
                BSTR       bstrValueName;
                _variant_t vtValue;

                hr = m_pWbemCtx->Next(0, &bstrValueName, &vtValue);
                if ( FAILED(hr) )
                {
                    SATracePrintf("CTaskContext::Save() - ERROR - IWbemContext::Next() returned: %lx", hr);
                    break;
                }
                else if ( WBEM_S_NO_MORE_DATA == hr )
                {
                    hr = S_OK;
                    break;
                }
                else
                {
                    VARTYPE vt = V_VT(&vtValue) & ~VT_ARRAY;
                    switch ( vt )
                    {
                        case VT_UI1:
                        case VT_I2:
                        case VT_BOOL:
                        case VT_I4:
                        case VT_R4:
                        case VT_R8:
                        case VT_CY:
                        case VT_DATE:
                        case VT_ERROR:
                        case VT_BSTR:

                            dwChkSum ^= lstrlen(bstrValueName);
                            if ( ! pBag->put(bstrValueName, &vtValue) )
                            {
                                SATracePrintf("CTaskContext::Save() - ERROR - Could not save task parameter '%ls'", bstrValueName);
                                hr = E_FAIL;
                            }
                            break;

                        default:

                            SATracePrintf("CTaskContext::Save() - ERROR - Cannot persist type %lx!", vt);
                            hr = E_FAIL;
                            break;
                    };
                    
                    SysFreeString(bstrValueName);
                }
            }
        }
        
        m_pWbemCtx->EndEnumeration();
        
        if ( SUCCEEDED(hr) )
        {
            _variant_t vtChkSum = (LONG)dwChkSum;
            if ( pBag->put(g_szChkSum, &vtChkSum) )
            {
                if ( pBag->save() )
                {
                    bRet = true;
                }
                else
                {
                    SATraceString("CTaskContext::Save() - ERROR - Could not persist task parameters");
                }
            }
            else
            {
                SATraceString("CTaskContext::Save() - ERROR - Could not persist checksum");
            }
        }

    } while ( FALSE );

    return bRet;
};

//**********************************************************************
// 
// FUNCTION:  IsOperationAllowedForClient - This function checks the token of the 
//            calling thread to see if the caller belongs to the Local System account
// 
// PARAMETERS:   none
// 
// RETURN VALUE: TRUE if the caller is an administrator on the local
//            machine.  Otherwise, FALSE.
// 
//**********************************************************************
BOOL 
CTaskContext::IsOperationAllowedForClient (
            VOID
            )
{

    HANDLE hToken = NULL;
    DWORD  dwStatus  = ERROR_SUCCESS;
    DWORD  dwAccessMask = 0;;
    DWORD  dwAccessDesired = 0;
    DWORD  dwACLSize = 0;
    DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
    PACL   pACL            = NULL;
    PSID   psidLocalSystem  = NULL;
    BOOL   bReturn        =  FALSE;

    PRIVILEGE_SET   ps;
    GENERIC_MAPPING GenericMapping;

    PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;

    CSATraceFunc objTraceFunc ("CTaskContext::IsOperationAllowedForClient ");
       
    do
    {
        //
        // we assume to always have a thread token, because the function calling in
        // appliance manager will be impersonating the client
        //
        bReturn  = OpenThreadToken(
                               GetCurrentThread(), 
                               TOKEN_QUERY, 
                               FALSE, 
                               &hToken
                               );
        if (!bReturn)
        {
            OutputDebugString(L"failed OpenThreadToken");
            SATraceFailure ("CTaskContext::IsOperationAllowedForClient failed on OpenThreadToken:", GetLastError ());
            break;
        }


        //
        // Create a SID for Local System account
        //
        bReturn = AllocateAndInitializeSid (  
                                        &SystemSidAuthority,
                                        1,
                                        SECURITY_LOCAL_SYSTEM_RID,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        &psidLocalSystem
                                        );
        if (!bReturn)
        {     
            SATraceFailure ("CTaskContext:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  GetLastError ());
            break;
        }
    
        //
        // get memory for the security descriptor
        //
        psdAdmin = HeapAlloc (
                              GetProcessHeap (),
                              0,
                              SECURITY_DESCRIPTOR_MIN_LENGTH
                              );
        if (NULL == psdAdmin)
        {
            SATraceString ("CTaskContext::IsOperationForClientAllowed failed on HeapAlloc");
            bReturn = FALSE;
            break;
        }
      
        bReturn = InitializeSecurityDescriptor(
                                            psdAdmin,
                                            SECURITY_DESCRIPTOR_REVISION
                                            );
        if (!bReturn)
        {
            SATraceFailure ("CTaskContext::IsOperationForClientAllowed failed on InitializeSecurityDescriptor:", GetLastError ());
            break;
        }

        // 
        // Compute size needed for the ACL.
        //
        dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                    GetLengthSid (psidLocalSystem);

        //
        // Allocate memory for ACL.
        //
        pACL = (PACL) HeapAlloc (
                                GetProcessHeap (),
                                0,
                                dwACLSize
                                );
        if (NULL == pACL)
        {
            SATraceString ("CTaskContext::IsOperationForClientAllowed failed on HeapAlloc2");
            bReturn = FALSE;
            break;
        }

        //
        // Initialize the new ACL.
        //
        bReturn = InitializeAcl(
                              pACL, 
                              dwACLSize, 
                              ACL_REVISION2
                              );
        if (!bReturn)
        {
            SATraceFailure ("CTaskContext::IsOperationForClientAllowed failed on InitializeAcl", GetLastError ());
            break;
        }


        // 
        // Make up some private access rights.
        // 
        const DWORD ACCESS_READ = 1;
        const DWORD  ACCESS_WRITE = 2;
        dwAccessMask= ACCESS_READ | ACCESS_WRITE;

        //
        // Add the access-allowed ACE to the DACL for Local System
        //
        bReturn = AddAccessAllowedAce (
                                    pACL, 
                                    ACL_REVISION2,
                                    dwAccessMask, 
                                    psidLocalSystem
                                    );
        if (!bReturn)
        {
            SATraceFailure ("CTaskContext::IsOperationForClientAllowed failed on AddAccessAllowedAce (LocalSystem)", GetLastError ());
            break;
        }
              
        //
        // Set our DACL to the SD.
        //
        bReturn = SetSecurityDescriptorDacl (
                                          psdAdmin, 
                                          TRUE,
                                          pACL,
                                          FALSE
                                          );
        if (!bReturn)
        {
            SATraceFailure ("CTaskContext::IsOperationForClientAllowed failed on SetSecurityDescriptorDacl", GetLastError ());
            break;
        }

        //
        // AccessCheck is sensitive about what is in the SD; set
        // the group and owner.
        //
        SetSecurityDescriptorGroup(psdAdmin, psidLocalSystem, FALSE);
        SetSecurityDescriptorOwner(psdAdmin, psidLocalSystem, FALSE);

        bReturn = IsValidSecurityDescriptor(psdAdmin);
        if (!bReturn)
        {
            SATraceFailure ("CTaskContext::IsOperationForClientAllowed failed on IsValidSecurityDescriptorl", GetLastError ());
            break;
        }
     

        dwAccessDesired = ACCESS_READ;

        // 
        // Initialize GenericMapping structure even though we
        // won't be using generic rights.
        // 
        GenericMapping.GenericRead    = ACCESS_READ;
        GenericMapping.GenericWrite   = ACCESS_WRITE;
        GenericMapping.GenericExecute = 0;
        GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;
        BOOL bAccessStatus = FALSE;

        OutputDebugString(L"before AccessCheck");
        //
        // check the access now
        //
        bReturn = AccessCheck  (
                                psdAdmin, 
                                hToken, 
                                dwAccessDesired, 
                                &GenericMapping, 
                                &ps,
                                &dwStructureSize, 
                                &dwStatus, 
                                &bAccessStatus
                                );

        if (!bReturn || !bAccessStatus)
        {
            WCHAR szDebug[1024];
            wsprintf(szDebug,L"%x failed",GetLastError());
            OutputDebugString(szDebug);

            SATraceFailure ("CTaskContext::IsOperationForClientAllowed failed on AccessCheck", GetLastError ());
        } 
        else
        {
            SATraceString ("Client is allowed to carry out operation!");
        }

        //
        // successfully checked 
        //
        bReturn  = bAccessStatus;        
 
    }    
    while (false);

    //
    // Cleanup 
    //
    if (pACL) 
    {
        HeapFree (GetProcessHeap (), 0, pACL);
    }

    if (psdAdmin) 
    {
        HeapFree (GetProcessHeap (), 0, psdAdmin);
    }
          

    if (psidLocalSystem) 
    {
        FreeSid(psidLocalSystem);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return (bReturn);

}// end of CTaskContext::IsOperationValidForClient method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\ieeventhandler.h ===
//#--------------------------------------------------------------
//
//  File:       ieeventhandler.h
//
//  Synopsis:   This file holds the declarations and implementation of the
//                CWebBrowserEventSink class
//
//  History:     11/10/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------


#ifndef _IEEVENTHANDLER_H_
#define _IEEVENTHANDLER_H_


class CMainWindow;
//
//    This class implements DIID_DWebBrowserEvents2 interface through
//    IDispatch to retrieve the events from IE control
//
class ATL_NO_VTABLE CWebBrowserEventSink : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatch

{
    BEGIN_COM_MAP(CWebBrowserEventSink)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(DIID_DWebBrowserEvents2, IDispatch)
    END_COM_MAP()

public:
    //
    //Constructor for CWebBrowserEventSink
    //Initialize the member variables
    //
    CWebBrowserEventSink() 
        :m_pMainWindow(NULL),
         m_bMainControl(true)
    {
    }

    //
    //None of the IDispatch methods are used, except Invoke
    //
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo) 
    { 
        return E_NOTIMPL; 
    }

    //
    //None of the IDispatch methods are used, except Invoke
    //
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo) 
    { 
        return E_NOTIMPL; 
    }

    //
    //None of the IDispatch methods are used, except Invoke
    //
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid) 
    { 
        return E_NOTIMPL; 
    }

    //
    //Notify the main 
    //
    STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, 
                        WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
                        EXCEPINFO* pexcepinfo, UINT* puArgErr);


public:
    //
    //pointer to main window to notify the window about IE control events
    //
    CMainWindow* m_pMainWindow;

    //
    //variable to distinguish event sinks for main IE control and secondary
    //one that is used to render startup and shutdown bitmaps
    //
    bool m_bMainControl;
};

#endif //_IEEVENTHANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\langchange.h ===
//#--------------------------------------------------------------
//
//  File:       langchange.h
//
//  Synopsis:   This file holds the declarations of the
//                CLangChange class
//
//
//  History:     05/24/2000  BalajiB Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#ifndef _LANGCHANGE_H_
#define _LANGCHANGE_H_

#include "stdafx.h"
#include "salangchange.h"
#include "satrace.h"


//
// declaration of CLangChange class
//
class CLangChange : public ISALangChange
{
public:
    //
    // constructor
    //
    CLangChange() : m_lRef(0),
                    m_hWnd(NULL)
    {}

    //
    // destructor cleans up resources
    //
    ~CLangChange() {}

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    //  IDispatch interface - not implemented
    //
    STDMETHODIMP GetTypeInfoCount(
                    /*[out]*/ UINT __RPC_FAR *pctinfo
                                 )
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP GetTypeInfo( 
                   /* [in] */ UINT iTInfo,
                   /* [in] */ LCID lcid,
                   /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo
                            )
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP GetIDsOfNames( 
                   /* [in] */ REFIID riid,
                   /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
                   /* [in] */ UINT cNames,
                   /* [in] */ LCID lcid,
                   /* [size_is][out] */ DISPID __RPC_FAR *rgDispId
                              )
    {
        return E_NOTIMPL;
    }
    
    STDMETHODIMP Invoke( 
                   /* [in] */ DISPID dispIdMember,
                   /* [in] */ REFIID riid,
                   /* [in] */ LCID lcid,
                   /* [in] */ WORD wFlags,
                   /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
                   /* [out] */ VARIANT __RPC_FAR *pVarResult,
                   /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
                   /* [out] */ UINT __RPC_FAR *puArgErr
                        )
    {
        return E_NOTIMPL;
    }


    STDMETHODIMP InformChange(
                      /*[in]*/ BSTR          bstrLangDisplayName,
                      /*[in]*/ BSTR          bstrLangISOName,
                      /*[in]*/ unsigned long ulLangID
                             );
                             
    //
    // method provided by class so that CDisplayWorker::Initialize
    // can set the I/O completion port handle to be used by
    // InformChange() 
    //
    void OnLangChangeCallback(HWND hWnd)
    {
        m_hWnd = hWnd;
    }

    void ClearCallback(void)
    {
        m_hWnd = NULL;
    }

private:
    LONG   m_lRef;
    HWND   m_hWnd;

};

#endif // _LANGCHANGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\core\taskctx\taskcontext.h ===
///////////////////////////////////////////////////////////////////////////
//
// Copyright(C) 1999 Microsoft Corporation all rights reserved.
//
// Module:      taskcontext.h
//
// Project:     Chameleon
//
// Description: Appliance Task Context Class 
//
// Log:
//
// When         Who    What
// ----         ---    ----
// 02/08/1999   TLP    Initial Version
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __INC_SA_TASK_CONTEXT_H_
#define __INC_SA_TASK_CONTEXT_H_

#include "resource.h"
#include <basedefs.h>
#include <atlhlpr.h>
#include <taskctx.h>
#include <comdef.h>
#include <comutil.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <atlctl.h>

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// TaskContext

class CTaskContext : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTaskContext,&CLSID_TaskContext>,
    public IDispatchImpl<ITaskContext, &IID_ITaskContext, &LIBID_TASKCTXLib>,
    public IObjectSafetyImpl<CTaskContext>
{
public:
    
    CTaskContext()
        : m_bInitialized(false) { }

    ~CTaskContext() { }

BEGIN_COM_MAP(CTaskContext)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITaskContext)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()


DECLARE_NOT_AGGREGATABLE(CTaskContext) 

DECLARE_REGISTRY_RESOURCEID(IDR_TaskContext)



    //
    // This interface is implemented to mark the component as safe for scripting
    // IObjectSafety interface methods
    //
    STDMETHOD(SetInterfaceSafetyOptions)
                        (
                        REFIID riid, 
                        DWORD dwOptionSetMask, 
                        DWORD dwEnabledOptions
                        )
    {
        BOOL bSuccess = ImpersonateSelf(SecurityImpersonation);
  
        if (!bSuccess)
        {
            return E_FAIL;

        }

        bSuccess = IsOperationAllowedForClient();

        RevertToSelf();

        return bSuccess? S_OK : E_FAIL;
    }

    // ITaskContext Interface

    STDMETHOD(GetParameter)(
                    /*[in]*/ BSTR        bstrName,
           /*[out, retval]*/ VARIANT*    pValue
                            );

    STDMETHOD(SetParameter)(
                    /*[in]*/ BSTR      bstrName,
                    /*[in]*/ VARIANT* pValue
                            );

    STDMETHOD(SaveParameters)(
                      /*[in]*/ BSTR  bstrObjectPath
                             );

    STDMETHOD(RestoreParameters)(
                         /*[in]*/  BSTR  bstrObjectPath
                                );    

    STDMETHOD(Clone)(
             /*[in]*/ IUnknown** ppTaskContext
                    );

    STDMETHOD(RemoveParameter)(
                       /*[in]*/ BSTR bstrName
                              );

private:

    HRESULT InternalInitialize(VARIANT* pValue);

    //
    // 
    // IsOperationAllowedForClient - This function checks the token of the 
    // calling thread to see if the caller belongs to the Local System account
    // 
    BOOL IsOperationAllowedForClient (
                                      VOID
                                     );

    bool Load(
      /*[in]*/ BSTR bstrObjectPath
             );

    bool Save(
        /*[in]*/ BSTR bstrObjectPath
             );

    bool                    m_bInitialized;
    CComPtr<IWbemContext>    m_pWbemCtx;
};

#endif // __INC_SA_TASK_CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\langchange.cpp ===
#include <stdafx.h>
#include "langchange.h"
#include <initguid.h>

//
// Standard IUnknown implementation
//
ULONG CLangChange::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//
// Standard IUnknown implementation
//
ULONG CLangChange::Release()
{
    if (InterlockedDecrement(&m_lRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_lRef;
}

//
// Standard IUnknown implementation
//
STDMETHODIMP CLangChange::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

    SATraceFunction("CLangChange::QueryInterface");
    if (IID_IUnknown==riid)
    {
        *ppv = (void *)(IUnknown *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        if (IID_ISALangChange==riid)
        {
            *ppv = (void *)(ISALangChange *) this;
            AddRef();
            return S_OK;
        }
    }
    return E_NOINTERFACE;
}

//++----------------------------------------------------------------------------
//
//  Function:   InformChange
//
//  Synopsis:   This is the method called by Loc Mgr when the language
//              on the SA changes. This method informs the worker 
//              thread of the adapter to refresh its strings.
//
//  Arguments:    bstrLangDisplayName - language display name (Eg.- English)
//                bstrLangISOName     - Language ISO name (Eg. - en)
//                ulLangID            - Language ID (Eg.- US English is 0409)
//
//  Returns:    HRESULT - success/failure
//
//  History:    BalajiB      Created     05/24/2000
//
//  Called By;  Localization Manager
//
//------------------------------------------------------------------------------
STDMETHODIMP CLangChange::InformChange(
                      /*[in]*/ BSTR          bstrLangDisplayName,
                      /*[in]*/ BSTR          bstrLangISOName,
                      /*[in]*/ unsigned long ulLangID
                                      )
{
    BOOL          fStat = FALSE;

    SATracePrintf("LangName(%ws), ISOName(%ws), ID(%ld)",
                  bstrLangDisplayName,
                  bstrLangISOName,
                  ulLangID);
    if (m_hWnd)
    {
        PostMessage(m_hWnd,wm_SaLocMessage,(WPARAM)0,(LPARAM)0);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\ldm.cpp ===
//#--------------------------------------------------------------
//
//  File:       ldm.cpp
//
//  Synopsis:   This file holds the implementation of the
//                CServiceModule class and WinMain
//
//  History:     11/15/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ldm.h"
#include "ldm_i.c"

#include "mainwindow.h"
#include <stdio.h>
#include "SAKeypadController.h"
#include "display.h"
#include "sacomguid.h"

CServiceModule _Module;

DWORD
SetAclForComObject ( 
    /*[in]*/    PSECURITY_DESCRIPTOR pSD,
    /*[out*/    PACL             *ppacl
    );

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAKeypadController, CSAKeypadController)
END_OBJECT_MAP()

const wchar_t szServiceAppID[] = L"{0678A0EA-A69E-4211-8A3E-EBF80BB64D38}";


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// Although some of these functions are big they are declared inline 
// since they are only used once
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        SATraceString ("LDM Service registration failed");
        return hr;
    }


    // Remove any previous service since it may point to
    // the incorrect file
    Uninstall();

    // Add service entries
    UpdateRegistryFromResource(IDR_Ldm, TRUE);

    // Adjust the AppID for Local Server or Service
    CRegKey keyAppID;

    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);

    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, szServiceAppID, KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;
    key.DeleteValue(_T("LocalService"));
    
    if (bService)
    {
        key.SetValue(_T("saldm"), _T("LocalService"));
        key.SetValue(_T("-Service"), _T("ServiceParameters"));
        // Create service
        Install();
    }

    // Add object entries
    hr = CComModule::RegisterServer(bRegTypeLib);
	
    CoUninitialize();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_Ldm, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, 
                                 UINT nServiceNameID, UINT nServiceShortNameID, 
                                 const GUID* plibid)
{
    CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));
    LoadString(h, nServiceShortNameID, m_szServiceShortName, sizeof(m_szServiceShortName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

///////////////////////////////////////////////////////////////////////////////
//
LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}

///////////////////////////////////////////////////////////////////////////////
//
BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
//
inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
           SATraceString ("CServiceModule::Install, Couldn't open service manager...");
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH +1];
    DWORD dwResult = ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);
    if (0 == dwResult)
    {
        return (FALSE);
    }
    szFilePath [_MAX_PATH] = L'\0';

    SC_HANDLE hService = ::CreateService(
        hSCM, m_szServiceShortName, m_szServiceName,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
        SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
           SATraceString ("CServiceModule::Install, Couldn't create service...");
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
           SATraceString ("CServiceModule::Uninstall, Couldn't open service manager...");
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
         SATraceString ("CServiceModule::Uninstall, Couldn't open service...");
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

     SATraceString ("CServiceModule::Uninstall, Service could not be deleted...");
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
    _vstprintf(chMsg, pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (m_bService)
    {
        /* Get a handle to use with ReportEvent(). */
        hEventSource = RegisterEventSource(NULL, m_szServiceName);
        if (hEventSource != NULL)
        {
            /* Write to event log. */
            ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
            DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        _putts(chMsg);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };

    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }

    if (m_bService == FALSE)
    {
        //Run();
    }
}

///////////////////////////////////////////////////////////////////////////////
//
inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;

    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);

    if (m_hServiceStatus == NULL)
    {
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
}

///////////////////////////////////////////////////////////////////////////////
//
inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:

        SetServiceStatus(SERVICE_STOP_PENDING);
        //
        // If we have a handle to the window, close the window
        //
        if (_Module.hwnd)
        {
            PostMessage(_Module.hwnd, WM_CLOSE, 0, 0);
        }
        //
        // quit the message pump with WM_QUIT message
        //
        else
        {
            PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        }

        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:

        //
        // post IOCTL_SADISPLAY_SHUTDOWN_MESSAGE to display driver
        //
        PostLCDShutdownMessage();

        //
        // If we have a handle to the window, close the window
        //
        if (_Module.hwnd)
        {
            PostMessage(_Module.hwnd, WM_CLOSE, 0, 0);
        }
        //
        // quit the message pump with WM_QUIT message
        //
        else
        {
            PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        }
        

        break;
    default:
        SATracePrintf ("LDM received unknown control request:%d", dwOpcode);
    }
}


//++--------------------------------------------------------------
//
//  Function:   PostLCDShutdownMessage 
//
//  Synopsis:   This is the CServiceModule private method to send
//              the shutdown message to the LCD
//     
//  Arguments:  none
//
//  History:    serdarun      Created     04/05/2001
//
//-----------------------------------------------------------------
void CServiceModule::PostLCDShutdownMessage()
{

    CDisplay objDisplay;

    //
    // send IOCTL_SADISPLAY_SHUTDOWN_MESSAGE message to display driver
    // using the CDisplay class method
    //

    //
    // lock the display first
    //
    objDisplay.Lock ();

    //
    // post the shutdown now
    //
    objDisplay.Shutdown ();


}    //    end of CServiceModule::PostLCDShutdownMessage method
///////////////////////////////////////////////////////////////////////////////
//
void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}

///////////////////////////////////////////////////////////////////////////////
//
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}

///////////////////////////////////////////////////////////////////////////////
//
void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

///////////////////////////////////////////////////////////////////////////////
//
void CServiceModule::Run()
{
    _Module.dwThreadID = GetCurrentThreadId();

    HRESULT hr = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//  HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        CSecurityDescriptor sd;

        sd.InitializeFromThreadToken();

        
        PACL pacl = NULL;
        //
        // 
        // Add ACLs to the SD using the builtin RIDs.
        //
        DWORD dwRetVal =  SetAclForComObject  ( 
                        (PSECURITY_DESCRIPTOR) sd.m_pSD,
                                &pacl
                            );    
            if (ERROR_SUCCESS != dwRetVal)      {return;}
            
        hr = CoInitializeSecurity(
                                sd, 
                                -1, 
                                NULL, 
                                NULL,
                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                                RPC_C_IMP_LEVEL_IDENTIFY, 
                                NULL, 
                                EOAC_NONE, 
                                NULL);

        _ASSERTE(SUCCEEDED(hr));

        // Register the class with COM
        //
        if (SUCCEEDED(hr))
        {

            hr = _Module.RegisterClassObjects(CLSCTX_SERVER, REGCLS_MULTIPLEUSE);

            _ASSERTE(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
            {
                if (m_bService)
                    SetServiceStatus(SERVICE_RUNNING);


                CMainWindow m_ieWindow;

                hr = m_ieWindow.Initialize();
                m_ieWindow.id = _Module.dwThreadID;

                if (FAILED(hr))
                {
                    _Module.hwnd = NULL;
                    SATraceString ("Main window initialization failed");
                }
                else
                {
                    _Module.hwnd = m_ieWindow.m_hWnd;
                    m_ieWindow.ShowWindow(SW_SHOW);
                    m_ieWindow.UpdateWindow();
                }
                
                MSG msg;

                while (GetMessage(&msg, NULL, 0, 0)) 
                {
                        
                    if ( (m_ieWindow.m_pMainInPlaceAO!= 0) && (!m_ieWindow.m_bActiveXFocus)/*&& (msg.wParam == VK_TAB) */)
                        m_ieWindow.m_pMainInPlaceAO->TranslateAccelerator(&msg);
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }


            }
            _Module.RevokeClassObjects();

        }

        //
        // cleanup
        //
        if (pacl) {LocalFree (pacl);}
        CoUninitialize();
    }
}





/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{

    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, 
                IDS_SERVICESHORTNAME, &LIBID_LDMLib);

    _Module.m_bService = TRUE;
    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);
        
        // Register as Service
        if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);
        
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;

    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);

    if (lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    CRegKey key;

    lRes = key.Open(keyAppID, szServiceAppID, KEY_READ);

    if (lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;

    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;

    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}

//++--------------------------------------------------------------
//
//  Function:   SetAclForComObject
//
//  Synopsis:   method for providing only the Local System and Admins rights 
//              to access the COM object
//
//  Arguments:  none
//
//  Returns:    HRESULT
//
//  History:    MKarki      11/15/2001    Created
//              serdarun    04/07/2002    remove admin from list
//----------------------------------------------------------------
DWORD
SetAclForComObject ( 
    /*[in]*/    PSECURITY_DESCRIPTOR pSD,
    /*[out*/    PACL             *ppacl
    )
{    
    DWORD dwError = ERROR_SUCCESS;
    int   cbAcl = 0;
    PACL  pacl = NULL;
    PSID  psidLocalSystemSid = NULL;
    SID_IDENTIFIER_AUTHORITY siaLocalSystemSidAuthority = SECURITY_NT_AUTHORITY;

    CSATraceFunc objTraceFunc ("SetAclFromComObject");

    do
    {
        if (NULL == pSD)
        {
            SATraceString ("SetAclFromComObject - invalid parameter passed in");
            dwError = ERROR_INVALID_PARAMETER;
            break;
        }
            
        //
        // Create a SID for Local System account
        //
        BOOL bRetVal = AllocateAndInitializeSid (  
                                            &siaLocalSystemSidAuthority,
                                            1,
                                            SECURITY_LOCAL_SYSTEM_RID,
                                            0,
                                            0,
                                            0,
                                            0,
                                            0,
                                            0,
                                            0,
                                            &psidLocalSystemSid 
                                            );
        if (!bRetVal)
        {     
            dwError = GetLastError ();
            SATraceFailure ("SetAclFromComObject:AllocateAndInitializeSid (LOCAL SYSTEM) failed",  dwError);
            break;
        }


        //
        // Calculate the length of required ACL buffer
        // with 1 ACE
        //
        cbAcl = sizeof (ACL)
                +   sizeof (ACCESS_ALLOWED_ACE)
                +   GetLengthSid( psidLocalSystemSid );

        pacl = (PACL) LocalAlloc ( 0, cbAcl );
        if (NULL == pacl) 
        {
            dwError = ERROR_OUTOFMEMORY;
            SATraceFailure ("SetAclFromComObject::LocalAlloc failed:", dwError);
            break;
        }

        //
        // initialize the ACl now
        //
        bRetVal =InitializeAcl( 
                              pacl,
                              cbAcl,
                              ACL_REVISION2
                              );
        if (!bRetVal)
        {
            dwError = GetLastError();
            SATraceFailure ("SetAclFromComObject::InitializeAcl failed:", dwError);
            break;
        }

        //
        // Add ACE with EVENT_ALL_ACCESS for Local System account
        //
        bRetVal = AddAccessAllowedAce ( 
                                        pacl,
                                        ACL_REVISION2,
                                        COM_RIGHTS_EXECUTE,
                                        psidLocalSystemSid
                                        );
        if (!bRetVal)
        {
            dwError = GetLastError();
            SATraceFailure ("SetAclFromComObject::AddAccessAllowedAce (LOCAL SYSTEM)  failed:", dwError);
            break;
        }

        //
        // Set the ACL which allows EVENT_ALL_ACCESS for all users and
        // Local System to the security descriptor.
        bRetVal = SetSecurityDescriptorDacl (   
                                            pSD,
                                            TRUE,
                                            pacl,
                                            FALSE 
                                            );
        if (!bRetVal)
        {
            dwError = GetLastError();
            SATraceFailure ("SetAclFromComObject::SetSecurityDescriptorDacl failed:", dwError);
            break;
        }
    
        //
        // success
        //
    }
    while (false);
    
    //
    // in case of error, cleanup
    //
    if (dwError) 
    {
        if ( pacl ) 
        {
            LocalFree ( pacl );
        }
    }
    else 
    {
        *ppacl = pacl;
    }


    //
    // free up resources now
    //
    if ( psidLocalSystemSid ) {FreeSid ( psidLocalSystemSid );}

    return (dwError);
        
}//End of SetAclFromComObject method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\myservice.h ===
//#--------------------------------------------------------------
//
//  File:       myservice.h
//
//  Synopsis:   This file holds the declaration of the
//                CMainWindow class
//
//  History:     11/10/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#ifndef _MYSERVICE_H_
#define _MYSERVICE_H_

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:

    HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
    HRESULT UnregisterServer();
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID,  
            UINT nServiceShortNameID, const GUID* plibid = NULL);
    void Start();
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
    LONG Unlock();
    void LogEvent(LPCTSTR pszFormat, ...);
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);
    void PostLCDShutdownMessage();

// data members
public:
    TCHAR m_szServiceName[256];
    TCHAR m_szServiceShortName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
    BOOL m_bService;
    HWND hwnd;
};


#endif // _MYSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\mainwindow.cpp ===
//#--------------------------------------------------------------
//
//  File:       mainwindow.cpp
//
//  Synopsis:   This file holds the implementation of the
//                CMainWindow class
//
//  History:     11/10/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------


#include "stdafx.h"
#include "mainwindow.h"


//
// PROGID of the Localization Manager
//
const WCHAR LOCALIZATION_MANAGER [] =  L"ServerAppliance.LocalizationManager";

const WCHAR szMainPage[] = L"\\localui_main.htm";

const WCHAR szLocalUIDir[] = L"\\ServerAppliance\\localui";

//
// startup registrypages
//
const WCHAR szLocalUI_StartPage[] = L"\\localui_startup_start.htm";

const WCHAR szLocalUI_ShutdownPage[] = L"\\localui_startup_shutdown.htm";

const WCHAR szLocalUI_UpdatePage[] = L"\\localui_startup_update.htm";

const WCHAR szLocalUI_ReadyPage[] = L"\\localui_startup_ready.htm";

//
// WBEM namespace to connection to
//
const WCHAR DEFAULT_NAMESPACE[] = L"\\\\.\\ROOT\\CIMV2";

//
// Query Language to use for WBEM
//
const WCHAR QUERY_LANGUAGE [] = L"WQL";

//
// WBEM query which specifies the type of events we are interested
// in
//
const WCHAR QUERY_STRING [] = L"select * from Microsoft_SA_AlertEvent";


//++--------------------------------------------------------------
//
//  Function:   startworkerroutine
//
//  Synopsis:   This is thread method for starting keypad reading
//
//  Arguments:  PVOID   - pointer to main window class object
//
//  Returns:    DWORD - success/failure
//
//  History:    serdarun      Created     11/10/2000
//
//  Called By:  Init method of CMainWindow
//
//----------------------------------------------------------------
DWORD WINAPI startworkerroutine (
        /*[in]*/    PVOID   pArg
        )
{
    ((CMainWindow*)pArg)->KeypadReader();

    return 0;
} //  end of startworkerroutine method



//++--------------------------------------------------------------
//
//  Function:   Invoke
//
//  Synopsis:   This is the Invoke method of famous IDispatch interface
//                
//  Arguments:  See MSDN for detailed description
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     11/10/2000
//
//  Called By:  WebBrowser control created by main window to notify events
//
//----------------------------------------------------------------
STDMETHODIMP CWebBrowserEventSink::Invoke(DISPID dispid, REFIID riid, LCID lcid, 
                        WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
                        EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    //
    //return immediately if we don't have a valid window pointer
    //
    if (NULL == m_pMainWindow)
        return S_OK;

    switch (dispid)
    {
        //
        //Occurs when a document has reached the READYSTATE_COMPLETE state
        //
        case DISPID_DOCUMENTCOMPLETE:
            if ( (pdispparams->cArgs == 2)
                && (pdispparams->rgvarg[0].vt == (VT_VARIANT | VT_BYREF))
                && (pdispparams->rgvarg[1].vt == VT_DISPATCH) && m_bMainControl )
                m_pMainWindow->PageLoaded(pdispparams->rgvarg[1].pdispVal, pdispparams->rgvarg[0].pvarVal);
            else
                m_pMainWindow->RegistryPageLoaded(pdispparams->rgvarg[1].pdispVal, pdispparams->rgvarg[0].pvarVal);
            break;
        //
        //Occurs before a navigation in the given WebBrowser 
        //
        case DISPID_BEFORENAVIGATE2:
            if (m_bMainControl)
                m_pMainWindow->LoadingNewPage();
            break;
        //
        //Not interested in rest of the events
        //
        default:
            break;
    }

    return S_OK;
}    //  end of CWebBrowserEventSink::Invoke method


//
// constructor
//
CMainWindow::CMainWindow() :
                m_hWorkerThread(INVALID_HANDLE_VALUE),
                m_lDispWidth(0),
                m_lDispHeight(0),
                m_dwMainCookie(0),    
                m_dwSecondCookie(0),    
                m_bPageReady(FALSE),
                m_pSAKeypadController(NULL),
                m_pMainWebBrowser(NULL),
                m_pMainWebBrowserUnk(NULL),
                m_pMainInPlaceAO(NULL),
                m_pMainOleObject(NULL),
                m_pMainViewObject(NULL),
                m_pMainWebBrowserEventSink(NULL),
                m_pSecondWebBrowser(NULL),
                m_pSecondWebBrowserUnk(NULL),
                m_pSecondWebBrowserEventSink(NULL),
                m_pLocInfo(NULL),
                m_pLangChange(NULL),
                m_RegBitmapState(BITMAP_STARTING),
                m_pSAWbemSink(NULL),
                m_pWbemServices(NULL),
                m_pSAConsumer(NULL),
                m_dwLEDMessageCode(1),
                m_bInTaskorMainPage(FALSE),
                m_pSaDisplay(NULL),
                m_unintptrMainTimer(0),
                m_unintptrSecondTimer(0),
                m_bSecondIECreated(FALSE)
{
} // end of constructor


//++--------------------------------------------------------------
//
//  Function:   OnSaKeyMessage
//
//  Synopsis:   Message handler for wm_SaKeyMessage generated by 
//                keypad reader. It converts these messages to real
//                WM_KEYDOWN messages and sends to IE control                
//                
//  Arguments:  windows message arguments
//                WPARAM contains the key id
//
//  Returns:    LRESULT - success/failure
//
//  History:    serdarun      Created     11/10/2000
//
//----------------------------------------------------------------
LRESULT CMainWindow::OnSaKeyMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LONG lMessage;
    BOOL fShiftKey;
    HRESULT hr;
    BYTE aKeyboardState[300];
    int iKey = wParam;
    

    if (m_pSAKeypadController)
    {
        hr = m_pSAKeypadController->GetKey(iKey,&lMessage,&fShiftKey);
    }
    else
    {
        SATraceString ("CMainWindow::OnSaKeyMessage, don't have a valid  keypad pointer...");
        return 0;
    }

    if (FAILED(hr))
    {
        SATraceString ("CMainWindow::OnSaKeyMessage failed on m_pSAKeypadController->GetKey");
        return 0;
    }

    //if key is disabled
    if (lMessage == 0)
        return 0;

    if (lMessage == -1)
    {
        m_pMainWebBrowser->GoBack();
        return 0;
    }

    //
    // get the current keyboard state
    //
    if (GetKeyboardState(aKeyboardState) == 0)
    {
        SATraceFailure("CMainWindow::OnSaKeyMessage failed on GetKeyboardState",GetLastError());
        return 0;
    }

    if (fShiftKey)
        aKeyboardState[VK_SHIFT] = 0xFF;
    else
        aKeyboardState[VK_SHIFT] = 0x00;

    //
    // set the new state with the shift key
    //
    if (SetKeyboardState(aKeyboardState) == 0)
    {
        SATraceFailure("CMainWindow::OnSaKeyMessage failed on SetKeyboardState",GetLastError());
        return 0;
    }

    HWND hwnd = ::GetFocus();
    HWND hwndTmp = m_hwndWebBrowser;

    while (hwnd && hwndTmp)
    {
        if (hwnd == hwndTmp) 
            break;
        hwndTmp = ::GetWindow(hwndTmp,GW_CHILD);
    }
    ::PostMessage(hwndTmp,WM_KEYDOWN,lMessage,1);


    return 0;

} // end of CMainWindow::OnSaKeyMessage


//++--------------------------------------------------------------
//
//  Function:   OnSaLocMessage
//
//  Synopsis:   Message handler for wm_SaLocMessage generated by 
//                keypad reader. It means Loc Id for the box has been
//                changed
//
//  Arguments:  windows message arguments
//
//  Returns:    LRESULT - success/failure
//
//  History:    serdarun      Created     11/28/2000
//
//----------------------------------------------------------------
LRESULT CMainWindow::OnSaLocMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    //
    // Initialize the state to the first page
    //
    m_RegBitmapState = BITMAP_STARTING;
    
    CComBSTR bstrBootingPage = m_szLocalUIDir.c_str();
    bstrBootingPage.Append(szLocalUI_StartPage);
    //
    // Second browser start the sequence
    //
    if (m_pSecondWebBrowser)
    {
        m_pSecondWebBrowser->Navigate(bstrBootingPage.Detach(),0,0,0,0);
    }

    //
    // Main browser might refresh, talk to mkarki and kevinz
    //

    return 0;
} // end of CMainWindow::OnSaLocMessage

//++--------------------------------------------------------------
//
//  Function:   OnSaLEDMessage
//
//  Synopsis:   Message handler for wm_SaLEDMessage generated by 
//                sa cinsumer component.
//                
//  Arguments:  windows message arguments
//                WPARAM contains the LED code
//
//  Returns:    LRESULT - success/failure
//
//  History:    serdarun      Created     11/10/2000
//
//----------------------------------------------------------------
LRESULT CMainWindow::OnSaLEDMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    m_dwLEDMessageCode = wParam;
    return 0;

} // end of CMainWindow::OnSaLEDMessage


//++--------------------------------------------------------------
//
//  Function:   OnSaAlertMessage
//
//  Synopsis:   Message handler for OnSaAlertMessage generated by 
//                sa consumer component.
//                
//  Arguments:  windows message arguments
//
//  Returns:    LRESULT - success/failure
//
//  History:    serdarun      Created     11/10/2000
//
//----------------------------------------------------------------
LRESULT CMainWindow::OnSaAlertMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    //
    // if we are not in tasks or main page, ignore alerts
    //
    if (!m_bInTaskorMainPage)
    {
        return 0;
    }

    SATraceString ("CMainWindow::OnSaAlertMessage, notifying the html page");
    //
    // send the special key press to the client
    //
    HWND hwnd = ::GetFocus();
    HWND hwndTmp = m_hwndWebBrowser;

    while (hwnd && hwndTmp)
    {
        if (hwnd == hwndTmp) 
            break;
        hwndTmp = ::GetWindow(hwndTmp,GW_CHILD);
    }

    //
    // Send a F24 key press to the html page, used for alerts
    //
    ::PostMessage(hwndTmp,WM_KEYDOWN,VK_F24,1);
    return 0;

} // end of CMainWindow::OnSaAlertMessage


LRESULT CMainWindow::OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    //
    // if it is a timer for registry page, print the page and go to the next page
    //
    if (wParam == m_unintptrSecondTimer)
    {
        KillTimer(m_unintptrSecondTimer);
        PrintRegistryPage();
        return 0;
    }


    if (m_bPageReady)
        GetBitmap();

    return 0;
}

LRESULT CMainWindow::OnFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_pMainOleObject)
        m_pMainOleObject->DoVerb(OLEIVERB_UIACTIVATE,0,0,0,0,0);
    return 0;
}


//++--------------------------------------------------------------
//
//  Function:   CreateMainIEControl
//
//  Synopsis:   Creates the main IE control and registers
//                in the event sink
//                
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     11/10/2000
//
//  Called By:  CMainWindow::OnCreate method
//
//----------------------------------------------------------------
HRESULT CMainWindow::CreateMainIEControl()
{
    SATraceString ("Entering CMainWindow::CreateMainIEControl ...");
    HRESULT hr = E_FAIL;

    //
    // Create the main IE control 
    //
    m_hwndWebBrowser = ::CreateWindow(_T("AtlAxWin"), m_szMainPage.c_str(),
                WS_CHILD|WS_VISIBLE, 0, 0, m_lDispWidth, m_lDispHeight, m_hWnd, NULL,
                ::GetModuleHandle(NULL), NULL);

    if (NULL == m_hwndWebBrowser)
    {
        SATraceString ("CreateWindow for main IE control failed");
        return hr;
    }

    //
    // Get a pointer to the control
    //
    AtlAxGetControl(m_hwndWebBrowser, &m_pMainWebBrowserUnk);

    if (m_pMainWebBrowserUnk == NULL)
    {
        SATraceString ("Getting a pointer to the main control failed");
        return hr;
    }

    //
    // QI for the IWebBrowser2 interface
    //
    hr = m_pMainWebBrowserUnk->QueryInterface(IID_IWebBrowser2, (void**)&m_pMainWebBrowser);

    if (FAILED(hr)) 
    {
        SATraceString ("QI for IWebBrowser2 interface failed");
        return hr;
    }

    //
    // QI for the IOleInPlaceActiveObject interface
    //
    hr = m_pMainWebBrowserUnk->QueryInterface(IID_IOleInPlaceActiveObject, (void**)&m_pMainInPlaceAO);

    if (FAILED(hr)) 
    {
        SATraceString ("QI for IOleInPlaceActiveObject interface failed");
        return hr;
    }

    //
    // QI for the IOleObject interface
    //
    hr = m_pMainWebBrowserUnk->QueryInterface(IID_IOleObject, (void**)&m_pMainOleObject);

    if (FAILED(hr)) 
    {
        SATraceString ("QI for IOleObject interface failed");
        return hr;
    }

    //
    // QI for the IViewObject2 interface
    //
    hr = m_pMainWebBrowser->QueryInterface(IID_IViewObject2, (void**)&m_pMainViewObject);

    if (FAILED(hr)) 
    {
        SATraceString ("QI for IViewObject2 interface failed");
        return hr;
    }

    //
    // Create the sink object for the events
    //
    hr = CComObject<CWebBrowserEventSink>::CreateInstance(&m_pMainWebBrowserEventSink);

    if (FAILED(hr)) 
    {
        SATraceString ("CreateInstance for sink object failed");
        return hr;
    }

    //
    //    Store the main window pointer for callbacks
    //
    m_pMainWebBrowserEventSink->m_pMainWindow = this;

    //
    // Register in the event sink of the main IE control
    //
    hr = AtlAdvise(m_pMainWebBrowserUnk, m_pMainWebBrowserEventSink->GetUnknown(), DIID_DWebBrowserEvents2, &m_dwMainCookie);

    if (FAILED(hr)) 
    {
        SATraceString ("AtlAdvise for main IE control failed");
        return hr;
    }

    return S_OK;
} // end of CMainWindow::CreateMainIEControl


//++--------------------------------------------------------------
//
//  Function:   CreateSecondIEControl
//
//  Synopsis:   Creates the second IE control and registers
//                in the event sink
//                
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     11/10/2000
//
//  Called By:  CMainWindow::OnCreate method
//
//----------------------------------------------------------------
HRESULT CMainWindow::CreateSecondIEControl()
{
    SATraceString ("Entering CMainWindow::CreateSecondIEControl ...");

    HRESULT hr = E_FAIL;

    wstring szStartUpPage;

    szStartUpPage.assign(m_szLocalUIDir);
    szStartUpPage.append(szLocalUI_StartPage);
    //
    // Create the main IE control 
    //
    HWND m_hwndSecondWebBrowser = ::CreateWindow(_T("AtlAxWin"), szStartUpPage.c_str(),
                WS_CHILD|WS_VISIBLE, 0, m_lDispHeight, m_lDispWidth, m_lDispHeight, m_hWnd, NULL,
                ::GetModuleHandle(NULL), NULL);

    if (NULL == m_hwndSecondWebBrowser)
    {
        SATraceString ("CreateWindow for second IE control failed");
        return hr;
    }

    //
    // Get a pointer to the control
    //
    AtlAxGetControl(m_hwndSecondWebBrowser, &m_pSecondWebBrowserUnk);

    if (m_pSecondWebBrowserUnk == NULL)
    {
        SATraceString ("Getting a pointer to the main control failed");
        return hr;
    }

    //
    // QI for the IWebBrowser2 interface
    //
    hr = m_pSecondWebBrowserUnk->QueryInterface(IID_IWebBrowser2, (void**)&m_pSecondWebBrowser);

    if (FAILED(hr)) 
    {
        SATraceString ("QI for IWebBrowser2 interface failed");
        return hr;
    }    

    //
    // Create the sink object for the events
    //
    hr = CComObject<CWebBrowserEventSink>::CreateInstance(&m_pSecondWebBrowserEventSink);

    if (FAILED(hr)) 
    {
        SATraceString ("CreateInstance for sink object failed");
        return hr;
    }

    //
    //    Store the main window pointer for callbacks
    //
    m_pSecondWebBrowserEventSink->m_pMainWindow = this;

    m_pSecondWebBrowserEventSink->m_bMainControl = FALSE;

    //
    // Register in the event sink of the main IE control
    //
    hr = AtlAdvise(m_pSecondWebBrowserUnk, m_pSecondWebBrowserEventSink->GetUnknown(), DIID_DWebBrowserEvents2, &m_dwSecondCookie);

    if (FAILED(hr)) 
    {
        SATraceString ("AtlAdvise for second IE control failed");
        return hr;
    }

    return S_OK;

} // end of CMainWindow::CreateSecondIEControl

//++--------------------------------------------------------------
//
//  Function:   OnCreate
//
//  Synopsis:   Creates the IE controls 
//
//  Arguments:  windows message arguments
//
//  Returns:    LRESULT - success(0)/failure(-1)
//
//  History:    serdarun      Created     11/10/2000
//
//----------------------------------------------------------------
LRESULT CMainWindow::OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr;

    SATraceString ("Entering CMainWindow::OnCreate...");

    //
    // Create main IE control
    //
    hr = CreateMainIEControl();

    if (FAILED(hr)) 
    {
        SATraceString ("CreateMainIEControl failed");
        return -1;
    }
    
    //
    // Create the memory DC used for rendering
    //
    m_HdcMem = ::CreateCompatibleDC(NULL);

    if (NULL == m_HdcMem)
    {
        SATraceFailure (
                "CMainWindow::OnCreate failed on CreateCompatibleDC(NULL):", 
                GetLastError ());
        return -1;
    }

    //
    // Create the monochrome bitmap
    //
    m_hBitmap = CreateBitmap(m_lDispWidth, m_lDispHeight,1,1,0);

    if (NULL == m_HdcMem)
    {
        SATraceFailure (
                "CMainWindow::OnCreate failed on CreateBitmap:", 
                GetLastError ());
        return -1;
    }

    //
    // Select bitmap into DC
    //
    SelectObject(m_HdcMem, m_hBitmap);


    //
    // Set the timer
    //
    m_unintptrMainTimer = ::SetTimer(m_hWnd,1,250,0);

    return 0;

}


//++--------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Clean up all the resources
//                
//  Arguments:  none
//
//  Returns:    none(just logs the problem)
//
//  History:    serdarun      Created     11/20/2000
//
//  Called By:  CMainWindow::OnDestroy method
//
//----------------------------------------------------------------
void CMainWindow::ShutDown()
{

    BOOL bStatus = FALSE;
    HRESULT hr;

    SATraceString ("Entering CMainWindow::ShutDown method ...");


    if (INVALID_HANDLE_VALUE != m_hWorkerThread) 
    {
        //
        // cleanup thread handle
        //
        ::CloseHandle (m_hWorkerThread);
        m_hWorkerThread = INVALID_HANDLE_VALUE;
    }

    //
    // delete Memory DC
    //
    if (m_HdcMem) 
    {
        ::DeleteDC (m_HdcMem);
        m_HdcMem = NULL;
    }


    //
    // release the localization manager
    //
    if (m_pLocInfo)
    {
        m_pLocInfo->Release ();
        m_pLocInfo = NULL;
    }

    //
    // do the reverse sequence of initialization
    //
    if (m_pLangChange) 
    {
        m_pLangChange->ClearCallback ();
        m_pLangChange->Release();
        m_pLangChange= NULL;
    }

    //
    // Unadvise event sinks for IE controls
    //
    if (m_dwMainCookie != 0)
        AtlUnadvise(m_pMainWebBrowserUnk, DIID_DWebBrowserEvents2, m_dwMainCookie);

    if (m_dwSecondCookie != 0)
        AtlUnadvise(m_pSecondWebBrowserUnk, DIID_DWebBrowserEvents2, m_dwSecondCookie);

    if ((m_pWbemServices) && (m_pSAWbemSink))
    {
        //
        // cancel reception of events
        //
        hr =  m_pWbemServices->CancelAsyncCall (m_pSAWbemSink);
        if (FAILED (hr))
        {
            SATracePrintf ("CMainWindow::Shutdown failed on-CancelAsyncCall failed with error:%x:",hr); 
        }
    }

    
    //
    // release all of the smart pointers
    //
    m_pMainWebBrowser = NULL;

    m_pMainWebBrowserUnk = NULL;

    m_pMainWebBrowserEventSink = NULL;

    m_pMainInPlaceAO = NULL;

    m_pMainOleObject = NULL;

    m_pMainViewObject = NULL;

    m_pSAKeypadController = NULL;

    m_pSecondWebBrowser = NULL;

    m_pSecondWebBrowserUnk = NULL;

    m_pSecondWebBrowserEventSink = NULL;

    m_pWbemServices = NULL;

    m_pSAWbemSink = NULL;

    m_pSaDisplay = NULL;

    if (m_pSAConsumer) 
    {
        m_pSAConsumer->Release();
        m_pSAConsumer= NULL;
    }
    return;

} // end of CMainWindow::ShutDown method


LRESULT CMainWindow::OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr;

    KillTimer(m_unintptrMainTimer);

    ShutDown();

    PostThreadMessage(id, WM_QUIT, 0, 0);

    return 0;
}

//++--------------------------------------------------------------
//
//  Function:   LoadingNewPage
//
//  Synopsis:   It is called before a new page is loaded by web control
//                
//  Arguments:  none
//
//  Returns:    none(just logs the problem)
//
//  History:    serdarun      Created     11/20/2000
//
//  Called By:  CWebBrowserEventSink::Invoke method
//
//----------------------------------------------------------------
void CMainWindow::LoadingNewPage()
{

    SATraceString ("Entering CMainWindow::LoadingNewPage method");

    //
    // Set ready flad to FALSE, we won't print any bitmaps until page is ready
    //
    m_bPageReady = FALSE;
    m_bInTaskorMainPage = FALSE;

    //
    // Load the default key messages for the new page
    //
    HRESULT hr;

    if (m_pSAKeypadController)
    {
        hr = m_pSAKeypadController->LoadDefaults();

        if (FAILED(hr))
        {
            SATraceString ("Setting default key messages failed");
        }
    }
    return;
} // end of CMainWindow::LoadingNewPage method


//++--------------------------------------------------------------
//
//  Function:   PageLoaded
//
//  Synopsis:   It is called after a new page is loaded by web control
//                
//  Arguments:  none
//
//  Returns:    none(just logs the problem)
//
//  History:    serdarun      Created     11/20/2000
//
//  Called By:  CWebBrowserEventSink::Invoke method
//
//----------------------------------------------------------------
void CMainWindow::PageLoaded(IDispatch* pdisp, VARIANT* purl)
{
    
    SATraceString ("Entering CMainWindow::PageLoaded method");

    BSTR bstrLocation;
    HRESULT hr;

    if (m_bSecondIECreated == FALSE)
    {
        hr = CreateSecondIEControl();

        if (FAILED(hr)) 
        {
            SATraceString ("CreateSecondIEControl failed");
        }
        
        m_bSecondIECreated = TRUE;
    }

    if (m_pMainWebBrowser)
    {
        if (SUCCEEDED(m_pMainWebBrowser->get_LocationName(&bstrLocation)))
        {
            if ( ( 0 == _wcsicmp (L"localui_main", bstrLocation ) ) ||
                ( 0 == _wcsicmp (L"localui_tasks", bstrLocation ) ) )
            {
                m_bInTaskorMainPage = TRUE;
            }
            else
            {
                m_bInTaskorMainPage = FALSE;
            }

        SysFreeString(bstrLocation);
        }

    }

    //
    // Inplace activate the web control
    //
    if (m_pMainOleObject)
    {
        m_pMainOleObject->DoVerb(OLEIVERB_UIACTIVATE,0,0,0,0,0);
    }

    //
    // begin printing new bitmaps
    //
    m_bPageReady = TRUE;

    return;
} // end of CMainWindow::PageLoaded method



//++--------------------------------------------------------------
//
//  Function:   RegistryPageLoaded
//
//  Synopsis:   It is called after a new page is loaded by secondary
//                web control
//                
//  Arguments:  none
//
//  Returns:    none(just logs the problem)
//
//  History:    serdarun      Created     11/25/2000
//
//  Called By:  CWebBrowserEventSink::Invoke method
//
//----------------------------------------------------------------
void CMainWindow::RegistryPageLoaded(IDispatch* pdisp, VARIANT* purl)
{

    m_unintptrSecondTimer = ::SetTimer(m_hWnd,2,3000,0);

}// end of CMainWindow::RegistryPageLoaded method

//++--------------------------------------------------------------
//
//  Function:   PrintRegistryPage
//
//  Synopsis:   It is called after a new page is loaded by secondary
//                web control
//                
//  Arguments:  none
//
//  Returns:    none(just logs the problem)
//
//  History:    serdarun      Created     11/25/2000
//
//  Called By:  OnTimer method
//
//----------------------------------------------------------------
void CMainWindow::PrintRegistryPage()
{
    CComPtr<IViewObject2> pViewObject;
    HRESULT hr;
    BYTE  DispBitmap [SA_DISPLAY_MAX_BITMAP_IN_BYTES];
    RECTL rcBounds = { 0, 0, m_lDispWidth, m_lDispHeight };
    BYTE BitMapInfoBuffer[sizeof(BITMAPINFO)+sizeof(RGBQUAD)];
    BITMAPINFO * pBitMapInfo = (BITMAPINFO*)BitMapInfoBuffer;
    BOOL bStatus;
    HKEY hOpenKey = NULL;
    LONG lMessageId;

    SATraceString ("Entering CMainWindow::PrintRegistryPage method");

    //
    // Make sure we have a valid pointer to draw 
    //

    if (!m_pSecondWebBrowser)
    {
        SATraceString ("m_pSecondWebBrowser is NULL in CMainWindow::PrintRegistryPage method");
        return;
    }

    //
    // Get the drawing interface pointer
    //
    hr = m_pSecondWebBrowser->QueryInterface(IID_IViewObject2,(void**)&pViewObject);
    if (FAILED(hr))
    {
        SATraceString ("CMainWindow::PrintRegistryPage method failed on QI for IViewObject");
        return;
    }

    
    //
    // Draw on the memory DC
    //
    hr = pViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, m_HdcMem, &rcBounds, NULL, NULL, 0);

    if (FAILED(hr))
    {

        SATraceString ("CMainWindow::PrintRegistryPage failed on Draw method");
        return;
    }


    //
    // Initialize the bitmap info structure
    //
    pBitMapInfo->bmiHeader.biSize = sizeof (BitMapInfoBuffer);
    pBitMapInfo->bmiHeader.biBitCount = 0;



    //
    // call to fill up the BITMAPINFO structure
    //
    bStatus =  ::GetDIBits (
                            m_HdcMem, 
                            (HBITMAP)m_hBitmap, 
                            0, 
                            0, 
                            NULL, 
                            pBitMapInfo, 
                            DIB_RGB_COLORS
                            );

    if (FALSE == bStatus)
    {       
        SATraceFailure (
                        "CMainWindow::PrintRegistryPage failed on GetDIBits:", 
                        GetLastError()
                        );
        return;
    }

    

    ::memset (DispBitmap, 0, SA_DISPLAY_MAX_BITMAP_IN_BYTES);

        
    //
    // get the bitmap into a buffer now
    //
    bStatus =  ::GetDIBits (
                            m_HdcMem, 
                            (HBITMAP)m_hBitmap, 
                            0,
                            m_lDispHeight,
                            (PVOID)DispBitmap,
                            pBitMapInfo, 
                            DIB_RGB_COLORS
                            );


    if (FALSE == bStatus)
    {       
        SATraceFailure (
                        "CMainWindow::PrintRegistryPage failed on GetDIBits:", 
                        GetLastError()
                        );
        return;
    }

    for (int i = 0; i < SA_DISPLAY_MAX_BITMAP_IN_BYTES; i++)
    {
        DispBitmap[i] = ~DispBitmap[i];
    }

    if (m_RegBitmapState == BITMAP_STARTING)
    {
        lMessageId = SA_DISPLAY_STARTING;
        m_RegBitmapState = BITMAP_CHECKDISK;
    }
    else if (m_RegBitmapState == BITMAP_CHECKDISK)
    {
        lMessageId = SA_DISPLAY_CHECK_DISK;
        m_RegBitmapState = BITMAP_READY;
    }
    else if (m_RegBitmapState == BITMAP_READY)
    {
        lMessageId = SA_DISPLAY_READY;
        m_RegBitmapState = BITMAP_SHUTDOWN;
    }
    else if (m_RegBitmapState == BITMAP_SHUTDOWN)
    {
        lMessageId = SA_DISPLAY_SHUTTING_DOWN;
        m_RegBitmapState = BITMAP_UPDATE;
    }
    else if (m_RegBitmapState == BITMAP_UPDATE)
    {
        lMessageId = SA_DISPLAY_ADD_START_TASKS;
        m_RegBitmapState = BITMAP_STARTING;
    }

    //
    // call display helper to store the bitmap in the registry
    //
    hr = m_pSaDisplay->StoreBitmap( 
                                    lMessageId,
                                    m_lDispWidth,
                                    m_lDispHeight,
                                    DispBitmap
                                    );
    if (FAILED(hr))
    {
        SATracePrintf (
                        "CMainWindow::PrintRegistryPage failed on StoreBitmap %x", 
                        hr
                        );
    }
    
    CComBSTR bstrStatePage;
    bstrStatePage = m_szLocalUIDir.c_str();


    //
    // append "ShutDown" to URL
    //
    if (m_RegBitmapState == BITMAP_SHUTDOWN)
    {
        bstrStatePage.Append(szLocalUI_ShutdownPage);
    }
    else if (m_RegBitmapState == BITMAP_CHECKDISK)
    {
        bstrStatePage.Append(szLocalUI_UpdatePage);
    }
    else if (m_RegBitmapState == BITMAP_UPDATE)
    {
        bstrStatePage.Append(szLocalUI_UpdatePage);
    }
    else if (m_RegBitmapState == BITMAP_READY)
    {
        bstrStatePage.Append(szLocalUI_ReadyPage);
    }

    //
    // go to the next page if sequence is not completed
    //
    if (m_RegBitmapState != BITMAP_STARTING)
    {
        m_pSecondWebBrowser->Navigate(bstrStatePage.Detach(),0,0,0,0);
    }
    else
    {
        //
        // tell the driver to pick up the new bitmaps
        //
        hr = m_pSaDisplay->ReloadRegistryBitmaps();
        if (FAILED(hr))
        {
            SATracePrintf (
                            "CMainWindow::PrintRegistryPage failed on ReloadRegistryBitmaps %x", 
                            hr
                            );
        }
        
    }


    return;
} // end of CMainWindow::PrintRegistryPage method



//++--------------------------------------------------------------
//
//  Function:   ConstructUrlStrings
//
//  Synopsis:   creates full path for main page
//                
//  Arguments:  none
//
//  Returns:    none(just logs the problem)
//
//  History:    serdarun      Created     02/06/2001
//
//  Called By:  CMainWindow::Initialize method
//
//----------------------------------------------------------------
HRESULT CMainWindow::ConstructUrlStrings()
{

    HRESULT hr = S_OK;
    

    WCHAR szSystemDir[MAX_PATH];
    
    //
    // Get system32 directory
    //
    if (GetSystemDirectory(szSystemDir,MAX_PATH) == 0)
    {
        SATraceFailure (
                        "CMainWindow::ConstructUrlStrings, failed on GetSystemDirectory", 
                        GetLastError()
                        );
        return hr;
    }

    //
    // localui dir = system directory + "ServerAppliance\localui"
    //
    m_szLocalUIDir.assign(szSystemDir);
    m_szLocalUIDir.append(szLocalUIDir);

    //
    // construct local ui main page
    //
    m_szMainPage.assign(m_szLocalUIDir);
    m_szMainPage.append(szMainPage);


    SATracePrintf ("ConstructUrlStrings Main Page:%ws",m_szMainPage.c_str()); 
    SATracePrintf ("ConstructUrlStrings LocalUI directory:%ws",m_szLocalUIDir.c_str()); 

    return hr;
}
// end of CMainWindow::ConstructUrlStrings method


//++--------------------------------------------------------------
//
//  Function:   CorrectTheFocus
//
//  Synopsis:   Sets focus to the first active element in the page
//                
//  Arguments:  none
//
//  Returns:    none(just logs the problem)
//
//  History:    serdarun      Created     11/20/2000
//
//  Called By:  CMainWindow::CorrectTheFocus method
//
//----------------------------------------------------------------
void CMainWindow::CorrectTheFocus()
{

    CComPtr<IDispatch> pDisp;
    CComPtr<IHTMLDocument2> pHTMLDocument;
    CComPtr<IHTMLElement> pHTMLElement;
    CComBSTR bstrTagName;
    HRESULT hr;

    USES_CONVERSION;
    
    //
    // If browser pointer is not valid, return
    //
    if (m_pMainWebBrowser == NULL)
        return;

    //
    // Get the current document from browser
    //
    hr = m_pMainWebBrowser->get_Document(&pDisp);

    if (FAILED(hr))
    {
        SATraceString ("CMainWindow::CorrectTheFocus failed on get_Document");
        return;
    }

    //
    // Get the document interface
    //
    hr = pDisp->QueryInterface(IID_IHTMLDocument2,(void**)&pHTMLDocument);

    if (FAILED(hr))
    {
        SATraceString ("CMainWindow::CorrectTheFocus failed on QueryInterface for IHTMLDocument");
        return;
    }

    //
    // Get the active element
    //
    if ( FAILED( pHTMLDocument->get_activeElement(&pHTMLElement) ) )
    {
        SATraceString ("CMainWindow::CorrectTheFocus failed on get_activeElement");
        return;
    }
    //
    // There is no active element, send a tab message
    //
    else if (pHTMLElement == NULL)
    {
        PostThreadMessage(GetCurrentThreadId(),WM_KEYDOWN,(WPARAM)VK_TAB,(LPARAM)1);
    }
    //
    // If body is the active element, also send a tab message
    // We want something else to have the focus
    //
    else
    {
        hr = pHTMLElement->get_tagName(&bstrTagName);
        m_bActiveXFocus = FALSE;
        if (FAILED(hr))
        {
            SATraceString ("CMainWindow::CorrectTheFocus failed on get_tagName");
            return;
        }
        //
        // Check if the tag is body
        //
        //else if (_wcsicmp(W2T(bstrTagName),_T("body")) == 0)
        //    PostThreadMessage(GetCurrentThreadId(),WM_KEYDOWN,(WPARAM)VK_TAB,(LPARAM)1);
        else if (_wcsicmp(W2T(bstrTagName),_T("object")) == 0)
            m_bActiveXFocus = TRUE;
    }

} // end of CMainWindow::CorrectTheFocus

//++--------------------------------------------------------------
//
//  Function:   GetBitmap
//
//  Synopsis:   Gets the bitmap from IE control and writes to LCD
//                
//  Arguments:  none
//
//  Returns:    none(just logs the problem)
//
//  History:    serdarun      Created     11/20/2000
//
//  Called By:  CMainWindow::OnTimer method
//
//----------------------------------------------------------------
void CMainWindow::GetBitmap()
{

    HRESULT hr;
    RECTL rcBounds = { 0, 0, m_lDispWidth, m_lDispHeight };
    BOOL bStatus;
    BYTE DisplayBitmap[SA_DISPLAY_MAX_BITMAP_IN_BYTES];
    BYTE BitMapInfoBuffer[sizeof(BITMAPINFO)+sizeof(RGBQUAD)];

    ::memset ((PVOID)BitMapInfoBuffer, 0, sizeof(BitMapInfoBuffer));

    BITMAPINFO * pBitMapInfo = (BITMAPINFO*)BitMapInfoBuffer;

    //SATraceString ("Entering CMainWindow::GetBitmap method");


    //
    // Make sure there is an active element
    //
    CorrectTheFocus();

    //
    // If IViewObject2 interface is NULL, we cannot get the bitmap
    //
    if (m_pMainViewObject == NULL)
        return;
    
    //
    // Draw on the memory DC
    //
    hr = m_pMainViewObject->Draw(DVASPECT_CONTENT, -1, NULL, NULL, NULL, m_HdcMem, &rcBounds, NULL, NULL, 0);

    if (FAILED(hr))
    {

        SATraceString ("CMainWindow::GetBitmap failed on Draw method");
        return;
    }


    //
    // Initialize the bitmap info structure
    //
    pBitMapInfo->bmiHeader.biSize = sizeof(BitMapInfoBuffer);
    pBitMapInfo->bmiHeader.biBitCount = 0;

    //
    // Initialize the display buffer
    //
    ::memset ((PVOID)DisplayBitmap, 0, SA_DISPLAY_MAX_BITMAP_IN_BYTES);


    //
    // call to fill up the BITMAPINFO structure
    //
    bStatus =  ::GetDIBits (
                            m_HdcMem, 
                            (HBITMAP)m_hBitmap, 
                            0, 
                            0, 
                            NULL, 
                            pBitMapInfo, 
                            DIB_RGB_COLORS
                            );

    if (FALSE == bStatus)
    {       
        SATraceFailure (
                        "CMainWindow::GetBitmap failed on GetDIBits:", 
                        GetLastError()
                        );
        return;
    }

    //
    // get the bitmap into a buffer now
    //
    bStatus =  ::GetDIBits (
                            m_HdcMem, 
                            (HBITMAP)m_hBitmap, 
                            0,
                            m_lDispHeight,
                            (PVOID)(DisplayBitmap), 
                            pBitMapInfo, 
                            DIB_RGB_COLORS
                            );

    if (FALSE == bStatus)
    {       
        SATraceFailure (
                        "CMainWindow::GetBitmap failed on GetDIBits:", 
                        GetLastError()
                        );
        return;
    }

    for (int i = 0; i < SA_DISPLAY_MAX_BITMAP_IN_BYTES; i++)
    {
        DisplayBitmap[i] = ~DisplayBitmap[i];
    }

 
    hr = m_pSaDisplay->ShowMessage(
                                m_dwLEDMessageCode,
                                m_lDispWidth,
                                m_lDispHeight,
                                (DisplayBitmap)
                                );

    if (FAILED(hr))
    {       
        SATracePrintf (
                        "CMainWindow::GetBitmap failed on ShowMessage: %x", 
                        hr
                        );
    }
    
    return;
} // end of CMainWindow::GetBitmap


//++--------------------------------------------------------------
//
//  Function:   Initialize
//
//  Synopsis:   This is method for initializing the drivers and 
//              creating the main window for the service
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     11/20/2000
//
//  Called By;  Run method of the service
//
//----------------------------------------------------------------
HRESULT CMainWindow::Initialize()
{

    SATraceString ("Entering CMainWindow::Initialize method");

    HRESULT hr = S_OK;

    if (!AtlAxWinInit())
    {
        SATraceString ("CMainWindow::Initialize, AtlAxWinInit failed...");
        return E_FAIL;
    }


    //
    // Construct the URL strings
    //
    ConstructUrlStrings();

    //
    //Create the keypad component
    //

    CComPtr<IClassFactory> pCF;

    hr = CoGetClassObject(CLSID_SAKeypadController,CLSCTX_INPROC_SERVER,0,IID_IClassFactory,(void**)&pCF);

    if (FAILED(hr))
    {
        SATracePrintf ("Initialize couldn't get class object for keypad controller:%x",hr);
        return hr;
    }

    hr = pCF->CreateInstance(NULL,IID_ISAKeypadController,(void**)&m_pSAKeypadController);

    if (FAILED(hr))
    {
        SATracePrintf ("Initialize couldn't create keypad controller:%x",hr);
        return hr;
    }
    else
    {
        m_pSAKeypadController->LoadDefaults();
    }


    //
    // initialize connection to display helper component
    //
    hr = InitDisplayComponent();
    if (FAILED(hr))
        return hr;

    //
    // initialize consumer component
    //
    hr = InitWMIConsumer();
    if (FAILED(hr))
    {

        SATraceString ("CMainWindow::Initialize method failed on initializing WMI consumer");
        //we can continue without consumer
        //return hr;
    }




    RECT rcMain = { 0, 0, m_lDispWidth+8, 2*m_lDispHeight+27 };

    HWND hwnd = Create(
                        NULL,    //parent window
                        rcMain,  //coordinates
                        L"Main Window", 
                        WS_OVERLAPPEDWINDOW);

    if (NULL == hwnd)
    {
        SATraceString ("CMainWindow::Initialize method failed creating the main window");
        ShutDown();
        return E_FAIL;

    }

    //
    // set the service window
    //
    m_pSAConsumer->SetServiceWindow(hwnd);

    //
    // following operations all depend on keypad driver
    //
    if (TRUE)
    {
        //
        // initialize connection to localization manager 
        //
        hr = InitLanguageCallback();
        if (FAILED(hr))
        {
            //
            // we can continue without loc manager
            //
            SATraceString ("CMainWindow::Initialize failed on InitLanguageCallback method..");

            //return hr;
        }
    


        //
        // spawn the worker thread now 
        //
        DWORD dwThreadID = 0;

        m_hWorkerThread = ::CreateThread (
                                         NULL,           //security
                                         0,              //stack size    
                                         startworkerroutine, 
                                         (PVOID)this,
                                         0,              //init flag
                                         &dwThreadID
                                         );


        if (INVALID_HANDLE_VALUE == m_hWorkerThread)
        {
            SATraceFailure (
                        "CMainWindow::Initialize failed on CreateThread:", 
                        GetLastError ()
                        );
            // we can continue without the reader thread
        }
    }
    
    SATraceString ("CMainWindow::Initialize completed successfully...");

    hr = S_OK;

    return hr;

}    //  end of CMainWindow::Initialize  method

//++--------------------------------------------------------------
//
//  Function:   InitLanguageCallback
//
//  Synopsis:   This is CMainWindow private method for 
//              initializing the localization manager the
//                callback function from CLangChange class
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     11/21/2000
//
//  Called By:  CMainWindow::InitLanguageCallback method
//
//----------------------------------------------------------------
HRESULT
CMainWindow::InitLanguageCallback(
                VOID
                )
{

    SATraceString("Entering CMainWindow::InitLanguageCallback....");

    CLSID clsidLocMgr;
    HRESULT hr;
    IUnknown *pLangChangeUnk = NULL;

    //
    // initialize the localization manager
    //
    hr = ::CLSIDFromProgID (LOCALIZATION_MANAGER,&clsidLocMgr);

    if (FAILED(hr))
    {
        SATracePrintf ("Display Adapter unable to get CLSID for Loc Mgr:%x",hr);
        return hr;
    }
        
    //
    // create the Localization Manager COM object
    //
    hr = ::CoCreateInstance (
                            clsidLocMgr,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            __uuidof (ISALocInfo), 
                            (PVOID*) &m_pLocInfo
                            ); 
    if (FAILED (hr))
    {
        SATracePrintf ("Display Adapter unable to create Loc Mgr:%x",hr);
        m_pLocInfo = NULL;
        return hr;
    }


    //
    // create object that supports ILangChange interface
    //
    m_pLangChange = new CLangChange;

    m_pLangChange->AddRef();

    if (m_pLangChange)
    {
        //
        // Get the IUnkown pointer from m_pLangChange
        //
        hr = m_pLangChange->QueryInterface(IID_IUnknown, (void **)&pLangChangeUnk);

        if (FAILED(hr))
        {
            SATracePrintf("Query(IUnknown) failed %X",hr);

            delete m_pLangChange;

            m_pLangChange = NULL;

            return hr;
        }
    }
    else
    {
        SATraceString("new CLangChange failed");

        return E_FAIL;
    }

    //
    // Set Language change call back interface
    //
    hr = m_pLocInfo->SetLangChangeCallBack(pLangChangeUnk);

    if (FAILED(hr))
    {
        //
        // for now, ignore if can't set lang change
        // call back
        //
        SATracePrintf("SetLangChangeCallBack failed %X",hr);

        pLangChangeUnk->Release();

        pLangChangeUnk = NULL;

        return hr;

    }
    else
    {

        m_pLangChange->OnLangChangeCallback (m_hWnd);

        pLangChangeUnk->Release();

        pLangChangeUnk = NULL;
    }


    return S_OK;

} // end of CMainWindow::InitLanguageCallback method



//++--------------------------------------------------------------
//
//  Function:   KeypadReader
//
//  Synopsis:   This is CMainWindow private method in which
//              the worker thread executes
//
//  Arguments:  none
//
//  Returns:    VOID
//
//  History:    serdarun      Created     11/22/2000
//
//----------------------------------------------------------------
void CMainWindow::KeypadReader()
{

    HRESULT hr = E_FAIL;

    CoInitialize(NULL);

    SAKEY sakey;

    CComPtr<ISaKeypad> pSaKeypad;


    SATraceString("CMainWindow::KeypadReader....");

    //
    // create the display helper component
    //
    hr = CoCreateInstance(
                        CLSID_SaKeypad,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_ISaKeypad,
                        (void**)&pSaKeypad
                        );
    if (FAILED(hr))
    {
        SATracePrintf("CMainWindow::KeypadReader failed on CoCreateInstance, %d",hr);
        return;
    }

    hr = pSaKeypad->get_Key(&sakey);
    while (SUCCEEDED(hr))
    {
        SATracePrintf("KeypadReader received a key press, %d",sakey);

        if ( (sakey >= SAKEY_UP) && (sakey <= SAKEY_RETURN))
        {
            PostMessage(wm_SaKeyMessage,(WPARAM)(sakey-1),(LPARAM)0);
        }
        else
        {
            SATracePrintf("CMainWindow::KeypadReader received unknown key, %d",sakey);
        }

        hr = pSaKeypad->get_Key(&sakey);

    }

    if (FAILED(hr))
    {
        SATracePrintf("CMainWindow::KeypadReader failed on get_Key, %d",hr);
    }
    return;



    SATraceFunction("Leaving CMainWindow::KeypadReader....");
    return;
} // end of CMainWindow::KeypadReader


//++--------------------------------------------------------------
//
//  Function:   InitDisplayComponent
//
//  Synopsis:   This is CMainWindow private method for 
//              initializing the local display adapter
//              connection to the display driver
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     11/21/2000
//
//  Called By:  CMainWindow::Initialize method
//
//----------------------------------------------------------------
HRESULT
CMainWindow::InitDisplayComponent(
                VOID
                )
{
    HRESULT hr = E_FAIL;

    SATraceString("CMainWindow::InitDisplayComponent....");
    do
    {

        //
        // create the display helper component
        //
        hr = CoCreateInstance(
                            CLSID_SaDisplay,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ISaDisplay,
                            (void**)&m_pSaDisplay
                            );
        if (FAILED(hr))
        {
            SATracePrintf("CMainWindow::InitDisplayComponent failed on CoCreateInstance, %d",hr);
            break;
        }

        //
        // get the dimensions for the lcd
        //
        hr = m_pSaDisplay->get_DisplayWidth(&m_lDispWidth);
        if (FAILED(hr))
        {
            SATracePrintf("CMainWindow::InitDisplayComponent failed on get_DisplayWidth, %d",hr);
            break;
        }

        hr = m_pSaDisplay->get_DisplayHeight(&m_lDispHeight);
        if (FAILED(hr))
        {
            SATracePrintf("CMainWindow::InitDisplayComponent failed on get_DisplayHeight, %d",hr);
            break;
        }

    }
    while (false);

    return (S_OK);

}   //  end of CMainWindow::InitDisplayComponent method



//++--------------------------------------------------------------
//
//  Function:   InitWMIConsumer
//
//  Synopsis:   This is CMainWindow private method for 
//              registering the alert consumer
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//
//  History:    serdarun      Created     12/10/2000
//
//  Called By:  CMainWindow::Initialize method
//
//----------------------------------------------------------------
HRESULT CMainWindow::InitWMIConsumer()
{

    SATraceString("CMainWindow::InitWMIConsumer....");

    HRESULT hr = S_OK;
    CComPtr  <IWbemLocator> pWbemLocator;

    
    m_pSAConsumer = new CSAConsumer();

    if (!m_pSAConsumer)
    {
        SATraceString("CMainWindow::InitWMIConsumer failed on memory allocation");
        return E_OUTOFMEMORY;
    }
    m_pSAConsumer->AddRef();

    //
    // get IWbemObjectSink interface
    //
    hr = m_pSAConsumer->QueryInterface(IID_IWbemObjectSink,(LPVOID*)&m_pSAWbemSink);
    if (FAILED(hr))
    {
        SATracePrintf ("InitWMIConsumer couldn't get IWbemObjectSink interface:%x",hr);
        return hr;
    }    
        

    //
    // create the WBEM locator object  
    //
    hr = ::CoCreateInstance (
                            __uuidof (WbemLocator),
                            0,                      //aggregation pointer
                            CLSCTX_INPROC_SERVER,
                            __uuidof (IWbemLocator),
                            (PVOID*) &pWbemLocator
                            );

    if (SUCCEEDED (hr) && (pWbemLocator.p))
    {


        CComBSTR strNetworkRes (DEFAULT_NAMESPACE);

        //
        // connect to WMI 
        // 
        hr =  pWbemLocator->ConnectServer (
                                            strNetworkRes,
                                            NULL,               //user-name
                                            NULL,               //password
                                            NULL,               //current-locale
                                            0,                  //reserved
                                            NULL,               //authority
                                            NULL,               //context
                                            &m_pWbemServices
                                            );
        if (SUCCEEDED (hr))
        {
            CComBSTR strQueryLang (QUERY_LANGUAGE);
            CComBSTR strQueryString (QUERY_STRING);

            //
            // set up the consumer object as the event sync
            // for the object type we are interested in
            //
            hr = m_pWbemServices->ExecNotificationQueryAsync (
                                            strQueryLang,
                                            strQueryString,
                                            0,                  //no-status
                                            NULL,               //status
                                            (IWbemObjectSink*)(m_pSAWbemSink)
                                            );
            if (SUCCEEDED (hr))
            {
                SATraceString ("Consumer component successfully registered...");
                return hr;
            }

            SATracePrintf ("Consumer component didn't register sink with WMI:%x",hr);

        }
        else
        {
            SATracePrintf ("Consumer component failed in connect to WMI:%x",hr);
        }
    }
    else
    {
        SATracePrintf ("Consumer component failed on Creating the WBEM Locator:%x",hr);
    }
    

    return (hr);

}  //  end of CMainWindow::InitWMIConsumer method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ldm.rc
//
#define IDS_SERVICENAME                 100
#define IDR_Ldm                         100
#define IDR_SAKEYPADCONTROLLER          101
#define IDS_SERVICESHORTNAME            104


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\mainwindow.h ===
//#--------------------------------------------------------------
//
//  File:       mainwindow.h
//
//  Synopsis:   This file holds the declarations of the
//                CMainWindow class
//
//  History:     11/10/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef _MAINWINDOW_H_
#define _MAINWINDOW_H_

#define SA_DISPLAY_MAX_BITMAP_IN_BYTES SA_DISPLAY_MAX_BITMAP_SIZE/8

#include <exdispid.h>
#include <atlhost.h>
#include "saio.h"
#include "ieeventhandler.h"
#include "langchange.h"
#include "salocmgr.h"
#include "ldm.h"
#include <string>
using namespace std;
#include "sacom.h"
#include "saconsumer.h"


class CMainWindow : public CWindowImpl<CMainWindow>
{
public:
    BEGIN_MSG_MAP(CMainWindow)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_SETFOCUS, OnFocus)
        MESSAGE_HANDLER(wm_SaKeyMessage,OnSaKeyMessage)
        MESSAGE_HANDLER(wm_SaLocMessage,OnSaLocMessage)
        MESSAGE_HANDLER(wm_SaLEDMessage,OnSaLEDMessage)
        MESSAGE_HANDLER(wm_SaAlertMessage,OnSaAlertMessage)
    END_MSG_MAP()


    CMainWindow();

    LRESULT OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSaKeyMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSaLocMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSaLEDMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSaAlertMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    void PageLoaded(IDispatch* pdisp, VARIANT* purl);
    
    void RegistryPageLoaded(IDispatch* pdisp, VARIANT* purl);

    void LoadingNewPage();

    void GetBitmap();

    HRESULT Initialize();




private:
    //
    // Clear the resources
    //
    void ShutDown();

    //
    // method to register alert consumer in WMI sink
    //
    HRESULT InitWMIConsumer();

    //
    // method to initialize display helper component
    //
    HRESULT InitDisplayComponent ();

    //
    // create the language change class
    // initialize the connection to localization manager
    //
    HRESULT InitLanguageCallback();

    //
    // determines the port number for default web site
    // and construct URLs for localui pages
    //
    HRESULT ConstructUrlStrings();

    //
    // creates the main IE control that is used for rendering
    //
    HRESULT CreateMainIEControl();

    //
    // creates the second IE control that is used for startup pages
    //
    HRESULT CreateSecondIEControl();

    void PrintRegistryPage();

    //
    // sets an active element on a page if nothing is selected
    //
    void CMainWindow::CorrectTheFocus();

    //
    // here are the private resource handles
    //
    LONG                m_lDispHeight;
    LONG                m_lDispWidth;
    HANDLE              m_hWorkerThread;
    BOOL                m_bSecondIECreated;

public:
    //
    // display component object
    //
    CComPtr<ISaDisplay> m_pSaDisplay;

    //
    // worker function to read messages from keypad
    //
    void KeypadReader();

    //
    // pointers to main IE control
    //
    CComPtr<IWebBrowser2>                m_pMainWebBrowser;
    CComPtr<IUnknown>                    m_pMainWebBrowserUnk;
    CComPtr<IOleInPlaceActiveObject>    m_pMainInPlaceAO;
    CComPtr<IOleObject>                    m_pMainOleObject;
    CComPtr<IViewObject2>                m_pMainViewObject;
    CComObject<CWebBrowserEventSink>*    m_pMainWebBrowserEventSink;

    //
    // window handle of the main IE control
    //
    HWND m_hwndWebBrowser;

    DWORD m_dwMainCookie;


    //
    // state of the startup pages
    //
    SA_REGISTRYBITMAP_STATE m_RegBitmapState;

    //
    // Language change 
    //
    CLangChange     *m_pLangChange;
    ISALocInfo      *m_pLocInfo;

    //
    // pointers to second IE control
    // this one is used render startup pages
    //
    CComPtr<IWebBrowser2>                m_pSecondWebBrowser;
    CComPtr<IUnknown>                    m_pSecondWebBrowserUnk;
    CComObject<CWebBrowserEventSink>*    m_pSecondWebBrowserEventSink;

    DWORD m_dwSecondCookie;


    //
    // GDI objects used for drawing
    //
    HDC m_HdcMem;
    HBITMAP m_hBitmap;


    //
    // timers for the registry and main page
    //
    UINT_PTR m_unintptrMainTimer;

    UINT_PTR m_unintptrSecondTimer;

    DWORD id;

    //
    // flag for the ready state of web page
    //
    BOOL m_bPageReady;

    //
    // Pointer to keypad controller component
    //
    CComPtr<ISAKeypadController> m_pSAKeypadController;

    //
    // Pointer to consumer component
    //
    CComPtr<IWbemObjectSink> m_pSAWbemSink;

    //
    // Pointer to saconsumer interface
    //
    CSAConsumer *m_pSAConsumer;

    //
    // led message dword
    //
    DWORD m_dwLEDMessageCode;

    //
    // URL strings
    //
    wstring m_szMainPage;

    BOOL m_bInTaskorMainPage;
    //
    // %system32%\ServerAppliance\LocalUI
    //
    wstring m_szLocalUIDir;

    //
    // Pointer to Wbem services component
    //
    CComPtr  <IWbemServices> m_pWbemServices;

    //
    // 
    //
    BOOL m_bActiveXFocus;

};






#endif //_MAINWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\sakeypadcontroller.cpp ===
//#--------------------------------------------------------------
//
//  File:       SAKeypadController.cpp
//
//  Synopsis:   This file holds the implementation of the
//                CSAKeypadController class
//
//  History:     11/15/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#include "stdafx.h"
#include "ldm.h"
#include "SAKeypadController.h"

/////////////////////////////////////////////////////////////////////////////
// CSAKeypadController methods

//++--------------------------------------------------------------
//
//  Function:   LoadDefaults
//
//  Synopsis:   This is the ISAKeypadController interface method 
//              through which default keys codes are set
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     11/15/2000
//
//  Called By:  ldm service
//
//----------------------------------------------------------------
STDMETHODIMP CSAKeypadController::LoadDefaults()
{
    // TODO: Add your implementation code here
    int i = 0;

    while(i < iNumberOfKeys)
    {
        arbShiftKeys[i] = FALSE;
        if ( i == 0 )
            arbShiftKeys[i] = TRUE;
        i++;
    }
    arlMessages[0] = VK_TAB;
    arlMessages[1] = VK_TAB;
    arlMessages[2] = VK_LEFT;
    arlMessages[3] = VK_RIGHT;
    arlMessages[4] = -1;
    arlMessages[5] = VK_RETURN;

    return S_OK;

} // end of CSAKeypadController::LoadDefaults method

//++--------------------------------------------------------------
//
//  Function:   SetKey
//
//  Synopsis:   This is the ISAKeypadController interface method 
//              through which specific keys codes are set
//
//  Arguments:  lKeyID: id of the key to be set
//                lMessage: message code to be set
//                fShiftKeyDown: state of the shift key
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     11/15/2000
//
//  Called By:  ldm service
//
//----------------------------------------------------------------
STDMETHODIMP CSAKeypadController::SetKey(LONG lKeyID, LONG lMessage, BOOL fShiftKeyDown)
{
    if ( (lKeyID < 0) || (lKeyID >= iNumberOfKeys) )
        return S_OK;

    arlMessages[lKeyID] = lMessage;
    arbShiftKeys[lKeyID] = fShiftKeyDown;

    return S_OK;
} // end of CSAKeypadController::SetKey method

//++--------------------------------------------------------------
//
//  Function:   GetKey
//
//  Synopsis:   This is the ISAKeypadController interface method 
//              through which specific keys codes are received
//
//  Arguments:  lKeyID: id of the key to be received
//                lMessage: message code
//                fShiftKeyDown: state of the shift key
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     11/15/2000
//
//  Called By:  ldm service
//
//----------------------------------------------------------------
STDMETHODIMP CSAKeypadController::GetKey(LONG lKeyID, LONG *lMessage, BOOL *fShiftKeyDown)
{

    if ((!lMessage) || (!fShiftKeyDown))
        return E_POINTER;


    if ( (lKeyID < 0) || (lKeyID >= iNumberOfKeys) )
        return S_OK;

    *lMessage = arlMessages[lKeyID];

    *fShiftKeyDown = arbShiftKeys[lKeyID];

    return S_OK;

} // end of CSAKeypadController::GetKey method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\saconsumer.cpp ===
//#--------------------------------------------------------------
//
//  File:       saconsumer.cpp
//
//  Synopsis:   This file holds the implementation of the
//                CSAConsumer class
//
//  History:     12/10/2000  serdarun Created
//
//  Copyright (C) 1999-2000 Microsoft Corporation
//  All rights reserved.
//
//#--------------------------------------------------------------

#include "stdafx.h"
#include "ldm.h"
#include "SAConsumer.h"

const WCHAR ELEMENT_RETRIEVER [] = L"Elementmgr.ElementRetriever";
const WCHAR RESOURCE_CONTAINER [] = L"LOCALUIAlertDefinitions";
const WCHAR SA_ALERTS [] = L"SA_Alerts";
//
// name of WBEM class
//
const WCHAR PROPERTY_CLASS_NAME     [] = L"__CLASS";
const WCHAR PROPERTY_ALERT_ID        [] = L"AlertID";
const WCHAR PROPERTY_ALERT_SOURCE    [] = L"AlertSource";
const WCHAR PROPERTY_ALERT_LOG        [] = L"AlertLog";
const WCHAR PROPERTY_ALERT_COOKIE    [] = L"Cookie";
const WCHAR PROPERTY_ALERT_BITCODE    [] = L"LocalUIMsgCode";

// Alert Event Classes
const WCHAR CLASS_WBEM_RAISE_ALERT    [] = L"Microsoft_SA_RaiseAlert";
const WCHAR CLASS_WBEM_CLEAR_ALERT    [] = L"Microsoft_SA_ClearAlert";

//
// Standard IUnknown implementation
//
ULONG CSAConsumer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//
// Standard IUnknown implementation
//
ULONG CSAConsumer::Release()
{
    if (InterlockedDecrement(&m_lRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_lRef;
}

//
// Standard IUnknown implementation
//
STDMETHODIMP CSAConsumer::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

    SATraceFunction("CSAConsumer::QueryInterface");
    if (IID_IUnknown==riid)
    {
        *ppv = (void *)(IUnknown *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        if (IID_IWbemObjectSink==riid)
        {
            *ppv = (void *)(IWbemObjectSink *) this;
            AddRef();
            return S_OK;
        }
    }
    return E_NOINTERFACE;
}

//++--------------------------------------------------------------
//
//  Function:   Indicate
//
//  Synopsis:   This is the IWbemObjectSink interface method 
//              through which WBEM calls back to provide the 
//              event objects
//
//  Arguments:  
//              [in]    LONG               -  number of events
//              [in]    IWbemClassObject** -  array of events
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/10/2000
//
//  Called By:  WBEM 
//
//----------------------------------------------------------------
STDMETHODIMP CSAConsumer::Indicate (
                    /*[in]*/    LONG                lObjectCount,
                    /*[in]*/    IWbemClassObject    **ppObjArray
                    )
{


    HRESULT hr = WBEM_S_NO_ERROR;
    
    BOOL bNewLocalUIAlert = FALSE;

    _ASSERT (ppObjArray && (0 != lObjectCount));

    //
    // check if we have somthing to process
    //
    if ((!ppObjArray) || (0 == lObjectCount)) 
    {
        return (WBEM_E_INVALID_PARAMETER);
    }

    CComBSTR bstrClassName = CComBSTR(PROPERTY_CLASS_NAME);
    if (bstrClassName.m_str == NULL)
    {
        SATraceString ("CSAConsumer::Indicate failed on memory allocation");
        return E_OUTOFMEMORY;
    }

    try
    {

        SATraceString ("CSAConsumer::Indicate-WMI called with event objects");

        for (LONG lCount = 0; lCount < lObjectCount; lCount++)
        {
            //
            // get the event type 
            //
            CComVariant vtName;
            hr = ppObjArray[lCount]->Get (
                                        bstrClassName, 
                                        0,                          //reserved
                                        &vtName,
                                        NULL,                      // type
                                        NULL                       // flavor
                                        );
            if (FAILED (hr))
            {
                SATracePrintf("CSAConsumer-Consumer unable to get event name:%x",hr);
                break;
            }


            if ( ( 0 == _wcsicmp (CLASS_WBEM_CLEAR_ALERT, V_BSTR (&vtName)) ) ||
                ( 0 == _wcsicmp (CLASS_WBEM_RAISE_ALERT, V_BSTR (&vtName)) ) )
            {
                bNewLocalUIAlert = TRUE;
            }

        }

        if (bNewLocalUIAlert)
        {
            //
            // Notify clients about this alert
            //
            ::PostMessage(m_hwndMainWindow,wm_SaAlertMessage,(WPARAM)0,(LPARAM)0);

            //
            // calculate the new message code and notify saldm
            //
            // don't need it anymore, no led support
            CalculateMsgCodeAndNotify();
        }

    }
    catch (...)
    {
        SATraceString("Exception occured in CSAConsumer::Indicate method");
    }
    
    //
    // we don't have enumeration, so just return
    //
    return WBEM_S_NO_ERROR;

} // end of CSAConsumer::Indicate method



//++--------------------------------------------------------------
//    
//  Function:   SetStatus
//
//  Synopsis:   This is the IWbemObjectSink interface method 
//              through which WBEM calls in to indicate end of
//              event sequence or provide other error codes
//
//  Arguments:  
//              [in]    LONG    -           progress 
//              [in]    HRESULT -           status information
//              [in]    BSTR    -           string info
//              [in]    IWbemClassObject* - status object 
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/10/2000
//
//  Called By:  WBEM 
//
//----------------------------------------------------------------
STDMETHODIMP CSAConsumer::SetStatus (
                /*[in]*/    LONG                lFlags,
                /*[in]*/    HRESULT             hResult,
                /*[in]*/    BSTR                strParam,
                /*[in]*/    IWbemClassObject    *pObjParam
                )
{   

    SATracePrintf ("SAConsumer-IWbemObjectSink::SetStatus called:%x",hResult);

    return (WBEM_S_NO_ERROR);

} // end of CSAConsumer::SetStatus method



STDMETHODIMP CSAConsumer::SetServiceWindow(
                                /*[in]*/ HWND hwndMainWindow
                                )
{
    m_hwndMainWindow = hwndMainWindow;
    return S_OK;
}

//++--------------------------------------------------------------
//
//  Function:   CalculateMsgCodeAndNotify
//
//  Synopsis:   calculate the new message code and notify saldm 
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/16/2001
//
//----------------------------------------------------------------
STDMETHODIMP CSAConsumer::CalculateMsgCodeAndNotify(void)
{

    HRESULT hr;
    
    //
    // will contain the class id for element manager
    //
    CLSID clsid;

    //
    // element manager pointer
    //
    CComPtr<IWebElementRetriever> pWebElementRetriever = NULL;

    CComPtr<IDispatch> pDispatch = NULL;

    //
    // All of the sa alerts
    //
    CComPtr<IWebElementEnum> pAlertEnum = NULL;

    //
    // Localui alert definitions
    //
    CComPtr<IWebElementEnum> pAlertDefEnum = NULL;

    //
    // LocalUI message code
    //
    DWORD dwLocalUIMsgCode = 1;

    //
    // number of sa alerts
    //
    LONG lAlertCount = 0;

    //
    // enumaration of sa alerts
    //
    CComPtr<IEnumVARIANT> pEnumVariant = NULL;
    CComPtr<IUnknown> pUnknown = NULL;
    
    DWORD dwElementsLeft = 0;

    CComVariant varElement;

    CComBSTR bstrSaAlerts = CComBSTR(SA_ALERTS);
    CComBSTR bstrResourceContainer = CComBSTR(RESOURCE_CONTAINER);
    CComBSTR bstrAlertLog = CComBSTR(PROPERTY_ALERT_LOG);
    CComBSTR bstrAlertID = CComBSTR(PROPERTY_ALERT_ID);
    CComBSTR bstrAlertBitCode = CComBSTR(PROPERTY_ALERT_BITCODE);

    if ( (bstrSaAlerts.m_str == NULL) ||
         (bstrResourceContainer.m_str == NULL)||
         (bstrAlertLog.m_str == NULL)||
         (bstrAlertID.m_str == NULL)||
         (bstrAlertBitCode.m_str == NULL) )
    {
        SATraceString("CSAConsumer::CalculateMsgCodeAndNotify failed on memory allocation ");
        return E_OUTOFMEMORY;
    }
    //
    // get the CLSID for Element manager
    //
    hr =  ::CLSIDFromProgID (ELEMENT_RETRIEVER,&clsid);

    if (FAILED (hr))
    {
        SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on CLSIDFromProgID:%x",hr);
        return hr;
    }


    //
    // create the Element Retriever now
    //
    hr = ::CoCreateInstance (
                            clsid,
                            NULL,
                            CLSCTX_LOCAL_SERVER,
                            IID_IWebElementRetriever,
                            (PVOID*) &pWebElementRetriever
                            );

    if (FAILED (hr))
    {
        SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on CoCreateInstance:%x",hr);
        return hr;
    }
    
    //
    // get all of the sa alerts
    //  
    hr = pWebElementRetriever->GetElements (
                                            1,
                                            bstrSaAlerts,
                                            &pDispatch
                                            );



    if (FAILED (hr))
    {
        SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on GetElements for sa alerts:%x",hr);
        return hr;
    }

    //
    //  get the enum variant for sa alerts
    //
    hr = pDispatch->QueryInterface (
            IID_IWebElementEnum,
            (LPVOID*) (&pAlertEnum)
            );

    if (FAILED (hr))
    {
        SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on QueryInterface:%x",hr);
        return hr;
    }


    //
    // get number of alerts
    //
    hr = pAlertEnum->get_Count (&lAlertCount);
    
    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on get_Count:%x",hr);
        return hr;
    }


    //
    // no alerts, just send message code zero to main window
    //
    if (0 == lAlertCount)
    {
        ::PostMessage(m_hwndMainWindow,wm_SaLEDMessage,WPARAM(dwLocalUIMsgCode),(LPARAM)0);
        return S_OK;
    }

    pDispatch = NULL;

    //
    // get localui alert definitions
    //  
    hr = pWebElementRetriever->GetElements (
                                            1,
                                            bstrResourceContainer,
                                            &pDispatch
                                            );
    if (FAILED (hr))
    {
        SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on GetElements for alert definitions:%x",hr);
        return hr;
    }

    //
    //  get the enum variant
    //
    hr = pDispatch->QueryInterface (
            IID_IWebElementEnum,
            (LPVOID*) (&pAlertDefEnum)
            );

    if (FAILED (hr))
    {
        SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on QueryInterface:%x",hr);
        return hr;
    }


    //
    // enumerate sa alerts and find the localui ones
    //
    hr = pAlertEnum->get__NewEnum (&pUnknown);
    if (FAILED (hr))
    {
        SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on get__NewEnum:%x",hr);
        return hr;
    }


    //
    //  get the enum variant
    //
    hr = pUnknown->QueryInterface (
                    IID_IEnumVARIANT,
                    (LPVOID*)(&pEnumVariant)
                    );

    if (FAILED (hr))
    {
        SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on QueryInterface:%x",hr);
        return hr;
    }

    //
    //  get elements out of the collection and initialize
    //
    hr = pEnumVariant->Next (1, &varElement, &dwElementsLeft);
    if (FAILED (hr))
    {
        SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on Next:%x",hr);
        return hr;
    }


    //
    // for each resource
    //
    while ((dwElementsLeft> 0) && (SUCCEEDED (hr)) )
    {

        //
        // get the IWebElement Interface from alert object
        //

        CComPtr <IWebElement> pElement;
        hr = varElement.pdispVal->QueryInterface ( 
                    __uuidof (IWebElement),
                    (LPVOID*)(&pElement)
                    );
        
        if (FAILED (hr))
        {
            SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on QueryInterface:%x",hr);
            return hr;
        }


        wstring wsAlertKey;
        //
        // get the alert log 
        //
        CComVariant vtAlertLog;
        hr = pElement->GetProperty (
                                bstrAlertLog, 
                                &vtAlertLog
                                );

        if (FAILED (hr))
        {
            SATracePrintf("CSAConsumer-CalculateMsgCodeAndNotify unable to get alert log:%x",hr);
            return hr;                    
        }

        SATracePrintf("CSAConsumer-CalculateMsgCodeAndNotify alert log:%ws",V_BSTR (&vtAlertLog));
        
        //
        // get the alert id 
        //
        CComVariant vtAlertID;
        hr = pElement->GetProperty (
                                    bstrAlertID, 
                                    &vtAlertID
                                    );

        if (FAILED (hr))
        {
            SATracePrintf("CSAConsumer-CalculateMsgCodeAndNotify unable to get alert id:%x",hr);
            return hr;
        }

        SATracePrintf("CSAConsumer-CalculateMsgCodeAndNotify alert id:%x",V_I4 (&vtAlertID));

        WCHAR szAlertID[16];

        //
        // convert alert id to a hex string
        //
        swprintf(szAlertID,L"%X",V_I4 (&vtAlertID));

        //
        // create key name by appending, container+alertlog+alertid
        //
        wsAlertKey.assign(RESOURCE_CONTAINER);
        wsAlertKey.append(V_BSTR (&vtAlertLog));
        wsAlertKey.append(szAlertID);

        CComVariant vtAlertKey = wsAlertKey.c_str();

        SATracePrintf("CSAConsumer-CalculateMsgCodeAndNotify alert element id:%ws",V_BSTR(&vtAlertKey));
            
        CComPtr<IDispatch> pDispElement = NULL;

        //
        // check if it is a localui alert
        //
        hr = pAlertDefEnum->Item(&vtAlertKey,&pDispElement);
                    
        if ( (SUCCEEDED(hr)) && (pDispElement != NULL) )
        {
            //
            // get the IWebElement Interface from alert definition object
            //

            CComPtr <IWebElement> pAlertElement = NULL;
            hr = pDispElement->QueryInterface ( 
                        __uuidof (IWebElement),
                        (LPVOID*)(&pAlertElement)
                        );
        
            if (FAILED (hr))
            {
                SATracePrintf ("CSAConsumer::CalculateMsgCodeAndNotify failed on QueryInterface for IWebElement:%x",hr);
                return hr;
            }

            //
            // get the alert message code
            //
            CComVariant vtAlertMsgCode;

            hr = pAlertElement->GetProperty (
                                        bstrAlertBitCode, 
                                        &vtAlertMsgCode
                                        );

            if (FAILED (hr))
            {
                SATracePrintf("CSAConsumer-CalculateMsgCodeAndNotify unable to get alert message code:%x",hr);
            }
            else
            {
                SATracePrintf("CSAConsumer-CalculateMsgCodeAndNotify message code:%x",V_I4(&vtAlertMsgCode));
                dwLocalUIMsgCode |= V_I4(&vtAlertMsgCode);
            }
        }

        //
        //  clear the perClient value from this variant
        //
        varElement.Clear ();

        //
        //  get next client out of the collection
        //
        hr = pEnumVariant->Next (1, &varElement, &dwElementsLeft);
        if (FAILED (hr))
        {
            SATracePrintf ("CSAConsumer-CalculateMsgCodeAndNotify failed on Next:%x",hr);
        }
    }
    
    ::PostMessage(m_hwndMainWindow,wm_SaLEDMessage,WPARAM(dwLocalUIMsgCode),(LPARAM)0);

    return S_OK;

} // end of CSAConsumer::CalculateMsgCodeAndNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\sakeypadcontroller.h ===
//#--------------------------------------------------------------
//
//  File:       SAKeypadController.h
//
//  Synopsis:   This file holds the declarations of the
//                CSAKeypadController class
//
//  History:     11/15/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------


#ifndef __SAKEYPADCONTROLLER_H_
#define __SAKEYPADCONTROLLER_H_

#include "resource.h"       // main symbols
#include <atlctl.h>


#define iNumberOfKeys 6
/////////////////////////////////////////////////////////////////////////////
// CSAKeypadController
//
// 
//
class ATL_NO_VTABLE CSAKeypadController : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSAKeypadController, &CLSID_SAKeypadController>,
    public IDispatchImpl<ISAKeypadController, &IID_ISAKeypadController, &LIBID_LDMLib>,
    public IObjectSafetyImpl<CSAKeypadController,INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{

public:

    CSAKeypadController()
    {
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_SAKEYPADCONTROLLER)

    DECLARE_NOT_AGGREGATABLE(CSAKeypadController)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_CLASSFACTORY_SINGLETON (CSAKeypadController)

    BEGIN_COM_MAP(CSAKeypadController)
        COM_INTERFACE_ENTRY(ISAKeypadController)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_COM_MAP()

private:

    LONG arlMessages[iNumberOfKeys];
    BOOL arbShiftKeys[iNumberOfKeys];

public:
    //
    // IObjectSafety methods
    //
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
    {
        return S_OK;
    }

    //
    // ISAKeypadController methods
    //
    STDMETHOD(GetKey)(
                    /*[in]*/ LONG lKeyID, 
                    /*[out]*/ LONG * lMessage, 
                    /*[out]*/ BOOL * fShiftKeyDown
                    );

    STDMETHOD(SetKey)(
                    /*[in]*/ LONG lKeyID, 
                    /*[in]*/ LONG lMessage, 
                    /*[in]*/ BOOL fShiftKeyDown);

    STDMETHOD(LoadDefaults)();
};

#endif //__SAKEYPADCONTROLLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\saconsumer.h ===
//#--------------------------------------------------------------
//
//  File:       saconsumer.h
//
//  Synopsis:   This file holds the declaration of the
//                CSAConsumer class
//
//  History:     12/10/2000  serdarun Created
//
//  Copyright (C) 1999-2000 Microsoft Corporation
//  All rights reserved.
//
//#--------------------------------------------------------------

#ifndef __SACONSUMER_H_
#define __SACONSUMER_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "elementmgr.h"
#include <string>
#include <map>
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CSAConsumer
//
// Class for receiving WMI events, specifically SA Alerts
//
class CSAConsumer : 
    public IWbemObjectSink
{
public:
    CSAConsumer()
        :m_pLocalUIAlertEnum(NULL),
        m_lRef(0),
        m_hwndMainWindow(NULL)
    {
    }

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


private:

    //
    // handle to the main window
    //
    HWND m_hwndMainWindow;

    //
    // points to localui alerts enumeration
    //
    CComPtr<IWebElementEnum> m_pLocalUIAlertEnum;


    //
    // calculate the new localui msg code and notify saldm
    //
    STDMETHOD(CalculateMsgCodeAndNotify)(void);

    //
    // reference counter
    //
    LONG m_lRef;

public:

    //
    // public method to receive handle to service window
    //
    STDMETHOD(SetServiceWindow) (
                                /*[in]*/ HWND hwndMainWindow
                                );


    //
    // ---------IWbemUnboundObjectSink interface methods----------
    //
    STDMETHOD(Indicate) (
                    /*[in]*/    LONG                lObjectCount,
                    /*[in]*/    IWbemClassObject    **ppObjArray
                    );
    
    STDMETHOD(SetStatus) (
                    /*[in]*/    LONG                lFlags,
                    /*[in]*/    HRESULT             hResult,
                    /*[in]*/    BSTR                strParam,
                    /*[in]*/    IWbemClassObject    *pObjParam
                    );


};

#endif //__SACONSUMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuictrl\hostname.h ===
//#--------------------------------------------------------------
//
//  File:       hostname.h
//
//  Synopsis:   This file holds the declaration of the
//                CSADataEntryCtrl class
//
//  History:     12/15/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#ifndef __HOSTNAME_H_
#define __HOSTNAME_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "LocalUIControlsCP.h"

#define SADataEntryCtrlMaxSize 50
#define SADataEntryCtrlDefaultSize 20

const WCHAR szDefaultCharSet[] = L"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";

/////////////////////////////////////////////////////////////////////////////
// CSADataEntryCtrl
class ATL_NO_VTABLE CSADataEntryCtrl : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ISADataEntryCtrl, &IID_ISADataEntryCtrl, &LIBID_LOCALUICONTROLSLib>,
    public CComControl<CSADataEntryCtrl>,
    public IOleControlImpl<CSADataEntryCtrl>,
    public IOleObjectImpl<CSADataEntryCtrl>,
    public IOleInPlaceActiveObjectImpl<CSADataEntryCtrl>,
    public IViewObjectExImpl<CSADataEntryCtrl>,
    public IOleInPlaceObjectWindowlessImpl<CSADataEntryCtrl>,
    public IConnectionPointContainerImpl<CSADataEntryCtrl>,
    public IQuickActivateImpl<CSADataEntryCtrl>,
    public IProvideClassInfo2Impl<&CLSID_SADataEntryCtrl, &DIID__ISADataEntryCtrlEvents, &LIBID_LOCALUICONTROLSLib>,
    public IPropertyNotifySinkCP<CSADataEntryCtrl>,
    public CComCoClass<CSADataEntryCtrl, &CLSID_SADataEntryCtrl>,
    public CProxy_ISADataEntryCtrlEvents< CSADataEntryCtrl >,
    public IObjectSafetyImpl<CSADataEntryCtrl,INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
    CSADataEntryCtrl()
    {
        wcscpy(m_strTextValue,L"AAAAAAAAAAAAAAAAAAA");
        m_iPositionFocus = 0;
        m_lMaxSize = SADataEntryCtrlDefaultSize;
        m_szTextCharSet = szDefaultCharSet;
        m_hFont = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SADATAENTRYCTRL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

DECLARE_CLASSFACTORY_SINGLETON (CSADataEntryCtrl)

BEGIN_COM_MAP(CSADataEntryCtrl)
    COM_INTERFACE_ENTRY(ISADataEntryCtrl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CSADataEntryCtrl)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CSADataEntryCtrl)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    CONNECTION_POINT_ENTRY(DIID__ISADataEntryCtrlEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CSADataEntryCtrl)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    CHAIN_MSG_MAP(CComControl<CSADataEntryCtrl>)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// ISADataEntryCtrl
public:


    //
    // get current data display in the controls
    //
    STDMETHOD(get_TextValue)
                        (
                        /*[out, retval]*/ BSTR *pVal
                        );

    //
    // set current data display in the controls
    //
    STDMETHOD(put_TextValue)
                        (
                        /*[in]*/ BSTR newVal
                        );

    //
    // set the maximum number of chars the control can display
    //
    STDMETHOD(put_MaxSize)
                        (
                        /*[in]*/ LONG lMaxSize
                        );

    //
    // set character set that can used in the data entry
    //
    STDMETHOD(put_TextCharSet)
                        (
                        /*[in]*/ BSTR newVal
                        );

    //
    // IObjectSafety methods
    //
    STDMETHOD(SetInterfaceSafetyOptions)
                        (
                        REFIID riid, 
                        DWORD dwOptionSetMask, 
                        DWORD dwEnabledOptions
                        )
    {
        return S_OK;
    }


    //
    // called just after constructor, initializes the component
    //
    STDMETHOD(FinalConstruct)(void);

    //
    // called just before destructor, releases resources
    //
    STDMETHOD(FinalRelease)(void);

    //
    // gets the current character set
    //
    BYTE GetCharacterSet ();

    //
    // handler for key messages
    //
    LRESULT OnKeyDown
                (
                UINT uMsg, 
                WPARAM wParam, 
                LPARAM lParam, 
                BOOL& bHandled
                );

    //
    // method to draw the control
    //
    HRESULT OnDraw
                (
                ATL_DRAWINFO& di
                );


    //
    //
    //
    WCHAR m_strTextValue[SADataEntryCtrlMaxSize+1];

    LONG m_lMaxSize;
    CComBSTR m_szTextCharSet;
    int m_iPositionFocus;

    HFONT m_hFont;

};

#endif //__HOSTNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuictrl\hostname.cpp ===
//#--------------------------------------------------------------
//
//  File:       SADataEntryCtrl.cpp
//
//  Synopsis:   This file holds the implmentation of the
//                CSADataEntryCtrl class
//
//  History:     12/15/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#include "stdafx.h"
#include "LocalUIControls.h"
#include "HostName.h"
#include "satrace.h"

//
// registry path for LCID value
//
const WCHAR LOCALIZATION_MANAGER_REGISTRY_PATH []  = 
        L"SOFTWARE\\Microsoft\\ServerAppliance\\LocalizationManager\\resources";


const WCHAR LANGID_VALUE [] = L"LANGID";


/////////////////////////////////////////////////////////////////////////////
// CSADataEntryCtrl

//++--------------------------------------------------------------
//
//  Function:   get_TextValue
//
//  Synopsis:   This is the ISADataEntryCtrl interface method 
//              through which data entry is retrieved
//
//  Arguments:  BSTR *pVal
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CSADataEntryCtrl::get_TextValue(BSTR *pVal)
{

    WCHAR strTextValue[SADataEntryCtrlMaxSize+1];

    int iFirstIndex = 0;
    int iSecondIndex = 0;
    BOOL bCopiedFirstChar = FALSE;

    if (pVal == NULL)
    {
        return E_POINTER;
    }

    //
    // trim the beginning spaces and copy until next space
    //
    while ( iFirstIndex < m_lMaxSize+1 )
    {
        if ( m_strTextValue[iFirstIndex] == ' ' )
        {
            //
            // this is one of the trailing spaces, stop copying
            //
            if ( bCopiedFirstChar )
            {
                break;
            }
        }
        else
        {
            bCopiedFirstChar = TRUE;
            strTextValue[iSecondIndex] = m_strTextValue[iFirstIndex];
            iSecondIndex++;
        }

        iFirstIndex++;
    }

    strTextValue[iSecondIndex] = 0;
    *pVal = SysAllocString(strTextValue);

    if (*pVal)
    {
        return S_OK;
    }

    return E_OUTOFMEMORY;

} // end of CSADataEntryCtrl::get_TextValue method

//++--------------------------------------------------------------
//
//  Function:   put_TextValue
//
//  Synopsis:   This is the ISADataEntryCtrl interface method 
//              through which data entry is set
//
//  Arguments:  BSTR newVal
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CSADataEntryCtrl::put_TextValue(BSTR newVal)
{

    if (newVal == NULL)
    {
        return E_POINTER;
    }

    //
    // reset the focus position
    //
    m_iPositionFocus = 0;

    //
    // must have at least one character
    //
    int iLength = wcslen(newVal);
    if (iLength == 0)
    {
        return E_INVALIDARG;
    }

    int iIndex = 0;
    while ( (iIndex < m_lMaxSize ) )
    {
        if ( iIndex < iLength ) 
        {
            m_strTextValue[iIndex] = newVal[iIndex];
        }
        else
        {
            m_strTextValue[iIndex] = ' ';
        }
        iIndex++;
    }

    m_strTextValue[iIndex] = 0;

    _wcsupr(m_strTextValue);

    //
    // draw the control again
    //
    FireViewChange();
    return S_OK;

} // end of CSADataEntryCtrl::put_TextValue method

//++--------------------------------------------------------------
//
//  Function:   put_MaxSize
//
//  Synopsis:   This is the ISADataEntryCtrl interface method 
//              through which size of the data entry is set
//
//  Arguments:  LONG lMaxSize
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CSADataEntryCtrl::put_MaxSize(LONG lMaxSize)
{

    if (lMaxSize <= 0)
    {
        return E_INVALIDARG;
    }

    if (lMaxSize > SADataEntryCtrlMaxSize)
    {
        m_lMaxSize = SADataEntryCtrlMaxSize;
    }

    //
    // reset the focus position
    //
    m_iPositionFocus = 0;

    m_lMaxSize = lMaxSize;

    //
    // add and remove characters from current value based on max size
    //
    int iIndex = wcslen(m_strTextValue);
    if (iIndex < m_lMaxSize+1)
    {
        while (iIndex < m_lMaxSize)
        {
            m_strTextValue[iIndex] = ' ';
            iIndex++;
        }
        m_strTextValue[iIndex] = 0;

    }
    else if (iIndex > m_lMaxSize)
    {
        while (iIndex > m_lMaxSize)
        {
            m_strTextValue[iIndex] = 0;
            iIndex--;
        }
    }

    //
    // draw the control again
    //
    FireViewChange();

    return S_OK;

} // end of CSADataEntryCtrl::put_MaxSize method

//++--------------------------------------------------------------
//
//  Function:   put_TextCharSet
//
//  Synopsis:   This is the ISADataEntryCtrl interface method 
//              through which character set is set
//
//  Arguments:  BSTR newVal
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CSADataEntryCtrl::put_TextCharSet(BSTR newVal)
{

    if (newVal == NULL)
    {
        return E_POINTER;
    }

    m_szTextCharSet = newVal;

    return S_OK;

} // end of CSADataEntryCtrl::put_TextCharSet method


//++--------------------------------------------------------------
//
//  Function:   FinalConstruct
//
//  Synopsis:   Called just after the constructor,
//              creates the font
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     04/18/2001
//
//----------------------------------------------------------------
STDMETHODIMP CSADataEntryCtrl::FinalConstruct(void)
{

    //
    // set the font now
    //
    LOGFONT logfnt;

    ::memset (&logfnt, 0, sizeof (logfnt));
    logfnt.lfOutPrecision = OUT_TT_PRECIS;
    logfnt.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    logfnt.lfQuality = PROOF_QUALITY;
    logfnt.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
    logfnt.lfHeight = 12;

    logfnt.lfCharSet = GetCharacterSet ();

    //
    // we chose the fontface for Japanese and let GDI
    // decide for the rest
    //
    if (SHIFTJIS_CHARSET == logfnt.lfCharSet) 
    {
        lstrcpy(logfnt.lfFaceName, TEXT("MS UI Gothic"));
    }
    else
    {
        lstrcpy(logfnt.lfFaceName, TEXT("Arial"));
    }

    m_hFont = ::CreateFontIndirect(&logfnt);

    return S_OK;
}

//++--------------------------------------------------------------
//
//  Function:   FinalRelease
//
//  Synopsis:   Called just after the destructor,
//              deletes the font
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     04/18/2001
//
//----------------------------------------------------------------
STDMETHODIMP CSADataEntryCtrl::FinalRelease(void)
{
    if (m_hFont)
    {
        DeleteObject(m_hFont);
    }

    return S_OK;

}

//++--------------------------------------------------------------
//
//  Function:   GetCharacterSet
//
//  Synopsis:   This is method used to get the character set to use
//              for the FONTS
//  Arguments:  
//
//  Returns:    BYTE    - CharacterSet
//
//  History:    serdarun      Created     04/18/2001
//
//  Called By:  FinalConstruct method
//
//----------------------------------------------------------------
BYTE CSADataEntryCtrl::GetCharacterSet ()
{
    HKEY hOpenKey = NULL;
    BYTE byCharSet = DEFAULT_CHARSET;

    do
    {
        DWORD dwLangId = 0;

        //
        // open the local machine registry
        //
        LONG lRetVal = ::RegOpenKeyEx (
                            HKEY_LOCAL_MACHINE,
                            LOCALIZATION_MANAGER_REGISTRY_PATH,
                            NULL,                   //reserved
                            KEY_QUERY_VALUE,
                            &hOpenKey
                            );
        if (ERROR_SUCCESS == lRetVal)
        {
            DWORD dwBufferSize = sizeof (dwLangId);
            //
            // get the LANGID now
            //
            lRetVal = ::RegQueryValueEx (
                                hOpenKey,
                                LANGID_VALUE,
                                NULL,                   //reserved
                                NULL,         
                                (LPBYTE) &dwLangId,
                                &dwBufferSize
                                );
            if (ERROR_SUCCESS == lRetVal)
            {
                SATracePrintf (
                    "CSADataEntryCtrl got the language ID:%d",
                    dwLangId
                    );
            }
            else
            {
                SATraceFailure (
                    "CSADataEntryCtrl unable to get language ID", 
                    GetLastError()
                    );
            }
        }
        else
        {
            SATraceFailure (
                "CSADataEntryCtrl failed to open registry to get language id",
                 GetLastError());
        }

        switch (dwLangId)
        {
        case 0x401:
            // Arabic     
            byCharSet = ARABIC_CHARSET;
            break;
        case 0x404:
            //Chinese (Taiwan)
            byCharSet = CHINESEBIG5_CHARSET;
            break;
        case 0x804:
            //Chinese (PRC)
            byCharSet = GB2312_CHARSET;
            break;
        case 0x408:
            //Greek
            byCharSet = GREEK_CHARSET;
            break;
        case 0x40D:
            //Hebrew
            byCharSet = HEBREW_CHARSET;
            break;
        case 0x411:
            //Japanese
            byCharSet = SHIFTJIS_CHARSET;
            break;
        case 0x419:
            //Russian
            byCharSet = RUSSIAN_CHARSET;
            break;
        case 0x41E:
            //Thai
            byCharSet = THAI_CHARSET;
            break;
        case 0x41F:
            //Turkish
            byCharSet = TURKISH_CHARSET;
            break;
        default:
            byCharSet = ANSI_CHARSET;
            break;
        }
    }
    while (false);
    
    if (hOpenKey) {::RegCloseKey (hOpenKey);}

    SATracePrintf ("CSADataEntryCtrl using Character Set:%d", byCharSet);

    return (byCharSet);

}  // end of CSADataEntryCtrl::GetCharacterSet method

//++--------------------------------------------------------------
//
//  Function:   OnDraw
//
//  Synopsis:   This is the public method of CSADataEntryCtrl
//              which handles paint messages
//
//  Arguments:  ATL_DRAWINFO& di
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
HRESULT CSADataEntryCtrl::OnDraw(ATL_DRAWINFO& di)
{



    HFONT hOldFont;

    //
    // select this font
    //

    if (m_hFont)
    {
        hOldFont = (HFONT) ::SelectObject(di.hdcDraw, m_hFont);
    }


    //
    // get the drawing rectangle
    //
    RECT& rc = *(RECT*)di.prcBounds;

    WCHAR strTextValue[SADataEntryCtrlMaxSize+2];

    int iIndex = 0;
    int iDestIndex = 0;

    int iLength = wcslen(m_strTextValue);

    while (iIndex < m_lMaxSize)
    {
        if (iIndex == m_iPositionFocus)
        {
            strTextValue[iDestIndex] = '&';
            iDestIndex++;
        }
        strTextValue[iDestIndex] = m_strTextValue[iIndex];
        iDestIndex++;
        iIndex++;
    }
    strTextValue[iDestIndex] = 0;


    DrawText(
            di.hdcDraw,
            strTextValue,
            wcslen(strTextValue),
            &rc,
            DT_VCENTER|DT_LEFT
            );

    if (m_hFont)
    {
        SelectObject(di.hdcDraw, hOldFont);
    }
    

    return S_OK;

}// end of CSADataEntryCtrl::OnDraw method


//++--------------------------------------------------------------
//
//  Function:   OnKeyDown
//
//  Synopsis:   This is the public method of CSADataEntryCtrl
//              to handle keydown messages
//
//  Arguments:  windows message arguments
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
LRESULT CSADataEntryCtrl::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    //
    // notify the container about any key press
    //
    Fire_KeyPressed();

    //
    // Enter key received, notify the container
    //
    if (wParam == VK_RETURN)
    {
        Fire_DataEntered();
        return 0;
    }

    //
    // Escape key received, notify the container
    //
    if (wParam == VK_ESCAPE)
    {
        Fire_OperationCanceled();
        return 0;
    }

    if (wParam == VK_RIGHT)
    {
        m_iPositionFocus++;
        if (m_iPositionFocus >= m_lMaxSize)
        {
            m_iPositionFocus--;
            
        }
    }
    else if (wParam == VK_LEFT)
    {
        m_iPositionFocus--;
        if (m_iPositionFocus < 0)
        {
            m_iPositionFocus = 0;

        }
    }
    else if (wParam == VK_UP)
    {
        WCHAR * pwStrCurrentValue = NULL;
    
        pwStrCurrentValue = wcschr(m_szTextCharSet, m_strTextValue[m_iPositionFocus]);
        if (NULL ==    pwStrCurrentValue)
        {
            m_strTextValue[m_iPositionFocus] = m_szTextCharSet[0];
        }
        else 
        {
            pwStrCurrentValue++;

            if (*pwStrCurrentValue != NULL)
            {
                m_strTextValue[m_iPositionFocus] = m_szTextCharSet[pwStrCurrentValue-m_szTextCharSet];
            }
            else
            {
                m_strTextValue[m_iPositionFocus] = m_szTextCharSet[0];
            }
        }
    }
    else if (wParam == VK_DOWN)
    {

        WCHAR * pwStrCurrentValue = NULL;
    
        pwStrCurrentValue = wcschr(m_szTextCharSet, m_strTextValue[m_iPositionFocus]);
        if (NULL ==    pwStrCurrentValue)
        {
            m_strTextValue[m_iPositionFocus] = m_szTextCharSet[0];
        }
        else 
        {

            if (pwStrCurrentValue == m_szTextCharSet)
            {
                m_strTextValue[m_iPositionFocus] = m_szTextCharSet[wcslen(m_szTextCharSet)-1];
            }
            else
            {
                m_strTextValue[m_iPositionFocus] = m_szTextCharSet[pwStrCurrentValue-m_szTextCharSet-1];
            }
        }

    }


    FireViewChange();
    return 0;



}// end of CSADataEntryCtrl::OnKeyDown method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\ldm\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1EF25351_278B_4522_843F_E46B08644BEB__INCLUDED_)
#define AFX_STDAFX_H__1EF25351_278B_4522_843F_E46B08644BEB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#undef _ATL_NO_DEBUG_CRT
#include <atlbase.h>

#include "myservice.h"

extern CServiceModule _Module;

#include <atlcom.h>

#include <satrace.h>

#define wm_SaKeyMessage   WM_USER+1
#define wm_SaLocMessage   WM_USER+2
#define wm_SaLEDMessage   WM_USER+3
#define wm_SaAlertMessage WM_USER+4


typedef enum _sa_registrybitmap_state_
{
    BITMAP_STARTING         =   1,
    BITMAP_CHECKDISK        =  BITMAP_STARTING +1,
    BITMAP_READY            =  BITMAP_CHECKDISK +1,
    BITMAP_SHUTDOWN         =  BITMAP_READY +1, 
    BITMAP_UPDATE           =  BITMAP_SHUTDOWN +1

}   SA_REGISTRYBITMAP_STATE;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1EF25351_278B_4522_843F_E46B08644BEB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuictrl\localuicontrols.cpp ===
//#--------------------------------------------------------------
//
//  File:       localuicontrols.cpp
//
//  Synopsis:   This file holds the implmentation of the
//                of DLL Exports
//
//  History:     12/15/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f LocalUIControlsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "LocalUIControls.h"

#include "LocalUIControls_i.c"
#include "StaticIp.h"
#include "HostName.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_StaticIp, CStaticIp)
OBJECT_ENTRY(CLSID_SADataEntryCtrl, CSADataEntryCtrl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_LOCALUICONTROLSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuictrl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuictrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LocalUIControls.rc
//
#define IDS_PROJNAME                    100
#define IDR_STATICIP                    102
#define IDR_SADATAENTRYCTRL             104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuictrl\staticip.h ===
//#--------------------------------------------------------------
//
//  File:       staticip.cpp
//
//  Synopsis:   This file holds the declaration of the
//                of CStaticIp class
//
//  History:     12/15/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#ifndef __STATICIP_H_
#define __STATICIP_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "LocalUIControlsCP.h"
#include "salocmgr.h"
#include "satrace.h"

#define IpAddressSize 16
#define IPHASFOCUS 1
#define SUBNETHASFOCUS 2
#define GATEWAYHASFOCUS 3
#define LASTPOSITION 15
#define FIRSTPOSITION 1
#define NUMBEROFENTRIES 3

/////////////////////////////////////////////////////////////////////////////
// CStaticIp
class ATL_NO_VTABLE CStaticIp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IStaticIp, &IID_IStaticIp, &LIBID_LOCALUICONTROLSLib>,
    public CComControl<CStaticIp>,
    public IPersistStreamInitImpl<CStaticIp>,
    public IOleControlImpl<CStaticIp>,
    public IOleObjectImpl<CStaticIp>,
    public IOleInPlaceActiveObjectImpl<CStaticIp>,
    public IViewObjectExImpl<CStaticIp>,
    public IOleInPlaceObjectWindowlessImpl<CStaticIp>,
    public IConnectionPointContainerImpl<CStaticIp>,
    public IPersistStorageImpl<CStaticIp>,
    public ISpecifyPropertyPagesImpl<CStaticIp>,
    public IQuickActivateImpl<CStaticIp>,
    public IDataObjectImpl<CStaticIp>,
    public IProvideClassInfo2Impl<&CLSID_StaticIp, &DIID__IStaticIpEvents, &LIBID_LOCALUICONTROLSLib>,
    public IPropertyNotifySinkCP<CStaticIp>,
    public CComCoClass<CStaticIp, &CLSID_StaticIp>,
    public CProxy_IStaticIpEvents< CStaticIp >,
    public IObjectSafetyImpl<CStaticIp,INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
    CStaticIp()
    {
        wcscpy(m_strIpAddress,L"000.000.000.000");
        wcscpy(m_strSubnetMask,L"000.000.000.000");
        wcscpy(m_strGateway,L"000.000.000.000");
        m_iEntryFocus = IPHASFOCUS;
        m_iPositionFocus = 0;

        m_bstrIpHeader = L"";
        m_bstrSubnetHeader = L"";
        m_bstrDefaultGatewayHeader = L"";

        m_hFont = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_STATICIP)

DECLARE_PROTECT_FINAL_CONSTRUCT()

DECLARE_CLASSFACTORY_SINGLETON (CStaticIp)

BEGIN_COM_MAP(CStaticIp)
    COM_INTERFACE_ENTRY(IStaticIp)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CStaticIp)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CStaticIp)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    CONNECTION_POINT_ENTRY(DIID__IStaticIpEvents)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CStaticIp)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    CHAIN_MSG_MAP(CComControl<CStaticIp>)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IStaticIp
public:
    STDMETHOD(get_Gateway)
                        (
                        /*[out, retval]*/ BSTR *pVal
                        );

    STDMETHOD(put_Gateway)
                        (
                        /*[in]*/ BSTR newVal
                        );

    STDMETHOD(get_SubnetMask)
                        (
                        /*[out, retval]*/ BSTR *pVal
                        );

    STDMETHOD(put_SubnetMask)
                        (
                        /*[in]*/ BSTR newVal
                        );

    STDMETHOD(get_IpAddress)
                        (
                        /*[out, retval]*/ BSTR *pVal
                        );

    STDMETHOD(put_IpAddress)
                        (
                        /*[in]*/ BSTR newVal
                        );
// IObjectSafety
    STDMETHOD(SetInterfaceSafetyOptions)
                        (
                        REFIID riid, 
                        DWORD dwOptionSetMask, 
                        DWORD dwEnabledOptions
                        )
    {
        return S_OK;
    }

    //
    // called just after constructor, gets the localized strings and creates the font
    //
    STDMETHOD(FinalConstruct)(void);

    //
    // called just before destructor, releases resources
    //
    STDMETHOD(FinalRelease)(void);

    //
    // gets the current character set
    //
    BYTE GetCharacterSet ();


    HRESULT OnDraw
                (
                ATL_DRAWINFO& di
                );

    LRESULT OnKeyDown
                (
                UINT uMsg, 
                WPARAM wParam, 
                LPARAM lParam, 
                BOOL& bHandled
                );

    void ProcessArrowKey
                        (
                        WCHAR * strFocus,
                        WPARAM wParam
                        );

    void CreateFocusString
                        (
                        WCHAR * strFocus,
                        WCHAR * strEntry
                        );

    HRESULT FormatAndCopy
                        (
                        /*[in]*/BSTR bstrValue,
                        /*[in,out]*/ WCHAR *strValue
                        );

    HRESULT TrimDuplicateZerosAndCopy
                        (
                        /*[in]*/WCHAR *strValue,
                        /*[in,out]*/ BSTR *pNewVal
                        );
    

    WCHAR m_strIpAddress[IpAddressSize];
    WCHAR m_strSubnetMask[IpAddressSize];
    WCHAR m_strGateway[IpAddressSize];

    int m_iEntryFocus;
    int m_iPositionFocus;

    CComBSTR m_bstrIpHeader;
    CComBSTR m_bstrSubnetHeader;
    CComBSTR m_bstrDefaultGatewayHeader;

    HFONT m_hFont;

};

#endif //__STATICIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuiresource\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuictrl\localuicontrolscp.h ===
//#--------------------------------------------------------------
//
//  File:       localuicontrols.cpp
//
//  Synopsis:   This file holds the declaration and implmentation of the
//                of control events class
//
//  History:     12/15/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------


#ifndef _LOCALUICONTROLSCP_H_
#define _LOCALUICONTROLSCP_H_



template <class T>
class CProxy_ISADataEntryCtrlEvents : public IConnectionPointImpl<T, &DIID__ISADataEntryCtrlEvents, CComDynamicUnkArray>
{
    //Warning this class may be recreated by the wizard.
public:
    HRESULT Fire_DataEntered()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = nConnections-1; nConnectionIndex >= 0; nConnectionIndex--)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
                break;
            }
        }
        return varResult.scode;
    
    }

    HRESULT Fire_OperationCanceled()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = nConnections-1; nConnectionIndex >= 0; nConnectionIndex--)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
                break;
            }
        }
        return varResult.scode;
    
    }

    HRESULT Fire_KeyPressed()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = nConnections-1; nConnectionIndex >= 0; nConnectionIndex--)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
                break;
            }
        }
        return varResult.scode;
    
    }
};

template <class T>
class CProxy_IStaticIpEvents : public IConnectionPointImpl<T, &DIID__IStaticIpEvents, CComDynamicUnkArray>
{
    //Warning this class may be recreated by the wizard.
public:
    HRESULT Fire_StaticIpEntered()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = nConnections-1; nConnectionIndex >= 0; nConnectionIndex--)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
                break;
            }
        }
        return varResult.scode;
    
    }

    HRESULT Fire_OperationCanceled()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = nConnections-1; nConnectionIndex >= 0; nConnectionIndex--)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
                break;
            }
        }
        return varResult.scode;
    
    }

    HRESULT Fire_KeyPressed()
    {
        CComVariant varResult;
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();
        
        for (nConnectionIndex = nConnections-1; nConnectionIndex >= 0; nConnectionIndex--)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                VariantClear(&varResult);
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
                break;
            }
        }
        return varResult.scode;
    
    }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuiresource\localuiresource.cpp ===
//#--------------------------------------------------------------
//
//  File:       localuiresource.cpp
//
//  Synopsis:   This file holds the implementation of DLL
//                exports
//
//  History:     01/15/2001  serdarun Created
//
//    Copyright (C) 2000-2001 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f localuiresourceps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "localuiresource.h"

#include "localuiresource_i.c"
#include "ResCtrl.h"
#include "TextResCtrl.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ResCtrl, CResCtrl)
OBJECT_ENTRY(CLSID_TextResCtrl, CTextResCtrl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_LOCALUIRESOURCELib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuiresource\resctrl.h ===
//#--------------------------------------------------------------
//
//  File:       ResCtrl.h
//
//  Synopsis:   This file holds the declaration of the
//                of CResCtrl class
//
//  History:     01/15/2001  serdarun Created
//
//    Copyright (C) 2000-2001 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#ifndef __RESCTRL_H_
#define __RESCTRL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "Wbemidl.h"
#include "elementmgr.h"
#include "satrace.h"
#include "getvalue.h"
#include "mem.h"
#include <string>
#include <map>
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CResCtrl
class ATL_NO_VTABLE CResCtrl : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IResCtrl, &IID_IResCtrl, &LIBID_LOCALUIRESOURCELib>,
    public CComControl<CResCtrl>,
    public IOleControlImpl<CResCtrl>,
    public IOleObjectImpl<CResCtrl>,
    public IOleInPlaceActiveObjectImpl<CResCtrl>,
    public IViewObjectExImpl<CResCtrl>,
    public IOleInPlaceObjectWindowlessImpl<CResCtrl>,
    public CComCoClass<CResCtrl, &CLSID_ResCtrl>,
    public IWbemObjectSink
{
public:
    CResCtrl()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_RESCTRL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

DECLARE_CLASSFACTORY_SINGLETON (CResCtrl)

BEGIN_COM_MAP(CResCtrl)
    COM_INTERFACE_ENTRY(IResCtrl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IWbemObjectSink)
END_COM_MAP()

BEGIN_PROP_MAP(CResCtrl)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CResCtrl)
    CHAIN_MSG_MAP(CComControl<CResCtrl>)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IResCtrl
private:
    //
    // method for determining the resource dll directory
    //
    HRESULT GetResourceDirectory (
                                /*[out]*/   wstring&    wstrResourceDir
                                );

    HRESULT ExpandSz(IN const TCHAR *lpszStr, OUT LPTSTR *ppszStr);


    //
    // sets the language id
    //
    void SetLangID(DWORD * dwLangID);


    //
    // mapping of state and icon information for each resource
    //
    typedef map< LONG, HICON >  ResourceIconMap;
    typedef ResourceIconMap::iterator         ResourceIconMapIterator;

    //
    // struct for each localui resource
    //
    typedef struct
    {
        LONG lState;
        ResourceIconMap mapResIcon;
    } ResourceStruct,*ResourceStructPtr;

    //
    // mapping of resource name and  localui resource
    //
    typedef map< wstring, ResourceStructPtr >  ResourceMap;
    typedef ResourceMap::iterator         ResourceMapIterator;

    //
    // contains all of the localui resources
    //
    ResourceMap m_ResourceMap;

    //
    // mapping of resource names and their merits
    //
    typedef map< DWORD, wstring>  MeritMap;
    typedef MeritMap::iterator        MeritMapIterator;

    
    //
    // contains localui resource names and merits
    //
    MeritMap m_MeritMap;

    //
    // resource directory
    //
    wstring m_wstrResourceDir;

    //
    // number of localui resources
    //
    LONG m_lResourceCount;


    CComPtr  <IWbemServices> m_pWbemServices;


    //
    // method obtaining resource information from element manager
    //
    STDMETHOD(GetLocalUIResources)
                                (
                                void
                                );

    //
    // initializes wbem for localui resource events
    //
    STDMETHOD(InitializeWbemSink)
                                (
                                void
                                );

    //
    // loads icons for each resource web element
    //
    STDMETHOD(AddIconResource)
                            (
                            /*[in]*/IWebElement * pElement
                            );

    //
    // converts a hex digit to base 10 number
    //
    ULONG HexCharToULong(WCHAR wch);

    //
    // converts a hex string to unsigned long
    //
    ULONG HexStringToULong(wstring wsHexString);

public:

    //
    // called just after constructor, initializes the component
    //
    STDMETHOD(FinalConstruct)(void);

    //
    // called just before destructor, releases resources
    //
    STDMETHOD(FinalRelease)(void);

    //
    // ---------IWbemUnboundObjectSink interface methods----------
    //
    STDMETHOD(Indicate) (
                    /*[in]*/    LONG                lObjectCount,
                    /*[in]*/    IWbemClassObject    **ppObjArray
                    );
    
    STDMETHOD(SetStatus) (
                    /*[in]*/    LONG                lFlags,
                    /*[in]*/    HRESULT             hResult,
                    /*[in]*/    BSTR                strParam,
                    /*[in]*/    IWbemClassObject    *pObjParam
                    );


    //
    // draws the icons
    //
    HRESULT OnDraw(ATL_DRAWINFO& di);

};

#endif //__RESCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuiresource\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by localuiresource.rc
//
#define IDS_PROJNAME                    100
#define IDR_RESCTRL                     102
#define IDR_TEXTRESCTRL                 104
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuictrl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__FB2CE150_1B9D_43AF_B542_A538D972D8FA__INCLUDED_)
#define AFX_STDAFX_H__FB2CE150_1B9D_43AF_B542_A538D972D8FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__FB2CE150_1B9D_43AF_B542_A538D972D8FA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuictrl\staticip.cpp ===
//#--------------------------------------------------------------
//
//  File:       staticip.cpp
//
//  Synopsis:   This file holds the implmentation of the
//                of CStaticIp class
//
//  History:     12/15/2000  serdarun Created
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#include "stdafx.h"
#include "LocalUIControls.h"
#include "StaticIp.h"

///////////////////////////////////////////////////////////////////
// CStaticIp

//
// registry path for LCID value
//
const WCHAR LOCALIZATION_MANAGER_REGISTRY_PATH []  = 
        L"SOFTWARE\\Microsoft\\ServerAppliance\\LocalizationManager\\resources";


const WCHAR LANGID_VALUE [] = L"LANGID";



//++--------------------------------------------------------------
//
//  Function:   get_IpAddress
//
//  Synopsis:   This is the IStaticIp interface method 
//              through which ip address entry is retrieved
//
//  Arguments:  BSTR *pVal
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CStaticIp::get_IpAddress(BSTR *pVal)
{

    if (pVal == NULL)
    {
        return E_POINTER;
    }

    return TrimDuplicateZerosAndCopy(m_strIpAddress,pVal);

} // end of CStaticIp::get_IpAddress method

//++--------------------------------------------------------------
//
//  Function:   put_IpAddress
//
//  Synopsis:   This is the IStaticIp interface method 
//              through which ip address entry is set
//
//  Arguments:  BSTR newVal
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CStaticIp::put_IpAddress(BSTR newVal)
{
    
    HRESULT hr;

    if (newVal == NULL)
    {
        return E_POINTER;
    }


    hr = FormatAndCopy(newVal,m_strIpAddress);

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;

} // end of CStaticIp::put_IpAddress method

//++--------------------------------------------------------------
//
//  Function:   get_SubnetMask
//
//  Synopsis:   This is the IStaticIp interface method 
//              through which subnet mask entry is retrieved
//
//  Arguments:  BSTR *pVal
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CStaticIp::get_SubnetMask(BSTR *pVal)
{

    if (pVal == NULL)
    {
        return E_POINTER;
    }

    return TrimDuplicateZerosAndCopy(m_strSubnetMask,pVal);

} // end of CStaticIp::get_SubnetMask method

//++--------------------------------------------------------------
//
//  Function:   put_SubnetMask
//
//  Synopsis:   This is the IStaticIp interface method 
//              through which ip address entry is set
//
//  Arguments:  BSTR newVal
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CStaticIp::put_SubnetMask(BSTR newVal)
{

    HRESULT hr;

    if (newVal == NULL)
    {
        return E_POINTER;
    }


    hr = FormatAndCopy(newVal,m_strSubnetMask);

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;

}  // end of CStaticIp::put_SubnetMask method

//++--------------------------------------------------------------
//
//  Function:   get_Gateway
//
//  Synopsis:   This is the IStaticIp interface method 
//              through which gateway entry is retrieved
//
//  Arguments:  BSTR *pVal
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CStaticIp::get_Gateway(BSTR *pVal)
{

    if (pVal == NULL)
    {
        return E_POINTER;
    }

    return TrimDuplicateZerosAndCopy(m_strGateway,pVal);

}  // end of CStaticIp::get_SubnetMask method

//++--------------------------------------------------------------
//
//  Function:   put_Gateway
//
//  Synopsis:   This is the IStaticIp interface method 
//              through which ip address entry is set
//
//  Arguments:  BSTR newVal
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
STDMETHODIMP CStaticIp::put_Gateway(BSTR newVal)
{

    HRESULT hr;

    if (newVal == NULL)
    {
        return E_POINTER;
    }


    hr = FormatAndCopy(newVal,m_strGateway);

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;

} // end of CStaticIp::put_Gateway method

//++--------------------------------------------------------------
//
//  Function:   FormatAndCopy
//
//  Synopsis:   This is the public method of CStaticIp
//              to format and copy ip structure
//
//  Arguments:  BSTR bstrValue        "0.0.0.0"
//                WCHAR *strValue     "000.000.000.000"
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
HRESULT CStaticIp::FormatAndCopy(
                        /*[in]*/BSTR bstrValue,
                        /*[in,out]*/ WCHAR *strValue
                        )
{

    int iIndex = 0;
    int iDestIndex = 0;
    int iLength = 0;

    iLength = wcslen(bstrValue);

    if (iLength <= 0)
    {
        return E_INVALIDARG;
    }


    iIndex = iLength - 1;

    iDestIndex = IpAddressSize - 2;

    wcscpy(strValue,L"...............");

    //
    // Start copying from end of the string
    //
    while ( iDestIndex >= 0 )
    {

        //
        // If it is not '.' just copy
        //
        if ( (iIndex >= 0) && (bstrValue[iIndex] != '.') )
        {
            strValue[iDestIndex] = bstrValue[iIndex];
            iIndex--;
            iDestIndex--;
        }
        //
        // it is a '.', put zeros as necessary
        //
        else
        {
            while ( (iDestIndex % 4 != 3) && (iDestIndex >= 0) )
            {
                strValue[iDestIndex] = '0';
                iDestIndex--;
            }
            iDestIndex--;
            iIndex--;
        }
    }

    return S_OK;

} // end of CStaticIp::FormatAndCopy method


//++--------------------------------------------------------------
//
//  Function:   TrimDuplicateZerosAndCopy
//
//  Synopsis:   This is the public method of CStaticIp
//              to format and copy ip structure
//
//  Arguments:  WCHAR *strValue     "000.000.000.000"
//                BSTR *pNewVal          "0.0.0.0"
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
HRESULT CStaticIp::TrimDuplicateZerosAndCopy(
                        /*[in]*/WCHAR *strValue,
                        /*[in,out]*/ BSTR *pNewVal
                        )
{
    int iIndex = 0;
    WCHAR strNewValue[IpAddressSize];
    int iDestIndex = 0;


    while ( iIndex < IpAddressSize-2 )
    {
        //
        // Don't copy one of two adjacent zeros
        //
        if (strValue[iIndex] == '0')
        {
            //
            // first digit of the octet cannot be zero
            //
            if ((iIndex % 4) == 0)
            {
                iIndex++;
                continue;
            }

            //
            // second digit cannot be zero if first digit is zero
            //
            if ( ((iIndex % 4) == 1) && (strValue[iIndex-1] == '0') )
            {
                iIndex++;
                continue;

            }

        }

        strNewValue[iDestIndex] = strValue[iIndex];
        iDestIndex++;
        iIndex++;
    }

    strNewValue[iDestIndex] = strValue[iIndex];
    strNewValue[iDestIndex+1] = 0;

    *pNewVal = SysAllocString(strNewValue);

    if (*pNewVal)
    {
        return S_OK;
    }

    return E_OUTOFMEMORY;

} // end of CStaticIp::TrimDuplicateZerosAndCopy method



//++--------------------------------------------------------------
//
//  Function:   FinalConstruct
//
//  Synopsis:   This is the CStaticIp method to get the localized strings
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CStaticIp::FinalConstruct()
{

    HRESULT hr;

    //
    // resource id's for strings we are looking for
    //
    ULONG ulIpHeaderResourceID = 1073872921;
    ULONG ulSubnetHeaderResourceID = 1073872922;
    ULONG ulDefaultGatewayHeaderResourceID = 1073872923;

    CComBSTR bstrResourceFileName = CComBSTR(L"salocaluimsg.dll");

    if (bstrResourceFileName.m_str == NULL)
    {
        SATraceString("CStaticIp::FinalConstruct failed on memory allocation ");
        return E_OUTOFMEMORY;
    }

    const WCHAR LOCALIZATION_MANAGER[] = L"ServerAppliance.LocalizationManager";

    CLSID clsid;

    CComPtr<ISALocInfo> pSALocInfo = NULL;
    //
    // get the localized string names for headers, ip subnetmask and default gateway
    //

    //
    // get the CLSID localization manager
    //
    hr =  ::CLSIDFromProgID (
                            LOCALIZATION_MANAGER,
                            &clsid
                            );

    if (FAILED (hr))
    {
        SATracePrintf ("CStaticIp::FinalConstruct  failed on CLSIDFromProgID:%x",hr);
    }
    else
    {
        //
        // create the Localization Manager COM object
        //
        hr = ::CoCreateInstance (
                                clsid,
                                NULL,
                                CLSCTX_INPROC_SERVER,    
                                __uuidof (ISALocInfo),
                                (PVOID*) &pSALocInfo
                                );

        if (FAILED (hr))
        {
            SATracePrintf ("CStaticIp::FinalConstruct  failed on CoCreateInstance:%x",hr);
        }
        else
        {
            CComVariant varReplacementString;
            hr = pSALocInfo->GetString(
                                        bstrResourceFileName,
                                        ulIpHeaderResourceID,
                                        &varReplacementString,
                                        &m_bstrIpHeader
                                        );

            if (FAILED(hr))
            {
                SATracePrintf ("CStaticIp::FinalConstruct, failed on getting ip header %x :",hr);
            }

            hr = pSALocInfo->GetString(
                                        bstrResourceFileName,
                                        ulSubnetHeaderResourceID,
                                        &varReplacementString,
                                        &m_bstrSubnetHeader
                                        );

            if (FAILED(hr))
            {
                SATracePrintf ("CStaticIp::FinalConstruct, failed on getting subnet mask header, %x :",hr);
            }

            hr = pSALocInfo->GetString(
                                        bstrResourceFileName,
                                        ulDefaultGatewayHeaderResourceID,
                                        &varReplacementString,
                                        &m_bstrDefaultGatewayHeader
                                        );

            if (FAILED(hr))
            {
                SATracePrintf ("CStaticIp::FinalConstruct, failed on getting default gateway header, %x :",hr);
            }
        }
    }

    //
    // set the font now
    //
    LOGFONT logfnt;

    ::memset (&logfnt, 0, sizeof (logfnt));
    logfnt.lfOutPrecision = OUT_TT_PRECIS;
    logfnt.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    logfnt.lfQuality = PROOF_QUALITY;
    logfnt.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
    logfnt.lfHeight = 12;

    logfnt.lfCharSet = GetCharacterSet ();

    //
    // we chose the fontface for Japanese and let GDI
    // decide for the rest
    //
    if (SHIFTJIS_CHARSET == logfnt.lfCharSet) 
    {
        lstrcpy(logfnt.lfFaceName, TEXT("MS UI Gothic"));
    }
    else
    {
        lstrcpy(logfnt.lfFaceName, TEXT("Arial"));
    }

    m_hFont = ::CreateFontIndirect(&logfnt);

    return S_OK;

} // end of CStaticIp::FinalConstruct method


//++--------------------------------------------------------------
//
//  Function:   FinalRelease
//
//  Synopsis:   Called just after the destructor,
//              deletes the font
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     04/18/2001
//
//----------------------------------------------------------------
STDMETHODIMP CStaticIp::FinalRelease(void)
{
    if (m_hFont)
    {
        DeleteObject(m_hFont);
    }

    return S_OK;

}

//++--------------------------------------------------------------
//
//  Function:   GetCharacterSet
//
//  Synopsis:   This is method used to get the character set to use
//              for the FONTS
//  Arguments:  
//
//  Returns:    BYTE    - CharacterSet
//
//  History:    serdarun      Created     04/18/2001
//
//  Called By:  FinalConstruct method
//
//----------------------------------------------------------------
BYTE CStaticIp::GetCharacterSet ()
{
    HKEY hOpenKey = NULL;
    BYTE byCharSet = DEFAULT_CHARSET;

    do
    {
        DWORD dwLangId = 0;

        //
        // open the local machine registry
        //
        LONG lRetVal = ::RegOpenKeyEx (
                            HKEY_LOCAL_MACHINE,
                            LOCALIZATION_MANAGER_REGISTRY_PATH,
                            NULL,                   //reserved
                            KEY_QUERY_VALUE,
                            &hOpenKey
                            );
        if (ERROR_SUCCESS == lRetVal)
        {
            DWORD dwBufferSize = sizeof (dwLangId);
            //
            // get the LANGID now
            //
            lRetVal = ::RegQueryValueEx (
                                hOpenKey,
                                LANGID_VALUE,
                                NULL,                   //reserved
                                NULL,         
                                (LPBYTE) &dwLangId,
                                &dwBufferSize
                                );
            if (ERROR_SUCCESS == lRetVal)
            {
                SATracePrintf (
                    "CStaticIp got the language ID:%d",
                    dwLangId
                    );
            }
            else
            {
                SATraceFailure (
                    "CStaticIp unable to get language ID", 
                    GetLastError()
                    );
            }
        }
        else
        {
            SATraceFailure (
                "CStaticIp failed to open registry to get language id",
                 GetLastError());
        }

        switch (dwLangId)
        {
        case 0x401:
            // Arabic     
            byCharSet = ARABIC_CHARSET;
            break;
        case 0x404:
            //Chinese (Taiwan)
            byCharSet = CHINESEBIG5_CHARSET;
            break;
        case 0x804:
            //Chinese (PRC)
            byCharSet = GB2312_CHARSET;
            break;
        case 0x408:
            //Greek
            byCharSet = GREEK_CHARSET;
            break;
        case 0x40D:
            //Hebrew
            byCharSet = HEBREW_CHARSET;
            break;
        case 0x411:
            //Japanese
            byCharSet = SHIFTJIS_CHARSET;
            break;
        case 0x419:
            //Russian
            byCharSet = RUSSIAN_CHARSET;
            break;
        case 0x41E:
            //Thai
            byCharSet = THAI_CHARSET;
            break;
        case 0x41F:
            //Turkish
            byCharSet = TURKISH_CHARSET;
            break;
        default:
            byCharSet = ANSI_CHARSET;
            break;
        }
    }
    while (false);
    
    if (hOpenKey) {::RegCloseKey (hOpenKey);}

    SATracePrintf ("CStaticIp using Character Set:%d", byCharSet);

    return (byCharSet);

}  // end of CStaticIp::GetCharacterSet method

//++--------------------------------------------------------------
//
//  Function:   OnDraw
//
//  Synopsis:   This is the public method of CStaticIp
//              which handles paint messages
//
//  Arguments:  ATL_DRAWINFO& di
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
HRESULT CStaticIp::OnDraw(ATL_DRAWINFO& di)
{


    HFONT hOldFont = NULL;

    //
    // if we don't have a valid font, return failure
    //
    if (m_hFont == NULL)
    {
        return E_FAIL;
    }

    hOldFont = (HFONT) ::SelectObject(di.hdcDraw, m_hFont);

    RECT rectIp = {0,0,14,13};
    DrawText(
            di.hdcDraw,
            m_bstrIpHeader,
            wcslen(m_bstrIpHeader),
            &rectIp,
            DT_VCENTER|DT_LEFT
            );

    RECT rectSubnet = {0,13,128,26};
    DrawText(
            di.hdcDraw,
            m_bstrSubnetHeader,
            wcslen(m_bstrSubnetHeader),
            &rectSubnet,
            DT_VCENTER|DT_LEFT
            );
        
    RECT rectGateway = {0,39,128,52};
    DrawText(
            di.hdcDraw,
            m_bstrDefaultGatewayHeader,
            wcslen(m_bstrDefaultGatewayHeader),
            &rectGateway,
            DT_VCENTER|DT_LEFT
            );

        

    RECT rect;
    WCHAR strFocusEntry[17];

    rect.left = 14;
    rect.top = 0;
    rect.right = 128;
    rect.bottom = 13;

    if (m_iEntryFocus == IPHASFOCUS)
    {
        CreateFocusString(strFocusEntry,m_strIpAddress);
        DrawText(
                di.hdcDraw,
                strFocusEntry,
                wcslen(strFocusEntry),
                &rect,
                DT_VCENTER|DT_LEFT
                );
    }
    else
    {
        DrawText(
                di.hdcDraw,
                m_strIpAddress,
                wcslen(m_strIpAddress),
                &rect,
                DT_VCENTER|DT_LEFT
                );
    }
    rect.left = 0;
    rect.top = 26;
    rect.right = 128;
    rect.bottom = 39;

    if (m_iEntryFocus == SUBNETHASFOCUS)
    {
        CreateFocusString(strFocusEntry,m_strSubnetMask);
        DrawText(
                di.hdcDraw,
                strFocusEntry,
                wcslen(strFocusEntry),
                &rect,
                DT_VCENTER|DT_LEFT
                );
    }
    else
    {
        DrawText(
                di.hdcDraw,
                m_strSubnetMask,
                wcslen(m_strSubnetMask),
                &rect,
                DT_VCENTER|DT_LEFT
                );
    }

    rect.left = 0;
    rect.top = 52;
    rect.right = 128;
    rect.bottom = 64;

    if (m_iEntryFocus == GATEWAYHASFOCUS)
    {
        CreateFocusString(strFocusEntry,m_strGateway);
        DrawText(
                di.hdcDraw,
                strFocusEntry,
                wcslen(strFocusEntry),
                &rect,
                DT_VCENTER|DT_LEFT
                );
    }
    else
    {
        DrawText(
                di.hdcDraw,
                m_strGateway,
                wcslen(m_strGateway),
                &rect,
                DT_VCENTER|DT_LEFT
                );
    }
        
    
    SelectObject(di.hdcDraw,hOldFont);

    return S_OK;

}// end of CStaticIp::OnDraw method

//++--------------------------------------------------------------
//
//  Function:   OnKeyDown
//
//  Synopsis:   This is the public method of CStaticIp
//              to handle keydown messages
//
//  Arguments:  windows message arguments
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
LRESULT CStaticIp::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    WCHAR * strFocus;
    //
    // notify the container about any key press
    //
    Fire_KeyPressed();

    //
    // Enter key received, notify the container
    //
    if (wParam == VK_RETURN)
    {
        Fire_StaticIpEntered();
        return 0;
    }

    //
    // Escape key received, notify the container
    //
    if (wParam == VK_ESCAPE)
    {
        Fire_OperationCanceled();
        return 0;
    }

    if (wParam == VK_RIGHT)
    {
        m_iPositionFocus++;
        if (m_iPositionFocus >= LASTPOSITION)
        {
            m_iPositionFocus = 0;
            
            m_iEntryFocus++;

            if (m_iEntryFocus > NUMBEROFENTRIES)
            {
                m_iEntryFocus = IPHASFOCUS;
            }
        }
        //
        // '.' cannot have the focus
        //
        if ( (m_iPositionFocus % 4) == 3)
        {
            m_iPositionFocus++;
        }
    }
    else if (wParam == VK_LEFT)
    {
        m_iPositionFocus--;
        if (m_iPositionFocus < 0)
        {
            m_iPositionFocus = LASTPOSITION - 1;

            m_iEntryFocus--;

            if (m_iEntryFocus == 0)
            {
                m_iEntryFocus = GATEWAYHASFOCUS;
            }
        }
        //
        // '.' cannot have the focus
        //
        if ( (m_iPositionFocus % 4) == 3) 
        {
            m_iPositionFocus--;
        }
    }
    else if ( (wParam == VK_UP) || (wParam == VK_DOWN) )
    {
        if (m_iEntryFocus == IPHASFOCUS)
        {
            strFocus = m_strIpAddress;
        }
        else if (m_iEntryFocus == SUBNETHASFOCUS)
        {
            strFocus = m_strSubnetMask;
        }
        else
        {
            strFocus = m_strGateway;
        }

        ProcessArrowKey(strFocus,wParam);
    }


    FireViewChange();
    return 0;



}// end of CStaticIp::OnKeyDown method


//++--------------------------------------------------------------
//
//  Function:   ProcessArrowKey
//
//  Synopsis:   This is the public method of CStaticIp
//              to increment or decrement ip character
//
//  Arguments:  WCHAR * strFocus
//                WPARAM wParam
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
void CStaticIp::ProcessArrowKey(WCHAR * strFocus,WPARAM wParam)
{

    if (wParam == VK_UP)
        strFocus[m_iPositionFocus]++;
    else
        strFocus[m_iPositionFocus]--;

    //
    // third position from nearest . from left
    //
    if  ( (m_iPositionFocus % 4) == 2 )
    {
        //
        // cannot be smaller than '0'
        //
        if (strFocus[m_iPositionFocus] < '0')
        {
            //
            // if preceeded by 25 it must go to 5
            //
            if ( (strFocus[m_iPositionFocus-2] == '2') && (strFocus[m_iPositionFocus-1] == '5') )
            {
                strFocus[m_iPositionFocus] = '5';
            }
            //
            // it must be 9
            //
            else
            {
                strFocus[m_iPositionFocus] = '9';
            }
        }
        //
        // cannot be greater than '9'
        //
        else if (strFocus[m_iPositionFocus] > '9')
        {
            strFocus[m_iPositionFocus] = '0';
        }
        //
        // greater than '5' and proceeded by 25, it must go to '0'
        //
        else if (strFocus[m_iPositionFocus] > '5')
        {
            if ( (strFocus[m_iPositionFocus-2] == '2') && (strFocus[m_iPositionFocus-1] == '5') )
            {
                strFocus[m_iPositionFocus] = '0';
            }
        }

    }
    //
    // second position from nearest . from left
    //
    else if  ( (m_iPositionFocus % 4) == 1 )
    {
        //
        // cannot be smaller than '0'
        //
        if (strFocus[m_iPositionFocus] < '0')
        {
            //
            // if preceeded by 2 it must go to 5
            //
            if (strFocus[m_iPositionFocus-1] == '2') 
            {
                strFocus[m_iPositionFocus] = '5';

                //
                // if followed by something greater than '5',
                // change folowing value to 0
                //
                if (strFocus[m_iPositionFocus+1] > '5')
                {
                    strFocus[m_iPositionFocus+1] = '0';
                }

            }
            //
            // it must be 9
            //
            else
            {
                strFocus[m_iPositionFocus] = '9';
            }
        }
        //
        // cannot be greater than '9'
        //
        else if (strFocus[m_iPositionFocus] > '9')
        {
            strFocus[m_iPositionFocus] = '0';
        }
        //
        // greater than '5' and proceeded by 2, it must go to '0'
        //
        else if (strFocus[m_iPositionFocus] > '5')
        {
            if (strFocus[m_iPositionFocus-1] == '2')
            {
                strFocus[m_iPositionFocus] = '0';
            }
        }
        //
        // greater than '5' and proceeded by 2, third position cannot be higher than 5
        //
        else if (strFocus[m_iPositionFocus] == '5')
        {
            if ( (strFocus[m_iPositionFocus-1] == '2') && (strFocus[m_iPositionFocus+1] > '5') )
            {
                strFocus[m_iPositionFocus+1] = '0';
            }
        }

    }
    //
    // first position from nearest . from left
    //
    else
    {
        //
        // cannot be smaller than '0'
        //
        if (strFocus[m_iPositionFocus] < '0')
        {
            strFocus[m_iPositionFocus] = '2';
            //
            // if followed by something greater than '5',
            // change that value to '0'
            //
            if (strFocus[m_iPositionFocus+1] > '5') 
            {
                strFocus[m_iPositionFocus+1] = '0';
            }
            //
            // if followed by '5'check if third position is greater than '5',
            // if so, change that value to '0'
            //
            if (strFocus[m_iPositionFocus+1] == '5')
            {
                //
                // if followed by something greater than '5',
                // change folowing value to 0
                //
                if (strFocus[m_iPositionFocus+2] > '5')
                {
                    strFocus[m_iPositionFocus+2] = '0';
                }

            }
        }
        //
        // cannot be greater than '2'
        //
        else if  (strFocus[m_iPositionFocus] > '2')
        {
            strFocus[m_iPositionFocus] = '0';
        }
        else if  (strFocus[m_iPositionFocus] == '2')
        {
            //
            // if followed by something greater than '5',
            // change that value to '0'
            //
            if (strFocus[m_iPositionFocus+1] > '5') 
            {
                strFocus[m_iPositionFocus+1] = '0';
            }
            //
            // if followed by '5'check if third position is greater than '5',
            // if so, change that value to '0'
            //
            else if (strFocus[m_iPositionFocus+1] == '5')
            {
                //
                // if followed by something greater than '5',
                // change folowing value to 0
                //
                if (strFocus[m_iPositionFocus+2] > '5')
                {
                    strFocus[m_iPositionFocus+2] = '0';
                }

            }
        }
    }




}// end of CStaticIp::ProcessArrowKey method


//++--------------------------------------------------------------
//
//  Function:   CreateFocusString
//
//  Synopsis:   This is the public method of CStaticIp
//              to create string with an underscore indicating focus
//
//  Arguments:  WCHAR * strFocus
//                WCHAR * strEntry
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/15/2000
//
//----------------------------------------------------------------
void CStaticIp::CreateFocusString(WCHAR * strFocus,WCHAR * strEntry)
{
    int iDestIndex = 0;
    int iIndex = 0;

    while (iIndex < LASTPOSITION)
    {
        if (iIndex == m_iPositionFocus)
        {
            strFocus[iDestIndex] = '&';
            iDestIndex++;
        }
        strFocus[iDestIndex] = strEntry[iIndex];
        iDestIndex++;
        iIndex++;
    }

    strFocus[iDestIndex] = 0;

}// end of CStaticIp::CreateFocusString method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuiresource\resctrl.cpp ===
//#--------------------------------------------------------------
//
//  File:       ResCtrl.cpp
//
//  Synopsis:   This file holds the implementation of the
//                of CResCtrl class
//
//  History:     01/15/2001  serdarun Created
//
//    Copyright (C) 2000-2001 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#include "stdafx.h"
#include "Localuiresource.h"
#include "ResCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CResCtrl

//
// currently supports at most 7 resources due LCD size
//
#define MAX_RESOURCE_COUNT 7

const WCHAR ELEMENT_RETRIEVER []  = L"Elementmgr.ElementRetriever";
const WCHAR RESOURCE_CONTAINER [] = L"LocalUIResource";

//
// localui resource definition properties
//
const WCHAR CAPTION_PROPERTY []        = L"CaptionRID";
const WCHAR SOURCE_PROPERTY []        = L"Source";
const WCHAR RESOURCENAME_PROPERTY []= L"ResourceName";
const WCHAR MERIT_PROPERTY []        = L"Merit";
const WCHAR STATE_PROPERTY []        = L"State";
const WCHAR TEXTRESOURCE_PROPERTY [] = L"IsTextResource";
const WCHAR UNIQUE_NAME []           = L"UniqueName";
const WCHAR DISPLAY_INFORMATION []   = L"DisplayInformationID";

//
// registry path where the resource information is stored
//
const WCHAR RESOURCE_REGISTRY_PATH [] = 
            L"SOFTWARE\\Microsoft\\ServerAppliance\\LocalizationManager\\Resources";

//
// language ID value
//
const WCHAR LANGID_VALUE [] = L"LANGID";

//
// resource directory 
//
const WCHAR RESOURCE_DIRECTORY [] = L"ResourceDirectory";

const WCHAR DEFAULT_DIRECTORY [] = 
                L"%systemroot%\\system32\\ServerAppliance\\mui";

const WCHAR DEFAULT_EXPANDED_DIRECTORY [] = 
                L"C:\\winnt\\system32\\ServerAppliance\\mui";

const WCHAR DELIMITER [] = L"\\";

const WCHAR NEW_LANGID_VALUE []       = L"NewLANGID";

const WCHAR DEFAULT_LANGID[]          = L"0409";


//++--------------------------------------------------------------
//
//  Function:   AddIconResource
//
//  Synopsis:   This is the CResCtrl method to retrieve 
//              each resource information
//
//  Arguments:  IWebElement * pElement
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CResCtrl::AddIconResource(IWebElement * pElement)
{

    HRESULT hr;

    USES_CONVERSION;

    CComVariant varUniqueName;
    wstring wsUniqueName;
    wstring wsSource;
    wstring wsIcon;
    wstring wsIconKey;
    DWORD  dwMerit;
    ResourceStructPtr pResourceStruct = NULL;

    CComBSTR bstrResourceName = CComBSTR(RESOURCENAME_PROPERTY);
    CComBSTR bstrSourceProp = CComBSTR(SOURCE_PROPERTY);
    CComBSTR bstrMeritProp = CComBSTR(MERIT_PROPERTY);
    CComBSTR bstrCaptionProp = CComBSTR(CAPTION_PROPERTY);

    if ( (bstrResourceName.m_str == NULL) ||
         (bstrSourceProp.m_str == NULL) ||
         (bstrMeritProp.m_str == NULL) ||
         (bstrCaptionProp.m_str == NULL) )
    {
        SATraceString("CResCtrl::AddIconResource failed on memory allocation ");
        return E_OUTOFMEMORY;
    }

    //
    // get the unique name for the resource
    //
    hr = pElement->GetProperty (bstrResourceName, &varUniqueName);
    if (FAILED(hr))
    {
        SATraceString ("CResCtrl::AddIconResource failed on getting uniquename");
        return hr;
    }

    //
    // store the unique name for later use
    //
    wsUniqueName = V_BSTR (&varUniqueName);

    //
    // get the resource dll for the resource
    //
    CComVariant varSource;
    hr = pElement->GetProperty (bstrSourceProp, &varSource);
    if (FAILED(hr))
    {
        SATraceString ("CResCtrl::AddIconResource failed on getting resource dll");
        return hr;
    }

    wsSource.assign(m_wstrResourceDir);
    wsSource.append(V_BSTR (&varSource));

    //
    // load the resource dll
    //
    HINSTANCE hInstance = NULL;

    hInstance = LoadLibrary(wsSource.c_str());

    if (NULL == hInstance)
    {
        DWORD dwError = GetLastError();
        SATracePrintf ("CResCtrl::AddIconResource failed on LoadLibrary:%x",dwError);
        return E_FAIL;
    }

    //
    // allocate a new struct for the resource
    //
    pResourceStruct = new ResourceStruct;

    if (NULL == pResourceStruct)
    {
        FreeLibrary(hInstance);
        return E_OUTOFMEMORY;
    }

    //
    // set default values
    //
    pResourceStruct->lState = 0;

    //
    // get the merit for resource
    //
    CComVariant varResMerit;
    hr = pElement->GetProperty (bstrMeritProp, &varResMerit);
    if (FAILED(hr))
    {
        SATraceString ("CResCtrl::AddIconResource failed on getting merit");
        FreeLibrary(hInstance);
        return hr;
    }
    
    dwMerit = V_I4 (&varResMerit);

    //
    // get the default icon resource id
    //
    CComVariant varResIcon;
    hr = pElement->GetProperty (bstrCaptionProp, &varResIcon);
    if (FAILED(hr))
    {
        SATraceString ("CResCtrl::AddIconResource failed on getting captionrid");
        FreeLibrary(hInstance);
        return hr;
    }

    int iCount = 0;
    //
    // icon resource string
    //
    wsIcon = V_BSTR (&varResIcon);

    //
    // while there are state icons
    //
    while (SUCCEEDED(hr))
    {
        
        HANDLE hIcon = NULL;

        //
        // load the icon from resource dll
        //
        hIcon = ::LoadImage (
                        hInstance,
                        MAKEINTRESOURCE(HexStringToULong(wsIcon)),
                        IMAGE_ICON,
                        16,
                        16,
                        LR_MONOCHROME
                        );


        if (NULL == hIcon)
        {
            SATraceString ("Loading the icon failed, continue...");
        }

        //
        // insert the icon to state-icon map
        //
        (pResourceStruct->mapResIcon).insert(ResourceIconMap::value_type(iCount,(HICON)hIcon));

        //
        // create statekey, state0, state1...
        //
        iCount++;
        WCHAR wstrCount[10];
        _itow(iCount,wstrCount,10);

        wsIconKey = L"State";
        wsIconKey.append(wstring(wstrCount));

        CComBSTR bstrIconKey = CComBSTR(wsIconKey.c_str());
        if (bstrIconKey.m_str == NULL)
        {
            SATraceString(" CTextResCtrl::AddTextResource failed on memory allocation ");
            return E_OUTOFMEMORY;
        }

        varResIcon.Clear();
        //
        // get the resource id for state icon
        //
        hr = pElement->GetProperty (bstrIconKey, &varResIcon);
        if (SUCCEEDED(hr))
        {
            wsIcon = V_BSTR (&varResIcon);
        }
        
    }

    //
    // increment the number of resources
    //
    m_lResourceCount++;

    //
    // insert the info to the resource map
    //
    m_ResourceMap.insert(ResourceMap::value_type(wsUniqueName,pResourceStruct));


    

    //
    // insert merit and resource name to merit map
    //
    m_MeritMap.insert(MeritMap::value_type(dwMerit,wsUniqueName));


    FreeLibrary(hInstance);

    return S_OK;
}// end of CResCtrl::AddIconResource


//++--------------------------------------------------------------
//
//  Function:   GetLocalUIResources
//
//  Synopsis:   This is the CResCtrl method to retrieve 
//              each resource from element manager
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CResCtrl::GetLocalUIResources()
{

    HRESULT hr;
    CLSID clsid;
    CComPtr<IWebElementRetriever> pWebElementRetriever = NULL;
    CComPtr<IDispatch> pDispatch = NULL;
    CComPtr<IWebElementEnum> pWebElementEnum = NULL;
    CComPtr<IUnknown> pUnknown = NULL;
    CComPtr<IEnumVARIANT> pEnumVariant = NULL;
    CComVariant varElement;
    DWORD dwElementsLeft = 0;

    CComBSTR bstrTextResource = CComBSTR(TEXTRESOURCE_PROPERTY);
    CComBSTR bstrResourceContainer = CComBSTR(RESOURCE_CONTAINER);

    if ( (bstrTextResource.m_str == NULL) ||
         (bstrResourceContainer.m_str == NULL) )
    {
        SATraceString(" CResCtrl::GetLocalUIResources failed on memory allocation ");
        return E_OUTOFMEMORY;
    }

    //
    // get the resource directory 
    //
    hr = GetResourceDirectory(m_wstrResourceDir);
    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on GetResourceDirectory:%x",hr);
        return hr;
    }

    //
    // get the CLSID for Element manager
    //
    hr =  ::CLSIDFromProgID (ELEMENT_RETRIEVER,&clsid);

    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on CLSIDFromProgID:%x",hr);
        return hr;
    }


    //
    // create the Element Retriever now
    //
    hr = ::CoCreateInstance (
                            clsid,
                            NULL,
                            CLSCTX_LOCAL_SERVER,
                            IID_IWebElementRetriever,
                            (PVOID*) &pWebElementRetriever
                            );

    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on CoCreateInstance:%x",hr);
        return hr;
    }
    

    //
    // get localui resource elements
    //  
    hr = pWebElementRetriever->GetElements (
                                            1,
                                            bstrResourceContainer,
                                            &pDispatch
                                            );
    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on GetElements:%x",hr);
        return hr;
    }

    //
    //  get the enum variant
    //
    hr = pDispatch->QueryInterface (
            IID_IWebElementEnum,
            (LPVOID*) (&pWebElementEnum)
            );

    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on QueryInterface:%x",hr);
        return hr;
    }

    m_lResourceCount = 0;

    //
    // get number of resource elements
    //
    hr = pWebElementEnum->get_Count (&m_lResourceCount);
    
    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on get_Count:%x",hr);
        return hr;
    }

    SATracePrintf ("CResCtrl::GetLocalUIResources failed on QueryInterface:%d",m_lResourceCount);

    //
    // no resources, just return
    //
    if (0 == m_lResourceCount)
    {
        return S_FALSE;
    }


    hr = pWebElementEnum->get__NewEnum (&pUnknown);
    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on get__NewEnum:%x",hr);
        return hr;
    }


    //
    //  get the enum variant
    //
    hr = pUnknown->QueryInterface (
                    IID_IEnumVARIANT,
                    (LPVOID*)(&pEnumVariant)
                    );

    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on QueryInterface:%x",hr);
        return hr;
    }

    //
    //  get elements out of the collection and initialize
    //
    hr = pEnumVariant->Next (1, &varElement, &dwElementsLeft);
    if (FAILED (hr))
    {
        SATracePrintf ("CResCtrl::GetLocalUIResources failed on Next:%x",hr);
    }

    m_lResourceCount = 0;

    //
    // for each resource
    //
    while ((dwElementsLeft> 0) && (SUCCEEDED (hr)) && (m_lResourceCount<MAX_RESOURCE_COUNT))
    {

        //
        // get the IWebElement Interface
        //

        CComPtr <IWebElement> pElement;
        hr = varElement.pdispVal->QueryInterface ( 
                    __uuidof (IWebElement),
                    (LPVOID*)(&pElement)
                    );
        
        if (FAILED (hr))
        {
            SATracePrintf ("CResCtrl::GetLocalUIResources failed on QueryInterface:%x",hr);
        }



        //
        // check if it is a text resource
        //
        CComVariant varIsTextResource;
        hr = pElement->GetProperty (bstrTextResource, &varIsTextResource);
        if (SUCCEEDED(hr))
        {
            if (0 == V_I4(&varIsTextResource))
            {
                AddIconResource(pElement);
            }
        }


        //
        //  clear the perClient value from this variant
        //
        varElement.Clear ();
        varIsTextResource.Clear();

        //
        //  get next client out of the collection
        //
        hr = pEnumVariant->Next (1, &varElement, &dwElementsLeft);
        if (FAILED (hr))
        {
            SATracePrintf ("CResCtrl::GetLocalUIResources failed on Next:%x",hr);
        }


    }
    
    return S_OK;

} // end of CResCtrl::GetLocalUIResources

//++--------------------------------------------------------------
//
//  Function:   InitializeWbemSink
//
//  Synopsis:   This is the CResCtrl method to initialize the 
//                component
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CResCtrl::InitializeWbemSink(void)
{

    CComPtr  <IWbemLocator> pWbemLocator;

    CComBSTR strNetworkRes = CComBSTR(_T("\\\\.\\ROOT\\CIMV2"));
    CComBSTR strQueryLang = CComBSTR(_T("WQL"));
    CComBSTR strQueryString = CComBSTR(_T("select * from Microsoft_SA_ResourceEvent"));

    if ( (strNetworkRes.m_str == NULL) ||
         (strQueryLang.m_str == NULL) ||
         (strQueryString.m_str == NULL) )
    {
        SATraceString(" CResCtrl::InitializeWbemSink failed on memory allocation ");
        return E_OUTOFMEMORY;
    }

    //
    // create the WBEM locator object  
    //
    HRESULT hr = ::CoCreateInstance (
                            __uuidof (WbemLocator),
                            0,                      //aggregation pointer
                            CLSCTX_INPROC_SERVER,
                            __uuidof (IWbemLocator),
                            (PVOID*) &pWbemLocator
                            );

    if (SUCCEEDED (hr) && (pWbemLocator.p))
    {

        //
        // connect to WMI 
        // 
        hr =  pWbemLocator->ConnectServer (
                                            strNetworkRes,
                                            NULL,               //user-name
                                            NULL,               //password
                                            NULL,               //current-locale
                                            0,                  //reserved
                                            NULL,               //authority
                                            NULL,               //context
                                            &m_pWbemServices
                                            );
        if (SUCCEEDED (hr))
        {
            //
            // set up the consumer object as the event sync
            // for the object type we are interested in
            //
            hr = m_pWbemServices->ExecNotificationQueryAsync (
                                            strQueryLang,
                                            strQueryString,
                                            0,                  //no-status
                                            NULL,               //status
                                            (IWbemObjectSink*)(this)
                                            );
            if (FAILED (hr))
            {
                SATracePrintf ("CResCtrl::InitializeWbemSink failed on ExecNotificationQueryAsync:%x",hr);

            }
    
        }
        else
        {
            SATracePrintf ("CResCtrl::InitializeWbemSink failed on ConnectServer:%x",hr);
        }
    }
    else
    {
        SATracePrintf ("CResCtrl::InitializeWbemSink failed on CoCreateInstance:%x",hr);
    }
    

    return (hr);
} // end of CResCtrl::InitializeWbemSink method

//++--------------------------------------------------------------
//
//  Function:   FinalConstruct
//
//  Synopsis:   This is the CResCtrl method to initialize the 
//                component
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CResCtrl::FinalConstruct()
{

    HRESULT hr;

    //
    // initialize the variables
    //
    m_ResourceMap.clear();
    m_MeritMap.clear();
    m_lResourceCount = 0;
    m_pWbemServices = NULL;

    //
    // get the local resources
    //
    hr = GetLocalUIResources();
    if (FAILED(hr))
    {
        SATracePrintf ("CResCtrl::FinalConstruct failed on GetLocalUIResources:%x",hr);
    }

    //
    // register in the wbem sink, if we have any resources
    //
    if (m_lResourceCount > 0)
    {
        hr = InitializeWbemSink();
        if (FAILED(hr))
        {
            SATracePrintf ("CResCtrl::FinalConstruct failed on InitializeWbemSink:%x",hr);
            //
            // returning failure cause component to be destroyed
            //
            return S_OK;
        }
    }
    return S_OK;

} // end of CResCtrl::FinalConstruct method

//++--------------------------------------------------------------
//
//  Function:   FinalRelease
//
//  Synopsis:   This is the CResCtrl method to release the 
//                resources
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CResCtrl::FinalRelease()
{

    HRESULT hr;

    //
    // cancel the call for wmi resource events
    //
    if (m_pWbemServices)
    {
        hr =  m_pWbemServices->CancelAsyncCall ((IWbemObjectSink*)(this));
        if (FAILED (hr))
        {
            SATracePrintf ("CResCtrl::FinalRelease failed on-CancelAsyncCall failed with error:%x:",hr); 
        }
    }


    if (m_lResourceCount == 0)
    {
        return S_OK;
    }

    //
    // release all of the icons if we have any resources
    //

    ResourceStructPtr ptrResourceStruct = NULL;

    ResourceIconMapIterator itrIconMap;

    ResourceMapIterator itrResourceMap = m_ResourceMap.begin();

    //
    // for each resource element
    //
    while (itrResourceMap != m_ResourceMap.end())
    {
        ptrResourceStruct = NULL;

        //
        // get resource information struct
        //
        ptrResourceStruct = (*itrResourceMap).second;

        //
        // get the icon map
        //
        itrIconMap = (ptrResourceStruct->mapResIcon).begin();

        while (itrIconMap != (ptrResourceStruct->mapResIcon).end())
        {
            DestroyIcon((*itrIconMap).second);
            itrIconMap++;
        }

        //
        //
        //clear the icon map
        (ptrResourceStruct->mapResIcon).clear();

        itrResourceMap++;
    }

    m_ResourceMap.clear();

    return S_OK;

} // end of CResCtrl::FinalRelease method

//++--------------------------------------------------------------
//
//  Function:   Indicate
//
//  Synopsis:   This is the IWbemObjectSink interface method 
//              through which WBEM calls back to provide the 
//              event objects
//
//  Arguments:  
//              [in]    LONG               -  number of events
//              [in]    IWbemClassObject** -  array of events
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/10/2000
//
//  Called By:  WBEM 
//
//----------------------------------------------------------------
STDMETHODIMP CResCtrl::Indicate (
                    /*[in]*/    LONG                lObjectCount,
                    /*[in]*/    IWbemClassObject    **ppObjArray
                    )
{

    wstring wsUniqueName = L"";
    BOOL bDirty = FALSE;
    ResourceMapIterator itrResourceMap = NULL;

    CComBSTR bstrUniqueName = CComBSTR(UNIQUE_NAME);
    CComBSTR bstrDisplayInfo = CComBSTR(DISPLAY_INFORMATION);

    if ( (bstrUniqueName.m_str == NULL) ||
         (bstrDisplayInfo.m_str == NULL) )
    {
        SATraceString(" CResCtrl::Indicate failed on memory allocation ");
        return WBEM_NO_ERROR;
    }

    // Get the info from the object.
    // =============================
    try
    {
        for (long i = 0; i < lObjectCount; i++)
        {

            itrResourceMap = NULL;

            IWbemClassObject *pObj = ppObjArray[i];
        
            //
            // get the unique name
            //
            CComVariant vUniqueName;
            pObj->Get(bstrUniqueName, 0, &vUniqueName, 0, 0);
            
            wsUniqueName = V_BSTR(&vUniqueName);
            
            // 
            // If here, we know the object is one of the kind we asked for.
            //
            itrResourceMap = m_ResourceMap.find(wsUniqueName);

            ResourceStructPtr ptrResourceStruct = NULL;


            if ( (itrResourceMap != NULL) )
            {
                ptrResourceStruct = (*itrResourceMap).second;

                //
                // get the new display state
                //
                CComVariant vDisplayInformationID;
                pObj->Get(bstrDisplayInfo, 0, &vDisplayInformationID,    0, 0);

                if (ptrResourceStruct)
                {
                    //
                    // if new state is different set dirty flag
                    //
                    if (ptrResourceStruct->lState != vDisplayInformationID.lVal)
                    {
                        ptrResourceStruct->lState = vDisplayInformationID.lVal;
                        bDirty = TRUE;
                    }
                }
                
            }        

        }

        //
        // force a repaint
        //
        if (bDirty)
        {
            FireViewChange();
        }
    }
    catch(...)
    {
        SATraceString("CResCtrl::Indicate, unknown exception occured");
    }


    return WBEM_NO_ERROR;

} // end of CResCtrl::Indicate method



//++--------------------------------------------------------------
//    
//  Function:   SetStatus
//
//  Synopsis:   This is the IWbemObjectSink interface method 
//              through which WBEM calls in to indicate end of
//              event sequence or provide other error codes
//
//  Arguments:  
//              [in]    LONG    -           progress 
//              [in]    HRESULT -           status information
//              [in]    BSTR    -           string info
//              [in]    IWbemClassObject* - status object 
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/10/2000
//
//  Called By:  WBEM 
//
//----------------------------------------------------------------
STDMETHODIMP CResCtrl::SetStatus (
                /*[in]*/    LONG                lFlags,
                /*[in]*/    HRESULT             hResult,
                /*[in]*/    BSTR                strParam,
                /*[in]*/    IWbemClassObject    *pObjParam
                )
{   

    SATracePrintf ("SAConsumer-IWbemObjectSink::SetStatus called:%x",hResult);

    return (WBEM_S_NO_ERROR);

} // end of CResCtrl::SetStatus method


//++--------------------------------------------------------------
//    
//  Function:   OnDraw
//
//  Synopsis:   Method used to draw the icons
//
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/10/2000
//
//----------------------------------------------------------------
HRESULT CResCtrl::OnDraw(ATL_DRAWINFO& di)
{
    //
    // get the drawing rectangle
    //
    RECT& rc = *(RECT*)di.prcBounds;

    //
    // position of the icon from left
    //
    int iLeft = 0;

    ResourceStructPtr ptrResourceStruct = NULL;

    ResourceIconMapIterator itrIconMap = NULL;

    //
    // iterator for resource
    //
    ResourceMapIterator itrResourceMap = m_ResourceMap.end();

    MeritMapIterator itrMeritMap = m_MeritMap.begin();

    //
    // for each resource in merit map
    //
    while (itrMeritMap != m_MeritMap.end())
    {
        //
        // find the resource in resource map
        //
        itrResourceMap = m_ResourceMap.find((*itrMeritMap).second);

        //
        // if it is not in the map, continue with the next item
        //
        if (itrResourceMap == m_ResourceMap.end())
        {
            itrMeritMap++;
            continue;
        }

        ptrResourceStruct = NULL;

        //
        // get resource information struct
        //
        ptrResourceStruct = (*itrResourceMap).second;

        if (NULL != ptrResourceStruct)
        {
            //
            // find the icon corresponding to the state
            //
            itrIconMap = (ptrResourceStruct->mapResIcon).find(ptrResourceStruct->lState);

            if (itrIconMap != (ptrResourceStruct->mapResIcon).end())
            {
                //
                // calculate the position and draw
                //
                DrawIconEx(
                        di.hdcDraw,                            // handle to device context
                        rc.left+iLeft,                        // x-coord of upper left corner
                        rc.top,                                // y-coord of upper left corner
                        (*itrIconMap).second,               // handle to icon
                        0,                                    // icon width
                        0,                                    // icon height
                        0,                                    // frame index, animated cursor
                        NULL,                                // handle to background brush
                        DI_NORMAL                            // icon-drawing flags
                        );
            }
        }
        itrMeritMap++;
        iLeft = iLeft + 16;
    }

    return S_OK;

}  // end of CResCtrl::OnDraw method




//++--------------------------------------------------------------
//
//  Function:   ExpandSz
//
//  Synopsis:   This is the CResCtrl class object method
//              used to get the directory where the resource dlls are
//              present
//
//  Arguments:  [out]    wstring&    -   directory path
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/16/2001
//
//----------------------------------------------------------------
HRESULT CResCtrl::ExpandSz(IN const TCHAR *lpszStr, OUT LPTSTR *ppszStr)
{
    DWORD  dwBufSize = 0;

    _ASSERT(lpszStr);
    _ASSERT(ppszStr);
    _ASSERT(NULL==(*ppszStr));

    if ((NULL==lpszStr) || (NULL==ppszStr) ||
        (NULL != (*ppszStr)))
    {
        return E_INVALIDARG;
    }

    dwBufSize = ExpandEnvironmentStrings(lpszStr,
                                        (*ppszStr),
                                        dwBufSize);
    _ASSERT(0 != dwBufSize);
    (*ppszStr) = (LPTSTR)SaAlloc(dwBufSize * sizeof(TCHAR) );
    if (NULL == (*ppszStr))
    {
        SATraceString("MemAlloc failed in ExpandSz");
        return E_OUTOFMEMORY;
    }
    ExpandEnvironmentStrings(lpszStr,
                            (*ppszStr),
                            dwBufSize);
    SATracePrintf("Expanded string is \'%ws\'", (*ppszStr));
    return S_OK;

} // end of CResCtrl::ExpandSz method


//++--------------------------------------------------------------
//
//  Function:   SetLangID
//
//  Synopsis:   This is the CResCtrl class object method
//              used to set the language id
//
//  Arguments:  [out]    DOWRD*   -   language id
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/16/2001
//
//----------------------------------------------------------------
void CResCtrl::SetLangID(DWORD * dwLangID)
{
    DWORD   dwErr, dwNewLangID, dwCurLangID;
    CRegKey crKey;
    int iConversion;
    

    iConversion = swscanf(DEFAULT_LANGID, TEXT("%X"), dwLangID);
    if (iConversion != 1)
    {
        *dwLangID = 0;
        return;
    }

    dwErr = crKey.Open(HKEY_LOCAL_MACHINE, RESOURCE_REGISTRY_PATH);
    if (dwErr != ERROR_SUCCESS)
    {
        SATracePrintf("RegOpen(2) failed %ld in SetLangID", dwErr);
        return;
    }

    dwCurLangID = 0;
    dwErr = crKey.QueryValue(dwCurLangID, LANGID_VALUE);
    if (ERROR_SUCCESS != dwErr)
    {
        SATracePrintf("QueryValue(CUR_LANGID_VALUE) failed %ld in SetLangID", dwErr);
        return;
    }
    else
    {
        *dwLangID = dwCurLangID;

    }
} // end of CResCtrl::SetLangID method

//++--------------------------------------------------------------
//
//  Function:   GetResourceDirectory
//
//  Synopsis:   This is the CResCtrl class object method
//              used to get the directory where the resource dlls are
//              present
//
//  Arguments:  [out]    wstring&    -   directory path
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/16/2001
//
//----------------------------------------------------------------
HRESULT CResCtrl::GetResourceDirectory (
        /*[out]*/   wstring&    wstrResourceDir
        )
{

    TCHAR  szLangId[10];
    LPTSTR lpszExStr=NULL;
    DWORD dwErr;
    DWORD dwRead = 0;
    HRESULT hr = S_OK;
    TCHAR szResourceDirectory[MAX_PATH];
    BOOL bRetVal = FALSE;

    DWORD dwLangID;

    do
    {

        //
        // get the language id from registry
        //
        SetLangID(&dwLangID);

        CComVariant vtPath;
        //
        // get the resource path from the registry
        //
        CRegKey crKey;

        dwErr = crKey.Open(HKEY_LOCAL_MACHINE, RESOURCE_REGISTRY_PATH);
        
        if (dwErr != ERROR_SUCCESS)
        {
            SATracePrintf("RegOpen failed %ld in GetResourceDirectory", dwErr);
        }
        else
        {
            dwErr = crKey.QueryValue(szResourceDirectory, RESOURCE_DIRECTORY,&dwRead);
            if ( (ERROR_SUCCESS != dwErr) || (dwRead == 0) )
            {
                SATracePrintf("QueryValue(RESOURCE_DIRECTORY) failed %ld in GetResourceDirectory", dwErr);
            }
            else
            {
                bRetVal = TRUE;
            }
        }

        if (!bRetVal)
        {
            SATraceString ("CResCtrl::GetResourceDirectory unable to obtain resource dir path");
            wstrResourceDir.assign (DEFAULT_DIRECTORY);
        }
        else
        {
            wstrResourceDir.assign (szResourceDirectory); 
        }

        hr = ExpandSz(wstrResourceDir.data(), &lpszExStr);

        if (FAILED(hr))
        {
            wstrResourceDir.assign (DEFAULT_EXPANDED_DIRECTORY);
        }
        else
        {
            wstrResourceDir.assign(lpszExStr);
            SaFree(lpszExStr);
            lpszExStr = NULL;
        }

        wstrResourceDir.append (DELIMITER);

        wsprintf(szLangId, TEXT("%04X"), dwLangID);

        wstrResourceDir.append (szLangId);
        wstrResourceDir.append (DELIMITER);
        
        SATracePrintf ("CResCtrl::GetResourceDirectory has set LANGID to:%d", dwLangID);


        //
        // success
        //
        SATracePrintf ("CResCtrl::GetResourceDirectory determined resource directory:'%ws'",wstrResourceDir.data ());
            
    }
    while (false);

    return (hr);

}   //  end of CResCtrl::GetResourceDirectory method

//++--------------------------------------------------------------
//    
//  Function:   HexCharToULong
//
//  Synopsis:   converts a hex digit to base 10 number
//
//
//  Returns:    ULONG
//
//  History:    serdarun      Created     12/10/2000
//
//----------------------------------------------------------------
ULONG CResCtrl::HexCharToULong(WCHAR wch)
{
    
    if ((wch >= '0') && (wch <= '9') )
    {
        return ULONG(wch - '0');
    }
    
    if ((wch >= 'A') && (wch <= 'F') )
    {
        return ULONG(wch - 'A' + 10);
    }

    if ((wch >= 'a') && (wch <= 'f') )
    {
        return ULONG(wch - 'a' + 10);
    }

    return 0;
}


//++--------------------------------------------------------------
//    
//  Function:   HexStringToULong
//
//  Synopsis:   converts a hex string to unsigned long
//
//
//  Returns:    ULONG
//
//  History:    serdarun      Created     12/10/2000
//
//----------------------------------------------------------------
ULONG CResCtrl::HexStringToULong(wstring wsHexString)
{
    int iLength;
    int iIndex = 0;
    ULONG ulResult = 0;

    iLength = wsHexString.size();

    while (iIndex < iLength)
    {
        ulResult *= 16;
        ulResult += HexCharToULong(wsHexString[iIndex]);
        iIndex++;
    }

    return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuiresource\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7B2039B7_B55A_4061_B652_DECF5B3F05A8__INCLUDED_)
#define AFX_STDAFX_H__7B2039B7_B55A_4061_B652_DECF5B3F05A8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7B2039B7_B55A_4061_B652_DECF5B3F05A8__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\resources\resource.h ===
#define IDI_DISKIDLE                     201
#define IDI_DISKACTIVE                   202
#define IDI_LANIDLE                      203
#define IDI_LANACTIVE                    204
#define IDI_LANERROR                     205
#define IDI_READYSTATE                   206
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuiresource\textresctrl.cpp ===
//#--------------------------------------------------------------
//
//  File:       TextResCtrl.cpp
//
//  Synopsis:   This file holds the implementation of the
//                of CTextResCtrl class
//
//  History:     01/15/2001  serdarun Created
//
//    Copyright (C) 2000-2001 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#include "stdafx.h"
#include "Localuiresource.h"
#include "TextResCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CTextResCtrl

//
// currently supports at most 3 resources due LCD size
//
#define MAX_RESOURCE_COUNT 3

const WCHAR ELEMENT_RETRIEVER []  = L"Elementmgr.ElementRetriever";
const WCHAR LOCALIZATION_MANAGER [] = L"ServerAppliance.LocalizationManager";
const WCHAR RESOURCE_CONTAINER [] = L"LocalUIResource";

//
// localui resource definition properties
//
const WCHAR CAPTION_PROPERTY []      = L"CaptionRID";
const WCHAR SOURCE_PROPERTY []       = L"Source";
const WCHAR RESOURCENAME_PROPERTY [] = L"ResourceName";
const WCHAR MERIT_PROPERTY []        = L"Merit";
const WCHAR STATE_PROPERTY []        = L"State";
const WCHAR TEXTRESOURCE_PROPERTY [] = L"IsTextResource";
const WCHAR UNIQUE_NAME []           = L"UniqueName";
const WCHAR DISPLAY_INFORMATION []   = L"DisplayInformationID";



//++--------------------------------------------------------------
//
//  Function:   AddTextResource
//
//  Synopsis:   This is the CTextResCtrl method to retrieve 
//              each resource information
//
//  Arguments:  IWebElement * pElement
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CTextResCtrl::AddTextResource(IWebElement * pElement)
{

    HRESULT hr;

    USES_CONVERSION;

    CComVariant varUniqueName;
    wstring wsUniqueName;
    wstring wsTextKey;
    DWORD  dwMerit;

    CComBSTR bstrResourceName = CComBSTR(RESOURCENAME_PROPERTY);
    CComBSTR bstrSourceProp = CComBSTR(SOURCE_PROPERTY);
    CComBSTR bstrMeritProp = CComBSTR(MERIT_PROPERTY);
    CComBSTR bstrCaptionProp = CComBSTR(CAPTION_PROPERTY);

    if ( (bstrResourceName.m_str == NULL) ||
         (bstrSourceProp.m_str == NULL) ||
         (bstrMeritProp.m_str == NULL) ||
         (bstrCaptionProp.m_str == NULL) )
    {
        SATraceString(" CTextResCtrl::AddTextResource failed on memory allocation ");
        return E_OUTOFMEMORY;
    }
    ResourceStructPtr pResourceStruct = NULL;

    //
    // get the unique name for the resource
    //
    hr = pElement->GetProperty (bstrResourceName, &varUniqueName);
    if (FAILED(hr))
    {
        SATraceString ("CTextResCtrl::AddTextResource failed on getting uniquename");
        return hr;
    }

    //
    // store the unique name for later use
    //
    wsUniqueName = V_BSTR (&varUniqueName);


    //
    // get the resource dll for the resource
    //
    CComVariant varSource;
    hr = pElement->GetProperty (bstrSourceProp, &varSource);
    if (FAILED(hr))
    {
        SATraceString ("CTextResCtrl::AddTextResource failed on getting resource dll");
        return hr;
    }

    //
    // allocate a new struct for the resource
    //
    pResourceStruct = new ResourceStruct;

    if (NULL == pResourceStruct)
    {
        return E_OUTOFMEMORY;
    }

    //
    // set default values
    //
    pResourceStruct->lState = 0;

    //
    // get the merit for resource
    //
    CComVariant varResMerit;
    hr = pElement->GetProperty (bstrMeritProp, &varResMerit);
    if (FAILED(hr))
    {
        SATraceString ("CTextResCtrl::AddTextResource failed on getting merit");
        return hr;
    }
    
    dwMerit = V_I4 (&varResMerit);

    //
    // get the default icon resource id
    //
    CComVariant varResText;
    hr = pElement->GetProperty (bstrCaptionProp, &varResText);
    if (FAILED(hr))
    {
        SATraceString ("CTextResCtrl::AddTextResource failed on getting captionrid");
        return hr;
    }

    int iCount = 0;

    //
    // while there are state texts
    //
    while (SUCCEEDED(hr))
    {

        CComBSTR pszValue;
        CComVariant varReplacementString;
        hr = m_pSALocInfo->GetString(
                                    V_BSTR (&varSource),
                                    HexStringToULong(wstring(V_BSTR (&varResText))),
                                    &varReplacementString,
                                    &pszValue
                                    );

        if (FAILED(hr))
        {
            SATracePrintf ("CTextResCtrl::AddTextResource, Loading the text failed, %x :",hr);
            break;
        }

        //
        // insert the icon to state-icon map
        //
        (pResourceStruct->mapResText).insert(ResourceTextMap::value_type(iCount,wstring(pszValue.m_str)));

        //
        // create statekey, state0, state1...
        //
        iCount++;
        WCHAR wstrCount[10];
        _itow(iCount,wstrCount,10);

        wsTextKey = L"State";
        wsTextKey.append(wstring(wstrCount));

        varResText.Clear();

        CComBSTR bstrTextKey = CComBSTR(wsTextKey.c_str());
        if (bstrTextKey.m_str == NULL)
        {
            SATraceString(" CTextResCtrl::AddTextResource failed on memory allocation ");
            return E_OUTOFMEMORY;
        }

        //
        // get the resource id for state icon
        //
        hr = pElement->GetProperty (bstrTextKey, &varResText);
        if (FAILED(hr))
        {
            break;
        }
        
    }

    //
    // increment the number of resources
    //
    m_lResourceCount++;

    //
    // insert the info to the resource map
    //
    m_ResourceMap.insert(ResourceMap::value_type(wsUniqueName,pResourceStruct));

    //
    // insert merit and resource name to merit map
    //
    m_MeritMap.insert(MeritMap::value_type(dwMerit,wsUniqueName));



    return S_OK;

}// end of CTextResCtrl::AddTextResource


//++--------------------------------------------------------------
//
//  Function:   GetLocalUIResources
//
//  Synopsis:   This is the CTextResCtrl method to retrieve 
//              each resource from element manager
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CTextResCtrl::GetLocalUIResources()
{

    HRESULT hr;
    CLSID clsid;
    CComPtr<IWebElementRetriever> pWebElementRetriever = NULL;
    CComPtr<IDispatch> pDispatch = NULL;
    CComPtr<IWebElementEnum> pWebElementEnum = NULL;
    CComPtr<IUnknown> pUnknown = NULL;
    CComPtr<IEnumVARIANT> pEnumVariant = NULL;
    CComVariant varElement;
    DWORD dwElementsLeft = 0;

    CComBSTR bstrTextResource = CComBSTR(TEXTRESOURCE_PROPERTY);
    CComBSTR bstrResourceContainer = CComBSTR(RESOURCE_CONTAINER);

    if ( (bstrTextResource.m_str == NULL) ||
         (bstrResourceContainer.m_str == NULL) )
    {
        SATraceString(" CTextResCtrl::GetLocalUIResources failed on memory allocation ");
        return E_OUTOFMEMORY;
    }

    //
    // get the CLSID for Element manager
    //
    hr =  ::CLSIDFromProgID (ELEMENT_RETRIEVER,&clsid);

    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on CLSIDFromProgID:%x",hr);
        return hr;
    }


    //
    // create the Element Retriever now
    //
    hr = ::CoCreateInstance (
                            clsid,
                            NULL,
                            CLSCTX_LOCAL_SERVER,
                            IID_IWebElementRetriever,
                            (PVOID*) &pWebElementRetriever
                            );

    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on CoCreateInstance:%x",hr);
        return hr;
    }
    

    //
    // get the CLSID localization manager
    //
    hr =  ::CLSIDFromProgID (
                            LOCALIZATION_MANAGER,
                            &clsid
                            );

    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on CLSIDFromProgID:%x",hr);
        return hr;
    }
            
    //
    // create the Localization Manager COM object
    //
    hr = ::CoCreateInstance (
                            clsid,
                            NULL,
                            CLSCTX_INPROC_SERVER,    
                            __uuidof (ISALocInfo),
                            (PVOID*) &m_pSALocInfo
                            );

    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on CoCreateInstance:%x",hr);
        return hr;
    }
    //
    // get localui resource elements
    //  
    hr = pWebElementRetriever->GetElements (
                                            1,
                                            bstrResourceContainer,
                                            &pDispatch
                                            );
    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on GetElements:%x",hr);
        return hr;
    }

    //
    //  get the enum variant
    //
    hr = pDispatch->QueryInterface (
            IID_IWebElementEnum,
            (LPVOID*) (&pWebElementEnum)
            );

    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on QueryInterface:%x",hr);
        return hr;
    }

    m_lResourceCount = 0;

    //
    // get number of resource elements
    //
    hr = pWebElementEnum->get_Count (&m_lResourceCount);
    
    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on get_Count:%x",hr);
        return hr;
    }

    SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on QueryInterface:%d",m_lResourceCount);

    //
    // no resources, just return
    //
    if (0 == m_lResourceCount)
    {
        return S_FALSE;
    }


    hr = pWebElementEnum->get__NewEnum (&pUnknown);
    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on get__NewEnum:%x",hr);
        return hr;
    }


    //
    //  get the enum variant
    //
    hr = pUnknown->QueryInterface (
                    IID_IEnumVARIANT,
                    (LPVOID*)(&pEnumVariant)
                    );

    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on QueryInterface:%x",hr);
        return hr;
    }

    //
    //  get elements out of the collection and initialize
    //
    hr = pEnumVariant->Next (1, &varElement, &dwElementsLeft);
    if (FAILED (hr))
    {
        SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on Next:%x",hr);
    }

    m_lResourceCount = 0;

    //
    // for each resource
    //
    while ((dwElementsLeft> 0) && (SUCCEEDED (hr)) && (m_lResourceCount < MAX_RESOURCE_COUNT))
    {

        //
        // get the IWebElement Interface
        //

        CComPtr <IWebElement> pElement;
        hr = varElement.pdispVal->QueryInterface ( 
                    __uuidof (IWebElement),
                    (LPVOID*)(&pElement)
                    );
        
        if (FAILED (hr))
        {
            SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on QueryInterface:%x",hr);
        }



        //
        // check if it is a text resource
        //
        CComVariant varIsTextResource;
        hr = pElement->GetProperty (bstrTextResource, &varIsTextResource);
        if (SUCCEEDED(hr))
        {
            if (0 != V_I4(&varIsTextResource))
            {
                AddTextResource(pElement);
            }
        }


        //
        //  clear the perClient value from this variant
        //
        varElement.Clear ();
        varIsTextResource.Clear();

        //
        //  get next client out of the collection
        //
        hr = pEnumVariant->Next (1, &varElement, &dwElementsLeft);
        if (FAILED (hr))
        {
            SATracePrintf ("CTextResCtrl::GetLocalUIResources failed on Next:%x",hr);
        }


    }
    
    return S_OK;

} // end of CTextResCtrl::GetLocalUIResources

//++--------------------------------------------------------------
//
//  Function:   InitializeWbemSink
//
//  Synopsis:   This is the CTextResCtrl method to initialize the 
//                component
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CTextResCtrl::InitializeWbemSink(void)
{

    CComPtr  <IWbemLocator> pWbemLocator;

    CComBSTR strNetworkRes = CComBSTR(_T("\\\\.\\ROOT\\CIMV2"));
    CComBSTR strQueryLang = CComBSTR(_T("WQL"));
    CComBSTR strQueryString = CComBSTR(_T("select * from Microsoft_SA_ResourceEvent"));

    if ( (strNetworkRes.m_str == NULL) ||
         (strQueryLang.m_str == NULL) ||
         (strQueryString.m_str == NULL) )
    {
        SATraceString(" CTextResCtrl::InitializeWbemSink failed on memory allocation ");
        return E_OUTOFMEMORY;
    }

    //
    // create the WBEM locator object  
    //
    HRESULT hr = ::CoCreateInstance (
                            __uuidof (WbemLocator),
                            0,                      //aggregation pointer
                            CLSCTX_INPROC_SERVER,
                            __uuidof (IWbemLocator),
                            (PVOID*) &pWbemLocator
                            );

    if (SUCCEEDED (hr) && (pWbemLocator.p))
    {


        //
        // connect to WMI 
        // 
        hr =  pWbemLocator->ConnectServer (
                                            strNetworkRes,
                                            NULL,               //user-name
                                            NULL,               //password
                                            NULL,               //current-locale
                                            0,                  //reserved
                                            NULL,               //authority
                                            NULL,               //context
                                            &m_pWbemServices
                                            );
        if (SUCCEEDED (hr))
        {
            //
            // set up the consumer object as the event sync
            // for the object type we are interested in
            //
            hr = m_pWbemServices->ExecNotificationQueryAsync (
                                            strQueryLang,
                                            strQueryString,
                                            0,                  //no-status
                                            NULL,               //status
                                            (IWbemObjectSink*)(this)
                                            );
            if (FAILED (hr))
            {
                SATracePrintf ("CTextResCtrl::InitializeWbemSink failed on ExecNotificationQueryAsync:%x",hr);

            }
    
        }
        else
        {
            SATracePrintf ("CTextResCtrl::InitializeWbemSink failed on ConnectServer:%x",hr);
        }
    }
    else
    {
        SATracePrintf ("CTextResCtrl::InitializeWbemSink failed on CoCreateInstance:%x",hr);
    }
    

    return (hr);
} // end of CTextResCtrl::InitializeWbemSink method

//++--------------------------------------------------------------
//
//  Function:   FinalConstruct
//
//  Synopsis:   This is the CTextResCtrl method to initialize the 
//                component
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CTextResCtrl::FinalConstruct()
{

    HRESULT hr;

    //
    // initialize the variables
    //
    m_ResourceMap.clear();
    m_MeritMap.clear();
    m_lResourceCount = 0;
    m_pWbemServices = NULL;
    m_pSALocInfo = NULL;
    //
    // get the local resources
    //
    hr = GetLocalUIResources();
    if (FAILED(hr))
    {
        SATracePrintf ("CTextResCtrl::FinalConstruct failed on GetLocalUIResources:%x",hr);
    }

    //
    // register in the wbem sink, if we have any resources
    //
    if (m_lResourceCount > 0)
    {
        hr = InitializeWbemSink();
        if (FAILED(hr))
        {
            SATracePrintf ("CTextResCtrl::FinalConstruct failed on InitializeWbemSink:%x",hr);
            //
            // returning failure cause component to be destroyed
            //
            return S_OK;
        }
    }
    return S_OK;

} // end of CTextResCtrl::FinalConstruct method

//++--------------------------------------------------------------
//
//  Function:   FinalRelease
//
//  Synopsis:   This is the CTextResCtrl method to release the 
//                resources
//
//  Arguments:  none
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     01/01/2001
//
//----------------------------------------------------------------
STDMETHODIMP CTextResCtrl::FinalRelease()
{

    HRESULT hr;

    //
    // cancel the call for wmi resource events
    //
    if (m_pWbemServices)
    {
        hr =  m_pWbemServices->CancelAsyncCall ((IWbemObjectSink*)(this));
        if (FAILED (hr))
        {
            SATracePrintf ("CTextResCtrl::FinalRelease failed on-CancelAsyncCall failed with error:%x:",hr); 
        }
    }

    m_pWbemServices = NULL;
    m_pSALocInfo = NULL;


    ResourceStructPtr ptrResourceStruct = NULL;

    ResourceMapIterator itrResourceMap = m_ResourceMap.begin();

    //
    // for each resource element
    //
    while (itrResourceMap != m_ResourceMap.end())
    {
        ptrResourceStruct = NULL;

        //
        // get resource information struct
        //
        ptrResourceStruct = (*itrResourceMap).second;

        //
        // delete the text map
        //
        (ptrResourceStruct->mapResText).clear();


        itrResourceMap++;
    }

    m_ResourceMap.clear();

    return S_OK;

} // end of CTextResCtrl::FinalRelease method

//++--------------------------------------------------------------
//
//  Function:   Indicate
//
//  Synopsis:   This is the IWbemObjectSink interface method 
//              through which WBEM calls back to provide the 
//              event objects
//
//  Arguments:  
//              [in]    LONG               -  number of events
//              [in]    IWbemClassObject** -  array of events
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/10/2000
//
//  Called By:  WBEM 
//
//----------------------------------------------------------------
STDMETHODIMP CTextResCtrl::Indicate (
                    /*[in]*/    LONG                lObjectCount,
                    /*[in]*/    IWbemClassObject    **ppObjArray
                    )
{

    wstring wsUniqueName = L"";
    BOOL bDirty = FALSE;
    ResourceMapIterator itrResourceMap = NULL;

    CComBSTR bstrUniqueName = CComBSTR(UNIQUE_NAME);
    CComBSTR bstrDisplayInfo = CComBSTR(DISPLAY_INFORMATION);

    if ( (bstrUniqueName.m_str == NULL) ||
         (bstrDisplayInfo.m_str == NULL) )
    {
        SATraceString(" CTextResCtrl::Indicate failed on memory allocation ");
        return WBEM_NO_ERROR;
    }

    // Get the info from the object.
    // =============================
    
    try
    {
        for (long i = 0; i < lObjectCount; i++)
        {

            itrResourceMap = NULL;

            IWbemClassObject *pObj = ppObjArray[i];
        
            //
            // get the unique name
            //
            CComVariant vUniqueName;
            pObj->Get(bstrUniqueName, 0, &vUniqueName, 0, 0);
            
            wsUniqueName = V_BSTR(&vUniqueName);
            
            // 
            // If here, we know the object is one of the kind we asked for.
            //
            itrResourceMap = m_ResourceMap.find(wsUniqueName);

            ResourceStructPtr ptrResourceStruct = NULL;


            if ( (itrResourceMap != NULL) )
            {
                ptrResourceStruct = (*itrResourceMap).second;

                //
                // get the new display state
                //
                CComVariant vDisplayInformationID;
                pObj->Get(bstrDisplayInfo, 0, &vDisplayInformationID,    0, 0);

                if (ptrResourceStruct)
                {
                    //
                    // if new state is different set dirty flag
                    //
                    if (ptrResourceStruct->lState != vDisplayInformationID.lVal)
                    {
                        ptrResourceStruct->lState = vDisplayInformationID.lVal;
                        bDirty = TRUE;
                    }
                }
                
            }        

        }

        //
        // force a repaint
        //
        if (bDirty)
        {
            FireViewChange();
        }
    }
    catch(...)
    {
        SATraceString("CTextResCtrl::Indicate, unknown exception occured");
    }

    return WBEM_NO_ERROR;

} // end of CTextResCtrl::Indicate method



//++--------------------------------------------------------------
//    
//  Function:   SetStatus
//
//  Synopsis:   This is the IWbemObjectSink interface method 
//              through which WBEM calls in to indicate end of
//              event sequence or provide other error codes
//
//  Arguments:  
//              [in]    LONG    -           progress 
//              [in]    HRESULT -           status information
//              [in]    BSTR    -           string info
//              [in]    IWbemClassObject* - status object 
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/10/2000
//
//  Called By:  WBEM 
//
//----------------------------------------------------------------
STDMETHODIMP CTextResCtrl::SetStatus (
                /*[in]*/    LONG                lFlags,
                /*[in]*/    HRESULT             hResult,
                /*[in]*/    BSTR                strParam,
                /*[in]*/    IWbemClassObject    *pObjParam
                )
{   

    SATracePrintf ("SAConsumer-IWbemObjectSink::SetStatus called:%x",hResult);

    return (WBEM_S_NO_ERROR);

} // end of CTextResCtrl::SetStatus method


//++--------------------------------------------------------------
//    
//  Function:   OnDraw
//
//  Synopsis:   Method used to draw the icons
//
//
//  Returns:    HRESULT - success/failure
//
//  History:    serdarun      Created     12/10/2000
//
//----------------------------------------------------------------
HRESULT CTextResCtrl::OnDraw(ATL_DRAWINFO& di)
{


    LOGFONT logfnt;

    ::memset (&logfnt, 0, sizeof (logfnt));
    logfnt.lfHeight = 13;

    logfnt.lfCharSet = DEFAULT_CHARSET;

    //
    // let GDI decide which font to use
    //  depending on the setting above
    //
    lstrcpy(logfnt.lfFaceName, TEXT("Arial"));

    
    HFONT hFont = ::CreateFontIndirect(&logfnt);

    //
    // if we cannot create font, return
    //
    if (NULL == hFont)
    {
        return E_FAIL;
    }

    //
    // select this font
    //
    HFONT hOldFont = (HFONT) ::SelectObject(di.hdcDraw, hFont);

    //
    // get the drawing rectangle
    //
    RECT& rc = *(RECT*)di.prcBounds;

    //
    // position of the text from top
    //
    int iTop = 0;

    ResourceStructPtr ptrResourceStruct = NULL;

    ResourceTextMapIterator itrTextMap = NULL;

    //
    // iterator for resource
    //
    ResourceMapIterator itrResourceMap = m_ResourceMap.end();

    MeritMapIterator itrMeritMap = m_MeritMap.begin();

    //
    // for each resource in merit map
    //
    while (itrMeritMap != m_MeritMap.end())
    {
        //
        // find the resource in resource map
        //
        itrResourceMap = m_ResourceMap.find((*itrMeritMap).second);

        //
        // if it is not in the map, continue with the next item
        //
        if (itrResourceMap == m_ResourceMap.end())
        {
            itrMeritMap++;
            continue;
        }

        ptrResourceStruct = NULL;

        //
        // get resource information struct
        //
        ptrResourceStruct = (*itrResourceMap).second;

        if (NULL != ptrResourceStruct)
        {
            //
            // find the icon corresponding to the state
            //
            itrTextMap = (ptrResourceStruct->mapResText).find(ptrResourceStruct->lState);

            if (itrTextMap != (ptrResourceStruct->mapResText).end())
            {

                RECT rectHeader = {rc.left,rc.top + iTop,rc.right ,rc.top + iTop + 12};
                DrawText(
                        di.hdcDraw,
                        ((*itrTextMap).second).c_str(),
                        wcslen(((*itrTextMap).second).c_str()),
                        &rectHeader,
                        DT_VCENTER|DT_LEFT
                        );


            }
        }
        itrMeritMap++;
        iTop = iTop + 12;
    }

    DeleteObject(SelectObject(di.hdcDraw,hOldFont));

    return S_OK;

}  // end of CTextResCtrl::OnDraw method


//++--------------------------------------------------------------
//    
//  Function:   HexCharToULong
//
//  Synopsis:   converts a hex digit to base 10 number
//
//
//  Returns:    ULONG
//
//  History:    serdarun      Created     12/10/2000
//
//----------------------------------------------------------------
ULONG CTextResCtrl::HexCharToULong(WCHAR wch)
{

    if ((wch >= '0') && (wch <= '9') )
    {
        return ULONG(wch - '0');
    }
    
    if ((wch >= 'A') && (wch <= 'F') )
    {
        return ULONG(wch - 'A' + 10);
    }
    
    if ((wch >= 'a') && (wch <= 'f') )
    {
        return ULONG(wch - 'a' + 10);
    }

    return 0;
}


//++--------------------------------------------------------------
//    
//  Function:   HexStringToULong
//
//  Synopsis:   converts a hex string to unsigned long
//
//
//  Returns:    ULONG
//
//  History:    serdarun      Created     12/10/2000
//
//----------------------------------------------------------------
ULONG CTextResCtrl::HexStringToULong(wstring wsHexString)
{
    int iLength;
    int iIndex = 0;
    ULONG ulResult = 0;

    iLength = wsHexString.size();

    while (iIndex < iLength)
    {
        ulResult *= 16;
        ulResult += HexCharToULong(wsHexString[iIndex]);
        iIndex++;
    }

    return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\localui\localuiresource\textresctrl.h ===
//#--------------------------------------------------------------
//
//  File:       TextResCtrl.h
//
//  Synopsis:   This file holds the declaration of the
//                of CTextResCtrl class
//
//  History:     01/15/2001  serdarun Created
//
//    Copyright (C) 2000-2001 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------

#ifndef __TEXTRESCTRL_H_
#define __TEXTRESCTRL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include "Wbemidl.h"
#include "elementmgr.h"
#include "salocmgr.h"
#include "satrace.h"
#include "getvalue.h"
#include "mem.h"
#include <string>
#include <map>
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CResCtrl
class ATL_NO_VTABLE CTextResCtrl : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ITextResCtrl, &IID_ITextResCtrl, &LIBID_LOCALUIRESOURCELib>,
    public CComControl<CTextResCtrl>,
    public IOleControlImpl<CTextResCtrl>,
    public IOleObjectImpl<CTextResCtrl>,
    public IOleInPlaceActiveObjectImpl<CTextResCtrl>,
    public IViewObjectExImpl<CTextResCtrl>,
    public IOleInPlaceObjectWindowlessImpl<CTextResCtrl>,
    public CComCoClass<CTextResCtrl, &CLSID_TextResCtrl>,
    public IWbemObjectSink
{
public:
    CTextResCtrl()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_TEXTRESCTRL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

DECLARE_CLASSFACTORY_SINGLETON (CTextResCtrl)

BEGIN_COM_MAP(CTextResCtrl)
    COM_INTERFACE_ENTRY(ITextResCtrl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IWbemObjectSink)
END_COM_MAP()

BEGIN_PROP_MAP(CTextResCtrl)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CTextResCtrl)
    CHAIN_MSG_MAP(CComControl<CTextResCtrl>)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

private:


    //
    // mapping of state and icon information for each resource
    //
    typedef map< LONG, wstring >  ResourceTextMap;
    typedef ResourceTextMap::iterator         ResourceTextMapIterator;

    //
    // struct for each localui resource
    //
    typedef struct
    {
        LONG lState;
        ResourceTextMap mapResText;
    } ResourceStruct,*ResourceStructPtr;

    //
    // mapping of resource name and  localui resource
    //
    typedef map< wstring, ResourceStructPtr >  ResourceMap;
    typedef ResourceMap::iterator         ResourceMapIterator;

    //
    // contains all of the localui resources
    //
    ResourceMap m_ResourceMap;

    //
    // mapping of resource names and their merits
    //
    typedef map< DWORD, wstring>  MeritMap;
    typedef MeritMap::iterator        MeritMapIterator;


    //
    // localization manager component
    //
    CComPtr <ISALocInfo> m_pSALocInfo;
    
    //
    // contains localui resource names and merits
    //
    MeritMap m_MeritMap;


    //
    // number of localui resources
    //
    LONG m_lResourceCount;


    //
    // Wbem services component
    //
    CComPtr  <IWbemServices> m_pWbemServices;


    //
    // method obtaining resource information from element manager
    //
    STDMETHOD(GetLocalUIResources)
                                (
                                void
                                );

    //
    // initializes wbem for localui resource events
    //
    STDMETHOD(InitializeWbemSink)
                                (
                                void
                                );

    //
    // loads icons for each resource web element
    //
    STDMETHOD(AddTextResource)
                            (
                            /*[in]*/IWebElement * pElement
                            );

    //
    // converts a hex digit to base 10 number
    //
    ULONG HexCharToULong(WCHAR wch);

    //
    // converts a hex string to unsigned long
    //
    ULONG HexStringToULong(wstring wsHexString);

public:

    //
    // called just after constructor, initializes the component
    //
    STDMETHOD(FinalConstruct)(void);

    //
    // called just before destructor, releases resources
    //
    STDMETHOD(FinalRelease)(void);

    //
    // ---------IWbemUnboundObjectSink interface methods----------
    //
    STDMETHOD(Indicate) (
                    /*[in]*/    LONG                lObjectCount,
                    /*[in]*/    IWbemClassObject    **ppObjArray
                    );
    
    STDMETHOD(SetStatus) (
                    /*[in]*/    LONG                lFlags,
                    /*[in]*/    HRESULT             hResult,
                    /*[in]*/    BSTR                strParam,
                    /*[in]*/    IWbemClassObject    *pObjParam
                    );


    //
    // draws the state strings
    //
    HRESULT OnDraw(ATL_DRAWINFO& di);

};

#endif //__TEXTRESCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\lcdman.h ===
// LCDMan.h : main header file for the LCDMAN application
//

#if !defined(AFX_LCDMAN_H__1BC85EF1_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
#define AFX_LCDMAN_H__1BC85EF1_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CLCDManApp:
// See LCDMan.cpp for the implementation of this class
//

class CLCDManApp : public CWinApp
{
public:
    CLCDManApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLCDManApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CLCDManApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LCDMAN_H__1BC85EF1_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\lcdmanview.cpp ===
// LCDManView.cpp : implementation of the CLCDManView class
//

#include "stdafx.h"
#include "LCDMan.h"

#include "LCDManDoc.h"
#include "LCDManView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLCDManView

IMPLEMENT_DYNCREATE(CLCDManView, CView)

BEGIN_MESSAGE_MAP(CLCDManView, CView)
    //{{AFX_MSG_MAP(CLCDManView)
    ON_COMMAND(ID_VIEW_NEXT, OnViewNext)
    ON_COMMAND(ID_VIEW_PREVIOUS, OnViewPrevious)
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLCDManView construction/destruction

CLCDManView::CLCDManView() : /*m_Rect(0, 0, 700, 70),*/ m_RectImg(100, 50, 100 + LCD_X_DIMENSION, 50 + LCD_Y_DIMENSION),
    m_iTimerInterval (0), m_iTextPos(0), m_pos(NULL)
{
    m_bmText.bmBits = m_bmVal;
}

CLCDManView::~CLCDManView()
{
}

BOOL CLCDManView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CLCDManView drawing

void CLCDManView::OnDraw(CDC* pDC)
{
    CLCDManDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    if (!pDoc->GetLIst()->IsEmpty())
    {
        // Convert the text into bitmap
//        HDC hDCMem = ::CreateCompatibleDC(pDC->m_hDC);
        CDC dcMem;
        if (!dcMem.CreateCompatibleDC(pDC))
            return;
        CFont cfFit;
        LOGFONT logfnt;
        // determine default font for document
        memset(&logfnt, 0, sizeof logfnt);
        lstrcpy(logfnt.lfFaceName, _T("Arial"));
        logfnt.lfOutPrecision = OUT_TT_PRECIS;
        logfnt.lfClipPrecision = CLIP_DEFAULT_PRECIS;
        logfnt.lfQuality = PROOF_QUALITY;
        logfnt.lfPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
        logfnt.lfHeight = (LCD_Y_DIMENSION);
        cfFit.CreateFontIndirect(&logfnt);
        CFont *pcfDefault = dcMem.SelectObject( &cfFit );
        SIZE size;
        size.cx = LCD_X_DIMENSION;
        size.cy = LCD_Y_DIMENSION;
        CBitmap CBitMapText;
//        HBITMAP hBitMap = ::CreateCompatibleBitmap(hDCMem, size.cx, size.cy);
        if (!CBitMapText.CreateCompatibleBitmap(pDC, size.cx, size.cy))
            return;
        dcMem.SelectObject(&CBitMapText);

        SIZE szState = dcMem.GetTextExtent(pDoc->GetState());
        CRect crectState(0, 0, szState.cx, size.cy);
        CRect crectMsg(szState.cx, 0,  size.cx, size.cy);
        // Build the full message string from m_List
        CStringList *pList = pDoc->GetLIst();
        CString CStrFull = (TEXT(""));
        CString cstr(TEXT(""));
        POSITION pos ;
        if (pList->IsEmpty())
            return;

        SIZE szMsg;
        LONG lFullLength = 0;
        for ( pos = pList->GetHeadPosition(); ; )
        {
            cstr = pList->GetNext(pos);
            szMsg = dcMem.GetTextExtent(cstr);
            CStrFull += cstr;
            lFullLength += szMsg.cx;
            if (lFullLength > size.cx + 10 && m_iTimerInterval == 0)
            {
                // Start rolling
                m_iTimerInterval = 200;
                KillTimer(1);
                SetTimer(1, m_iTimerInterval, NULL);
                m_iTextPos = 0;
            }
            if (lFullLength - m_iTextPos > size.cx + 10)
                break;
            else if (pos == NULL &&  lFullLength  > size.cx + 10)
                pos = pList->GetHeadPosition();
            else if (pos == NULL)
                break;
        }
        
        if (lFullLength <= size.cx + 10 && m_iTimerInterval != 0)
        {
            // Stop rolling
            m_iTimerInterval = 0;
            KillTimer(1);
            m_iTextPos = 0;
        }

        dcMem.ExtTextOut(0, 0, ETO_CLIPPED | ETO_OPAQUE, &crectState, pDoc->GetState(), NULL);
        dcMem.ExtTextOut(crectState.right - m_iTextPos,0, ETO_CLIPPED | ETO_OPAQUE, &crectMsg, CStrFull, NULL);

        // Recreate the bitmap from BITMAP srtuct
        CBitMapText.GetBitmap(&m_bmText);
        m_bmText.bmBits = m_bmVal;
        CBitMapText.GetBitmapBits(sizeof(m_bmVal), m_bmText.bmBits);
        dcMem.SelectObject(pcfDefault );
        dcMem.DeleteDC();
        CBitMapText.DeleteObject();
        CBitmap CBOut;
        if (!CBOut.CreateBitmapIndirect(&m_bmText))
            return;

        // Display new bitmap
        CDC dcMem1;
        if (!dcMem1.CreateCompatibleDC(pDC))
            return;
        dcMem1.SelectObject(&CBOut);

        // Display the bitmap
        GetClientRect(m_RectImg);
        m_RectImg.top = (m_RectImg.bottom - LCD_Y_DIMENSION) / 2;
        m_RectImg.bottom = (m_RectImg.bottom + LCD_Y_DIMENSION) / 2;
        m_RectImg.left = (m_RectImg.right - LCD_X_DIMENSION) / 2;
        m_RectImg.right = (m_RectImg.right + LCD_X_DIMENSION) / 2;
        CRect crFrame(m_RectImg);
        crFrame.InflateRect(1,1,1,1);
        pDC->Rectangle(&crFrame);
        pDC->BitBlt(m_RectImg.left, m_RectImg.top, size.cx, size.cy, &dcMem1, 0, 0, SRCCOPY );

        // Clean up
        CBOut.DeleteObject();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CLCDManView printing

BOOL CLCDManView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}

void CLCDManView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}

void CLCDManView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CLCDManView diagnostics

#ifdef _DEBUG
void CLCDManView::AssertValid() const
{
    CView::AssertValid();
}

void CLCDManView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CLCDManDoc* CLCDManView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CLCDManDoc)));
    return (CLCDManDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLCDManView message handlers

void CLCDManView::OnViewNext() 
{
    CLCDManDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    CStringList *pList = pDoc->GetLIst();
    if (m_pos)
    {
        pList->GetNext(m_pos);
    }
    InvalidateRect(NULL, TRUE);
}

void CLCDManView::OnViewPrevious() 
{
    CLCDManDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    CStringList *pList = pDoc->GetLIst();
    if (m_pos)
    {
        pList->GetPrev(m_pos);
    }
    InvalidateRect(NULL, TRUE);
}

void CLCDManView::OnTimer(UINT nIDEvent) 
{
    if (nIDEvent == 1)
    {
        // Roll the message
        m_iTextPos += 5;
        InvalidateRect(&m_RectImg, FALSE);
    }
    else if (nIDEvent == 2)
    {
        // Recreate document
        CLCDManDoc* pDoc = GetDocument();
        ASSERT_VALID(pDoc);
        pDoc->InitDocument(NULL);
        InvalidateRect(&m_RectImg, FALSE);
    }

    CView::OnTimer(nIDEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\lcdman.cpp ===
// LCDMan.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "LCDMan.h"

#include "MainFrm.h"
#include "LCDManDoc.h"
#include "LCDManView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLCDManApp

BEGIN_MESSAGE_MAP(CLCDManApp, CWinApp)
    //{{AFX_MSG_MAP(CLCDManApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLCDManApp construction

CLCDManApp::CLCDManApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLCDManApp object

CLCDManApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CLCDManApp initialization

BOOL CLCDManApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();            // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();    // Call this when linking to MFC statically
#endif

    // Change the registry key under which our settings are stored.
    // TODO: You should modify this string to be something appropriate
    // such as the name of your company or organization.
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CLCDManDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CLCDManView));
    AddDocTemplate(pDocTemplate);

    // Enable DDE Execute open
    EnableShellOpen();
    RegisterShellFileTypes(TRUE);

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();

    // Enable drag/drop open
    m_pMainWnd->DragAcceptFiles();

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CLCDManApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CLCDManApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\lcdmandoc.h ===
// LCDManDoc.h : interface of the CLCDManDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_LCDMANDOC_H__1BC85EF7_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
#define AFX_LCDMANDOC_H__1BC85EF7_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CLCDManDoc : public CDocument
{
protected: // create from serialization only
    CLCDManDoc();
    DECLARE_DYNCREATE(CLCDManDoc)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLCDManDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CLCDManDoc();
    CStringList *GetLIst() { return &m_List;}
    CString GetState() { return  m_cstrState;}
    void InitDocument(CFile *);
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
//    CTypedPtrList <CObList, CString*> m_List;
    CStringList m_List;
    CString m_cstrState;
    int m_iDocTimeIntrval;
    LPTSTR m_ptFileBuffer;
    LPTSTR m_ptBufferStart;
    LPTSTR m_ptBufferEnd;
    //{{AFX_MSG(CLCDManDoc)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LCDMANDOC_H__1BC85EF7_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\lcdmandoc.cpp ===
// LCDManDoc.cpp : implementation of the CLCDManDoc class
//

#include "stdafx.h"
#include "LCDMan.h"

#include "LCDManDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLCDManDoc

IMPLEMENT_DYNCREATE(CLCDManDoc, CDocument)

BEGIN_MESSAGE_MAP(CLCDManDoc, CDocument)
    //{{AFX_MSG_MAP(CLCDManDoc)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLCDManDoc construction/destruction

CLCDManDoc::CLCDManDoc() : m_List(10), m_cstrState(_T("")), m_iDocTimeIntrval(0),
    m_ptFileBuffer(NULL), m_ptBufferStart(NULL), m_ptBufferEnd(NULL)
{
    // TODO: add one-time construction code here

}

CLCDManDoc::~CLCDManDoc()
{
    if (m_ptBufferStart)
        free(m_ptBufferStart);
}

BOOL CLCDManDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    InitDocument(NULL);
    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CLCDManDoc serialization

void CLCDManDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
    m_List.Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CLCDManDoc diagnostics

#ifdef _DEBUG
void CLCDManDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CLCDManDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLCDManDoc commands

BOOL CLCDManDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
//    if (!CDocument::OnOpenDocument(lpszPathName))    Do not use the archive
//        return FALSE;
    if (lpszPathName)
    {
        CFile CFSource(lpszPathName, CFile::modeRead);
        if (CFSource)
            InitDocument(&CFSource);
    }
    
    return TRUE;
}

void CLCDManDoc::InitDocument(CFile *pCFSource)
{
    if (pCFSource)
    {
        m_List.RemoveAll();
        // Red the file and build m_List
        DWORD dwLength = pCFSource->GetLength();
        m_ptFileBuffer = (LPTSTR)malloc(dwLength);
        m_ptBufferStart = m_ptFileBuffer;
        if (m_ptFileBuffer)
        {
            pCFSource->Read(m_ptFileBuffer, dwLength);
            m_ptFileBuffer++;    // Notepad places 0xFF 0xFE codes at the beginig of the file
            m_ptBufferEnd = m_ptFileBuffer + dwLength;
        }
    }
    else if (!m_ptFileBuffer)
        return;    // No file, no document, no nothing

    while (m_ptFileBuffer < m_ptBufferEnd)
    {
        LPTSTR ptEndString = _tcschr(m_ptFileBuffer,  _T('\r'));
        if (!ptEndString)
            break;
        *ptEndString = _T('\0');
        if (_tcsstr(m_ptFileBuffer, _T("TIME:")))
        {
            // Set the timer for the message set
            m_ptFileBuffer += _tcsclen(_T("TIME:"));
            _stscanf(m_ptFileBuffer, _T("%d"), &m_iDocTimeIntrval);
            POSITION posView = GetFirstViewPosition();
            CView *pView = GetNextView(posView);
            pView->SetTimer(2, m_iDocTimeIntrval * 1000, NULL);
        }
        else if (_tcsstr(m_ptFileBuffer, _T("STATE:")))
        {
            // Set the state
            m_ptFileBuffer += _tcsclen(_T("STATE:"));
            m_cstrState = m_ptFileBuffer;
        }
        else if (_tcsstr(m_ptFileBuffer, _T("ADDMSG:")))
        {
            // Add message to the list
            m_ptFileBuffer += _tcsclen(_T("ADDMSG:"));
            m_List.AddTail(m_ptFileBuffer);
        }
        else if (_tcsstr(m_ptFileBuffer, _T("REMOVEMSG:")))
        {
            // Remove message from the list
            m_ptFileBuffer += _tcsclen(_T("REMOVEMSG:"));
            CString cstr(TEXT(""));
            CString cstrMsg(m_ptFileBuffer);
            for (POSITION pos = m_List.GetHeadPosition(); pos != NULL; m_List.GetNext(pos) )
            {
                cstr = m_List.GetAt(pos);
                if (cstr == cstrMsg)
                {
                    m_List.RemoveAt(pos);
                    break;
                }
            }
        }
        else if (_tcsstr(m_ptFileBuffer, _T("END:")))
        {
            // End of the document
            m_ptFileBuffer = ptEndString + 2;
            break;
        }
        m_ptFileBuffer = ptEndString + 2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "LCDMan.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    // TODO: add member initialization code here
    
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
        | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // TODO: Delete these three lines if you don't want the toolbar to
    //  be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\lcdmanview.h ===
// LCDManView.h : interface of the CLCDManView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_LCDMANVIEW_H__1BC85EF9_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
#define AFX_LCDMANVIEW_H__1BC85EF9_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Hardware.h"

class CLCDManView : public CView
{
protected: // create from serialization only
    CLCDManView();
    DECLARE_DYNCREATE(CLCDManView)

// Attributes
public:
    CLCDManDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLCDManView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CLCDManView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    POSITION m_pos; // !!!!!!!!!!!!! Obsolete
    CRect m_RectImg;
    BITMAP m_bmText;
    BYTE m_bmVal[LCD_X_DIMENSION * LCD_Y_DIMENSION * 15];
    int m_iTimerInterval;
    int m_iTextPos;
    //{{AFX_MSG(CLCDManView)
    afx_msg void OnViewNext();
    afx_msg void OnViewPrevious();
    afx_msg void OnTimer(UINT nIDEvent);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in LCDManView.cpp
inline CLCDManDoc* CLCDManView::GetDocument()
   { return (CLCDManDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LCDMANVIEW_H__1BC85EF9_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LCDMan.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_LCDMANTYPE                  129
#define ID_VIEW_NEXT                    32771
#define ID_VIEW_PREVIOUS                32772
#define ID_BUTPREV                      32773

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32775
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1BC85EF3_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
#define AFX_STDAFX_H__1BC85EF3_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>        // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>            // MFC support for Windows Common Controls
#include <afxtempl.h>

#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1BC85EF3_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//    LCDMan.pch will be the pre-compiled header
//    stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\lcdman\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__1BC85EF5_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
#define AFX_MAINFRM_H__1BC85EF5_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CFrameWnd
{
    
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__1BC85EF5_74DE_11D2_AB4D_00C04F991DFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\propsheet\chklst.cpp ===
/*****************************************************************************
 *
 *      chklst.cpp
 *
 *      Wrappers that turn a listview into a checked listbox.
 *
 *      Typical usage:
 *
 *      // at app startup
 *      CCheckList::Init();
 *
 *      // Dialog template should look like this:
 *
 *          CONTROL         "", IDC_TYPE_CHECKLIST, WC_LISTVIEW,
 *                          LVS_REPORT | LVS_SINGLESEL |
 *                          LVS_NOCOLUMNHEADER |
 *                          LVS_SHAREIMAGELISTS |
 *                          WS_TABSTOP | WS_BORDER,
 *                          7, 17, 127, 117
 *
 *      // Do not use the LVS_SORTASCENDING or LVS_SORTDESCENDING flags.
 *
 *      // in the dialog's WM_INITDIALOG handler
 *      hwndList = GetDlgItem(hDlg, IDC_TYPE_CHECKLIST);
 *      CCheckList::OnInitDialog(hwndList);
 *
 *      // The first item added is always item zero, but you can put it
 *      // into a variable if it makes you feel better
 *      iFirst = CCheckList::AddString(hwndList,
 *                                   "Checkitem, initially checked", TRUE);
 *
 *      // The second item added is always item one, but you can put it
 *      // into a variable if it makes you feel better
 *      iSecond = CCheckList::AddString(hwndList,
 *                                    "Checkitem, initially unchecked", FALSE);
 *
 *      CCheckList::InitFinish(hwndList);
 *
 *      // To suck out values
 *      if (CCheckList::GetState(hwndList, iFirst)) {...}
 *      if (CCheckList::GetState(hwndList, iSecond)) {...}
 *
 *      // At dialog box destruction
 *      CCheckList::OnDestroy(hwndList);
 *
 *      // at app shutdown
 *      CCheckList::Term();
 *
 *****************************************************************************/

#include <windows.h>
#include <commctrl.h>
#include <comdef.h>
#include "crtdbg.h"
#include "resource.h"
#include "chklst.h"

#ifndef    STATEIMAGEMASKTOINDEX
#define    STATEIMAGEMASKTOINDEX(i) ((i & LVIS_STATEIMAGEMASK) >> 12)
#endif

HIMAGELIST g_himlState;

/*****************************************************************************
 *
 *      CCheckList::Init
 *
 *      One-time initialization.  Call this at app startup.
 *
 *      IDB_CHECK should refer to chk.bmp.
 *
 *****************************************************************************/
extern HINSTANCE   g_hInst;

BOOL WINAPI
CCheckList::Init(HWND hwnd)
{
    ListView_DeleteAllItems(hwnd);
#ifdef USE_BITMAP_FOR_IMAGES
    g_himlState = ImageList_LoadImage(g_hInst, MAKEINTRESOURCE(IDB_CHECK),
                                      0, 2, RGB(0xFF, 0x00, 0xFF),
                                      IMAGE_BITMAP, 0);
#else
    g_himlState = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
        GetSystemMetrics(SM_CYSMICON), ILC_COLOR4 , 1, 1); 

    HICON hiconItem;        // icon for list view items 
    // Add an icon to each image list. 
    hiconItem = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_BLANK)); 
    ImageList_AddIcon(g_himlState, hiconItem);     
    hiconItem = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_CHECKED)); 
    ImageList_AddIcon(g_himlState, hiconItem);     
    hiconItem = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_GRAYCHECKED)); 
    ImageList_AddIcon(g_himlState, hiconItem);     
    DeleteObject(hiconItem); 
#endif USE_BITMAP_FOR_IMAGES
    
//    ListView_SetExtendedListViewStyleEx(hwnd, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);
    ListView_SetImageList(hwnd, g_himlState, LVSIL_SMALL );

    return (BOOL)g_himlState;
}

/*****************************************************************************
 *
 *      CCheckList::Term
 *
 *      One-time shutdown.  Call this at app termination.
 *
 *****************************************************************************/

void WINAPI
CCheckList::Term(void)
{
    if (g_himlState) {
        ImageList_Destroy(g_himlState);
    }
}

/*****************************************************************************
 *
 *      CCheckList::AddString
 *
 *      Add a string and a checkbox.
 *
 *****************************************************************************/

int WINAPI
CCheckList::AddString(HWND hwnd, LPTSTR ptszText, PSID pSID, LONG lSidLength, CHKMARK chkmrk)
{
    LV_ITEM lvi;
    ZeroMemory(&lvi, sizeof(lvi));

    pSid9X *ppSID9X = new pSid9X;
    ppSID9X->length = lSidLength;
    ppSID9X->psid = pSID;

    lvi.pszText = ptszText;
    lvi.lParam = (LONG)ppSID9X;
#ifdef USE_BITMAP_FOR_IMAGES
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvi.state = INDEXTOSTATEIMAGEMASK(chkmrk);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
#else
     lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
     lvi.iImage = chkmrk;
#endif USE_BITMAP_FOR_IMAGES
     lvi.iItem = ListView_GetItemCount(hwnd);

    return ListView_InsertItem(hwnd, &lvi);
}

/*****************************************************************************
 *
 *      CCheckList::Mark
 *
 *      Check or Uncheck a checkbox.
 *
 *****************************************************************************/

BOOL WINAPI
CCheckList::Mark(HWND hwnd, int item, CHKMARK chkmrk)
{
    LV_ITEM lvi;
    ZeroMemory(&lvi, sizeof(lvi));

#ifdef USE_BITMAP_FOR_IMAGES
    lvi.mask = LVIF_STATE;
    lvi.state = INDEXTOSTATEIMAGEMASK(chkmrk);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
#else
     lvi.mask = LVIF_IMAGE;
     lvi.iImage = chkmrk;
#endif    USE_BITMAP_FOR_IMAGES
    lvi.iItem = item;

    return ListView_SetItem(hwnd, &lvi);
}

/*****************************************************************************
 *
 *      CCheckList::InitFinish
 *
 *      Wind up the initialization.  Do this after you've added all the
 *      strings you plan on adding.
 *
 *****************************************************************************/

void WINAPI
CCheckList::InitFinish(HWND hwnd)
{
    RECT rc;
    LV_COLUMN col;
    int icol;

    /*
     *  Add the one and only column.
     */
    GetClientRect(hwnd, &rc);
    col.mask = LVCF_WIDTH;
    col.cx = rc.right;
    icol = ListView_InsertColumn(hwnd, 0, &col);

    ListView_SetColumnWidth(hwnd, icol, LVSCW_AUTOSIZE);
}

/*****************************************************************************
 *
 *  CCheckList::GetName
 *
 *****************************************************************************/

void WINAPI
CCheckList::GetName(HWND hwnd, int iItem, LPTSTR lpsName, int cchTextMax)
{
    ListView_GetItemText(hwnd, iItem, 0, lpsName, cchTextMax);
}

/*****************************************************************************
 *
 *  CCheckList::GetSID
 *
 *****************************************************************************/

void WINAPI
CCheckList::GetSID(HWND hwnd, int iItem, PSID* ppSID, LONG *plengthSID)
{
    LV_ITEM lvi;
    ZeroMemory(&lvi, sizeof(lvi));

    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    ListView_GetItem(hwnd, &lvi);
    if (lvi.lParam)
    {
        *ppSID = ((pSid9X *)(lvi.lParam))->psid;
        *plengthSID = ((pSid9X *)(lvi.lParam))->length;
    }
}

/*****************************************************************************
 *
 *  CCheckList::GetState
 *
 *  Read the state of a checklist item
 *
 *****************************************************************************/

CHKMARK WINAPI
CCheckList::GetState(HWND hwnd, int iItem)
{
    LV_ITEM lvi;
    ZeroMemory(&lvi, sizeof(lvi));

    lvi.iItem = iItem;
#ifdef USE_BITMAP_FOR_IMAGES
    lvi.mask = LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    ListView_GetItem(hwnd, &lvi);
    return (CHKMARK)STATEIMAGEMASKTOINDEX(lvi.state);
#else
     lvi.mask = LVIF_IMAGE;
     ListView_GetItem(hwnd, &lvi);
     return (CHKMARK)lvi.iImage;
#endif USE_BITMAP_FOR_IMAGES
}

/*****************************************************************************
 *
 *  CCheckList::SetState
 *
 *  Sets the state of a checklist item
 *
 *****************************************************************************/

BOOL WINAPI 
CCheckList::SetState(HWND hwnd, int iItem, CHKMARK chkmrk)
{
    LV_ITEM lvi;
    ZeroMemory(&lvi, sizeof(lvi));

    lvi.iItem = iItem;
#ifdef USE_BITMAP_FOR_IMAGES
    lvi.mask = LVIF_STATE;
    lvi.state = INDEXTOSTATEIMAGEMASK(chkmrk);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
#else
     lvi.mask = LVIF_IMAGE;
     lvi.iImage = chkmrk;
#endif USE_BITMAP_FOR_IMAGES
    return ListView_SetItem(hwnd, &lvi);
}

/*****************************************************************************
 *
 *      CCheckList::OnDestroy
 *
 *      Clean up a checklist.  Call this before destroying the window.
 *
 *****************************************************************************/

void WINAPI
CCheckList::OnDestroy(HWND hwnd)
{
    BOOL fRes = FALSE;
    LV_ITEM lvi;
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;

    DWORD    dwNumSAUsers = ListView_GetItemCount(hwnd);
    PSID psidSAUsers;

    for(DWORD i=0; i<dwNumSAUsers; i++)
    {
        lvi.iItem = i;
        ListView_GetItem(hwnd, &lvi);
        pSid9X *ppSID9X = (pSid9X *)lvi.lParam;
        psidSAUsers = ppSID9X->psid;

        fRes = HeapFree(GetProcessHeap(), 0, psidSAUsers);
        _ASSERTE(fRes);
        delete ppSID9X;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\propsheet\chklst.h ===
#ifndef CHECKLIST_H
#define CHECKLIST_H

#include "ComUtil.h"

typedef enum {
    BLANK = 0,
    CHECKED,
    GRAYCHECKED
} CHKMARK;

struct pSid9X    // We need it because Win9X doesn't support SID API
{
    LONG length;
    PSID psid;
};

class CCheckList
{
public:
    BOOL WINAPI Init(HWND);
    void WINAPI Term(void);
    int WINAPI AddString(HWND hwnd, LPTSTR ptszText, PSID pSID, LONG lSidLength, CHKMARK Check);
    BOOL WINAPI    Mark(HWND , int , CHKMARK);
    void WINAPI InitFinish(HWND hwnd);
    CHKMARK WINAPI GetState(HWND hwnd, int iItem);
    void WINAPI GetName(HWND hwnd, int iItem, LPTSTR lpsName, int cchTextMax);
    void WINAPI GetSID(HWND hwnd, int iItem, PSID* ppSID, LONG *plengthSID);
    BOOL WINAPI SetState(HWND hwnd, int iItem, CHKMARK chkmrk);
    void WINAPI OnDestroy(HWND hwnd);
};
#endif CHECKLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\propsheet\isausinf.cpp ===
#include <windows.h>
#include "crtdbg.h"
#include <objbase.h>
#include "ISAUsInf.h"

PSID g_pSidEverybody = NULL;
LONG g_pSidEverybodyLenght = 0;
PSID g_pSidAdmins = NULL;
LONG g_pSidAdminsLenght = 0;

VARIANT_BOOL UserSidFound(PSID psidSAUser, LONG psidSAUserLength, PSID ppsidAAUsers[], LONG ppsidAAUsersLength[], DWORD dwNumAASids)
{
    DWORD i;

    for(i=0; i<dwNumAASids; i++)
    {
//        if (EqualSid(psidSAUser, ppsidAAUsers[i]) == TRUE)
        if (psidSAUserLength && psidSAUserLength == ppsidAAUsersLength[i] && !memcmp(psidSAUser, ppsidAAUsers[i], ppsidAAUsersLength[i]))
            return VARIANT_TRUE;
    }
    return VARIANT_FALSE;
}


HRESULT GetUserList(ISAUserInfo  *pSAUserInfo,     BSTR  **ppbstrSAUserNames, 
                    VARIANT_BOOL **ppvboolUserTypes, PSID **ppsidSAUsers, LONG **ppsidSAUsersLength, DWORD *pdwNumSAUsers)
{
    VARIANT_BOOL vboolRes;
    VARIANT      vUserNames, vUserTypes, vUserSids;
    SAFEARRAY    *psaUserNames, *psaUserTypes, *psaUserSids;
    LONG         lNumUsers, lCurrent;
    LONG         lStartUserNames, lEndUserNames, lStartUserTypes, lEndUserTypes, lStartUserSids, lEndUserSids;
    HRESULT      hr;

    *pdwNumSAUsers = 0;
    VariantInit(&vUserNames);
    VariantInit(&vUserTypes);
    VariantInit(&vUserSids);

    hr = pSAUserInfo->GetSAUsers(&vUserNames, 
                                 &vUserTypes, 
                                 &vUserSids, 
                                 VARIANT_TRUE, 
                                 &vboolRes);    

    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    
    psaUserNames = V_ARRAY(&vUserNames);
    psaUserTypes = V_ARRAY(&vUserTypes);
    psaUserSids  = V_ARRAY(&vUserSids);
    
    _ASSERTE (V_VT(&vUserNames) == (VT_ARRAY | VT_VARIANT));
    if (V_VT(&vUserNames) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    _ASSERTE(V_VT(&vUserTypes) == (VT_ARRAY | VT_VARIANT));
    if (V_VT(&vUserTypes) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    _ASSERTE(V_VT(&vUserSids) == (VT_ARRAY | VT_VARIANT));
    if (V_VT(&vUserSids) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;
    
    hr = SafeArrayGetLBound( psaUserNames, 1, &lStartUserNames );
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    
    hr = SafeArrayGetUBound( psaUserNames, 1, &lEndUserNames );
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    
    hr = SafeArrayGetLBound( psaUserTypes, 1, &lStartUserTypes );
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    
    hr = SafeArrayGetUBound( psaUserTypes, 1, &lEndUserTypes );
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;

    hr = SafeArrayGetLBound( psaUserSids, 1, &lStartUserSids );
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    
    hr = SafeArrayGetUBound( psaUserSids, 1, &lEndUserSids );
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;

    _ASSERTE(!( (lStartUserNames != lStartUserTypes) || (lEndUserNames != lEndUserNames) ));
    if ( (lStartUserNames != lStartUserTypes) || (lEndUserNames != lEndUserNames) )
        return E_FAIL;

    _ASSERTE(!( (lStartUserNames != lStartUserSids) || ((lEndUserNames+2) != lEndUserSids) ));
    if ( (lStartUserNames != lStartUserSids) || ((lEndUserNames+2) != lEndUserSids) )
        return E_FAIL;


    lNumUsers = lEndUserNames - lStartUserNames + 1;

    *pdwNumSAUsers = lNumUsers;

    *ppbstrSAUserNames = (BSTR *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lNumUsers * sizeof(BSTR *));
    _ASSERTE(*ppbstrSAUserNames);
    if ((*ppbstrSAUserNames) == NULL)
        return E_OUTOFMEMORY;

    *ppvboolUserTypes = (VARIANT_BOOL *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lNumUsers * sizeof(VARIANT_BOOL));
    _ASSERTE(*ppvboolUserTypes );
    if ((*ppvboolUserTypes ) == NULL)
        return E_OUTOFMEMORY;

    *ppsidSAUsers = (PSID *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (lNumUsers + 2) * sizeof(PSID));
    _ASSERTE(*ppsidSAUsers );
    if ((*ppsidSAUsers ) == NULL)
        return E_OUTOFMEMORY;

    *ppsidSAUsersLength = (LONG *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (lNumUsers + 2) * sizeof(LONG));
    _ASSERTE(*ppsidSAUsersLength );
    if ((*ppsidSAUsersLength ) == NULL)
        return E_OUTOFMEMORY;

    VARIANT vName;
    VARIANT vType;
    VARIANT vSid;
    
    VariantInit( &vName );
    VariantInit( &vType );
    VariantInit( &vSid );
            
    //
    // Process the array elements.
    //
    for ( lCurrent = lStartUserNames; lCurrent <= lEndUserNames; lCurrent++) 
    {
        hr = SafeArrayGetElement( psaUserNames, &lCurrent, &vName );
        _ASSERTE( !FAILED(hr) );
        if( FAILED(hr) )
            return hr;
        
        hr = SafeArrayGetElement( psaUserTypes, &lCurrent, &vType );
        _ASSERTE( !FAILED(hr) );
        if( FAILED(hr) )
            return hr;

        hr = SafeArrayGetElement( psaUserSids, &lCurrent, &vSid );
        _ASSERTE( !FAILED(hr) );
        if( FAILED(hr) )
            return hr;

        _ASSERTE ( V_VT(&vName) == VT_BSTR );
        if ( V_VT(&vName) != VT_BSTR )
            return E_FAIL;

        _ASSERTE ( V_VT(&vType) == VT_BOOL );
        if ( V_VT(&vType) != VT_BOOL )
            return hr;

        (*ppbstrSAUserNames)[lCurrent] = SysAllocString(V_BSTR(&vName));
        (*ppvboolUserTypes)[lCurrent]  = V_BOOL(&vType);
        hr = UnpackSidFromVariant(&vSid, &(*ppsidSAUsers)[lCurrent], &(*ppsidSAUsersLength)[lCurrent]);
        _ASSERTE( !FAILED(hr) );
        if (FAILED(hr))
            return hr;

//        _ASSERTE (IsValidSid((*ppsidSAUsers)[lCurrent]));
//        if (IsValidSid((*ppsidSAUsers)[lCurrent]) == FALSE)
//            return E_INVALIDARG;

        VariantClear( &vName );
        VariantClear( &vType );
        VariantClear( &vSid );
    }

    // Stash Administrators SID
    lCurrent = lEndUserSids - 1 ;

    hr = SafeArrayGetElement( psaUserSids, &lCurrent, &vSid );
    _ASSERTE( !FAILED(hr) );
    if( FAILED(hr) )
        return hr;

    hr = UnpackSidFromVariant(&vSid, &g_pSidAdmins, &g_pSidAdminsLenght);
    _ASSERTE( !FAILED(hr) );
    if (FAILED(hr))
        return hr;

    VariantClear( &vSid );

    // Stash Everyone SID
    lCurrent = lEndUserSids;

    hr = SafeArrayGetElement( psaUserSids, &lCurrent, &vSid );
    _ASSERTE( !FAILED(hr) );
    if( FAILED(hr) )
        return hr;

    hr = UnpackSidFromVariant(&vSid, &g_pSidEverybody, &g_pSidEverybodyLenght);
    _ASSERTE( !FAILED(hr) );
    if (FAILED(hr))
        return hr;

    VariantClear( &vSid );

    return S_OK;
}

HRESULT UnpackSidFromVariant(VARIANT *pvarSid, PSID *ppSid, LONG *plSidLength)
{
    SAFEARRAY     *psaSid;
    LONG          lStart = 0L, lEnd = 0L,lCurrent;
    BYTE          byteOfSid;
    HRESULT       hr;

    _ASSERTE (V_VT(pvarSid) == (VT_ARRAY | VT_UI1));
    if (V_VT(pvarSid) != (VT_ARRAY | VT_UI1))
        return E_INVALIDARG;
    
    psaSid = V_ARRAY(pvarSid);
    
    hr = SafeArrayGetLBound( psaSid, 1, &lStart );
    _ASSERTE( !FAILED(hr) );
    if (FAILED(hr))
        return hr;
    
    hr = SafeArrayGetUBound( psaSid, 1, &lEnd );
    _ASSERTE( !FAILED(hr) );
    if (FAILED(hr))
        return hr;

    *plSidLength = lEnd - lStart + 1;

    *ppSid = (PSID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *plSidLength);
    _ASSERTE(*ppSid);
    if ((*ppSid) == NULL)
        return E_OUTOFMEMORY;

    for(lCurrent = lStart; lCurrent<lEnd; lCurrent++)
    {
        hr = SafeArrayGetElement( psaSid, &lCurrent, &byteOfSid );
        _ASSERTE( !FAILED(hr) );
        if( FAILED(hr) )
            return hr;
        ((PBYTE)(*ppSid))[lCurrent] = byteOfSid;
    }
    return S_OK;
}

HRESULT PackSidInVariant(VARIANT **ppVarSid, PSID pSid, LONG lSidLength)
{
    ULONG    i;
    HRESULT  hr;

    _ASSERTE (!((pSid == NULL) || (ppVarSid == NULL)));
    if ((pSid == NULL) || (ppVarSid == NULL))
        return E_INVALIDARG;

    *ppVarSid = (VARIANT *)HeapAlloc(GetProcessHeap(), 0, sizeof(VARIANT));
    _ASSERTE(*ppVarSid);
    if ((*ppVarSid) == NULL)
        return E_FAIL;

    VariantInit((*ppVarSid));

    V_VT((*ppVarSid)) = VT_ARRAY | VT_UI1;

    SAFEARRAYBOUND  bounds;
    bounds.cElements = lSidLength;//GetLengthSid(pSid);
    bounds.lLbound   = 0;

    SAFEARRAY *psaUserSid = NULL;

    psaUserSid = SafeArrayCreate(VT_UI1, 1, &bounds);
    _ASSERTE(psaUserSid);
    if (psaUserSid == NULL)
        return E_OUTOFMEMORY;

    for(i=0; i<bounds.cElements; i++)
    {
        hr = SafeArrayPutElement(psaUserSid, (LONG*)&i, (LPVOID)(((unsigned char *)pSid)+i*sizeof(unsigned char)));
        _ASSERTE( !FAILED(hr) );
        if (FAILED(hr))
            return hr;
    }
    
    V_ARRAY((*ppVarSid)) = psaUserSid;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\propsheet\isausinf.h ===
class ISAUserInfo : public IDispatch
{
public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSAUsers( 
            /* [out] */ VARIANT __RPC_FAR *pbstrArrUsers,
            /* [out] */ VARIANT __RPC_FAR *pboolArrUserTypes,
            /* [out] */ VARIANT __RPC_FAR *pSidArrUserSids,
            /* [in] */ VARIANT_BOOL vboolWantSid,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vboolRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFileAccessAllowedAces( 
            /* [in] */ BSTR bstrFileName,
            /* [out] */ VARIANT __RPC_FAR *pvArrSid,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vboolRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetFileAccessAllowedAces( 
            /* [in] */ BSTR bstrFileName,
            /* [in] */ VARIANT __RPC_FAR *pvArrSid,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vboolRetVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoIHaveAccess(
            /* [in] */ BSTR bstrFileName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vboolRetVal) = 0;
};



const IID IID_ISAUserInfo = {0x84F238D0,0xA0D7,0x11D2,{0x85,0x52,0x00,0x10,0x4B,0xCC,0x1E,0xCB}};
const CLSID CLSID_SAUserInfo = {0x84F238D1,0xA0D7,0x11D2,{0x85,0x52,0x00,0x10,0x4B,0xCC,0x1E,0xCB}};


HRESULT GetUserList(ISAUserInfo  *pSAUserInfo,     BSTR  **ppbstrSAUserNames, VARIANT_BOOL **ppvboolUserTypes, PSID **ppsidSAUsers, LONG **ppsidSAUsersLength, DWORD *pdwNumSAUsers);
HRESULT UnpackSidFromVariant(VARIANT *pvarSid, PSID *ppSid, LONG *plSidLength);
void ShowUsersAllowedAccess(BSTR bstrSAUserNames[], VARIANT_BOOL vboolIsSAUserAdmin[], PSID ppsidSAUsers[], PSID ppsidAAUsers[], DWORD dwNumSAUsers, DWORD dwNumAASids);
VARIANT_BOOL UserSidFound(PSID psidSAUser, LONG psidSAUserLength, PSID ppsidAAUsers[], LONG ppsidAAUsersLength[], DWORD dwNumAASids);
HRESULT PackSidInVariant(VARIANT **ppVarSid, PSID pSid, LONG lSidLength);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\web\makefile.inc ===
#
# Makefile to strip-out debug code from ASP in fre builds
#
$(O)\inc_debug.asp: inc_debug.asp.src
    cl /EP $(C_PREPROCESSOR_FLAGS) inc_debug.asp.src > $(O)\inc_debug.asp

clean:
 del inc_debug.asp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\propsheet\propsheet.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          PropSheet.h

   Description:   

**************************************************************************/

#ifndef SHELLEXT_H
#define SHELLEXT_H

//#include "tchar.h"
#include "windows.h"
#include "shlobj.h"
#include "crtdbg.h"
#include "chklst.h"
#include "Comdef.h"
#include "ObjBase.h"
#include "CHString.h"
#include "lmaccess.h"
#include "resource.h"
#include "olectl.h"
#include "ShellApi.h"
#include "ShlWapi.h"
#include "ISAUsInf.h"

// Constants
#define STRING_SECURITY_WORLD_SID_AUTHORITY "S-1-1-0"
#define DOMAIN_NAME "SMELLY"    //KIBBLESNBITS
#define DOMAIN_SERVER "Domination" //L"ALPO"
#define DOCUMENTS_FOLDER "D:\\Yuri"    //    "D:\\\\Documents\\\\"
#define CHAMELEON_SHARE    "\\\\Domination\\Yuri"    //    "\\\\ALPO\\Documents"

/**************************************************************************
   global variables and definitions
**************************************************************************/
#ifndef ListView_SetCheckState
// #ifndef is important because this macro (well, a
// slightly fixed-up version of this macro) will be going into the
// next version of commctrl.h 
#define ListView_SetCheckState(hwndLV, i, fCheck) \
      ListView_SetItemState(hwndLV, i, \
      INDEXTOSTATEIMAGEMASK((fCheck)?2:1), LVIS_STATEIMAGEMASK)
#endif

#define IDM_DISPLAY  0

extern PSID g_pSidEverybody;
extern LONG g_pSidEverybodyLenght;
extern PSID g_pSidAdmins;
extern LONG g_pSidAdminsLenght;

/**************************************************************************

   CClassFactory class definition

**************************************************************************/

class CClassFactory : public IClassFactory
{
protected:
   DWORD m_ObjRefCount;

public:
   CClassFactory();
   ~CClassFactory();

   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IClassFactory methods
   STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
   STDMETHODIMP LockServer(BOOL);
};

/**************************************************************************

   CShellPropSheetExt class definition

**************************************************************************/

class CShellPropSheetExt : public IShellExtInit, IShellPropSheetExt
{
protected:
    DWORD          m_ObjRefCount;
    CCheckList    m_CheckList;
    BOOL m_fEveryone;
    UINT m_uiUser;
    ISAUserInfo  *m_pSAUserInfo;//    IWbemServices *m_pIWbemServices;
    TCHAR m_szPath[MAX_PATH];
    _bstr_t m_bsPath;
    BOOL m_fChanged;
//    PSID m_pSidEverybody;
//    LONG m_pSidEverybodyLenght;
    BOOL m_fHasAccess;

    //    System info
    TCHAR m_tszDomainServer[MAX_PATH];
    TCHAR m_tszShare[MAX_PATH];
    TCHAR m_tszDocuments[MAX_PATH];
public:
   CShellPropSheetExt();
   ~CShellPropSheetExt();
   
   //IUnknown methods
   STDMETHOD(QueryInterface)(REFIID, LPVOID FAR *);
   STDMETHOD_(DWORD, AddRef)();
   STDMETHOD_(DWORD, Release)();

   //IShellExtInit methods
   STDMETHOD(Initialize)(LPCITEMIDLIST, LPDATAOBJECT, HKEY);

   //IShellPropSheetExt methods
   STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE, LPARAM);
   STDMETHOD(ReplacePage)(UINT, LPFNADDPROPSHEETPAGE, LPARAM);

private:
   static BOOL CALLBACK PageDlgProc(HWND, UINT, WPARAM, LPARAM);
   static UINT CALLBACK PageCallbackProc(HWND, UINT, LPPROPSHEETPAGE);
   BOOL IsChamelon(LPTSTR);
   BOOL Connect();
   void EnumUsers(HWND hWndList);
    void Save(HWND hWnd);
    void CleanUp();
    void NoAccessUpdateView(HWND);
    void AccessUpdateView(HWND);
    HRESULT GetFilePermissions(HWND hWnd);
    HRESULT SetFilePermissions(HWND hWnd);
}
;

#endif   //SHELLEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\propsheet\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PropSheet.rc
//
#define IDD_PAGEDLG                     101
#define IDB_CHECK                       107
#define IDI_BLANK                       108
#define IDI_CHECKED                     109
#define IDI_GRAYCHECKED                 110
#define IDC_FILE_LIST                   1001
#define IDC_CHECKEVRYBODY               1005
#define IDC_EVERYONE                    1006
#define IDC_SELECTUSERS                 1007
#define IDC_BUTTONGROUP                 1008
#define IDC_ADMIN_MESSAGE               1009
#define IDC_USER_MESSAGE                1010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\propsheet\propsheet.cpp ===
/**************************************************************************
    Folder Properties, Security page for Win9X

    Author: Yury Polyakovsky

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          PropSheet.cpp

   Description:   

**************************************************************************/

#include "PropSheet.h"
#include "CHString.h"

/**************************************************************************
   private function prototypes
**************************************************************************/

int WideCharToLocal(LPTSTR, LPWSTR, DWORD);
int LocalToWideChar(LPWSTR, LPTSTR, DWORD);
void StringFromSid( PSID psid, CHString& str );
PSID StrToSID(const CHString& sid);
 BOOL WINAPI RtlAllocateAndInitializeSid(
     PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
     UCHAR SubAuthorityCount,
     ULONG SubAuthority0,
     ULONG SubAuthority1,
     ULONG SubAuthority2,
     ULONG SubAuthority3,
     ULONG SubAuthority4,
     ULONG SubAuthority5,
     ULONG SubAuthority6,
     ULONG SubAuthority7,
    OUT PSID *Sid);
 WINADVAPI PSID_IDENTIFIER_AUTHORITY WINAPI RtlGetSidIdentifierAuthority(PSID pSid);
 PUCHAR WINAPI RtlGetSidSubAuthorityCount (PSID pSid);
 PDWORD WINAPI RtlGetSidSubAuthority (PSID pSid, DWORD nSubAuthority);

BOOL IsNT();

/**************************************************************************
   global variables and definitions
**************************************************************************/

#define INITGUID
#include <initguid.h>
//#include <shlguid.h>

// {E3B33E82-7B11-11d2-9274-00105A24ED29}
DEFINE_GUID(   CLSID_PropSheetExt, 
               0x48a02841, 
               0x39f1, 
               0x150b, 
               0x92, 
               0x74, 
               0x0, 
               0x10, 
               0x5a, 
               0x24, 
               0xed, 
               0x29);

HINSTANCE   g_hInst;
UINT        g_DllRefCount;

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//SID_IDENTIFIER_AUTHORITY g_siaEveryone = {0x80,0,1,0,0,0};
//BYTE bSubAuthorityCount = 0;
//SID_IDENTIFIER_AUTHORITY g_siaEveryone = SECURITY_WORLD_SID_AUTHORITY;
//SID_IDENTIFIER_AUTHORITY g_siaDomainUsers = SECURITY_WORLD_SID_AUTHORITY;
//BYTE bSubAuthorityCount = 1;

TCHAR tszSubKey[] = TEXT("Software\\Microsoft\\ServerAppliance");    

LPTSTR ptszValue[] = 
{
    TEXT("DomainName"),
    TEXT("ServerName"),
    TEXT("Documents"),
    TEXT("Share"),
};

LPTSTR ptszData[] = 
{
    TEXT(DOMAIN_NAME),
    TEXT(DOMAIN_SERVER),
    TEXT(DOCUMENTS_FOLDER),    // Local path at server in C format
    TEXT(CHAMELEON_SHARE)    // in C format
};
/**************************************************************************

   DllMain

**************************************************************************/

extern "C" BOOL WINAPI DllMain(  HINSTANCE hInstance, 
                                 DWORD dwReason, 
                                 LPVOID lpReserved)
{
switch(dwReason)
   {
   case DLL_PROCESS_ATTACH:
       InitCommonControls();
      g_hInst = hInstance;
      break;

   case DLL_PROCESS_DETACH:
      g_hInst = hInstance;
      break;
   }
   
return TRUE;
}                                 

/**************************************************************************

   DllCanUnloadNow

**************************************************************************/

STDAPI DllCanUnloadNow(void)
{
int   i;

i = 1;

return (g_DllRefCount == 0) ? S_OK : S_FALSE;
}

/**************************************************************************

   DllGetClassObject

**************************************************************************/

STDAPI DllGetClassObject( REFCLSID rclsid, 
                                    REFIID riid, 
                                    LPVOID *ppReturn)
{
*ppReturn = NULL;

//if we don't support this classid, return the proper error code
if(!IsEqualCLSID(rclsid, CLSID_PropSheetExt))
   return CLASS_E_CLASSNOTAVAILABLE;
   
//create a CClassFactory object and check it for validity
CClassFactory *pClassFactory = new CClassFactory();
if(NULL == pClassFactory)
   return E_OUTOFMEMORY;
   
//get the QueryInterface return for our return value
HRESULT hResult = pClassFactory->QueryInterface(riid, ppReturn);

//call Release to decement the ref count - creating the object set it to one 
//and QueryInterface incremented it - since its being used externally (not by 
//us), we only want the ref count to be 1
pClassFactory->Release();

//return the result from QueryInterface
return hResult;
}

/**************************************************************************

   DllRegisterServer

**************************************************************************/

typedef struct{
   HKEY  hRootKey;
   LPTSTR lpszSubKey;
   LPTSTR lpszValueName;
   LPTSTR lpszData;
}REGSTRUCT, *LPREGSTRUCT;

//register the CLSID entries
REGSTRUCT ClsidEntries[] = {  HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s"), NULL,                                      TEXT("Security Context Menu Extension"),
                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\InprocServer32"), NULL,                                      TEXT("%s"),
                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Apartment"),
//                              HKEY_CLASSES_ROOT,   TEXT(".ext"),                                 NULL,                            TEXT("StrFile"),    Specific extension
//                              HKEY_CLASSES_ROOT,   TEXT("*\\ShellEx\\PropertySheetHandlers\\%s"), NULL,        TEXT(""),                All files
                              HKEY_CLASSES_ROOT, TEXT("Directory\\ShellEx\\PropertySheetHandlers\\%s"), NULL,        TEXT(""),
                              NULL,                NULL,                                                NULL,                   NULL};


STDAPI DllRegisterServer(void)
{
int      i;
HKEY     hKey;
LRESULT  lResult;
DWORD    dwDisp;
TCHAR    szSubKey[MAX_PATH];
TCHAR    szCLSID[MAX_PATH];
TCHAR    szModule[MAX_PATH];
LPWSTR   pwsz;

//get the CLSID in string form
StringFromIID(CLSID_PropSheetExt, &pwsz);

if(pwsz)
   {
   WideCharToLocal(szCLSID, pwsz, ARRAYSIZE(szCLSID));

   //free the string
   LPMALLOC pMalloc;
   CoGetMalloc(1, &pMalloc);
   if(pMalloc)
      {
      pMalloc->Free(pwsz);
      pMalloc->Release();
      }
   }

//get this DLL's path and file name
GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule));

for(i = 0; ClsidEntries[i].hRootKey; i++)
   {
   //Create the sub key string.
   wsprintf(szSubKey, ClsidEntries[i].lpszSubKey, szCLSID);

   lResult = RegCreateKeyEx(  ClsidEntries[i].hRootKey,
                              szSubKey,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);
   
   if(NOERROR == lResult)
      {
      TCHAR szData[MAX_PATH] = TEXT("");

      //if necessary, create the value string
      wsprintf(szData, ClsidEntries[i].lpszData, szModule);
   
      lResult = RegSetValueEx(   hKey,
                                 ClsidEntries[i].lpszValueName,
                                 0,
                                 REG_SZ,
                                 (LPBYTE)szData,
                                 lstrlen(szData) + 1);
      
      RegCloseKey(hKey);
      }
   else
      return SELFREG_E_CLASS;
   }

//If running on NT, register the extension as approved.
OSVERSIONINFO  osvi;

osvi.dwOSVersionInfoSize = sizeof(osvi);
GetVersionEx(&osvi);

if(VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
   {
   lstrcpy(szSubKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"));

   lResult = RegCreateKeyEx(  HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);

   if(NOERROR == lResult)
      {
      TCHAR szData[MAX_PATH];

      //Create the value string.
      lstrcpy(szData, TEXT("Security Context Menu Extension"));

      lResult = RegSetValueEx(   hKey,
                                 szCLSID,
                                 0,
                                 REG_SZ,
                                 (LPBYTE)szData,
                                 lstrlen(szData) + 1);
      
      RegCloseKey(hKey);
      }
   else
      return SELFREG_E_CLASS;
   }

    // Chameleon Server constants
    lResult = RegCreateKeyEx(  HKEY_LOCAL_MACHINE,
                              tszSubKey,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey,
                              &dwDisp);

    if(NOERROR == lResult)
    {
        for (int ind = 0; ind < sizeof(ptszValue) / sizeof(ptszValue[0]); ind++)
        {
            lResult = RegSetValueEx(hKey,
                ptszValue[ind],
                0,
                REG_SZ,
                (LPBYTE)ptszData[ind],
                lstrlen(ptszData[ind]) + 1);
        }
        RegCloseKey(hKey);
    }
    else
      return SELFREG_E_CLASS;

    return S_OK;
}


STDAPI DllUnregisterServer(void)
{
int      i;
LRESULT  lResult;
TCHAR    szSubKey[MAX_PATH];
TCHAR    szCLSID[MAX_PATH];
TCHAR    szModule[MAX_PATH];
LPWSTR   pwsz;

//get the CLSID in string form
StringFromIID(CLSID_PropSheetExt, &pwsz);

if(pwsz)
   {
   WideCharToLocal(szCLSID, pwsz, ARRAYSIZE(szCLSID));

   //free the string
   LPMALLOC pMalloc;
   CoGetMalloc(1, &pMalloc);
   if(pMalloc)
      {
      pMalloc->Free(pwsz);
      pMalloc->Release();
      }
   }

//get this DLL's path and file name
GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule));

for(i = 0; ClsidEntries[i].hRootKey; i++)
   {
   //Create the sub key string.
   wsprintf(szSubKey, ClsidEntries[i].lpszSubKey, szCLSID);

   lResult = RegDeleteKey(  ClsidEntries[i].hRootKey,
                              szSubKey);   // Review Yury: In case we want to run it on NT we have to recursively enumerate the subkeys and delete them individually
   
   if(NOERROR != lResult)
      return SELFREG_E_CLASS;
   }

    //Review Yury: If running on NT, unregister the extension as approved.

    // Chameleon Server constants
    lResult = RegDeleteKey(  HKEY_LOCAL_MACHINE,
                              tszSubKey);

    if(NOERROR != lResult)
      return SELFREG_E_CLASS;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////
//
// IClassFactory implementation
//

/**************************************************************************

   CClassFactory::CClassFactory

**************************************************************************/

CClassFactory::CClassFactory()
{
m_ObjRefCount = 1;
g_DllRefCount++;
}

/**************************************************************************

   CClassFactory::~CClassFactory

**************************************************************************/

CClassFactory::~CClassFactory()
{
g_DllRefCount--;
}

/**************************************************************************

   CClassFactory::QueryInterface

**************************************************************************/

STDMETHODIMP CClassFactory::QueryInterface(  REFIID riid, 
                                             LPVOID FAR * ppReturn)
{
*ppReturn = NULL;

if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = (LPUNKNOWN)(LPCLASSFACTORY)this;
   }
   
if(IsEqualIID(riid, IID_IClassFactory))
   {
   *ppReturn = (LPCLASSFACTORY)this;
   }   

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

/**************************************************************************

   CClassFactory::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CClassFactory::AddRef()
{
return ++m_ObjRefCount;
}


/**************************************************************************

   CClassFactory::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CClassFactory::Release()
{
if(--m_ObjRefCount == 0)
   delete this;
   
return m_ObjRefCount;
}

/**************************************************************************

   CClassFactory::CreateInstance

**************************************************************************/

STDMETHODIMP CClassFactory::CreateInstance(  LPUNKNOWN pUnknown, 
                                             REFIID riid, 
                                             LPVOID FAR * ppObject)
{
*ppObject = NULL;

if(pUnknown != NULL)
   return CLASS_E_NOAGGREGATION;

//add implementation specific code here

CShellPropSheetExt *pShellExt = new CShellPropSheetExt;
if(NULL == pShellExt)
   return E_OUTOFMEMORY;
  
//get the QueryInterface return for our return value
HRESULT hResult = pShellExt->QueryInterface(riid, ppObject);

//call Release to decement the ref count
pShellExt->Release();

//return the result from QueryInterface
return hResult;

}

/**************************************************************************

   CClassFactory::LockServer

**************************************************************************/

STDMETHODIMP CClassFactory::LockServer(BOOL)
{
return E_NOTIMPL;
}

/**************************************************************************

   CShellPropSheetExt::CShellPropSheetExt()

**************************************************************************/

CShellPropSheetExt::CShellPropSheetExt()
{
    m_uiUser = 0;
    m_ObjRefCount = 1;
    g_DllRefCount++;
    m_pSAUserInfo = NULL;//    m_pIWbemServices = NULL;
    m_fEveryone = FALSE;
    m_szPath[0] = _T('\0');
    m_fChanged = FALSE;
    m_fHasAccess = FALSE;
}

/**************************************************************************

   CShellPropSheetExt::~CShellPropSheetExt()

**************************************************************************/

CShellPropSheetExt::~CShellPropSheetExt()
{
    g_DllRefCount--;
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CShellPropSheetExt::QueryInterface

**************************************************************************/

STDMETHODIMP CShellPropSheetExt::QueryInterface(   REFIID riid, 
                                                LPVOID FAR * ppReturn)
{
*ppReturn = NULL;

//IUnknown
if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = (LPVOID)this;
   }

//IShellExtInit
if(IsEqualIID(riid, IID_IShellExtInit))
   {
   *ppReturn = (LPSHELLEXTINIT)this;
   }   

//IShellPropSheetExt
if(IsEqualIID(riid, IID_IShellPropSheetExt))
   {
   *ppReturn = (LPSHELLPROPSHEETEXT)this;
   }   

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

/**************************************************************************

   CShellPropSheetExt::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CShellPropSheetExt::AddRef()
{
return ++m_ObjRefCount;
}


/**************************************************************************

   CShellPropSheetExt::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CShellPropSheetExt::Release()
{
if(--m_ObjRefCount == 0)
   delete this;
   
return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IShellExtInit Implementation
//

/**************************************************************************

    CShellPropSheetExt::EnumUsers()

  **************************************************************************/

void CShellPropSheetExt::EnumUsers(HWND hWnd)
{
    if (!m_pSAUserInfo)
        return;

    HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);

    HRESULT  hRes;

    BSTR         *lpbstrSAUserNames;
    VARIANT_BOOL *vboolIsSAUserAdmin;
    PSID *ppsidSAUsers;
    LONG *ppsidSAUsersLength;
    DWORD        dwNumSAUsers;

    dwNumSAUsers = 0;
    hRes = GetUserList(m_pSAUserInfo, 
                     &lpbstrSAUserNames, 
                     &vboolIsSAUserAdmin, 
                     &ppsidSAUsers,  
                     &ppsidSAUsersLength,  
                     &dwNumSAUsers);
    

    _ASSERTE(SUCCEEDED(hRes)) ;
    if (!(SUCCEEDED(hRes)))
        return ;

    TCHAR tcName[100];    // Review Yury: What is size of the name
    TCHAR szPathChank[MAX_PATH];
    
    _bstr_t bsDirPath("");
//    bsDirPath += "\"";
    HKEY hKey;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("Software\\Microsoft\\ServerAppliance"), 
        0,
        KEY_READ,
        &hKey) != ERROR_SUCCESS)
        return ;

    DWORD dwcData = sizeof(m_tszDocuments);
    if (RegQueryValueEx(hKey, 
        "Documents", 
        0, 
        NULL, 
        (LPBYTE)m_tszDocuments,
        &dwcData) != ERROR_SUCCESS)
        return ;

    dwcData = sizeof(m_tszShare);
    if (RegQueryValueEx(hKey, 
        "Share", 
        0, 
        NULL, 
        (LPBYTE)m_tszShare,
        &dwcData) != ERROR_SUCCESS)
        return ;

    RegCloseKey(hKey);
    // Convert share to local server path
    bsDirPath += m_tszDocuments;    // Temporary, till I know how to get local path for the share
    LPTSTR szPath;
    if (_tcsnccmp(m_szPath, TEXT("\\\\"), 2))
        szPath = m_szPath + sizeof(_T("G:"));    // Skip network dis name
    else
        szPath = m_szPath + lstrlen(m_tszShare);    // Skip share name

    for (LPTSTR ptWack = szPath, ptWackTmp = szPath; ptWack; )
    {
        ptWackTmp = ptWack;
        ptWack = _tcschr(ptWack, _T('\\'));
        if (!ptWack)
        {
            _tcscpy(szPathChank, ptWackTmp);
            bsDirPath += "\\";
            bsDirPath += szPathChank;
        }
        else
        {
            _tcsncpy(szPathChank, ptWackTmp, ptWack - ptWackTmp);
            szPathChank[ptWack - ptWackTmp] = _T('\0');
            ptWack++;
            bsDirPath += "\\";
            bsDirPath += szPathChank;
        }
    }
    m_bsPath = bsDirPath;

    VARIANT_BOOL vboolRetVal;
    HRESULT  hResAccess;
    hResAccess = m_pSAUserInfo->DoIHaveAccess(m_bsPath, &vboolRetVal);

    if (FAILED(hResAccess))
//        if (hResAccess == E_ACCESSDENIED && vboolRetVal == VARIANT_FALSE)
        m_fHasAccess = FALSE;
    else
        m_fHasAccess = TRUE;

    for (int indGroup = 0; indGroup <= 1; indGroup++)
    {
        for (DWORD indUser = 0; indUser < dwNumSAUsers; indUser++)
        {
            if (indGroup > 0)
            {
                // Set the administrator's checkmarks
                if (vboolIsSAUserAdmin[indUser])
                {
                    // Set grayed checked box
                    m_CheckList.Mark(hWndList, indUser, GRAYCHECKED);
                }
            }
            else if (SUCCEEDED(hRes)) 
            {
                // Add the user to the output listbox.
                WideCharToLocal(tcName,lpbstrSAUserNames[indUser], ARRAYSIZE(tcName));
                if (_tcsicmp(tcName, TEXT("Domain Users")))
                {
                    // Eliminate Domain Users. Review Yury: Use m_pSidDomainUsers to do that after StringFromSid is fixed.
                    m_CheckList.AddString(hWndList, tcName, ppsidSAUsers[indUser], ppsidSAUsersLength[indUser], BLANK);
                }
            }
        } 
        if (indGroup == 0)
        {
            // Set checkmarks 
            hRes = GetFilePermissions(hWnd);
            _ASSERTE(SUCCEEDED(hRes));
            if (!SUCCEEDED(hRes))
                return;
        }
    } // end of groups

    // Clean up
    BOOL fRes = FALSE;
    fRes = HeapFree(GetProcessHeap(), 0, ppsidSAUsers);
    _ASSERTE(fRes);
    fRes = HeapFree(GetProcessHeap(), 0, ppsidSAUsersLength);
    _ASSERTE(fRes);
    fRes = HeapFree(GetProcessHeap(), 0, lpbstrSAUserNames);
    _ASSERTE(fRes);
    fRes = HeapFree(GetProcessHeap(), 0, vboolIsSAUserAdmin);
    _ASSERTE(fRes);

    // If we user has no access show only admins
    int cUserCount = ListView_GetItemCount(hWndList);
    for (int indUser = 0; !m_fHasAccess && indUser < cUserCount; indUser++)
    {
        if (m_CheckList.GetState(hWndList, indUser) == BLANK)
        {
            ListView_DeleteItem(hWndList, indUser);
            indUser--;
            cUserCount--;
        }
    }
    m_CheckList.InitFinish(hWndList);
    // Done with this enumerator.
}


/**************************************************************************

    CShellPropSheetExt::GetFilePermissions()

  **************************************************************************/

HRESULT CShellPropSheetExt::GetFilePermissions(HWND hWnd)
{
    if (!m_pSAUserInfo)
        return E_FAIL;

    PSID *ppsidAAUsers;
    LONG *ppsidAAUsersLength;
    DWORD dwNumAASids;
    SAFEARRAY    *psaAASids;
    VARIANT_BOOL vboolRes;
    VARIANT      vAASids;
    LONG         lStartAASids, lEndAASids, lCurrent;
    HRESULT      hr;

    dwNumAASids = 0;
    VariantInit(&vAASids);
    hr = m_pSAUserInfo->GetFileAccessAllowedAces(m_bsPath,
                                               &vAASids,
                                               &vboolRes);
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;

    psaAASids = V_ARRAY(&vAASids);
    _ASSERTE(V_VT(&vAASids) == (VT_ARRAY | VT_VARIANT));
    if (V_VT(&vAASids) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    hr = SafeArrayGetLBound( psaAASids, 1, &lStartAASids );
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    
    hr = SafeArrayGetUBound( psaAASids, 1, &lEndAASids );
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    
    dwNumAASids = lEndAASids - lStartAASids + 1;
    ppsidAAUsers = (PSID *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwNumAASids * sizeof(PSID));
    _ASSERTE(ppsidAAUsers);
    if (ppsidAAUsers == NULL)
        return E_OUTOFMEMORY;

    ppsidAAUsersLength = (LONG *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwNumAASids * sizeof(LONG));
    _ASSERTE(ppsidAAUsersLength);
    if (ppsidAAUsersLength == NULL)
        return E_OUTOFMEMORY;

    VARIANT vAASid;

    for(lCurrent = lStartAASids; lCurrent <= lEndAASids; lCurrent++)
    {
        VariantInit(&vAASid);
        hr = SafeArrayGetElement( psaAASids, &lCurrent, &vAASid );
        _ASSERTE(!FAILED(hr));
        if( FAILED(hr) )
            return hr;
        
        hr = UnpackSidFromVariant(&vAASid, &(ppsidAAUsers)[lCurrent], &(ppsidAAUsersLength[lCurrent]));
        _ASSERTE(!FAILED(hr));
        if (FAILED(hr))
            return hr;

//        BOOL fRes = IsValidSid((*ppsidAAUsers)[lCurrent]);
//        _ASSERTE(fRes);
//        if (fRes == FALSE)
//            return E_INVALIDARG;

        HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
        PSID pSID;
        LONG lenghSid;
        DWORD dwNumSAUsers = ListView_GetItemCount(hWndList);

        for (DWORD indUser = 0; indUser < dwNumSAUsers; indUser++)
        {
            m_CheckList.GetSID(hWndList, indUser, &pSID, &lenghSid);
            if (UserSidFound(pSID, lenghSid, ppsidAAUsers, ppsidAAUsersLength, dwNumAASids) == VARIANT_TRUE)
                m_CheckList.Mark(hWndList, indUser, CHECKED);
        }

        // Check if Everybody sid is set
        if (UserSidFound(g_pSidEverybody, g_pSidEverybodyLenght, ppsidAAUsers, ppsidAAUsersLength, dwNumAASids) == VARIANT_TRUE)
            m_fEveryone = TRUE;
    }

    // Clean up
    BOOL fRes = FALSE;
    for(DWORD i=0; i<dwNumAASids; i++)
    {
        fRes = HeapFree(GetProcessHeap(), 0, ppsidAAUsers[i]);
        _ASSERTE(fRes);
    }
    fRes = HeapFree(GetProcessHeap(), 0, ppsidAAUsers);
    _ASSERTE(fRes);


    return S_OK;
}


/**************************************************************************

    CShellPropSheetExt::SetFilePermissions()

  **************************************************************************/

HRESULT CShellPropSheetExt::SetFilePermissions(HWND hWnd)
{
    DWORD indUser, indUserAcess;
    DWORD       dwNumSAUsers = 0;
    VARIANT      vArrSids;
    HRESULT      hr;

    HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
    dwNumSAUsers = ListView_GetItemCount(hWndList);

    VariantInit(&vArrSids);
    V_VT(&vArrSids) = VT_ARRAY | VT_VARIANT;

    SAFEARRAYBOUND bounds;
    bounds.cElements = (ULONG)dwNumSAUsers + 2; 
    bounds.lLbound   = 0;

    SAFEARRAY *psaSids = NULL;
    SAFEARRAY *psaUserSid = NULL;

    psaSids = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    _ASSERTE(psaSids);
    if (psaSids == NULL)
        return E_OUTOFMEMORY;

    
    for(indUser=0, indUserAcess = 0; indUser < dwNumSAUsers; indUser++)
    {
        if (m_CheckList.GetState(hWndList, indUser) == CHECKED)
        {
            VARIANT  *pVarSid = NULL;
            PSID pSID = NULL;
            LONG lengthSID;
            
            m_CheckList.GetSID(hWndList, indUser, &pSID, &lengthSID);
            hr = PackSidInVariant(&pVarSid, pSID, lengthSID);
            _ASSERTE(!FAILED(hr));
            if (FAILED(hr))
            {
                SafeArrayDestroy(psaSids);
                psaUserSid = V_ARRAY(pVarSid);
                SafeArrayDestroy(psaUserSid);
                HeapFree(GetProcessHeap(), 0, pVarSid);
                return hr;
            }
            hr = SafeArrayPutElement(psaSids, (LONG *)&indUserAcess, (LPVOID)pVarSid);
            _ASSERTE(!FAILED(hr));
            if (FAILED(hr))
            {
                SafeArrayDestroy(psaSids);
                psaUserSid = V_ARRAY(pVarSid);
                SafeArrayDestroy(psaUserSid);
                HeapFree(GetProcessHeap(), 0, pVarSid);
                return hr;
            }
            psaUserSid = V_ARRAY(pVarSid);
            SafeArrayDestroy(psaUserSid);
            HeapFree(GetProcessHeap(), 0, pVarSid);
            indUserAcess++;
        }
    }

    VARIANT  *pVarSid = NULL;

    if (m_fEveryone)
    {
        hr = PackSidInVariant(&pVarSid, g_pSidEverybody, g_pSidEverybodyLenght/*ppsidSAUsers[dwNumSAUsers+1]*/);
        _ASSERTE(!FAILED(hr));
        if (FAILED(hr))
        {
            SafeArrayDestroy(psaSids);
            HeapFree(GetProcessHeap(), 0, pVarSid);
            return hr;
        }
        hr = SafeArrayPutElement(psaSids, (LONG *)&indUserAcess, (LPVOID)pVarSid);
        _ASSERTE(!FAILED(hr));
        if (FAILED(hr))
        {
            SafeArrayDestroy(psaSids);
            HeapFree(GetProcessHeap(), 0, pVarSid);
            return hr;
        }
        HeapFree(GetProcessHeap(), 0, pVarSid);
        indUserAcess++;
    }

    // Administrators always should have access
    hr = PackSidInVariant(&pVarSid, g_pSidAdmins, g_pSidAdminsLenght/*ppsidSAUsers[dwNumSAUsers+1]*/);
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
    {
        SafeArrayDestroy(psaSids);
        HeapFree(GetProcessHeap(), 0, pVarSid);
        return hr;
    }
    hr = SafeArrayPutElement(psaSids, (LONG *)&indUserAcess, (LPVOID)pVarSid);
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
    {
        SafeArrayDestroy(psaSids);
        HeapFree(GetProcessHeap(), 0, pVarSid);
        return hr;
    }
    HeapFree(GetProcessHeap(), 0, pVarSid);
    indUserAcess++;

    bounds.cElements = (ULONG)indUserAcess; 
    SafeArrayRedim(psaSids, &bounds);
    
    V_ARRAY(&vArrSids) = psaSids;
    VARIANT_BOOL vboolRetVal;
    hr = m_pSAUserInfo->SetFileAccessAllowedAces(m_bsPath,
                                               &vArrSids,
                                               &vboolRetVal);
    _ASSERTE(!FAILED(hr));
    if (FAILED(hr))
        return hr;
    else 
        m_fChanged = FALSE;

    SafeArrayDestroy(psaSids);
    VariantClear(&vArrSids);
    return S_OK;
}

/**************************************************************************

    CShellPropSheetExt::Connect()

  **************************************************************************/

BOOL CShellPropSheetExt::Connect()
{
    BOOL bRet  = FALSE;
    HRESULT  hRes;
    HKEY hKey = 0;
    DWORD dwType = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("Software\\Microsoft\\ServerAppliance"), 
        0,
        KEY_READ,
        &hKey) != ERROR_SUCCESS)
        return FALSE;

    DWORD dwcData = sizeof(m_tszDomainServer);
    if (RegQueryValueEx(hKey, 
        TEXT("ServerName"), 
        0, 
        &dwType, 
        (LPBYTE)m_tszDomainServer,
        &dwcData) != ERROR_SUCCESS)
        return FALSE;

    RegCloseKey(hKey);

    COSERVERINFO serverInfo;

    CoInitialize(NULL);
    serverInfo.dwReserved1 = 0;
    serverInfo.dwReserved2 = 0;
    _bstr_t bsDomainSevrer("\\\\");
    bsDomainSevrer += m_tszDomainServer;
    serverInfo.pwszName    = bsDomainSevrer.copy();//SysAllocString(L"\\\\BALAJIB_1");
    serverInfo.pAuthInfo   = NULL;

    MULTI_QI qi = {&IID_ISAUserInfo, NULL, 0};

    hRes = CoCreateInstanceEx(CLSID_SAUserInfo,
                            NULL,
                            CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
                            &serverInfo,
                            1,
                            &qi);

    _ASSERTE(SUCCEEDED(hRes) && SUCCEEDED(qi.hr));
    if (SUCCEEDED(hRes) && SUCCEEDED(qi.hr))
    {
        m_pSAUserInfo = (ISAUserInfo *)qi.pItf;
        
        hRes = CoSetProxyBlanket((IUnknown*)m_pSAUserInfo,
                       RPC_C_AUTHN_WINNT,
                        RPC_C_AUTHZ_NONE,                           
                       NULL,
                       RPC_C_AUTHN_LEVEL_PKT,
                       RPC_C_IMP_LEVEL_IMPERSONATE,
                       NULL,
                       EOAC_NONE);

        if (SUCCEEDED(hRes))
            bRet = TRUE;
    }

    return bRet;
}


/**************************************************************************

    CShellPropSheetExt::Save()

  **************************************************************************/

void CShellPropSheetExt::Save(HWND hWnd)
{
    HRESULT      hr;

    hr = SetFilePermissions(hWnd);
    _ASSERTE (!FAILED(hr));
}


/**************************************************************************

   CShellPropSheetExt::CleanUp

**************************************************************************/

void CShellPropSheetExt::CleanUp()
{
    BOOL fRes = FALSE;
    m_pSAUserInfo->Release();

    if (g_pSidEverybody)
    {
        fRes = HeapFree(GetProcessHeap(), 0, g_pSidEverybody);
        _ASSERTE(fRes);
        g_pSidEverybody = NULL;
    }
    if (g_pSidAdmins)
    {
        fRes = HeapFree(GetProcessHeap(), 0, g_pSidAdmins);
        _ASSERTE(fRes);
        g_pSidAdmins = NULL;
    }
}



/**************************************************************************

   CShellPropSheetExt::IsChamelon()

**************************************************************************/
BOOL CShellPropSheetExt::IsChamelon(LPTSTR szPath)
{
    // Review Yury: use WNetGetConnection instead.
    TCHAR szPathTmp[MAX_PATH];
//    TCHAR szNetwork[MAX_PATH + 4] = "Network\\";
    TCHAR szSubKeyRemotePathNT[MAX_PATH] = TEXT("Network\\");
    TCHAR szSubKeyRemotePathWindows[MAX_PATH] = TEXT("Network\\Persistent\\");
    _tcsncpy(szPathTmp, szPath, ARRAYSIZE(szPathTmp));
    if (PathStripToRoot(szPathTmp) && GetDriveType(szPathTmp) == DRIVE_REMOTE)
    {
        HKEY     hKey;
        LRESULT  lResult = ERROR_SUCCESS;
        LPTSTR pszSubKey = NULL;
        szPathTmp[1] = _T('\0');    // We need only letter

        if (IsNT())
            pszSubKey = szSubKeyRemotePathNT;
        else
            pszSubKey = szSubKeyRemotePathWindows;

        _tcscat(pszSubKey, szPathTmp);
        lResult = RegOpenKeyEx(HKEY_CURRENT_USER, 
            pszSubKey, 
            0, 
            KEY_READ,
            &hKey);
        _ASSERTE(lResult == ERROR_SUCCESS);
        if(lResult != ERROR_SUCCESS)
           return FALSE;

        //create an array to put our data in
        TCHAR szShare[MAX_PATH];
        DWORD dwType;
        DWORD dwSize = sizeof(szShare);
        lResult = RegQueryValueEx( hKey,
                                   TEXT("RemotePath"),
                                   NULL,
                                   &dwType,
                                   (LPBYTE)szShare,
                                   &dwSize);
        _ASSERTE(lResult == ERROR_SUCCESS);
        RegCloseKey(hKey);
        if(lResult != ERROR_SUCCESS)
           return FALSE;

        if (!_tcsicmp(szShare, TEXT(CHAMELEON_SHARE)))
            return TRUE;
        else
            return FALSE;
    }
    else if (PathIsUNC(szPath))
    {
        return TRUE;
    }
    else
        return FALSE;
}    

/**************************************************************************

   CShellPropSheetExt::Initialize()

**************************************************************************/

STDMETHODIMP CShellPropSheetExt::Initialize( LPCITEMIDLIST pidlFolder,
                                             LPDATAOBJECT lpDataObj,
                                             HKEY  hKeyProgId)
{
STGMEDIUM   medium;
FORMATETC   fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
HRESULT     hResult = E_FAIL;
TCHAR szPath[MAX_PATH];
BOOL fResult = FALSE;

// OLE initialization. This is 'lighter' than OleInitialize()
//  which also setups DnD, etc.
if(FAILED(CoInitialize(NULL))) 
   return E_FAIL;

if(NULL == lpDataObj)
   return E_INVALIDARG;

if(FAILED(lpDataObj->GetData(&fe, &medium)))
   return E_FAIL;

//get the file name from the HDROP
UINT  uCount = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0);
DragQueryFile((HDROP)medium.hGlobal, 0, szPath, MAX_PATH);
_tcsncpy(m_szPath, szPath, ARRAYSIZE(m_szPath));
#ifdef USE_FILE_ACCESS_TO_CHECK_PERMISSION
HANDLE hFolder = CreateFile(m_szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_ATTRIBUTE_NORMAL, NULL);
//WIN32_FIND_DATA FindFileData;
//HANDLE hFolder = FindFirstFile(szPath, &FindFileData );    // This doesn't work because we can find the foldre even we don't have permision
if (hFolder != INVALID_HANDLE_VALUE)
{
    CloseHandle(hFolder);
    m_fHasAccess = TRUE;
}
else
{
    DWORD dwError = GetLastError();
    if (dwError == ERROR_ACCESS_DENIED)
        m_fHasAccess = FALSE;
    else
        m_fHasAccess = TRUE;
}
#endif USE_FILE_ACCESS_TO_CHECK_PERMISSION
    
//if(uCount == 1 && ((PathStripToRoot(szPath) && GetDriveType(szPath) == DRIVE_REMOTE) || PathIsUNC(szPath)))
if (uCount == 1 && IsChamelon(szPath))
    hResult = S_OK;
else
    return E_FAIL;

if (!Connect())
   return E_FAIL;

ReleaseStgMedium(&medium);

return hResult;
}

///////////////////////////////////////////////////////////////////////////
//
// IShellPropSheetExt Implementation
//

/**************************************************************************

   CShellPropSheetExt::AddPages()

**************************************************************************/

STDMETHODIMP CShellPropSheetExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
PROPSHEETPAGE  psp;
HPROPSHEETPAGE hPage;

psp.dwSize        = sizeof(psp);
psp.dwFlags       = PSP_USEREFPARENT | PSP_USETITLE | PSP_USECALLBACK;
psp.hInstance     = g_hInst;
psp.pszTemplate   = MAKEINTRESOURCE(IDD_PAGEDLG);
psp.hIcon         = 0;
psp.pszTitle      = TEXT("Security");
psp.pfnDlgProc    = PageDlgProc;
psp.pcRefParent   = &g_DllRefCount;
psp.pfnCallback   = PageCallbackProc;
psp.lParam        = (LPARAM)this;

hPage = CreatePropertySheetPage(&psp);
            
if(hPage) 
   {
   if(lpfnAddPage(hPage, lParam))
      {
      //keep this object around until the page is released in PageCallbackProc
      this->AddRef();
      return S_OK;
      }
   else
      {
      DestroyPropertySheetPage(hPage);
      }

   }
else
   {
   return E_OUTOFMEMORY;
   }

return E_FAIL;
}

/**************************************************************************

   CShellPropSheetExt::ReplacePage()

**************************************************************************/

STDMETHODIMP CShellPropSheetExt::ReplacePage(   UINT uPageID, 
                                             LPFNADDPROPSHEETPAGE lpfnAddPage, 
                                             LPARAM lParam)
{
return E_NOTIMPL;
}


/**************************************************************************

   CShellPropSheetExt::NoAccessUpdateView()

**************************************************************************/

void CShellPropSheetExt::NoAccessUpdateView(HWND hWnd)
{
    HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
    HWND hWndButGroup = GetDlgItem(hWnd, IDC_BUTTONGROUP);
    ShowWindow(hWndButGroup, SW_HIDE);
    HWND hWndButEveryone = GetDlgItem(hWnd, IDC_EVERYONE);
    ShowWindow(hWndButEveryone, SW_HIDE);
    HWND hWndButSelected = GetDlgItem(hWnd, IDC_SELECTUSERS);
    ShowWindow(hWndButSelected, SW_HIDE);
    HWND hWndAdminMessage = GetDlgItem(hWnd, IDC_ADMIN_MESSAGE);
    ShowWindow(hWndAdminMessage, SW_HIDE);
    HWND hWndUserMessage = GetDlgItem(hWnd, IDC_USER_MESSAGE);
    ShowWindow(hWndUserMessage, SW_SHOW);
    EnableWindow(hWndList, FALSE);
}

/**************************************************************************

   CShellPropSheetExt::AccessUpdateView()

**************************************************************************/

void CShellPropSheetExt::AccessUpdateView(HWND hWnd)
{
    HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
    HWND hWndButGroup = GetDlgItem(hWnd, IDC_BUTTONGROUP);
    ShowWindow(hWndButGroup, SW_SHOW);
    HWND hWndButEveryone = GetDlgItem(hWnd, IDC_EVERYONE);
    ShowWindow(hWndButEveryone, SW_SHOW);
    HWND hWndButSelected = GetDlgItem(hWnd, IDC_SELECTUSERS);
    ShowWindow(hWndButSelected, SW_SHOW);
    HWND hWndAdminMessage = GetDlgItem(hWnd, IDC_ADMIN_MESSAGE);
    ShowWindow(hWndAdminMessage, SW_SHOW);
    HWND hWndUserMessage = GetDlgItem(hWnd, IDC_USER_MESSAGE);
    ShowWindow(hWndUserMessage, SW_HIDE);
    EnableWindow(hWndList, TRUE);
}

/**************************************************************************

   PageDlgProc

**************************************************************************/

#define THIS_POINTER_PROP  TEXT("ThisPointerProperty")

INT_PTR CALLBACK CShellPropSheetExt::PageDlgProc(  HWND hWnd, 
                                                   UINT uMsg, 
                                                   WPARAM wParam, 
                                                   LPARAM lParam)
{
switch(uMsg)
{
   case WM_INITDIALOG:
    {
      LPPROPSHEETPAGE pPage = (LPPROPSHEETPAGE)lParam;

      if(pPage)
      {
         CShellPropSheetExt *pExt = (CShellPropSheetExt*)pPage->lParam;

         if(pExt)
         {
            SetProp(hWnd, THIS_POINTER_PROP, (HANDLE)pExt);

            HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
            pExt->m_CheckList.Init(hWndList);
            pExt->EnumUsers(hWnd);

            ListView_SetItemState(hWndList, pExt->m_uiUser, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
            ::SendDlgItemMessage(hWnd, (pExt->m_fEveryone) ? IDC_EVERYONE : IDC_SELECTUSERS, BM_SETCHECK, BST_CHECKED, 0);
            if (!pExt->m_fHasAccess)
                pExt->NoAccessUpdateView(hWnd);
            else 
            {
                pExt->AccessUpdateView(hWnd);
                if (pExt->m_fEveryone)
                    ::EnableWindow(hWndList , FALSE);
            }
         }
      }
    }
    break;
   
   case WM_COMMAND:
       {
           WORD wNotifyCode;
           switch ( wNotifyCode = HIWORD(wParam))
           {
           case BN_CLICKED:
               {
                   CShellPropSheetExt *pExt = (CShellPropSheetExt*)GetProp(hWnd,THIS_POINTER_PROP);
                   if(pExt &&
                       (((int) LOWORD(wParam) == IDC_SELECTUSERS && pExt->m_fEveryone)
                       || ((int) LOWORD(wParam) == IDC_EVERYONE && !pExt->m_fEveryone)))
                   {
                       pExt->m_fEveryone = !pExt->m_fEveryone;
                       HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
                       EnableWindow(hWndList , (pExt->m_fEveryone) ? FALSE : TRUE);
                       PropSheet_Changed(GetParent(hWnd), hWnd);
                       pExt->m_fChanged = TRUE;
                   }
               }
               break;
           }
       }
       break;
    
   case WM_NOTIFY:
     {
       switch (((NMHDR FAR *)lParam)->code)
       {
       case LVN_KEYDOWN:
           {
               LPNMLVKEYDOWN pnm = (LPNMLVKEYDOWN) lParam;
               if (pnm->wVKey == VK_SPACE)
               {
                   // Change the access
                   CShellPropSheetExt *pExt = (CShellPropSheetExt*)GetProp(hWnd,THIS_POINTER_PROP);
                   if (pExt)
                   {
                        HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
                        CHKMARK chk = pExt->m_CheckList.GetState(hWndList, pExt->m_uiUser);
                        CHKMARK chkNew = BLANK;
                        switch (chk)
                        {
                            case BLANK:
                                chkNew = CHECKED;
                            case CHECKED:
                                PropSheet_Changed(GetParent(hWnd), hWnd);
                                pExt->m_CheckList.Mark(hWndList, pExt->m_uiUser, chkNew);
                                pExt->m_fChanged = TRUE;
                                break;
                            default:
                               break;
                        }
                   }
               }
           }
           break;
       case LVN_ITEMCHANGED:
           {
               LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam; 
               if (pnmv->uChanged == LVIF_STATE && pnmv->uNewState & LVIS_SELECTED)
               {
                   CShellPropSheetExt *pExt = (CShellPropSheetExt*)GetProp(hWnd,THIS_POINTER_PROP);
                   pExt->m_uiUser = pnmv->iItem;
               }
           }
           break;
       case NM_CLICK:
           {
               LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam; 
               CShellPropSheetExt *pExt = (CShellPropSheetExt*)GetProp(hWnd,THIS_POINTER_PROP);
               if (pExt)
               {
                   HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
                   RECT recIcon;
                   if (!ListView_GetItemRect(hWndList, pnmv->iItem, &recIcon, LVIR_ICON))
                       break;
                   if (recIcon.right > pnmv->ptAction.x)
                   {
                       HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
                       CHKMARK chk = pExt->m_CheckList.GetState(hWndList, pExt->m_uiUser);
                       CHKMARK chkNew = BLANK;
                        switch (chk)
                        {
                            case BLANK:
                                chkNew = CHECKED;
                            case CHECKED:
                                PropSheet_Changed(GetParent(hWnd), hWnd);
                                pExt->m_CheckList.Mark(hWndList, pExt->m_uiUser, chkNew);
                                pExt->m_fChanged = TRUE;
                                break;
                            default:
                               break;
                        }
                   }
               }
           }
           break;

           case PSN_SETACTIVE:
                break;

           case PSN_APPLY:
              {
                //User has clicked the OK or Apply 
                CShellPropSheetExt *pExt = (CShellPropSheetExt*)GetProp(hWnd,THIS_POINTER_PROP);
               if(pExt && pExt->m_fChanged)
               {
                   pExt->Save(hWnd);
                   if (!pExt->m_fChanged)
                   {
                        VARIANT_BOOL vboolRetVal;
                        HRESULT  hResAccess;
                        if (SUCCEEDED(hResAccess = pExt->m_pSAUserInfo->DoIHaveAccess(pExt->m_bsPath, &vboolRetVal)))
                            pExt->m_fHasAccess = TRUE;
                        else 
                        {
                            // We lost access. Redo the ListView.
                            HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
                            pExt->m_CheckList.Init(hWndList);
                            pExt->EnumUsers(hWnd);
                            pExt->m_fHasAccess = FALSE;
                            pExt->NoAccessUpdateView(hWnd);
                        }
                   }
               }
              }
              break;

           case PSN_QUERYCANCEL:
               break;
        
            default:
                break;
       }
     }
     break;

   case WM_DESTROY:
        CShellPropSheetExt *pExt = (CShellPropSheetExt*)GetProp(hWnd,THIS_POINTER_PROP);
        if (pExt)
        {
            HWND hWndList = GetDlgItem(hWnd, IDC_FILE_LIST);
            // Delete SIDs in here 
//            _bstr_t *pbsSID;
            LV_ITEM lvi;
            ZeroMemory(&lvi, sizeof(lvi));
            lvi.mask = LVIF_PARAM;
            for (int indUser = 0; indUser < ListView_GetItemCount(hWndList); indUser++)
            {
                lvi.iItem = indUser;
                ListView_GetItem(hWndList, &lvi);
//                pbsSID = (_bstr_t *)lvi.lParam;
//                if (pbsSID)
//                {
//                    delete pbsSID;
//                }
            }
            pExt->m_CheckList.OnDestroy(hWndList);
            pExt->m_CheckList.Term();
            RemoveProp(hWnd, THIS_POINTER_PROP);
            pExt->CleanUp();
        }
        break; 
   }

return FALSE;
}


/**************************************************************************

   PageCallbackProc()

**************************************************************************/

UINT CALLBACK CShellPropSheetExt::PageCallbackProc(   HWND hWnd,
                                                      UINT uMsg,
                                                      LPPROPSHEETPAGE ppsp)
{
switch(uMsg)
   {
   case PSPCB_CREATE:
      return TRUE;

   case PSPCB_RELEASE:
      {
      /*
      Release the object. This gets called even if the page dialog was never 
      actually created.
      */
      CShellPropSheetExt *pExt = (CShellPropSheetExt*)ppsp->lParam;

      if(pExt)
         {
         pExt->Release();
         }
      }
      break;
   }

return FALSE;
}

/**************************************************************************

   WideCharToLocal()
   
**************************************************************************/

int WideCharToLocal(LPTSTR pLocal, LPWSTR pWide, DWORD dwChars)
{
*pLocal = 0;

#ifdef UNICODE
lstrcpyn(pLocal, pWide, dwChars);
#else
WideCharToMultiByte( CP_ACP, 
                     0, 
                     pWide, 
                     -1, 
                     pLocal, 
                     dwChars, 
                     NULL, 
                     NULL);
#endif

return lstrlen(pLocal);
}

/**************************************************************************

   LocalToWideChar()
   
**************************************************************************/

int LocalToWideChar(LPWSTR pWide, LPTSTR pLocal, DWORD dwChars)
{
*pWide = 0;

#ifdef UNICODE
lstrcpyn(pWide, pLocal, dwChars);
#else
MultiByteToWideChar( CP_ACP, 
                     0, 
                     pLocal, 
                     -1, 
                     pWide, 
                     dwChars); 
#endif

return lstrlenW(pWide);
}





#ifdef WE_USE_WBEM

/**************************************************************************

   StringFromSid()
   
    Here's a conversion from binary SID to string 
    We need it because of WBEM inconsitency.
    Win32_Account has it as a string and Win32_Trastee as a binary

**************************************************************************/

void StringFromSid( PSID psid, CHString& str )
{
    // Initialize m_strSid - human readable form of our SID
    SID_IDENTIFIER_AUTHORITY *psia = RtlGetSidIdentifierAuthority( psid );
    
    // We assume that only last byte is used (authorities between 0 and 15).
    // Correct this if needed.
    _ASSERTE( psia->Value[0] == 0 &&
        psia->Value[1] ==  0 &&
        psia->Value[2] ==  0 &&
        psia->Value[3] ==  0 &&
        psia->Value[4] == 0 );
    DWORD dwTopAuthority = psia->Value[5];

    str.Format( TEXT("S-1-%d"), dwTopAuthority );
    CHString strSubAuthority;
    UCHAR ucSubAuthorityCount = 0;
    UCHAR *pucTemp = RtlGetSidSubAuthorityCount( psid );
    ucSubAuthorityCount = *pucTemp;
    for ( UCHAR i = 0; i < ucSubAuthorityCount; i++ ) {

        DWORD dwSubAuthority = *( RtlGetSidSubAuthority( psid, i ) );
        strSubAuthority.Format( TEXT("%d"), dwSubAuthority );
        str += "-" + strSubAuthority;
    }
}


/**************************************************************************

   StrToSID()
   
    Here's a conversion from string to  binary SID 
    We need it because of WBEM inconsitency.
    Win32_Account has it as a string and Win32_Trastee as a binary

**************************************************************************/
// for input of the form AAA-BBB-CCC
// will return AAA in token
// and BBB-CCC in str
bool WhackToken(CHString& str, CHString& token)
{
    bool bRet = false;
    if (bRet = !str.IsEmpty())
    {
        int index;

        index = str.Find('-');
 
        if (index == -1)
        {
            // all that's left is the token, we're done
            token = str;
            str.Empty();
        }
        else
        {
            token = str.Left(index);
            str = str.Mid(index+1);
        }
    }
    return bRet;
}


// helper for StrToSID
// takes a string, converts to a SID_IDENTIFIER_AUTHORITY
// returns false if not a valid SID_IDENTIFIER_AUTHORITY
// contents of identifierAuthority are unreliable on failure
bool StrToIdentifierAuthority(const CHString& str, SID_IDENTIFIER_AUTHORITY& identifierAuthority)
{
    bool bRet = false;
    memset(&identifierAuthority, '\0', sizeof(SID_IDENTIFIER_AUTHORITY));

    DWORD duhWord;
    TCHAR* p = NULL;
    CHString localStr(str);

    // per KB article Q13132, if identifier authority is greater than 2**32, it's in hex
    if ((localStr[0] == '0') && localStr.GetLength() > 1 && ((localStr[1] == 'x') || (localStr[1] == 'X')))
    // if it looks hexidecimalish...
    {
        // going to parse this out backwards, chpping two chars off the end at a time
        // first, whack off the 0x
        localStr = localStr.Mid(2);
        
        CHString token;
        int nValue =5;
        
        bRet = true;
        while (bRet && localStr.GetLength() && (nValue > 0))
        {
            token = localStr.Right(2);
            localStr = localStr.Left(localStr.GetLength() -2);
            duhWord = _tcstoul(token, &p, 16);

            // if strtoul succeeds, the pointer is moved
            if (p != (LPCTSTR)token)
                identifierAuthority.Value[nValue--] = (BYTE)duhWord;
            else
                bRet = false;
        }
    }
    else
    // it looks decimalish
    {    
        duhWord = _tcstoul(localStr, &p, 10);

        if (p != (LPCTSTR)localStr)
        // conversion succeeded
        {
            bRet = true;
            identifierAuthority.Value[5] = LOBYTE(LOWORD(duhWord));
            identifierAuthority.Value[4] = HIBYTE(LOWORD(duhWord));
            identifierAuthority.Value[3] = LOBYTE(HIWORD(duhWord));
            identifierAuthority.Value[2] = HIBYTE(HIWORD(duhWord));
        }
    }
        
    return bRet;
}

// a string representation of a SID is assumed to be:
// S-#-####-####-####-####-####-####
// we will enforce only the S ourselves, 
// The version is not checked
// everything else will be handed off to the OS
// caller must free the SID returned
PSID StrToSID(const CHString& sid)
{
    PSID pSid = NULL; 
    if (!sid.IsEmpty() && ((sid[0] == 'S')||(sid[0] == 's')) && (sid[1] == '-'))
    {
        // get a local copy we can play with
        // we'll parse this puppy the easy way
        // by slicing off each token as we find it
        // slow but sure
        // start by slicing off the "S-"
        CHString str(sid.Mid(2));
        CHString token;
        
        SID_IDENTIFIER_AUTHORITY identifierAuthority = {0,0,0,0,0,0};
        BYTE nSubAuthorityCount =0;  // count of subauthorities
        DWORD dwSubAuthority[8]   = {0,0,0,0,0,0,0,0};    // subauthorities
        
        // skip version
        WhackToken(str, token);
        // Grab Authority
        if (WhackToken(str, token))
        {
            DWORD duhWord;
            TCHAR* p = NULL;
            bool bDoIt = false;

            if (StrToIdentifierAuthority(token, identifierAuthority))
            // conversion succeeded
            {
                bDoIt = true;

                // now fill up the subauthorities
                while (bDoIt && WhackToken(str, token))
                {
                    p = NULL;
                    duhWord = _tcstoul(token, &p, 10);
                    
                    if (p != (LPCTSTR)token)
                    {
                        dwSubAuthority[nSubAuthorityCount] = duhWord;
                        bDoIt = (++nSubAuthorityCount <= 8);
                    }
                    else
                        bDoIt = false;
                } // end while WhackToken

                if (bDoIt)
                {
                    if (IsNT())
                        AllocateAndInitializeSid(&identifierAuthority,
                                                 nSubAuthorityCount,
                                              dwSubAuthority[0],                                    
                                              dwSubAuthority[1],                                    
                                              dwSubAuthority[2],                                    
                                              dwSubAuthority[3],                                    
                                              dwSubAuthority[4],                                    
                                              dwSubAuthority[5],                                    
                                              dwSubAuthority[6],                                    
                                              dwSubAuthority[7],
                                              &pSid);
                    else
                        RtlAllocateAndInitializeSid(&identifierAuthority,
                                                 nSubAuthorityCount,
                                              dwSubAuthority[0],                                    
                                              dwSubAuthority[1],                                    
                                              dwSubAuthority[2],                                    
                                              dwSubAuthority[3],                                    
                                              dwSubAuthority[4],                                    
                                              dwSubAuthority[5],                                    
                                              dwSubAuthority[6],                                    
                                              dwSubAuthority[7],
                                              &pSid);
                }
            }
        }
    }
    return pSid;
}


/*++

Routine Description:

    This routine returns the length, in bytes, required to store an SID
    with the specified number of Sub-Authorities.

Arguments:

    SubAuthorityCount - The number of sub-authorities to be stored in the SID.

Return Value:

    ULONG - The length, in bytes, required to store the SID.


--*/
ULONG
RtlLengthRequiredSid (ULONG SubAuthorityCount)
{
    return (8L + (4 * SubAuthorityCount));
}




BOOL WINAPI
RtlAllocateAndInitializeSid(
    PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
     UCHAR SubAuthorityCount,
     ULONG SubAuthority0,
     ULONG SubAuthority1,
     ULONG SubAuthority2,
     ULONG SubAuthority3,
     ULONG SubAuthority4,
     ULONG SubAuthority5,
     ULONG SubAuthority6,
     ULONG SubAuthority7,
    OUT PSID *Sid
    )

/*++

Routine Description:

    This function allocates and initializes a sid with the specified
    number of sub-authorities (up to 8).  A sid allocated with this
    routine must be freed using RtlFreeSid().

Arguments:

    IdentifierAuthority - Pointer to the Identifier Authority value to
        set in the SID.

    SubAuthorityCount - The number of sub-authorities to place in the SID.
        This also identifies how many of the SubAuthorityN parameters
        have meaningful values.  This must contain a value from 0 through
        8.

    SubAuthority0-7 - Provides the corresponding sub-authority value to
        place in the SID.  For example, a SubAuthorityCount value of 3
        indicates that SubAuthority0, SubAuthority1, and SubAuthority0
        have meaningful values and the rest are to be ignored.

    Sid - Receives a pointer to the SID data structure to initialize.

Return Value:

    STATUS_SUCCESS - The SID has been allocated and initialized.

    STATUS_NO_MEMORY - The attempt to allocate memory for the SID
        failed.

    STATUS_INVALID_SID - The number of sub-authorities specified did
        not fall in the valid range for this api (0 through 8).


--*/
{
    PISID ISid;

    if ( SubAuthorityCount > 8 ) {
        return 0;//( STATUS_INVALID_SID );
    }

    ISid = (PISID)HeapAlloc( GetProcessHeap(), 0,
                            RtlLengthRequiredSid(SubAuthorityCount)
                            );
    if (ISid == NULL) {
        return(STATUS_NO_MEMORY);
    }

    ISid->SubAuthorityCount = (UCHAR)SubAuthorityCount;
    ISid->Revision = 1;
    ISid->IdentifierAuthority = *IdentifierAuthority;

    switch (SubAuthorityCount) {

    case 8:
        ISid->SubAuthority[7] = SubAuthority7;
    case 7:
        ISid->SubAuthority[6] = SubAuthority6;
    case 6:
        ISid->SubAuthority[5] = SubAuthority5;
    case 5:
        ISid->SubAuthority[4] = SubAuthority4;
    case 4:
        ISid->SubAuthority[3] = SubAuthority3;
    case 3:
        ISid->SubAuthority[2] = SubAuthority2;
    case 2:
        ISid->SubAuthority[1] = SubAuthority1;
    case 1:
        ISid->SubAuthority[0] = SubAuthority0;
    case 0:
        ;
    }

    (*Sid) = ISid;
    return 1;//( STATUS_SUCCESS );

}


/*++

Routine Description:

    The RtlGetSidIdentifierAuthority function returns the address 
    of the SID_IDENTIFIER_AUTHORITY structure in a specified security identifier (SID). 

Arguments:

    pSid - Receives a pointer to the SID data structure to initialize.

Return Value:

  PSID_IDENTIFIER_AUTHORITY

--*/

PSID_IDENTIFIER_AUTHORITY WINAPI
RtlGetSidIdentifierAuthority(PSID pSid)
{
    PISID ISid = (PISID)pSid;
   _ASSERTE( ISid->SubAuthorityCount <= 8 );
    return &(ISid->IdentifierAuthority);
}

/*++

Routine Description:

The RtlGetSidSubAuthorityCount function returns the address of the field
in a SID structure containing the subauthority count

Arguments:

    pSid - Receives a pointer to the SID data structure to initialize.

Return Value:

    pointer to the subauthority count for the specified SID structure

--*/
 
PUCHAR WINAPI
RtlGetSidSubAuthorityCount (PSID pSid)
{
    PISID ISid = (PISID)pSid;
   _ASSERTE( ISid->SubAuthorityCount <= 8 );
   return &(ISid->SubAuthorityCount);
}


/*++

Routine Description:

    The RtlGetSidSubAuthority function returns the address of a specified 
    subauthority in a SID structure

Arguments:

    pSid - Receives a pointer to the SID data structure to initialize.
    nSubAuthority - Specifies an index value identifying 
    the subauthority array element whose address the function will return. 

Return Value:

  PSID_IDENTIFIER_AUTHORITY

--*/

PDWORD WINAPI
RtlGetSidSubAuthority (PSID pSid, DWORD nSubAuthority)
{
    PISID ISid = (PISID)pSid;
   _ASSERTE( ISid->SubAuthorityCount <= 8 );
   return &(ISid->SubAuthority[nSubAuthority]);
}

#endif WE_USE_WBEM


BOOL IsNT()
{
    OSVERSIONINFO  OsVersionInfo;
    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);
    if ((VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId))// Review Yury: What about Win2000? && (OsVersionInfo.dwMajorVersion == 4))
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\commands.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          Commands.h

   Description:   Defines the private commands for this project.

**************************************************************************/

/**************************************************************************
   global variables and definitions
**************************************************************************/

#define IDM_EXPLORE        1
#define IDM_OPEN           2
#define IDM_NEW            3
#define IDM_NEW_FOLDER     4
#define IDM_NEW_ITEM       5
#define IDM_MODIFY_DATA    6
#define IDM_RENAME         7
#define IDM_DELETE         8
#define IDM_COPY           9
#define IDM_CUT            10
#define IDM_PASTE          11
#define IDM_SEPARATOR      12
#define IDM_VIEW           13
#define IDM_VIEW_LARGE     14
#define IDM_VIEW_SMALL     15
#define IDM_VIEW_LIST      16
#define IDM_VIEW_DETAILS   17

#define IDM_LAST           17

//view menu items
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\contmenu.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/******************************************************************************

   File:          ContMenu.h
   
   Description:   CContextMenu definitions.

******************************************************************************/

#ifndef CONTMENU_H
#define CONTMENU_H

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include "ShlFldr.h"
#include "PidlMgr.h"
#include "resource.h"

/**************************************************************************

   CContextMenu class definition

**************************************************************************/

class CContextMenu : public IContextMenu
{
private:
   DWORD          m_ObjRefCount;
   LPITEMIDLIST   *m_aPidls;
   IMalloc        *m_pMalloc;
   CPidlMgr       *m_pPidlMgr;
   CShellFolder   *m_psfParent;
   UINT           m_uItemCount;
   BOOL           m_fBackground;
   UINT           m_cfPrivateData;
   
public:
   CContextMenu(CShellFolder *psfParent, LPCITEMIDLIST *aPidls = NULL, UINT uItemCount = 0);
   ~CContextMenu();
   
   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IContextMenu methods
   STDMETHODIMP QueryContextMenu(HMENU, UINT, UINT, UINT, UINT);
   STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO);
   STDMETHODIMP GetCommandString(UINT, UINT, LPUINT, LPSTR, UINT);

private:
   LPITEMIDLIST* AllocPidlTable(DWORD);
   VOID FreePidlTable(LPITEMIDLIST*);
   BOOL FillPidlTable(LPCITEMIDLIST*, UINT);
   BOOL DoCopyOrCut(HWND, BOOL);
   BOOL DoPaste(VOID);
   BOOL DoExplore(HWND);
   BOOL DoOpen(HWND);
   STDMETHODIMP DoDelete(VOID);
   STDMETHODIMP DoNewFolder(HWND);
   STDMETHODIMP DoNewItem(HWND);
   VOID DoRename(HWND);
   int DoModifyData(HWND);
   UINT InsertBackgroundItems(HMENU, UINT, UINT);
   UINT InsertItems(HMENU, UINT, UINT, UINT);
};

#define MYCMF_MULTISELECT   0x00010000

#endif// CONTMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\clsfact.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ClsFact.cpp
   
   Description:   Implements CClassFactory.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "ClsFact.h"

/**************************************************************************
   private function prototypes
**************************************************************************/

/**************************************************************************
   global variables
**************************************************************************/

///////////////////////////////////////////////////////////////////////////
//
// IClassFactory implementation
//

/**************************************************************************

   CClassFactory::CClassFactory

**************************************************************************/

CClassFactory::CClassFactory()
{
g_DllRefCount++;
m_ObjRefCount = 1;
}

/**************************************************************************

   CClassFactory::~CClassFactory

**************************************************************************/

CClassFactory::~CClassFactory()
{
g_DllRefCount--;
}

/**************************************************************************

   CClassFactory::QueryInterface

**************************************************************************/

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
*ppReturn = NULL;

if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = this;
   }
   
else if(IsEqualIID(riid, IID_IClassFactory))
   {
   *ppReturn = (IClassFactory*)this;
   }   

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

/**************************************************************************

   CClassFactory::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CClassFactory::AddRef()
{
return ++m_ObjRefCount;
}


/**************************************************************************

   CClassFactory::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CClassFactory::Release()
{
if(--m_ObjRefCount == 0)
   {
   delete this;
   return 0;
   }
   
return m_ObjRefCount;
}

/**************************************************************************

   CClassFactory::CreateInstance

**************************************************************************/

STDMETHODIMP CClassFactory::CreateInstance(  LPUNKNOWN pUnknown, 
                                             REFIID riid, 
                                             LPVOID *ppObject)
{
*ppObject = NULL;

if(pUnknown != NULL)
   return CLASS_E_NOAGGREGATION;

//add implementation specific code here

CShellFolder *pShellFolder = new CShellFolder();
if(NULL == pShellFolder)
   return E_OUTOFMEMORY;
  
//get the QueryInterface return for our return value
HRESULT hResult = pShellFolder->QueryInterface(riid, ppObject);

//call Release to decement the ref count
pShellFolder->Release();

//return the result from QueryInterface
return hResult;
}

/**************************************************************************

   CClassFactory::LockServer

**************************************************************************/

STDMETHODIMP CClassFactory::LockServer(BOOL)
{
return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\clsfact.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ClsFact.h
   
   Description:   CClassFactory definitions.

**************************************************************************/

#ifndef CLASSFACTORY_H
#define CLASSFACTORY_H

#include <windows.h>
#include "ShlFldr.h"
#include "ShlView.h"

/**************************************************************************

   CClassFactory class definition

**************************************************************************/

class CClassFactory : public IClassFactory
{
private:
   DWORD m_ObjRefCount;

public:
   CClassFactory();
   ~CClassFactory();

   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID*);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IClassFactory methods
   STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
   STDMETHODIMP LockServer(BOOL);
};

#endif   //CLASSFACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\dropsrc.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          DropSrc.cpp

   Description:   CDropSource implementation.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "DropSrc.h"

/**************************************************************************

   CDropSource::CDropSource()

**************************************************************************/

CDropSource::CDropSource(void)
{
g_DllRefCount++;

m_ObjRefCount = 1;
}

/**************************************************************************

   CDropSource::~CDropSource()

**************************************************************************/

CDropSource::~CDropSource(void)
{
g_DllRefCount--;
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CDropSource::QueryInterface()

**************************************************************************/

STDMETHODIMP CDropSource::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
*ppReturn = NULL;

//IUnknown
if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = this;
   }

//IDropTarget
else if(IsEqualIID(riid, IID_IDropSource))
   {
   *ppReturn = (IDropSource*)this;
   }

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}

/**************************************************************************

   CDropSource::AddRef()

**************************************************************************/

STDMETHODIMP_(DWORD) CDropSource::AddRef(VOID)
{
return ++m_ObjRefCount;
}

/**************************************************************************

   CDropSource::Release()

**************************************************************************/

STDMETHODIMP_(DWORD) CDropSource::Release(VOID)
{
if(--m_ObjRefCount == 0)
   {
   delete this;
   return 0;
   }
   
return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IDropSource Implementation
//

/**************************************************************************

   CDropSource::QueryContinueDrag()

**************************************************************************/

STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEsc, DWORD dwKeyState)
{
if(fEsc)
   return DRAGDROP_S_CANCEL;

// Make sure the left mouse button is still down
if(!(dwKeyState & MK_LBUTTON))
   return DRAGDROP_S_DROP;

return S_OK;
}

/**************************************************************************

   CDropSource::GiveFeedback()

**************************************************************************/

STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
{
return DRAGDROP_S_USEDEFAULTCURSORS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\contmenu.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ContMenu.cpp
   
   Description:   CContextMenu implementation.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "ContMenu.h"
#include "Commands.h"
#include "ShlView.h"

/**************************************************************************
   global variables
**************************************************************************/

#define MAX_VERB  64

typedef struct {
   TCHAR szVerb[MAX_VERB];
   DWORD dwCommand;
   }VERBMAPPING, FAR *LPVERBMAPPING;

VERBMAPPING g_VerbMap[] = {   TEXT("explore"),     IDM_EXPLORE,
                              TEXT("open"),        IDM_OPEN,
                              TEXT("delete"),      IDM_DELETE,
                              TEXT("rename"),      IDM_RENAME,
                              TEXT("copy"),        IDM_COPY,
                              TEXT("cut"),         IDM_CUT,
                              TEXT("paste"),       IDM_PASTE,
                              TEXT("NewFolder"),   IDM_NEW_FOLDER,
                              TEXT("NewItem"),     IDM_NEW_ITEM,
                              TEXT("ModifyData"),  IDM_MODIFY_DATA,
                              TEXT(""),            (DWORD)-1
                              };

/**************************************************************************

   CContextMenu::CContextMenu()

**************************************************************************/

CContextMenu::CContextMenu(CShellFolder *psfParent, LPCITEMIDLIST *aPidls, UINT uItemCount)
{
g_DllRefCount++;

m_ObjRefCount = 1;
m_aPidls = NULL;
m_uItemCount = 0;
m_fBackground = FALSE;

m_psfParent = psfParent;
if(m_psfParent)
   m_psfParent->AddRef();

SHGetMalloc(&m_pMalloc);
if(!m_pMalloc)
   {
   delete this;
   return;
   }

m_pPidlMgr = new CPidlMgr();

m_uItemCount = uItemCount;

if(m_uItemCount)
   {
   m_aPidls = AllocPidlTable(uItemCount);
   if(m_aPidls)
      {
      FillPidlTable(aPidls, uItemCount);
      }
   }
else
   {
   m_fBackground = TRUE;
   }

m_cfPrivateData = RegisterClipboardFormat(CFSTR_SAMPVIEWDATA);

}

/**************************************************************************

   CContextMenu::~CContextMenu()

**************************************************************************/

CContextMenu::~CContextMenu()
{
if(m_psfParent)
   m_psfParent->Release();

g_DllRefCount--;

//make sure the pidls are freed
if(m_aPidls && m_pMalloc)
   {
   FreePidlTable(m_aPidls);
   }

if(m_pPidlMgr)
   delete m_pPidlMgr;

if(m_pMalloc)
   m_pMalloc->Release();
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CContextMenu::QueryInterface

**************************************************************************/

STDMETHODIMP CContextMenu::QueryInterface(   REFIID riid, 
                                             LPVOID FAR * ppReturn)
{
*ppReturn = NULL;

if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = (LPUNKNOWN)(LPCONTEXTMENU)this;
   }
   
if(IsEqualIID(riid, IID_IContextMenu))
   {
   *ppReturn = (LPCONTEXTMENU)this;
   }   

if(IsEqualIID(riid, IID_IShellExtInit))
   {
   *ppReturn = (LPSHELLEXTINIT)this;
   }   

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

/**************************************************************************

   CContextMenu::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CContextMenu::AddRef()
{
return ++m_ObjRefCount;
}


/**************************************************************************

   CContextMenu::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CContextMenu::Release()
{
if(--m_ObjRefCount == 0)
   delete this;
   
return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IContextMenu Implementation
//

/**************************************************************************

   CContextMenu::QueryContextMenu()

**************************************************************************/

STDMETHODIMP CContextMenu::QueryContextMenu( HMENU hMenu,
                                             UINT indexMenu,
                                             UINT idCmdFirst,
                                             UINT idCmdLast,
                                             UINT uFlags)
{
if(!(CMF_DEFAULTONLY & uFlags))
   {
   if(m_fBackground)
      {
      //add the menu items that apply to the background of the view
      InsertBackgroundItems(hMenu, indexMenu, idCmdFirst);
      }
   else
      {
      InsertItems(hMenu, indexMenu, idCmdFirst, uFlags);
      }

   return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_LAST + 1));
   }
else
   {
   /*
   Just insert the default item.
   */
   MENUITEMINFO   mii;
   TCHAR          szText[MAX_PATH];

   ZeroMemory(&mii, sizeof(mii));
   mii.cbSize = sizeof(mii);

   if(CMF_EXPLORE & uFlags)
      {
      LoadString(g_hInst, IDS_EXPLORE, szText, sizeof(szText));
      mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
      mii.wID = idCmdFirst + IDM_EXPLORE;
      mii.fType = MFT_STRING;
      mii.dwTypeData = szText;
      mii.fState = MFS_ENABLED | MFS_DEFAULT;
      InsertMenuItem(   hMenu, 
                        indexMenu++, 
                        TRUE, 
                        &mii);
      }
   else
      {
      LoadString(g_hInst, IDS_OPEN, szText, sizeof(szText));
      mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
      mii.wID = idCmdFirst + IDM_OPEN;
      mii.fType = MFT_STRING;
      mii.dwTypeData = szText;
      mii.fState = MFS_ENABLED | MFS_DEFAULT;
      InsertMenuItem(   hMenu, 
                        indexMenu++, 
                        TRUE, 
                        &mii);
      }

   return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_LAST + 1));
   }

return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0));
}

/**************************************************************************

   CContextMenu::InvokeCommand()

**************************************************************************/

STDMETHODIMP CContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
LPCMINVOKECOMMANDINFOEX piciex;

if(pici->cbSize < sizeof(CMINVOKECOMMANDINFO))
   return E_INVALIDARG;

if(pici->cbSize >= sizeof(CMINVOKECOMMANDINFOEX) - sizeof(POINT))
   piciex = (LPCMINVOKECOMMANDINFOEX)pici;
else
   piciex = NULL;

if(HIWORD(pici->lpVerb))
   {
   //the command is being sent via a verb
   LPCTSTR  pVerb;

#ifdef UNICODE        
   BOOL  fUnicode = FALSE;
   WCHAR szVerb[MAX_PATH];

   if(piciex && ((pici->fMask & CMIC_MASK_UNICODE) == CMIC_MASK_UNICODE))
      {
      fUnicode = TRUE;
      }

   if(!fUnicode || piciex->lpVerbW == NULL)
      {
      MultiByteToWideChar( CP_ACP, 
                           0,
                           pici->lpVerb, 
                           -1,
                           szVerb, 
                           ARRAYSIZE(szVerb));
      pVerb = szVerb;
      }
   else
      {
      pVerb = piciex->lpVerbW;
      }
#else
   pVerb = pici->lpVerb;
#endif   //UNICODE

   //run through our list of verbs and get the command ID of the verb, if any
   int   i;
   for(i = 0; -1 != g_VerbMap[i].dwCommand; i++)
      {
      if(0 == lstrcmpi(pVerb, g_VerbMap[i].szVerb))
         {
         pici->lpVerb = (LPCSTR)MAKEINTRESOURCE(g_VerbMap[i].dwCommand);
         break;
         }
      }
   }

//this will also catch if an unsupported verb was specified
if((DWORD)pici->lpVerb > IDM_LAST)
   return E_INVALIDARG;

switch(LOWORD(pici->lpVerb))
   {
   case IDM_EXPLORE:
      DoExplore(GetParent(pici->hwnd));
      break;

   case IDM_OPEN:
      DoOpen(GetParent(pici->hwnd));
      break;

   case IDM_NEW_FOLDER:
      DoNewFolder(pici->hwnd);
      break;

   case IDM_NEW_ITEM:
      DoNewItem(pici->hwnd);
      break;
   
   case IDM_MODIFY_DATA:
      DoModifyData(pici->hwnd);
      break;
   
   case IDM_RENAME:
      DoRename(pici->hwnd);
      break;
   
   case IDM_PASTE:
      DoPaste();
      break;
   
   case IDM_CUT:
      DoCopyOrCut(pici->hwnd, TRUE);
      break;

   case IDM_COPY:
      DoCopyOrCut(pici->hwnd, FALSE);
      break;
   
   case IDM_DELETE:
      DoDelete();
      break;
   
   }

return NOERROR;
}

/**************************************************************************

   CContextMenu::GetCommandString()

**************************************************************************/

STDMETHODIMP CContextMenu::GetCommandString( UINT idCommand,
                                             UINT uFlags,
                                             LPUINT lpReserved,
                                             LPSTR lpszName,
                                             UINT uMaxNameLen)
{
HRESULT  hr = E_INVALIDARG;

switch(uFlags)
   {
   case GCS_HELPTEXT:
      switch(idCommand)
         {
         case 0:
            hr = NOERROR;
            break;
         }
      break;
   
   case GCS_VERBA:
      {
      int   i;
      for(i = 0; -1 != g_VerbMap[i].dwCommand; i++)
         {
         if(g_VerbMap[i].dwCommand == idCommand)
            {
            LocalToAnsi(lpszName, g_VerbMap[i].szVerb, uMaxNameLen);
            hr = NOERROR;
            break;
            }
         }
      }
      break;

   /*
   NT 4.0 with IE 3.0x or no IE will always call this with GCS_VERBW. In this 
   case, you need to do the lstrcpyW to the pointer passed.
   */
   case GCS_VERBW:
      {
      int   i;
      for(i = 0; -1 != g_VerbMap[i].dwCommand; i++)
         {
         if(g_VerbMap[i].dwCommand == idCommand)
            {
            LocalToWideChar((LPWSTR)lpszName, g_VerbMap[i].szVerb, uMaxNameLen);
            hr = NOERROR;
            break;
            }
         }
      }
      break;

   case GCS_VALIDATE:
      hr = NOERROR;
      break;
   }

return hr;
}

///////////////////////////////////////////////////////////////////////////
//
// private and utility methods
//

/**************************************************************************

   CContextMenu::AllocPidlTable()

**************************************************************************/

LPITEMIDLIST* CContextMenu::AllocPidlTable(DWORD dwEntries)
{
LPITEMIDLIST   *aPidls;

dwEntries++;

aPidls = (LPITEMIDLIST*)m_pMalloc->Alloc(dwEntries * sizeof(LPITEMIDLIST));

if(aPidls)
   {
   //set all of the entries to NULL
   ZeroMemory(aPidls, dwEntries * sizeof(LPITEMIDLIST));
   }

return aPidls;
}

/**************************************************************************

   CContextMenu::FreePidlTable()

**************************************************************************/

VOID CContextMenu::FreePidlTable(LPITEMIDLIST *aPidls)
{
if(aPidls && m_pPidlMgr)
   {
   UINT  i;
   for(i = 0; aPidls[i]; i++)
      m_pPidlMgr->Delete(aPidls[i]);
   
   m_pMalloc->Free(aPidls);
   }
}

/**************************************************************************

   CContextMenu::FillPidlTable()

**************************************************************************/

BOOL CContextMenu::FillPidlTable(LPCITEMIDLIST *aPidls, UINT uItemCount)
{
if(m_aPidls)
   {
   if(m_pPidlMgr)
      {
      UINT  i;
      for(i = 0; i < uItemCount; i++)
         {
         m_aPidls[i] = m_pPidlMgr->Copy(aPidls[i]);
         }
      return TRUE;
      }
   }

return FALSE;
}

/**************************************************************************

   CContextMenu::DoCopyOrCut()

**************************************************************************/

BOOL CContextMenu::DoCopyOrCut(HWND hWnd, BOOL fCut)
{
/*
Copy the data to the clipboard. If this is a cut operation, mark the 
item as cut in the list. We will do this in the same way that the shell 
does it for the file system where the source data actually gets deleted 
when the paste operation occurs.
*/
BOOL  fSuccess = FALSE;

if(OpenClipboard(NULL))
   {
   if(EmptyClipboard())
      {
      HGLOBAL        hMem;
      LPITEMIDLIST   pidlParent;

      pidlParent = m_psfParent->CreateFQPidl(NULL);

      if(pidlParent)
         {
         hMem = CreatePrivateClipboardData(pidlParent, m_aPidls, m_uItemCount, fCut);

         if(SetClipboardData(m_cfPrivateData, hMem))
            {
            fSuccess = TRUE;

            if(fCut)
               {
               CShellView  *pView = (CShellView*)GetViewInterface(hWnd);

               if(pView)
                  {
                  pView->MarkItemsAsCut((LPCITEMIDLIST*)m_aPidls, m_uItemCount);
                  pView->Release();
                  }
               }
            }
         m_pPidlMgr->Delete(pidlParent);
         }
      }

   CloseClipboard();
   }

return fSuccess;
}

/**************************************************************************

   CContextMenu::DoPaste()

**************************************************************************/

BOOL CContextMenu::DoPaste(VOID)
{
BOOL     fSuccess = FALSE;
HGLOBAL  hMem;

OpenClipboard(NULL);

hMem = GetClipboardData(m_cfPrivateData);

if(hMem)
   {
   LPPRIVCLIPDATA pData = (LPPRIVCLIPDATA)GlobalLock(hMem);

   if(pData)
      {
      BOOL           fCut = pData->fCut;
      CShellFolder   *psfFrom = NULL;
      IShellFolder   *psfDesktop;
      LPITEMIDLIST   pidl;

      pidl = (LPITEMIDLIST)((LPBYTE)(pData) + pData->aoffset[0]);
      /*
      This is a fully qualified PIDL, so use the desktop folder to get the 
      IShellFolder for this folder.
      */
      SHGetDesktopFolder(&psfDesktop);
      if(psfDesktop)
         {
         psfDesktop->BindToObject(pidl, NULL, IID_IShellFolder, (LPVOID*)&psfFrom);
         psfDesktop->Release();
         }
      
      if(psfFrom)
         {
         LPITEMIDLIST   *aPidls;

         //allocate an array of PIDLS
         aPidls = AllocPidlTable(pData->cidl - 1);

         if(aPidls)
            {
            UINT  i;

            //fill in the PIDL array
            for(i = 0; i < pData->cidl - 1; i++)
               {
               aPidls[i] = m_pPidlMgr->Copy((LPITEMIDLIST)((LPBYTE)(pData) + pData->aoffset[i + 1]));
               }

            if(SUCCEEDED(m_psfParent->CopyItems(psfFrom, aPidls, pData->cidl - 1)))
               {
               fSuccess = TRUE;
      
               if(fCut)
                  {
                  psfFrom->DeleteItems(aPidls, pData->cidl - 1);
                  }
               }

            FreePidlTable(aPidls);
            }

         psfFrom->Release();
         }

      GlobalUnlock(hMem);

      if(fSuccess && fCut)
         {
         //a successful cut and paste operation will remove the data from the clipboard
         EmptyClipboard();
         }
      }
   }

CloseClipboard();

return fSuccess;
}

/**************************************************************************

   CContextMenu::DoExplore()

**************************************************************************/

BOOL CContextMenu::DoExplore(HWND hWnd)
{
LPITEMIDLIST      pidlFQ;
SHELLEXECUTEINFO  sei;

pidlFQ = m_psfParent->CreateFQPidl(m_aPidls[0]);

ZeroMemory(&sei, sizeof(sei));
sei.cbSize = sizeof(sei);
sei.fMask = SEE_MASK_IDLIST | SEE_MASK_CLASSNAME;
sei.lpIDList = pidlFQ;
sei.lpClass = TEXT("folder");
sei.hwnd = hWnd;
sei.nShow = SW_SHOWNORMAL;
sei.lpVerb = TEXT("explore");

BOOL fReturn = ShellExecuteEx(&sei);

m_pPidlMgr->Delete(pidlFQ);

return fReturn;
}

/**************************************************************************

   CContextMenu::DoOpen()

**************************************************************************/

BOOL CContextMenu::DoOpen(HWND hWnd)
{
LPITEMIDLIST      pidlFQ;
SHELLEXECUTEINFO  sei;

pidlFQ = m_psfParent->CreateFQPidl(m_aPidls[0]);

ZeroMemory(&sei, sizeof(sei));
sei.cbSize = sizeof(sei);
sei.fMask = SEE_MASK_IDLIST | SEE_MASK_CLASSNAME;
sei.lpIDList = pidlFQ;
sei.lpClass = TEXT("folder");
sei.hwnd = hWnd;
sei.nShow = SW_SHOWNORMAL;
sei.lpVerb = TEXT("open");

BOOL fReturn = ShellExecuteEx(&sei);

m_pPidlMgr->Delete(pidlFQ);

return fReturn;
}

/**************************************************************************

   CContextMenu::DoDelete()

**************************************************************************/

STDMETHODIMP CContextMenu::DoDelete(VOID)
{
return m_psfParent->DeleteItems(m_aPidls, m_uItemCount);
}

/**************************************************************************

   CContextMenu::DoNewFolder()

   Add the folder with the new folder name and then put the ListView into 
   rename mode.

**************************************************************************/

STDMETHODIMP CContextMenu::DoNewFolder(HWND hWnd)
{
HRESULT        hr = E_FAIL;
TCHAR          szName[MAX_PATH];
LPITEMIDLIST   pidl;

m_psfParent->GetUniqueName(TRUE, szName, MAX_PATH);
hr = m_psfParent->AddFolder(szName, &pidl);
if(SUCCEEDED(hr))
   {
   /*
   CShellFolder::AddFolder should have added the new item. Tell the view to 
   put the item into edit mode.
   */
   CShellView  *pView = (CShellView*)GetViewInterface(hWnd);
   if(pView)
      {
      pView->EditItem(pidl);
      pView->Release();
      }

   m_pPidlMgr->Delete(pidl);
   }

return hr;
}

/**************************************************************************

   CContextMenu::DoNewItem()

   Add the item with the new item name and then put the ListView into 
   rename mode.

**************************************************************************/

STDMETHODIMP CContextMenu::DoNewItem(HWND hWnd)
{
HRESULT        hr;
TCHAR          szName[MAX_PATH];
LPITEMIDLIST   pidl;

m_psfParent->GetUniqueName(FALSE, szName, MAX_PATH);
hr = m_psfParent->AddItem(szName, NULL, &pidl);
if(SUCCEEDED(hr))
   {
   /*
   CShellFolder::AddItem should have added the new item. Tell the view to 
   put the item into edit mode.
   */
   CShellView  *pView = (CShellView*)GetViewInterface(hWnd);
   if(pView)
      {
      pView->EditItem(pidl);
      pView->Release();
      }

   m_pPidlMgr->Delete(pidl);
   }

return hr;
}

/**************************************************************************

   CContextMenu::DoRename()

**************************************************************************/

VOID CContextMenu::DoRename(HWND hWnd)
{
CShellView  *pView = (CShellView*)GetViewInterface(hWnd);
if(pView)
   {
   pView->EditItem(m_aPidls[0]);
   pView->Release();
   }
}

/**************************************************************************

   CContextMenu::DoModifyData()

**************************************************************************/

int CContextMenu::DoModifyData(HWND hwndList)
{
TCHAR szData[MAX_DATA];
int   nRet;

//get the item's current data
m_pPidlMgr->GetData(m_aPidls[0], szData, MAX_DATA);

nRet = DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_ITEMDATADLG), hwndList, ItemDataDlgProc, (LPARAM)szData);

if(IDOK == nRet)
   {
   m_psfParent->SetItemData(m_aPidls[0], szData);
   }

return nRet;
}

/**************************************************************************

   CContextMenu::InsertBackgroundItems()

**************************************************************************/

UINT CContextMenu::InsertBackgroundItems( HMENU hMenu, 
                                          UINT indexMenu, 
                                          UINT idCmdFirst)
{
HMENU          hPopup;
TCHAR          szText[MAX_PATH];
MENUITEMINFO   mii;

ZeroMemory(&mii, sizeof(mii));
mii.cbSize = sizeof(mii);

//add the View submenu
hPopup = CreatePopupMenu();

if(hPopup)
   {
   AddViewMenuItems(hPopup, idCmdFirst, -1, TRUE);

   LoadString(g_hInst, IDS_VIEW, szText, sizeof(szText));
   mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE | MIIM_SUBMENU;
   mii.wID = idCmdFirst + IDM_VIEW;
   mii.fType = MFT_STRING;
   mii.dwTypeData = szText;
   mii.fState = MFS_ENABLED;
   mii.hSubMenu = hPopup;
   InsertMenuItem(   hMenu, 
                     indexMenu++, 
                     TRUE, 
                     &mii);

   //only add a separator if needed
   mii.fMask = MIIM_TYPE;
   GetMenuItemInfo(hMenu, indexMenu, TRUE, &mii);
   if(!(mii.fType & MFT_SEPARATOR))
      {
      ZeroMemory(&mii, sizeof(mii));
      mii.cbSize = sizeof(mii);
      mii.fMask = MIIM_ID | MIIM_TYPE;
      mii.wID = 0;
      mii.fType = MFT_SEPARATOR;
      InsertMenuItem(   hMenu, 
                        indexMenu++, 
                        TRUE, 
                        &mii);
      }
   }

indexMenu += AddFileMenuItems(hMenu, idCmdFirst, indexMenu, TRUE);

//only add a separator if needed
mii.fMask = MIIM_TYPE;
GetMenuItemInfo(hMenu, indexMenu, TRUE, &mii);
if(!(mii.fType & MFT_SEPARATOR))
   {
   ZeroMemory(&mii, sizeof(mii));
   mii.cbSize = sizeof(mii);
   mii.fMask = MIIM_ID | MIIM_TYPE;
   mii.wID = 0;
   mii.fType = MFT_SEPARATOR;
   InsertMenuItem(   hMenu, 
                     indexMenu++, 
                     TRUE, 
                     &mii);
   }

OpenClipboard(NULL);
HGLOBAL  hClip = GetClipboardData(m_cfPrivateData);
CloseClipboard();

LoadString(g_hInst, IDS_PASTE, szText, sizeof(szText));
mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
mii.wID = idCmdFirst + IDM_PASTE;
mii.fType = MFT_STRING;
mii.dwTypeData = szText;
mii.fState = (hClip ? MFS_ENABLED : MFS_DISABLED);
InsertMenuItem(   hMenu, 
                  indexMenu++, 
                  TRUE, 
                  &mii);

return indexMenu;
}

/**************************************************************************

   CContextMenu::InsertItems()

**************************************************************************/

UINT CContextMenu::InsertItems(  HMENU hMenu, 
                                 UINT indexMenu, 
                                 UINT idCmdFirst,
                                 UINT uFlags)
{
MENUITEMINFO   mii;
TCHAR          szText[MAX_PATH];
BOOL           fExplore = uFlags & CMF_EXPLORE;
DWORD          dwAttr = SFGAO_CANRENAME | 
                           SFGAO_CANDELETE | 
                           SFGAO_CANCOPY | 
                           SFGAO_CANMOVE | 
                           SFGAO_FOLDER;

ZeroMemory(&mii, sizeof(mii));
mii.cbSize = sizeof(mii);

m_psfParent->GetAttributesOf(m_uItemCount, (LPCITEMIDLIST*)m_aPidls, &dwAttr);

//only add the Open and Explore items if all items are folders.
if(dwAttr & SFGAO_FOLDER)
   {
   if(fExplore)
      {
      LoadString(g_hInst, IDS_EXPLORE, szText, sizeof(szText));
      mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
      mii.wID = idCmdFirst + IDM_EXPLORE;
      mii.fType = MFT_STRING;
      mii.dwTypeData = szText;
      mii.fState = MFS_ENABLED | MFS_DEFAULT;
      InsertMenuItem(   hMenu, 
                        indexMenu++, 
                        TRUE, 
                        &mii);

      LoadString(g_hInst, IDS_OPEN, szText, sizeof(szText));
      mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
      mii.wID = idCmdFirst + IDM_OPEN;
      mii.fType = MFT_STRING;
      mii.dwTypeData = szText;
      mii.fState = MFS_ENABLED;
      InsertMenuItem(   hMenu, 
                        indexMenu++, 
                        TRUE, 
                        &mii);
      }
   else
      {
      LoadString(g_hInst, IDS_OPEN, szText, sizeof(szText));
      mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
      mii.wID = idCmdFirst + IDM_OPEN;
      mii.fType = MFT_STRING;
      mii.dwTypeData = szText;
      mii.fState = MFS_ENABLED | MFS_DEFAULT;
      InsertMenuItem(   hMenu, 
                        indexMenu++, 
                        TRUE, 
                        &mii);

      LoadString(g_hInst, IDS_EXPLORE, szText, sizeof(szText));
      mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
      mii.wID = idCmdFirst + IDM_EXPLORE;
      mii.fType = MFT_STRING;
      mii.dwTypeData = szText;
      mii.fState = MFS_ENABLED;
      InsertMenuItem(   hMenu, 
                        indexMenu++, 
                        TRUE, 
                        &mii);
      }
   }

if(dwAttr & SFGAO_CANRENAME)
   {
   //only add a separator if needed
   if(GetMenuItemCount(hMenu))
      {
      mii.fMask = MIIM_TYPE;
      GetMenuItemInfo(hMenu, indexMenu, TRUE, &mii);
      if(!(mii.fType & MFT_SEPARATOR))
         {
         ZeroMemory(&mii, sizeof(mii));
         mii.cbSize = sizeof(mii);
         mii.fMask = MIIM_ID | MIIM_TYPE;
         mii.wID = 0;
         mii.fType = MFT_SEPARATOR;
         InsertMenuItem(   hMenu, 
                           indexMenu++, 
                           TRUE, 
                           &mii);
         }
      }

   LoadString(g_hInst, IDS_RENAME, szText, sizeof(szText));
   mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
   mii.wID = idCmdFirst + IDM_RENAME;
   mii.fType = MFT_STRING;
   mii.dwTypeData = szText;
   mii.fState = ((uFlags & MYCMF_MULTISELECT) ? MFS_DISABLED : MFS_ENABLED);
   InsertMenuItem(   hMenu, 
                     indexMenu++, 
                     TRUE, 
                     &mii);
   }

//only add a separator if needed
if(GetMenuItemCount(hMenu))
   {
   mii.fMask = MIIM_TYPE;
   GetMenuItemInfo(hMenu, indexMenu, TRUE, &mii);
   if(!(mii.fType & MFT_SEPARATOR))
      {
      mii.fMask = MIIM_ID | MIIM_TYPE;
      mii.wID = 0;
      mii.fType = MFT_SEPARATOR;
      InsertMenuItem(   hMenu, 
                        indexMenu++, 
                        TRUE, 
                        &mii);
      }
   }

LoadString(g_hInst, IDS_CUT, szText, sizeof(szText));
mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
mii.wID = idCmdFirst + IDM_CUT;
mii.fType = MFT_STRING;
mii.dwTypeData = szText;
mii.fState = ((dwAttr & SFGAO_CANMOVE) ? MFS_ENABLED : MFS_DISABLED);
InsertMenuItem(   hMenu, 
                  indexMenu++, 
                  TRUE, 
                  &mii);

LoadString(g_hInst, IDS_COPY, szText, sizeof(szText));
mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
mii.wID = idCmdFirst + IDM_COPY;
mii.fType = MFT_STRING;
mii.dwTypeData = szText;
mii.fState = ((dwAttr & SFGAO_CANCOPY) ? MFS_ENABLED : MFS_DISABLED);
InsertMenuItem(   hMenu, 
                  indexMenu++, 
                  TRUE, 
                  &mii);

if(dwAttr & SFGAO_CANDELETE)
   {
   //only add a separator if needed
   if(GetMenuItemCount(hMenu))
      {
      mii.fMask = MIIM_TYPE;
      GetMenuItemInfo(hMenu, indexMenu, TRUE, &mii);
      if(!(mii.fType & MFT_SEPARATOR))
         {
         ZeroMemory(&mii, sizeof(mii));
         mii.cbSize = sizeof(mii);
         mii.fMask = MIIM_ID | MIIM_TYPE;
         mii.wID = 0;
         mii.fType = MFT_SEPARATOR;
         InsertMenuItem(   hMenu, 
                           indexMenu++, 
                           TRUE, 
                           &mii);
         }
      }

   LoadString(g_hInst, IDS_DELETE, szText, sizeof(szText));
   mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
   mii.wID = idCmdFirst + IDM_DELETE;
   mii.fType = MFT_STRING;
   mii.dwTypeData = szText;
   mii.fState = MFS_ENABLED;
   InsertMenuItem(   hMenu, 
                     indexMenu++, 
                     TRUE, 
                     &mii);
   }

if(!(dwAttr & SFGAO_FOLDER) && !(m_fBackground))
   {
   //only add a separator if needed
   if(GetMenuItemCount(hMenu))
      {
      mii.fMask = MIIM_TYPE;
      GetMenuItemInfo(hMenu, indexMenu, TRUE, &mii);
      if(!(mii.fType & MFT_SEPARATOR))
         {
         ZeroMemory(&mii, sizeof(mii));
         mii.cbSize = sizeof(mii);
         mii.fMask = MIIM_ID | MIIM_TYPE;
         mii.wID = 0;
         mii.fType = MFT_SEPARATOR;
         InsertMenuItem(   hMenu, 
                           indexMenu++, 
                           TRUE, 
                           &mii);
         }
      }

   LoadString(g_hInst, IDS_MODIFY_DATA, szText, sizeof(szText));
   mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STATE;
   mii.wID = idCmdFirst + IDM_MODIFY_DATA;
   mii.fType = MFT_STRING;
   mii.dwTypeData = szText;
   mii.fState = ((uFlags & MYCMF_MULTISELECT) ? MFS_DISABLED : MFS_ENABLED);
   InsertMenuItem(   hMenu, 
                     indexMenu++, 
                     TRUE, 
                     &mii);
   }

return indexMenu;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\dataobj.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/******************************************************************************

   File:          DataObj.h
   
   Description:   CDataObject definitions.

******************************************************************************/

#ifndef DATAOBJ_H
#define DATAOBJ_H

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include "ShlFldr.h"
#include "PidlMgr.h"
#include "resource.h"

#define SETDefFormatEtc(fe, cf, med) \
    {\
    (fe).cfFormat=cf; \
    (fe).dwAspect=DVASPECT_CONTENT; \
    (fe).ptd=NULL;\
    (fe).tymed=med;\
    (fe).lindex=-1;\
    };

/**************************************************************************

   CDataObject class definition

**************************************************************************/

class CDataObject : public IDataObject, IEnumFORMATETC
{
private:
   DWORD          m_ObjRefCount;
   LPITEMIDLIST   *m_aPidls;
   IMalloc        *m_pMalloc;
   CPidlMgr       *m_pPidlMgr;
   CShellFolder   *m_psfParent;
   UINT           m_uItemCount;
    ULONG              m_iCurrent;
    ULONG              m_cFormatEtc;
    LPFORMATETC    m_pFormatEtc;
   UINT           m_cfPrivateData;
   UINT           m_cfShellIDList;
   
public:
   CDataObject(CShellFolder*, LPCITEMIDLIST*, UINT);
   ~CDataObject();
   
   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IDataObject methods
    STDMETHODIMP GetData(LPFORMATETC, LPSTGMEDIUM);
    STDMETHODIMP GetDataHere(LPFORMATETC, LPSTGMEDIUM);
    STDMETHODIMP QueryGetData(LPFORMATETC);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC, LPFORMATETC);
    STDMETHODIMP SetData(LPFORMATETC, LPSTGMEDIUM, BOOL);
    STDMETHODIMP EnumFormatEtc(DWORD, IEnumFORMATETC**);
    STDMETHODIMP DAdvise(LPFORMATETC, DWORD, IAdviseSink*, LPDWORD);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA** ppEnumAdvise);

    // IEnumFORMATETC members
    STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG*);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(LPENUMFORMATETC*);

private:
   BOOL AllocPidlTable(DWORD);
   VOID FreePidlTable(VOID);
   BOOL FillPidlTable(LPCITEMIDLIST*, UINT);
};

#endif// DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\dataobj.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          DataObj.cpp
   
   Description:   CDataObject implementation.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "DataObj.h"

/**************************************************************************
   global variables
**************************************************************************/

/**************************************************************************

   CDataObject::CDataObject()

**************************************************************************/

CDataObject::CDataObject(CShellFolder *psfParent, LPCITEMIDLIST *aPidls, UINT uItemCount)
{
g_DllRefCount++;

m_uItemCount = 0;

m_psfParent = psfParent;
if(m_psfParent)
   m_psfParent->AddRef();

m_ObjRefCount = 1;

m_aPidls = NULL;
SHGetMalloc(&m_pMalloc);
if(!m_pMalloc)
   {
   delete this;
   return;
   }

m_pPidlMgr = new CPidlMgr();

m_uItemCount = uItemCount;

AllocPidlTable(uItemCount);
if(m_aPidls)
   {
   FillPidlTable(aPidls, uItemCount);
   }

m_cfPrivateData = RegisterClipboardFormat(CFSTR_SAMPVIEWDATA);
m_cfShellIDList = RegisterClipboardFormat(CFSTR_SHELLIDLIST);

m_cFormatEtc = 2;
m_pFormatEtc = new FORMATETC[m_cFormatEtc];
SETDefFormatEtc(m_pFormatEtc[0], m_cfPrivateData, TYMED_HGLOBAL);
SETDefFormatEtc(m_pFormatEtc[1], m_cfShellIDList, TYMED_HGLOBAL);

m_iCurrent = 0;
}

/**************************************************************************

   CDataObject::~CDataObject()

**************************************************************************/

CDataObject::~CDataObject()
{
if(m_psfParent)
   m_psfParent->Release();

g_DllRefCount--;

//make sure the pidls are freed
if(m_aPidls && m_pMalloc)
   {
   FreePidlTable();
   }

if(m_pPidlMgr)
   delete m_pPidlMgr;

if(m_pMalloc)
   m_pMalloc->Release();

//delete [] m_pFormatEtc;
delete m_pFormatEtc;
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CDataObject::QueryInterface

**************************************************************************/

STDMETHODIMP CDataObject::QueryInterface(   REFIID riid, 
                                            LPVOID *ppReturn)
{
*ppReturn = NULL;

if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = (LPUNKNOWN)(LPCONTEXTMENU)this;
   }
else if(IsEqualIID(riid, IID_IDataObject))
   {
   *ppReturn = (LPDATAOBJECT)this;
   }   
else if(IsEqualIID(riid, IID_IEnumFORMATETC))
   {
   *ppReturn = (LPENUMFORMATETC)this;
   }   

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

/**************************************************************************

   CDataObject::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CDataObject::AddRef()
{
return ++m_ObjRefCount;
}


/**************************************************************************

   CDataObject::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CDataObject::Release()
{
if(--m_ObjRefCount == 0)
   delete this;
   
return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IDataObject Implementation
//

/**************************************************************************

   CDataObject::GetData()

**************************************************************************/

STDMETHODIMP CDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
if(pFE->cfFormat == m_cfPrivateData)
   {
   LPITEMIDLIST   pidlParent;

   pidlParent = m_psfParent->CreateFQPidl(NULL);

   if(pidlParent)
      {
      pStgMedium->hGlobal = CreatePrivateClipboardData(pidlParent, m_aPidls, m_uItemCount, FALSE);

      m_pPidlMgr->Delete(pidlParent);

      if(pStgMedium->hGlobal)
         {
         pStgMedium->tymed = TYMED_HGLOBAL;
         return S_OK;
         }
      }
   
   return E_OUTOFMEMORY;
   }

else if(pFE->cfFormat == m_cfShellIDList)
   {
   LPITEMIDLIST   pidlParent;

   pidlParent = m_psfParent->CreateFQPidl(NULL);

   if(pidlParent)
      {
      pStgMedium->hGlobal = CreateShellIDList(pidlParent, m_aPidls, m_uItemCount);

      m_pPidlMgr->Delete(pidlParent);

      if(pStgMedium->hGlobal)
         {
         pStgMedium->tymed = TYMED_HGLOBAL;
         return S_OK;
         }
      }
   
   return E_OUTOFMEMORY;
   }

return E_INVALIDARG;
}

/**************************************************************************

   CDataObject::GetDataHere()

**************************************************************************/

STDMETHODIMP CDataObject::GetDataHere (LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
return E_NOTIMPL;
}

/**************************************************************************

   CDataObject::QueryGetData()

**************************************************************************/

STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC pFE)
{
BOOL fReturn = FALSE;

/*
Check the aspects we support. Implementations of this object will only
support DVASPECT_CONTENT.
*/
if(!(DVASPECT_CONTENT & pFE->dwAspect))
   return DV_E_DVASPECT;

if(pFE->cfFormat == m_cfPrivateData)
   {
   //
   // Now check for an appropriate TYMED.
   //
   for(UINT i = 0; i < m_cFormatEtc; i++)
      {
      fReturn |= m_pFormatEtc[i].tymed & pFE->tymed;
      }
   }

if(pFE->cfFormat == m_cfShellIDList)
   {
   //
   // Now check for an appropriate TYMED.
   //
   for(UINT i = 0; i < m_cFormatEtc; i++)
      {
      fReturn |= m_pFormatEtc[i].tymed & pFE->tymed;
      }
   }

return (fReturn ? S_OK : DV_E_TYMED);
}

/**************************************************************************

   CDataObject::GetCanonicalFormatEtc()

**************************************************************************/

STDMETHODIMP CDataObject::GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut)
{
if(NULL == pFEOut)
   return E_INVALIDARG;

pFEOut->ptd = NULL;

return DATA_S_SAMEFORMATETC;
}

/**************************************************************************

   CDataObject::EnumFormatEtc()

**************************************************************************/

STDMETHODIMP CDataObject::EnumFormatEtc(  DWORD dwDirection, 
                                          IEnumFORMATETC** ppEFE)
{
*ppEFE = NULL;

if(DATADIR_GET == dwDirection)
   {
   return this->QueryInterface(IID_IEnumFORMATETC, (LPVOID*)ppEFE);
   }

return E_NOTIMPL;
}

/**************************************************************************

   CDataObject::SetData()

**************************************************************************/

STDMETHODIMP CDataObject::SetData(  LPFORMATETC pFE, 
                                    LPSTGMEDIUM pStgMedium, 
                                    BOOL fRelease)
{
return E_NOTIMPL;
}

/**************************************************************************

   CDataObject::DAdvise()

**************************************************************************/

STDMETHODIMP CDataObject::DAdvise(  LPFORMATETC pFE, 
                                    DWORD advf, 
                                    IAdviseSink *ppAdviseSink, 
                                    LPDWORD pdwConnection)
{
return E_NOTIMPL;
}

/**************************************************************************

   CDataObject::DUnadvise()

**************************************************************************/

STDMETHODIMP CDataObject::DUnadvise(DWORD dwConnection)
{
return E_NOTIMPL;
}

/**************************************************************************

   CDataObject::EnumDAdvise()

**************************************************************************/

STDMETHODIMP CDataObject::EnumDAdvise(IEnumSTATDATA** ppEnumAdvise)
{
return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IEnumFORMATETC Implementation
//

STDMETHODIMP CDataObject::Next(ULONG uRequested, LPFORMATETC pFormatEtc, ULONG* pulFetched)
{
if(NULL == m_pFormatEtc)
   return S_FALSE;

if(NULL != pulFetched)
   *pulFetched = 0L;

if(NULL == pFormatEtc)
   return E_INVALIDARG;

ULONG uFetched;
for(uFetched = 0; m_iCurrent < m_cFormatEtc && uRequested > uFetched; uFetched++)
   {
   *pFormatEtc++ = m_pFormatEtc[m_iCurrent++];
   }

if(NULL != pulFetched)
   *pulFetched = uFetched;

return ((uFetched == uRequested) ? S_OK : S_FALSE);
}

/**************************************************************************

   CDataObject::Skip()

**************************************************************************/

STDMETHODIMP CDataObject::Skip(ULONG cSkip)
{
if((m_iCurrent + cSkip) >= m_cFormatEtc)
   return S_FALSE;

m_iCurrent += cSkip;

return S_OK;
}


/**************************************************************************

   CDataObject::Reset()

**************************************************************************/

STDMETHODIMP CDataObject::Reset(void)
{
m_iCurrent = 0;
return S_OK;
}

/**************************************************************************

   CDataObject::Clone()

**************************************************************************/

STDMETHODIMP CDataObject::Clone(LPENUMFORMATETC* ppEnum)
{
CDataObject* pNew;

*ppEnum = NULL;

// Create the clone.
pNew = new CDataObject(m_psfParent, (LPCITEMIDLIST*)m_aPidls, m_uItemCount);
if (NULL == pNew)
   return E_OUTOFMEMORY;

pNew->m_iCurrent = m_iCurrent;

*ppEnum = pNew;

return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// private and utility methods
//

/**************************************************************************

   CDataObject::AllocPidlTable()

**************************************************************************/

BOOL CDataObject::AllocPidlTable(DWORD dwEntries)
{
m_aPidls = (LPITEMIDLIST*)m_pMalloc->Alloc(dwEntries * sizeof(LPITEMIDLIST));

if(m_aPidls)
   {
   //set all of the entries to NULL
   ZeroMemory(m_aPidls, dwEntries * sizeof(LPITEMIDLIST));
   }

return (m_aPidls != NULL);
}

/**************************************************************************

   CDataObject::FreePidlTable()

**************************************************************************/

VOID CDataObject::FreePidlTable(VOID)
{
if(m_aPidls && m_pPidlMgr)
   {
   UINT  i;
   for(i = 0; i < m_uItemCount; i++)
      m_pPidlMgr->Delete(m_aPidls[i]);
   
   m_pMalloc->Free(m_aPidls);

   m_aPidls = NULL;
   }
}

/**************************************************************************

   CDataObject::FillPidlTable()

**************************************************************************/

BOOL CDataObject::FillPidlTable(LPCITEMIDLIST *aPidls, UINT uItemCount)
{
if(m_aPidls)
   {
   if(m_pPidlMgr)
      {
      UINT  i;
      for(i = 0; i < uItemCount; i++)
         {
         m_aPidls[i] = m_pPidlMgr->Copy(aPidls[i]);
         }
      return TRUE;
      }
   }

return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\dropsrc.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          DropSrc.h

   Description:   CDropSource class defintions

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include <windows.h>
#include "Utility.h"

/**************************************************************************
   class definitions
**************************************************************************/

class CDropSource : public IDropSource
{
private: 
   DWORD m_ObjRefCount;

public: 
   // Contstructor and Destructor
   CDropSource();
   ~CDropSource();

   // IUnknown Interface members
   STDMETHODIMP QueryInterface(REFIID, LPVOID*);
   STDMETHODIMP_(ULONG) AddRef(void);
   STDMETHODIMP_(ULONG) Release(void);

   // IDropSource Interface members
   STDMETHODIMP QueryContinueDrag(BOOL, DWORD);
   STDMETHODIMP GiveFeedback(DWORD);
   
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\droptgt.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          DropTgt.h

   Description:   CDropTarget definitions.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include <windows.h>
#include <ole2.h>
#include <shlobj.h>
#include "ShlFldr.h"
#include "PidlMgr.h"

/**************************************************************************
   global variables and definitions
**************************************************************************/

/**************************************************************************
   class definitions
**************************************************************************/

class FAR CDropTarget : public IDropTarget
{
public:
   CDropTarget(CShellFolder*);
   ~CDropTarget();

   //IUnknown methods
   STDMETHOD(QueryInterface)(REFIID, LPVOID*);
   STDMETHOD_(ULONG, AddRef)(void);
   STDMETHOD_(ULONG, Release)(void);

   //IDropTarget methods
   STDMETHOD(DragEnter)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
   STDMETHOD(DragOver)(DWORD, POINTL, LPDWORD);
   STDMETHOD(DragLeave)(VOID);
   STDMETHOD(Drop)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);

private:
   CShellFolder   *m_psfParent;
   CPidlMgr       *m_pPidlMgr;
   IMalloc        *m_pMalloc;
   ULONG          m_ObjRefCount;  
   BOOL           m_fAcceptFmt;
   UINT           m_cfPrivateData;

   BOOL QueryDrop(DWORD, LPDWORD);
   DWORD GetDropEffectFromKeyState(DWORD);
   BOOL DoDrop(HGLOBAL, BOOL);
   LPITEMIDLIST* AllocPidlTable(DWORD);
   VOID FreePidlTable(LPITEMIDLIST*);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\droptgt.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED 'AS IS' WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          DropTgt.cpp

   Description:   Implements CDropTarget.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "DropTgt.h"
#include "Utility.h"

/**************************************************************************

   CDropTarget::CDropTarget()

**************************************************************************/

CDropTarget::CDropTarget(CShellFolder *psfParent)
{
g_DllRefCount++;

m_psfParent = psfParent;
if(m_psfParent)
   m_psfParent->AddRef();
else
   {
   delete this;
   return;
   }

m_pPidlMgr = new CPidlMgr();
if(!m_pPidlMgr)
   {
   delete this;
   return;
   }

SHGetMalloc(&m_pMalloc);
if(!m_pMalloc)
   {
   delete this;
   return;
   }

m_ObjRefCount = 1;

m_fAcceptFmt = FALSE;

m_cfPrivateData = RegisterClipboardFormat(CFSTR_SAMPVIEWDATA);
}

/**************************************************************************

   CDropTarget::~CDropTarget()

**************************************************************************/

CDropTarget::~CDropTarget()
{
if(m_psfParent)
   m_psfParent->Release();

if(m_pPidlMgr)
   delete m_pPidlMgr;

if(m_pMalloc)
   m_pMalloc->Release();

g_DllRefCount--;
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CDropTarget::QueryInterface()

**************************************************************************/

STDMETHODIMP CDropTarget::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
*ppReturn = NULL;

//IUnknown
if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = this;
   }

//IDropTarget
else if(IsEqualIID(riid, IID_IDropTarget))
   {
   *ppReturn = (IDropTarget*)this;
   }

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}

/**************************************************************************

   CDropTarget::AddRef()

**************************************************************************/

STDMETHODIMP_(DWORD) CDropTarget::AddRef(VOID)
{
return ++m_ObjRefCount;
}

/**************************************************************************

   CDropTarget::Release()

**************************************************************************/

STDMETHODIMP_(DWORD) CDropTarget::Release(VOID)
{
if(--m_ObjRefCount == 0)
   {
   delete this;
   return 0;
   }
   
return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IDropTarget Implementation
//

/**************************************************************************

   CDropTarget::DragEnter()

**************************************************************************/

STDMETHODIMP CDropTarget::DragEnter(   LPDATAOBJECT pDataObj, 
                                       DWORD dwKeyState, 
                                       POINTL pt, 
                                       LPDWORD pdwEffect)
{  
FORMATETC   fmtetc;
 
fmtetc.cfFormat   = m_cfPrivateData;
fmtetc.ptd        = NULL;
fmtetc.dwAspect   = DVASPECT_CONTENT;
fmtetc.lindex     = -1;
fmtetc.tymed      = TYMED_HGLOBAL;

//does the drag source provide our data type?
m_fAcceptFmt = (S_OK == pDataObj->QueryGetData(&fmtetc)) ? TRUE : FALSE;

QueryDrop(dwKeyState, pdwEffect);

return S_OK;
}

/**************************************************************************

   CDropTarget::DragOver()

**************************************************************************/

STDMETHODIMP CDropTarget::DragOver(DWORD dwKeyState, POINTL pt, LPDWORD pdwEffect)
{
QueryDrop(dwKeyState, pdwEffect);

return S_OK;
}

/**************************************************************************

   CDropTarget::DragLeave()

**************************************************************************/

STDMETHODIMP CDropTarget::DragLeave(VOID)
{
m_fAcceptFmt = FALSE;

return S_OK;
}

/**************************************************************************

   CDropTarget::Drop()

**************************************************************************/

STDMETHODIMP CDropTarget::Drop(  LPDATAOBJECT pDataObj,
                                 DWORD dwKeyState,
                                 POINTL pt,
                                 LPDWORD pdwEffect)
{   
HRESULT  hr = E_FAIL;

if(QueryDrop(dwKeyState, pdwEffect))
   {      
   FORMATETC   fmtetc;
   STGMEDIUM   medium;

   fmtetc.cfFormat   = m_cfPrivateData;
   fmtetc.ptd        = NULL;
   fmtetc.dwAspect   = DVASPECT_CONTENT;
   fmtetc.lindex     = -1;
   fmtetc.tymed      = TYMED_HGLOBAL;

   //The user has dropped on us. Get the data from the data object.
   hr = pDataObj->GetData(&fmtetc, &medium);
   if(SUCCEEDED(hr))
      {
      DoDrop(medium.hGlobal, DROPEFFECT_MOVE == *pdwEffect);

      //release the STGMEDIUM
      ReleaseStgMedium(&medium);

      return S_OK;
      }
   }

*pdwEffect = DROPEFFECT_NONE;

return hr;
}

/**************************************************************************

   CDropTarget::QueryDrop()

**************************************************************************/

BOOL CDropTarget::QueryDrop(DWORD dwKeyState, LPDWORD pdwEffect)
{
DWORD dwOKEffects = *pdwEffect;

*pdwEffect = DROPEFFECT_NONE;

if(m_fAcceptFmt)
   {
   *pdwEffect = GetDropEffectFromKeyState(dwKeyState);

   //we don't accept links
   if(DROPEFFECT_LINK == *pdwEffect)
      *pdwEffect = DROPEFFECT_NONE;
   
   /*
   Check if the drag source application allows the drop effect desired by the 
   user. The drag source specifies this in DoDragDrop. 
   */
   if(*pdwEffect & dwOKEffects)
      return TRUE;
   }

return FALSE;
}

/**************************************************************************

   CDropTarget::GetDropEffectFromKeyState()

**************************************************************************/

DWORD CDropTarget::GetDropEffectFromKeyState(DWORD dwKeyState)
{
//move is the default
DWORD dwDropEffect = DROPEFFECT_MOVE;

if(dwKeyState & MK_CONTROL)
   {
   if(dwKeyState & MK_SHIFT)
      {
      dwDropEffect = DROPEFFECT_LINK;
      }
   else
      {
      dwDropEffect = DROPEFFECT_COPY;
      }
   }

return dwDropEffect;
}

/**************************************************************************

   CDropTarget::DoDrop()

**************************************************************************/

BOOL CDropTarget::DoDrop(HGLOBAL hMem, BOOL fCut)
{
BOOL     fSuccess = FALSE;

if(hMem)
   {
   LPPRIVCLIPDATA pData = (LPPRIVCLIPDATA)GlobalLock(hMem);

   if(pData)
      {
      CShellFolder   *psfFrom = NULL;
      IShellFolder   *psfDesktop;
      LPITEMIDLIST   pidl;

      pidl = (LPITEMIDLIST)((LPBYTE)(pData) + pData->aoffset[0]);
      /*
      This is a fully qualified PIDL, so use the desktop folder to get the 
      IShellFolder for this folder.
      */
      SHGetDesktopFolder(&psfDesktop);
      if(psfDesktop)
         {
         psfDesktop->BindToObject(pidl, NULL, IID_IShellFolder, (LPVOID*)&psfFrom);
         psfDesktop->Release();
         }
      
      if(psfFrom)
         {
         LPITEMIDLIST   *aPidls;

         //allocate an array of PIDLS
         aPidls = AllocPidlTable(pData->cidl - 1);

         if(aPidls)
            {
            UINT  i;

            //fill in the PIDL array
            for(i = 0; i < pData->cidl - 1; i++)
               {
               aPidls[i] = m_pPidlMgr->Copy((LPITEMIDLIST)((LPBYTE)(pData) + pData->aoffset[i + 1]));
               }

            if(SUCCEEDED(m_psfParent->CopyItems(psfFrom, aPidls, pData->cidl - 1)))
               {
               fSuccess = TRUE;
      
               if(fCut)
                  {
                  psfFrom->DeleteItems(aPidls, pData->cidl - 1);
                  }
               }

            FreePidlTable(aPidls);
            }

         psfFrom->Release();
         }

      GlobalUnlock(hMem);
      }
   }

return fSuccess;
}

/**************************************************************************

   CDropTarget::AllocPidlTable()

**************************************************************************/

LPITEMIDLIST* CDropTarget::AllocPidlTable(DWORD dwEntries)
{
LPITEMIDLIST   *aPidls;

dwEntries++;

aPidls = (LPITEMIDLIST*)m_pMalloc->Alloc(dwEntries * sizeof(LPITEMIDLIST));

if(aPidls)
   {
   //set all of the entries to NULL
   ZeroMemory(aPidls, dwEntries * sizeof(LPITEMIDLIST));
   }

return aPidls;
}

/**************************************************************************

   CDropTarget::FreePidlTable()

**************************************************************************/

VOID CDropTarget::FreePidlTable(LPITEMIDLIST *aPidls)
{
if(aPidls && m_pPidlMgr)
   {
   UINT  i;
   for(i = 0; aPidls[i]; i++)
      m_pPidlMgr->Delete(aPidls[i]);
   
   m_pMalloc->Free(aPidls);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\extricon.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ExtrIcon.cpp
   
   Description:   Implements CExtractIcon.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "ExtrIcon.h"

/**************************************************************************

   CExtractIcon::CExtractIcon()

**************************************************************************/

CExtractIcon::CExtractIcon(LPCITEMIDLIST pidl)
{
g_DllRefCount++;

m_pPidlMgr = new CPidlMgr();
if(!m_pPidlMgr)
   {
   delete this;
   return;
   }

m_pidl = m_pPidlMgr->Copy(pidl);

m_ObjRefCount = 1;
}

/**************************************************************************

   CExtractIcon::~CExtractIcon()

**************************************************************************/

CExtractIcon::~CExtractIcon()
{
if(m_pidl)
   {
   m_pPidlMgr->Delete(m_pidl);
   m_pidl = NULL;
   }

if(m_pPidlMgr)
   {
   delete m_pPidlMgr;
   }

g_DllRefCount--;
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CExtractIcon::QueryInterface

**************************************************************************/

STDMETHODIMP CExtractIcon::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
*ppReturn = NULL;

//IUnknown
if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = this;
   }

//IExtractIcon
else if(IsEqualIID(riid, IID_IExtractIcon))
   {
   *ppReturn = (IExtractIcon*)this;
   }

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

/**************************************************************************

   CExtractIcon::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CExtractIcon::AddRef()
{
return ++m_ObjRefCount;
}

/**************************************************************************

   CExtractIcon::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CExtractIcon::Release()
{
if(--m_ObjRefCount == 0)
   {
   delete this;
   return 0;
   }
   
return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IExtractIcon Implementation
//

/**************************************************************************

   CExtractIcon::GetIconLocation()
   
**************************************************************************/

STDMETHODIMP CExtractIcon::GetIconLocation(  UINT uFlags, 
                                             LPTSTR szIconFile, 
                                             UINT cchMax, 
                                             LPINT piIndex, 
                                             LPUINT puFlags)
{
//tell the shell to always call Extract
*puFlags = GIL_NOTFILENAME;

//the pidl is either a value or a folder, so find out which it is
if(m_pPidlMgr->IsFolder(m_pPidlMgr->GetLastItem(m_pidl)))
   {
   //its a folder
   if(uFlags & GIL_OPENICON)
      {
      //tell Extract to return the open folder icon
      *piIndex = ICON_INDEX_FOLDEROPEN;
      }
   else
      {
      //tell Extract to return the closed folder icon
      *piIndex = ICON_INDEX_FOLDER;
      }
   }
else
   {
   //its not a folder
    *piIndex = m_pPidlMgr->GetIcon(m_pPidlMgr->GetLastItem(m_pidl));
    if (*piIndex < 0)
        *piIndex = ICON_INDEX_ITEM;  //tell Extract to return the item icon   
   }

return S_OK;
}

/**************************************************************************

   CExtractIcon::Extract()
   
**************************************************************************/

STDMETHODIMP CExtractIcon::Extract( LPCTSTR pszFile, 
                                    UINT nIconIndex, 
                                    HICON *phiconLarge, 
                                    HICON *phiconSmall, 
                                    UINT nIconSize)
{
*phiconLarge = ImageList_GetIcon(g_himlLarge, nIconIndex, ILD_TRANSPARENT);
*phiconSmall = ImageList_GetIcon(g_himlSmall, nIconIndex, ILD_TRANSPARENT);

return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\enumidl.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          EnumIDL.h
   
   Description:   CEnumIDList definitions.

**************************************************************************/

#ifndef ENUMIDLIST_H
#define ENUMIDLIST_H

#include <windows.h>
#include <shlobj.h>

#include "PidlMgr.h"
#include "Utility.h"

/**************************************************************************
   structure defintions
**************************************************************************/

typedef struct tagENUMLIST
   {
   struct tagENUMLIST   *pNext;
   LPITEMIDLIST         pidl;
   }ENUMLIST, FAR *LPENUMLIST;

/**************************************************************************

   CEnumIDList class definition

**************************************************************************/

class CEnumIDList : public IEnumIDList
{
private:
   DWORD       m_ObjRefCount;
   LPMALLOC    m_pMalloc;
   LPENUMLIST  m_pFirst;
   LPENUMLIST  m_pLast;
   LPENUMLIST  m_pCurrent;
   CPidlMgr    *m_pPidlMgr;
   DWORD       m_dwFlags;
   IXMLElement   *m_pXMLRoot;
   IXMLDocument *m_pXMLDoc;
   BOOL m_fFolder;
   
public:
   CEnumIDList(IXMLDocument *, DWORD);
   ~CEnumIDList();
   
   //IUnknown methods
   STDMETHOD (QueryInterface)(REFIID, LPVOID*);
   STDMETHOD_ (DWORD, AddRef)();
   STDMETHOD_ (DWORD, Release)();
   
   //IEnumIDList
   STDMETHOD (Next) (DWORD, LPITEMIDLIST*, LPDWORD);
   STDMETHOD (Skip) (DWORD);
   STDMETHOD (Reset) (VOID);
   STDMETHOD (Clone) (LPENUMIDLIST*);
   BOOL AddToEnumList(LPITEMIDLIST);
   DWORD GetFlags() {return m_dwFlags;}
   void SetFolder(BOOL flag) {m_fFolder = flag;}
   BOOL IsFolder() {return m_fFolder;}
   
private:
   BOOL CreateEnumList(VOID);
   BOOL DeleteList(VOID);
};

#endif   //ENUMIDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\extricon.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ExtrIcon.h
   
   Description:   CExtractIcon definitions.

**************************************************************************/

#ifndef EXTRACTICON_H
#define EXTRACTICON_H

/**************************************************************************
   #include statements
**************************************************************************/

#include <windows.h>
#include <shlobj.h>
#include "PidlMgr.h"
#include "Utility.h"

/**************************************************************************

   CExtractIcon class definition

**************************************************************************/

class CExtractIcon : public IExtractIcon
{
private:
   DWORD          m_ObjRefCount;
    LPITEMIDLIST   m_pidl;
   CPidlMgr       *m_pPidlMgr;

public:
   CExtractIcon(LPCITEMIDLIST);
   ~CExtractIcon();

   //IUnknown methods
   STDMETHOD (QueryInterface) (REFIID riid, LPVOID * ppvObj);
   STDMETHOD_ (ULONG, AddRef) (VOID);
   STDMETHOD_ (ULONG, Release) (VOID);

   //IExtractIcon methods
   STDMETHOD (GetIconLocation) (UINT, LPTSTR, UINT, LPINT, LPUINT);
   STDMETHOD (Extract) (LPCTSTR, UINT, HICON*, HICON*, UINT);
};

#define ICON_INDEX_ITEM       0
#define ICON_INDEX_FOLDER     1
#define ICON_INDEX_FOLDEROPEN 2

#endif   //EXTRACTICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\enumidl.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          EnumIDL.cpp
   
   Description:   Implements IEnumIDList.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "EnumIDL.h"
#include "ShlFldr.h"
#include "mshtml.h"
#include "msxml.h"
#include "ParseXML.h"

/**************************************************************************

   CEnumIDList::CEnumIDList

**************************************************************************/

CEnumIDList::CEnumIDList(IXMLDocument *pXMLDoc, DWORD dwFlags)
{
g_DllRefCount++;

m_pFirst = m_pLast = m_pCurrent = NULL;

m_pXMLRoot = NULL;
m_dwFlags = dwFlags;
m_fFolder = FALSE;
m_pXMLDoc = pXMLDoc;

m_pPidlMgr = new CPidlMgr();
if(!m_pPidlMgr)
   {
   delete this;
   return;
   }

//get the shell's IMalloc pointer
//we'll keep this until we get destroyed
if(FAILED(SHGetMalloc(&m_pMalloc)))
   {
   delete this;
   return;
   }

if(!CreateEnumList())
   {
   delete this;
   return;
   }

m_ObjRefCount = 1;
}

/**************************************************************************

   CEnumIDList::~CEnumIDList

**************************************************************************/

CEnumIDList::~CEnumIDList()
{
DeleteList();

if(m_pMalloc)
   m_pMalloc->Release();

if(m_pPidlMgr)
   delete m_pPidlMgr;

g_DllRefCount--;
}

/**************************************************************************

   CEnumIDList::QueryInterface

**************************************************************************/

STDMETHODIMP CEnumIDList::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
*ppReturn = NULL;

//IUnknown
if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = this;
   }
   
//IEnumIDList
else if(IsEqualIID(riid, IID_IEnumIDList))
   {
   *ppReturn = (IEnumIDList*)this;
   }   

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

/**************************************************************************

   CEnumIDList::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CEnumIDList::AddRef()
{
return ++m_ObjRefCount;
}


/**************************************************************************

   CEnumIDList::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CEnumIDList::Release()
{
if(--m_ObjRefCount == 0)
   {
   delete this;
   return 0;
   }
   
return m_ObjRefCount;
}

/**************************************************************************

   CEnumIDList::Next()
   
**************************************************************************/

STDMETHODIMP CEnumIDList::Next(DWORD dwElements, LPITEMIDLIST apidl[], LPDWORD pdwFetched)
{
DWORD    dwIndex;
HRESULT  hr = S_OK;

if(dwElements > 1 && !pdwFetched)
   return E_INVALIDARG;

for(dwIndex = 0; dwIndex < dwElements; dwIndex++)
   {
   //is this the last item in the list?
   if(!m_pCurrent)
      {
      hr =  S_FALSE;
      break;
      }

   apidl[dwIndex] = m_pPidlMgr->Copy(m_pCurrent->pidl);

   m_pCurrent = m_pCurrent->pNext;
   }

if(pdwFetched)
   *pdwFetched = dwIndex;

return hr;
}

/**************************************************************************

   CEnumIDList::Skip()
   
**************************************************************************/

STDMETHODIMP CEnumIDList::Skip(DWORD dwSkip)
{
DWORD    dwIndex;
HRESULT  hr = S_OK;

for(dwIndex = 0; dwIndex < dwSkip; dwIndex++)
   {
   //is this the last item in the list?
   if(!m_pCurrent)
      {
      hr = S_FALSE;
      break;
      }

   m_pCurrent = m_pCurrent->pNext;
   }

return hr;
}

/**************************************************************************

   CEnumIDList::Reset()
   
**************************************************************************/

STDMETHODIMP CEnumIDList::Reset(VOID)
{
m_pCurrent = m_pFirst;

return S_OK;
}

/**************************************************************************

   CEnumIDList::Clone()
   
**************************************************************************/

STDMETHODIMP CEnumIDList::Clone(LPENUMIDLIST *ppEnum)
{
HRESULT  hr = E_OUTOFMEMORY;

*ppEnum = new CEnumIDList(m_pXMLDoc, m_dwFlags);    

if(*ppEnum)
   {
   LPENUMLIST  pTemp;

   //synchronize the current pointer
   for(pTemp = m_pFirst; pTemp != m_pCurrent; pTemp = pTemp->pNext)
      {
      (*ppEnum)->Skip(1);
      }
   hr = S_OK;
   }

return hr;
}

/**************************************************************************

   CEnumIDList::CreateEnumList()
   
**************************************************************************/

BOOL CEnumIDList::CreateEnumList(VOID)
{
HRESULT hr;

// Get the sourse XML
if (m_pXMLDoc == NULL)
{
        return FALSE;
}

if (m_pXMLRoot == NULL)
{
    hr = m_pXMLDoc->get_root(&m_pXMLRoot);
    if (!SUCCEEDED(hr) || !m_pXMLRoot)
    {
        SAFERELEASE(m_pXMLRoot);
        return FALSE;
    }
}

//enumerate the folders
//
// Now walk the OM 
//
// Dump the top level meta nodes of the document.
//
DumpElement(NULL, m_pPidlMgr, this, m_pXMLRoot, T_ROOT); 

// Done
SAFERELEASE(m_pXMLRoot);
   
return TRUE;
}

/**************************************************************************

   CEnumIDList::AddToEnumList()
   
**************************************************************************/

BOOL CEnumIDList::AddToEnumList(LPITEMIDLIST pidl)
{
LPENUMLIST  pNew;

pNew = (LPENUMLIST)m_pMalloc->Alloc(sizeof(ENUMLIST));

if(pNew)
   {
   //set the next pointer
   pNew->pNext = NULL;
   pNew->pidl = pidl;

   //is this the first item in the list?
   if(!m_pFirst)
      {
      m_pFirst = pNew;
      m_pCurrent = m_pFirst;
      }

   if(m_pLast)
      {
      //add the new item to the end of the list
      m_pLast->pNext = pNew;
      }
   
   //update the last item pointer
   m_pLast = pNew;

   return TRUE;
   }

return FALSE;
}

/**************************************************************************

   CEnumIDList::DeleteList()
   
**************************************************************************/

BOOL CEnumIDList::DeleteList(VOID)
{
LPENUMLIST  pDelete;

while(m_pFirst)
   {
   pDelete = m_pFirst;
   m_pFirst = pDelete->pNext;

   //free the pidl
   m_pPidlMgr->Delete(pDelete->pidl);
   
   //free the list item
   m_pMalloc->Free(pDelete);
   }

m_pFirst = m_pLast = m_pCurrent = NULL;

return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\parsexml.cpp ===
//*******************************
// XML OM test code
//
// *******************************

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h>
#include <crtdbg.h>
#include <io.h>
#include <urlmon.h>
#include <hlink.h>
#include <dispex.h>
#include <shlobj.h>
#include "mshtml.h"
#include "msxml.h"
#include "Utility.h"
#include "EnumIDL.h"
#include "ParseXML.h"


//
// Dump an element attribute member if present.
//
void DumpAttrib(IXMLElement *pElem, BSTR bstrAttribName)
{
    VARIANT vProp;
    
    VariantInit(&vProp);

    if (SUCCEEDED(pElem->getAttribute(bstrAttribName, &vProp)))
    {
        if (vProp.vt == VT_BSTR)
        {
            printf(" %S=\"%S\"", bstrAttribName, vProp.bstrVal);
        }
        VariantClear(&vProp);
    }
}

//
// Helper routine to quickly find out if this is a named element
// currently only used to improve the format of the output.
//
BOOL IsNamedElement(IXMLElement *pElem)
{
    BSTR bstrName;

    if (SUCCEEDED(pElem->get_tagName(&bstrName)))
    {
        if (bstrName)
        {
            SysFreeString(bstrName);
            return TRUE;
        }
    }
    return FALSE;
}


void DumpElement
(
  LPITEMIDLIST   pidl,
 CPidlMgr *pCPidlMgr,
 CEnumIDList   *pCEnumIDList,
 IXMLElement * pElem,
 XMLTAG tag
)
{
    BSTR bstrTagName = NULL;
    BSTR bstrContent = NULL;
    IXMLElementCollection * pChildren;
    BSTR bstrITEM = L"ITEM";
    BSTR bstrNAME = L"NAME";
    BSTR bstrTYPE = L"TYPE";
    BSTR bstrFOLDER = L"Folder";
    BSTR bstrICON = L"ICON";
    BSTR bstrBASE_URL = L"BASE-URL";

    //
    // Dump the NODE.
    //
    pElem->get_tagName(&bstrTagName);
    if (bstrTagName)
    {
        if (!_wcsicmp(bstrTagName, bstrITEM)) 
        {
            if  (tag == T_ITEM)
            {
                // Skip internal ITEMs
                SysFreeString(bstrTagName);
                return;
            }
            else if (tag == T_ROOT)
            {
                // We are at the root
                // Drill down and look for ITEMs
                tag = T_NONE;
            }
            else
            {
                // Drill down
                tag = T_ITEM;
                // Create new PIDL
                pidl = pCPidlMgr->Create();
                if(pidl)
                  pCEnumIDList->AddToEnumList(pidl);
            }
        }
        else if (!_wcsicmp(bstrTagName, bstrNAME))
            // Drill down
            tag = T_NAME;
        else if (!_wcsicmp(bstrTagName, bstrTYPE))
            // Drill down
            tag =T_TYPE;
        else if (!_wcsicmp(bstrTagName, bstrICON))
            // Drill down
            tag = T_ICON;
        else if (!_wcsicmp(bstrTagName, bstrBASE_URL))
            // Drill down
            tag = T_BASE_URL;
        else 
        {
            // We are not interested
            SysFreeString(bstrTagName);
            return;
        }
    }
    else 
    {
        // Build PIDL
        XMLELEM_TYPE xmlElemType;
        PIDLDATA pidldata;
        if (SUCCEEDED(pElem->get_type((long *)&xmlElemType)))
        {
            if (xmlElemType == XMLELEMTYPE_TEXT)
            {
                if (SUCCEEDED(pElem->get_text(&bstrContent)))
                {
                    if (bstrContent)
                    {
                        if (tag == T_TYPE)
                        {
                            if ( !_wcsicmp(bstrContent, bstrFOLDER))    // Later check on SHCONTF_FOLDERS
                                pidldata.fFolder = TRUE;
                            else
                                pidldata.fFolder = FALSE;

                            pidl = pCPidlMgr->SetDataPidl(pidl, &pidldata, FOLDER);
                        }
                        else if (tag == T_NAME)
                        {
                            WideCharToLocal(pidldata.szName, bstrContent, MAX_NAME);
                            pidl = pCPidlMgr->SetDataPidl(pidl, &pidldata, NAME);
                        }
                        else if (tag == T_ICON)
                        {
                            TCHAR szIcon[MAX_NAME];
                            WideCharToLocal(szIcon, bstrContent, MAX_NAME);
                            int index = AddIconImageList(g_himlLarge, szIcon);
                            AddIconImageList(g_himlSmall, szIcon);
                            pidldata.iIcon = index;
                            pidl = pCPidlMgr->SetDataPidl(pidl, &pidldata, ICON);
                        }
                        else if (tag == T_BASE_URL)
                        {
                            WideCharToLocal(pidldata.szUrl, bstrContent, MAX_NAME);
                            pidl = pCPidlMgr->SetDataPidl(pidl, &pidldata, URL);
                        }
                    }
                    SysFreeString(bstrContent);
                }
            }
        }
        return;    // no need to free bstrTagName
    }
    //
    // Find the children if they exist.
    //
    if (SUCCEEDED(pElem->get_children(&pChildren)) && pChildren)
    {
        WALK_ELEMENT_COLLECTION(pChildren, pDisp)
        {
            //
            // pDisp will iterate over an IDispatch for each item in the collection.
            //
            IXMLElement * pChild;
            if (SUCCEEDED(pDisp->QueryInterface(IID_IXMLElement, (void **)&pChild)))
            {
                DumpElement(pidl, pCPidlMgr, pCEnumIDList, pChild, tag );
                pChild->Release();
            }
        }
        END_WALK_ELEMENT_COLLECTION(pDisp);
        pChildren->Release();
    }

    if (bstrTagName)
        SysFreeString(bstrTagName);
}

int MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCTSTR psz)
{
    int i;
    i=MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchWideChar);
    if (!i)
    {
        //DBG_WARN("MyStrToOleStrN string too long; truncated");
        pwsz[cchWideChar-1]=0;
    }
    else
        ZeroMemory(pwsz+i, sizeof(OLECHAR)*(cchWideChar-i));

    return i;
}


HRESULT GetSourceXML(IXMLDocument **ppDoc, TCHAR  *pszURL)
{
    PSTR pszErr = NULL;
    IStream                *pStm = NULL;
    IPersistStreamInit     *pPSI = NULL;
    IXMLElement            *pElem = NULL;
    WCHAR                  *pwszURL=NULL;
    BSTR                   pBURL=NULL;
    HRESULT hr;
    int cszURL = 0;

    //
    // Create an empty XML document.
    //
    hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                                IID_IXMLDocument, (void**)ppDoc);

    CHECK_ERROR (*ppDoc, "CoCreateInstance Failed");
 
    pwszURL = (WCHAR *)LocalAlloc(LMEM_FIXED, ((sizeof(WCHAR))*(strlen(pszURL) + 2)));
    CHECK_ERROR(pwszURL, "Mem Alloc Failure");

    cszURL = MyStrToOleStrN(pwszURL, (strlen(pszURL) + 1), pszURL);
    CHECK_ERROR(cszURL, "Failed to convert to UNICODE");
    pBURL = SysAllocString(pwszURL);
    CHECK_ERROR(pBURL, "Mem Alloc Failure");
    LocalFree(pwszURL);

    hr = (*ppDoc)->put_URL(pBURL);

    if (! SUCCEEDED(hr))
    {
        //
        // Failed to parse stream, output error information.
        //
        IXMLError *pXMLError = NULL ;
        XML_ERROR xmle;
    
        hr = (*ppDoc)->QueryInterface(IID_IXMLError, (void **)&pXMLError);
        CHECK_ERROR(SUCCEEDED(hr), "Couldn't get IXMLError");
    
//        ASSERT(pXMLError);
    
        hr = pXMLError->GetErrorInfo(&xmle);
        SAFERELEASE(pXMLError);
        CHECK_ERROR(SUCCEEDED(hr), "GetErrorInfo Failed");
    
        SysFreeString(xmle._pszFound);
        SysFreeString(xmle._pszExpected);
        SysFreeString(xmle._pchBuf);
    }

done: // Clean up.
    //
    // Release any used interfaces.
    //
    SAFERELEASE(pPSI);
    SAFERELEASE(pStm);
//    SAFERELEASE(*ppDoc);    Do it in the caller!!!!!!!!!!!!!!!!!!
    SysFreeString(pBURL);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\guid.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          Guid.h
   
   Description:   Private GUID definition.

**************************************************************************/

// {E2CB71D0-D2DC-11d1-B022-00600893AD51}
DEFINE_GUID(   CLSID_SampleNameSpace, 
               0xe2cb71d0, 
               0xd2dc, 
               0x11d1, 
               0xb0, 
               0x22, 
               0x0, 
               0x60, 
               0x8, 
               0x93, 
               0xad, 
               0x52);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\parsexml.h ===
#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}
#define SAFERELEASE(p) if (p) {(p)->Release(); p = NULL;} else ;

typedef enum tagXMLTAG
{
    T_ROOT,
    T_NONE,
    T_ITEM,
    T_NAME,
    T_ICON,
    T_TYPE,
    T_BASE_URL
} XMLTAG;

HRESULT GetSourceXML(IXMLDocument **, TCHAR *);
//void DumpElement(LPITEMIDLIST (CPidlMgr::*)( LPCTSTR )  , BOOL (CEnumIDList::*)(LPITEMIDLIST), IXMLElement *);
void DumpElement(LPITEMIDLIST, CPidlMgr *,  CEnumIDList   *, IXMLElement *, XMLTAG);

#define WALK_ELEMENT_COLLECTION(pCollection, pDispItem) \
    {\
        long length;\
        \
        if (SUCCEEDED(pChildren->get_length(&length)) && length > 0)\
        {\
            VARIANT vIndex, vEmpty;\
            vIndex.vt = VT_I4;\
            vEmpty.vt = VT_EMPTY;\
                                 \
            for (long i=0; i<length; i++)\
            {\
                vIndex.lVal = i;\
                IDispatch *pDispItem = NULL;\
                if (SUCCEEDED(pCollection->item(vIndex, vEmpty, &pDispItem)))\
                {

#define END_WALK_ELEMENT_COLLECTION(pDispItem) \
                    pDispItem->Release();\
                }\
            }\
        }\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\pidlmgr.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          PidlMgr.h
   
   Description:   CPidlMgr definitions.

**************************************************************************/

#ifndef PIDLMGR_H
#define PIDLMGR_H

#include <windows.h>
#include <shlobj.h>

/**************************************************************************
   data types
**************************************************************************/

#define MAX_NAME MAX_PATH
#define MAX_DATA 128

typedef struct tagPIDLDATA
   {
   BOOL fFolder;
   TCHAR szName[MAX_NAME];
   TCHAR szData[MAX_DATA];
   TCHAR szUrl[MAX_DATA];
   int iIcon;
   }PIDLDATA, FAR *LPPIDLDATA;

typedef enum tagPIDLDATATYPE
{
    FOLDER = 0x1,
    NAME = 0x2,
    DATA = 0x4,
    ICON = 0x8,
    URL = 0x10
} PIDLDATATYPE;

/**************************************************************************

   CPidlMgr class definition

**************************************************************************/

class CPidlMgr
{
public:
   CPidlMgr();
   ~CPidlMgr();

   VOID Delete(LPITEMIDLIST);
   LPITEMIDLIST GetNextItem(LPCITEMIDLIST);
   LPITEMIDLIST Copy(LPCITEMIDLIST);
   LPITEMIDLIST CopySingleItem(LPCITEMIDLIST);
   LPITEMIDLIST GetLastItem(LPCITEMIDLIST);
   LPITEMIDLIST Concatenate(LPCITEMIDLIST, LPCITEMIDLIST);
   LPITEMIDLIST Create(VOID);
   LPITEMIDLIST CreateFolderPidl(LPCTSTR);
   LPITEMIDLIST CreateItemPidl(LPCTSTR, LPCTSTR);
   LPITEMIDLIST SetDataPidl(LPITEMIDLIST, LPPIDLDATA , PIDLDATATYPE);
   
   int GetName(LPCITEMIDLIST, LPTSTR, DWORD);
   int GetRelativeName(LPCITEMIDLIST, LPTSTR, DWORD);
   int GetData(LPCITEMIDLIST, LPTSTR, DWORD);
   BOOL IsFolder(LPCITEMIDLIST);
   int SetData(LPCITEMIDLIST, LPCTSTR);
   UINT GetSize(LPCITEMIDLIST);
   int GetIcon(LPCITEMIDLIST);
   int GetUrl(LPCITEMIDLIST, LPTSTR, DWORD);

private:
   LPMALLOC m_pMalloc;
   LPPIDLDATA GetDataPointer(LPCITEMIDLIST);
};

#endif   //PIDLMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\shlfldr.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ShlFldr.cpp
   
   Description:   Implements CShellFolder.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "ShlFldr.h"
#include "ShlView.h"
#include "ExtrIcon.h"
#include "ContMenu.h"
#include "DataObj.h"
#include "DropTgt.h"
#include "ViewList.h"
#include "Guid.h"
#include "resource.h"
#include "Utility.h"
#include "ParseXML.h"

/**************************************************************************
   global variables
**************************************************************************/

#define DEFAULT_DATA TEXT("Data")

extern CViewList  *g_pViewList;

/**************************************************************************

   CShellFolder::CShellFolder()

**************************************************************************/

CShellFolder::CShellFolder(CShellFolder *pParent, LPCITEMIDLIST pidl)
{
g_DllRefCount++;

m_psfParent = pParent;
if(m_psfParent)
   m_psfParent->AddRef();

m_pPidlMgr = new CPidlMgr();
if(!m_pPidlMgr)
   {
   delete this;
   return;
   }

//get the shell's IMalloc pointer
//we'll keep this until we get destroyed
if(FAILED(SHGetMalloc(&m_pMalloc)))
   {
   delete this;
   return;
   }

m_pidlFQ = NULL;
m_pidlRel = NULL;
if(pidl)
   {
   m_pidlRel = m_pPidlMgr->Copy(pidl);
   }
m_pXMLDoc = NULL;

m_ObjRefCount = 1;
}

/**************************************************************************

   CShellFolder::~CShellFolder()

**************************************************************************/

CShellFolder::~CShellFolder()
{
if(m_pidlRel)
   {
   m_pPidlMgr->Delete(m_pidlRel);
   m_pidlRel = NULL;
   }

if(m_pidlFQ)
   {
   m_pPidlMgr->Delete(m_pidlFQ);
   m_pidlFQ = NULL;
   }

if(m_psfParent)
   m_psfParent->Release();

if(m_pMalloc)
   {
   m_pMalloc->Release();
   }

if(m_pPidlMgr)
   {
   delete m_pPidlMgr;
   }

if (m_pXMLDoc)
  SAFERELEASE(m_pXMLDoc);

g_DllRefCount--;
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CShellFolder::QueryInterface

**************************************************************************/

STDMETHODIMP CShellFolder::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
*ppReturn = NULL;

//IUnknown
if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = this;
   }

//IShellFolder
else if(IsEqualIID(riid, IID_IShellFolder))
   {
   *ppReturn = (IShellFolder*)this;
   }

//IPersist
else if(IsEqualIID(riid, IID_IPersist))
   {
   *ppReturn = (IPersist*)this;
   }

//IPersistFolder
else if(IsEqualIID(riid, IID_IPersistFolder))
   {
   *ppReturn = (IPersistFolder*)this;
   }

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

#define DC_NAME   TEXT("David Campbell")
#define DC_DATA   TEXT("Really Loves Cheese")

/**************************************************************************

   CShellFolder::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CShellFolder::AddRef(VOID)
{
return ++m_ObjRefCount;
}

/**************************************************************************

   CShellFolder::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CShellFolder::Release(VOID)
{
if(--m_ObjRefCount == 0)
   {
   delete this;
   return 0;
   }
   
return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IPersist Implementation
//

/**************************************************************************

   CShellView::GetClassID()
   
**************************************************************************/

STDMETHODIMP CShellFolder::GetClassID(LPCLSID lpClassID)
{
*lpClassID = CLSID_SampleNameSpace;

return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// IPersistFolder Implementation
//

/**************************************************************************

   CShellView::Initialize()
   
**************************************************************************/

STDMETHODIMP CShellFolder::Initialize(LPCITEMIDLIST pidlFQ)
{
if(m_pidlFQ)
   {
   m_pPidlMgr->Delete(m_pidlFQ);
   m_pidlFQ = NULL;
   }

m_pidlFQ = m_pPidlMgr->Copy(pidlFQ);

return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// IShellFolder Implementation
//

/**************************************************************************

   CShellFolder::BindToObject()
   
**************************************************************************/

STDMETHODIMP CShellFolder::BindToObject(  LPCITEMIDLIST pidl, 
                                          LPBC pbcReserved, 
                                          REFIID riid, 
                                          LPVOID *ppvOut)
{
*ppvOut = NULL;

//Make sure the item is a folder.
ULONG ulAttribs = SFGAO_FOLDER;
this->GetAttributesOf(1, &pidl, &ulAttribs);
if(!(ulAttribs & SFGAO_FOLDER))
   return E_INVALIDARG;

CShellFolder   *pShellFolder = new CShellFolder(this, pidl);
if(!pShellFolder)
   return E_OUTOFMEMORY;

LPITEMIDLIST   pidlTemp = m_pPidlMgr->Concatenate(m_pidlFQ, pidl);
pShellFolder->Initialize(pidlTemp);
m_pPidlMgr->Delete(pidlTemp);

HRESULT  hr = pShellFolder->QueryInterface(riid, ppvOut);

pShellFolder->Release();

return hr;
}

/**************************************************************************

   CShellFolder::BindToStorage()
   
**************************************************************************/

STDMETHODIMP CShellFolder::BindToStorage( LPCITEMIDLIST pidl, 
                                          LPBC pbcReserved, 
                                          REFIID riid, 
                                          LPVOID *ppvOut)
{
*ppvOut = NULL;

return E_NOTIMPL;
}

/**************************************************************************

   CShellFolder::CompareIDs()
   
**************************************************************************/

STDMETHODIMP CShellFolder::CompareIDs( LPARAM lParam, 
                                       LPCITEMIDLIST pidl1, 
                                       LPCITEMIDLIST pidl2)
{
HRESULT        hr = E_FAIL;
LPITEMIDLIST   pidlTemp1;
LPITEMIDLIST   pidlTemp2;

//walk down the lists, comparing each individual item

pidlTemp1 = (LPITEMIDLIST)pidl1;
pidlTemp2 = (LPITEMIDLIST)pidl2;

while(pidlTemp1 && pidlTemp2)
   {
   hr = CompareItems(pidlTemp1, pidlTemp2);
   if(HRESULT_CODE(hr))
      {
      //the items are different
      break;
      }

   pidlTemp1 = m_pPidlMgr->GetNextItem(pidlTemp1);
   pidlTemp2 = m_pPidlMgr->GetNextItem(pidlTemp2);

   if(pidlTemp1 && !pidlTemp1->mkid.cb)
      {
      pidlTemp1 = NULL;
      }

   if(pidlTemp2 && !pidlTemp2->mkid.cb)
      {
      pidlTemp2 = NULL;
      }

   hr = E_FAIL;
   }

if(!pidlTemp1 && pidlTemp2)
   {
   //pidl1 is at a higher level than pidl2
   return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(-1));
   }
else if(pidlTemp1 && !pidlTemp2)
   {
   //pidl2 is at a higher level than pidl1
   return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(1));
   }
else if(SUCCEEDED(hr))
   {
   //the items are at the same level but are different
   return hr;
   }

//the items are the same
return MAKE_HRESULT(SEVERITY_SUCCESS, 0, 0);
}

/**************************************************************************

   CShellFolder::CreateViewObject()
   
**************************************************************************/

STDMETHODIMP CShellFolder::CreateViewObject( HWND hwndOwner, 
                                             REFIID riid, 
                                             LPVOID *ppvOut)
{
HRESULT  hr = E_NOINTERFACE;

if(IsEqualIID(riid, IID_IShellView))
   {
   CShellView  *pShellView;

   *ppvOut = NULL;

   pShellView = new CShellView(this, m_pidlRel);
   if(!pShellView)
      return E_OUTOFMEMORY;

   hr = pShellView->QueryInterface(riid, ppvOut);

   pShellView->Release();
   }
else if(IsEqualIID(riid, IID_IDropTarget))
   {
   CDropTarget *pdt = new CDropTarget(this);

   if(pdt)
      {
      *ppvOut = pdt;
      return S_OK;
      }
   }
else if(IsEqualIID(riid, IID_IContextMenu))
   {
   /*
   Create a context menu object for this folder. This can be used for the 
   background of a view.
   */
   CContextMenu   *pcm = new CContextMenu(this);

   if(pcm)
      {
      *ppvOut = pcm;
      return S_OK;
      }
   }


return hr;
}

/**************************************************************************

   CShellFolder::EnumObjects()
   
**************************************************************************/

STDMETHODIMP CShellFolder::EnumObjects(   HWND hwndOwner, 
                                          DWORD dwFlags, 
                                          LPENUMIDLIST *ppEnumIDList)
{
*ppEnumIDList = NULL;
TCHAR  szXMLUrl[MAX_PATH];
LPTSTR pszXMLUrl = szXMLUrl;
HRESULT hr;

if (m_pidlRel == NULL)
{
    // The root of namespace
    pszXMLUrl = (TCHAR *)g_szXMLUrl;
}
else if (m_pPidlMgr->GetUrl(m_pidlRel, pszXMLUrl, MAX_PATH) < 0 )
    return E_FAIL;

if (m_pXMLDoc == NULL)
{
    hr = GetSourceXML(&m_pXMLDoc, pszXMLUrl);
    if (!SUCCEEDED(hr) || !m_pXMLDoc)
    {
        SAFERELEASE(m_pXMLDoc);
        return hr;
    }
    BSTR bstrVal;
    hr = m_pXMLDoc->get_version(&bstrVal);
    // Check if the version is correct ???????
    // 
    SysFreeString(bstrVal);
    bstrVal = NULL;
}

*ppEnumIDList = new CEnumIDList(m_pXMLDoc, dwFlags);

if(!*ppEnumIDList)
   return E_OUTOFMEMORY;

return S_OK;
}

/**************************************************************************

   CShellFolder::GetAttributesOf()
   
**************************************************************************/

STDMETHODIMP CShellFolder::GetAttributesOf(  UINT uCount, 
                                             LPCITEMIDLIST aPidls[], 
                                             LPDWORD pdwAttribs)
{
UINT  i;

if(IsBadWritePtr(pdwAttribs, sizeof(DWORD)))
   {
   return E_INVALIDARG;
   }

if(0 == uCount)
   {
   /*
   This can happen in the Win95 shell when the view is run in rooted mode. 
   When this occurs, return the attributes for a plain old folder.
   */
   *pdwAttribs = SFGAO_FOLDER | 
                  SFGAO_HASSUBFOLDER | 
                  SFGAO_BROWSABLE | 
                  SFGAO_DROPTARGET;
   }

for(i = 0; i < uCount; i++)
   {
   DWORD dwAttribs = 0;

   //Add the flags common to all items, if applicable.
   dwAttribs |= SFGAO_CANRENAME | SFGAO_CANDELETE | SFGAO_CANCOPY | SFGAO_CANMOVE;

   //is this item a folder?
   if(m_pPidlMgr->IsFolder(m_pPidlMgr->GetLastItem(aPidls[i])))
      {
      dwAttribs |= SFGAO_FOLDER | SFGAO_BROWSABLE | SFGAO_DROPTARGET | SFGAO_CANLINK;

      //does this folder item have any sub folders?
      if(HasSubFolder(aPidls[i]))
         dwAttribs |= SFGAO_HASSUBFOLDER;
      }
   
   *pdwAttribs &= dwAttribs;
   }

return S_OK;
}

/**************************************************************************

   CShellFolder::GetUIObjectOf()
   
**************************************************************************/

STDMETHODIMP CShellFolder::GetUIObjectOf( HWND hwndOwner, 
                                          UINT uCount, 
                                          LPCITEMIDLIST *pPidls, 
                                          REFIID riid, 
                                          LPUINT puReserved, 
                                          LPVOID *ppvOut)
{
*ppvOut = NULL;

if(IsEqualIID(riid, IID_IContextMenu))
   {
   CContextMenu   *pcm = new CContextMenu(this, pPidls, uCount);

   if(pcm)
      {
      *ppvOut = pcm;
      return S_OK;
      }
   }

else if(IsEqualIID(riid, IID_IDataObject))
   {
   CDataObject *pdo = new CDataObject(this, pPidls, uCount);

   if(pdo)
      {
      *ppvOut = pdo;
      return S_OK;
      }
   }

if(uCount != 1)
   return E_INVALIDARG;

if(IsEqualIID(riid, IID_IExtractIcon))
   {
   CExtractIcon   *pei;
   LPITEMIDLIST   pidl;

   pidl = m_pPidlMgr->Concatenate(m_pidlRel, pPidls[0]);

   pei = new CExtractIcon(pidl);

   /*
   The temp PIDL can be deleted because the new CExtractIcon either failed or 
   made its own copy of it.
   */
   m_pPidlMgr->Delete(pidl);

   if(pei)
      {
      *ppvOut = pei;
      return S_OK;
      }
   
   return E_OUTOFMEMORY;
   }
else if(IsEqualIID(riid, IID_IDropTarget))
   {
   CShellFolder   *psfTemp = NULL;

   BindToObject(pPidls[0], NULL, IID_IShellFolder, (LPVOID*)&psfTemp);

   if(psfTemp)
      {
      CDropTarget *pdt = new CDropTarget(psfTemp);

      psfTemp->Release();
      
      if(pdt)
         {
         *ppvOut = pdt;
         return S_OK;
         }
      }
   }

return E_NOINTERFACE;
}

/**************************************************************************

   CShellFolder::GetDisplayNameOf()
   
**************************************************************************/

STDMETHODIMP CShellFolder::GetDisplayNameOf( LPCITEMIDLIST pidl, 
                                             DWORD dwFlags, 
                                             LPSTRRET lpName)
{
TCHAR szText[MAX_PATH] = TEXT("");
int   cchOleStr;

if(dwFlags & SHGDN_FORPARSING)
   {
   //a "path" is being requested - is it full or relative?
   if(dwFlags & SHGDN_INFOLDER)
      {
      //the relative path is being requested
      m_pPidlMgr->GetRelativeName(pidl, szText, ARRAYSIZE(szText));
      }
   else
      {
      GetFullName(pidl, szText, ARRAYSIZE(szText));
      }
   }
else
   {
   //only the text of the last item is being requested
   LPITEMIDLIST   pidlLast = m_pPidlMgr->GetLastItem(pidl);
   m_pPidlMgr->GetRelativeName(pidlLast, szText, ARRAYSIZE(szText));
   }

//put this in to see what SHGDN options are specified for different displays
#if 0
if(dwFlags & SHGDN_FORPARSING)
   lstrcat(szText, " [FP]");

if(dwFlags & SHGDN_INFOLDER)
   lstrcat(szText, " [IF]");

if(dwFlags & SHGDN_FORADDRESSBAR)
   lstrcat(szText, " [AB]");
#endif

//get the number of characters required
cchOleStr = lstrlen(szText) + 1;

//allocate the wide character string
lpName->pOleStr = (LPWSTR)m_pMalloc->Alloc(cchOleStr * sizeof(WCHAR));
if(!lpName->pOleStr)
   return E_OUTOFMEMORY;

lpName->uType = STRRET_WSTR;

LocalToWideChar(lpName->pOleStr, szText, cchOleStr);

return S_OK;
}

/**************************************************************************

   CShellFolder::ParseDisplayName()
   
**************************************************************************/

STDMETHODIMP CShellFolder::ParseDisplayName( HWND hwndOwner, 
                                             LPBC pbcReserved, 
                                             LPOLESTR lpDisplayName, 
                                             LPDWORD pdwEaten, 
                                             LPITEMIDLIST *pPidlNew, 
                                             LPDWORD pdwAttributes)
{
return E_NOTIMPL;
}

/**************************************************************************

   CShellFolder::SetNameOf()
   
**************************************************************************/

STDMETHODIMP CShellFolder::SetNameOf(  HWND hwndOwner, 
                                       LPCITEMIDLIST pidl, 
                                       LPCOLESTR lpName, 
                                       DWORD dwFlags, 
                                       LPITEMIDLIST *ppidlOut)
{
if(!pidl)
   return E_INVALIDARG;

if(m_pPidlMgr->IsFolder(pidl))
   {
   TCHAR          szOld[MAX_PATH];
   TCHAR          szNew[MAX_PATH];
   LPTSTR         pszTemp;
   LPITEMIDLIST   pidlNew;
   LPITEMIDLIST   pidlFQOld;
   LPITEMIDLIST   pidlFQNew;

   //get the old name
   GetPath(pidl, szOld, MAX_PATH);

   //build the new name
   GetPath(pidl, szNew, MAX_PATH);
   for(pszTemp = szNew + lstrlen(szNew) - 1; pszTemp > szNew; pszTemp--)
      {
      if('\\' == *pszTemp)
         {
         *(pszTemp + 1) = 0;
         break;
         }
      }

   pszTemp = szNew + lstrlen(szNew);
   WideCharToLocal(pszTemp, (LPWSTR)lpName, MAX_PATH);

   if(!MoveFile(szOld, szNew))
      {
      MessageBeep(MB_ICONERROR);
      return E_FAIL;
      }
   
   //create a PIDL for the renamed folder using the relative name
   WideCharToLocal(szNew, (LPWSTR)lpName, MAX_PATH);
   pidlNew = m_pPidlMgr->CreateFolderPidl(szNew);

   pidlFQOld = CreateFQPidl(pidl);
   pidlFQNew = CreateFQPidl(pidlNew);

   SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_IDLIST, pidlFQOld, pidlFQNew);

   NotifyViews(SHCNE_RENAMEFOLDER, pidl, pidlNew);

   if(ppidlOut)
      {
      *ppidlOut = pidlNew;
      }
   else
      {
      m_pPidlMgr->Delete(pidlNew);
      }

   m_pPidlMgr->Delete(pidlFQOld);
   m_pPidlMgr->Delete(pidlFQNew);
   }
else
   {
   TCHAR          szOld[MAX_PATH];
   TCHAR          szNew[MAX_PATH];
   TCHAR          szData[MAX_DATA];
   TCHAR          szFile[MAX_PATH];
   LPITEMIDLIST   pidlNew;
   LPITEMIDLIST   pidlFQOld;
   LPITEMIDLIST   pidlFQNew;

   //get the new name
   WideCharToLocal(szNew, (LPWSTR)lpName, MAX_PATH);

   //get the file name
   GetPath(pidl, szFile, MAX_PATH);

   //get the old item name
   m_pPidlMgr->GetName(pidl, szOld, MAX_PATH);

   //get the old item's data
   m_pPidlMgr->GetData(pidl, szData, MAX_PATH);

   //remove the old entry from the INI file
   WritePrivateProfileString( c_szSection,
                              szOld,
                              NULL,
                              szFile);

   //add the new entry into the INI file
   WritePrivateProfileString( c_szSection,
                              szNew,
                              szData,
                              szFile);

   m_pPidlMgr->GetData(pidl, szData, MAX_DATA);
   pidlNew = m_pPidlMgr->CreateItemPidl(szNew, szData);

   pidlFQOld = CreateFQPidl(pidl);
   pidlFQNew = CreateFQPidl(pidlNew);

   SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_IDLIST, pidlFQOld, pidlFQNew);

   NotifyViews(SHCNE_RENAMEITEM, pidl, pidlNew);

   if(0 == lstrcmpi(szNew, DC_NAME))
      {
      SetItemData((LPCITEMIDLIST)pidlNew, DC_DATA);
      }

   if(ppidlOut)
      {
      *ppidlOut = pidlNew;
      m_pPidlMgr->Delete((LPITEMIDLIST)pidl);
      }
   else
      {
      m_pPidlMgr->Delete(pidlNew);
      }

   m_pPidlMgr->Delete(pidlFQOld);
   m_pPidlMgr->Delete(pidlFQNew);
   }

return S_OK;
}

/**************************************************************************

   CShellFolder::AddFolder()

**************************************************************************/

STDMETHODIMP CShellFolder::AddFolder(LPCTSTR pszName, LPITEMIDLIST *ppidlOut)
{
HRESULT  hr = E_FAIL;

//create a folder
TCHAR szFolder[MAX_PATH] = TEXT("");

if(m_pidlRel)
   {
   GetPath(NULL, szFolder, MAX_PATH);
   }
else
   {
   lstrcpy(szFolder, g_szStoragePath);
   }

SmartAppendBackslash(szFolder);
lstrcat(szFolder, pszName);

if(ppidlOut)
   *ppidlOut = NULL;

if(CreateDirectory(szFolder, NULL))
   {
   LPITEMIDLIST   pidl;

   //set the attributes that define one of our folders
   DWORD dwAttr = GetFileAttributes(szFolder);
   SetFileAttributes(szFolder, dwAttr | FILTER_ATTRIBUTES);

   //add an empty items.ini file because this also defines one of our folders
   TCHAR szFile[MAX_PATH];
   lstrcpy(szFile, szFolder);
   SmartAppendBackslash(szFile);
   lstrcat(szFile, c_szDataFile);
   HANDLE   hFile;
   hFile = CreateFile(  szFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
   CloseHandle(hFile);
   
   pidl = m_pPidlMgr->CreateFolderPidl(pszName);
   if(pidl)
      {
      LPITEMIDLIST   pidlFQ;

      hr = S_OK;

      pidlFQ = CreateFQPidl(pidl);
   
      SHChangeNotify(SHCNE_MKDIR, SHCNF_IDLIST, pidlFQ, NULL);

      NotifyViews(SHCNE_MKDIR, pidl, NULL);

      m_pPidlMgr->Delete(pidlFQ);

      if(ppidlOut)
         *ppidlOut = pidl;
      else
         m_pPidlMgr->Delete(pidl);
      }
   }

return hr;
}

/**************************************************************************

   CShellFolder::AddItem()

**************************************************************************/

STDMETHODIMP CShellFolder::AddItem( LPCTSTR pszName, 
                                    LPCTSTR pszData, 
                                    LPITEMIDLIST *ppidlOut)
{
if(ppidlOut)
   *ppidlOut = NULL;

//create an item
HRESULT  hr = E_FAIL;
TCHAR    szFile[MAX_PATH];
LPCTSTR  psz = DEFAULT_DATA;

if(pszData && *pszData)
   psz = pszData;

//get the file name
if(m_pidlRel)
   {
   GetPath(NULL, szFile, MAX_PATH);
   }
else
   {
   lstrcpy(szFile, g_szStoragePath);
   }

SmartAppendBackslash(szFile);
lstrcat(szFile, c_szDataFile);

//add the new entry into the INI file
if(WritePrivateProfileString( c_szSection,
                              pszName,
                              DEFAULT_DATA,
                              szFile))
   {
   LPITEMIDLIST   pidl;

   pidl = m_pPidlMgr->CreateItemPidl(pszName, psz);
   if(pidl)
      {
      LPITEMIDLIST   pidlFQ;

      hr = S_OK;

      pidlFQ = CreateFQPidl(pidl);
   
      SHChangeNotify(SHCNE_CREATE, SHCNF_IDLIST, pidlFQ, NULL);

      NotifyViews(SHCNE_CREATE, pidl, NULL);

      m_pPidlMgr->Delete(pidlFQ);

      if(ppidlOut)
         *ppidlOut = pidl;
      else
         m_pPidlMgr->Delete(pidl);
      }
   }

return hr;
}

/**************************************************************************

   CShellFolder::SetItemData()

**************************************************************************/

STDMETHODIMP CShellFolder::SetItemData(LPCITEMIDLIST pidl, LPCTSTR pszData)
{
BOOL  fResult;

if(m_pPidlMgr->IsFolder(pidl))
   {
   return E_INVALIDARG;
   }

if(!pszData)
   fResult = m_pPidlMgr->SetData(pidl, TEXT(""));
else
   fResult = m_pPidlMgr->SetData(pidl, pszData);

TCHAR szName[MAX_PATH];
TCHAR szFile[MAX_PATH];

//get the file name
GetPath(pidl, szFile, MAX_PATH);

//get the old item name
m_pPidlMgr->GetName(pidl, szName, MAX_PATH);

//change/add the name in the INI file
WritePrivateProfileString( c_szSection,
                           szName,
                           pszData,
                           szFile);

NotifyViews(SHCNE_UPDATEITEM, pidl, NULL);

return fResult ? S_OK : E_FAIL;
}

/**************************************************************************

   CShellFolder::GetFullName()
   
**************************************************************************/

VOID CShellFolder::GetFullName(LPCITEMIDLIST pidl, LPTSTR pszText, DWORD dwSize)
{
*pszText = 0;

//Get the name of our fully-qualified PIDL from the desktop folder.
IShellFolder   *psfDesktop = NULL;
SHGetDesktopFolder(&psfDesktop);
if(psfDesktop)
   {
   STRRET   str;
   if(SUCCEEDED(psfDesktop->GetDisplayNameOf(   m_pidlFQ, 
                                                SHGDN_NORMAL | 
                                                   SHGDN_FORPARSING | 
                                                   SHGDN_INCLUDE_NONFILESYS, 
                                                &str)))
      {
      GetTextFromSTRRET(m_pMalloc, &str, m_pidlFQ, pszText, dwSize);
      if(*pszText)
         {
         SmartAppendBackslash(pszText);
         }
      }
   
   psfDesktop->Release();
   }

//add the current item's text
m_pPidlMgr->GetRelativeName(  pidl, 
                              pszText + lstrlen(pszText), 
                              dwSize - lstrlen(pszText));
}

/**************************************************************************

   CShellFolder::GetUniqueName()

**************************************************************************/

#define NEW_FOLDER_NAME TEXT("New Folder")
#define NEW_ITEM_NAME TEXT("New Item")

STDMETHODIMP CShellFolder::GetUniqueName(BOOL fFolder, LPTSTR pszName, DWORD dwSize)
{
HRESULT  hr;
IEnumIDList *pEnum = NULL;
LPTSTR pszTemp;

if(fFolder)
   {
   pszTemp = NEW_FOLDER_NAME;
   }
else
   {
   pszTemp = NEW_ITEM_NAME;
   }

hr = EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &pEnum);

if(pEnum)
   {
   BOOL  fUnique = FALSE;

   lstrcpyn(pszName, pszTemp, dwSize);

   while(!fUnique)
      {
      //see if this name already exists in this folder
      LPITEMIDLIST   pidl;
      DWORD          dwFetched;
      int            i = 1;
next:
      pEnum->Reset();
      
      while((S_OK == pEnum->Next(1, &pidl, &dwFetched)) && dwFetched)
         {
         STRRET   str;
         TCHAR    szText[MAX_PATH];

         GetDisplayNameOf(pidl, SHGDN_NORMAL | SHGDN_INFOLDER, &str);
      
         GetTextFromSTRRET(m_pMalloc, &str, pidl, szText, MAX_PATH);

         if(0 == lstrcmpi(szText, pszName))
            {
            wsprintf(pszName, TEXT("%s %d"), pszTemp, i++);
            goto next;
            }
         }
      fUnique = TRUE;
      }

   pEnum->Release();
   }

return hr;
}

/**************************************************************************

   CShellFolder::CreateFQPidl()

**************************************************************************/

LPITEMIDLIST CShellFolder::CreateFQPidl(LPCITEMIDLIST pidl)
{
return m_pPidlMgr->Concatenate(m_pidlFQ, pidl);
}

/**************************************************************************

   CShellFolder::GetPath()

**************************************************************************/

VOID CShellFolder::GetPath(LPCITEMIDLIST pidl, LPTSTR pszPath, DWORD dwSize)
{
CShellFolder   **ppsf;
CShellFolder   *psfCurrent;
int            nCount;

*pszPath = 0;

//we need the number of parent items in the chain
for(nCount = 0, psfCurrent = this; psfCurrent; nCount++)
   {
   psfCurrent = psfCurrent->m_psfParent;
   }

ppsf = (CShellFolder**)m_pMalloc->Alloc(nCount * sizeof(CShellFolder*));
if(ppsf)
   {
   int   i;

   //fill in the interface pointer array
   for(i = 0, psfCurrent = this; i < nCount; i++)
      {
      *(ppsf + i) = psfCurrent;
      psfCurrent = psfCurrent->m_psfParent;
      }

   //Get the name of the root of our storage.
   lstrcpyn(pszPath, g_szStoragePath, dwSize);
   SmartAppendBackslash(pszPath);

   /*
   Starting at the top of the parent chain, walk down, getting the text for 
   each folder's PIDL.
   */
   for(i = nCount - 1; i >= 0; i--)
      {
      psfCurrent = *(ppsf + i);
      if(psfCurrent)
         {
         LPTSTR   pszCurrent = pszPath + lstrlen(pszPath);
         DWORD    dwCurrentSize = dwSize - lstrlen(pszPath);

         m_pPidlMgr->GetRelativeName(  psfCurrent->m_pidlRel, 
                                       pszCurrent, 
                                       dwCurrentSize);
         SmartAppendBackslash(pszPath);
         }
      }
   
   //add the item's path
   if(pidl)
      {
      if(m_pPidlMgr->IsFolder(pidl))
         {
         m_pPidlMgr->GetRelativeName(pidl, pszPath + lstrlen(pszPath), 
            dwSize - lstrlen(pszPath));
         }
      else
         {
         lstrcpyn(   pszPath + lstrlen(pszPath), 
                     c_szDataFile, 
                     dwSize - lstrlen(pszPath));
         }
      }

   m_pMalloc->Free(ppsf);
   }
}

/**************************************************************************

   CShellFolder::HasSubFolder()

**************************************************************************/

BOOL CShellFolder::HasSubFolder(LPCITEMIDLIST pidl)
{
TCHAR             szPath[MAX_PATH];
TCHAR             szTemp[MAX_PATH];
HANDLE            hFind;
WIN32_FIND_DATA   wfd;
BOOL              fReturn = FALSE;

if(!m_pPidlMgr->IsFolder(pidl))
   return FALSE;

GetPath(pidl, szPath, MAX_PATH);
lstrcpy(szTemp, szPath);
SmartAppendBackslash(szTemp);
lstrcat(szTemp, TEXT("*.*"));

hFind = FindFirstFile(szTemp, &wfd);

if(INVALID_HANDLE_VALUE != hFind)
   {
   do
      {
      if((FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes) && 
         ((wfd.dwFileAttributes & FILTER_ATTRIBUTES) == FILTER_ATTRIBUTES) &&
         lstrcmpi(wfd.cFileName, TEXT(".")) && 
         lstrcmpi(wfd.cFileName, TEXT("..")))
         {
         //We found one of our directories. Make sure it contains a data file.

         //build the path of the directory or file found
         lstrcpy(szTemp, szPath);
         SmartAppendBackslash(szTemp);
         lstrcat(szTemp, wfd.cFileName);
         SmartAppendBackslash(szTemp);
         lstrcat(szTemp, c_szDataFile);
         HANDLE   hDataFile = FindFirstFile(szTemp, &wfd);
         if(INVALID_HANDLE_VALUE != hDataFile)
            {
            fReturn = TRUE;
            FindClose(hDataFile);
            break;
            }
         }
      }
   while(FindNextFile(hFind, &wfd));
   
   FindClose(hFind);
   }

return fReturn;
}

/**************************************************************************

   CShellFolder::DeleteItems()

**************************************************************************/

STDMETHODIMP CShellFolder::DeleteItems(LPITEMIDLIST *aPidls, UINT uCount)
{
HRESULT  hr = E_FAIL;
UINT     i;

for(i = 0; i < uCount; i++)
   {
   if(m_pPidlMgr->IsFolder(aPidls[i]))
      {
      TCHAR szPath[MAX_PATH];

      GetPath(aPidls[i], szPath, MAX_PATH);

      DeleteDirectory(szPath);

      LPITEMIDLIST   pidlFQ = CreateFQPidl(aPidls[i]);

      SHChangeNotify(SHCNE_RMDIR, SHCNF_IDLIST, pidlFQ, NULL);

      NotifyViews(SHCNE_RMDIR, aPidls[i], NULL);

      m_pPidlMgr->Delete(pidlFQ);

      hr = S_OK;
      }
   else
      {
      TCHAR szFile[MAX_PATH];
      TCHAR szName[MAX_NAME];
   
      //get the file name
      GetPath(aPidls[i], szFile, MAX_PATH);

      //get the item name
      m_pPidlMgr->GetName(aPidls[i], szName, MAX_NAME);

      //remove the entry from the INI file
      WritePrivateProfileString( c_szSection,
                                 szName,
                                 NULL,
                                 szFile);

      LPITEMIDLIST   pidlFQ = CreateFQPidl(aPidls[i]);

      SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlFQ, NULL);

      NotifyViews(SHCNE_DELETE, aPidls[i], NULL);

      m_pPidlMgr->Delete(pidlFQ);

      hr = S_OK;
      }
   }

return hr;
}

/**************************************************************************

   CShellFolder::CopyItems()

**************************************************************************/

STDMETHODIMP CShellFolder::CopyItems(  CShellFolder *psfSource, 
                                       LPITEMIDLIST *aPidls, 
                                       UINT uCount)
{
HRESULT  hr = E_FAIL;
TCHAR    szFromFolder[MAX_PATH];
TCHAR    szToFolder[MAX_PATH];
UINT     i;

//get the storage path of the folder being copied from
psfSource->GetPath(NULL, szFromFolder, MAX_PATH);
SmartAppendBackslash(szFromFolder);

//get the storage path of the folder being copied to
this->GetPath(NULL, szToFolder, MAX_PATH);
SmartAppendBackslash(szToFolder);

for(i = 0; i < uCount; i++)
   {
   TCHAR    szFrom[MAX_PATH];
   TCHAR    szTo[MAX_PATH];

   lstrcpy(szFrom, szFromFolder);
   
   lstrcpy(szTo, szToFolder);
   
   if(m_pPidlMgr->IsFolder(aPidls[i]))
      {
      LPTSTR   pszTemp;
      pszTemp = szFrom + lstrlen(szFrom);
      m_pPidlMgr->GetRelativeName(aPidls[i], pszTemp, MAX_PATH - lstrlen(szFrom));

      SmartAppendBackslash(szTo);

      //need to double NULL terminate the names
      *(szFrom + lstrlen(szFrom) + 1) = 0;
      *(szTo + lstrlen(szTo) + 1) = 0;

      SHFILEOPSTRUCT sfi;
      sfi.hwnd = NULL;
      sfi.wFunc = FO_COPY;
      sfi.pFrom = szFrom;
      sfi.pTo = szTo;
      sfi.fFlags = FOF_NOCONFIRMMKDIR | FOF_SILENT;

      if(0 == SHFileOperation(&sfi))
         {
         LPITEMIDLIST   pidlFQ;

         pidlFQ = CreateFQPidl(aPidls[i]);
   
         SHChangeNotify(SHCNE_MKDIR, SHCNF_IDLIST, pidlFQ, NULL);

         NotifyViews(SHCNE_MKDIR, aPidls[i], NULL);

         m_pPidlMgr->Delete(pidlFQ);

         hr = S_OK;
         }
      }
   else
      {
      TCHAR szName[MAX_NAME];
      TCHAR szData[MAX_DATA];

      lstrcat(szFrom, c_szDataFile);
      lstrcat(szTo, c_szDataFile);

      m_pPidlMgr->GetRelativeName(aPidls[i], szName, MAX_NAME);

      if(GetPrivateProfileString(c_szSection, szName, TEXT(""), szData, MAX_DATA, szFrom))
         {
         //add the entry to the destination
         if(WritePrivateProfileString(c_szSection, szName, szData, szTo))
            {
            LPITEMIDLIST   pidlFQ;

            //remove the entry from the source
            WritePrivateProfileString(c_szSection, szName, NULL, szFrom);

            pidlFQ = CreateFQPidl(aPidls[i]);
   
            SHChangeNotify(SHCNE_CREATE, SHCNF_IDLIST, pidlFQ, NULL);

            NotifyViews(SHCNE_CREATE, aPidls[i], NULL);

            m_pPidlMgr->Delete(pidlFQ);

            hr = S_OK;
            }
         }
      }
   }

return hr;
}

/**************************************************************************

   CShellFolder::NotifyViews()

   This function is used to notify any existing views that something has 
   changed. This is necessary because there is no public way to register for 
   change notifications that get generated in response to SHChangeNotify. 
   Each CShellView adds itself to g_pViewList when it gets created and 
   removes itself from g_pViewList when it is destroyed.

**************************************************************************/

VOID CShellFolder::NotifyViews(  DWORD dwType, 
                                 LPCITEMIDLIST pidlOld, 
                                 LPCITEMIDLIST pidlNew)
{
IShellFolder   *psfDesktop;

SHGetDesktopFolder(&psfDesktop);

if(psfDesktop)
   {
   if(g_pViewList)
      {
      CShellView  *pView;

      pView = g_pViewList->GetNextView(NULL);
      while(pView)
         {
         LPITEMIDLIST   pidlView = pView->GetFQPidl();

         //is this view a view of this folder?
         HRESULT  hr;
         hr = psfDesktop->CompareIDs(0, m_pidlFQ, pidlView);
         if(SUCCEEDED(hr) && 0 == HRESULT_CODE(hr))
            {
            switch(dwType)
               {
               case SHCNE_MKDIR:
               case SHCNE_CREATE:
                  pView->AddItem(pidlOld);
                  break;
            
               case SHCNE_RMDIR:
               case SHCNE_DELETE:
                  pView->DeleteItem(pidlOld);
                  break;

               case SHCNE_RENAMEFOLDER:
               case SHCNE_RENAMEITEM:
                  pView->RenameItem(pidlOld, pidlNew);
                  break;

               case SHCNE_UPDATEITEM:
                  pView->UpdateData(pidlOld);
                  break;
               }
            }
         pView = g_pViewList->GetNextView(pView);
         }
      }
   psfDesktop->Release();
   }
}

/**************************************************************************

   CShellFolder::CompareItems()

**************************************************************************/

STDMETHODIMP CShellFolder::CompareItems(  LPCITEMIDLIST pidl1, 
                                          LPCITEMIDLIST pidl2)
{
TCHAR szString1[MAX_PATH] = TEXT("");
TCHAR szString2[MAX_PATH] = TEXT("");

/*
Special case - If one of the items is a folder and the other is an item, always 
make the folder come before the item.
*/
if(m_pPidlMgr->IsFolder(pidl1) != m_pPidlMgr->IsFolder(pidl2))
   {
   return MAKE_HRESULT( SEVERITY_SUCCESS, 
                        0, 
                        USHORT(m_pPidlMgr->IsFolder(pidl1) ? -1 : 1));
   }

m_pPidlMgr->GetRelativeName(pidl1, szString1, ARRAYSIZE(szString1));
m_pPidlMgr->GetRelativeName(pidl2, szString2, ARRAYSIZE(szString2));

return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(lstrcmpi(szString1, szString2)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\pidlmgr.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          PidlMgr.cpp
   
   Description:   Implements CPidlMgr.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "PidlMgr.h"
#include "ShlFldr.h"
#include "Guid.h"
#include "resource.h"

/**************************************************************************

   CPidlMgr::CPidlMgr

**************************************************************************/

CPidlMgr::CPidlMgr()
{
g_DllRefCount++;

//get the shell's IMalloc pointer
//we'll keep this until we get destroyed
if(FAILED(SHGetMalloc(&m_pMalloc)))
   {
   delete this;
   }
}

/**************************************************************************

   CPidlMgr::~CPidlMgr

**************************************************************************/

CPidlMgr::~CPidlMgr()
{
if(m_pMalloc)
   m_pMalloc->Release();

g_DllRefCount--;
}

/**************************************************************************

   CPidlMgr::Create()

   Creates a new PIDL
   
**************************************************************************/

LPITEMIDLIST CPidlMgr::Create(VOID)
{
LPITEMIDLIST   pidlOut;
USHORT         uSize;

pidlOut = NULL;

/*
Calculate the size. This consists of the ITEMIDLIST plus the size of our 
private PIDL structure. 
*/
uSize = sizeof(ITEMIDLIST) + sizeof(PIDLDATA);

/*
Allocate the memory, adding an additional ITEMIDLIST for the NULL terminating 
ID List.
*/
pidlOut = (LPITEMIDLIST)m_pMalloc->Alloc(uSize + sizeof(ITEMIDLIST));

if(pidlOut)
   {
   LPITEMIDLIST   pidlTemp = pidlOut;

   //set the size of this item
   pidlTemp->mkid.cb = uSize;

   //set the NULL terminator to 0
   pidlTemp = GetNextItem(pidlTemp);
   pidlTemp->mkid.cb = 0;
   pidlTemp->mkid.abID[0] = 0;
   }

return pidlOut;
}

/**************************************************************************

   CPidlMgr::Delete()

   Deletes a PIDL
   
**************************************************************************/

VOID CPidlMgr::Delete(LPITEMIDLIST pidl)
{
m_pMalloc->Free(pidl);
}

/**************************************************************************

   CPidlMgr::GetNextItem()
   
**************************************************************************/

LPITEMIDLIST CPidlMgr::GetNextItem(LPCITEMIDLIST pidl)
{
if(pidl)
   {
   return (LPITEMIDLIST)(LPBYTE)(((LPBYTE)pidl) + pidl->mkid.cb);
   }
else
   return NULL;
}

/**************************************************************************

   CPidlMgr::GetSize()
   
**************************************************************************/

UINT CPidlMgr::GetSize(LPCITEMIDLIST pidl)
{
UINT cbTotal = 0;
LPITEMIDLIST pidlTemp = (LPITEMIDLIST)pidl;

if(pidlTemp)
   {
   while(pidlTemp->mkid.cb)
      {
      cbTotal += pidlTemp->mkid.cb;
      pidlTemp = GetNextItem(pidlTemp);
      }  

   //add the size of the NULL terminating ITEMIDLIST
   cbTotal += sizeof(ITEMIDLIST);
   }

return cbTotal;
}

/**************************************************************************

   CPidlMgr::GetLastItem()

   Gets the last item in the list
   
**************************************************************************/

LPITEMIDLIST CPidlMgr::GetLastItem(LPCITEMIDLIST pidl)
{
LPITEMIDLIST   pidlLast = NULL;

//get the PIDL of the last item in the list
while(pidl && pidl->mkid.cb)
   {
   pidlLast = (LPITEMIDLIST)pidl;
   pidl = GetNextItem(pidl);
   }  

return pidlLast;
}

/**************************************************************************

   CPidlMgr::Copy()
   
**************************************************************************/

LPITEMIDLIST CPidlMgr::Copy(LPCITEMIDLIST pidlSource)
{
LPITEMIDLIST pidlTarget = NULL;
UINT cbSource = 0;

if(NULL == pidlSource)
   return NULL;

// Allocate the new pidl
cbSource = GetSize(pidlSource);
pidlTarget = (LPITEMIDLIST)m_pMalloc->Alloc(cbSource);
if(!pidlTarget)
   return NULL;

// Copy the source to the target
CopyMemory(pidlTarget, pidlSource, cbSource);

return pidlTarget;
}

/**************************************************************************

   CPidlMgr::CopySingleItem()

**************************************************************************/

LPITEMIDLIST CPidlMgr::CopySingleItem(LPCITEMIDLIST pidlSource)
{
LPITEMIDLIST pidlTarget = NULL;
UINT cbSource = 0;

if(NULL == pidlSource)
   return NULL;

// Allocate the new pidl
cbSource = pidlSource->mkid.cb;
pidlTarget = (LPITEMIDLIST)m_pMalloc->Alloc(cbSource + sizeof(ITEMIDLIST));
if(!pidlTarget)
   return NULL;

// Copy the source to the target
ZeroMemory(pidlTarget, cbSource + sizeof(ITEMIDLIST));
CopyMemory(pidlTarget, pidlSource, cbSource);

return pidlTarget;
}

/**************************************************************************

   CPidlMgr::GetDataPointer()
   
**************************************************************************/

inline LPPIDLDATA CPidlMgr::GetDataPointer(LPCITEMIDLIST pidl)
{
if(!pidl)
   return NULL;

return (LPPIDLDATA)(pidl->mkid.abID);
}

/**************************************************************************

   CPidlMgr::Concatenate()

   Create a new PIDL by combining two existing PIDLs.
   
**************************************************************************/

LPITEMIDLIST CPidlMgr::Concatenate(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
LPITEMIDLIST   pidlNew;
UINT           cb1 = 0, 
               cb2 = 0;

//are both of these NULL?
if(!pidl1 && !pidl2)
   return NULL;

//if pidl1 is NULL, just return a copy of pidl2
if(!pidl1)
   {
   pidlNew = Copy(pidl2);

   return pidlNew;
   }

//if pidl2 is NULL, just return a copy of pidl1
if(!pidl2)
   {
   pidlNew = Copy(pidl1);

   return pidlNew;
   }

cb1 = GetSize(pidl1) - sizeof(ITEMIDLIST);

cb2 = GetSize(pidl2);

//create the new PIDL
pidlNew = (LPITEMIDLIST)m_pMalloc->Alloc(cb1 + cb2);

if(pidlNew)
   {
   //copy the first PIDL
   CopyMemory(pidlNew, pidl1, cb1);
   
   //copy the second PIDL
   CopyMemory(((LPBYTE)pidlNew) + cb1, pidl2, cb2);
   }

return pidlNew;
}

/**************************************************************************

   CPidlMgr::CreateFolderPidl()

   Create a new folder PIDL.
   
**************************************************************************/

LPITEMIDLIST CPidlMgr::CreateFolderPidl(LPCTSTR pszName)
{
LPITEMIDLIST   pidl = Create();
LPPIDLDATA     pData = GetDataPointer(pidl);

if(pData)
   {
   pData->fFolder = TRUE;

   lstrcpyn(pData->szName, pszName, MAX_NAME);

   pData->szData[0] = 0;
   }

return pidl;
}

/**************************************************************************

   CPidlMgr::CreateItemPidl()

   Create a new item PIDL.
   
**************************************************************************/

LPITEMIDLIST CPidlMgr::CreateItemPidl( LPCTSTR pszName, 
                                       LPCTSTR pszData)
{
LPITEMIDLIST   pidl = Create();
LPPIDLDATA     pData = GetDataPointer(pidl);

if(pData)
   {
   pData->fFolder = FALSE;
   
   lstrcpyn(pData->szName, pszName, MAX_NAME);
   lstrcpyn(pData->szData, pszData, MAX_DATA);
   }

return pidl;
}

/**************************************************************************

   CPidlMgr::SetDataPidl()

   Set a data in the PIDL.
   
**************************************************************************/

LPITEMIDLIST CPidlMgr::SetDataPidl(LPITEMIDLIST pidl, LPPIDLDATA  pSourceData, PIDLDATATYPE pidldatatype)
{
    if (!pidl)
        pidl = Create();

    LPPIDLDATA     pData = GetDataPointer(pidl);

    if(pData)
    {
        if (pidldatatype & FOLDER)
            pData->fFolder = pSourceData->fFolder;
        if (pidldatatype &  NAME)
            lstrcpyn(pData->szName, pSourceData->szName, MAX_NAME);
        if (pidldatatype & DATA)
            lstrcpyn(pData->szData, pSourceData->szData, MAX_DATA);
        if (pidldatatype &  ICON)
            pData->iIcon = pSourceData->iIcon;
        if (pidldatatype &  URL)
            lstrcpyn(pData->szUrl, pSourceData->szUrl, MAX_DATA);
    }

    return pidl;
}

/**************************************************************************

   CPidlMgr::GetName()

   Gets the name for this item
   
**************************************************************************/

int CPidlMgr::GetName(LPCITEMIDLIST pidl, LPTSTR pszText, DWORD dwSize)
{
if(!IsBadWritePtr(pszText, dwSize))
   {
   *pszText = 0;

   LPPIDLDATA  pData = GetDataPointer(pidl);

   if(pData)
      {
      lstrcpyn(pszText, pData->szName, dwSize);
      return lstrlen(pszText);
      }
   }

return 0;
}

/**************************************************************************

   CPidlMgr::GetRelativeName()

   Gets the full name for this item
   
**************************************************************************/

int CPidlMgr::GetRelativeName(LPCITEMIDLIST pidl, LPTSTR pszText, DWORD dwSize)
{
if(!IsBadWritePtr(pszText, dwSize))
   {
   LPITEMIDLIST   pidlTemp;
   *pszText = 0;

   //walk the list, getting the name for each item
   pidlTemp = (LPITEMIDLIST)pidl;
   while(pidlTemp && pidlTemp->mkid.cb)
      {
      LPTSTR   pszCurrent = pszText + lstrlen(pszText);
      dwSize -= GetName(pidlTemp, pszCurrent, dwSize);
      pidlTemp = GetNextItem(pidlTemp);

      //don't add a backslash to the last item
      if(pidlTemp && pidlTemp->mkid.cb)
         {
         SmartAppendBackslash(pszCurrent);
         }
      }
   return lstrlen(pszText);
   }

return 0;
}

/**************************************************************************

   CPidlMgr::GetData()

   Gets the data for this item
   
**************************************************************************/

int CPidlMgr::GetData(LPCITEMIDLIST pidl, LPTSTR pszText, DWORD dwSize)
{
if(!IsBadWritePtr(pszText, dwSize))
   {
   *pszText = 0;

   LPPIDLDATA  pData = GetDataPointer(pidl);

   if(pData)
      {
      lstrcpyn(pszText, pData->szData, dwSize);
      return lstrlen(pszText);
      }
   }

return 0;
}

/**************************************************************************

   CPidlMgr::IsFolder()

   Determines if the item is a folder
   
**************************************************************************/

BOOL CPidlMgr::IsFolder(LPCITEMIDLIST pidl)
{
LPPIDLDATA  pData = GetDataPointer(pidl);

if(pData)
   {
   return pData->fFolder;
   }

return FALSE;
}

/**************************************************************************

   CPidlMgr::SetData()

**************************************************************************/

int CPidlMgr::SetData(LPCITEMIDLIST pidl, LPCTSTR pszData)
{
LPPIDLDATA  pData = GetDataPointer(pidl);

if(pData)
   {
   lstrcpyn(pData->szData, pszData, MAX_DATA);

   return lstrlen(pData->szData);
   }

return 0;
}

/**************************************************************************

   CPidlMgr::GetIcon()

   Determines if the item is a folder
   
**************************************************************************/

int CPidlMgr::GetIcon(LPCITEMIDLIST pidl)
{
    LPPIDLDATA  pData = GetDataPointer(pidl);

    if(pData)
    {
        return pData->iIcon;
    }

    return FALSE;
}

/**************************************************************************

   CPidlMgr::GetUrl()

   Gets the data for this item
   
**************************************************************************/

int CPidlMgr::GetUrl(LPCITEMIDLIST pidl, LPTSTR pszText, DWORD dwSize)
{
if(!IsBadWritePtr(pszText, dwSize))
   {
   *pszText = 0;

   LPPIDLDATA  pData = GetDataPointer(pidl);

   if(pData)
      {
      lstrcpyn(pszText, pData->szUrl, dwSize);
      return lstrlen(pszText);
      }
   }

return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\shlfldr.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ShlFldr.h
   
   Description:   CShellFolder definitions.

**************************************************************************/

#ifndef SHELLFOLDER_H
#define SHELLFOLDER_H

/**************************************************************************
   #include statements
**************************************************************************/

#include <windows.h>
#include <shlobj.h>

#include "EnumIDL.h"
#include "PidlMgr.h"

/**************************************************************************

   CShellFolder class definition

**************************************************************************/

class CShellFolder : public IShellFolder, 
                     public IPersistFolder
{
friend class CShellView;
friend class CContextMenu;
friend class CDropTarget;
friend class CDataObject;

private:
   DWORD          m_ObjRefCount;
    LPITEMIDLIST   m_pidlRel;
    LPITEMIDLIST   m_pidlFQ;
    CShellFolder   *m_psfParent;
    LPMALLOC       m_pMalloc;
   CPidlMgr       *m_pPidlMgr;
    IXMLDocument *m_pXMLDoc;
   
public:
   CShellFolder(CShellFolder *pParent = NULL, LPCITEMIDLIST pidl = NULL);
   ~CShellFolder();

   //IUnknown methods
   STDMETHOD (QueryInterface) (REFIID riid, LPVOID * ppvObj);
   STDMETHOD_ (ULONG, AddRef) (VOID);
   STDMETHOD_ (ULONG, Release) (VOID);

   //IShellFolder methods
   STDMETHOD (ParseDisplayName) (HWND, LPBC, LPOLESTR, LPDWORD, LPITEMIDLIST*, LPDWORD);
   STDMETHOD (EnumObjects) (HWND, DWORD, LPENUMIDLIST*);
   STDMETHOD (BindToObject) (LPCITEMIDLIST, LPBC, REFIID, LPVOID*);
   STDMETHOD (BindToStorage) (LPCITEMIDLIST, LPBC, REFIID, LPVOID*);
   STDMETHOD (CompareIDs) (LPARAM, LPCITEMIDLIST, LPCITEMIDLIST);
   STDMETHOD (CreateViewObject) (HWND, REFIID, LPVOID* );
   STDMETHOD (GetAttributesOf) (UINT, LPCITEMIDLIST*, LPDWORD);
   STDMETHOD (GetUIObjectOf) (HWND, UINT, LPCITEMIDLIST*, REFIID, LPUINT, LPVOID*);
   STDMETHOD (GetDisplayNameOf) (LPCITEMIDLIST, DWORD, LPSTRRET);
   STDMETHOD (SetNameOf) (HWND, LPCITEMIDLIST, LPCOLESTR, DWORD, LPITEMIDLIST*);

   //IPersist methods
   STDMETHODIMP GetClassID(LPCLSID);

   //IPersistFolder methods
   STDMETHODIMP Initialize(LPCITEMIDLIST);

private:
   STDMETHOD (AddFolder)(LPCTSTR, LPITEMIDLIST*);
   STDMETHOD (AddItem)(LPCTSTR, LPCTSTR, LPITEMIDLIST*);
   STDMETHOD (SetItemData)(LPCITEMIDLIST, LPCTSTR);
   STDMETHOD (GetUniqueName)(BOOL, LPTSTR, DWORD);
   LPITEMIDLIST CreateFQPidl(LPCITEMIDLIST);
   STDMETHOD (DeleteItems)(LPITEMIDLIST*, UINT);
   STDMETHOD (CopyItems)(CShellFolder*, LPITEMIDLIST*, UINT);
   VOID GetFullName(LPCITEMIDLIST, LPTSTR, DWORD);
   VOID GetPath(LPCITEMIDLIST, LPTSTR, DWORD);
   BOOL HasSubFolder(LPCITEMIDLIST);
   VOID NotifyViews(DWORD, LPCITEMIDLIST, LPCITEMIDLIST);
   STDMETHOD (CompareItems) (LPCITEMIDLIST, LPCITEMIDLIST);
};

#endif   //SHELLFOLDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XMLView.rc
//
#define IDS_COLUMN1                     1
#define IDS_COLUMN2                     2
#define IDS_TB_COMMAND                  3
#define IDS_MI_COMMAND                  4
#define IDS_EXT_TITLE                   5
#define IDS_MI_FILEITEM                 6
#define IDS_FOLDER                      7
#define IDS_VIEW                        8
#define IDS_VIEW_LARGE                  9
#define IDS_VIEW_SMALL                  10
#define IDS_VIEW_LIST                   11
#define IDS_VIEW_DETAILS                12
#define IDS_NEW                         13
#define IDS_NEW_FOLDER                  14
#define IDS_NEW_ITEM                    15
#define IDS_PASTE                       16
#define IDS_EXPLORE                     17
#define IDS_OPEN                        18
#define IDS_RENAME                      19
#define IDS_CUT                         20
#define IDS_COPY                        21
#define IDS_DELETE                      22
#define IDS_MODIFY_DATA                 23
#define IDS_ITEM                        24
#define IDS_FOLDER_DATA                 25
#define IDS_STRING26                    26
#define IDS_STRING27                    27
#define IDI_MAINICON                    100
#define IDR_ACCELS                      101
#define IDD_ITEMDATADLG                 102
#define IDC_DATA                        1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         2001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\shlview.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ShlView.cpp
   
   Description:   Implements IShellView.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "ShlView.h"
#include "Guid.h"
#include "Commands.h"
#include "resource.h"
#include "Tools.h"
#include "ViewList.h"
#include "DropSrc.h"

/**************************************************************************
   global variables
**************************************************************************/

MYTOOLINFO g_Tools[] = 
   {
   IDB_VIEW_SMALL_COLOR, IDM_NEW_FOLDER, VIEW_NEWFOLDER, IDS_NEW_FOLDER, TBSTATE_ENABLED, TBSTYLE_BUTTON,
   IDB_STD_SMALL_COLOR, IDM_NEW_ITEM, STD_FILENEW, IDS_NEW_ITEM, TBSTATE_ENABLED, TBSTYLE_BUTTON,
   0, IDM_SEPARATOR, 0, 0, 0, TBSTYLE_SEP,
   IDB_VIEW_SMALL_COLOR, IDM_VIEW_LARGE, VIEW_LARGEICONS, IDS_VIEW_LARGE, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,
   IDB_VIEW_SMALL_COLOR, IDM_VIEW_SMALL, VIEW_SMALLICONS, IDS_VIEW_SMALL, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,
   IDB_VIEW_SMALL_COLOR, IDM_VIEW_LIST, VIEW_LIST, IDS_VIEW_LIST, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,
   IDB_VIEW_SMALL_COLOR, IDM_VIEW_DETAILS, VIEW_DETAILS, IDS_VIEW_DETAILS, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP,
   0, -1, 0, 0, 0, 0,
   };

extern CViewList  *g_pViewList;

/**************************************************************************

   CShellView::CShellView()

**************************************************************************/

CShellView::CShellView(CShellFolder *pFolder, LPCITEMIDLIST pidl)
{
g_DllRefCount++;

#ifdef INITCOMMONCONTROLSEX

INITCOMMONCONTROLSEX iccex;
iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
iccex.dwICC = ICC_LISTVIEW_CLASSES;
InitCommonControlsEx(&iccex);

#else

InitCommonControls();

#endif   //INITCOMMONCONTROLSEX

m_hMenu = NULL;
m_fInEdit = FALSE;
m_hAccels = LoadAccelerators(g_hInst, MAKEINTRESOURCE(IDR_ACCELS));

m_pPidlMgr = new CPidlMgr();
if(!m_pPidlMgr)
   {
   delete this;
   return;
   }

m_psfParent = pFolder;
if(m_psfParent)
   m_psfParent->AddRef();

//get the shell's IMalloc pointer
//we'll keep this until we get destroyed
if(FAILED(SHGetMalloc(&m_pMalloc)))
   {
   delete this;
   return;
   }

m_pidl = m_pPidlMgr->Copy(pidl);

m_uState = SVUIA_DEACTIVATE;

if(g_pViewList)
   g_pViewList->AddToList(this);

m_ObjRefCount = 1;
}

/**************************************************************************

   CShellView::~CShellView()

**************************************************************************/

CShellView::~CShellView()
{
if(g_pViewList)
   g_pViewList->RemoveFromList(this);

if(m_pidl)
   {
   m_pPidlMgr->Delete(m_pidl);
   m_pidl = NULL;
   }

if(m_psfParent)
   m_psfParent->Release();

if(m_pMalloc)
   {
   m_pMalloc->Release();
   }

if(m_pPidlMgr)
   {
   delete m_pPidlMgr;
   }

g_DllRefCount--;
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CShellView::QueryInterface

**************************************************************************/

STDMETHODIMP CShellView::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
*ppReturn = NULL;

//IUnknown
if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = this;
   }

//IOleWindow
else if(IsEqualIID(riid, IID_IOleWindow))
   {
   *ppReturn = (IOleWindow*)this;
   }

//IShellView
else if(IsEqualIID(riid, IID_IShellView))
   {
   *ppReturn = (IShellView*)this;
   }   

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

/**************************************************************************

   CShellView::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CShellView::AddRef()
{
return ++m_ObjRefCount;
}


/**************************************************************************

   CShellView::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CShellView::Release()
{
if(--m_ObjRefCount == 0)
   {
   delete this;
   return 0;
   }
   
return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleWindow Implementation
//

/**************************************************************************

   CShellView::GetWindow()
   
**************************************************************************/

STDMETHODIMP CShellView::GetWindow(HWND *phWnd)
{
*phWnd = m_hWnd;

return S_OK;
}

/**************************************************************************

   CShellView::ContextSensitiveHelp()
   
**************************************************************************/

STDMETHODIMP CShellView::ContextSensitiveHelp(BOOL fEnterMode)
{
return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IShellView Implementation
//

/**************************************************************************

   CShellView::TranslateAccelerator()
   
**************************************************************************/

STDMETHODIMP CShellView::TranslateAccelerator(LPMSG pmsg)
{
if(m_fInEdit)
   {
   if((pmsg->message >= WM_KEYFIRST) && (pmsg->message <= WM_KEYLAST))
      {
      TranslateMessage(pmsg);
      DispatchMessage(pmsg);
      return S_OK;
      }
   }
else if(::TranslateAccelerator(m_hWnd, m_hAccels, pmsg))
   return S_OK;

return S_FALSE;
}

/**************************************************************************

   CShellView::EnableModeless()
   
**************************************************************************/

STDMETHODIMP CShellView::EnableModeless(BOOL fEnable)
{
return E_NOTIMPL;
}

/**************************************************************************

   CShellView::OnActivate()
   
**************************************************************************/

LRESULT CShellView::OnActivate(UINT uState)
{
//don't do anything if the state isn't really changing
if(m_uState == uState)
   return S_OK;

OnDeactivate();

//only do this if we are active
if(uState != SVUIA_DEACTIVATE)
   {
   //merge the menus
   m_hMenu = CreateMenu();
   
   if(m_hMenu)
      {
       OLEMENUGROUPWIDTHS   omw = {0, 0, 0, 0, 0, 0};
      MENUITEMINFO         mii;

      m_pShellBrowser->InsertMenusSB(m_hMenu, &omw);

      //add your top level sub-menu here, if desired

      //get the view menu so we can merge with it
      ZeroMemory(&mii, sizeof(mii));
      mii.cbSize = sizeof(mii);
      mii.fMask = MIIM_SUBMENU;
      
      //merge our items into the File menu
      if(GetMenuItemInfo(m_hMenu, FCIDM_MENU_FILE, FALSE, &mii))
         {
         MergeFileMenu(mii.hSubMenu, (BOOL)(SVUIA_ACTIVATE_FOCUS == uState));
         }

      //merge our items into the Edit menu
      if(GetMenuItemInfo(m_hMenu, FCIDM_MENU_EDIT, FALSE, &mii))
         {
         MergeEditMenu(mii.hSubMenu, (BOOL)(SVUIA_ACTIVATE_FOCUS == uState));
         }

      //merge our items into the View menu
      if(GetMenuItemInfo(m_hMenu, FCIDM_MENU_VIEW, FALSE, &mii))
         {
         MergeViewMenu(mii.hSubMenu);
         }

      //add the items that should only be added if we have the focus
      if(SVUIA_ACTIVATE_FOCUS == uState)
         {
         }

      m_pShellBrowser->SetMenuSB(m_hMenu, NULL, m_hWnd);
      }
   }

m_uState = uState;

UpdateToolbar();

return 0;
}

/**************************************************************************

   CShellView::OnDeactivate()
   
**************************************************************************/

VOID CShellView::OnDeactivate(VOID)
{
if(m_uState != SVUIA_DEACTIVATE)
   {
   if(m_hMenu)
      {
      m_pShellBrowser->SetMenuSB(NULL, NULL, NULL);

      m_pShellBrowser->RemoveMenusSB(m_hMenu);

      DestroyMenu(m_hMenu);

      m_hMenu = NULL;
      }

   m_uState = SVUIA_DEACTIVATE;
   }
}

/**************************************************************************

   CShellView::UIActivate()

   This function activates the view window. Note that activating it 
   will not change the focus, while setting the focus will activate it.

   
**************************************************************************/

STDMETHODIMP CShellView::UIActivate(UINT uState)
{
//don't do anything if the state isn't really changing
if(m_uState == uState)
   return S_OK;

//OnActivate handles the menu merging and internal state
OnActivate(uState);

//only do this if we are active
if(uState != SVUIA_DEACTIVATE)
   {
   TCHAR szName[MAX_PATH] = TEXT("");
   LRESULT  lResult;
   int      nPartArray[1] = {-1};
   
   //update the status bar
   //set the number of parts
   m_pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETPARTS, 1, (LPARAM)nPartArray, &lResult);

   //set the text for the parts
   m_pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETTEXT, 0, (LPARAM)g_szExtTitle, &lResult);
   }

return S_OK;
}

/**************************************************************************

   CShellView::MergeFileMenu()
   
**************************************************************************/

VOID CShellView::MergeFileMenu(HMENU hMenu, BOOL fFocus)
{
MENUITEMINFO   mii;
UINT           uPos = 0;

ZeroMemory(&mii, sizeof(mii));

//uPos += AddFileMenuItems(hMenu, 0, IDM_SEPARATOR, FALSE);
uPos += AddFileMenuItems(hMenu, 0, 0, TRUE);

//add a separator
mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
mii.fType = MFT_SEPARATOR;
mii.wID = IDM_SEPARATOR;
mii.fState = MFS_ENABLED;

//insert this item at the beginning of the menu
InsertMenuItem(hMenu, uPos, TRUE, &mii);
uPos++;

if(fFocus)
   {
   TCHAR szText[MAX_PATH];

   //add the Delete item
   LoadString(g_hInst, IDS_DELETE, szText, sizeof(szText));
   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
   mii.fType = MFT_STRING;
   mii.fState = MFS_ENABLED;
   mii.dwTypeData = szText;
   mii.wID = IDM_DELETE;
   InsertMenuItem(hMenu, uPos, TRUE, &mii);
   uPos++;

   //add the Rename item
   LoadString(g_hInst, IDS_RENAME, szText, sizeof(szText));
   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
   mii.fType = MFT_STRING;
   mii.fState = MFS_ENABLED;
   mii.dwTypeData = szText;
   mii.wID = IDM_RENAME;
   InsertMenuItem(hMenu, uPos, TRUE, &mii);
   uPos++;

   //add a separator
   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
   mii.fType = MFT_SEPARATOR;
   mii.wID = IDM_SEPARATOR;
   mii.fState = MFS_ENABLED;
   InsertMenuItem(hMenu, uPos, TRUE, &mii);
   uPos++;
   }
}

/**************************************************************************

   CShellView::MergeViewMenu()
   
**************************************************************************/

VOID CShellView::MergeViewMenu(HMENU hMenu)
{
MENUITEMINFO   mii;

ZeroMemory(&mii, sizeof(mii));
mii.cbSize = sizeof(mii);

//add a separator at the correct position in the menu
mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
mii.fType = MFT_SEPARATOR;
mii.wID = IDM_SEPARATOR;
mii.fState = MFS_ENABLED;
InsertMenuItem(hMenu, FCIDM_MENU_VIEW_SEP_OPTIONS, FALSE, &mii);

AddViewMenuItems(hMenu, 0, FCIDM_MENU_VIEW_SEP_OPTIONS, FALSE);
}

/**************************************************************************

   CShellView::MergeEditMenu()

**************************************************************************/

VOID CShellView::MergeEditMenu(HMENU hMenu, BOOL fFocus)
{
if(hMenu)
   {
   MENUITEMINFO   mii;
   TCHAR          szText[MAX_PATH];

   ZeroMemory(&mii, sizeof(mii));
   mii.cbSize = sizeof(mii);

   if(fFocus)
      {
      LoadString(g_hInst, IDS_CUT, szText, sizeof(szText));
      mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
      mii.fType = MFT_STRING;
      mii.fState = MFS_ENABLED;
      mii.dwTypeData = szText;
      mii.wID = IDM_CUT;
      InsertMenuItem(hMenu, -1, TRUE, &mii);

      LoadString(g_hInst, IDS_COPY, szText, sizeof(szText));
      mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
      mii.fType = MFT_STRING;
      mii.fState = MFS_ENABLED;
      mii.dwTypeData = szText;
      mii.wID = IDM_COPY;
      InsertMenuItem(hMenu, -1, TRUE, &mii);
      }

   //add the paste menu items at the correct position in the menu
   LoadString(g_hInst, IDS_PASTE, szText, sizeof(szText));
   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
   mii.fType = MFT_STRING;
   mii.fState = MFS_ENABLED;
   mii.dwTypeData = szText;
   mii.wID = IDM_PASTE;
   InsertMenuItem(hMenu, -1, TRUE, &mii);
   }
}

/**************************************************************************

   CShellView::MergeToolbar()
   
**************************************************************************/

VOID CShellView::MergeToolbar(VOID)
{
int         i;
TBADDBITMAP tbab;
LRESULT     lStdOffset;
LRESULT     lViewOffset;

m_pShellBrowser->SetToolbarItems(NULL, 0, FCT_MERGE);
   
tbab.hInst = HINST_COMMCTRL;
tbab.nID = (int)IDB_STD_SMALL_COLOR;
m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 0, (LPARAM)&tbab, &lStdOffset);

tbab.hInst = HINST_COMMCTRL;
tbab.nID = (int)IDB_VIEW_SMALL_COLOR;
m_pShellBrowser->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 0, (LPARAM)&tbab, &lViewOffset);

//get the number of items in tool array
for(i = 0; -1 != g_Tools[i].idCommand; i++)
   {
   }

LPTBBUTTON  ptbb = (LPTBBUTTON)GlobalAlloc(GPTR, sizeof(TBBUTTON) * i);

if(ptbb)
   {
   for(i = 0; -1 != g_Tools[i].idCommand; i++)
      {
      (ptbb + i)->iBitmap = 0;
      switch(g_Tools[i].uImageSet)
         {
         case IDB_STD_SMALL_COLOR:
            (ptbb + i)->iBitmap = lStdOffset + g_Tools[i].iImage;
            break;

         case IDB_VIEW_SMALL_COLOR:
            (ptbb + i)->iBitmap = lViewOffset + g_Tools[i].iImage;
            break;
         }

      (ptbb + i)->idCommand = g_Tools[i].idCommand;
      (ptbb + i)->fsState = g_Tools[i].bState;
      (ptbb + i)->fsStyle = g_Tools[i].bStyle;
      (ptbb + i)->dwData = 0;
      (ptbb + i)->iString = 0;
      }
   
   m_pShellBrowser->SetToolbarItems(ptbb, i, FCT_MERGE);
   
   GlobalFree((HGLOBAL)ptbb);
   }

UpdateToolbar();
}

/**************************************************************************

   CShellView::Refresh()
   
**************************************************************************/

STDMETHODIMP CShellView::Refresh(VOID)
{
//empty the list
ListView_DeleteAllItems(m_hwndList);

//refill the list
FillList();

return S_OK;
}

/**************************************************************************

   CShellView::CreateViewWindow()
   
**************************************************************************/

STDMETHODIMP CShellView::CreateViewWindow(   LPSHELLVIEW pPrevView, 
                                             LPCFOLDERSETTINGS lpfs, 
                                             LPSHELLBROWSER psb, 
                                             LPRECT prcView, 
                                             HWND *phWnd)
{
WNDCLASS wc;

*phWnd = NULL;

//if our window class has not been registered, then do so
if(!GetClassInfo(g_hInst, NS_CLASS_NAME, &wc))
   {
   ZeroMemory(&wc, sizeof(wc));
   wc.style          = CS_HREDRAW | CS_VREDRAW;
   wc.lpfnWndProc    = WndProc;
   wc.cbClsExtra     = 0;
   wc.cbWndExtra     = 0;
   wc.hInstance      = g_hInst;
   wc.hIcon          = NULL;
   wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
   wc.lpszMenuName   = NULL;
   wc.lpszClassName  = NS_CLASS_NAME;
   
   if(!RegisterClass(&wc))
      return E_FAIL;
   }

//set up the member variables
m_pShellBrowser = psb;
m_FolderSettings = *lpfs;

//get our parent window
m_pShellBrowser->GetWindow(&m_hwndParent);

*phWnd = CreateWindowEx(   0,
                           NS_CLASS_NAME,
                           NULL,
                           WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                           prcView->left,
                           prcView->top,
                           prcView->right - prcView->left,
                           prcView->bottom - prcView->top,
                           m_hwndParent,
                           NULL,
                           g_hInst,
                           (LPVOID)this);
                           
if(!*phWnd)
   return E_FAIL;

MergeToolbar();

m_pShellBrowser->AddRef();

return S_OK;
}

/**************************************************************************

   CShellView::DestroyViewWindow()
   
**************************************************************************/

STDMETHODIMP CShellView::DestroyViewWindow(VOID)
{
//Make absolutely sure all our UI is cleaned up.
UIActivate(SVUIA_DEACTIVATE);

if(m_hMenu)
   DestroyMenu(m_hMenu);

DestroyWindow(m_hWnd);

//release the shell browser object
m_pShellBrowser->Release();

return S_OK;
}

/**************************************************************************

   CShellView::GetCurrentInfo()
   
**************************************************************************/

STDMETHODIMP CShellView::GetCurrentInfo(LPFOLDERSETTINGS lpfs)
{
*lpfs = m_FolderSettings;

return S_OK;
}

/**************************************************************************

   CShellView::AddPropertySheetPages()
   
**************************************************************************/

STDMETHODIMP CShellView::AddPropertySheetPages( DWORD dwReserved, 
                                                LPFNADDPROPSHEETPAGE lpfn, 
                                                LPARAM lParam)
{
return E_NOTIMPL;
}

/**************************************************************************

   CShellView::SaveViewState()
   
**************************************************************************/

STDMETHODIMP CShellView::SaveViewState(VOID)
{
return S_OK;
}

/**************************************************************************

   CShellView::SelectItem()
   
**************************************************************************/

STDMETHODIMP CShellView::SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags)
{
return E_NOTIMPL;
}

/**************************************************************************

   CShellView::GetItemObject()
   
**************************************************************************/

STDMETHODIMP CShellView::GetItemObject(UINT uItem, REFIID riid, LPVOID *ppvOut)
{
*ppvOut = NULL;

return E_NOTIMPL;
}


/**************************************************************************

   CShellView::WndProc()
   
**************************************************************************/

LRESULT CALLBACK CShellView::WndProc(  HWND hWnd, 
                                       UINT uMessage, 
                                       WPARAM wParam, 
                                       LPARAM lParam)
{
CShellView  *pThis = (CShellView*)GetWindowLong(hWnd, VIEW_POINTER_OFFSET);

switch (uMessage)
   {
   case WM_NCCREATE:
      {
      LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
      pThis = (CShellView*)(lpcs->lpCreateParams);
      SetWindowLong(hWnd, VIEW_POINTER_OFFSET, (LONG)pThis);

      //set the window handle
      pThis->m_hWnd = hWnd;
      }
      break;
   
   case WM_SIZE:
      return pThis->OnSize(LOWORD(lParam), HIWORD(lParam));
   
   case WM_CREATE:
      return pThis->OnCreate();
   
   case WM_DESTROY:
      return pThis->OnDestroy();
   
   case WM_SETFOCUS:
      return pThis->OnSetFocus();
   
   case WM_KILLFOCUS:
      return pThis->OnKillFocus();

   case WM_ACTIVATE:
      return pThis->OnActivate(SVUIA_ACTIVATE_FOCUS);
   
   case WM_COMMAND:
      return pThis->OnCommand(   GET_WM_COMMAND_ID(wParam, lParam), 
                                 GET_WM_COMMAND_CMD(wParam, lParam), 
                                 GET_WM_COMMAND_HWND(wParam, lParam));
   
   case WM_INITMENUPOPUP:
      return pThis->UpdateMenu((HMENU)wParam);
   
   case WM_NOTIFY:
      return pThis->OnNotify((UINT)wParam, (LPNMHDR)lParam);
   
   case WM_SETTINGCHANGE:
      return pThis->OnSettingChange((LPCTSTR)lParam);

   case WM_CONTEXTMENU:
      {
      pThis->DoContextMenu(LOWORD(lParam), HIWORD(lParam), FALSE, (UINT)-1);
      return 0;
      }
   }

return DefWindowProc(hWnd, uMessage, wParam, lParam);
}

/**************************************************************************

   CShellView::OnSetFocus()
   
**************************************************************************/

LRESULT CShellView::OnSetFocus(VOID)
{
/*
Tell the browser one of our windows has received the focus. This should always 
be done before merging menus (OnActivate merges the menus) if one of our 
windows has the focus.
*/
m_pShellBrowser->OnViewWindowActive(this);

OnActivate(SVUIA_ACTIVATE_FOCUS);

return 0;
}

/**************************************************************************

   CShellView::OnKillFocus()
   
**************************************************************************/

LRESULT CShellView::OnKillFocus(VOID)
{
OnActivate(SVUIA_ACTIVATE_NOFOCUS);

return 0;
}

/**************************************************************************

   CShellView::OnCommand()
   
**************************************************************************/

LRESULT CShellView::OnCommand(DWORD dwCmdID, DWORD dwCmd, HWND hwndCmd)
{
//ignore command messages while in edit mode
if(m_fInEdit)
   return 0;

DoContextMenu(0, 0, FALSE, dwCmdID);

return 0;
}

/**************************************************************************

   CShellView::UpdateMenu()
   
**************************************************************************/

LRESULT CShellView::UpdateMenu(HMENU hMenu)
{
UINT  uCommand;

//enable/disable your menu items here
OpenClipboard(NULL);
HGLOBAL  hClip = GetClipboardData(RegisterClipboardFormat(CFSTR_SAMPVIEWDATA));
CloseClipboard();

EnableMenuItem(hMenu, IDM_PASTE, MF_BYCOMMAND | (hClip ? MF_ENABLED : MF_DISABLED | MF_GRAYED));

uCommand = ListView_GetSelectedCount(m_hwndList);
EnableMenuItem(hMenu, IDM_CUT, MF_BYCOMMAND | (uCommand ? MF_ENABLED : MF_DISABLED | MF_GRAYED));
EnableMenuItem(hMenu, IDM_COPY, MF_BYCOMMAND | (uCommand ? MF_ENABLED : MF_DISABLED | MF_GRAYED));

switch(m_FolderSettings.ViewMode)
   {
   case FVM_ICON:
      uCommand = IDM_VIEW_LARGE;
      break;

   case FVM_SMALLICON:
      uCommand = IDM_VIEW_SMALL;
      break;

   case FVM_LIST:
      uCommand = IDM_VIEW_LIST;
      break;

   case FVM_DETAILS:
   default:
      uCommand = IDM_VIEW_DETAILS;
      break;
   }

CheckMenuRadioItem(hMenu, IDM_VIEW_LARGE, IDM_VIEW_DETAILS, uCommand, MF_BYCOMMAND);

return 0;
}

/**************************************************************************

   CShellView::UpdateToolbar()

**************************************************************************/

LRESULT CShellView::UpdateToolbar(VOID)
{
LRESULT  lResult;
UINT     uCommand;

//enable/disable/check the toolbar items here
switch(m_FolderSettings.ViewMode)
   {
   case FVM_ICON:
      uCommand = IDM_VIEW_LARGE;
      break;

   case FVM_SMALLICON:
      uCommand = IDM_VIEW_SMALL;
      break;

   case FVM_LIST:
      uCommand = IDM_VIEW_LIST;
      break;

   case FVM_DETAILS:
   default:
      uCommand = IDM_VIEW_DETAILS;
      break;
   }

m_pShellBrowser->SendControlMsg( FCW_TOOLBAR, 
                                 TB_CHECKBUTTON,
                                 uCommand, 
                                 MAKELPARAM(TRUE, 0), 
                                 &lResult);

return 0;
}

/**************************************************************************

   CShellView::OnNotify()
   
**************************************************************************/

#define MENU_MAX     100

LRESULT CShellView::OnNotify(UINT CtlID, LPNMHDR lpnmh)
{
switch(lpnmh->code)
   {
   /*
   The original shell on NT will always send TTN_NEEDTEXTW, so handle the 
   cases separately.
   */
   case TTN_NEEDTEXTA:
      {
      LPNMTTDISPINFOA pttt = (LPNMTTDISPINFOA)lpnmh;
      int            i;

      for(i = 0; -1 != g_Tools[i].idCommand; i++)
         {
         if(g_Tools[i].idCommand == pttt->hdr.idFrom)
            {
            LoadStringA(g_hInst, g_Tools[i].idString, pttt->szText, sizeof(pttt->szText));
            return TRUE;
            }
         }
      }
      break;

   case TTN_NEEDTEXTW:
      {
      LPNMTTDISPINFOW pttt = (LPNMTTDISPINFOW)lpnmh;
      int            i;

      for(i = 0; -1 != g_Tools[i].idCommand; i++)
         {
         if(g_Tools[i].idCommand == pttt->hdr.idFrom)
            {
            LoadStringW(g_hInst, g_Tools[i].idString, pttt->szText, sizeof(pttt->szText));
            return TRUE;
            }
         }
      }
      break;

   case NM_SETFOCUS:
      OnSetFocus();
      break;

   case NM_KILLFOCUS:
      OnDeactivate();
      break;

   case HDN_ENDTRACK:
      {
      g_nColumn = ListView_GetColumnWidth(m_hwndList, 0);
      ListView_SetColumnWidth(m_hwndList, 1, LVSCW_AUTOSIZE_USEHEADER);
      }
      return 0;
   
   case LVN_DELETEITEM:
      {
      NM_LISTVIEW *lpnmlv = (NM_LISTVIEW*)lpnmh;
      
      //delete the pidl because we made a copy of it
      m_pPidlMgr->Delete((LPITEMIDLIST)lpnmlv->lParam);
      }
      break;
   
#ifdef LVN_ITEMACTIVATE
   
   case LVN_ITEMACTIVATE:

#else    //LVN_ITEMACTIVATE

   case NM_DBLCLK:
   case NM_RETURN:

#endif   //LVN_ITEMACTIVATE

      DoContextMenu(0, 0, TRUE, (DWORD)-1);
      return 0;
   
   case LVN_GETDISPINFO:
      {
      NMLVDISPINFO   *lpdi = (NMLVDISPINFO*)lpnmh;
      LPITEMIDLIST   pidl = (LPITEMIDLIST)lpdi->item.lParam;

      //is the sub-item information being requested?
      if(lpdi->item.iSubItem)
         {
         //is the text being requested?
         if(lpdi->item.mask & LVIF_TEXT)
            {
            //is this a folder or a value?
            if(m_pPidlMgr->IsFolder(pidl))
               {
               LoadString(g_hInst, IDS_FOLDER_DATA, lpdi->item.pszText, lpdi->item.cchTextMax);
               }
            //its an item
            else
               {
               m_pPidlMgr->GetData(pidl, lpdi->item.pszText, lpdi->item.cchTextMax);
               }
            }
         }
      //the item text is being requested
      else
         {
         //is the text being requested?
         if(lpdi->item.mask & LVIF_TEXT)
            {
            STRRET   str;

            if(SUCCEEDED(m_psfParent->GetDisplayNameOf(pidl, SHGDN_NORMAL | SHGDN_INFOLDER, &str)))
               {
               GetTextFromSTRRET(m_pMalloc, &str, pidl, lpdi->item.pszText, lpdi->item.cchTextMax);
               }
            }

         //is the image being requested?
         if(lpdi->item.mask & LVIF_IMAGE)
            {
            IExtractIcon   *pei;

            if(SUCCEEDED(m_psfParent->GetUIObjectOf(m_hWnd, 1, (LPCITEMIDLIST*)&pidl, IID_IExtractIcon, NULL, (LPVOID*)&pei)))
               {
               UINT  uFlags;

               //GetIconLocation will give us the index into our image list
               pei->GetIconLocation(GIL_FORSHELL, NULL, 0, &lpdi->item.iImage, &uFlags);

               pei->Release();
               }
            }
         }
      }
      return 0;
   
   case LVN_BEGINLABELEDIT:
      {
      NMLVDISPINFO   *lpdi = (NMLVDISPINFO*)lpnmh;
      LPITEMIDLIST   pidl = (LPITEMIDLIST)lpdi->item.lParam;
      DWORD          dwAttr = SFGAO_CANRENAME;

      m_psfParent->GetAttributesOf(1, (LPCITEMIDLIST*)&pidl, &dwAttr);
      if(SFGAO_CANRENAME & dwAttr)
         {
         m_fInEdit = TRUE;
         return FALSE;
         }
      }
      return TRUE;
   
   case LVN_ENDLABELEDIT:
      {
      LRESULT        lResult = 0;
      NMLVDISPINFO   *pdi = (NMLVDISPINFO*)lpnmh;

      if(pdi->item.pszText)
         {
         //the user wants to keep the change
         LVITEM         lvItem;
         LPITEMIDLIST   pidl;
         WCHAR          wszNewName[MAX_PATH];

         ZeroMemory(&lvItem, sizeof(lvItem));
         lvItem.mask = LVIF_PARAM;
         lvItem.iItem = pdi->item.iItem;
         ListView_GetItem(m_hwndList, &lvItem);

         LocalToWideChar(wszNewName, pdi->item.pszText, MAX_PATH);
         
         /*
         This will cause this class' RenameItem function to be called. This 
         can cause problems, so the m_fInEdit flag will prevent RenameItem 
         from being called on this object. SetNameOf will also free the old 
         PIDL, so we don't have to do it again.
         */
         HRESULT  hr = m_psfParent->SetNameOf(NULL, (LPITEMIDLIST)lvItem.lParam, wszNewName, 0, &pidl);

         if(SUCCEEDED(hr) && pidl)
            {
            lvItem.mask = LVIF_PARAM;
            lvItem.lParam = (LPARAM)pidl;
            ListView_SetItem(m_hwndList, &lvItem);
            lResult = TRUE;
            }
         }
      
      m_fInEdit = FALSE;
      return lResult;
      }
   
   case LVN_BEGINDRAG:
      {
      HRESULT        hr;
      IDataObject    *pDataObject = NULL;
      UINT           uItemCount;
      LPITEMIDLIST   *aPidls;

      //get the number of selected items
      uItemCount = ListView_GetSelectedCount(m_hwndList);
      if(!uItemCount)
         return 0;
      
      aPidls = (LPITEMIDLIST*)m_pMalloc->Alloc(uItemCount * sizeof(LPITEMIDLIST));
      
      if(aPidls)
         {
         int   i;
         UINT  x;

         for(i = 0, x = 0; x < uItemCount && i < ListView_GetItemCount(m_hwndList); i++)
            {
            if(ListView_GetItemState(m_hwndList, i, LVIS_SELECTED))
               {
               LVITEM   lvItem;

               lvItem.mask = LVIF_PARAM;
               lvItem.iItem = i;

               ListView_GetItem(m_hwndList, &lvItem);
               aPidls[x] = (LPITEMIDLIST)lvItem.lParam;
               x++;
               }
            }

         hr = m_psfParent->GetUIObjectOf( m_hWnd, 
                                          uItemCount, 
                                          (LPCITEMIDLIST*)aPidls, 
                                          IID_IDataObject, 
                                          NULL, 
                                          (LPVOID*)&pDataObject);
      
         if(SUCCEEDED(hr) && pDataObject)
            {
            IDropSource *pDropSource = new CDropSource;
            DWORD       dwEffect = DROPEFFECT_COPY | DROPEFFECT_MOVE;
            DWORD       dwAttributes = SFGAO_CANLINK;

            hr = m_psfParent->GetAttributesOf(  uItemCount, 
                                                (LPCITEMIDLIST*)aPidls, 
                                                &dwAttributes);
            
            if(SUCCEEDED(hr) && (dwAttributes & SFGAO_CANLINK))
               {
               dwEffect |= DROPEFFECT_LINK;
               }

            DoDragDrop( pDataObject, 
                        pDropSource, 
                        dwEffect, 
                        &dwEffect);

            pDataObject->Release();
            pDropSource->Release();
            }

         m_pMalloc->Free(aPidls);
         }
      }
      break;
   
   case LVN_ITEMCHANGED:
      {
      UpdateToolbar();
      }
      break;
   }

return 0;
}

/**************************************************************************

   CShellView::OnSize()
   
**************************************************************************/

LRESULT CShellView::OnSize(WORD wWidth, WORD wHeight)
{
//resize the ListView to fit our window
if(m_hwndList)
   {
   MoveWindow(m_hwndList, 0, 0, wWidth, wHeight, TRUE);

   ListView_SetColumnWidth(m_hwndList, 0, g_nColumn);
   ListView_SetColumnWidth(m_hwndList, 1, LVSCW_AUTOSIZE_USEHEADER);
   }

return 0;
}

/**************************************************************************

   CShellView::OnCreate()
   
**************************************************************************/

LRESULT CShellView::OnCreate(VOID)
{
//create the ListView
if(CreateList())
   {
   if(InitList())
      {
      FillList();
      }
   }

HRESULT  hr;
IDropTarget *pdt;

//get the IDropTarget for this folder
hr = m_psfParent->CreateViewObject( m_hWnd, 
                                    IID_IDropTarget, 
                                    (LPVOID*)&pdt);

if(SUCCEEDED(hr))
   {
   //register the window as a drop target
   RegisterDragDrop(m_hWnd, pdt);

   pdt->Release();
   }

return 0;
}

/**************************************************************************

   CShellView::OnDestroy()
   
**************************************************************************/

LRESULT CShellView::OnDestroy(VOID)
{
//unregister the window as a drop target
RevokeDragDrop(m_hWnd);

return 0;
}

/**************************************************************************

   CShellView::CreateList()
   
**************************************************************************/

BOOL CShellView::CreateList(VOID)
{
DWORD dwStyle;

dwStyle =   WS_TABSTOP | 
            WS_VISIBLE |
            WS_CHILD | 
            WS_BORDER | 
            LVS_NOSORTHEADER |
            LVS_SHAREIMAGELISTS |
            LVS_EDITLABELS;

switch(m_FolderSettings.ViewMode)
   {
   default:
   case FVM_ICON:
      dwStyle |= LVS_ICON;
      break;

   case FVM_SMALLICON:
      dwStyle |= LVS_SMALLICON;
      break;

   case FVM_LIST:
      dwStyle |= LVS_LIST;
      break;

   case FVM_DETAILS:
      dwStyle |= LVS_REPORT;
      break;

   }

if(FWF_AUTOARRANGE & m_FolderSettings.fFlags)
   dwStyle |= LVS_AUTOARRANGE;

m_hwndList = CreateWindowEx(     WS_EX_CLIENTEDGE,
                                 WC_LISTVIEW,
                                 NULL,
                                 dwStyle,
                                 0,
                                 0,
                                 0,
                                 0,
                                 m_hWnd,
                                 (HMENU)ID_LISTVIEW,
                                 g_hInst,
                                 NULL);

if(!m_hwndList)
   return FALSE;

GetShellSettings();

return TRUE;
}

/**************************************************************************

   CShellView::InitList()
   
**************************************************************************/

BOOL CShellView::InitList(VOID)
{
LVCOLUMN    lvColumn;
TCHAR       szString[MAX_PATH];

//empty the list
ListView_DeleteAllItems(m_hwndList);

//initialize the columns
lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
lvColumn.fmt = LVCFMT_LEFT;
lvColumn.pszText = szString;

lvColumn.cx = g_nColumn;
LoadString(g_hInst, IDS_COLUMN1, szString, sizeof(szString));
ListView_InsertColumn(m_hwndList, 0, &lvColumn);

lvColumn.cx = g_nColumn;
LoadString(g_hInst, IDS_COLUMN2, szString, sizeof(szString));
ListView_InsertColumn(m_hwndList, 1, &lvColumn);

ListView_SetImageList(m_hwndList, g_himlLarge, LVSIL_NORMAL);
ListView_SetImageList(m_hwndList, g_himlSmall, LVSIL_SMALL);

return TRUE;
}

/**************************************************************************

   CShellView::FillList()
   
**************************************************************************/

VOID CShellView::FillList(VOID)
{
LPENUMIDLIST   pEnumIDList;

if(SUCCEEDED(m_psfParent->EnumObjects(m_hWnd, SHCONTF_NONFOLDERS | SHCONTF_FOLDERS, &pEnumIDList)))
   {
   LPITEMIDLIST   pidl;
   DWORD          dwFetched;

   //turn the listview's redrawing off
   SendMessage(m_hwndList, WM_SETREDRAW, FALSE, 0);

   while((S_OK == pEnumIDList->Next(1, &pidl, &dwFetched)) && dwFetched)
      {
      AddItem(pidl);
/*
*/
      }

   //sort the items
   ListView_SortItems(m_hwndList, CompareItems, (LPARAM)m_psfParent);
   
   //turn the listview's redrawing back on and force it to draw
   SendMessage(m_hwndList, WM_SETREDRAW, TRUE, 0);
   InvalidateRect(m_hwndList, NULL, TRUE);
   UpdateWindow(m_hwndList);

   pEnumIDList->Release();
   }
}

/**************************************************************************

   CShellView::GetShellSettings()
   
**************************************************************************/

#if (_WIN32_IE >= 0x0400)
typedef VOID (WINAPI *PFNSHGETSETTINGSPROC)(LPSHELLFLAGSTATE lpsfs, DWORD dwMask);

VOID CShellView::GetShellSettings(VOID)
{
SHELLFLAGSTATE       sfs;
HINSTANCE            hinstShell32;

/*
Since SHGetSettings is not implemented in all versions of the shell, get the 
function address manually at run time. This allows the extension to run on all 
platforms.
*/

ZeroMemory(&sfs, sizeof(sfs));

/*
The default, in case any of the following steps fails, is classic Windows 95 
style.
*/
sfs.fWin95Classic = TRUE;

hinstShell32 = LoadLibrary(TEXT("shell32.dll"));
if(hinstShell32)
   {
   PFNSHGETSETTINGSPROC pfnSHGetSettings;

   pfnSHGetSettings = (PFNSHGETSETTINGSPROC)GetProcAddress(hinstShell32, "SHGetSettings");
   if(pfnSHGetSettings)
      {
      (*pfnSHGetSettings)(&sfs, SSF_DOUBLECLICKINWEBVIEW | SSF_WIN95CLASSIC);
      }
   FreeLibrary(hinstShell32);
   }

DWORD dwExStyles = 0;

if(!sfs.fWin95Classic && !sfs.fDoubleClickInWebView)
   {
   dwExStyles |= LVS_EX_ONECLICKACTIVATE | 
                  LVS_EX_TRACKSELECT | 
                  LVS_EX_UNDERLINEHOT;
   }

ListView_SetExtendedListViewStyle(m_hwndList, dwExStyles);
}
#else
VOID CShellView::GetShellSettings(VOID)
{
}
#endif

/**************************************************************************

   CShellView::OnSettingChange()
   
**************************************************************************/

LRESULT CShellView::OnSettingChange(LPCTSTR lpszSection)
{
if(0 == lstrcmpi(lpszSection, TEXT("ShellState")))
   {
   GetShellSettings();
   return 0;
   }

return 0;
}

/**************************************************************************

   CShellView::DoContextMenu()
   
**************************************************************************/

VOID CShellView::DoContextMenu(WORD x, WORD y, BOOL fDefault, DWORD dwCmdIn)
{
UINT           uSelected = 0;
LPITEMIDLIST   *aSelectedItems = NULL;
LPCONTEXTMENU  pContextMenu = NULL;

if(m_uState != SVUIA_ACTIVATE_NOFOCUS)
   {
   uSelected = ListView_GetSelectedCount(m_hwndList);
   }

if(uSelected)
   {
   aSelectedItems = (LPITEMIDLIST*)m_pMalloc->Alloc((uSelected + 1) * sizeof(LPITEMIDLIST));

   if(aSelectedItems)
      {
      UINT     i;
      LVITEM   lvItem;

      ZeroMemory(&lvItem, sizeof(lvItem));
      lvItem.mask = LVIF_STATE | LVIF_PARAM;
      lvItem.stateMask = LVIS_SELECTED;
      lvItem.iItem = 0;

      i = 0;

      while(ListView_GetItem(m_hwndList, &lvItem) && (i < uSelected))
         {
         if(lvItem.state & LVIS_SELECTED)
            {
            aSelectedItems[i] = (LPITEMIDLIST)lvItem.lParam;
            i++;
            }
         lvItem.iItem++;
         }
      m_psfParent->GetUIObjectOf(   m_hwndParent,
                                    uSelected,
                                    (LPCITEMIDLIST*)aSelectedItems,
                                    IID_IContextMenu,
                                    NULL,
                                    (LPVOID*)&pContextMenu);

      }
   }
else
   {
   m_psfParent->CreateViewObject(   m_hwndParent,
                                    IID_IContextMenu,
                                    (LPVOID*)&pContextMenu);
   }

if(pContextMenu)
   {
   HMENU hMenu = CreatePopupMenu();

   /*
   See if we are in Explore or Open mode. If the browser's tree is present, 
   then we are in Explore mode.
   */
   BOOL  fExplore = FALSE;
   HWND  hwndTree = NULL;
   if(SUCCEEDED(m_pShellBrowser->GetControlWindow(FCW_TREE, &hwndTree)) && hwndTree)
      {
      fExplore = TRUE;
      }

   if(hMenu && SUCCEEDED(pContextMenu->QueryContextMenu( hMenu,
                                                         0,
                                                         0,
                                                         MENU_MAX,
                                                         CMF_NORMAL | 
                                                            (fExplore ? CMF_EXPLORE : 0) |
                                                            ((uSelected > 1) ? MYCMF_MULTISELECT: 0))))
      {
      UINT  uCommand;

      if(fDefault)
         {
         MENUITEMINFO   mii;
         int            nMenuIndex;

         uCommand = 0;
         
         ZeroMemory(&mii, sizeof(mii));
         mii.cbSize = sizeof(mii);
         mii.fMask = MIIM_STATE | MIIM_ID;

         nMenuIndex = 0;

         //find the default item in the menu
         while(GetMenuItemInfo(hMenu, nMenuIndex, TRUE, &mii))
            {
            if(mii.fState & MFS_DEFAULT)
               {
               uCommand = mii.wID;
               break;
               }

            nMenuIndex++;
            }
         }
      else if(-1 != dwCmdIn)
         {
         //this command will get sent directly without bringing up the menu
         uCommand = dwCmdIn;
         }
      else
         {
         uCommand = TrackPopupMenu( hMenu,
                                    TPM_LEFTALIGN | TPM_RETURNCMD,
                                    x,
                                    y,
                                    0,
                                    m_hWnd,
                                    NULL);
         }
      
      if(uCommand > 0)
         {
         //some commands need to be handled by the view itself
         switch(uCommand)
            {
            case IDM_VIEW_LARGE:
               OnViewLarge();
               break;

            case IDM_VIEW_SMALL:
               OnViewSmall();
               break;

            case IDM_VIEW_LIST:
               OnViewList();
               break;

            case IDM_VIEW_DETAILS:
               OnViewDetails();
               break;

            default:
               {
               CMINVOKECOMMANDINFO  cmi;

               ZeroMemory(&cmi, sizeof(cmi));
               cmi.cbSize = sizeof(cmi);
               cmi.hwnd = m_hWnd;
               cmi.lpVerb = (LPCSTR)MAKEINTRESOURCE(uCommand);

               pContextMenu->InvokeCommand(&cmi);
               }
               break;
            }

         }

      DestroyMenu(hMenu);
      }
   
   pContextMenu->Release();
   }

if(aSelectedItems)
   m_pMalloc->Free(aSelectedItems);

UpdateToolbar();
}

/**************************************************************************

   CShellView::AddItem()

**************************************************************************/

BOOL CShellView::AddItem(LPCITEMIDLIST pidl)
{
LVITEM   lvItem;

ZeroMemory(&lvItem, sizeof(lvItem));

//set the mask
lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;

//add the item to the end of the list
lvItem.iItem = ListView_GetItemCount(m_hwndList);

//set the item's data
lvItem.lParam = (LPARAM)m_pPidlMgr->Copy(pidl);

//get text on a callback basis
lvItem.pszText = LPSTR_TEXTCALLBACK;

//get the image on a callback basis
lvItem.iImage = I_IMAGECALLBACK;

//add the item
if(-1 == ListView_InsertItem(m_hwndList, &lvItem))
   return FALSE;

return TRUE;
}

/**************************************************************************

   CShellView::DeleteItem()

**************************************************************************/

BOOL CShellView::DeleteItem(LPCITEMIDLIST pidl)
{
//delete the item from the list
int   nIndex = FindItemPidl(pidl);

if(-1 != nIndex)
   {
   return ListView_DeleteItem(m_hwndList, nIndex);
   }

return FALSE;
}

/**************************************************************************

   CShellView::RenameItem()

**************************************************************************/

BOOL CShellView::RenameItem(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidlNew)
{
//don't allow this to be called if this object is the being edited

if(m_fInEdit)
   return TRUE;

//find the item in the list
int   nIndex = FindItemPidl(pidlOld);

if(-1 != nIndex)
   {
   BOOL     fReturn;
   LVITEM   lvItem;

   ZeroMemory(&lvItem, sizeof(lvItem));
   lvItem.mask = LVIF_PARAM;
   lvItem.iItem = nIndex;
   ListView_GetItem(m_hwndList, &lvItem);
   
   m_pPidlMgr->Delete((LPITEMIDLIST)lvItem.lParam);

   ZeroMemory(&lvItem, sizeof(lvItem));
   lvItem.mask = LVIF_PARAM;
   lvItem.iItem = nIndex;
   lvItem.lParam = (LPARAM)m_pPidlMgr->Copy(pidlNew);
   fReturn = ListView_SetItem(m_hwndList, &lvItem);
   ListView_Update(m_hwndList, nIndex);
   return fReturn;
   }

return FALSE;
}

/**************************************************************************

   CShellView::GetPidl()

**************************************************************************/

LPITEMIDLIST CShellView::GetPidl()
{
return m_psfParent->CreateFQPidl(NULL);
}

/**************************************************************************

   CShellView::GetFQPidl()

**************************************************************************/

LPITEMIDLIST CShellView::GetFQPidl()
{
return m_psfParent->CreateFQPidl(NULL);
}

/**************************************************************************

   CShellView::FindItemPidl()

**************************************************************************/

int CShellView::FindItemPidl(LPCITEMIDLIST pidl)
{
LVITEM   lvItem;

ZeroMemory(&lvItem, sizeof(lvItem));
lvItem.mask = LVIF_PARAM;

for(lvItem.iItem = 0; ListView_GetItem(m_hwndList, &lvItem); lvItem.iItem++)
   {
   LPITEMIDLIST   pidlFound = (LPITEMIDLIST)lvItem.lParam;
   HRESULT        hr = m_psfParent->CompareIDs(0, pidl, pidlFound);
   if(SUCCEEDED(hr) && 0 == HRESULT_CODE(hr))
      {
      //we found the item
      return lvItem.iItem;
      }
   }

return -1;
}

/**************************************************************************

   CShellView::MarkItemsAsCut()

   Marks the items as cut.

**************************************************************************/

VOID CShellView::MarkItemsAsCut(LPCITEMIDLIST *aPidls, UINT uItemCount)
{
UINT  i;

for(i = 0; i < uItemCount; i++)
   {
   LPITEMIDLIST   pidlTemp = m_pPidlMgr->GetLastItem(aPidls[i]);
   int            nIndex = FindItemPidl(pidlTemp);

   if(nIndex != -1)
      {
      ListView_SetItemState(m_hwndList, nIndex, LVIS_CUT, LVIS_CUT);
      }
   }
}

/**************************************************************************

   CShellView::EditItem()

**************************************************************************/

VOID CShellView::EditItem(LPCITEMIDLIST pidl)
{
int   i;

i = FindItemPidl(pidl);

if(-1 != i)
   {
   SetFocus(m_hwndList);

   //put the ListView into edit mode
   ListView_EditLabel(m_hwndList, i);
   }
}

/**************************************************************************

   CShellView::UpdateData()

**************************************************************************/

VOID CShellView::UpdateData(LPCITEMIDLIST pidl)
{
int   i;

i = FindItemPidl(pidl);

if(-1 != i)
   {
   LVITEM   lvItem;

   ZeroMemory(&lvItem, sizeof(lvItem));
   lvItem.mask = LVIF_PARAM;
   lvItem.iItem = i;
   ListView_GetItem(m_hwndList, &lvItem);
   
   m_pPidlMgr->Delete((LPITEMIDLIST)lvItem.lParam);

   ZeroMemory(&lvItem, sizeof(lvItem));
   lvItem.mask = LVIF_PARAM;
   lvItem.iItem = i;
   lvItem.lParam = (LPARAM)m_pPidlMgr->Copy(pidl);
   ListView_SetItem(m_hwndList, &lvItem);
   ListView_Update(m_hwndList, i);
   }
}

/**************************************************************************

   CShellView::OnViewLarge()

**************************************************************************/

LRESULT CShellView::OnViewLarge(VOID)
{
m_FolderSettings.ViewMode = FVM_ICON;

DWORD dwStyle = GetWindowLong(m_hwndList, GWL_STYLE);
dwStyle &= ~LVS_TYPEMASK;
dwStyle |= LVS_ICON;
SetWindowLong(m_hwndList, GWL_STYLE, dwStyle);

return 0;
}

/**************************************************************************

   CShellView::OnViewSmall()

**************************************************************************/

LRESULT CShellView::OnViewSmall(VOID)
{
m_FolderSettings.ViewMode = FVM_SMALLICON;

DWORD dwStyle = GetWindowLong(m_hwndList, GWL_STYLE);
dwStyle &= ~LVS_TYPEMASK;
dwStyle |= LVS_SMALLICON;
SetWindowLong(m_hwndList, GWL_STYLE, dwStyle);

return 0;
}

/**************************************************************************

   CShellView::OnViewList()

**************************************************************************/

LRESULT CShellView::OnViewList(VOID)
{
m_FolderSettings.ViewMode = FVM_LIST;

DWORD dwStyle = GetWindowLong(m_hwndList, GWL_STYLE);
dwStyle &= ~LVS_TYPEMASK;
dwStyle |= LVS_LIST;
SetWindowLong(m_hwndList, GWL_STYLE, dwStyle);

return 0;
}

/**************************************************************************

   CShellView::OnViewDetails()

**************************************************************************/

LRESULT CShellView::OnViewDetails(VOID)
{
m_FolderSettings.ViewMode = FVM_DETAILS;

DWORD dwStyle = GetWindowLong(m_hwndList, GWL_STYLE);
dwStyle &= ~LVS_TYPEMASK;
dwStyle |= LVS_REPORT;
SetWindowLong(m_hwndList, GWL_STYLE, dwStyle);

return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\shlview.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ShlView.h
   
   Description:   CShellView definitions.

**************************************************************************/

#ifndef SHELLVIEW_H
#define SHELLVIEW_H

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <shlobj.h>
#include <ServProv.h>
#include <DocObj.h>
#include "ShlFldr.h"
#include "PidlMgr.h"
#include "ContMenu.h"

/**************************************************************************
   global IDs
**************************************************************************/

//control IDs
#define ID_LISTVIEW     2000

/**************************************************************************

   CShellView class definition

**************************************************************************/

class CShellView : public IShellView
{
friend class CShellFolder;
friend class CContextMenu;

private:
   DWORD          m_ObjRefCount;
   UINT           m_uState;
    LPITEMIDLIST   m_pidl;
    FOLDERSETTINGS m_FolderSettings;
    LPSHELLBROWSER m_pShellBrowser;
    HWND           m_hwndParent;
    HWND           m_hWnd;
    HWND           m_hwndList;
    HMENU          m_hMenu;
   CShellFolder   *m_psfParent;
    LPMALLOC       m_pMalloc;
   CPidlMgr       *m_pPidlMgr;
   HACCEL         m_hAccels;
   BOOL           m_fInEdit;
   
public:
   CShellView(CShellFolder*, LPCITEMIDLIST);
   ~CShellView();
   
   //IUnknown methods
   STDMETHOD (QueryInterface)(REFIID, LPVOID*);
   STDMETHOD_ (DWORD, AddRef)();
   STDMETHOD_ (DWORD, Release)();
   
   //IOleWindow methods
   STDMETHOD (GetWindow) (HWND*