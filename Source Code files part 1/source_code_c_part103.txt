(hDir);

            // duplicate path
            *lpath = (LPWSTR) LocalAlloc(LMEM_FIXED, (wcslen(path)+1)*sizeof(WCHAR));
            if (*lpath != NULL) {
                wcscpy(*lpath, path);
                SetupLog(("Local path %S\n", *lpath));
            } else {
                err = GetLastError();
            }
        } else {
            err = GetLastError(); 
            SetupLogError(("Unable to open directory %d\n", err));
        }

        if (err == ERROR_SUCCESS) {

            // check if share doesn't exist already
            SHARE_INFO_502 shareInfo;
            PBYTE BufPtr;

            err = NetShareGetInfo(NULL, name, 502, (PBYTE *)&BufPtr);
            // [RajDas] 550180: Check that the share points to the expected local path.
            if (err == ERROR_SUCCESS) {
                SHARE_INFO_502 *pShareInfo=(SHARE_INFO_502 *)BufPtr;

                if (wcscmp(path, pShareInfo->shi502_path) != 0) {
                    SetupLogError(("Share %S pointing to %S instead of %S\n", name, pShareInfo->shi502_path, path));
                    err = ERROR_INVALID_PARAMETER;
                }
                else {
                    SetupLogError(("Netshare '%S' already exists\n", name));
                }
                NetApiBufferFree(BufPtr);
            }
            else {
                PSECURITY_DESCRIPTOR    secDesc;

                err = ConvertStringSecurityDescriptorToSecurityDescriptor(
                    L"D:P(A;;GA;;;BA)(A;;GA;;;CO)",
                    SDDL_REVISION_1,
                    &secDesc,
                    NULL);

                if (!err) {
                    secDesc = NULL;
                    err = GetLastError();
                    SetupLogError(("Unable to get security desc %d\n", err));
                }

                // create a net share now
                ZeroMemory( &shareInfo, sizeof( shareInfo ) );
                shareInfo.shi502_netname =      name;
                shareInfo.shi502_type =         STYPE_DISKTREE;
                shareInfo.shi502_remark =       L"Cluster Quorum Share";
                shareInfo.shi502_max_uses =     -1;
                shareInfo.shi502_path =         path;
                shareInfo.shi502_passwd =       NULL;
                shareInfo.shi502_permissions =  ACCESS_ALL;
                //  set security stuff
                shareInfo.shi502_security_descriptor = secDesc;

                err = NetShareAdd( NULL, 502, (PBYTE)&shareInfo, NULL );

                if (secDesc)
                    LocalFree(secDesc);
            } 
        }
    } else {
        err = GetLastError();
    }

exit_gracefully:
    if (path) {
        HeapFree(GetProcessHeap(), 0, path);
    }
    
    return err;

}

DWORD
GetDwParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )


{
    DWORD Value = 0;
    DWORD ValueLength;
    DWORD ValueType;
    DWORD Status;

    ValueLength = sizeof(Value);
    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  (LPBYTE) &Value,
                                  &ValueLength);
    if ( (Status != ERROR_SUCCESS) &&
         (Status != ERROR_MORE_DATA) ) {
        SetLastError(Status);
    }

    return(Value);
}

LPWSTR
GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )

/*++

Routine Description:

    Queries a REG_SZ parameter out of the registry and allocates the
    necessary storage for it.

Arguments:

    ClusterKey - Supplies the cluster key where the parameter is stored

    ValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter if successful.

    NULL if unsuccessful.

--*/

{
    LPWSTR Value;
    DWORD ValueLength;
    DWORD ValueType;
    DWORD Status;

    ValueLength = 0;
    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  NULL,
                                  &ValueLength);
    if ( (Status != ERROR_SUCCESS) &&
         (Status != ERROR_MORE_DATA) ) {
        SetLastError(Status);
        return(NULL);
    }
    if ( ValueType == REG_SZ ) {
        ValueLength += sizeof(UNICODE_NULL);
    }
    Value = LocalAlloc(LMEM_FIXED, ValueLength);
    if (Value == NULL) {
        return(NULL);
    }
    Status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &ValueType,
                                  (LPBYTE)Value,
                                  &ValueLength);
    if (Status != ERROR_SUCCESS) {
        LocalFree(Value);
        SetLastError(Status);
        Value = NULL;
    }

    return(Value);
} // GetParameter

#ifdef ENABLE_SMB
The flag above should always be turned off.
Just ensuring that this code is never compiled.

DWORD
SetupNetworkInterfaceFromRegistry(HKEY hkey, LPWSTR netname, VCD_INFO *info)
{
    HKEY    rkey;
    DWORD   err, index;

    // get network key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_NETINTERFACES, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
    return err;
    }

    for (index = 0; TRUE; index++) {
    WCHAR   name[256];
    DWORD   sz;
    FILETIME   mtime;
    HKEY    tkey;
    LPWSTR  tname;
    DWORD   id;

    sz = sizeof(name) / sizeof(WCHAR);
    err = ClusterRegEnumKey(rkey, index, name, &sz, &mtime);
    if (err != ERROR_SUCCESS)
        break;

    err = ClusterRegOpenKey(rkey, name, KEY_READ, &tkey);
    if (err != ERROR_SUCCESS)
        break;

    // get the name and compare it against our name
    tname = GetParameter(tkey, CLUSREG_NAME_NETIFACE_NODE);
    if (tname == NULL)
        continue;

    id = wcstol(tname, NULL, 10);
    LocalFree(tname);
    
    if (id != info->lid)
        continue;

    tname = GetParameter(tkey, CLUSREG_NAME_NETIFACE_NETWORK);
    
    SetupLog(("Node %d adapter %S\n", id, tname));
    if (wcscmp(tname, netname) == 0) {
        // get adapter id
        LocalFree(tname);

        tname = GetParameter(tkey, CLUSREG_NAME_NETIFACE_ADAPTER_ID);
        if (tname) {
            // find nic
            SetupLog(("Find transport %S\n", tname));
            err = FindTransport(tname, &info->Transport);
            LinkageGuidToIndex(tname, &info->Nic);
        }
        LocalFree(tname);
        ClusterRegCloseKey(tkey);
        break;
    }

    LocalFree(tname);
    ClusterRegCloseKey(tkey);
    }

    ClusterRegCloseKey(rkey);
    
    if (err == ERROR_NO_MORE_ITEMS)
    err = ERROR_SUCCESS;
    return err;
}

DWORD
SetupNetworkFromRegistry(HKEY hkey, VCD_INFO *info)
{
    HKEY    rkey;
    DWORD   err, index;

    // get network key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_NETWORKS, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
    return err;
    }

    for (index = 0; TRUE; index++) {
    WCHAR   name[256];
    DWORD   sz;
    FILETIME   mtime;
    HKEY    tkey;
    DWORD   id;

    sz = sizeof(name) / sizeof(WCHAR);
    err = ClusterRegEnumKey(rkey, index, name, &sz, &mtime);
    if (err != ERROR_SUCCESS)
        break;

    err = ClusterRegOpenKey(rkey, name, KEY_READ, &tkey);
    if (err != ERROR_SUCCESS)
        break;

    // get the name and compare it against our name
    id = GetDwParameter(tkey, CLUSREG_NAME_NET_PRIORITY);
    SetupLog(("Found network %d %S\n", id, name));
    if (id == 1) {
        // find which nic belongs to this transport
        err = SetupNetworkInterfaceFromRegistry(hkey, name, info);
        ClusterRegCloseKey(tkey);
        break;
    }

    ClusterRegCloseKey(tkey);
    }

    ClusterRegCloseKey(rkey);
    
    if (err == ERROR_NO_MORE_ITEMS)
    err = ERROR_SUCCESS;
    return err;
}
#endif //ENABLE_SMB

DWORD
SetupNodesFromRegistry(HCLUSTER hCluster, VCD_INFO *info)
{
    HKEY    hkey, rkey;
    DWORD   err, index;
    WCHAR   localname[MAX_COMPUTERNAME_LENGTH + 1];

    memset(info, 0, sizeof(*info));

    index = sizeof(localname) / sizeof(WCHAR);
    if (GetComputerName(localname, &index) == FALSE) {
    return GetLastError();
    }

    hkey = GetClusterKey(hCluster, KEY_READ);
    if (hkey == NULL)
        return GetLastError();

    // get resource key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_NODES, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
        ClusterRegCloseKey(hkey);
        return err;
    }

    for (index = 0; TRUE; index++) {
    WCHAR   name[256];
    DWORD   sz;
    FILETIME   mtime;
    HKEY    tkey;
    LPWSTR  tname;
    DWORD   id;

    sz = sizeof(name) / sizeof(WCHAR);
    err = ClusterRegEnumKey(rkey, index, name, &sz, &mtime);
    if (err != ERROR_SUCCESS)
        break;

    err = ClusterRegOpenKey(rkey, name, KEY_READ, &tkey);
    if (err != ERROR_SUCCESS)
        break;

    // get the name and compare it against our name
    tname = GetParameter(tkey, CLUSREG_NAME_NODE_NAME);
    if (tname == NULL) {
        err = GetLastError();
        ClusterRegCloseKey(tkey);
        break;
    }
    ClusterRegCloseKey(tkey);

    id = wcstol(name, NULL, 10);

    SetupLog(("Found node %d %S\n", id, tname));

    NodeAddNode(info, tname, id);

    if (wcscmp(localname, tname) == 0) {
        // set our local id
        info->lid = id;
#ifdef ENABLE_SMB        
        // find which nic and transport to use
        SetupNetworkFromRegistry(hkey, info);
#endif        
        
    }
    LocalFree(tname);
    }

    ClusterRegCloseKey(rkey);
    ClusterRegCloseKey(hkey);

    if (err == ERROR_NO_MORE_ITEMS)
    err = ERROR_SUCCESS;
    return err;
}

DWORD
SetupNodes(HKEY hClusKey, VCD_INFO *info)
{
    DWORD err;

    memset(info, 0, sizeof(*info));

    if ((info->lid = GetLocalNodeId(hClusKey)) == 0) {
        err = GetLastError();
        SetupLogError(("Unable to get local id %d\n", err));
        return err;
    }

    SetupLog(("Local node id %d\n", info->lid));

    err = NodeInit(info, hClusKey);

    return err;
}


DWORD
GetIDFromRegistry(IN HKEY hClusKey, IN LPWSTR resname, OUT LPWSTR *id)
{
    HKEY        hRessKey=NULL, hResKey=NULL;
    WCHAR       resId[MAX_PATH], rName[MAX_PATH];
    DWORD       status=ERROR_SUCCESS;
    DWORD       ndx, size, type;
    FILETIME    fileTime;

    *id = NULL;

    status = RegOpenKeyExW(hClusKey, CLUSREG_KEYNAME_RESOURCES, 0, KEY_READ, &hRessKey);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }
    
    for(ndx=0;TRUE;ndx++) {
        size = MAX_PATH;
        status = RegEnumKeyExW(hRessKey, ndx, resId, &size, NULL, NULL, 0, &fileTime);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
        
        status = RegOpenKeyExW(hRessKey, resId, 0, KEY_READ, &hResKey);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        size = MAX_PATH;
        status = RegQueryValueExW(hResKey, CLUSREG_NAME_RES_NAME, NULL, &type, (LPBYTE)rName, &size);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        if (wcscmp(rName, resname)) {
            RegCloseKey(hResKey);
            hResKey = NULL;
            continue;
        }
        *id = LocalAlloc(LMEM_FIXED, MAX_PATH);
        if (*id) {
            wcscpy(*id, resId);
        }
        else {
            status = GetLastError();
        }
        break;        
    }
    
error_exit:

    if (hResKey) {
        RegCloseKey(hResKey);
    }

    if (hRessKey) {
        RegCloseKey(hRessKey);
    }

    if (status == ERROR_NO_MORE_ITEMS) {
        status = ERROR_NOT_FOUND;
    }
    else if (status == ERROR_SUCCESS) {
        SetupLog(("Guid %S\n", *id));
    }
    
    return status;
}

DWORD
GetIDFromName(
    IN      HRESOURCE   hResource,
    IN      HCLUSTER    hCluster,
    OUT     LPWSTR      *ppszID
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;
    TCHAR locName[128];
    DWORD size = sizeof(locName)/sizeof(TCHAR);
    HNODE hNode;

    if (hResource && ppszID) 
    {
        //
        // Should be able to hold the string representation of a guid
        //
        DWORD cbBuf = 80;

        //
        // Set the out parameter to something known
        //
        *ppszID = NULL;

        // Should prevent the ClusterResourceControl() call below from going to another node.
        if (!GetComputerName(locName, &size)) {
            dwError = GetLastError();
            SetupLogError(("Failed to get local node name, status=%u\n", dwError));
            return dwError;
        }

        if ((hNode = OpenClusterNode(hCluster, locName)) == NULL) {
            dwError = GetLastError();
            SetupLogError(("Failed to open cluster node %ws, status=%u\n", locName, dwError));
            return dwError;
        }
            
        if (*ppszID = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf)) 
        {
            if ((dwError = ClusterResourceControl(hResource, 
                                                  hNode,
                                                  CLUSCTL_RESOURCE_GET_ID,
                                                  NULL,                                               
                                                  0,
                                                  *ppszID,
                                                  cbBuf,
                                                  &cbBuf)) == ERROR_MORE_DATA) 
            {
                LocalFree(*ppszID);

                if (*ppszID = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf)) 
                {
                    dwError = ClusterResourceControl(hResource, 
                                                     hNode,
                                                     CLUSCTL_RESOURCE_GET_ID,
                                                     NULL,                                               
                                                     0,
                                                     *ppszID,
                                                     cbBuf,
                                                     &cbBuf);
                }
                else
                {
                    dwError = GetLastError();
                }
            }

            //
            // Free the memory if getting the ID failed
            //
            if (dwError != ERROR_SUCCESS && *ppszID) 
            {
                LocalFree(*ppszID);
                *ppszID = NULL;
            }
        }
        else
        {
            dwError = GetLastError();
        }

        CloseClusterNode(hNode);
    }
    
    return dwError;
}

DWORD
SetupIoctlQuorumResource(LPWSTR ResType, DWORD ControlCode)
{

    HRESOURCE hres;
    HCLUSTER chdl;
    HKEY    hkey, rkey, qkey;
    DWORD   err, index;
    LPWSTR  tname, resname;

    chdl = OpenCluster(NULL);
    if (chdl == NULL) {
        SetupLogError(("Unable to open cluster\n"));
        return GetLastError();
    }

    hkey = GetClusterKey(chdl, KEY_READ);
    if (hkey == NULL) {
        CloseCluster(chdl);
        return GetLastError();
    }

    // get quorum key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_QUORUM, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
        ClusterRegCloseKey(hkey);
        CloseCluster(chdl);
        return err;
    }

    // read guid of current quorum
    tname = GetParameter(rkey, CLUSREG_NAME_QUORUM_RESOURCE);
    if (tname == NULL) {
        err = GetLastError();
        ClusterRegCloseKey(rkey);
        ClusterRegCloseKey(hkey);
        CloseCluster(chdl);
        return err;
    }

    // close rkey
    ClusterRegCloseKey(rkey);

    // get resources key
    err = ClusterRegOpenKey(hkey, CLUSREG_KEYNAME_RESOURCES, KEY_READ, &rkey);
    if (err != ERROR_SUCCESS) {
        ClusterRegCloseKey(hkey);
        CloseCluster(chdl);
        LocalFree(tname);
        return err;
    }

    // get resource key
    err = ClusterRegOpenKey(rkey, tname, KEY_READ, &qkey);
    LocalFree(tname);
    if (err != ERROR_SUCCESS) {
        ClusterRegCloseKey(rkey);
        ClusterRegCloseKey(hkey);
        CloseCluster(chdl);
        return err;
    }

    // read resource type of current quorum
    tname = GetParameter(qkey, CLUSREG_NAME_RES_TYPE);
    if (tname == NULL)
        err = GetLastError();

    if (tname != NULL && wcscmp(tname, ResType) == 0) {
        resname = GetParameter(qkey, CLUSREG_NAME_RES_NAME);
        if (resname != NULL) {
            err = ERROR_SUCCESS;
            // open this resource and drop ioctl now
            hres = OpenClusterResource(chdl, resname);
            if (hres != NULL) {
                err = ClusterResourceControl(hres, NULL, ControlCode, NULL, 0, NULL,
                                             0, NULL);
                CloseClusterResource(hres);
            }

            LocalFree(resname);

        } else {
            err = GetLastError();
        }
    }

    if (tname)
        LocalFree(tname);

    ClusterRegCloseKey(qkey);
    ClusterRegCloseKey(rkey);
    ClusterRegCloseKey(hkey);
    CloseCluster(chdl);

    return err;
}


DWORD
SetupStart(LPWSTR ResourceName, LPWSTR *SrvPath,
       LPWSTR *DiskList, DWORD *DiskListSize,
       DWORD *NicId, LPWSTR *Transport, DWORD *ArbTime)
{
    DWORD       status=ERROR_SUCCESS;
    LPWSTR      Guid=NULL, nbtName=NULL, lpath=NULL;
    VCD_INFO    Info;
    VCD_NODE    *cur;
    HKEY        hClusKey=NULL;
    DWORD       size, type, sz, ndx;

    // Initialize.
    *SrvPath = NULL;
    *DiskListSize = 0;
    *NicId = 0;
    *Transport = NULL;
    *ArbTime = 0;
    RtlZeroMemory(&Info, sizeof(Info));

    if ((status = RegOpenKeyExW(HKEY_LOCAL_MACHINE, CLUSREG_KEYNAME_CLUSTER, 0, KEY_READ, &hClusKey)) 
                    != ERROR_SUCCESS) {
        SetupLogError(("Unable to open cluster key, status %u\n", status));
        return status;                    
    }

    // Read Quorum arbitration time.
    size= sizeof(DWORD);
    status = RegQueryValueExW(hClusKey, CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT, NULL, &type, (LPBYTE)ArbTime, &size);
    if (status != ERROR_SUCCESS) {
        // This is a tolerated failure.
        *ArbTime = 180;
        status = ERROR_SUCCESS;
    }
    // Use 2/3 of available time.
    *ArbTime = (2 * ((*ArbTime) * 1000)) / 3;
    SetupLog(("Maximum arbitration time %u msec\n", *ArbTime));

    status = GetIDFromRegistry(hClusKey, ResourceName, &Guid);
    if (status != ERROR_SUCCESS) {
        SetupLogError(("GetIDFromRegistry(%S) returned %u\n", ResourceName, status));
        goto done;
    }

    // Add a $ onto the guid
    wcscat(Guid, L"$");

    sz = wcslen(Guid);
    // netbios name are 16 bytes, 3 back-slashs, 1 null and few extra pads
    sz += 32;
    nbtName = (LPWSTR) LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * sz);
    if (nbtName == NULL) {
        status = GetLastError();
        goto done;
    }

    nbtName[0] = L'\\';
    nbtName[1] = L'\\';
    // netbios name are 15 bytes + 1 byte for type. So, we use first 15 bytes
    wcsncpy(&nbtName[2], Guid, 15);
    nbtName[17] = L'\0';
    wcscat(nbtName, L"\\");
    wcscat(nbtName, Guid);
        
    // guid for everything to do with shares and directory name
    status = SetupShare(Guid, &lpath);
    if (status != ERROR_SUCCESS) {
        SetupLogError(("Unable to setup share %d\n", status));
        goto done;
    }

    // get list of nodes.
    // make a path with \\guid\guid
    // make disklist with UNC\nodename\guid, for local node we can use the
    // raw ntfs path directly
    status = SetupNodes(hClusKey, &Info);
    if (status != ERROR_SUCCESS) {
        SetupLogError(("SetupNodes() returned %d\n", status));
    }

    // we start @ slot 1 and not zero, store local path in zero
    DiskList[0] = lpath;
    lpath = NULL;
    for (cur = Info.ClusterList; cur != NULL; cur=cur->next){
        // build a unc\hostname\guid path
        // Mess up the UNC name.
        sz = wcslen(L"UNCCCC\\");
        sz += wcslen(cur->name);
        sz += wcslen(L"\\");
        sz += wcslen(Guid);
        sz += 1;
        ndx = cur->id;

        DiskList[ndx] = (LPWSTR) LocalAlloc(LMEM_FIXED, sz * sizeof(WCHAR));
        if (DiskList[ndx] == NULL) {
            status = GetLastError();
            break;
        }

        wcscpy(DiskList[ndx], L"UNCCC\\");
        wcscat(DiskList[ndx], cur->name);
        wcscat(DiskList[ndx], L"\\");
        wcscat(DiskList[ndx], Guid);

    }

    if (status == ERROR_SUCCESS) {
        *DiskListSize = Info.ClusterSize;
        *SrvPath = nbtName;
        nbtName = NULL;
    }

done:

    // free guid buffer
    if (Guid) {
        LocalFree(Guid);
    }

    while(cur = Info.ClusterList) {
        cur = cur->next;
        LocalFree((PVOID)Info.ClusterList);
        Info.ClusterList = cur;
    }

    if (nbtName) {
        LocalFree(nbtName);
    }

    if (lpath) {
        LocalFree(lpath);
    }

    RegCloseKey(hClusKey);

    return status;
}

DWORD
SetupDelete(IN LPWSTR Path)
{
    LPWSTR  name;
    DWORD   err = ERROR_INVALID_PARAMETER;
    HANDLE  vfd;
    WCHAR   tmp[MAX_PATH];

    if (Path == NULL)
        return err;

    // We need to do couple of things here. First we remove the
    // network share and then delete the tree structure.

    SetupLog(("Delete path %S\n", Path));
    name = wcsstr(Path, SETUP_DIRECTORY_PREFIX);
    if (name != NULL) {
        name += wcslen(SETUP_DIRECTORY_PREFIX);
        err = NetShareDel(NULL, name, 0);
        SetupLog(("Delete share %S err %d\n", name, err));
    }

    // Open path with delete on close and delete whole tree
    // accounting for \\??\\.
    if (wcslen(Path) > (MAX_PATH-16)) {
        return ERROR_MORE_DATA;
    }

    swprintf(tmp,L"\\??\\%s", Path);
    err = xFsOpen(&vfd, NULL, tmp, wcslen(tmp), 
          FILE_GENERIC_READ | FILE_GENERIC_WRITE,
          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
          FILE_DIRECTORY_FILE);

    if (err == STATUS_SUCCESS) {

        err = xFsDeleteTree(vfd);
        xFsClose(vfd);
        SetupLog(("Delete tree %S err %x\n", tmp, err));
        // now delete root
        if (err == STATUS_SUCCESS)
            err = xFsDelete(NULL, tmp, wcslen(tmp));
        SetupLog(("Delete tree %S err %x\n", tmp, err));
    }

    return RtlNtStatusToDosError(err);
}

#ifdef USE_SMB

DWORD
SetupTree(
    IN LPTSTR TreeName,
    IN LPTSTR DlBuf,
    IN OUT DWORD *DlBufSz,
    IN LPTSTR TransportName OPTIONAL,
    IN LPVOID SecurityDescriptor OPTIONAL
    )

{
    DWORD ApiStatus;
    DWORD ConnectionType = USE_WILDCARD; // use_chardev
    IO_STATUS_BLOCK iosb;
    NTSTATUS ntstatus;                      // Status from NT operations.
    OBJECT_ATTRIBUTES objattrTreeConn;      // Attrs for tree conn.
    LPTSTR pszTreeConn = NULL;              // See strTreeConn below.
    UNICODE_STRING ucTreeConn;
    HANDLE TreeConnHandle = NULL;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION Ea;
    USHORT TransportNameSize = 0;
    ULONG EaBufferSize = 0;
    PWSTR UnicodeTransportName = NULL;

    UCHAR EaNameDomainNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_DOMAIN) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNamePasswordSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_PASSWORD) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNameTransportNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_TRANSPORT) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNameTypeSize = (UCHAR) (ROUND_UP_COUNT(
                                        strlen(EA_NAME_TYPE) + sizeof(CHAR),
                                        ALIGN_DWORD
                                        ) - sizeof(CHAR));

    UCHAR EaNameUserNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_USERNAME) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    USHORT TypeSize = sizeof(ULONG);



    if ((TreeName == NULL) || (TreeName[0] == 0)) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Build NT-style name for what we're connecting to.  Note that there is
    // NOT a pair of backslashes anywhere in this name.
    //

    {
        DWORD NameSize =

            // /Device/LanManRedirector      /    server/share     \0
            ( ( STRLEN((LPTSTR)DD_NFS_DEVICE_NAME_U) + 1 + STRLEN(TreeName) + 1 ) )
            * sizeof(TCHAR);

        pszTreeConn = (LPTSTR)LocalAlloc(LMEM_FIXED, NameSize );
    }

    if (pszTreeConn == NULL) {
        ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Build the tree connect name.
    //

    (void) STRCPY(pszTreeConn, (LPTSTR) DD_NFS_DEVICE_NAME_U);

    //
    // NOTE: We add 1, (not sizeof(TCHAR)) because pointer arithmetic is done
    // in terms of multiples of sizeof(*pointer), not bytes
    //
    {
    LPWSTR  p = wcschr(TreeName+2, L'\\');
    if (p != NULL) {
        *p = L'\0';
    }

    (void) STRCAT(pszTreeConn, TreeName+1); // \server\share
    if (p != NULL) {
        *p = L'\\';
        (void) STRCAT(pszTreeConn, L"\\IPC$"); // \server\IPC$
    }
    }

    RtlInitUnicodeString(&ucTreeConn, pszTreeConn);

    //
    // Calculate the number of bytes needed for the EA buffer.
    // This may have the transport name.  For regular sessions, the user
    // name, password, and domain name are implicit.  For null sessions, we
    // must give 0-len user name, 0-len password, and 0-len domain name.
    //

    if (ARGUMENT_PRESENT(TransportName)) {

        UnicodeTransportName = TransportName;
        TransportNameSize = (USHORT) (wcslen(UnicodeTransportName) * sizeof(WCHAR));

        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameTransportNameSize + sizeof(CHAR) +
                            TransportNameSize,
                            ALIGN_DWORD
                            );
    }


    EaBufferSize += ((ULONG)FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]))+
                    EaNameTypeSize + sizeof(CHAR) +
                    TypeSize;


    //
    // Allocate the EA buffer
    //

    if ((EaBuffer = LocalAlloc(LMEM_FIXED, EaBufferSize )) == NULL) {
        ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Fill-in the EA buffer.
    //

    RtlZeroMemory(EaBuffer, EaBufferSize);

    Ea = EaBuffer;

    if (ARGUMENT_PRESENT(TransportName)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy(Ea->EaName, EA_NAME_TRANSPORT);
        Ea->EaNameLength = EaNameTransportNameSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        (VOID) wcscpy(
            (LPWSTR) &(Ea->EaName[EaNameTransportNameSize + sizeof(CHAR)]),
            UnicodeTransportName
            );

        Ea->EaValueLength = TransportNameSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameTransportNameSize + sizeof(CHAR) +
                                  TransportNameSize,
                                  ALIGN_DWORD
                                  );
        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }




    //
    // Copy the EA for the connection type name into EA buffer.  EA name length
    // does not include the zero terminator.
    //
    strcpy(Ea->EaName, EA_NAME_TYPE);
    Ea->EaNameLength = EaNameTypeSize;

    *((PULONG) &(Ea->EaName[EaNameTypeSize + sizeof(CHAR)])) = ConnectionType;

    Ea->EaValueLength = TypeSize;

    Ea->NextEntryOffset = 0;
    Ea->Flags = 0;

    // Set object attributes for the tree conn.
    InitializeObjectAttributes(
                & objattrTreeConn,                       // obj attr to init
                (LPVOID) & ucTreeConn,                   // string to use
                OBJ_CASE_INSENSITIVE,                    // Attributes
                NULL,                                    // Root directory
                SecurityDescriptor);                     // Security Descriptor


    //
    // Open a tree connection to the remote server.
    //
    ntstatus = NtCreateFile(
                &TreeConnHandle,                        // ptr to handle
                SYNCHRONIZE                              // desired...
                | GENERIC_READ | GENERIC_WRITE,          // ...access
                & objattrTreeConn,                       // name & attributes
                & iosb,                                  // I/O status block.
                NULL,                                    // alloc size.
                FILE_ATTRIBUTE_NORMAL,                   // (ignored)
                FILE_SHARE_READ | FILE_SHARE_WRITE,      // ...access
                FILE_OPEN_IF,                            // create disposition
                FILE_CREATE_TREE_CONNECTION              // create...
                | FILE_SYNCHRONOUS_IO_NONALERT,          // ...options
                EaBuffer,                                // EA buffer
                EaBufferSize );                          // Ea buffer size


    ApiStatus = RtlNtStatusToDosError(ntstatus);
    if (ntstatus == STATUS_SUCCESS) {
        // create drive letter 
        NETRESOURCE nr;
        DWORD result;

        nr.dwType = RESOURCETYPE_DISK;
        nr.lpLocalName = NULL; //drive;
        nr.lpRemoteName = TreeName;
        nr.lpProvider = NULL;

        if (DlBufSz != NULL)
            ApiStatus = WNetUseConnection(NULL, &nr, NULL, NULL, CONNECT_REDIRECT,
                                          DlBuf, DlBufSz, &result);
        else
            ApiStatus = WNetUseConnection(NULL, &nr, NULL, NULL, 0, NULL, 0, NULL);
    }


 Cleanup:

    // Clean up.
    if ( TreeConnHandle != NULL ) {
        ntstatus = NtClose(TreeConnHandle);
    }

    if ( pszTreeConn != NULL ) {
        LocalFree(pszTreeConn);
    }

    if (EaBuffer != NULL) {
        LocalFree(EaBuffer);
    }

    return ApiStatus;

}

#endif // ENABLE_SMB

#ifdef STANDALONE

__cdecl
main()
{
    DWORD err;
    WCHAR Drive[10];
    DWORD DriveSz;
    LPWSTR DiskList[FsMaxNodes];
    DWORD   DiskListSz, Nic;
    LPWSTR  Path, Share, Transport;
    LPWSTR  ResName = L"Majority Node Set";

    err = SetupStart(ResName, &Path, DiskList, &DiskListSz, &Nic, &Transport);
    if (err == ERROR_SUCCESS) {
    DWORD i;
    
    Share = wcschr(Path+2, L'\\');
    wprintf(L"Path is '%s'\n", Path);
    wprintf(L"Share is '%s'\n", Share);
    wprintf(L"Nic %d\n", Nic);
    wprintf(L"Transport '%s'\n", Transport);

    for (i = 1; i < FsMaxNodes; i++) {
        if (DiskList[i])
            wprintf(L"Disk%d: %s\n", i, DiskList[i]);
    }

    DriveSz = sizeof(Drive);
    err = SetupTree(Path, Drive, &DriveSz, Transport, NULL);
    if (err == ERROR_SUCCESS)
        wprintf(L"Drive %s\n", Drive);
    }
    printf("Err is %d\n",err);
    return err;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\fsutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsutil.c

Abstract:

    Implements interface to underlying filesystem

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <ntddvol.h>
#include <string.h>
#include <assert.h>

#include <malloc.h>

#include "fs.h"
#include "fsp.h"

#include "fsutil.h"
#include <strsafe.h>

#define XFS_ENUM_FIRST  0x1
#define XFS_ENUM_LAST   0x2
#define XFS_ENUM_DIR    0x4

typedef NTSTATUS (*PXFS_ENUM_CALLBACK)(PVOID,HANDLE,PFILE_DIRECTORY_INFORMATION);

NTSTATUS
xFsCreate(HANDLE *fd, HANDLE root, LPWSTR buf, int n, UINT32 flag,
          UINT32 attrib, UINT32 share, UINT32 *disp, UINT32 access,
          PVOID eabuf, int easz)
{

    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;

    n = n * sizeof(WCHAR);
    cwspath.Buffer = buf;
    cwspath.Length = (USHORT) n;
    cwspath.MaximumLength = (USHORT) n;

    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);

    // if write access is enabled, we turn on write-through bit
    if (access & FILE_WRITE_DATA) {
        flag |= FILE_WRITE_THROUGH;
    }

    *fd = INVALID_HANDLE_VALUE;
    status = NtCreateFile(fd,
                          SYNCHRONIZE |
                          access,
                          &objattrs, &iostatus,
                          0,
                          attrib,
                          share,
                          *disp,
                          FILE_SYNCHRONOUS_IO_ALERT | 
                          flag,
                          eabuf,
                          easz);


    *disp = (UINT32) iostatus.Information;

    if (NT_SUCCESS(status)) {
        status = STATUS_SUCCESS;
    }
    else {
        *fd = INVALID_HANDLE_VALUE;
    }
    
    return status;

}

NTSTATUS
xFsOpen(HANDLE *fd, HANDLE root, LPWSTR buf, int n, UINT32 access,
        UINT32 share, UINT32 flags)
{
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    IO_STATUS_BLOCK iostatus;

    n = n * sizeof(WCHAR);
    cwspath.Buffer = buf;
    cwspath.Length = (USHORT) n;
    cwspath.MaximumLength = (USHORT) n;
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);

    *fd = INVALID_HANDLE_VALUE;
    return  NtOpenFile(fd,
                        SYNCHRONIZE |
                        access,
                        &objattrs,
                        &iostatus,
                       share,
                       flags | FILE_SYNCHRONOUS_IO_ALERT);

}

NTSTATUS
xFsOpenEx(HANDLE *fd, HANDLE root, LPWSTR buf, int n, UINT32 access,
        UINT32 share, UINT32 flags)
{
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    IO_STATUS_BLOCK iostatus;

    n = n * sizeof(WCHAR);
    cwspath.Buffer = buf;
    cwspath.Length = (USHORT) n;
    cwspath.MaximumLength = (USHORT) n;
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);

    *fd = INVALID_HANDLE_VALUE;
    return  NtOpenFile(fd,
                        access,
                        &objattrs,
                        &iostatus,
                       share,
                       flags);

}

NTSTATUS
xFsDelete(HANDLE root, LPWSTR buf, int n)
{
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;

    n = n * sizeof(WCHAR);
    cwspath.Buffer = buf;
    cwspath.Length = (USHORT) n;
    cwspath.MaximumLength = (USHORT) n;
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);

    return NtDeleteFile(&objattrs);

}

NTSTATUS
xFsQueryObjectId(HANDLE fd, PVOID id)
{
    NTSTATUS status;
    IO_STATUS_BLOCK iostatus;
    fs_ea_t x;
    fs_ea_name_t name;

    FsInitEa(&x);
    FsInitEaName(&name);

    status = NtQueryEaFile(fd, &iostatus, 
                           (PVOID) &x, sizeof(x),
                           TRUE, (PVOID) &name, sizeof(name), 
                           NULL, TRUE);

    if (status == STATUS_SUCCESS) {
        fs_id_t *fid;
        
        if (iostatus.Information > sizeof(x.hdr)) {
            FsInitEaFid(&x, fid);
            memcpy(id, fid, sizeof(fs_id_t));
        } else {
            memset(id, 0, sizeof(fs_id_t));
        }
    } else {
        FsLog(("QueryEa failed %x\n", status));
    }

    return status;
}


NTSTATUS
xFsRename(HANDLE fh, HANDLE root, WCHAR *dname, int n)
{
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;
    struct {
        FILE_RENAME_INFORMATION x;
        WCHAR   buf[MAXPATH];
    }info;

    info.x.ReplaceIfExists = TRUE;
    info.x.RootDirectory = root;

    ASSERT(n == (int)wcslen(dname));
    // convert to unicode
    StringCchCopyW(info.x.FileName, MAXPATH, dname);
    info.x.FileNameLength = n * sizeof(WCHAR);

    status = NtSetInformationFile(fh, &iostatus, (PVOID) &info, sizeof(info),
                                FileRenameInformation);
    return status;
}

NTSTATUS
xFsSetAttr(HANDLE fd, FILE_BASIC_INFORMATION *attr)
{
    IO_STATUS_BLOCK iostatus;

    return NtSetInformationFile(fd, &iostatus, 
                               (PVOID) attr, sizeof(*attr),
                                FileBasicInformation);
}

NTSTATUS
xFsQueryAttr(HANDLE fd, FILE_NETWORK_OPEN_INFORMATION *attr)
{
    IO_STATUS_BLOCK iostatus;

    return NtQueryInformationFile(fd, &iostatus, 
                                  (PVOID)attr, sizeof(*attr),
                                  FileNetworkOpenInformation);
}

NTSTATUS
xFsQueryAttrName(HANDLE root, LPWSTR buf, int n, FILE_NETWORK_OPEN_INFORMATION *attr)
{
    NTSTATUS err;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;

    n = n * sizeof(WCHAR);
    cwspath.Buffer = buf;
    cwspath.Length = (USHORT) n;
    cwspath.MaximumLength = (USHORT) n;

    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);

    err = NtQueryFullAttributesFile(&objattrs, attr);

    return err;

}

NTSTATUS
xFsReadDir(HANDLE fd, PVOID buf, int *rlen, BOOLEAN flag)
{
    NTSTATUS err;
    IO_STATUS_BLOCK iostatus;
            
    err = NtQueryDirectoryFile(fd, NULL, NULL, NULL, &iostatus, 
                               (LPVOID) buf, *rlen >> 1,
                               FileDirectoryInformation, FALSE, NULL, 
                               flag);

    
    *rlen = (int) iostatus.Information;
    return err;
}

LPWSTR
xFsBuildRelativePath(VolInfo_t *vol, int nid, LPWSTR path)
{

    LPWSTR share, s=NULL;

    // Since the shares were opened using ipaddress, skip over the node name part.
    // share = wcschr(vol->DiskList[nid], L'\\');
    // share = wcschr(vol->DiskList[nid], L'\\');
    // FsLog(("xFsBuildRelativePath(%ws) root:%ws\n", path, vol->Root));
    share = vol->Root;
    if (share != NULL) {
        s = wcsstr(path, share);
        if (s != NULL) {
            s += (wcslen(share)+1);
            s = wcsstr(s, share);
            if (s != NULL) {
                s += (wcslen(share) + 1);
            }
        }
    }
    // FsLog(("xFsBuildRelativePath() returns %ws\n", s));
    return s;
}

NTSTATUS
_FsGetHandleById(HANDLE root, fs_id_t *id, UINT32 access, HANDLE *fhdl)
{

    NTSTATUS    err, status;
    int         sz;
    BOOLEAN     flag = TRUE;
    IO_STATUS_BLOCK ios;
    PVOID       buf;
    DWORD       bufsize;

    bufsize = PAGESIZE;
    buf = (PVOID) VirtualAlloc(NULL, bufsize, MEM_COMMIT, PAGE_READWRITE);
    if (buf == NULL) {
        return STATUS_NO_MEMORY;
    }

    status = STATUS_OBJECT_PATH_NOT_FOUND;
    while (TRUE) {
        PFILE_DIRECTORY_INFORMATION p;

        err = NtQueryDirectoryFile(root, NULL, NULL, NULL, &ios,
                                   (LPVOID) buf, bufsize,
                                   FileDirectoryInformation, FALSE, NULL, 
                                   flag);

        sz = (int) ios.Information;

        if (err != STATUS_SUCCESS) {
//          FsLogError(("ReadDir failed %x flags %d\n", err, flag));
            break;
        }

        flag = FALSE;

        p = (PFILE_DIRECTORY_INFORMATION) buf;
        while (TRUE) {
            // open each entry and get its object id
            HANDLE fd;
            OBJECT_ATTRIBUTES objattrs;
            UNICODE_STRING  cwspath;

            cwspath.Buffer = p->FileName;
            cwspath.Length = (USHORT) p->FileNameLength;
            cwspath.MaximumLength = (USHORT) p->FileNameLength;

            InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                                       root, NULL);

            // todo: what if the file is nonsharable @ this time?
            err = NtOpenFile(&fd,
                             SYNCHRONIZE | 
                             ((p->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ?
                              (FILE_GENERIC_READ | FILE_GENERIC_EXECUTE) : (access)),
                             &objattrs,
                             &ios,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_SYNCHRONOUS_IO_ALERT);

            if (err == STATUS_SUCCESS) {
                fs_id_t fid;
                err = xFsQueryObjectId(fd, (PVOID)fid);
                if (err == STATUS_SUCCESS) {
#ifdef DEBUG
                    wprintf(L"Compare file %wZ, %I64x:%I64x with %I64x:%I64x\n",
                            &cwspath, fid[0], fid[1], (*id)[0], (*id)[1]);
#endif
                    if (fid[0] == (*id)[0] && fid[1] == (*id)[1]) {
#ifdef DEBUG
                        wprintf(L"Found file %wZ, %I64x:%I64x\n",
                                &cwspath, fid[0], fid[1]);
#endif

                        status = STATUS_SUCCESS;
#if 0
                        if (access != FILE_GENERIC_READ) {
                            HANDLE nfd;

                            xFsClose(fd);

                            err = NtOpenFile(&nfd,
                                             SYNCHRONIZE | access,
                                             &objattrs,
                                             &ios,
                                             FILE_SHARE_READ,
                                             FILE_SYNCHRONOUS_IO_ALERT);

                            if (err == STATUS_SUCCESS) {
                                fd = nfd;
                            } else {
                                fd = 0;
                            }
                        }
#endif
                        *fhdl = fd;
                    } else if (p->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        status = _FsGetHandleById(fd, id, access, fhdl);
                        xFsClose(fd);
                        fd = 0;
                    }
                } else {
                    FsLog(("_GetHandleById: query '%wZ' err 0x%x\n", &cwspath, err));
                }
                if (status == STATUS_SUCCESS) {
                    goto done;
                }

                if (fd)
                    xFsClose(fd);
            } else {
                if (err == STATUS_SHARING_VIOLATION) {
                    status = err;
                    FsLog(("_GetHandleById: open '%wZ' err 0x%x\n", &cwspath, err));
                    break;
                }
            }

            if (p->NextEntryOffset == 0)
                break;

            p = (PFILE_DIRECTORY_INFORMATION) (((PBYTE)p) + p->NextEntryOffset);
        }
    }
 done:
    VirtualFree(buf, 0, MEM_RELEASE);

    return status;
}

NTSTATUS
xFsGetHandleById(HANDLE root, fs_id_t *id, UINT32 access, HANDLE *fhdl)
{
    // open each entry and get its object id
    HANDLE fd;
    NTSTATUS err;

    err = NtDuplicateObject(NtCurrentProcess(),
                            root,
                            NtCurrentProcess(),
                            &fd,
                            (ACCESS_MASK)0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS);


    if (err != STATUS_SUCCESS) {
        FsLogError(("Unable to duplicate root handle %x\n", err));
        return err;
    }

    err = _FsGetHandleById(fd, id, access, fhdl);

    xFsClose(fd);

    return err;

}

DWORD
xFsGetHandlePath(HANDLE fd, WCHAR *path, int *pathlen)
{

    NTSTATUS status;
    IO_STATUS_BLOCK iostatus;
    int orig_len=*pathlen;
    struct {
        FILE_NAME_INFORMATION x;
        WCHAR   buf[MAXPATH];
    }info;

    *path = L'\0';
    *pathlen = 0;

    status = NtQueryInformationFile(fd, &iostatus,
                                    (LPVOID) &info, sizeof(info),
                                    FileNameInformation);

    if (status == STATUS_SUCCESS) {
        int k = info.x.FileNameLength / sizeof(WCHAR);
        info.x.FileName[k] = L'\0';
        StringCbCopyW(path, orig_len, info.x.FileName);
        *pathlen = k;
    }
    return status;
}

NTSTATUS
xFsGetPathById(HANDLE vfd, fs_id_t *id, WCHAR *name, int *name_len)
{
    NTSTATUS    err;
    HANDLE      fd;

    err = xFsGetHandleById(vfd, id, FILE_READ_EA, &fd);
    if (err == STATUS_SUCCESS) {
        err = xFsGetHandlePath(fd, name, name_len);
        xFsClose(fd);
    }

    return err;
}


NTSTATUS
_xFsEnumTree(HANDLE hdl, int mode, PXFS_ENUM_CALLBACK callback, PVOID callback_arg)
{
    NTSTATUS err = STATUS_SUCCESS;
    IO_STATUS_BLOCK ios;
    BOOLEAN flag;
    PVOID       buf;
    DWORD       bufsize;

    bufsize = PAGESIZE;
    buf = (PVOID) VirtualAlloc(NULL, bufsize, MEM_COMMIT, PAGE_READWRITE);
    if (buf == NULL) {
        return STATUS_NO_MEMORY;
    }

    flag = TRUE;
    while (err == STATUS_SUCCESS) {
        PFILE_DIRECTORY_INFORMATION p;

        p = (PFILE_DIRECTORY_INFORMATION) buf;

        err = NtQueryDirectoryFile(hdl, NULL, NULL, NULL, &ios,
                                   (LPVOID) buf, bufsize,
                                   FileDirectoryInformation, FALSE, NULL, flag);

        if (err != STATUS_SUCCESS) {
            break;
        }
        flag = FALSE;

        while (err == STATUS_SUCCESS) {
            BOOLEAN     skip = FALSE;

            if (p->FileNameLength == 2 && p->FileName[0] == L'.' ||
                (p->FileNameLength == 4 && p->FileName[0] == L'.' && p->FileName[1] == L'.'))
                skip = TRUE;

            // skip . and ..
            if (skip == FALSE) {
                // traverse before
                if (mode & XFS_ENUM_FIRST) {
                    err = callback(callback_arg, hdl, p);
                }

                if ((mode & XFS_ENUM_DIR) && (p->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    HANDLE fd;
                    OBJECT_ATTRIBUTES objattrs;
                    UNICODE_STRING  cwspath;


                    cwspath.Buffer = p->FileName;
                    cwspath.Length = (USHORT) p->FileNameLength;
                    cwspath.MaximumLength = (USHORT) p->FileNameLength;

                    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                                               hdl, NULL);

                    // todo: what if the dir is nonsharable @ this time?
                    err = NtOpenFile(&fd,
                                     SYNCHRONIZE | FILE_GENERIC_READ | FILE_GENERIC_EXECUTE,
                                     &objattrs,
                                     &ios,
                                     FILE_SHARE_READ,
                                     FILE_SYNCHRONOUS_IO_ALERT);

                    if (err == STATUS_SUCCESS) {
                        err = _xFsEnumTree(fd, mode, callback, callback_arg);
                        NtClose(fd);
                    } else {
                        FsLog(("Open failed on traverse dir %S %x\n", p->FileName, err));
                    }
                }

                // traverse after
                if (mode & XFS_ENUM_LAST) {
                    err = callback(callback_arg, hdl, p);
                }
            }

            if (p->NextEntryOffset == 0)
                break;

            p = (PFILE_DIRECTORY_INFORMATION) (((PBYTE)p) + p->NextEntryOffset);
        }
    }

    VirtualFree(buf, 0, MEM_RELEASE);

    if (err == STATUS_NO_MORE_FILES)
        err = STATUS_SUCCESS;
    return err;

}

NTSTATUS
xFsRemove(PVOID arg, HANDLE root, PFILE_DIRECTORY_INFORMATION item)
{
    NTSTATUS err;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;

    cwspath.Buffer = item->FileName;
    cwspath.Length = (USHORT) item->FileNameLength;
    cwspath.MaximumLength = (USHORT) item->FileNameLength;
    
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);


    // if the file is marked read-only, we have to clear it first before we delete
    if (item->FileAttributes & FILE_ATTRIBUTE_READONLY) {
        // clear this bit in order to delete
        HANDLE  fd;
        IO_STATUS_BLOCK iostatus;

        err = NtOpenFile(&fd,
                         SYNCHRONIZE | (STANDARD_RIGHTS_WRITE | FILE_WRITE_ATTRIBUTES),
                         &objattrs,
                         &iostatus,
                         FILE_SHARE_READ,
                         FILE_SYNCHRONOUS_IO_ALERT);

        if (err == STATUS_SUCCESS) {
            FILE_BASIC_INFORMATION attr;

            memset((PVOID) &attr, 0, sizeof(attr));
            attr.FileAttributes = item->FileAttributes & ~FILE_ATTRIBUTE_READONLY;

            err = NtSetInformationFile(fd, &iostatus,
                                       (PVOID) &attr, sizeof(attr),
                                       FileBasicInformation);
            xFsClose(fd);
        }
    }


    err = NtDeleteFile(&objattrs);

    FsLog(("xFsRemove: '%wZ' err 0x%x\n", &cwspath, err));
    // The code below is an infinite loop.
    // while (err == STATUS_SHARING_VIOLATION) {
    //     Sleep(5*10000);
    // }
    return err;
}

NTSTATUS
xFsCopy(PVOID arg, HANDLE root, PFILE_DIRECTORY_INFORMATION item)
{
    WCHAR *name = item->FileName;
    int name_len = item->FileNameLength / sizeof(WCHAR);
    NTSTATUS err;

    err = xFsDupFile(root, (HANDLE) arg, name, name_len, TRUE);

    return err;
}

// copy all files from mvfd to vfd.
NTSTATUS
xFsCopyTree(HANDLE mvfd, HANDLE vfd)
{
    NTSTATUS err;

    // first, remove all files in vfd
    FsLog(("CopyTree: remove first\n"));
    err = _xFsEnumTree(vfd, XFS_ENUM_LAST|XFS_ENUM_DIR, xFsRemove, NULL);

    // copy files
    if (err == STATUS_SUCCESS) {
        FsLog(("CopyTree: copy second\n"));
        err = _xFsEnumTree(mvfd, XFS_ENUM_FIRST, xFsCopy, (PVOID) vfd);
    }

    FsLog(("CopyTree: exit %x\n", err));

    return err;
}

// delete all files 
NTSTATUS
xFsDeleteTree(HANDLE vfd)
{

    // remove all files in vfd
    return _xFsEnumTree(vfd, XFS_ENUM_LAST|XFS_ENUM_DIR, xFsRemove, NULL);

}

NTSTATUS
xFsTouch(PVOID arg, HANDLE root, PFILE_DIRECTORY_INFORMATION item)
{
    NTSTATUS err=STATUS_SUCCESS;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    HANDLE      fd;
    IO_STATUS_BLOCK iostatus;
    DWORD cnt = 0;

    cwspath.Buffer = item->FileName;
    cwspath.Length = (USHORT) item->FileNameLength;
    cwspath.MaximumLength = (USHORT) item->FileNameLength;
    
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               root, NULL);


    do {
        err = NtOpenFile(&fd,
                         SYNCHRONIZE | FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                         &objattrs,
                         &iostatus,
                         FILE_SHARE_READ,
                         FILE_SYNCHRONOUS_IO_ALERT);

        if (err == STATUS_SUCCESS) {
        NtClose(fd);
    } else {
            FsLogError(("xFsTouch: open '%wZ' failed 0x%x\n", &cwspath, err));
            if (err == STATUS_SHARING_VIOLATION || err == STATUS_DELETE_PENDING) {
                Sleep(5*1000);
                cnt++;
            }
        }
    } while ((err == STATUS_SHARING_VIOLATION ||
              err == STATUS_DELETE_PENDING) && cnt < 1000);

    return err;
}

// touch each file
NTSTATUS
xFsTouchTree(HANDLE mvfd)
{

    return _xFsEnumTree(mvfd, XFS_ENUM_LAST | XFS_ENUM_DIR, xFsTouch, NULL);
}


NTSTATUS
xFsDupFile(HANDLE mvfd, HANDLE vfd, WCHAR *name, int name_len, BOOLEAN flag)
{
    NTSTATUS err;
    HANDLE mfd, fd;
    IO_STATUS_BLOCK ios;
    fs_id_t     *fs_id;
    fs_ea_t xattr;
    FILE_NETWORK_OPEN_INFORMATION       attr;
    FILE_BASIC_INFORMATION      new_attr;
    char        buf[PAGESIZE];

    // Create file on vfd with same name and attrib and extended attributes (object id)
    // If we created a directory, we are done.
    // Otherwise, copy all data from source file to new file


    // Open master file
    err = xFsOpenRD(&mfd, mvfd, name, name_len); 
    if (err != STATUS_SUCCESS) {
        // We couldn't open source file. If file is locked we have to use the handle we
        // already have. todo:
        FsLog(("FsDupFile: unable to open source '%.*ls' err %x\n", name_len/sizeof(WCHAR), name, err));
        return err;
    }

    // Query name on mvfd and obtain all attributes.
    err = xFsQueryAttr(mfd, &attr);
    if (err != STATUS_SUCCESS) {
        FsLog(("FsDupFile: unable to query source '%.*ls' err %x\n", name_len/sizeof(WCHAR), name, err));
        xFsClose(mfd);
        return err;
    }

    // get objectid and set the ea stuff
    FsInitEa(&xattr);
    FsInitEaFid(&xattr, fs_id);

    err = xFsQueryObjectId(mfd, (PVOID) fs_id);
    if (err == STATUS_SUCCESS) {
        UINT32 disp = FILE_CREATE;

        err = xFsCreate(&fd, vfd, name, name_len,
                        (attr.FileAttributes & FILE_ATTRIBUTE_DIRECTORY ? 
                         FILE_DIRECTORY_FILE : 0),
                        attr.FileAttributes,
                        FILE_SHARE_READ,
                        &disp,
                        FILE_GENERIC_EXECUTE | FILE_GENERIC_WRITE,
                        (PVOID) &xattr,
                        sizeof(xattr));

        if (err == STATUS_SUCCESS) {
            assert(disp == FILE_CREATED);

            // if file we need to copy data and set access flags
            if (!(attr.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                int buflen = sizeof(buf);
                LARGE_INTEGER off;

                off.LowPart = 0;
                off.HighPart = 0;
                while (1) {
                    err = NtReadFile(mfd, NULL, NULL, NULL, &ios, buf, buflen, &off, NULL);
                    if (err == STATUS_PENDING) {
                        EventWait(mfd);
                        err = ios.Status;
                    }
                    if (err != STATUS_SUCCESS) {
                        break;
                    }
                    err = NtWriteFile(fd, NULL, NULL, NULL, &ios, buf, (ULONG)ios.Information,
                                      &off, NULL);
                    if (err == STATUS_PENDING) {
                        EventWait(fd);
                        err = ios.Status;
                    }
                    
                    if (err != STATUS_SUCCESS) {
                        break;
                    }
                    off.LowPart += (ULONG) ios.Information;
                }

                // adjust return code
                if (err == STATUS_END_OF_FILE) {
                    err = STATUS_SUCCESS;
                }

                FsLog(("FsDupFile: '%.*ls' err %x\n", name_len/sizeof(WCHAR), name, err));
            } else if (flag == TRUE) {
                // call enum again
                err = _xFsEnumTree(mfd, XFS_ENUM_FIRST, xFsCopy, (PVOID) fd);
            }

            // set new file attributes
            new_attr.CreationTime = attr.CreationTime;
            new_attr.LastAccessTime = attr.LastAccessTime;
            new_attr.LastWriteTime = attr.LastWriteTime;
            new_attr.ChangeTime = attr.ChangeTime;
            new_attr.FileAttributes = attr.FileAttributes;
            err = xFsSetAttr(fd, &new_attr);

            // close new file
            xFsClose(fd);

        }
        if (err != STATUS_SUCCESS)
            FsLog(("FsDupFile: unable to open/reset attr '%S' err %x\n", name, err));
    } else {
        FsLog(("FsDupFile: unable to query sid '%S' err %x, skip!\n", name, err));
        err = STATUS_SUCCESS;
    }

    // close master file
    xFsClose(mfd);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\pipe.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pipe.c

Abstract:

    Implements initialization and pipe interface for rudimentary quorum access server

Author:

    Gor Nishanov (gorn) 20-Sep-2001

Revision History:

--*/

#define UNICODE 1

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include "fs.h"
#include "pipe.h"
#include "QfsTrans.h"
#include "clusrtl.h"

typedef struct _PIPECTX_ {
    CRITICAL_SECTION	cs;
    LUID      me;

    USHORT uid;
    USHORT tid;
    PVOID user;
    FsDispatchTable *pDisp;
    LPWSTR share;
    
    PVOID	FsCtx;
    PVOID	resHdl;

    int		nThreads;
    HANDLE*	hThreads;

    SHARED_MEM_SERVER MemServer;
    LONG NeedsCleanup;
} PipeCtx_t;
typedef DWORD (*PipeDispatch_t)(PipeCtx_t* ctx, JobBuf_t* job);

// QFSP_INSERT_OP_NAMES defined in QfsTrans
// it is used here to generate human readable
// operation names

#define OPNAME(Name) "op"  #Name,
char* OpNames[] = {
    QFSP_INSERT_OP_NAMES
};
#undef OPNAME

// QFSP_INSERT_OP_NAMES defined in QfsTrans
// it is used here to generate forward declarations of operation handlers

#define OPNAME(Name) extern DWORD Qfsp ## Name(PipeCtx_t* ctx, JobBuf_t* job);
    QFSP_INSERT_OP_NAMES
#undef OPNAME

// QFSP_INSERT_OP_NAMES defined in QfsTrans
// it is used here to generate array of operation handlers

#define OPNAME(Name) Qfsp ## Name,
PipeDispatch_t OpDispatch[] =
{
    QFSP_INSERT_OP_NAMES
};
#undef OPNAME

#define LogError(_x_)   EPRINT(_x_)
#define Log(_x_)   DPRINT(_x_)

#undef malloc
#undef free

#define malloc(dwBytes) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes)
#define free(hHeap) HeapFree(GetProcessHeap(), 0, hHeap)


    
DWORD
PipeInit(PVOID resHdl, PVOID fsHdl, PVOID *Hdl)
{
    PipeCtx_t *ctx;
    DWORD err;

    ctx = (PipeCtx_t *) malloc(sizeof(*ctx));
    if (ctx == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(ctx, 0, sizeof(*ctx));

    if (!AllocateLocallyUniqueId(&ctx->me)) {
        free(ctx);
        LogError(("PipeInit, failed to allocate LUID, error %d\n", GetLastError()));
        return GetLastError();
    }

    ctx->FsCtx = fsHdl;
    ctx->resHdl = resHdl;

    InitializeCriticalSection(&ctx->cs);

    *Hdl = (PVOID) ctx;
    return ERROR_SUCCESS;
}

void
PipeExit(PVOID Hdl)
{
    PipeCtx_t *ctx = (PipeCtx_t *) Hdl;

    if (ctx != NULL) {
        DeleteCriticalSection(&ctx->cs);
        free(ctx);
    }
}

VOID MemServer_Dispatch(PJOB_BUF buf, PVOID Hdl)
{
    PipeCtx_t *ctx = (PipeCtx_t *) Hdl;
    if (buf->hdr.OpCode >= OpCount) {
        LogError(("bad opcode %d\n", buf->hdr.OpCode));
        buf->hdr.Status = ERROR_INVALID_FUNCTION;
    } else {
        Log(("enter %s... \n", OpNames[buf->hdr.OpCode]));
        buf->hdr.Status = OpDispatch[buf->hdr.OpCode](ctx, buf);
        Log(("exit %s => %d\n", OpNames[buf->hdr.OpCode], buf->hdr.Status));
        buf->hdr.OpCode = opNone;
    }
}

#define NUM_BUFFERS 8


DWORD PipeOnline(PVOID Hdl, LPWSTR Path)
{
    PipeCtx_t *ctx = (PipeCtx_t *) Hdl;
    int nThreads = 0;
    int i;
    WCHAR* lastSlash = wcsrchr(Path, '\\');
    DWORD Status = ERROR_SUCCESS;

    ctx->share = Path;
    
    if (lastSlash) {
    	 Path = lastSlash+1;
    }

    Log(("PipeOnline. Path \"%ws\" Share \"%ws\"\n", ctx->share, Path));

    FsLogonUser(ctx->FsCtx, NULL, ctx->me, &ctx->uid);
    FsMount(ctx->FsCtx, Path, ctx->uid, &ctx->tid);
    ctx->pDisp = FsGetHandle(ctx->FsCtx, ctx->tid, ctx->uid, &ctx->user);

    if (!ctx->pDisp) {
        return ERROR_FILE_NOT_FOUND;
    }
    
    // This should be done after registering with FS.
    Status = MemServer_Online(
        &ctx->MemServer, NUM_BUFFERS,
        MemServer_Dispatch, Hdl);
    
    if (Status != ERROR_SUCCESS) {
        FsDisMount(ctx->FsCtx, ctx->uid, ctx->tid);
        FsLogoffUser(ctx->FsCtx, ctx->me);
        return Status;
    }

    ctx->NeedsCleanup = TRUE;
    return ERROR_SUCCESS;
}

DWORD PipeOffline(PVOID Hdl)
{
    PipeCtx_t *ctx = (PipeCtx_t *) Hdl;
    if (InterlockedExchange(&ctx->NeedsCleanup, FALSE) == TRUE) {
        MemServer_Offline(&ctx->MemServer);
        FsDisMount(ctx->FsCtx, ctx->uid, ctx->tid);
        FsLogoffUser(ctx->FsCtx, ctx->me);
    }
    return ERROR_SUCCESS;
}

#define QfsHandleToWin32Handle(hdl) ((HANDLE)(hdl))
USHORT Win32HandleToQfsHandle(HANDLE hFile)
{
    ULONG_PTR u = (ULONG_PTR)hFile;
    if (u > 0xffff) {
        LogError(("pipe: Invalid Win32 handle passed 0x%x\n", u));
        return INVALID_FHANDLE_T;
    } 
    return (USHORT) (u);
}

/////////////////////////////////////////////////////////////
// operation handler routines 
//   given a JobBuf calls appropriate Fs routines
/////////////////////////////////////////////////////////////

DWORD QfspCreateFile(
  PipeCtx_t *ctx,
  JobBuf_t* j)
{
    DWORD error;
    DWORD flags = 0;
    fattr_t attr;
    fhandle_t hdl;
    
    ZeroMemory(&attr, sizeof(attr));

    if (j->dwFlagsAndAttributes & FILE_ATTRIBUTE_READONLY) attr.attributes |= ATTR_READONLY;
    if (j->dwFlagsAndAttributes & FILE_ATTRIBUTE_HIDDEN)     attr.attributes |= ATTR_HIDDEN;
    if (j->dwFlagsAndAttributes & FILE_ATTRIBUTE_SYSTEM)     attr.attributes |= ATTR_SYSTEM;
    if (j->dwFlagsAndAttributes & FILE_ATTRIBUTE_ARCHIVE)   attr.attributes |= ATTR_ARCHIVE;
    if (j->dwFlagsAndAttributes & FILE_ATTRIBUTE_DIRECTORY) attr.attributes |= ATTR_DIRECTORY;
    if (j->dwFlagsAndAttributes & FILE_ATTRIBUTE_COMPRESSED) attr.attributes |= ATTR_COMPRESSED;
    if (j->dwFlagsAndAttributes & FILE_ATTRIBUTE_OFFLINE) attr.attributes |= ATTR_OFFLINE;
    
    if (j->dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING)    flags |= CACHE_NO_BUFFERING;
    if (j->dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH) flags |= CACHE_WRITE_THROUGH;
    
    switch (j->dwCreationDisposition) {
        case CREATE_NEW:  flags |= DISP_CREATE_NEW; break;
        case CREATE_ALWAYS:  flags |= DISP_CREATE_ALWAYS; break;
        case OPEN_EXISTING: flags |= DISP_OPEN_EXISTING; break;
        case OPEN_ALWAYS:     flags |= DISP_OPEN_ALWAYS; break;
        case TRUNCATE_EXISTING: flags |= DISP_TRUNCATE_EXISTING; break;
    }
    if(j->dwShareMode & FILE_SHARE_READ) flags |= SHARE_READ;
    if(j->dwShareMode & FILE_SHARE_WRITE) flags |= SHARE_WRITE;
    if(j->dwDesiredAccess & GENERIC_READ)   flags |= ACCESS_READ;
    if(j->dwDesiredAccess & GENERIC_WRITE) flags |= ACCESS_WRITE;

    LogError(("Flags %x\n", flags));

    error = ctx->pDisp->FsCreate(
        ctx->user,
        j->FileName,
        (USHORT)wcslen(j->FileName),
        flags, 
        &attr, 
        &hdl,
        &j->dwCreationDisposition);

    if (error != ERROR_SUCCESS) {
        j->Handle = INVALID_HANDLE_VALUE;
    } else {
        j->Handle = QfsHandleToWin32Handle(hdl);
        *FsGetFilePointerFromHandle(ctx->user, hdl) = 0;
        switch (j->dwCreationDisposition & 0x7) {
            case FILE_CREATE: j->dwCreationDisposition = CREATE_NEW; break;
            case FILE_OPEN: j->dwCreationDisposition = OPEN_EXISTING; break;
            default: j->dwCreationDisposition = 0;
        }
    }

    return error;
}

DWORD QfspCloseFile(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    return ctx->pDisp->FsClose(ctx->user, Win32HandleToQfsHandle(j->Handle));
}

DWORD QfspNone(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    return ERROR_SUCCESS;
}

DWORD QfspReadFile(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    DWORD Status;
    fhandle_t hdl = Win32HandleToQfsHandle(j->Handle);
    if(j->Offset == (ULONGLONG)-1) {
        j->Offset = *FsGetFilePointerFromHandle(ctx->user, hdl);
    }
    Status = ctx->pDisp->FsRead(
        ctx->user,
        hdl, 
        (UINT32)j->Offset, 
        &j->cbSize, 
        j->Buffer,
        NULL);
    if (Status == ERROR_SUCCESS) {
        j->Offset += j->cbSize;
        *FsGetFilePointerFromHandle(ctx->user, hdl) = (UINT32)j->Offset;
    }
    return Status;
}

DWORD QfspWriteFile(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    DWORD Status;
    fhandle_t hdl = Win32HandleToQfsHandle(j->Handle);
    if(j->Offset == ~0) {
        j->Offset = *FsGetFilePointerFromHandle(ctx->user, hdl);
    }
    Status = ctx->pDisp->FsWrite(
        ctx->user,
        hdl, 
        (UINT32)j->Offset, 
        &j->cbSize, 
        j->Buffer,
        NULL);
    if (Status == ERROR_SUCCESS) {
        j->Offset += j->cbSize;
        *FsGetFilePointerFromHandle(ctx->user, hdl) = (UINT32)j->Offset;
    }
    return Status;
}

DWORD QfspFlushFile(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    return ctx->pDisp->FsFlush(
        ctx->user,
        Win32HandleToQfsHandle(j->Handle));
}

DWORD QfspDeleteFile(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    return ctx->pDisp->FsRemove(
        ctx->user,
        j->FileName,
        (USHORT)wcslen(j->FileName) );
}

DWORD QfspCreateDir(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    return ctx->pDisp->FsMkdir(
        ctx->user,
        j->FileName,
        (USHORT)wcslen(j->FileName), 
        NULL );
}

// Dir stuff has to be improved
// Currently it is as bad as original srvcom stuff

DWORD QfspFindFirstFile(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    DWORD cbDirSize = wcslen(j->FileName);
    DWORD Status;
    DWORD len;
    Status = ctx->pDisp->FsGetRoot(ctx->user, j->FileNameDest);
    if (Status != ERROR_SUCCESS) {
        return Status;
    }
    len = wcslen(j->FileNameDest);
    
    if (j->FileName[0] != 0 && j->FileName[0] != '\\' && len > 0 && j->FileNameDest[len-1] != '\\') {
        j->FileNameDest[len] = '\\';
        ++len;
    }
    
    CopyMemory(j->FileNameDest+len, j->FileName, sizeof(WCHAR) * (cbDirSize+1));
    
    j->Handle = FindFirstFileW(j->FileNameDest, &j->FindFileData);
    if (j->Handle == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
    }

    Log(("QfspFindFirstFile path %ws, hdl %x status %d\n", j->FileNameDest, j->Handle, Status));
    return Status;
}

DWORD QfspFindNextFile(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    DWORD Status;
    if( FindNextFile(j->Handle, &j->FindFileData) ) {
        Status = ERROR_SUCCESS;
    } else {
        Status = GetLastError();
    }

    Log(("QfspFindNextFile, status %d\n", Status));
    return Status;
}

DWORD QfspFindClose(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    if( FindClose(j->Handle) ) {
        return ERROR_SUCCESS;
    } else {
        return GetLastError();
    }
}

DWORD QfspGetDiskFreeSpace(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    fs_attr_t fsinfo;
    DWORD Status = ctx->pDisp->FsStatfs(ctx->user, &fsinfo);
    if (Status == ERROR_SUCCESS) {
        ULONGLONG bpu = fsinfo.bytes_per_sector * fsinfo.sectors_per_unit; 

        j->TotalNumberOfFreeBytes =  // don't understand quotas    
        j->FreeBytesAvailable = fsinfo.free_units * bpu;
        j->TotalNumberOfBytes = fsinfo.total_units * bpu;
    }
    return Status;
}

DWORD QfspGetAttr(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    fattr_t finfo;
    DWORD Status = ctx->pDisp->FsGetAttr(ctx->user, Win32HandleToQfsHandle(j->Handle), &finfo);
    if (Status == ERROR_SUCCESS) {
        j->EndOfFile = finfo.file_size;
        j->AllocationSize = finfo.alloc_size;
        j->CreationTime = finfo.create_time;
        j->LastAccessTime = finfo.access_time;
        j->LastWriteTime = finfo.mod_time;
        j->FileAttributes = finfo.attributes;
    }
    return Status;
}

DWORD QfspSetAttr2(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    fattr_t finfo;
    extern UINT32 get_attributes(DWORD a);

    finfo.file_size = j->EndOfFile;
    finfo.alloc_size = j->AllocationSize;
    finfo.create_time = j->CreationTime;
    finfo.access_time = j->LastAccessTime;
    finfo.mod_time = j->LastWriteTime;
    finfo.attributes = get_attributes(j->FileAttributes);
    
    return ctx->pDisp->FsSetAttr2(ctx->user, j->FileName, (USHORT)wcslen(j->FileName), &finfo);
}

DWORD QfspRename(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    return ctx->pDisp->FsRename(
        ctx->user,
        j->FileName,
        (USHORT)wcslen(j->FileName), 
        j->FileNameDest,
        (USHORT)wcslen(j->FileNameDest) );
}

DWORD QfspConnect(
    PipeCtx_t *ctx,
    JobBuf_t* j)
{
    DWORD Status;
    PWCHAR p = ctx->share;
    if (*p == '\\' && *++p == '\\') ++p;
    if( wcsncmp(p, j->FileName, wcslen(p)) == 0 ) {
        Status = ctx->pDisp->FsConnect(ctx->user, j->ClussvcProcessId);
    } else {
        // This is the correct return value.
        Status = ERROR_NO_MATCH;
    }
    Log(("[Qfs] Connect %ws => %d\n", j->FileName, Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\util.h ===
#ifndef _X_FS_H
#define _X_FS_H

extern 
char *
char *
BuildRelativePath(VolInfo *vol, int nid, char *path);

NTSTATUS
FsGetHandleById(HANDLE root, fs_id_t *id, UINT32 access, HANDLE *fhdl);

DWORD
FsGetHandlePath(HANDLE fd, char *path, int *pathlen);

NTSTATUS
FsGetPathById(HANDLE vfd, fs_id_t *id, char *name, int *name_len);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\undo.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    undo.c

Abstract:

    Implements undo of records during replica recovery

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <stdio.h>
#include <ntddvol.h>
#include <string.h>
#include <assert.h>

#include "fs.h"
#include "fsp.h"
#include "fsutil.h"

NTSTATUS
fs_undo_create(VolInfo_t *volinfo,
                 fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    WCHAR name[MAXPATH];
    int name_len = sizeof(name);

    name[0] = '\0';

    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    FsLogUndo(("fs_undo_create: try %I64x:%I64x\n",
                  lrec->id[0], lrec->id[1]));

    err = xFsGetPathById(vfd, &lrec->id, name, &name_len);

    if (err == STATUS_SUCCESS) {
        int relative_name_len;
        LPWSTR relative_name;

        relative_name = xFsBuildRelativePath(volinfo, nid, name);
        relative_name_len = wcslen(relative_name);

        err = xFsDelete(vfd, relative_name, relative_name_len);
    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
        // if we can't find file in the master disk, the file/dir
        // must have already been delete. Just return success, since
        // we are trying to remove this file anyway.
        err = STATUS_SUCCESS;
    }


    FsLogUndo(("fs_undo_create: status %x\n", err));

    return err;
}


NTSTATUS
fs_undo_setattr(VolInfo_t *volinfo,
                fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE mvfd = FS_GET_VOL_HANDLE(volinfo, mid);
    WCHAR       name[MAXPATH];
    int         name_len=sizeof(name);
    

    name[0] = '\0';

    FsLogUndo(("fs_undo_setattr: try %I64x:%I64x\n",
                  lrec->fs_id[0], lrec->fs_id[1]));

    err = xFsGetPathById(mvfd, &lrec->fs_id, name, &name_len);

    if (err == STATUS_SUCCESS) {
        int relative_name_len;
        LPWSTR relative_name;
        HANDLE fd;
        FILE_NETWORK_OPEN_INFORMATION attr;
        FILE_BASIC_INFORMATION new_attr;

        // build relative name and get current attribute from
        // master disk and apply it to 'nid' disk
        relative_name = xFsBuildRelativePath(volinfo, mid, name);
        relative_name_len = wcslen(relative_name);

        err = xFsQueryAttrName(mvfd, relative_name, relative_name_len,
                               &attr);

        if (err == STATUS_SUCCESS) {
            // we now apply attribute to nid disk
            err = xFsOpenWA(&fd, vfd, relative_name, relative_name_len);
            if (err == STATUS_SUCCESS) {

                new_attr.CreationTime = attr.CreationTime;
                new_attr.LastAccessTime = attr.LastAccessTime;
                new_attr.LastWriteTime = attr.LastWriteTime;
                new_attr.ChangeTime = attr.ChangeTime;
                new_attr.FileAttributes = attr.FileAttributes;
                err = xFsSetAttr(fd, &new_attr);
                xFsClose(fd);
            }
        }

    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
        // if we can't find file in the master disk, the file/dir
        // must have already been delete. Just return success, since
        // we will get to remove this dir/file anyway during the
        // replay phase
        err = STATUS_SUCCESS;
    }

    FsLogUndo(("fs_undo_setattr: status %x\n", err));

    return err;
}

NTSTATUS
fs_undo_mkdir(VolInfo_t *volinfo,
                 fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    WCHAR name[MAXPATH];
    int name_len=sizeof(name);

    name[0] = '\0';

    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    FsLogUndo(("fs_undo_mkdir: try %I64x:%I64x\n",
                  lrec->id[0], lrec->id[1]));

    err = xFsGetPathById(vfd, &lrec->id, name, &name_len);

    if (err == STATUS_SUCCESS) {
        int relative_name_len;
        WCHAR *relative_name;

        relative_name = xFsBuildRelativePath(volinfo, nid, name);
        relative_name_len = wcslen(relative_name);

        err = xFsDelete(vfd, relative_name, relative_name_len);
    }

    FsLogUndo(("fs_undo_mkdir: status %x\n", err));

    return err;
}

NTSTATUS
fs_undo_remove(VolInfo_t *volinfo,
               fs_log_rec_t *lrec, int nid, int mid)

{

    // we need to recreate the file with same name and attributes.
    // if file is not a directory, we also need to copy data
    // from master disk to nid disk
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE mvfd = FS_GET_VOL_HANDLE(volinfo, mid);
    WCHAR       name[MAXPATH];
    int         name_len=sizeof(name);
    

    name[0] = '\0';
    FsLogUndo(("fs_undo_remove: try %I64x:%I64x\n",
                  lrec->fs_id[0], lrec->fs_id[1]));

    err = xFsGetPathById(mvfd, &lrec->fs_id, name, &name_len);

    if (err == STATUS_SUCCESS) {
        int relative_name_len;
        WCHAR *relative_name;

        // build relative name
        relative_name = xFsBuildRelativePath(volinfo, mid, name);
        relative_name_len = wcslen(relative_name);

        // duplicate file or dir
        err = xFsDupFile(mvfd, vfd, relative_name, relative_name_len, FALSE);

    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
        // if we can't find file in the master disk, the file/dir
        // must have already been delete. 
        err = STATUS_SUCCESS;
    }

    FsLogUndo(("fs_undo_remove: status %x\n", err));

    return err;

}

NTSTATUS
fs_undo_rename(VolInfo_t *volinfo,
               fs_log_rec_t *lrec, int nid, int mid)

{
    // we need to recreate the file with same name and attributes.
    // if file is not a directory, we also need to copy data
    // from master disk to nid disk
    NTSTATUS err;
    // find the objectid 
    HANDLE vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE mvfd = FS_GET_VOL_HANDLE(volinfo, mid);
    WCHAR       name[MAXPATH];
    int         name_len=sizeof(name);
    

    name[0] = '\0';
    FsLogUndo(("fs_undo_rename: try %I64x:%I64x\n",
                  lrec->fs_id[0], lrec->fs_id[1]));

    err = xFsGetPathById(mvfd, &lrec->fs_id, name, &name_len);

    if (err == STATUS_SUCCESS) {
        int relative_name_len;
        WCHAR *relative_name;
        HANDLE fd;

        // build relative name and get current attribute from
        // master disk
        relative_name = xFsBuildRelativePath(volinfo, mid, name);
        relative_name_len = wcslen(relative_name);

        // we open the file on the nid disk
        err = xFsGetHandleById(vfd, &lrec->fs_id, FILE_GENERIC_WRITE, &fd);
        if (err == STATUS_SUCCESS) {
            err = xFsRename(fd, vfd, relative_name, relative_name_len);
            xFsClose(fd);
        }

    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
        // if we can't find file in the master disk, the file/dir
        // must have already been delete. 
        err = STATUS_SUCCESS;
    }

    FsLogUndo(("fs_undo_rename: status %x\n", err));

    return err;

}

NTSTATUS
fs_undo_write(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    HANDLE shdl = INVALID_HANDLE_VALUE;
    HANDLE dhdl = INVALID_HANDLE_VALUE;
    WCHAR *buf = NULL;
    HANDLE      vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE      mvfd = FS_GET_VOL_HANDLE(volinfo, mid);


    FsLogUndo(("fs_undo_write: %I64x:%I64x\n", lrec->fs_id[0],
                  lrec->fs_id[1]));

    // get the master file
    err = xFsGetHandleById(mvfd, &lrec->fs_id, FILE_GENERIC_READ, &shdl);

    if (err == STATUS_SUCCESS) {
        ULONG sz = 0;
        LARGE_INTEGER off;

        // get nid disk file
        err = xFsGetHandleById(vfd, &lrec->fs_id, FILE_GENERIC_WRITE, &dhdl);
        if (err != STATUS_SUCCESS) {
            // this is a very bad error, must abort now
            FsLogUndo(("Aborting replay_write err %x\n", err));
            err = STATUS_TRANSACTION_ABORTED;
            goto done;
        }


        // we need to read the new data from the sfd first
        if (lrec->length > 0) {
            // allocate buf
            buf = VirtualAlloc(NULL, lrec->length, MEM_COMMIT, PAGE_READWRITE);

            if (buf == NULL) {
                FsLogError(("Unable to allocate write buffer to replay\n"));
                err = STATUS_TRANSACTION_ABORTED;
                goto done;
            }


            off.LowPart = lrec->offset;
            off.HighPart = 0;

            // read local data. todo: what if the file is locked? 
            err = NtReadFile(shdl, NULL, NULL, NULL, &ios, buf,
                             lrec->length, &off, NULL);

            if (err == STATUS_PENDING) {
                EventWait(shdl);
            }

            if (ios.Status != STATUS_SUCCESS) {
                FsLogUndo(("Read failed for replay %x\n", ios.Status));
                err = STATUS_TRANSACTION_ABORTED;
                goto done;
            }
        } else {
            buf = NULL;
            ios.Information = 0;
        }
                        
        sz = (ULONG) ios.Information;
        off.LowPart = lrec->offset;
        off.HighPart = 0;
        if (sz > 0) {
            err = NtWriteFile(dhdl, NULL, NULL, (PVOID) NULL,
                              &ios, buf, sz, &off, NULL);
        } else {
            FILE_END_OF_FILE_INFORMATION x;

            x.EndOfFile = off;

            err = NtSetInformationFile(dhdl, &ios,
                                       (char *) &x, sizeof(x),
                                       FileEndOfFileInformation);

        }
        if (err == STATUS_PENDING) {
            EventWait(dhdl);
            err = ios.Status;
        }
        sz = (ULONG) ios.Information;

        // check if we have the same size, otherwise abort
        if (sz != lrec->length) {
            FsLogError(("Write sz mismatch, %d expected %d\n", sz, lrec->length));
            err = STATUS_TRANSACTION_ABORTED;
        }

    } else if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
        // if we can't find file in the master disk, the file/dir
        // must have already been delete. 
        err = STATUS_SUCCESS;
    }

 done:
    if (buf != NULL) {
        VirtualFree(buf, 0, MEM_RELEASE);
    }

    if (shdl != INVALID_HANDLE_VALUE)
        xFsClose(shdl);

    if (dhdl != INVALID_HANDLE_VALUE)
        xFsClose(dhdl);

    FsLogUndo(("Undo write offset %d len %d err %x\n", 
                 lrec->offset, lrec->length, err));

    return err;
}

FsReplayHandler_t FsUndoCallTable[] = {
    fs_undo_create,
    fs_undo_setattr,
    fs_undo_write,
    fs_undo_mkdir,
    fs_undo_remove,
    fs_undo_rename
};

NTSTATUS
FsUndoXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int mid)
{
    fs_log_rec_t        *p = (fs_log_rec_t *) arg;
    NTSTATUS            err;
    fs_id_t             *fs_id;
    HANDLE              vhdl;

    vhdl = FS_GET_VOL_HANDLE(volinfo, mid);
    if (vhdl == INVALID_HANDLE_VALUE) {
        FsLogUndo(("FsUndoXid Failed to get crs handle %d\n",
                     mid));
        return STATUS_TRANSACTION_ABORTED;
    }

    vhdl = FS_GET_VOL_HANDLE(volinfo, nid);
    if (vhdl == INVALID_HANDLE_VALUE) {
        FsLogUndo(("FsUndoXid Failed to get crs handle %d\n", nid));
        return STATUS_TRANSACTION_ABORTED;
    }

    fs_id = &p->fs_id;

    FsLogUndo(("Undo action %d nid %d objid %I64x:%I64x\n", p->command,
               nid,
               (*fs_id)[0], (*fs_id)[1]));

    err = FsUndoCallTable[p->command](volinfo, p, nid, mid);

    FsLogUndo(("Undo Status %x\n", err));

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\standalone\cli.c ===
#define UNICODE
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <stdio.h>
#include <ntddvol.h>
#include <string.h>
#include <assert.h>

#include "fs.h"
#include "fsp.h"
#include "fsutil.h"
#include "pipe.h"

#define DUMB_CLIENT
#define QFS_DO_NOT_UNMAP_WIN32
#include "..\..\..\service\inc\qfs.h"
#include "..\..\..\service\init\qfs.c"

char msg[] = "Gorik\n";
char buf[1024];

void Dir(LPCWSTR path)
{
    WIN32_FIND_DATA data;
    QfsHANDLE hdl = QfsFindFirstFile(path, &data);
    if (!QfsIsHandleValid(hdl)) {
        printf("Failed to open %ws, error %d\n", path, GetLastError());
    } else {
        printf(" Directory of %ws\n", path);
        printf("    %ws\n", data.cFileName);
        while (QfsFindNextFile(hdl, &data)) {
            printf("    %ws\n", data.cFileName);
        }
        if (GetLastError() != ERROR_NO_MORE_FILES) {
            printf("Strange error returned %d\n", GetLastError());
        }
        QfsFindClose(hdl);
    }
 }

//#define PREFIX L"\\\\GORN$QFS\\ROOT\\"
//#define PREFIX L"\\\\qfs\\root$\\"
//#define PREFIX  L"\\\\c67c3538-5167-4\\c67c3538-5167-40f0-a1dd-83f8bf41c932$\\"
// \\?\UNC\ //
#define PREFIX  L"\\\\?\\UNC\\c67c3538-5167-4\\c67c3538-5167-40f0-a1dd-83f8bf41c932$\\"
//#define PREFIX L"z:\\"

// 
//                                      OPEN_EXISTING,
//                                      OPEN_ALWAYS,

// #define CREATE_NEW          1
// #define CREATE_ALWAYS       2
// #define OPEN_EXISTING       3
// #define OPEN_ALWAYS         4
// #define TRUNCATE_EXISTING   5

char* dispName[] = {"0 disp", 
    "CREATE_NEW", 
    "CREATE_ALWAYS",
    "OPEN_EXISTING",
    "OPEN_ALWAYS",
    "TRUNCATE_EXISTING"
    };

//#define FNAME PREFIX L"GOR.txt"
#define FNAME L"C:\\GOR.txt"

void cf(LPCWSTR Name, DWORD disp, DWORD hardError, DWORD softError)
{
    QfsHANDLE Handle;
    char buf[128];
    DWORD Status;
    BOOL good;

    Handle = QfsCreateFile(Name,
                                      GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ,
        //                            0,
                                      NULL,
                                      disp,
    //                                  FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
        //                            FILE_FLAG_WRITE_THROUGH | FILE_FLAG_OVERLAPPED,
                                    0,
                                      NULL);

    Status = GetLastError();
    if (hardError == 0) {
        good = QfsIsHandleValid(Handle) && softError == Status;
        sprintf(buf, "should succeed with gle = %d", softError);
    } else {
        good = !QfsIsHandleValid(Handle) && hardError == Status;
        sprintf(buf, "should fail, status %d", hardError);
    }
    printf("%s %s handle %x gle %d (%s)\n", good?"":"****", dispName[disp], Handle, GetLastError(), buf);
    QfsCloseHandleIfValid(Handle);
}

DWORD cat(LPCWSTR Name)
{
    PCHAR buf[1024];
    DWORD dwBytes;

    QfsHANDLE hFile = QfsCreateFile(Name,
                                      GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ,
                                      NULL,
                                      OPEN_EXISTING,
                                      0,
                                      NULL);
    if (!QfsIsHandleValid(hFile)) {
        return FALSE;
    }

    while (QfsReadFile(hFile, buf, sizeof(buf), &dwBytes, NULL) && dwBytes) {
        printf("%.*s", dwBytes, buf);
    }
    printf("\n");

    QfsCloseHandle(hFile);
    return TRUE;
}

void MiniShell()
{
    DWORD len;
    DWORD err;
    WCHAR TempDir[1024];
    WCHAR HomeDir[1024];
    WCHAR CurrentDir[1024];
    WCHAR cmd[1024];

    QfsLogLevel = 1;

    len = GetCurrentDirectory(1024, CurrentDir);
    if (len == 1024 || len == 0) {
        printf("GetCurrentDir failed, error %d\n", GetLastError());
        return;
    }

    printf("Quorum Minishell\n(C) Copyright 1985-2001 Microsoft Corp.\n\n");
    wcscpy(HomeDir, CurrentDir);

    for(;;) {
        printf("%ws>", CurrentDir);
        if ((_getws(cmd) == NULL) || wcscmp(cmd, L"exit")==0) {
            break;
        }
        if (cmd[0] == 0) continue;
        if (wcsncmp(cmd, L"cd",2) == 0) {
            if (cmd[2] == 0) {
                wcscpy(CurrentDir, HomeDir);
                continue;
            }
            if (cmd[2] != ' ') {
                goto invalid_command;
            }                
            if (cmd[3] == '.') {
                if (cmd[4] == '.') {
                    WCHAR* p = wcsrchr(CurrentDir, '\\');
                    if (p) *p = 0;
                }
                continue;
            }
            if (cmd[3] == '\\' || cmd[4] == ':') {
                wcscpy(CurrentDir, cmd+3);
            } else {
                wcscat(CurrentDir, cmd+3);
            }
            len = wcslen(CurrentDir);
            if (len > 0 && CurrentDir[len-1] == '\\') {
                CurrentDir[len-1] = 0;
            }
            continue;
        }
        if (wcscmp(cmd, L"dir")==0) {
            wcscpy(TempDir, CurrentDir);
            wcscat(TempDir, L"\\*");
            Dir(TempDir);
            continue;
        }
        if (wcsncmp(cmd, L"mkdir ", 6)==0) {
            err = QfsCreateDirectory(cmd + 6, NULL);
        } else if (wcsncmp(cmd, L"rmdir ", 6) == 0) {
            err = QfsRemoveDirectory(cmd + 6);
        } else if (wcsncmp(cmd, L"del ", 4) == 0) {
            err = QfsDeleteFile(cmd + 4);
        } else if (wcsncmp(cmd, L"cat ", 4) == 0) { 
            wcscpy(TempDir, CurrentDir);
            wcscat(TempDir, L"\\");
            wcscat(TempDir, cmd + 4);
            err = cat(TempDir);
        }
        continue;
invalid_command:
        printf("  Invalid command \"%ws\"\n", cmd);
    }
    printf("Bye\n\n");
}


_cdecl
main()
{

    MiniShell();

#if 0
    QfsHANDLE Handle;
    DWORD dwSize;
    DWORD status;
    int i;

    // CREATE_NEW Creates a new file. The function fails if the specified file already exists. 
    // CREATE_ALWAYS Creates a new file. If the file exists, the function overwrites the file and clears the existing attributes. 
    // OPEN_EXISTING Opens the file. The function fails if the file does not exist. 
    // OPEN_ALWAYS Opens the file, if it exists. If the file does not exist, the function creates the file as if dwCreationDisposition were CREATE_NEW. 
    // TRUNCATE_EXISTING 

    QfsDeleteFile(FNAME);
    cf(FNAME, CREATE_NEW, 0,0);
    cf(FNAME, CREATE_NEW, 80,80);

    QfsDeleteFile(FNAME);
    cf(FNAME, CREATE_ALWAYS, 0,0);
    cf(FNAME, CREATE_ALWAYS, 0,183);

    cf(FNAME, OPEN_EXISTING, 0,0);
    QfsDeleteFile(FNAME);
    cf(FNAME, OPEN_EXISTING, 2,2);

    QfsDeleteFile(FNAME);
    cf(FNAME, OPEN_ALWAYS, 0,0);
    cf(FNAME, OPEN_ALWAYS, 0,183);

    cf(FNAME, TRUNCATE_EXISTING, 0,0);
    QfsDeleteFile(FNAME);
    cf(FNAME, TRUNCATE_EXISTING, 2,2);

    return 0;
    QfsDeleteFile(PREFIX L"gor.txt");

    for(i = 0; i < 2; ++i) {
        status = QfsCreateFile(&Handle, PREFIX L"gor.txt",
                                      GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ,
        //                            0,
                                      NULL,
                                      OPEN_ALWAYS,
    //                                  FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
        //                            FILE_FLAG_WRITE_THROUGH | FILE_FLAG_OVERLAPPED,
                                    0,
                                      NULL);

        printf("handle %x gle %d\n", Handle, status);
        QfsCloseHandleIfValid(Handle);
    }
#endif
    

//    Dir(PREFIX L"\\*");
    
#if 0    
#if 0
    status = QfsCreateFile(
        &Handle,
        L"zTest2.txt",
        GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL);

    QfsWriteFile(
          Handle,
          msg,
          sizeof(msg),
          &dwSize,
          NULL);

    QfsFlushFileBuffers(Handle);
              
    QfsCloseHandle(Handle);
#endif

    status = QfsCreateFile(
        &Handle,
        PREFIX L"zTest.txt",
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
    if (status == ERROR_SUCCESS) {
        dwSize = QfsGetFileSize(Handle, NULL);
#if 1
        dwSize = 0;
        QfsReadFile(
              Handle,
              buf,
              sizeof(buf),
              &dwSize,
              NULL);
        printf("read => %d bytes, %s\n", dwSize, buf);
#endif                  

        QfsSetEndOfFile(Handle, dwSize + 2);
        QfsCloseHandle(Handle);
    }

    QfsSetFileAttributes(PREFIX L"zTest.txt", FILE_ATTRIBUTE_NORMAL);

    QfsCopyFile(PREFIX L"zTest.txt", PREFIX L"A.txt", FALSE);
#endif    
//    QfsCopyFile(PREFIX L"A.txt", PREFIX L"B.txt", FALSE);
#if 0
    QfsDeleteFile(L"zTest2.txt");
    QfsDeleteFile(L"zbuild.log");

    Dir(L"z\\*");
    Dir(L"z\\*.tx?");
    Dir(L"z\\1st\\*");
    QfsCreateDirectory(L"z1st", NULL);
    Dir(L"z\\1st\\*");    
#endif
#if 0
    {
        ULARGE_INTEGER FreeBytesAvailable;    // bytes available to caller
        ULARGE_INTEGER TotalNumberOfBytes;    // bytes on disk
        ULARGE_INTEGER TotalNumberOfFreeBytes; // free bytes on disk
        if (QfsGetDiskFreeSpaceEx(L"z.", &FreeBytesAvailable, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)) {
            printf("av %u total %u free %u\n", FreeBytesAvailable.LowPart, TotalNumberOfBytes.LowPart, TotalNumberOfFreeBytes.LowPart);
        }    
        if (QfsGetDiskFreeSpaceEx(L"C:\\drop\\test\\root", &FreeBytesAvailable, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)) {
            printf("av %u total %u free %u\n", FreeBytesAvailable.LowPart, TotalNumberOfBytes.LowPart, TotalNumberOfFreeBytes.LowPart);
        }    
//        if (QfsGetDiskFreeSpaceEx(PREFIX L".", &FreeBytesAvailable, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)) {
//            printf("av %u total %u free %u\n", FreeBytesAvailable.LowPart, TotalNumberOfBytes.LowPart, TotalNumberOfFreeBytes.LowPart);
//        }    
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\standalone\main.c ===
#define UNICODE
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <stdio.h>
#include <ntddvol.h>
#include <string.h>
#include <assert.h>

#include "fs.h"
#include "fsp.h"
#include "fsutil.h"
#include "pipe.h"

//#define ENABLE_SMB

extern
DWORD
FindTransport(LPWSTR TransportId, LPWSTR *Transport);

extern
DWORD
SetupTree(
    IN LPTSTR TreeName,
    IN LPTSTR DlBuf,
    IN OUT DWORD *DlBufSz,
    IN LPTSTR TransportName OPTIONAL,
    IN LPVOID SecurityDescriptor OPTIONAL
    );

HANDLE event;
int Done = FALSE;

BOOL WINAPI HandlerRoutine(DWORD dwCtrlType)
{
    switch(dwCtrlType) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
	Done = TRUE;
	SetEvent(event);
        return TRUE;
    default:
        return FALSE;
    }
}


_cdecl
main(int argc, char *argv[])
{
    int cnt;
    char cmd[80];
    DWORD err;
    WCHAR *share = L"root";
    HANDLE hdl;
    PVOID srvhdl, fshdl, pipehdl;
    PVOID fid;
    extern BOOLEAN FsReadOnly;
    WCHAR   *wargv[FsMaxNodes], *tmp[FsMaxNodes];
    int i, mask;
    LPWSTR	tid;
    WCHAR	localname[MAX_COMPUTERNAME_LENGTH + 20];
    DWORD	now;

    now = GetTickCount();

    wcscpy(localname,L"\\\\");
    err = sizeof(localname);
    if (GetComputerName(&localname[wcslen(localname)], &err) == FALSE) {
	return GetLastError();
    }

    wcscat(localname,L"$QFS\\");
    wcscat(localname,share);

    if (argc < 2) {
	printf("Usage %s: disk1 disk2 ... diskN\n", argv[0]);
	return 0;
    }

    tid = NULL;
    err = FindTransport(L"NetBT_Tcpip", &tid);
    if (err != ERROR_SUCCESS) {
	printf("Unable to find transport to bind1 %d\n", err);
	return 0;
    }

    memset(wargv, 0, sizeof(wargv));
    wargv[0] = NULL;
    for (i = 1; i < argc; i++) {
	int j;
	wargv[i] = (WCHAR *) malloc((strlen(argv[i])+1) * sizeof(WCHAR));
	j = mbstowcs(wargv[i], argv[i], strlen(argv[i]));
	wargv[i][j] = L'\0';
    }

    FsReadOnly = TRUE;
    err = FsInit(NULL, &fshdl);
    if (err != STATUS_SUCCESS) {
	printf("Unable to init filesystem %d\n", err);
	return 0;
    }

    err = PipeInit(0,fshdl,&pipehdl);
    if (err != STATUS_SUCCESS) {
	printf("Unable to init server %d\n", err);
	return 0;
    }

    err = SrvInit(NULL, fshdl, &srvhdl);
    if (err != STATUS_SUCCESS) {
	printf("Unable to init server %d\n", err);
	return 0;
    }

    err = FsRegister(fshdl, share, wargv[1], wargv, argc-1, &fid);
    if (err != STATUS_SUCCESS) {
	printf("Unable to register share %d\n", err);
	return 0;
    }

 regain:
    // arb
    event = CreateEvent(NULL, FALSE, FALSE, NULL);
    err = FsArbitrate(fid, event, &hdl);

    if (err == ERROR_IO_PENDING || err == ERROR_PATH_BUSY) {
	HANDLE	a[2];

	a[0] = hdl;
	a[1] = event;

	err = WaitForMultipleObjects(2, a, FALSE, 45 * 1000);
	if (err != WAIT_TIMEOUT) {
	    // check if we got it or not
	    err = FsIsQuorum(fid);
	} else {
	    // our time ran out, cancel it now
	    printf("Arb timedout\n");
	    FsCancelArbitration(fid);
	    err = ERROR_CANCELLED;
	}
    }

    if (err != ERROR_SUCCESS) {
	printf("Arbitration failed %d\n", err); Sleep(5*1000);
	goto regain;
	return 1;
    }

    printf("Arb in %d msec\n", GetTickCount() - now);

    {
	HANDLE	fd;

	sprintf(cmd, "\\\\?\\%s\\foo.txt", argv[1]);
	fd = CreateFileA(cmd, GENERIC_READ|GENERIC_WRITE,
			FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL);
	if (fd == INVALID_HANDLE_VALUE) {
	    printf("Open failed %d\n", GetLastError());
	}
    }
    // online filesystem before onlining its network name
    while (FsIsOnline(fid) == ERROR_IO_PENDING)
	Sleep(1*1000);

    err = PipeOnline(pipehdl, share);
    if (err != STATUS_SUCCESS) {
	printf("Unable to online pipeserver %d\n", err);
	return 0;
    }
#ifdef ENABLE_SMB
    // online
    err = SrvOnline(srvhdl, NULL, 0);
    if (err != ERROR_SUCCESS) {
	printf("Srv Online failed %d\n", err);
	return 1;
    }
#endif

 #ifdef ENABLE_SMB
    // Now we need to connect tree
 retry:
    err = SetupTree(localname, NULL, NULL, tid, NULL);
    if (err != ERROR_SUCCESS) {
	printf("Unable to setup tree '%S' %d\n", localname, err);
	if (err == ERROR_PATH_NOT_FOUND) {
	    Sleep(1000 * 2);
	    goto retry;
	}
	return err;
    }
 #endif

    SetConsoleCtrlHandler(HandlerRoutine, TRUE);
    printf("Server is up.\n");
    mask = 0x2;
    while (Done == FALSE) {
	int cnt;
	if (FsReserve(fid) != ERROR_SUCCESS) {
	    printf("Lost reservation!\n");
	    break;
	}
	err = FsIsOnline(fid);
	if ( err != ERROR_SUCCESS && err != ERROR_IO_PENDING) {
	    printf("Fs offlined %d!\n", err);
	}

	// Every 5 seconds change replica set
	WaitForSingleObject(event, 5 * 1000);
#if 0
	memset(tmp, 0, sizeof(tmp));
	cnt = 0;
	for (i = 1; i < argc; i++) {
	    if (mask & (1 << i)) {
		cnt++;
		printf("New replica %d '%S'\n", i, wargv[i]);
		tmp[i] = wargv[i];
	    }
	}
	printf("Changing set %x size %d\n", mask, cnt);
	FsUpdateReplicaSet(fid, tmp, cnt);
	mask += 2;
	if (cnt >= (argc - 1)) {
	    mask = 2;
	}
#endif
    }
    printf("Exiting...\n");

    // offline
#ifdef ENABLE_SMB
    SrvOffline(srvhdl);
#endif 

    PipeOffline(pipehdl);

    // release
    FsRelease(fid);

    SrvExit(srvhdl);
    PipeExit(pipehdl);
    FsExit(fshdl);
    return 0;
}

#include <stdlib.h>
#include <stdarg.h>

void
debug_log(char *format, ...)
{
    va_list marker;

    va_start(marker, format);

    printf("%d:%x:",GetTickCount(), GetCurrentThreadId());
    vprintf(format, marker);

    va_end(marker);

}

void
error_log(char *format, ...)
{
    va_list marker;

    va_start(marker, format);

    printf("*E %d:%x:",GetTickCount(), GetCurrentThreadId());
    vprintf(format, marker);

    va_end(marker);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\netname\namechk.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    namechk.h

Abstract:

    Routines for checking nbt network names.

Author:

    Rod Gamache (rodga) 1-Aug-1997

Revision History:

--*/

#include <tdi.h>
#include <nb30.h>


#define MAX_PATH_SIZE   64

#define NETBIOS_NAME_SIZE 16

//
// The format of Adapter Status responses
//
typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;


//----------------------------------------------------------------------
//
//  Function Prototypes
//

NTSTATUS
ReadRegistry(
    IN UCHAR  pDeviceName[][MAX_PATH_SIZE]
    );

NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );

NTSTATUS
OpenNbt(
    IN  CHAR    path[][MAX_PATH_SIZE],
    OUT PHANDLE pHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\netname\namechk.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    namechk.c

Abstract:

    Check on network names given by the cluster network name resource dll.

Author:

    Rod Gamache (rodga) 1-Aug-1997

Environment:

    User Mode

Revision History:


--*/

#define UNICODE 1

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>

#include <nb30.h>
#include <lmaccess.h>

#include "namechk.h"
#include "resapi.h"
#include "netname.h"
#include "nameutil.h"
#include "clusres.h"


#define NET_NAME_SVC L"LanmanServer"

#define BUFF_SIZE   650

#define NBT_MAXIMUM_BINDINGS 20


NTSTATUS
CheckNbtName(
    IN HANDLE           Fd,
    IN LPCWSTR          Name,
    IN ULONG            Type,
    IN RESOURCE_HANDLE  ResourceHandle
    );

NTSTATUS
ReadRegistry(
    IN UCHAR  pDeviceName[][MAX_PATH_SIZE]
    );

NTSTATUS
OpenNbt(
    IN char path[][MAX_PATH_SIZE],
    OUT PHANDLE pHandle
    );



DWORD
NetNameCheckNbtName(
    IN LPCWSTR         NetName,
    IN DWORD           NameHandleCount,
    IN HANDLE *        NameHandleList,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Checks a network name.

Arguments:

    NetName - pointer to the network name to validate.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD     status = ERROR_SUCCESS;
    NTSTATUS  ntStatus;

    //
    // loop through the list of handles we acquired when bringing the
    // name online and check that our netname is still registered
    // on each device
    //

    while ( NameHandleCount-- ) {

        //
        // Check the workstation name. If this fails, immediate failure!
        //
        ntStatus = CheckNbtName(
                       *NameHandleList,
                       NetName,
                       0x00,
                       ResourceHandle
                       );

        if ( !NT_SUCCESS(ntStatus) ) {
            status = RtlNtStatusToDosError(ntStatus);
            return(status);
        }

        //
        // Check the server name. If this fails, then only fail if Srv service
        // is not running.
        //
        ntStatus = CheckNbtName(
                       *NameHandleList,
                       NetName,
                       0x20,
                       ResourceHandle
                       );

        if ( !NT_SUCCESS(ntStatus) ) {
            if ( ResUtilVerifyResourceService( NET_NAME_SVC) == ERROR_SUCCESS ) {
                status = ERROR_RESOURCE_FAILED;
            }
        }

        ++NameHandleList;
    }

    return(status);

} // NetNameCheckName


NTSTATUS
CheckNbtName(
    IN HANDLE           fd,
    IN LPCWSTR          Name,
    IN ULONG            Type,
    IN RESOURCE_HANDLE  ResourceHandle
    )

/*++

Routine Description:

    This procedure does an adapter status query to get the local name table.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG                            Count;
    ULONG                           BufferSize = sizeof( tADAPTERSTATUS );
    tADAPTERSTATUS                  staticBuffer;
    PVOID                           pBuffer = (PVOID)&staticBuffer;
    NTSTATUS                        status;
    tADAPTERSTATUS                  *pAdapterStatus;
    NAME_BUFFER                     *pNames;
    ULONG                           Ioctl;
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
    PVOID                           pInput;
    ULONG                           SizeInput;
    UCHAR                           netBiosName[NETBIOS_NAME_SIZE +4];
    OEM_STRING                      netBiosNameString;
    UNICODE_STRING                  unicodeName;
    NTSTATUS                        ntStatus;

    //
    // set the correct Ioctl for the call to NBT, to get either
    // the local name table or the remote name table
    //
    Ioctl = IOCTL_TDI_QUERY_INFORMATION;
    QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status or whatever
    SizeInput = sizeof(TDI_REQUEST_QUERY_INFORMATION);
    pInput = &QueryInfo;

    do {
        status = DeviceIoCtrl(fd,
                              pBuffer,
                              BufferSize,
                              Ioctl,
                              pInput,
                              SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW) {
            if ( pBuffer != &staticBuffer ) {
                LocalFree( pBuffer );
            }

            BufferSize += sizeof( staticBuffer.Names );
            pBuffer = LocalAlloc( LMEM_FIXED, BufferSize);

            if (!pBuffer || (BufferSize >= 0xFFFF)) {
                LocalFree( pBuffer );
                (NetNameLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Unable to allocate memory for name query.\n"
                    );
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    } while (status == STATUS_BUFFER_OVERFLOW);

    if (status != STATUS_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Name query request failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    Count = pAdapterStatus->AdapterInfo.name_count;
    pNames = pAdapterStatus->Names;

    status = STATUS_NOT_FOUND;

    if (Count == 0) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Name query request returned zero entries.\n"
            );
        goto error_exit;
    }

    //
    // Convert the ServerName to an OEM string
    //
    RtlInitUnicodeString( &unicodeName, Name );

    netBiosNameString.Buffer = (PCHAR)netBiosName;
    netBiosNameString.MaximumLength = sizeof( netBiosName );

    ntStatus = RtlUpcaseUnicodeStringToOemString(
                   &netBiosNameString,
                   &unicodeName,
                   FALSE
                   );

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to convert name %1!ws! to an OEM string, status %2!u!\n",
            Name,
            status
            );
        return(status);
    }

    //
    // blank fill the name
    //
    memset(&netBiosName[netBiosNameString.Length],
           ' ',
           NETBIOS_NAME_SIZE - netBiosNameString.Length);

    while ( Count-- ) {
        //
        // Make sure the type and name matches
        //
        if ( (pNames->name[NETBIOS_NAME_SIZE-1] == Type) &&
             (memcmp(pNames->name, netBiosName, NETBIOS_NAME_SIZE-1) == 0) )
        {

            switch(pNames->name_flags & 0x0F) {

            case REGISTERING:
            case REGISTERED:
               status = STATUS_SUCCESS;
               break;

            case DUPLICATE_DEREG:
            case DUPLICATE:
                (NetNameLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Name %1!ws!<%2!x!> is in conflict.\n",
                    Name,
                    Type
                    );
                status = STATUS_DUPLICATE_NAME;
                break;

            case DEREGISTERED:
                (NetNameLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Name %1!ws!<%2!x!> was deregistered.\n",
                    Name,
                    Type
                    );
                status = STATUS_NOT_FOUND;
                break;

            default:
                (NetNameLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Name %1!ws!<%2!x!> is in unknown state %3!x!.\n",
                    Name,
                    Type,
                    (pNames->name_flags & 0x0F)
                    );
               status = STATUS_UNSUCCESSFUL;
               break;
            }
        }

        pNames++;
    }

    if (status == STATUS_NOT_FOUND) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Name %1!ws!<%2!x!> is no longer registered with NBT.\n",
            Name,
            Type
            );
    }

error_exit:

    if ( pBuffer != &staticBuffer ) {
        LocalFree( pBuffer );
    }

    return(status);

} // CheckNbtName

//------------------------------------------------------------------------
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;


    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);

} // DeviceIoCtrl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\netname\compobj.cpp ===
/*++

Copyright (c) 2000, 2001  Microsoft Corporation

Module Name:

    compobj.cpp

Abstract:

    routines for backing computer object support

Author:

    Charlie Wickham (charlwi) 14-Dec-2000

Environment:

    User Mode

Revision History:

--*/

#define UNICODE         1
#define _UNICODE        1
#define LDAP_UNICODE    1

#define SECURITY_WIN32

extern "C" {
#include "clusres.h"
#include "clusstrs.h"
#include "clusrtl.h"

#include <winsock2.h>

#include <lm.h>
#include <lmaccess.h>
#include <sspi.h>

#include <winldap.h>
#include <ntldap.h>
#include <dsgetdc.h>
#include <dsgetdcp.h>
#include <ntdsapi.h>
#include <sddl.h>

#include <objbase.h>
#include <iads.h>
#include <adshlp.h>
#include <adserr.h>

#include "netname.h"
#include "nameutil.h"
}

//
// Constants
//

#define LOG_CURRENT_MODULE LOG_MODULE_NETNAME

#define NTLMSP_NAME     TEXT("NTLM")

//
// private structures
//
#define SPN_MAX_SPN_COUNT   6

typedef struct _NN_SPN_LIST {
    DWORD   SpnCount;
    LPWSTR  Spn[ SPN_MAX_SPN_COUNT ];
} NN_SPN_LIST, *PNN_SPN_LIST;

//
// Externs
//
extern PLOG_EVENT_ROUTINE   NetNameLogEvent;

extern "C" {
DWORD
EncryptNNResourceData(
    PNETNAME_RESOURCE   Resource,
    LPWSTR              MachinePwd,
    PBYTE *             EncryptedData,
    PDWORD              EncryptedDataLength
    );

DWORD
DecryptNNResourceData(
    PNETNAME_RESOURCE   Resource,
    PBYTE               EncryptedData,
    DWORD               EncryptedDataLength,
    LPWSTR              MachinePwd
    );
}

//
// static data
//
static WCHAR LdapHeader[] = L"LDAP://";

//
// partial list of SPNs used by clustering. All netname resources get Host and
// VS SPN. Cluster core name gets server cluster SPN which is used to find
// "clusters" in the DS (for Whistler). This array is order dependent: the
// last entry must be for the core resource.
//
static PWCHAR SPNServiceClass[] = {
    L"HOST/",
    L"MSClusterVirtualServer/",
    L"MSServerCluster/"
};

//
// each SPN ServiceClass is used to form two SPNs: netbios based and DNS
// based. Virtual servers use the first two entries while core resources use
// all three.
//
#define SPN_VS_SPN_COUNT            4
#define SPN_CORE_SPN_COUNT          6

#define SPN_VS_SERVICECLASS_COUNT   2
#define SPN_CORE_SERVICECLASS_COUNT 3
#define SPN_MAX_SERVICECLASS_COUNT  3

#define SPN_MAX_SERVICECLASS_CHARS  23      // virtual server

//
// forward references
//

HRESULT
GetComputerObjectViaFQDN(
    IN     LPWSTR               DistinguishedName,
    IN     LPWSTR               DCName              OPTIONAL,
    IN OUT IDirectoryObject **  ComputerObject
    );

//
// private routines
//

static DWORD
GenerateRandomBytes(
    PWSTR   Buffer,
    DWORD   BufferLength
    )

/*++

Routine Description:

    Generate random bytes for a password. Length is specified in characters
    and allows room for the trailing null.

Arguments:

    Buffer - pointer to area to receive random data

    BufferLength - size of Buffer in characters

Return Value:

    ERROR_SUCCESS otherwise GetLastError()

--*/

{
    HCRYPTPROV  cryptProvider;
    DWORD       status = ERROR_SUCCESS;
    DWORD       charLength = BufferLength - 1;
    DWORD       byteLength = charLength * sizeof( WCHAR );
    BOOL        success;

    if ( !CryptAcquireContext(&cryptProvider,
                              NULL,
                              NULL,
                              PROV_RSA_FULL,
                              CRYPT_VERIFYCONTEXT
                              )) {
        return GetLastError();
    }

    //
    // leave room for the terminating null
    //
    if (CryptGenRandom( cryptProvider, byteLength, (BYTE *)Buffer )) {

        //
        // run down the array as WCHARs to make sure there is no premature
        // terminating NULL
        //
        PWCHAR  pw = Buffer;

        while ( charLength-- ) {
            if ( *pw == UNICODE_NULL ) {
                *pw = 0xA3F5;
            }
            ++pw;
        }

        *pw = UNICODE_NULL;
    } else {
        status = GetLastError();
    }

    success = CryptReleaseContext( cryptProvider, 0 );
    ASSERT( success );

    return status;
} // GenerateRandomBytes

DWORD
FindDomainForServer(
    IN  RESOURCE_HANDLE             ResourceHandle,
    IN  PWSTR                       Server,
    IN  PWSTR                       DCName,     OPTIONAL
    IN  DWORD                       DSFlags,
    OUT PDOMAIN_CONTROLLER_INFO *   DCInfo
    )

/*++

Routine Description:

    get the name of a DC for our node

Arguments:

    Server - pointer to string containing our server (i.e., node) name

    DCName - non-null if we should connect to a specific DC

    DSFlags - any specific flags needed by the caller

    DCInfo - address of a pointer that receives a pointer to DC information

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error. If successful, caller must
    free DCInfo buffer.

--*/

{
    ULONG   status;
    WCHAR   localServerName[ DNS_MAX_LABEL_BUFFER_LENGTH ];

    PDOMAIN_CONTROLLER_INFOW    dcInfo;

    //
    // MAX_COMPUTERNAME_LENGTH is defined to be 15 but I could create computer
    // objects with name lengths of up to 20 chars. 15 is the max number of
    // chars for a Netbios name. In any case, we'll leave ourselves extra room
    // by using the DNS constants. Leave space for the dollar sign and
    // trailing null.
    //
    wcsncpy( localServerName, Server, DNS_MAX_LABEL_LENGTH - 2 );
    wcscat( localServerName, L"$" );

    //
    // specifying that a DS is required makes us home in on a W2K or better DC
    // (as opposed to an NT4 PDC).
    //
    DSFlags |= DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME;

retry_findDC:
    status = DsGetDcNameWithAccountW(DCName,
                                     localServerName,
                                     UF_MACHINE_ACCOUNT_MASK,
                                     L"",
                                     NULL,
                                     NULL,
                                     DSFlags,
                                     &dcInfo );

#if DBG
    (NetNameLogEvent)(ResourceHandle,
                      LOG_INFORMATION,
                      L"FindDomainForServer: DsGetGetDcName returned %1!u! with flags %2!08X!\n",
                      status,
                      DSFlags);
#endif

    if ( status == NO_ERROR ) {
        HANDLE  dsHandle = NULL;

        //
        // make sure it is really available by binding to it
        //
        status = DsBindW( dcInfo->DomainControllerName, NULL, &dsHandle );

#if DBG
        (NetNameLogEvent)(ResourceHandle,
                          LOG_INFORMATION,
                          L"FindDomainForServer: DsBind returned %1!u!\n",
                          status);
#endif

        if (DCName == NULL && status != NO_ERROR && !(DSFlags & DS_FORCE_REDISCOVERY )) {
            //
            // couldn't bind to the returned DC and we haven't forced a
            // rediscovery; do so now
            //

            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"FindDomainForServer: Bind to DS failed (status %1!u). "
                              L"Forcing discovery of available DC.\n",
                              status);

            NetApiBufferFree( dcInfo );
            dcInfo = NULL;
            DSFlags |= DS_FORCE_REDISCOVERY;
            goto retry_findDC;
        }
        else if ( status == NO_ERROR ) {
            DsUnBind( &dsHandle );
            *DCInfo = dcInfo;
        } else {
            //
            // some other error; free up DC info and return error to caller
            //
            NetApiBufferFree( dcInfo );
        }
    }

    return status;
} // FindDomainForServer

HRESULT
AddDnsHostNameAttribute(
    RESOURCE_HANDLE     ResourceHandle,
    IDirectoryObject *  CompObj,
    PWCHAR              VirtualName,
    BOOL                Rename
    )

/*++

Routine Description:

    add the DnsHostName attribute to the computer object for the specified
    virtual name.

Arguments:

    ResourceHandle - used to log in cluster log

    CompObj - IDirObj COM pointer to object

    VirtualName - network name

    Rename - true if we're renaming the CO

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error

--*/

{
    HRESULT hr;
    DWORD   numberModified;
    WCHAR   dnsSuffix[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   dnsSuffixSize;
    WCHAR   FQDnsName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    BOOL    success;

    ADSVALUE    attrValue;

    ADS_ATTR_INFO   attrInfo;

    //
    // get the node's primary DNS domain
    //
    dnsSuffixSize = COUNT_OF( dnsSuffix );
    success = GetComputerNameEx(ComputerNameDnsDomain,
                                dnsSuffix,
                                &dnsSuffixSize);

    if ( success ) {
        //
        // build the FQ Dns name for this host
        //
        FQDnsName[ COUNT_OF( FQDnsName ) - 1 ] = UNICODE_NULL;
        _snwprintf( FQDnsName, COUNT_OF( FQDnsName ) - 1, L"%ws.%ws", VirtualName, dnsSuffix );

        attrValue.dwType =              ADSTYPE_CASE_IGNORE_STRING;
        attrValue.CaseIgnoreString =    FQDnsName;

        attrInfo.pszAttrName =      L"dNSHostName";
        attrInfo.dwControlCode =    ADS_ATTR_UPDATE;
        attrInfo.dwADsType =        ADSTYPE_CASE_IGNORE_STRING;
        attrInfo.pADsValues =       &attrValue;
        attrInfo.dwNumValues =      1;

        hr = CompObj->SetObjectAttributes( &attrInfo, 1, &numberModified );
        if ( SUCCEEDED( hr ) && numberModified != 1 ) {
            //
            // don't know why this scenario would happen but we'd better log
            // it since it is unusual
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Setting DnsHostName attribute succeeded but NumberModified is zero!\n");

            hr = E_ADS_PROPERTY_NOT_SET;
        }

        if ( Rename && SUCCEEDED( hr )) {
            WCHAR   dollarName[ DNS_MAX_NAME_BUFFER_LENGTH ];

            //
            // try to update the display name as well. Default access rights
            // don't allow this to be written but in case the domain admin has
            // given the cluster service account additional privileges, we
            // might be able to update it
            //
            dollarName[ COUNT_OF( dollarName ) - 1 ] = UNICODE_NULL;
            _snwprintf( dollarName, COUNT_OF( dollarName ) - 1, L"%ws$", VirtualName );

            attrValue.dwType =              ADSTYPE_CASE_IGNORE_STRING;
            attrValue.CaseIgnoreString =    dollarName;

            attrInfo.pszAttrName =      L"displayName";
            attrInfo.dwControlCode =    ADS_ATTR_UPDATE;
            attrInfo.dwADsType =        ADSTYPE_CASE_IGNORE_STRING;
            attrInfo.pADsValues =       &attrValue;
            attrInfo.dwNumValues =     1;

            hr = CompObj->SetObjectAttributes( &attrInfo, 1, &numberModified );
            if ( FAILED( hr )) {
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_WARNING,
                                  L"Failed to set DisplayName attribute. status %1!08X!\n",
                                  hr);

                hr = NO_ERROR;
            }
        }
    }
    else {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return hr;
} // AddDnsHostNameAttribute

DWORD
BuildNetNameSPNs(
    IN  LPWSTR          HostName,
    IN  BOOL            CoreResource,
    OUT PNN_SPN_LIST *  SpnList
    )

/*++

Routine Description:

    For the given name, build the appropriate list of SPNs. Caller frees
    returned list with only one call to LocalFree().

Arguments:

    HostName - host name to be used as part of the SPN

    CoreResource - TRUE if this is the core netname resource. It gets extra SPNs

    SpnList - address of pointer that receives structure containing array of
              pointers to SPNs

Return Value:

    ERROR_SUCCESS if everything worked ok....

--*/

{
    DWORD   spnCount;
    DWORD   serviceClassCount;
    PWCHAR  spnBuffer;
    DWORD   charsLeft;
    DWORD   spnSize;
    DWORD   i;
    BOOL    success;
    WCHAR   dnsDomain[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   dnsDomainChars;
    DWORD   hostNameChars = wcslen( HostName );

    PNN_SPN_LIST    spnList;

    //
    // get the node's DNS domain
    //
    dnsDomainChars = COUNT_OF( dnsDomain );
    success = GetComputerNameEx( ComputerNameDnsDomain, dnsDomain, &dnsDomainChars );
    if ( !success ) {
        return GetLastError();
    }

    //
    // compute the space needed for the SPN List - minimum is for virtual servers
    //
    if ( CoreResource ) {
        spnCount = SPN_CORE_SPN_COUNT;
        serviceClassCount = SPN_CORE_SERVICECLASS_COUNT;
    } else {
        spnCount = SPN_VS_SPN_COUNT;
        serviceClassCount = SPN_VS_SERVICECLASS_COUNT;
    }

    //
    // total size is: the header, the size of the Netbios based SPNs, and the
    // size of the DNS based SPNs.
    //
    spnSize = sizeof( NN_SPN_LIST ) +
        ( serviceClassCount * ( SPN_MAX_SERVICECLASS_CHARS + hostNameChars + 1 ) +
          serviceClassCount * ( SPN_MAX_SERVICECLASS_CHARS + dnsDomainChars )
        ) * sizeof( WCHAR );

    spnList = (PNN_SPN_LIST)LocalAlloc( LMEM_FIXED, spnSize );
    if ( spnList == NULL ) {
        return GetLastError();
    }

    //
    // build up the structure
    //
    spnList->SpnCount = spnCount;
    spnBuffer = (PWCHAR)(spnList + 1);
    charsLeft = ( spnSize - sizeof( NN_SPN_LIST )) / sizeof( WCHAR );

    for ( i = 0; i < serviceClassCount; ++i ) {
        LONG    charCount;

        //
        // build Netbios based SPN
        //
        spnList->Spn[ 2 * i ] = spnBuffer;
        charCount = _snwprintf( spnBuffer, charsLeft, L"%ws%ws", SPNServiceClass[i], HostName );
        ASSERT( charCount > 0 );

        spnBuffer += ( charCount + 1 );
        charsLeft -= ( charCount + 1 );

        //
        // build DNS based SPN
        //
        spnList->Spn[ 2 * i + 1 ] = spnBuffer;
        charCount = _snwprintf( spnBuffer, charsLeft, L"%ws%ws.%ws", SPNServiceClass[i], HostName, dnsDomain );
        ASSERT( charCount > 0 );

        spnBuffer += ( charCount + 1 );
        charsLeft -= ( charCount + 1 );
    }

    *SpnList = spnList;

    return ERROR_SUCCESS;
} // BuildNetNameSPNs

DWORD
AddServicePrincipalNames(
    HANDLE  DsHandle,
    PWCHAR  VirtualFQDN,
    PWCHAR  VirtualName,
    PWCHAR  DnsDomain,
    BOOL    IsCoreResource
    )

/*++

Routine Description:

    add the DNS and Netbios host service principal names to the specified
    virtual name. These are: HOST, MSClusterVirtualServer, and MSServerCluster
    if it is the core resource.

Arguments:

    DsHandle - handle obtained from DsBind

    VirtualFQDN - distinguished name of computer object for the virtual netname

    VirtualName - the network name to be added

    DnsDomain - the DNS domain used to construct the DNS SPN

    IsCoreResource - true if we need to add the core resource SPN

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error

--*/

{
    DWORD   status;

    PNN_SPN_LIST    spnList;

    //
    // get a list of the SPNs
    //
    status = BuildNetNameSPNs( VirtualName, IsCoreResource, &spnList );
    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    //
    //
    //
    // write the SPNs to the DS
    //

    status = DsWriteAccountSpnW(DsHandle,
                                DS_SPN_ADD_SPN_OP,
                                VirtualFQDN,
                                spnList->SpnCount,
                                (LPCWSTR *)spnList->Spn);

    LocalFree( spnList );
    return status;
} // AddServicePrincipalNames

DWORD
SetACLOnParametersKey(
    HKEY    ParametersKey
    )

/*++

Routine Description:

    Set the ACL on the params key to allow only admin group and creator/owner
    to have access to the data

Arguments:

    ParametersKey - cluster HKEY to the netname's params key

Return Value:

    ERROR_SUCCESS if successful

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    success;

    PSECURITY_DESCRIPTOR    secDesc = NULL;

    //
    // build an SD the quick way. This gives builtin admins (local admins's
    // group), creator/owner and the service SID full access to the
    // key. Inheritance is prevented in both directions, i.e., doesn't inherit
    // from its parent nor passes the settings onto its children (of which the
    // node parameters keys are the only children).
    //
    success = ConvertStringSecurityDescriptorToSecurityDescriptor(
                  L"D:P(A;;KA;;;BA)(A;;KA;;;CO)(A;;KA;;;SU)",
                  SDDL_REVISION_1,
                  &secDesc,
                  NULL);

    if ( success  &&
         (secDesc != NULL) ) {
        status = ClusterRegSetKeySecurity(ParametersKey,
                                          DACL_SECURITY_INFORMATION,
                                          secDesc);
        LocalFree( secDesc );
    }
    else {
        if ( secDesc != NULL )
        {
            LocalFree( secDesc );
            status = GetLastError();
        }
    }

    return status;
} // SetACLOnParametersKey

HRESULT
GetComputerObjectViaFQDN(
    IN     LPWSTR               DistinguishedName,
    IN     LPWSTR               DCName              OPTIONAL,
    IN OUT IDirectoryObject **  ComputerObject
    )

/*++

Routine Description:

    for the specified distinguished name, get an IDirectoryObject pointer to
    it

Arguments:

    DistinguishedName - FQDN of object in DS to find

    DCName - optional pointer to name of DC (not domain) that we should bind to

    ComputerObject - address of pointer that receives pointer to computer object

Return Value:

    success if everything worked, otherwise....

--*/

{
    WCHAR   buffer[ 256 ];
    PWCHAR  bindingString = buffer;
    LONG    charCount;
    HRESULT hr;
    DWORD   dnLength;
    DWORD   adsFlags = ADS_SECURE_AUTHENTICATION;

    //
    // format an LDAP binding string for our distingiushed name. If DCName is
    // specified, we need to add a trailing "/".
    //
    dnLength =  (DWORD)( COUNT_OF( LdapHeader ) + wcslen( DistinguishedName ));
    if ( DCName != NULL ) {
        if ( *DCName == L'\\' && *(DCName+1) == L'\\' ) {   // skip over double backslashes
            DCName += 2;
        }

        dnLength += wcslen( DCName ) + 1;
        adsFlags |= ADS_SERVER_BIND;
    }

    if ( dnLength > COUNT_OF( buffer )) {
        bindingString = (PWCHAR)LocalAlloc( LMEM_FIXED, dnLength * sizeof( WCHAR ));
        if ( bindingString == NULL ) {
            return HRESULT_FROM_WIN32( GetLastError());
        }
    }

    wcscpy( bindingString, LdapHeader );
    if ( DCName != NULL ) {
        wcscat( bindingString, DCName );
        wcscat( bindingString, L"/" );
    }
    wcscat( bindingString, DistinguishedName );

    *ComputerObject = NULL;
    hr = ADsOpenObject(bindingString,
                       NULL,            // username
                       NULL,            // password
                       adsFlags,
                       IID_IDirectoryObject,
                       (VOID **)ComputerObject );

    if ( bindingString != buffer ) {
        LocalFree( bindingString );
    }

    if ( FAILED( hr ) && *ComputerObject != NULL ) {
        (*ComputerObject)->Release();
    }

    return hr;
} // GetComputerObjectViaFQDN

HRESULT
GetComputerObjectViaGUID(
    IN     LPWSTR               ObjectGUID,
    IN     LPWSTR               DCName              OPTIONAL,
    IN OUT IDirectoryObject **  ComputerObject
    )

/*++

Routine Description:

    for the specified object GUID, get an IDirectoryObject pointer to it

Arguments:

    ObjectGUID - GUID of object in DS to find

    DCName - optional pointer to name of DC (not domain) that we should bind to

    ComputerObject - address of pointer that receives pointer to computer object

Return Value:

    success if everything worked, otherwise....

--*/

{
    WCHAR   guidHeader[] = L"<GUID=";
    WCHAR   guidTrailer[] = L">";
    LONG    charCount;
    HRESULT hr;
    DWORD   dnLength;
    DWORD   adsFlags = ADS_SECURE_AUTHENTICATION;

    //
    // 37 = guid length 
    //
    WCHAR   buffer[ COUNT_OF( LdapHeader ) +
                    DNS_MAX_NAME_BUFFER_LENGTH +
                    COUNT_OF( guidHeader ) +
                    37 +
                    COUNT_OF( guidTrailer ) ];

    PWCHAR  bindingString = buffer;

    //
    // format an LDAP binding string for the object GUID. If DCName is
    // specified, we need to add a trailing / plus the trailing null.
    //
    ASSERT( ObjectGUID != NULL );
    dnLength =  (DWORD)( COUNT_OF( LdapHeader ) +
                         COUNT_OF( guidHeader ) +
                         COUNT_OF( guidTrailer ) +
                         wcslen( ObjectGUID ));

    if ( DCName != NULL ) {
        if ( *DCName == L'\\' && *(DCName+1) == L'\\' ) {   // skip over double backslashes
            DCName += 2;
        }

        dnLength += ( wcslen( DCName ) + 1 );
        adsFlags |= ADS_SERVER_BIND;
    }

    if ( dnLength > COUNT_OF( buffer )) {
        bindingString = (PWCHAR)LocalAlloc( LMEM_FIXED, dnLength * sizeof( WCHAR ));
        if ( bindingString == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    wcscpy( bindingString, LdapHeader );
    if ( DCName != NULL ) {
        wcscat( bindingString, DCName );
        wcscat( bindingString, L"/" );
    }

    wcscat( bindingString, guidHeader );
    wcscat( bindingString, ObjectGUID );
    wcscat( bindingString, guidTrailer );

    *ComputerObject = NULL;
    hr = ADsOpenObject(bindingString,
                       NULL,            // username
                       NULL,            // password
                       adsFlags,
                       IID_IDirectoryObject,
                       (VOID **)ComputerObject );

    if ( bindingString != buffer ) {
        LocalFree( bindingString );
    }

    if ( FAILED( hr ) && *ComputerObject != NULL ) {
        (*ComputerObject)->Release();
    }

    return hr;
} // GetComputerObjectViaGUID

DWORD
DeleteComputerObject(
    IN  PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    delete the computer object in the DS for this name.

    Not called right now since we don't have the virtual netname at this point
    in time. The name must be kept around and cleaned during close processing
    instead of offline where it is done now. This means dealing with renaming
    issues while it is offline but not getting deleted.

Arguments:

    Resource - pointer to the resource context info

Return Value:

    ERROR_SUCCESS if everything worked

--*/

{
    DWORD   status;
    WCHAR   virtualDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    HKEY    resourceKey = Resource->ResKey;
    PWSTR   virtualName = Resource->Params.NetworkName;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    PDOMAIN_CONTROLLER_INFO dcInfo;

    //
    // get the name of a writable DC
    //
    status = FindDomainForServer( resourceHandle, Resource->NodeName, NULL, DS_WRITABLE_REQUIRED, &dcInfo );

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to find a DC, status %1!u!.\n",
                          status);
        return status;
    }

    (NetNameLogEvent)(resourceHandle,
                      LOG_INFORMATION,
                      L"Using domain controller %1!ws! to delete computer account %2!ws!.\n",
                      dcInfo->DomainControllerName,
                      virtualName);

    //
    // add a $ to the end of the name
    //
    virtualDollarName[ COUNT_OF( virtualDollarName ) - 1 ] = UNICODE_NULL;
    _snwprintf( virtualDollarName, COUNT_OF( virtualDollarName ) - 1, L"%ws$", virtualName );

    status = NetUserDel( dcInfo->DomainControllerName, virtualDollarName );
    if ( status == NERR_Success ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Deleted computer account %1!ws! in domain %2!ws!.\n",
                          virtualName,
                          dcInfo->DomainName);

        ClusResLogSystemEventByKey1(resourceKey,
                                    LOG_NOISE,
                                    RES_NETNAME_COMPUTER_ACCOUNT_DELETED,
                                    dcInfo->DomainName);

        if ( Resource->ObjectGUID ) {
            LocalFree( Resource->ObjectGUID );
            Resource->ObjectGUID = NULL;
        }
    } else {
        LPWSTR  msgBuff;
        DWORD   msgBytes;

        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Unable to delete computer account %1!ws! in domain %2!ws!, status %3!u!.\n",
                          virtualName,
                          dcInfo->DomainName,
                          status);

        msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 status,
                                 0,
                                 (LPWSTR)&msgBuff,
                                 0,
                                 NULL);

        if ( msgBytes > 0 ) {

            ClusResLogSystemEventByKey2(resourceKey,
                                        LOG_UNUSUAL,
                                        RES_NETNAME_DELETE_COMPUTER_ACCOUNT_FAILED,
                                        dcInfo->DomainName,
                                        msgBuff);

            LocalFree( msgBuff );
        } else {
            ClusResLogSystemEventByKeyData1(resourceKey,
                                            LOG_UNUSUAL,
                                            RES_NETNAME_DELETE_COMPUTER_ACCOUNT_FAILED_STATUS,
                                            sizeof( status ),
                                            &status,
                                            dcInfo->DomainName);
        }
    }

    NetApiBufferFree( dcInfo );

    return status;
} // DeleteComputerObject

DWORD
NNLogonUser(
    RESOURCE_HANDLE ResourceHandle,
    LPTSTR          UserName,
    LPTSTR          DomainName,
    LPTSTR          Password,
    PHANDLE         VSToken,
    PDWORD          TokenStatus
    )

/*++

Routine Description:

    Do a network logon of the machine account credentials by generating a
    security context between the cluster service account and the machine.

    NTLM is currently used for this purpose though Kerberos should eventually
    be used. If it is changed to Kerb, then NNGetAuthenticatingDC has to be
    changed to query Kerb for its DC.

Arguments:

    ResourceHandle - used to log in cluster log

    UserName - pointer to buffer holding machine name with trailing $

    DomainName - duh....

    Password - double duh...

    VSToken - pointer which gets token handle to passed in credentials

    TokenStatus - pointer to DWORD returning status on getting token handle

Return Value:

    ERROR_SUCCESS if password is good...

--*/

{
    SECURITY_STATUS secStatus = SEC_E_OK;

    DWORD   tokenStatus = ERROR_SUCCESS;
    BOOL    success;

    CredHandle csaCredHandle = { 0, 0 };           // cluster service account
    CredHandle computerCredHandle = { 0, 0 };       // machine account

    CtxtHandle computerCtxtHandle = { 0, 0 };
    CtxtHandle csaCtxtHandle = { 0, 0 };

    ULONG contextAttributes;

    ULONG packageCount;
    ULONG packageIndex;
    PSecPkgInfo packageInfo;
    DWORD cbMaxToken = 0;

    TimeStamp ctxtLifeTime;
    SEC_WINNT_AUTH_IDENTITY authIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    PVOID computerBuffer = NULL;
    PVOID csaBuffer = NULL;

    //
    // validate parameters
    //
    if ( DomainName == NULL || UserName == NULL || Password == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

//
// << this section could be cached in a repeat caller scenario >>
//

    //
    // Get info about the security packages.
    //
    secStatus = EnumerateSecurityPackages( &packageCount, &packageInfo );
    if( secStatus != SEC_E_OK ) {
        return secStatus;
    }

    //
    // loop through the packages looking for NTLM
    //
    for(packageIndex = 0 ; packageIndex < packageCount ; packageIndex++ ) {
        if(packageInfo[packageIndex].Name != NULL) {
            if( ClRtlStrICmp(packageInfo[packageIndex].Name, NTLMSP_NAME) == 0) {
                cbMaxToken = packageInfo[packageIndex].cbMaxToken;
                break;
            }
        }
    }

    FreeContextBuffer( packageInfo );

    if( cbMaxToken == 0 ) {
        secStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

//
// << end of cached section >>
//

    //
    // Acquire an outbound (client side) credential handle for the computer
    // account
    //
    ZeroMemory( &authIdentity, sizeof(authIdentity) );

    authIdentity.Domain = DomainName;
    authIdentity.DomainLength = lstrlen(DomainName);

    authIdentity.User = UserName;
    authIdentity.UserLength = lstrlen(UserName);

    authIdentity.Password = Password;
    authIdentity.PasswordLength = lstrlen(Password);

    authIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    secStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &authIdentity,
                    NULL,
                    NULL,
                    &computerCredHandle,
                    &ctxtLifeTime
                    );

    if ( secStatus != SEC_E_OK ) {
        goto cleanup;
    }

    //
    // Acquire an inbound (server side) credential handle for the cluster
    // service account. The resulting security context will represent the
    // computer account.
    //
    secStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &csaCredHandle,
                    &ctxtLifeTime
                    );

    if ( secStatus != SEC_E_OK ) {
        goto cleanup;
    }

    //
    // allocate token buffers for the computer and CSA sides.
    //
    computerBuffer = LocalAlloc( LMEM_FIXED, cbMaxToken);

    if( computerBuffer == NULL ) {
        secStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    csaBuffer = LocalAlloc( LMEM_FIXED, cbMaxToken);

    if( csaBuffer == NULL ) {
        secStatus = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    //
    // Get the NegotiateMessage (ClientSide)
    //
    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = computerBuffer;

    secStatus = InitializeSecurityContext(
                    &computerCredHandle,
                    NULL,                       // No Client context yet
                    NULL,                       // target name
                    /* ISC_REQ_SEQUENCE_DETECT | ISC_REQ_DELEGATE */ 0,
                    0,                          // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                       // No initial input token
                    0,                          // Reserved 2
                    &computerCtxtHandle,
                    &NegotiateDesc,
                    &contextAttributes,
                    &ctxtLifeTime
                    );


    if( secStatus < 0 ) {
        goto cleanup;
    }

    //
    // Get the ChallengeMessage (ServerSide)
    //
    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = csaBuffer;


    secStatus = AcceptSecurityContext(
                    &csaCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ASC_REQ_ALLOW_NON_USER_LOGONS,    // | ASC_REQ_DELEGATE,
                    SECURITY_NATIVE_DREP,
                    &csaCtxtHandle,
                    &ChallengeDesc,
                    &contextAttributes,
                    &ctxtLifeTime
                    );


    if( secStatus < 0 ) {
        goto cleanup;
    }

    //
    // Get the AuthenticateMessage (ClientSide)
    //
    ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = computerBuffer;

    secStatus = InitializeSecurityContext(
                    NULL,
                    &computerCtxtHandle,
                    NULL,                   // target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                      // Reserved 2
                    &computerCtxtHandle,
                    &AuthenticateDesc,
                    &contextAttributes,
                    &ctxtLifeTime
                    );

    if ( secStatus < 0 ) {
        goto cleanup;
    }


    //
    // Finally authenticate the user (ServerSide)
    //
    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    secStatus = AcceptSecurityContext(
                    NULL,
                    &csaCtxtHandle,
                    &AuthenticateDesc,
                    ASC_REQ_ALLOW_NON_USER_LOGONS,  // | ASC_REQ_DELEGATE,
                    SECURITY_NATIVE_DREP,
                    &csaCtxtHandle,
                    NULL,
                    &contextAttributes,
                    &ctxtLifeTime
                    );

    //
    // now get a primary token to the virtual computer account if we were
    // successful up to this point
    //
    if ( secStatus == SEC_E_OK ) {
        if ( *VSToken != NULL ) {
            CloseHandle( *VSToken );
            *VSToken = NULL;
        }

        tokenStatus = ImpersonateSecurityContext( &csaCtxtHandle );
        if ( tokenStatus == SEC_E_OK ) {
            SECURITY_STATUS revertStatus;

            //
            // create a new primary token that represents the virtual computer
            // account
            //
            success = LogonUser(UserName,
                                DomainName,
                                Password,
                                LOGON32_LOGON_NEW_CREDENTIALS,
                                LOGON32_PROVIDER_DEFAULT,
                                VSToken);

            if ( !success ) {
                secStatus = GetLastError();
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_ERROR,
                                  L"Could not create primary token for the virtual computer account "
                                  L"associated with this resource. status %u\n",
                                  secStatus );
            }

            revertStatus = RevertSecurityContext( &csaCtxtHandle );
            if ( revertStatus != SEC_E_OK ) {
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_ERROR,
                                  L"Could not revert this thread's security context back to "
                                  L"the Cluster Service Account after acquiring a token to "
                                  L"this resource's virtual computer account - status %u. This will subsequently "
                                  L"cause different types of access denied failures when this thread  "
                                  L"is used by the resource monitor. The cluster service should be stopped "
                                  L"and restarted on this node to recover from this situation\n",
                                  revertStatus);

               tokenStatus = revertStatus;
            }
        } else {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Unable to impersonate virtual computer account - status %1!u!\n",
                              tokenStatus);
        }

        *TokenStatus = tokenStatus;
    }

cleanup:

    //
    // clean up the security contexts
    //
    if ( computerCtxtHandle.dwUpper != 0 && computerCtxtHandle.dwLower != 0 ) {
        DeleteSecurityContext( &computerCtxtHandle );
    }

    if ( csaCtxtHandle.dwUpper != 0 && csaCtxtHandle.dwLower != 0 ) {
        DeleteSecurityContext( &csaCtxtHandle );
    }

    //
    // Free credential handles
    //
    if ( csaCredHandle.dwUpper != 0 && csaCredHandle.dwLower != 0 ) {
        FreeCredentialsHandle( &csaCredHandle );
    }

    if ( computerCredHandle.dwUpper != 0 && computerCredHandle.dwLower != 0 ) {
        FreeCredentialsHandle( &computerCredHandle );
    }

    if( computerBuffer != NULL ) {
        ZeroMemory( computerBuffer, cbMaxToken );
        LocalFree( computerBuffer );
    }

    if( csaBuffer != NULL ) {
        ZeroMemory( csaBuffer, cbMaxToken );
        LocalFree( csaBuffer );
    }

    return secStatus;
} // NNLogonUser

#ifdef BUG601100

don't want to throw this code away since it might be useful in the
future. It's not clear it is needed for anything at this point. It does make
sense to restore the ACL back to its original form making the CSA the owner.

HRESULT
ResetComputerObjectSecurityDesc(
    IN  LPWSTR          DCName,
    IN  LPWSTR          VirtualName,
    IDirectoryObject *  ComputerObject
    )

/*++

Routine Description:

    Reset the security descriptor on the computer object as specified in the
    schema.

    By default, only domain level admins have this access. The SELF is not
    granted this right since this could lead to DS DoS attacks where millions
    of child objects are created. The Cluster Service Account could be given
    elevated access rights to accomplish but there are other issues involved
    like this code doesn't correctly inherit the ACEs in the parent container.

Arguments:

    VirtualName - pointer to the name of the object

Return Value:

    ERROR_SUCCESS

--*/

{
    HRESULT hr;
    IADs *  rootDSE = NULL;
    IADs *  computerSchema = NULL;
    VARIANT schemaNamingCtxt;
    VARIANT computerSchemaSDDL;
    WCHAR   computerCN[] = L"/cn=computer,";
    DWORD   pathChars;
    LPWSTR  computerSchemaPath = NULL;
    DWORD   numberModified;
    WCHAR   rootDN[] = L"/rootDSE";
    WCHAR   rootServerPath[ COUNT_OF( LdapHeader ) + DNS_MAX_NAME_BUFFER_LENGTH + COUNT_OF( rootDN ) ];

    ADSVALUE    attrValue;

    ADS_ATTR_INFO   attrInfo;

    PSECURITY_DESCRIPTOR    schemaSD = NULL;

    //
    // skip over '\\' if it is in front of the DC name
    //
    if ( *DCName == L'\\' && *(DCName+1) == L'\\' ) {
        DCName += 2;
    }

    //
    // Get rootDSE and the schema container's DN. Bind to current user's
    // domain using current user's security context.
    //
    rootServerPath[ COUNT_OF( rootServerPath ) - 1 ] = UNICODE_NULL;
    _snwprintf( rootServerPath,
                COUNT_OF( rootServerPath ) - 1,
                L"%ws%ws%ws",
                LdapHeader,
                DCName,
                rootDN);

    hr = ADsOpenObject(L"LDAP://rootDSE",
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
                       IID_IADs,
                       (void**)&rootDSE);
 
    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // get the DN to the schema
    //
    hr = rootDSE->Get( L"schemaNamingContext", &schemaNamingCtxt );
    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // build the path to the computer class schema object and get an ADs
    // pointer to it. Subtract one since COUNT_OF includes the NULL and we
    // only need to do that once. The path is of the form:
    //
    // LDAP://DCName/cn=computer,<path to computer classSchema object in schema>
    //
    pathChars = COUNT_OF( LdapHeader ) +
        wcslen( DCName ) +
        COUNT_OF( computerCN ) +
        wcslen( schemaNamingCtxt.bstrVal ) -
        1;

    computerSchemaPath = (LPWSTR)LocalAlloc( 0, pathChars * sizeof( WCHAR ));
    if ( computerSchemaPath == NULL ) {
        hr = HRESULT_FROM_WIN32( GetLastError());
        goto cleanup;
    }

    computerSchemaPath[ pathChars - 1 ] = UNICODE_NULL;
    _snwprintf(computerSchemaPath,
               pathChars - 1, 
               L"%ws%ws%ws%ws",
               LdapHeader,
               DCName,
               computerCN,
               schemaNamingCtxt.bstrVal );

    hr = ADsOpenObject(computerSchemaPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND,
                       IID_IADs,
                       (void**)&computerSchema);

    LocalFree( computerSchemaPath );

    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // now read the default security descriptor and convert it from string
    // notation to a self-relative SD
    //
    hr = computerSchema->Get( L"defaultSecurityDescriptor", &computerSchemaSDDL );
    if ( FAILED( hr )) {
        goto cleanup;
    }

    if ( computerSchemaSDDL.vt == VT_BSTR ) {
        if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(computerSchemaSDDL.bstrVal,
                                                                  SDDL_REVISION_1,
                                                                  &schemaSD,
                                                                  NULL)) {
            hr = HRESULT_FROM_WIN32( GetLastError());
        }
    } else {
        hr = E_INVALIDARG;
    }

    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // finally, set the schema SD on our object.
    //
    attrValue.dwType =                      ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attrValue.SecurityDescriptor.dwLength = GetSecurityDescriptorLength( schemaSD );
    attrValue.SecurityDescriptor.lpValue =  (LPBYTE)schemaSD;

    attrInfo.pszAttrName =      L"nTSecurityDescriptor";
    attrInfo.dwControlCode =    ADS_ATTR_UPDATE;
    attrInfo.dwADsType =        ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attrInfo.pADsValues =       &attrValue;
    attrInfo.dwNumValues =      1;

    hr = ComputerObject->SetObjectAttributes( &attrInfo, 1, &numberModified );
    if ( SUCCEEDED( hr ) && numberModified != 1 ) {
        hr = E_ADS_PROPERTY_NOT_SET;
    }

cleanup:

    VariantClear( &computerSchemaSDDL );

    if ( computerSchema ) {
        computerSchema->Release();
    }

    VariantClear( &schemaNamingCtxt );

    if ( rootDSE ) {
        rootDSE->Release();
    }

    return hr;

} // ResetComputerObjectSecurityDesc

#endif // BUG601100

DWORD
NNGetAuthenticatingDCName(
    LPWSTR *    AuthDCName
    )

/*++

Routine Description:

    get the DC that netname uses to authenticate with when generating the VS
    token. Currently, we use NTLM so this is the other end of netlogon's
    trusted connection

Arguments:

    AuthDCName - address of pointer that receives the buffer containing
                 the name (that Jack built)

Return Value:

    ERROR_SUCCESS

--*/

{
    WCHAR   trustedDomainName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PWCHAR  inputParam = trustedDomainName;
    DWORD   nameBufferSize = COUNT_OF( trustedDomainName );
    DWORD   status = ERROR_SUCCESS;
    BOOL    success;

    NET_API_STATUS  netStatus;

    PNETLOGON_INFO_2    nlInfo2;

    //
    // get our domain name
    //
    success = GetComputerNameEx(ComputerNameDnsDomain,
                                trustedDomainName,
                                &nameBufferSize);

    if ( success ) {
        netStatus = I_NetLogonControl2(NULL,        // this node
                                       NETLOGON_CONTROL_TC_QUERY,
                                       2,
                                       (LPBYTE)&inputParam,
                                       (LPBYTE *)&nlInfo2 );

        if ( netStatus == NERR_Success ) {
            *AuthDCName = ResUtilDupString( nlInfo2->netlog2_trusted_dc_name );
            NetApiBufferFree( nlInfo2 );
        } else {
            status = netStatus;
        }
    } else {
        status = GetLastError();
    }

    return status;
} // NNGetAuthenticatingDCName

//
// exported routines
//

DWORD
AddComputerObject(
    IN  PCLUS_WORKER        Worker,
    IN  PNETNAME_RESOURCE   Resource,
    OUT PWCHAR *            MachinePwd
    )

/*++

Routine Description:

    Create a computer object in the DS that is used primarily for kerb
    authentication.

Arguments:

    Worker - cluster worker thread so we can abort early if asked to do so

    Resource - pointer to netname resource context block

    MachinePwd - address of pointer to receive pointer to machine account PWD

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error

--*/

{
    DWORD   status;
    PWSTR   virtualName = Resource->Params.NetworkName;
    DWORD   virtualNameSize = wcslen( virtualName );
    PWSTR   virtualFQDN = NULL;
    HANDLE  dsHandle = NULL;
    WCHAR   virtualDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    PWCHAR  machinePwd = NULL;
    DWORD   pwdBufferByteLength = ((LM20_PWLEN + 1) * sizeof( WCHAR ));
    DWORD   pwdBufferCharLength = LM20_PWLEN + 1;
    DWORD   paramInError = 0;
    BOOL    deleteObjectOnFailure = FALSE;      // only delete the CO if we create it
    HRESULT hr = S_OK;
    BOOL    objectExists = FALSE;
    DWORD   addtlErrTextID;
    PWCHAR  dcName = NULL;
    DWORD   dsFlags = DS_PDC_REQUIRED | DS_WRITABLE_REQUIRED;

    USER_INFO_1     netUI1;
    PUSER_INFO_20   netUI20 = NULL;
    USER_INFO_1003  netUI1003;

    RESOURCE_HANDLE     resourceHandle = Resource->ResourceHandle;
    IDirectoryObject *  compObj = NULL;

    PDOMAIN_CONTROLLER_INFO dcInfo = NULL;

    //
    // Time to choose a DC. The order of preference is: PDC, authenticating
    // DC, any DC. This strategy centers around how computer/machine account
    // passwords are handled with the goal being to increase the chances that
    // genearting a token for the virtual computer account will succeed.
    //
    // Just like user accounts, if a logon attempt fails at the authenticating
    // DC, the logon is forwarded to the PDC. If it has the correct password,
    // the logon succeeds. Unlike user accounts, password changes for machine
    // accounts are not automatically forwarded to the PDC. Hence we favor the
    // PDC when selecting the DC on which to either create or update the
    // computer object.
    //
    // This strategy breaks down when the computer object doesn't exist in the
    // domain or more specifically, the authenticating DC. That DC will not
    // forward the logon request if it can't find the object in its SAM. For
    // that reason, getting a token for the virtual computer account is not
    // considered a failure during online. If one is requested later on, the
    // logon attempt will be retried. Replication of the object and discovery
    // by netlogon takes about 15 seconds so this shouldn't be that big of a
    // problem.
    //
    (NetNameLogEvent)(resourceHandle,
                      LOG_INFORMATION,
                      L"Searching the PDC for existing computer account %1!ws!.\n",
                      virtualName);

    while ( TRUE ) {
        LPWSTR  hostingDCName = NULL;
        LPWSTR  searchDCName;

        //
        // if we've tried the PDC and the auth DC, set our search routine to
        // search the domain and not a specific DC
        //
        if (( dsFlags & DS_PDC_REQUIRED ) == 0 && dcName == NULL ) {
            searchDCName = NULL;
            status = ERROR_SUCCESS;
        } else {
            //
            // we have a specific DC in mind; look up its info
            //
            status = FindDomainForServer(resourceHandle,
                                         Resource->NodeName,
                                         dcName,
                                         dsFlags,
                                         &dcInfo );

            if ( status == ERROR_SUCCESS ) {
                searchDCName = dcInfo->DomainControllerName;
            }
        }

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;
            goto cleanup;
        }

        if ( status == ERROR_SUCCESS ) {
            hr = IsComputerObjectInDS(resourceHandle,
                                      Resource->NodeName,
                                      virtualName,
                                      searchDCName,
                                      &objectExists,
                                      &virtualFQDN,
                                      &hostingDCName);

            if ( FAILED( hr )) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_WARNING,
                                  L"Search for existing computer account failed. status %1!08X!\n",
                                  hr);
            }
        } // if DC lookup was successful
        else {
            if ( dsFlags & DS_PDC_REQUIRED ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_WARNING,
                                  L"Couldn't get information about PDC. status %1!u!\n",
                                  status);
            }
            else if ( dcName != NULL ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_WARNING,
                                  L"Couldn't get information about authenticating DC %1!ws!. status %2!u!\n",
                                  dcName,
                                  status);
            }
            else {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Couldn't get information about any DC in the domain. status %1!u!\n",
                                  status);
            }
        }

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;

            if ( hostingDCName ) {
                LocalFree( hostingDCName );
            }

            goto cleanup;
        }

        if ( SUCCEEDED( hr ) && objectExists ) {
            //
            // object is on a DC; if this was a general domain wide search,
            // then get this DC's information
            //
            if ( searchDCName == NULL ) {
                status = FindDomainForServer(resourceHandle,
                                             Resource->NodeName,
                                             hostingDCName,
                                             dsFlags,
                                             &dcInfo );
            }

            LocalFree( hostingDCName );

            break;
        }

        if ( dsFlags & DS_PDC_REQUIRED ) {

            //
            // not on PDC; look up authenticating DC and try that. If we
            // can't get the auth DC, then just search the domain
            //
            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"Computer account %1!ws! not found on PDC.\n",
                              virtualName);

            dsFlags &= ~DS_PDC_REQUIRED;
            if ( dcInfo != NULL ) {
                NetApiBufferFree( dcInfo );
                dcInfo = NULL;
            }

            status = NNGetAuthenticatingDCName( &dcName );
            if ( status == ERROR_SUCCESS ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_INFORMATION,
                                  L"Searching %1!ws! for existing computer account %2!ws!.\n",
                                  dcName,
                                  virtualName);

            } else {
                //
                // couldn't get auth DC name; skip to looking in the whole domain
                //
                dcName = NULL;
                (NetNameLogEvent)(resourceHandle,
                                  LOG_WARNING,
                                  L"Couldn't get name of authenticating DC (status %1!u!). "
                                  L"Performing domain wide search.\n",
                                  status);
            }
        }
        else if ( dcName != NULL ) {

            //
            // not on the auth DC; try just the domain
            //
            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"Computer account %1!ws! not found on DC %2!ws!. Performing "
                              L"domain wide search.\n",
                              virtualName,
                              dcName);

            if ( dcInfo != NULL ) {
                NetApiBufferFree( dcInfo );
                dcInfo = NULL;
            }

            LocalFree( dcName );
            dcName = NULL;
        }
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"Computer account %1!ws! does not exist in this domain.\n",
                              virtualName);

            break;
        }

    } // end of while TRUE

    if ( ClusWorkerCheckTerminate( Worker )) {
        status = ERROR_OPERATION_ABORTED;
        goto cleanup;
    }

    if ( !objectExists ) {
        //
        // couldn't find object anywhere so we need to pick a DC on which to
        // create the object. Our preference is the PDC, then the auth DC,
        // then any DC.
        //
        status = FindDomainForServer(resourceHandle,
                                     Resource->NodeName,
                                     NULL,
                                     DS_PDC_REQUIRED | DS_WRITABLE_REQUIRED,
                                     &dcInfo );

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_WARNING,
                              L"Failed to find the PDC in this domain. status %1!u!\n", 
                              status );

            status = NNGetAuthenticatingDCName( &dcName );
            if ( status == ERROR_SUCCESS ) {
                //
                // got the auth DC name; get its info
                //
                status = FindDomainForServer(resourceHandle,
                                             Resource->NodeName,
                                             dcName,
                                             DS_WRITABLE_REQUIRED,
                                             &dcInfo );
                LocalFree( dcName );
                dcName = NULL;

            } // else couldn't get auth DC name

            if ( status != ERROR_SUCCESS ) {
                //
                // find any DC out there
                //
                status = FindDomainForServer(resourceHandle,
                                             Resource->NodeName,
                                             NULL,
                                             DS_WRITABLE_REQUIRED,
                                             &dcInfo );
                    
            } // else was able to get auth DC info

        }  // else PDC info was available

    } // else an existing object was found 

    if ( status != ERROR_SUCCESS ) {
        LPWSTR  msgBuff;
        DWORD   msgBytes;

        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Failed to find a suitable DC in this domain. status %1!u!\n", 
                          status );

        msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 status,
                                 0,
                                 (LPWSTR)&msgBuff,
                                 0,
                                 NULL);

        if ( msgBytes > 0 ) {
            ClusResLogSystemEventByKey1(Resource->ResKey,
                                        LOG_CRITICAL,
                                        RES_NETNAME_NO_WRITEABLE_DC,
                                        msgBuff);

            LocalFree( msgBuff );
        } else {
            ClusResLogSystemEventByKeyData(Resource->ResKey,
                                           LOG_CRITICAL,
                                           RES_NETNAME_NO_WRITEABLE_DC_STATUS,
                                           sizeof( status ),
                                           &status);
        }

        goto cleanup;

    } // else we found a suitable DC

    //
    // bind to the DS on this DC
    //
    status = DsBindW( dcInfo->DomainControllerName, NULL, &dsHandle );
    if ( status != NO_ERROR ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Failed to bind to DC %1!ws!, status %2!u!\n", 
                          dcInfo->DomainControllerName,
                          status );

        addtlErrTextID = RES_NETNAME_DC_BIND_FAILED;
        goto cleanup;
    }

    if ( ClusWorkerCheckTerminate( Worker )) {
        status = ERROR_OPERATION_ABORTED;
        goto cleanup;
    }

    (NetNameLogEvent)(resourceHandle,
                      LOG_INFORMATION,
                      L"Using domain controller %1!ws!.\n",
                      dcInfo->DomainControllerName);

    //
    // initialize the user's pwd buffer and get a buffer to hold the machine
    // Pwd
    //
    *MachinePwd = NULL;
    machinePwd = (PWCHAR)LocalAlloc( LMEM_FIXED, pwdBufferByteLength );
    if ( machinePwd == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to allocate memory for resource data. status %1!u!.\n",
                          status);

        addtlErrTextID = RES_NETNAME_RESDATA_ALLOC_FAILED;
        goto cleanup;
    }

    //
    // generate a random stream of bytes for the password
    //
    status = GenerateRandomBytes( machinePwd, pwdBufferCharLength );
    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to generate password. status %1!u!.\n",
                          status);

        addtlErrTextID = RES_NETNAME_PASSWORD_UPDATE_FAILED;
        goto cleanup;
    }

    //
    // set the ACL on the parameters key to contain just the cluster
    // service account since we're about to store sensitive info in there.
    //
    status = SetACLOnParametersKey( Resource->ParametersKey );
    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to set permissions on resource's parameters key. status %1!u!\n",
                          status );

        addtlErrTextID = RES_NETNAME_PARAMS_KEY_PERMISSION_UPDATE_FAILED;
        goto cleanup;
    }

    //
    // take our new password, encrypt it and store it in the cluster
    // registry
    //
    if ( Resource->Params.ResourceData != NULL ) {
        LocalFree( Resource->Params.ResourceData );
        Resource->Params.ResourceData = NULL;
    }

    status = EncryptNNResourceData(Resource,
                                   machinePwd,
                                   &Resource->Params.ResourceData,
                                   &Resource->ResDataSize);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to store resource data. status %1!u!\n",
                          status );

        addtlErrTextID = RES_NETNAME_RESDATA_STORE_FAILED;
        goto cleanup;
    }

#ifdef PASSWORD_ROTATION
    //
    // record when it is time to rotate the pwd; per MSDN, convert to
    // ULARGE Int and add in the update interval.
    //
    GetSystemTimeAsFileTime( &Resource->Params.NextUpdate );
    updateTime.LowPart = Resource->Params.NextUpdate.dwLowDateTime;
    updateTime.HighPart = Resource->Params.NextUpdate.dwHighDateTime;
    updateTime.QuadPart += ( Resource->Params.UpdateInterval * 60 * 1000 * 100 );
    Resource->Params.NextUpdate.dwLowDateTime = updateTime.LowPart;
    Resource->Params.NextUpdate.dwHighDateTime = updateTime.HighPart;

    setValueStatus = ResUtilSetBinaryValue(Resource->ParametersKey,
                                           PARAM_NAME__NEXT_UPDATE,
                                           (const LPBYTE)&updateTime,  
                                           sizeof( updateTime ),
                                           NULL,
                                           NULL);

    if ( setValueStatus != ERROR_SUCCESS ) {
        status = setValueStatus;
        goto cleanup;
    }
#endif

    //
    // identify this as a machine account by adding a $ to the end of the name.
    //
    virtualDollarName[ COUNT_OF( virtualDollarName ) - 1 ] = UNICODE_NULL;
    _snwprintf( virtualDollarName, COUNT_OF( virtualDollarName ) - 1, L"%ws$", virtualName );

    if ( objectExists ) {
        //
        // found an object; see if it is enabled and whether we can hijack it.
        //
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Found existing computer account %1!ws! on DC %2!ws!.\n",
                          virtualName,
                          dcInfo->DomainControllerName);

        //
        // check if the account is disabled
        //
        status = NetUserGetInfo(dcInfo->DomainControllerName,
                                virtualDollarName,
                                20,
                                (LPBYTE *)&netUI20);

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;
            goto cleanup;
        }

        if ( status == NERR_Success ) {
            if ( netUI20->usri20_flags & UF_ACCOUNTDISABLE ) {
                USER_INFO_1008  netUI1008;

                //
                // try to re-enable; fail if we can't
                //
                netUI1008.usri1008_flags = netUI20->usri20_flags & ~UF_ACCOUNTDISABLE;
                status = NetUserSetInfo(dcInfo->DomainControllerName,
                                        virtualDollarName,
                                        1008,
                                        (LPBYTE)&netUI1008,
                                        &paramInError);

                if ( status != NERR_Success ) {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Computer account %1!ws! is disabled and couldn't be re-enabled. "
                                      L"status %2!u!\n",
                                      virtualName,
                                      status);

                    addtlErrTextID = RES_NETNAME_CO_CANT_BE_REENABLED;
                }
            }

            NetApiBufferFree( netUI20 );
            netUI20 = NULL;

            if ( status != NERR_Success ) {
                goto cleanup;
            }
        } else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_WARNING,
                              L"Couldn't determine if computer account %1!ws! "
                              L"is disabled. status %2!u!\n",
                              virtualName,
                              status);
        }

        //
        // set the password on the computer object
        //
        netUI1003.usri1003_password   = (PWCHAR)machinePwd;
        status = NetUserSetInfo(dcInfo->DomainControllerName,
                                virtualDollarName,
                                1003,
                                (PBYTE)&netUI1003,
                                &paramInError );

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;
            goto cleanup;
        }

        if ( status != NERR_Success ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to update password for computer account "
                              L"%1!ws! on DC %2!ws!, status %3!u!.\n",
                              virtualName,
                              dcInfo->DomainControllerName,
                              status);

            addtlErrTextID = RES_NETNAME_CO_PASSWORD_UPDATE_FAILED;
            goto cleanup;
        }
    }
    else {
        //
        // the computer account doesn't exist in the DS. Create it.
        //
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Failed to find a computer account for "
                          L"%1!ws! on DC %2!ws!. Attempting to create one.\n",
                          virtualName,
                          dcInfo->DomainControllerName);

        //
        // create the computer object (machine account).
        //
        RtlZeroMemory( &netUI1, sizeof( netUI1 ) );
        netUI1.usri1_password   = (PWCHAR)machinePwd;
        netUI1.usri1_priv       = USER_PRIV_USER;
        netUI1.usri1_name       = virtualDollarName;
        netUI1.usri1_flags      = UF_WORKSTATION_TRUST_ACCOUNT | UF_SCRIPT;
        netUI1.usri1_comment    = NetNameCompObjAccountDesc;

        status = NetUserAdd( dcInfo->DomainControllerName, 1, (PBYTE)&netUI1, &paramInError );

        if ( status == NERR_Success ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"Created computer account %1!ws! on DC %2!ws!.\n",
                              virtualName,
                              dcInfo->DomainControllerName);

            deleteObjectOnFailure = TRUE;
        } // if NetUserAdd was successful
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to create computer account %1!ws! on DC %2!ws!, "
                              L"status %3!u! (paramInError: %4!u!)\n",
                              virtualName,
                              dcInfo->DomainControllerName,
                              status,
                              paramInError);

            addtlErrTextID = RES_NETNAME_CREATE_CO_FAILED;
            goto cleanup;
        }

        //
        // get the FQDN for setting attributes
        //
        hr = IsComputerObjectInDS( resourceHandle,
                                   Resource->NodeName,
                                   virtualName,
                                   dcInfo->DomainControllerName,
                                   &objectExists,
                                   &virtualFQDN,
                                   NULL);

        if ( FAILED( hr ) || !objectExists ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to get LDAP distinguished name for computer account %1!ws! "
                              L"on DC %2!ws!, status %3!08X!.\n",
                              virtualName,
                              dcInfo->DomainControllerName,
                              hr);

            addtlErrTextID = RES_NETNAME_GET_LDAP_NAME_FAILED;
            status = hr;
            goto cleanup;
        }
    }

    //
    // use the Object GUID for binding during CheckComputerObjectAttributes so
    // we don't have to track changes to the DN. If the object is moved in the
    // DS, its DN will change but not its GUID. We use this code instead of
    // GetComputerObjectGuid because we need to target a specific DC.
    //
    {
        IADs *  pADs = NULL;

        hr = GetComputerObjectViaFQDN( virtualFQDN, dcInfo->DomainControllerName, &compObj );
        if ( SUCCEEDED( hr )) {
            hr = compObj->QueryInterface(IID_IADs, (void**) &pADs);
            if ( SUCCEEDED( hr )) {
                BSTR    guidStr = NULL;

                hr = pADs->get_GUID( &guidStr );
                if ( SUCCEEDED( hr )) {
                    if ( Resource->ObjectGUID != NULL ) {
                        LocalFree( Resource->ObjectGUID );
                        Resource->ObjectGUID = NULL;
                    }

                    Resource->ObjectGUID = ResUtilDupString( guidStr );
                    if ( Resource->ObjectGUID == NULL ) {
                        hr = HRESULT_FROM_WIN32( GetLastError());
                    }
                }
                else {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Failed to get object GUID for computer account %1!ws!, "
                                      L"status %2!08X!\n",
                                      virtualName,
                                      hr );
                }

                if ( guidStr ) {
                    SysFreeString( guidStr );
                }
            }

            if ( pADs != NULL ) {
                pADs->Release();
            }

            if ( FAILED( hr )) {
                addtlErrTextID = RES_NETNAME_GET_CO_GUID_FAILED;
                status = hr;
                goto cleanup;
            }
        }
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Failed to obtain access to computer account %1!ws!, status %2!08X!\n",
                              virtualName,
                              hr );

            status = hr;
            addtlErrTextID = RES_NETNAME_GET_CO_POINTER_FAILED;
            goto cleanup;
        }
    }

    //
    // add the DnsHostName and ServicePrincipalName attributes
    //
    hr = AddDnsHostNameAttribute( resourceHandle, compObj, virtualName, FALSE );

    if ( FAILED( hr )) {
        status = hr;
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to set DnsHostName attribute for computer account "
                          L"%1!ws!, status %2!08X!.\n",
                          virtualName,
                          hr);

        addtlErrTextID = RES_NETNAME_DNSHOSTNAME_UPDATE_FAILED;
        goto cleanup;
    }

    if ( ClusWorkerCheckTerminate( Worker )) {
        status = ERROR_OPERATION_ABORTED;
        goto cleanup;
    }

    status = AddServicePrincipalNames( dsHandle,
                                       virtualFQDN,
                                       virtualName,
                                       dcInfo->DomainName,
                                       Resource->dwFlags & CLUS_FLAG_CORE );

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to set ServicePrincipalName attribute for computer account "
                          L"%1!ws!, status %2!u!.\n",
                          virtualName,
                          status);

        addtlErrTextID = RES_NETNAME_SPN_UPDATE_FAILED;
        goto cleanup;
    }

    //
    // store the name of our creating DC in that property and make a copy for
    // the online parameters block
    //
    if ( Resource->Params.CreatingDC != NULL ) {
        //
        // this shouldn't be the case, but it will avoid mem leaks
        //
        LocalFree( Resource->Params.CreatingDC );
    }

    Resource->Params.CreatingDC = ResUtilDupString( dcInfo->DomainControllerName );
    if ( Resource->Params.CreatingDC == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to allocate memory for CreatingDC property, status %1!u!.\n",
                          status);

        addtlErrTextID = RES_NETNAME_CREATINDC_ALLOC_FAILED;
        goto cleanup;
    }

    status = ResUtilSetSzValue(Resource->ParametersKey,
                               PARAM_NAME__CREATING_DC,
                               Resource->Params.CreatingDC,
                               NULL);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to set CreatingDC property, status %1!u!.\n",
                          status);

        addtlErrTextID = RES_NETNAME_CREATINGDC_UPDATE_FAILED;
        goto cleanup;
    }

cleanup:
    //
    // always free these
    //
    if ( dsHandle != NULL ) {
        DsUnBind( &dsHandle );
    }

    if ( compObj != NULL ) {
        compObj->Release();
    }

    if ( virtualFQDN != NULL ) {
        LocalFree( virtualFQDN );
    }

    if ( dcName != NULL ) {
        LocalFree( dcName );
    }

    if ( netUI20 != NULL ) {
        NetApiBufferFree( netUI20 );
    }

    if ( status == ERROR_SUCCESS ) {
        *MachinePwd = machinePwd;
    } else {
        if ( status != ERROR_OPERATION_ABORTED ) {
            LPWSTR  msgBuff;
            DWORD   msgBytes;
            LPWSTR  addtlErrText;
            LPWSTR  domainName;
            WCHAR   domainNameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
            DWORD   domainNameChars = COUNT_OF( domainNameBuffer );
            BOOL    success;

            msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_FROM_SYSTEM,
                                     NULL,
                                     status,
                                     0,
                                     (LPWSTR)&msgBuff,
                                     0,
                                     NULL);

            //
            // get the additional error text to go with the generic failed message
            //
            addtlErrText = ClusResLoadMessage( addtlErrTextID );

            success = GetComputerNameEx(ComputerNameDnsDomain,
                                        domainNameBuffer,
                                        &domainNameChars);

            if ( success ) {
                domainName = domainNameBuffer;
            }
            else {
                domainName = NULL;
            }

            if ( msgBytes > 0 ) {
                ClusResLogSystemEventByKey3(Resource->ResKey,
                                            LOG_CRITICAL,
                                            RES_NETNAME_ADD_COMPUTER_ACCOUNT_FAILED,
                                            domainName,
                                            addtlErrText,
                                            msgBuff);

                LocalFree( msgBuff );
            } else {
                ClusResLogSystemEventByKeyData2(Resource->ResKey,
                                                LOG_CRITICAL,
                                                RES_NETNAME_ADD_COMPUTER_ACCOUNT_FAILED_STATUS,
                                                sizeof( status ),
                                                &status,
                                                domainName,
                                                addtlErrText);
            }

            if ( addtlErrText ) {
                LocalFree( addtlErrText );
            }
        }

        if ( machinePwd != NULL ) {
            RtlSecureZeroMemory( machinePwd, pwdBufferByteLength );
            LocalFree( machinePwd );
        }

        if ( Resource->Params.ResourceData ) {
            DWORD   deleteStatus;

            RemoveNNCryptoCheckpoint( Resource );

            deleteStatus = ClusterRegDeleteValue(Resource->ParametersKey,
                                                 PARAM_NAME__RESOURCE_DATA);

            if ( deleteStatus != ERROR_SUCCESS && deleteStatus != ERROR_FILE_NOT_FOUND ) {
                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_ERROR,
                                  L"Unable to clear the "
                                  PARAM_NAME__RESOURCE_DATA
                                  L" property. status %1!u!\n",
                                  deleteStatus );
            }

            LocalFree( Resource->Params.ResourceData );
            Resource->Params.ResourceData = NULL;
        }

        if ( Resource->Params.CreatingDC ) {
            DWORD   deleteStatus;

            deleteStatus = ClusterRegDeleteValue(Resource->ParametersKey,
                                                 PARAM_NAME__CREATING_DC);

            if ( deleteStatus != ERROR_SUCCESS && deleteStatus != ERROR_FILE_NOT_FOUND ) {
                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_ERROR,
                                  L"Unable to clear the "
                                  PARAM_NAME__CREATING_DC
                                  L" property. status %1!u!\n",
                                  deleteStatus );
            }

            LocalFree( Resource->Params.CreatingDC );
            Resource->Params.CreatingDC = NULL;
        }

        if ( deleteObjectOnFailure ) {
            //
            // only delete the object if we created it. It is possible that
            // the name was online at one time and the object was properly
            // created allowing additional information/SPNs to be registered
            // with the CO. For this reason, we shouldn't undo the work done
            // by other applications.
            //
            DeleteComputerObject( Resource );
        }
    }

    if ( dcInfo != NULL ) {
        NetApiBufferFree( dcInfo );
    }

    return status;
} // AddComputerObject

DWORD
UpdateComputerObject(
    IN  PCLUS_WORKER        Worker,
    IN  PNETNAME_RESOURCE   Resource,
    OUT PWCHAR *            MachinePwd
    )

/*++

Routine Description:

    Check the status of our existing computer object in the DS, i.e., make
    sure that nothing has happened to it.

Arguments:

    Worker - cluster worker thread so we can abort early if asked to do so

    Resource - pointer to netname resource context block

    MachinePwd - address of pointer to receive pointer to machine account PWD

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error

--*/

{
    DWORD   status;
    PWSTR   virtualName = Resource->Params.NetworkName;
    PWSTR   virtualFQDN = NULL;
    HANDLE  dsHandle = NULL;
    WCHAR   virtualDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    PWCHAR  machinePwd = NULL;
    DWORD   pwdBufferByteLength = ((LM20_PWLEN + 1) * sizeof( WCHAR ));
    DWORD   paramInError = 0;
    BOOL    objectFound = FALSE;
    HRESULT hr;
    DWORD   addtlErrTextID;
    DWORD   tokenStatus;
    BOOL    success;
    PWCHAR  hostingDCName = NULL;

    PUSER_INFO_20   netUI20 = NULL;
    USER_INFO_1003  netUI1003;

    RESOURCE_HANDLE     resourceHandle = Resource->ResourceHandle;
    IDirectoryObject *  compObj = NULL;

    PDOMAIN_CONTROLLER_INFO dcInfo = NULL;


    *MachinePwd = NULL;

    //
    // find the object in the domain
    //
    hr = IsComputerObjectInDS(resourceHandle,
                              Resource->NodeName,
                              virtualName,
                              NULL,
                              &objectFound,
                              &virtualFQDN,
                              &hostingDCName);

    if ( SUCCEEDED( hr )) {
        if ( !objectFound ) {
            //
            // couldn't find object anywhere in the DS; let's specifically
            // retry on the creating DC in the event it was overlooked
            //
            (NetNameLogEvent)(resourceHandle,
                              LOG_WARNING,
                              L"Computer account %1!ws! could not be found on the available "
                              L"domain controllers. Checking the DC where the object was "
                              L"created.\n",
                              virtualName);

            hostingDCName = Resource->Params.CreatingDC;
            hr = IsComputerObjectInDS(resourceHandle,
                                      Resource->NodeName,
                                      virtualName,
                                      hostingDCName,
                                      &objectFound,
                                      &virtualFQDN,
                                      NULL);

            if ( SUCCEEDED( hr )) {
                if ( !objectFound ) {

                    //
                    // something's amiss. Our object should be on the creating
                    // DC node but it's not. Fail and log a message to the
                    // system event log.
                    //
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Unable to find computer account %1!ws! on DC %2!ws! where it was "
                                      L"created.\n",
                                      virtualName,
                                      hostingDCName);

                    status = ERROR_DS_OBJ_NOT_FOUND;
                    addtlErrTextID = RES_NETNAME_MISSING_CO;
                    goto cleanup;
                }
            } // if the search succeeded
            else {
                //
                // search on creating DC failed. assume it is not available.
                //
                (NetNameLogEvent)(resourceHandle,
                                  LOG_WARNING,
                                  L"Search for computer account %1!ws! on DC %2!ws! "
                                  L"failed. status %3!08X!.\n",
                                  virtualName,
                                  hostingDCName,
                                  hr);
            }
        } // end: the object wasn't found

    } // if the domain wide search succeeded
    else {
        //
        // our domain wide search failed - continue on
        //
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Domain wide search for computer account %1!ws! failed. status %2!08X!.\n",
                          virtualName,
                          hr);
    }

    //
    // get a buffer to hold the machine Pwd
    //
    machinePwd = (PWCHAR)LocalAlloc( LMEM_FIXED, pwdBufferByteLength );
    if ( machinePwd == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to allocate memory for resource data. status %1!u!.\n",
                          status);

        addtlErrTextID = RES_NETNAME_RESDATA_ALLOC_FAILED;
        goto cleanup;
    }

    //
    // Extract the password from the ResourceData property.
    //
    ASSERT( Resource->Params.ResourceData != NULL );
    status = DecryptNNResourceData(Resource,
                                   Resource->Params.ResourceData,
                                   Resource->ResDataSize,
                                   machinePwd);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to decrypt resource data. status %1!u!\n",
                          status );

        addtlErrTextID = RES_NETNAME_DECRYPT_RESDATA_FAILED;
        goto cleanup;
    }

    if ( !objectFound ) {
        //
        // no point in proceeding with the rest of the routine since we don't
        // have an object on which to check the attributes and trying to
        // generate a token is going to fail (most likely).
        //
        goto cleanup;
    }

    //
    // get info about our selected DC and bind to its DS
    //
    (NetNameLogEvent)(resourceHandle,
                      LOG_INFORMATION,
                      L"Found computer account %1!ws! on domain controller %2!ws!.\n",
                      virtualName,
                      hostingDCName);

    status = FindDomainForServer( resourceHandle, Resource->NodeName, hostingDCName, 0, &dcInfo );

    if ( ClusWorkerCheckTerminate( Worker )) {
        status = ERROR_OPERATION_ABORTED;
        goto cleanup;
    }

    if ( status == ERROR_SUCCESS ) {
        status = DsBindW( dcInfo->DomainControllerName, NULL, &dsHandle );
        if ( status != NO_ERROR ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_WARNING,
                              L"Unable to bind to domain controller %1!ws! (status %2!u!). "
                              L"Cannot proceed with computer account attribute check.\n",
                              hostingDCName,
                              status);

        }
    }
    else {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Unable to get information about domain controller %1!ws! "
                          L"(status %2!u!). Cannot proceed with computer account attribute "
                          L"check.\n",
                          hostingDCName,
                          status);
    }

    if ( status != ERROR_SUCCESS ) {
        //
        // we couldn't get the DC info or we couldn't bind - non-fatal
        //
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // add a $ to the end of the name. I don't know why we need to do this;
    // computer accounts have always had a $ at the end.
    //
    virtualDollarName[ COUNT_OF( virtualDollarName ) - 1 ] = UNICODE_NULL;
    _snwprintf( virtualDollarName, COUNT_OF( virtualDollarName ) - 1, L"%ws$", virtualName );

    //
    // now check if it is disabled
    //
    status = NetUserGetInfo(dcInfo->DomainControllerName,
                            virtualDollarName,
                            20,
                            (LPBYTE *)&netUI20);

    if ( ClusWorkerCheckTerminate( Worker )) {
        status = ERROR_OPERATION_ABORTED;
        goto cleanup;
    }

    if ( status == NERR_Success ) {
        if ( netUI20->usri20_flags & UF_ACCOUNTDISABLE ) {
            USER_INFO_1008  netUI1008;

            //
            // try to re-enable; fail if we can't. Kerb on W2K will continue
            // to give out tickets to disabled objects. In order to perform
            // updates on the object, it needs to be enabled.
            //
            netUI1008.usri1008_flags = netUI20->usri20_flags & ~UF_ACCOUNTDISABLE;
            status = NetUserSetInfo(dcInfo->DomainControllerName,
                                    virtualDollarName,
                                    1008,
                                    (LPBYTE)&netUI1008,
                                    &paramInError);

            if ( status != NERR_Success ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Computer account %1!ws! is disabled and couldn't be re-enabled. "
                                  L"status %2!u!\n",
                                  virtualName,
                                  status);

                addtlErrTextID = RES_NETNAME_CO_CANT_BE_REENABLED;
            }
        } // else the CO was enabled

        NetApiBufferFree( netUI20 );
        netUI20 = NULL;

        if ( status != NERR_Success ) {
            goto cleanup;
        }
    } else {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Couldn't determine if computer account %1!ws! "
                          L"is already disabled. status %2!u!\n",
                          virtualName,
                          status);
    }

    //
    // see if our password is good by trying to do a network logon with this
    // account. Get a token while we're at it.
    //
    status = NNLogonUser(resourceHandle,
                         virtualDollarName,
                         dcInfo->DomainName,
                         machinePwd,
                         &Resource->VSToken,
                         &tokenStatus);

    if ( status == SEC_E_LOGON_DENIED ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Password for computer account %1!ws! is incorrect "
                          L"(status 0x%2!08X!). Updating computer account with "
                          L"stored password.\n",
                          virtualName,
                          status);

        //
        // now we need the PDC in write mode; rebind (if necessary). If that
        // fails, fall back to the authenticating DC. See comments in
        // AddComputerObject about choosing a DC.
        //
        if (( dcInfo->Flags & DS_WRITABLE_FLAG ) == 0 || ( dcInfo->Flags & DS_PDC_FLAG ) == 0 ) {
            LPWSTR  dcName = NULL;
            DWORD   nlStatus;
            DWORD   dsFlags = DS_PDC_REQUIRED | DS_WRITABLE_REQUIRED;

            DsUnBind( &dsHandle );
            dsHandle = NULL;

            NetApiBufferFree( dcInfo );
            dcInfo = NULL;

        retry_dc_search:
            status = FindDomainForServer( resourceHandle,
                                          Resource->NodeName,
                                          dcName,
                                          dsFlags,
                                          &dcInfo );

            if ( status != ERROR_SUCCESS ) {

                if ( dsFlags & DS_PDC_REQUIRED ) {

                    //
                    // retry with authenticating DC. remove the PDC flag so if
                    // we fail again, we'll fall through to the bailout case
                    //
                    nlStatus = NNGetAuthenticatingDCName( &dcName );
                    if ( nlStatus == ERROR_SUCCESS ) {

                        dsFlags &= ~DS_PDC_REQUIRED;

                        (NetNameLogEvent)(resourceHandle,
                                          LOG_WARNING,
                                          L"Unable to find the PDC in the domain (status: %1!u!). "
                                          L"retying with the authenticating DC (%2!ws!).\n",
                                          status,
                                          dcName);

                        goto retry_dc_search;
                    }
                    else {
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"Unable to determine the name of the authenticating DC, status %1!u!.\n",
                                          nlStatus);
                    }
                } // else couldn't find the PDC and NL's DC wasn't available

                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"No domain controller available to update password for computer "
                                  L"account %1!ws!, status %2!u!.\n",
                                  virtualName,
                                  status);
            } // else found the PDC

            if ( dcName != NULL ) {
                LocalFree( dcName );
            }
        } // else DC we had was PDC and writable
        else {
            status = ERROR_SUCCESS;
        }

        if ( status != ERROR_SUCCESS ) {
            //
            // we lost our original DC and we couldn't get one to the PDC or
            // the auth DC and the password doesn't work. bail out.
            //
            addtlErrTextID = RES_NETNAME_NO_DC_FOR_PASSWORD_UPDATE;
            goto cleanup;
        }

        //
        // if the DC handling the update is different from the original
        // creator, then it becomes the new synchronization DC while waiting
        // for attribute changes to replicate.
        //
        if ( ClRtlStrICmp( dcInfo->DomainControllerName, Resource->Params.CreatingDC ) != 0 ) {
            LPWSTR  newDCName;

            newDCName = ResUtilDupString( dcInfo->DomainControllerName );
            if ( newDCName == NULL ) {
                status = GetLastError();
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Unable to allocate memory for CreatingDC property value, "
                                  L"status %1!u!.\n",
                                  status);

                addtlErrTextID = RES_NETNAME_CREATINDC_ALLOC_FAILED;
                goto cleanup;
            }

            status = ResUtilSetSzValue(Resource->ParametersKey,
                                       PARAM_NAME__CREATING_DC,
                                       newDCName,
                                       NULL);

            if ( status != ERROR_SUCCESS ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Unable to set CreatingDC property, status %1!u!.\n",
                                  status);

                addtlErrTextID = RES_NETNAME_CREATINGDC_UPDATE_FAILED;
                LocalFree( newDCName );
                goto cleanup;
            }

            //
            // successfully committed change to cluster hive, now update the
            // resource struct
            //
            LocalFree( Resource->Params.CreatingDC );
            Resource->Params.CreatingDC = newDCName;

        } // else the DC we are using is the original creating DC

        //
        // try setting our password on the object
        //
        netUI1003.usri1003_password   = (PWCHAR)machinePwd;
        status = NetUserSetInfo(dcInfo->DomainControllerName,
                                virtualDollarName,
                                1003,
                                (PBYTE)&netUI1003,
                                &paramInError );

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;
            goto cleanup;
        }

        if ( status == NERR_Success ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"Updated password for computer account "
                              L"%1!ws! on DC %2!ws!.\n",
                              virtualName,
                              dcInfo->DomainControllerName);

            //
            // now that password is fixed up, try to get a token; if object
            // hasn't replicated to authenticating DC, this could fail.
            //
            status = NNLogonUser(resourceHandle,
                                 virtualDollarName,
                                 dcInfo->DomainName,
                                 machinePwd,
                                 &Resource->VSToken,
                                 &tokenStatus);

            if ( status != ERROR_SUCCESS ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_WARNING,
                                  L"Couldn't log the computer account onto the domain. status 0x%1!08X!\n",
                                  status);
            }
        } else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to update password for computer account "
                              L"%1!ws! on DC %2!ws!, status %3!u!.\n",
                              virtualName,
                              dcInfo->DomainControllerName,
                              status);

            addtlErrTextID = RES_NETNAME_CO_PASSWORD_UPDATE_FAILED;
            goto cleanup;
        }

    } // else logon failed for some reason other than logon denied
    else if ( status != ERROR_SUCCESS ) {
        //
        // can't tell if password is good; continue on hoping that it is ok.
        //
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Couldn't log the computer account onto the domain (status 0x%1!08X!). "
                          L"Validity of locally stored password is unknown.\n",
                          status);
    }   // else NNLogonUser succeeded

    if ( tokenStatus != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Unable to get token for computer account  - status %1!u!\n",
                          tokenStatus);
    }

    //
    // make sure residual non-fatal error doesn't kill us later on
    // 
    status = ERROR_SUCCESS;

    //
    // use the Object GUID for binding during CheckComputerObjectAttributes so
    // we don't have to track changes to the DN. If the object moved in the
    // DS, its DN will change but not its GUID. We use this code instead of
    // GetComputerObjectGuid because we want to target a specific DC.
    //
    // If we fail to get the GUID, that in itself is not a failure. If later
    // on, we need to update the DNS hostname attribute, then we fail since we
    // need a pointer to the computer object which is a side effect of getting
    // the GUID.
    //
    {
        IADs *  pADs = NULL;

        hr = GetComputerObjectViaFQDN( virtualFQDN, dcInfo->DomainControllerName, &compObj );
        if ( SUCCEEDED( hr )) {
            hr = compObj->QueryInterface(IID_IADs, (void**) &pADs);
            if ( SUCCEEDED( hr )) {
                BSTR    guidStr = NULL;

                hr = pADs->get_GUID( &guidStr );
                if ( SUCCEEDED( hr )) {
                    if ( Resource->ObjectGUID != NULL ) {
                        LocalFree( Resource->ObjectGUID );
                        Resource->ObjectGUID = NULL;
                    }

                    Resource->ObjectGUID = ResUtilDupString( guidStr );
                    if ( Resource->ObjectGUID == NULL ) {
                        hr = HRESULT_FROM_WIN32( GetLastError());
                    }
                }
                else {
                }

                if ( guidStr ) {
                    SysFreeString( guidStr );
                }
            }       // else QI for IADs object failed

            if ( pADs != NULL ) {
                pADs->Release();
            }

            if ( FAILED( hr )) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_WARNING,
                                  L"Failed to get object GUID for computer account %1!ws!, "
                                  L"status %2!08X!\n",
                                  virtualName,
                                  hr );
            }
        }
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_WARNING,
                              L"Failed to obtain IDirectoryObject pointer to computer "
                              L"account %1!ws!, status %2!08X!\n",
                              virtualName,
                              hr );
        }
    }       // local block to get IDirectoryObject pointer

    //
    // now check the attributes on the object we care about are correct
    //
    hr = CheckComputerObjectAttributes( Resource, dcInfo->DomainControllerName );
    if ( FAILED( hr ) && compObj != NULL ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Updating attributes for computer account %1!ws!\n",
                          virtualName);

        //
        // add the DnsHostName and ServicePrincipalName attributes
        //
        hr = AddDnsHostNameAttribute( resourceHandle, compObj, virtualName, FALSE );

        if ( FAILED( hr )) {
            status = hr;
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to set DnsHostName attribute for computer account %1!ws!, "
                              L"status %2!08X!.\n",
                              virtualName,
                              status);

            addtlErrTextID = RES_NETNAME_DNSHOSTNAME_UPDATE_FAILED;
            goto cleanup;
        }

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;
            goto cleanup;
        }

        status = AddServicePrincipalNames( dsHandle,
                                           virtualFQDN,
                                           virtualName,
                                           dcInfo->DomainName,
                                           Resource->dwFlags & CLUS_FLAG_CORE );

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to set ServicePrincipalName attribute for computer account %1!ws!, "
                              L"status %2!u!.\n",
                              virtualName,
                              status);

            addtlErrTextID = RES_NETNAME_SPN_UPDATE_FAILED;
            goto cleanup;
        }
    } // else attributes are correct

cleanup:
    //
    // always free these
    //
    if ( dsHandle != NULL ) {
        DsUnBind( &dsHandle );
    }

    if ( compObj != NULL ) {
        compObj->Release();
    }

    if ( virtualFQDN != NULL ) {
        LocalFree( virtualFQDN );
    }

    if ( hostingDCName != NULL && hostingDCName != Resource->Params.CreatingDC ) {
        //
        // hostingDCName was allocated by the search routine
        //
        LocalFree( hostingDCName );
    }

    if ( netUI20 != NULL ) {
        NetApiBufferFree( netUI20 );
    }

    if ( status == ERROR_SUCCESS ) {
        *MachinePwd = machinePwd;
    } else {
        if ( status != ERROR_OPERATION_ABORTED ) {
            LPWSTR  msgBuff;
            DWORD   msgBytes;
            LPWSTR  addtlErrText;
            LPWSTR  domainName;
            WCHAR   domainNameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
            DWORD   domainNameChars = COUNT_OF( domainNameBuffer );

            msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_FROM_SYSTEM,
                                     NULL,
                                     status,
                                     0,
                                     (LPWSTR)&msgBuff,
                                     0,
                                     NULL);

            //
            // get the additional error text to go with the generic failed message
            //
            addtlErrText = ClusResLoadMessage( addtlErrTextID );

            success = GetComputerNameEx(ComputerNameDnsDomain,
                                        domainNameBuffer,
                                        &domainNameChars);

            if ( success ) {
                domainName = domainNameBuffer;
            }
            else {
                domainName = NULL;
            }

            if ( msgBytes > 0 ) {
                ClusResLogSystemEventByKey3(Resource->ResKey,
                                            LOG_CRITICAL,
                                            RES_NETNAME_UPDATE_COMPUTER_ACCOUNT_FAILED,
                                            domainName,
                                            addtlErrText,
                                            msgBuff);

                LocalFree( msgBuff );
            } else {
                ClusResLogSystemEventByKeyData2(Resource->ResKey,
                                                LOG_CRITICAL,
                                                RES_NETNAME_UPDATE_COMPUTER_ACCOUNT_FAILED_STATUS,
                                                sizeof( status ),
                                                &status,
                                                domainName,
                                                addtlErrText);
            }

            if ( addtlErrText ) {
                LocalFree( addtlErrText );
            }
        }

        if ( machinePwd != NULL ) {
            //
            // zero out the string
            //
            RtlSecureZeroMemory( machinePwd, pwdBufferByteLength );
            LocalFree( machinePwd );
        }

        if ( Resource->VSToken ) {
            CloseHandle( Resource->VSToken );
            Resource->VSToken = NULL;
        }
    }

    if ( dcInfo != NULL ) {
        NetApiBufferFree( dcInfo );
    }

    return status;
} // UpdateComputerObject

DWORD
DisableComputerObject(
    PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    Disable the CO associated with the resource.

Arguments:

    Resource

Return Value:

    success otherwise Win32 error

--*/

{
    WCHAR   virtualDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    PWCHAR  virtualName;
    LPWSTR  dcName = NULL;

    NET_API_STATUS  status;
    PUSER_INFO_20   netUI20;
    USER_INFO_1008  netUI1008;
    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    PDOMAIN_CONTROLLER_INFO dcInfo = NULL;

    //
    // use the name stored in the registry since the name property could have
    // been changed multiple times while offline
    //
    virtualName = ResUtilGetSzValue( Resource->ParametersKey, PARAM_NAME__NAME );
    if ( virtualName == NULL ) {
        return ERROR_SUCCESS;
    }

    //
    // find a writable DC; 2nd time through, we try the creating DC...
    //
retry_findDC:
    status = FindDomainForServer( resourceHandle, Resource->NodeName, dcName, DS_WRITABLE_REQUIRED, &dcInfo );

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Can't connect to DC %1!ws! to disable computer account %2!ws!. "
                          L"status %3!u!\n",
                          Resource->Params.CreatingDC,
                          virtualName,
                          status);

        return status;
    }

    virtualDollarName[ COUNT_OF( virtualDollarName ) - 1 ] = UNICODE_NULL;
    _snwprintf( virtualDollarName, COUNT_OF( virtualDollarName ) - 1, L"%ws$", virtualName );

    //
    // get the current flags associated with the account
    //
    status = NetUserGetInfo(dcInfo->DomainControllerName,
                            virtualDollarName,
                            20,
                            (LPBYTE *)&netUI20);

    if ( status == NERR_Success ) {
        DWORD   paramInError;

        if ( netUI20->usri20_flags & UF_ACCOUNTDISABLE ) {
            status = ERROR_SUCCESS;
        } else {
            netUI1008.usri1008_flags = netUI20->usri20_flags | UF_ACCOUNTDISABLE;
            status = NetUserSetInfo(dcInfo->DomainControllerName,
                                    virtualDollarName,
                                    1008,
                                    (LPBYTE)&netUI1008,
                                    &paramInError);

            if ( status != NERR_Success ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Failed to disable computer account %1!ws!. status %2!u!\n",
                                  virtualName,
                                  status);
            }
        }

        NetApiBufferFree( netUI20 );
    } else if ( status == NERR_UserNotFound && dcName == NULL && Resource->Params.CreatingDC != NULL ) {
        //
        // object must have not replicated just yet; retry on our synch point
        // DC
        //
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Failed to find computer account %1!ws! in order "
                          L"to disable. Retrying on DC %2!ws!.\n",
                          virtualName,
                          Resource->Params.CreatingDC);

        NetApiBufferFree( dcInfo );
        dcInfo = NULL;
        dcName = Resource->Params.CreatingDC;
        goto retry_findDC;
    } else if ( status == NERR_UserNotFound ) {
        //
        // apparently nothing to disable
        //
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Failed to find computer account %1!ws! in order "
                          L"to disable.\n",
                          virtualName);
    } else {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Couldn't determine if computer account %1!ws! "
                          L"is already disabled. status %2!u!\n",
                          virtualName,
                          status);
    }

    if ( status == ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Computer account %1!ws! is disabled.\n",
                          virtualName);
    }

    LocalFree( virtualName );

    if ( dcInfo != NULL ) {
        NetApiBufferFree( dcInfo );
    }

    return status;
} // DisableComputerObject

HRESULT
GetComputerObjectGuid(
    IN PNETNAME_RESOURCE    Resource,
    IN LPWSTR               Name        OPTIONAL
    )

/*++

Routine Description:

    For the given resource, find its computer object's GUID in the DS

Arguments:

    Resource - pointer to netname resource context block

    Name - optional pointer to name to use. If not specified, use name in resource block

Return Value:

    ERROR_SUCCESS, otherwise appropriate Win32 error

--*/

{
    LPWSTR  virtualFQDN = NULL;
    LPWSTR  nameToFind;
    HRESULT hr;
    DWORD   status;
    BOOL    objectExists;

    //
    // use the optional name if specified.
    //
    if ( ARGUMENT_PRESENT( Name )) {
        nameToFind = Name;
    } else {
        nameToFind = Resource->Params.NetworkName;
    }

    //
    // get the FQ Distinguished Name of the object
    //
    hr = IsComputerObjectInDS( Resource->ResourceHandle,
                               Resource->NodeName,
                               nameToFind,
                               NULL,
                               &objectExists,
                               &virtualFQDN,
                               NULL);            // don't need HostingDCName

    if ( SUCCEEDED( hr )) {
        if ( objectExists ) {
            IDirectoryObject *  compObj = NULL;

            //
            // get a COM pointer to the computer object
            //
            hr = GetComputerObjectViaFQDN( virtualFQDN, NULL, &compObj );
            if ( SUCCEEDED( hr )) {
                IADs *  pADs = NULL;

                //
                // get a pointer to the generic IADs interface so we can get the
                // GUID
                //
                hr = compObj->QueryInterface(IID_IADs, (void**) &pADs);
                if ( SUCCEEDED( hr )) {
                    BSTR    guidStr = NULL;

                    hr = pADs->get_GUID( &guidStr );
                    if ( SUCCEEDED( hr )) {
                        if ( Resource->ObjectGUID != NULL ) {
                            LocalFree( Resource->ObjectGUID );
                        }

                        Resource->ObjectGUID = ResUtilDupString( guidStr );
                    }

                    if ( guidStr ) {
                        SysFreeString( guidStr );
                    }
                }

                if ( pADs != NULL ) {
                    pADs->Release();
                }
            }

            if ( compObj != NULL ) {
                compObj->Release();
            }
        }
        else {
            hr = HRESULT_FROM_WIN32( ERROR_DS_NO_SUCH_OBJECT );
        }
    }

    if ( virtualFQDN ) {
        LocalFree( virtualFQDN );
    }

    return hr;
} // GetComputerObjectGuid

HRESULT
CheckComputerObjectAttributes(
    IN  PNETNAME_RESOURCE   Resource,
    IN  LPWSTR              DCName      OPTIONAL
    )

/*++

Routine Description:

    LooksAlive routine for computer object. Using an IDirectoryObject pointer
    to the virtual CO, check its DnsHostName and SPN attributes

Arguments:

    Resource - pointer to netname resource context structure

    DCName - optional pointer to a DC to bind to

Return Value:

    S_OK if everything worked ok...

--*/

{
    HRESULT hr;

    ADS_ATTR_INFO * attributeInfo = NULL;
    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    IDirectoryObject *  compObj = NULL;

    //
    // get a pointer to our CO
    //
    hr = GetComputerObjectViaGUID( Resource->ObjectGUID, DCName, &compObj );

    if ( SUCCEEDED( hr )) {
        LPWSTR          attributeNames[2] = { L"DnsHostName", L"ServicePrincipalName" };
        DWORD           numAttributes = COUNT_OF( attributeNames );
        DWORD           countOfAttrs;;

        hr = compObj->GetObjectAttributes(attributeNames,
                                          numAttributes,
                                          &attributeInfo,
                                          &countOfAttrs );

        if ( SUCCEEDED( hr )) {
            DWORD   i;
            WCHAR   fqDnsName[ DNS_MAX_NAME_BUFFER_LENGTH ];
            DWORD   nodeCharCount;
            DWORD   fqDnsSize;
            BOOL    setUnexpected = FALSE;
            BOOL    success;

            ADS_ATTR_INFO * attrInfo;

            //
            // check that we found our attributes
            //
            if ( countOfAttrs != numAttributes ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_WARNING,
                                  L"DnsHostName and/or ServicePrincipalName attributes are "
                                  L"missing from computer account in DS.\n");

                hr = E_UNEXPECTED;
                goto cleanup;
            }

            //
            // build our FQDnsName using the primary DNS domain for this
            // node. Add 1 for the dot.
            //
            nodeCharCount = wcslen( Resource->Params.NetworkName ) + 1;
            wcscpy( fqDnsName, Resource->Params.NetworkName );
            wcscat( fqDnsName, L"." );
            fqDnsSize = COUNT_OF( fqDnsName ) - nodeCharCount;

            success = GetComputerNameEx( ComputerNameDnsDomain,
                                         &fqDnsName[ nodeCharCount ],
                                         &fqDnsSize );

            ASSERT( success );

            attrInfo = attributeInfo;
            for( i = 0; i < countOfAttrs; i++, attrInfo++ ) {
                if ( ClRtlStrICmp( attrInfo->pszAttrName, L"DnsHostName" ) == 0 ) {
                    //
                    // should only be one entry and it should match our constructed FQDN
                    //
                    if ( attrInfo->dwNumValues == 1 ) {
                        if ( ClRtlStrICmp( attrInfo->pADsValues->CaseIgnoreString,
                                       fqDnsName ) != 0 )
                        {
                            (NetNameLogEvent)(resourceHandle,
                                              LOG_ERROR,
                                              L"DnsHostName attribute in DS doesn't match. "
                                              L"Expected: %1!ws! Actual: %2!ws!\n",
                                              fqDnsName,
                                              attrInfo->pADsValues->CaseIgnoreString);
                            setUnexpected = TRUE;
                        }
                    }
                    else {
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"Found more than one string for DnsHostName attribute in DS.\n");
                        setUnexpected = TRUE;
                    }
                }
                else {
                    //
                    // SPNs require more work since we publish a bunch of them
                    // as well as other services may have added their
                    // SPNs. The core resource should have more SPNs than the
                    // normal VS resource.
                    //
                    BOOL    isCoreResource = ( Resource->dwFlags & CLUS_FLAG_CORE );
                    DWORD   spnCount =  isCoreResource ? SPN_CORE_SPN_COUNT : SPN_VS_SPN_COUNT;

                    PNN_SPN_LIST    spnList;

                    if ( attrInfo->dwNumValues >= spnCount ) {
                        DWORD   countOfOurSPNs = 0;
                        DWORD   value;
                        DWORD   status;

                        status = BuildNetNameSPNs( Resource->Params.NetworkName,
                                                   isCoreResource,
                                                   &spnList);

                        if ( status == ERROR_SUCCESS ) {
                            //
                            // examine each SPN and count the number that match the list
                            //
                            for ( value = 0; value < attrInfo->dwNumValues; value++, attrInfo->pADsValues++) {
                                DWORD spnIndex;

                                for ( spnIndex = 0; spnIndex < spnCount; ++spnIndex ) {
                                    if ( ClRtlStrICmp(attrInfo->pADsValues->CaseIgnoreString,
                                                  spnList->Spn[ spnIndex ]) == 0 )
                                    {
                                        ++countOfOurSPNs;
                                        break;
                                    }
                                } // SPN list loop
                            } // end of for each SPN value in the DS

                            if ( countOfOurSPNs != spnCount ) {
                                (NetNameLogEvent)(resourceHandle,
                                                  LOG_WARNING,
                                                  L"There are missing entries in the ServicePrincipalName "
                                                  L"attribute.\n");
                                setUnexpected = TRUE;
                            }

                            LocalFree( spnList );
                        } else {
                            (NetNameLogEvent)(resourceHandle,
                                              LOG_WARNING,
                                              L"Unable to build list of SPNs to check, status %1!u!\n");
                        }
                    }
                    else {
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_WARNING,
                                          L"There are missing entries in the ServicePrincipalName "
                                          L"attribute.\n");
                        setUnexpected = TRUE;
                    }
                }
            } // for each attribute info entry

            if ( setUnexpected ) {
                hr = E_UNEXPECTED;
            }
        } // if GetObjectAttributes succeeded
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to find attributes for computer object in DS. status %1!08X!.\n",
                              hr);
        }
    } // if GetComputerObjectViaFQDN succeeded
    else {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Computer account attribute check: Unable to find computer account %1!ws! with GUID "
                          L"{%2!.2ws!%3!.2ws!%4!.2ws!%5!.2ws!-%6!.2ws!%7!.2ws!-%8!.2ws!%9!.2ws!-%10!.4ws!-%11!ws!} "
                          L"in Active Directory. status %12!08X!.\n",
                          Resource->Params.NetworkName,
                          Resource->ObjectGUID + 6,
                          Resource->ObjectGUID + 4,
                          Resource->ObjectGUID + 2,
                          Resource->ObjectGUID,
                          Resource->ObjectGUID + 10,
                          Resource->ObjectGUID + 8,
                          Resource->ObjectGUID + 14,
                          Resource->ObjectGUID + 12,
                          Resource->ObjectGUID + 16,
                          Resource->ObjectGUID + 20,
                          hr);
    }

cleanup:
    if ( attributeInfo != NULL ) {
        FreeADsMem( attributeInfo );
    }

    if ( compObj != NULL ) {
        compObj->Release();
    }

    return hr;
} // CheckComputerObjectAttributes

HRESULT
IsComputerObjectInDS(
    IN  RESOURCE_HANDLE ResourceHandle,
    IN  LPWSTR          NodeName,
    IN  LPWSTR          NewObjectName,
    IN  LPWSTR          DCName              OPTIONAL,
    OUT PBOOL           ObjectExists,
    OUT LPWSTR *        DistinguishedName,  OPTIONAL
    OUT LPWSTR *        HostingDCName       OPTIONAL
    )

/*++

Routine Description:

    See if the specified name has a computer object in the DS. We do this by:

    1) binding to a domain controller in the domain and QI'ing for an
       IDirectorySearch object
    2) specifying (&(objectCategory=computer)(cn=<new name>)) as the search
       string
    3) examining result count of search; 1 means it exists.

Arguments:

    ResourceHandle - used to log domain lookup into cluster log

    NodeName - our name; used to to find DS with which to bind

    NewObjectName - requested new name of object

    DCName - name of DC where search is performed. If none supplied,
             then domain is searched

    ObjectExists - TRUE if object already exists; only valid if function
                   status is success

    DistinguishedName - optional address of pointer that receives the
                        LDAP FQDN of the object

    HostingDCName - optional address of pointer to receive name of DC where
                    object was found. Used when DCName is NULL.

Return Value:

    ERROR_SUCCESS if everything worked

--*/

{
    BOOL    objectExists;
    HRESULT hr;
    DWORD   charsFormatted;
    LPWSTR  distName = L"distinguishedName";
    WCHAR   buffer[ DNS_MAX_NAME_BUFFER_LENGTH + COUNT_OF( LdapHeader ) ];
    PWCHAR  bindingString = buffer;
    DWORD   bindingChars;
    DWORD   status;
    LPWSTR  targetName;

    WCHAR   searchLeader[] = L"(&(objectCategory=computer)(name=";
    WCHAR   searchTrailer[] = L"))";
    WCHAR   searchFilter[ COUNT_OF( searchLeader ) + MAX_COMPUTERNAME_LENGTH + COUNT_OF( searchTrailer )];

    ADS_SEARCH_COLUMN   searchCol;
    ADS_SEARCHPREF_INFO searchPrefs[2];
    IDirectorySearch *  pDSSearch = NULL;
    ADS_SEARCH_HANDLE   searchHandle;

    PDOMAIN_CONTROLLER_INFO dcInfo = NULL;

    //
    // bind to the domain if no DC was specified
    //
    if ( ARGUMENT_PRESENT( DCName )) {
        if ( *DCName == L'\\' && *(DCName+1) == L'\\' ) {   // skip over double backslashes
            DCName += 2;
        }

        targetName = DCName;
    }
    else {

        //
        // get any DC
        //
        status = FindDomainForServer( ResourceHandle, NodeName, NULL, 0, &dcInfo );

        if ( status != ERROR_SUCCESS ) {
            return HRESULT_FROM_WIN32( status );
        }

        //
        // format an LDAP binding string for DNS suffix of the domain.
        //
        targetName = dcInfo->DomainName;
    }

    bindingChars =  (DWORD)( COUNT_OF( LdapHeader ) + wcslen( targetName ));
    if ( bindingChars > COUNT_OF( buffer )) {
        bindingString = (PWCHAR)LocalAlloc( LMEM_FIXED, bindingChars * sizeof( WCHAR ));
        if ( bindingString == NULL ) {
            hr = HRESULT_FROM_WIN32( GetLastError());
            goto cleanup;
        }
    }

    wcscpy( bindingString, LdapHeader );
    wcscat( bindingString, targetName );

    hr = ADsGetObject( bindingString, IID_IDirectorySearch, (VOID **)&pDSSearch );
    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // build search preference array. we limit the size to one and we want to
    // scope the search to check all subtrees.
    //
    searchPrefs[0].dwSearchPref     = ADS_SEARCHPREF_SIZE_LIMIT;
    searchPrefs[0].vValue.dwType    = ADSTYPE_INTEGER;
    searchPrefs[0].vValue.Integer   = 1;

    searchPrefs[1].dwSearchPref     = ADS_SEARCHPREF_SEARCH_SCOPE;
    searchPrefs[1].vValue.dwType    = ADSTYPE_INTEGER;
    searchPrefs[1].vValue.Integer   = ADS_SCOPE_SUBTREE;

    hr = pDSSearch->SetSearchPreference( searchPrefs, COUNT_OF( searchPrefs ));
    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // build the search filter and execute the search; constrain the
    // attributes to the distinguished name.
    //
    searchFilter[ COUNT_OF( searchFilter ) - 1 ] = UNICODE_NULL;
    charsFormatted = _snwprintf(searchFilter,
                                COUNT_OF( searchFilter ) - 1,
                                L"%ws%ws%ws",
                                searchLeader,
                                NewObjectName,
                                searchTrailer);
    ASSERT( charsFormatted > COUNT_OF( searchLeader ));

    hr = pDSSearch->ExecuteSearch(searchFilter,
                                  &distName,
                                  1,
                                  &searchHandle);
    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // try to get the first row. Anything but S_OK returns FALSE
    //
    hr = pDSSearch->GetFirstRow( searchHandle );
    *ObjectExists = (hr == S_OK);
    if ( hr == S_ADS_NOMORE_ROWS ) {
        hr = S_OK;
    }

    if ( *ObjectExists ) {

        if ( ARGUMENT_PRESENT( DistinguishedName )) {
            hr = pDSSearch->GetColumn( searchHandle, distName, &searchCol );

            if ( SUCCEEDED( hr )) {
                DWORD   fqdnChars;

#if DBG
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_INFORMATION,
                                  L"IsComputerObjectInDS: found %1!ws!\n",
                                  searchCol.pADsValues->DNString);
#endif

                fqdnChars = wcslen( searchCol.pADsValues->DNString ) + 1;
                *DistinguishedName = (LPWSTR)LocalAlloc( LMEM_FIXED, fqdnChars * sizeof(WCHAR));

                if ( *DistinguishedName ) {
                    wcscpy( *DistinguishedName, searchCol.pADsValues->DNString );
                } else {
                    hr = HRESULT_FROM_WIN32( GetLastError());
                }

                pDSSearch->FreeColumn( &searchCol );
            }
        } // else FQDN wasn't needed

        if ( ARGUMENT_PRESENT( HostingDCName )) {
            IADsObjectOptions * objOpt = NULL;
            VARIANT serverName;

            VariantInit( &serverName );

            hr = pDSSearch->QueryInterface( IID_IADsObjectOptions, (void**)&objOpt );
            if ( SUCCEEDED( hr )) {

                hr = objOpt->GetOption( ADS_OPTION_SERVERNAME, &serverName );
                if ( SUCCEEDED( hr )) {
                    *HostingDCName = ResUtilDupString( V_BSTR( &serverName ));
                }

                VariantClear( &serverName );
            }

            if ( objOpt != NULL ) {
                objOpt->Release();
            }

        } // else hosting DC name wasn't needed
    }

    pDSSearch->CloseSearchHandle( searchHandle );

cleanup:
    if ( pDSSearch != NULL ) {
        pDSSearch->Release();
    }

    if ( dcInfo != NULL ) {
        NetApiBufferFree( dcInfo );
    }

    if ( bindingString != buffer && bindingString != NULL ) {
        LocalFree( bindingString );
    }

    return hr;
} // IsComputerObjectInDS

HRESULT
RenameComputerObject(
    IN  PNETNAME_RESOURCE   Resource,
    IN  LPWSTR              OriginalName,
    IN  LPWSTR              NewName
    )

/*++

Routine Description:

    Rename the computer object at the DS. Do this by:

    1) Check if we have to recover from an interrupted rename attempt.

    2) Find the object in the DS on the CreatingDC. If that fails, try to find
       the object on another DC. If that succeeds, get the DC that provided
       the binding and update CreatingDC property.

    3) Write the old and new names to the resource's GUID reg area (not
       Parameters). These are used to recover from a botched rename attempt if
       resmon fails in the middle of renaming.

    4) use NetUserSetInfo, level 0 to change the name. This updates a number
       of name specific attributes of the object as well as all Netbios based
       SPNs

    5) Clear just the old name from the resource's reg area. This will
       indicate that the rename was successful. When the Name property is
       successfully updated in the registry, the RenameNewName value is
       deleted.

    6) update the DnsHostName attribute. This updates the DNS based SPNs

    Renaming must be a recoverable operation. If the DnsHostName update fails
    after the object is renamed, the rename must be backed out. Even though
    online tries to fixup the attribute, if it can't be changed here, the
    fixup will fail during online.

    In addition, if resmon should die while in the middle of a rename, netname
    has to recover from that as well. Two keys, RenameOriginalName and
    RenameNewName, hold those names prior to the update. If resmon dies before
    the Name property is updated, the orignal name will be kept. If necessary,
    the object must be renamed back to the original name.

Arguments:

    Resource - pointer to the netname context block

    OriginalName - pointer to the current name

    NewName - pointer to new name

Return Value:

    ERROR_SUCCESS if it worked...

--*/

{
    HRESULT hr = S_OK;
    DWORD   status;
    WCHAR   originalDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    WCHAR   newDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    DWORD   paramInError;
    LPWSTR  renameOriginalName;
    LPWSTR  renameNewName;
    BOOL    performRename = TRUE;
    BOOL    freeOriginalName = FALSE;
    LPWSTR  nameForGuidLookup = OriginalName;

    USER_INFO_0 netUI0;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    IDirectoryObject *  compObj = NULL;
    IADsObjectOptions * objOpts = NULL;

    //
    // see if we need to recover from an interrupted rename attempt. If a
    // rename failed in the middle of a previous attempt, then the astute
    // admin will check on the name before bringing it online (there is
    // recovery code in the online path as well). If we're here (as opposed to
    // going online), we need to figure out how much work was done by the last
    // attempt. There will be two scenarios: 1) the rename didn't get far
    // enough to rename the object in which case, we can continue or 2) it did
    // rename the object but failed before the Name property could be
    // stored. In that case, we can skip the rename op providing the NewName
    // matches RenameNewName. If it doesn't, then we set OriginalName to
    // RenameNewName so we can rename the object to NewName.
    //

    //
    // read the rename keys from the registry. If these fail for reasons other
    // than file not found, then something is wrong at the service level (like
    // it's dead) so no need to log an error.
    //
    renameOriginalName = ResUtilGetSzValue( Resource->ResKey, PARAM_NAME__RENAMEORIGINALNAME );
    if ( renameOriginalName == NULL ) {
        status = GetLastError();
        if ( status != ERROR_FILE_NOT_FOUND ) {
            return HRESULT_FROM_WIN32( status );
        }
    }

    renameNewName = ResUtilGetSzValue( Resource->ResKey, PARAM_NAME__RENAMENEWNAME );
    if ( renameNewName == NULL ) {
        status = GetLastError();
        if ( status != ERROR_FILE_NOT_FOUND ) {
            return HRESULT_FROM_WIN32( status );
        }
    }

    if ( renameNewName && renameOriginalName ) {
        BOOL    originalNameObjectExists;
        BOOL    newNameObjectExists;

        //
        // since both keys exist, we don't know if the object rename
        // happened. Go find it now.
        //
        // ISSUE - 11/11/01. charlwi (Charlie Wickham)
        //
        // We've also constrained the searching to the creating DC. If this DC
        // were demoted before recovery could take place, then the object will
        // never be found. For Windows Server 2003, disabling and re-enabling Kerb
        // support will fix this since it will find the object on another DC and that
        // will become the creating DC. When there is no option to disable
        // Kerb, this routine will have to be fixed to look on other DCs.
        //
        hr = IsComputerObjectInDS( resourceHandle,
                                   Resource->NodeName,
                                   renameOriginalName,
                                   Resource->Params.CreatingDC,
                                   &originalNameObjectExists,
                                   NULL,                        // FQDN not needed
                                   NULL);                       // Hosting DC Name not needed

        if ( SUCCEEDED( hr )) {
            if ( !originalNameObjectExists ) {
                //
                // couldn't find an object with the original (old) name; try
                // with the new name.
                //
                hr = IsComputerObjectInDS( resourceHandle,
                                           Resource->NodeName,
                                           renameNewName,
                                           Resource->Params.CreatingDC,
                                           &newNameObjectExists,
                                           NULL,                        // FQDN not needed
                                           NULL);                       // Hosting DC Name not needed

                if ( SUCCEEDED( hr )) {
                    if ( newNameObjectExists ) {

                        (NetNameLogEvent)(resourceHandle,
                                          LOG_INFORMATION,
                                          L"Recovering computer account %1!ws! on DC %2!ws! from "
                                          L"interrupted rename operation.\n",
                                          renameNewName,
                                          Resource->Params.CreatingDC);

                        nameForGuidLookup = renameNewName;

                        //
                        // now check if NewName is different from the old
                        // "NewName". If so, then set OriginalName to the old
                        // "NewName" and continue with the rename op
                        //
                        if ( ClRtlStrICmp( renameNewName, NewName ) != 0 ) {
                            OriginalName = ResUtilDupString( renameNewName );
                            if ( OriginalName == NULL ) {
                                hr = HRESULT_FROM_WIN32 ( GetLastError());
                            } else {
                                freeOriginalName = TRUE;
                            }
                        }
                        else {
                            performRename = FALSE;
                        }
                    }
                    else {
                        //
                        // this is very bad: can't find the object by either name.
                        //
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"The computer account for this resource could not be "
                                          L"found on DC %1!ws! during rename recovery. The original "
                                          L"name (%2!ws!) was being renamed to %3!ws! and "
                                          L"a computer account by either name could not be found. "
                                          L"The resource cannot go online until the object is recreated. This "
                                          L"can be accomplished by disabling and re-enabling Kerberos "
                                          L"Authentication for this resource.\n",
                                          Resource->Params.CreatingDC,
                                          renameOriginalName,
                                          renameNewName);

                        hr = HRESULT_FROM_WIN32( ERROR_DS_NO_SUCH_OBJECT );
                    }
                }
                else {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"AD search for computer account %1!ws! on DC %2!ws! failed "
                                      L"during rename recovery operation - status %2!08X!.\n",
                                      renameNewName,
                                      Resource->Params.CreatingDC,
                                      hr);
                }
            }
            else {
                //
                // object with original name exists. Nothing to do.
                //
                nameForGuidLookup = renameOriginalName;
            }
        }
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"AD search for computer account %1!ws! on DC %2!ws! failed "
                              L"during rename recovery operation - status %2!08X!.\n",
                              renameOriginalName,
                              Resource->Params.CreatingDC,
                              hr);
        }
    }
    else if ( renameNewName && renameOriginalName == NULL ) {

        //
        // could be we made it past writing the Name property but not far
        // enough to delete the RenameNewName key. If the names are aligned,
        // then nothing to do.
        //
        if ( ClRtlStrICmp( renameNewName, OriginalName ) != 0 ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"Found partially renamed computer account %1!ws! on "
                              L"DC %2!ws!. Attempting recovery.\n",
                              renameNewName,
                              Resource->Params.CreatingDC);

            nameForGuidLookup = renameNewName;

            //
            // now we need to check if NewName equals RenameNewName. If they don't
            // then we change OriginalName to RenameNewName and proceed with the
            // rename.
            //
            if ( ClRtlStrICmp( renameNewName, NewName ) != 0 ) {
                OriginalName = ResUtilDupString( renameNewName );
                if ( OriginalName == NULL ) {
                    hr = HRESULT_FROM_WIN32 ( GetLastError());
                } else {
                    freeOriginalName = TRUE;
                }
            }
            else {
                performRename = FALSE;
            }
        }
    }

    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // get the CO GUID if necessary
    //
    if ( Resource->ObjectGUID == NULL ) {
        //
        // GUID isn't set in param block if we haven't been online yet. do it
        // here since we need it to get a computer object pointer.
        //
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Getting Computer Object GUID.\n");

        hr = GetComputerObjectGuid( Resource, nameForGuidLookup );
        if ( FAILED( hr )) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Failed to find the object GUID for computer account %1!ws! "
                              L"(status %2!08X!). This error can occur if the Network Name "
                              L"was changed and the name change of the corresponding computer "
                              L"account hasn't replicated to other domain controllers. The rename of "
                              L"the computer account occurs on the DC named in the CreatingDC "
                              L"property. Ensure that this DC is availalbe and attempt the "
                              L"rename again.\n",
                              nameForGuidLookup,
                              hr);

            goto cleanup;
        }
    }

    //
    // get a IDirectoryObject pointer on the creating DC; if that fails, then
    // try to find the object on another DC and update the CreatingDC
    // property.
    //
    hr = GetComputerObjectViaGUID( Resource->ObjectGUID, Resource->Params.CreatingDC, &compObj );
    if ( FAILED( hr )) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Failed to find computer account %1!ws! on DC %2!ws! (status %3!08X!). "
                          L"Trying on another DC.\n",
                          OriginalName,
                          Resource->Params.CreatingDC,
                          hr);

        hr = GetComputerObjectViaGUID( Resource->ObjectGUID, NULL, &compObj );
        if ( SUCCEEDED( hr )) {
            LPWSTR  attributeNames[1] = { L"cn" };
            DWORD   numAttributes = COUNT_OF( attributeNames );
            DWORD   countOfAttrs;;

            ADS_ATTR_INFO * attributeInfo = NULL;

            //
            // Check that the common name of the object matches the current
            // network name of the resource. If the name is changed on DC A
            // which becomes unavailable soon thereafter and doesn't replicate
            // the change to DC B and DC B becomes available before DC A and
            // another rename operation is attempted then we can get a pointer
            // to the object since the GUID hasn't changed but the name of the
            // object on DC A and the network name won't match. Disallow the
            // rename in that case.
            //
            hr = compObj->GetObjectAttributes(attributeNames,
                                              numAttributes,
                                              &attributeInfo,
                                              &countOfAttrs );

            if ( SUCCEEDED( hr )) {
                if ( countOfAttrs == 1 ) {
                    if ( ClRtlStrICmp( OriginalName, attributeInfo->pADsValues->CaseIgnoreString ) != 0 ) {
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"The Network Name (%1!ws!) does not match the name of the "
                                          L"corresponding computer account in AD (%2!ws!). This is "
                                          L"usually due to the name change of the computer account "
                                          L"not replicating to other domain controllers in the domain. "
                                          L"A subsequent rename cannot be performed until the name "
                                          L"change has replicated to other DCs. If the Network Name "
                                          L"has not been changed, then it is out synch with the name of "
                                          L"the computer account. This problem can be fixed by renaming "
                                          L"the computer account and letting that change replicate "
                                          L"to other DCs. Once that has occurred, the Network Name for this "
                                          L"resource can be changed.\n",
                                          OriginalName,
                                          attributeInfo->pADsValues->CaseIgnoreString);

                        ClusResLogSystemEventByKey2(Resource->ResKey,
                                                    LOG_CRITICAL,
                                                    RES_NETNAME_RENAME_OUT_OF_SYNCH_WITH_COMPOBJ,
                                                    OriginalName,
                                                    attributeInfo->pADsValues->CaseIgnoreString);

                        hr = HRESULT_FROM_WIN32( ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME );
                    }
                } else {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"The cn attribute is missing for computer account %1!ws!.\n",
                                      attributeInfo->pADsValues->CaseIgnoreString);

                    hr = E_ADS_PROPERTY_NOT_FOUND;
                }

                FreeADsMem( attributeInfo );
            } else {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Failed to get information on computer account %1!ws! on DC %2!ws! "
                                  L"(status %3!08X!). Trying on another DC.\n",
                                  OriginalName,
                                  Resource->Params.CreatingDC,
                                  hr);

            }

            if ( FAILED( hr )) {
                goto cleanup;
            }

            hr = compObj->QueryInterface( IID_IADsObjectOptions, (void **)&objOpts );
            if ( SUCCEEDED( hr )) {

                VARIANT serverName;
                VariantInit( &serverName );
                hr = objOpts->GetOption( ADS_OPTION_SERVERNAME, &serverName );

                if ( SUCCEEDED( hr )) {
                    DWORD   dcNameChars;
                    LPWSTR  creatingDC;

                    //
                    // CreatingDC property needs leading backslashes; add them if they
                    // are not there.
                    //
                    dcNameChars = wcslen( serverName.bstrVal ) + 1;
                    if ( serverName.bstrVal[0] != L'\\' && serverName.bstrVal[1] != L'\\' ) {
                        dcNameChars += 2;
                    }

                    creatingDC = (LPWSTR)LocalAlloc( LMEM_FIXED, dcNameChars * sizeof( WCHAR ));
                    if ( creatingDC ) {
                        PWCHAR  p = creatingDC;

                        if ( serverName.bstrVal[0] != L'\\' && serverName.bstrVal[1] != L'\\' ) {
                            *p++ = L'\\';
                            *p++ = L'\\';
                        }

                        wcscpy( p, serverName.bstrVal );

                        status = ResUtilSetSzValue(Resource->ParametersKey,
                                                   PARAM_NAME__CREATING_DC,
                                                   creatingDC,
                                                   NULL);

                        if ( status != ERROR_SUCCESS ) {
                            (NetNameLogEvent)(resourceHandle,
                                              LOG_ERROR,
                                              L"Unable to set CreatingDC property, status %1!u!.\n",
                                              status);

                            hr = HRESULT_FROM_WIN32( status );
                            LocalFree( creatingDC );
                        } else {
                            LocalFree( Resource->Params.CreatingDC );
                            Resource->Params.CreatingDC = creatingDC;
                        }
                    }
                    else {
                        hr = HRESULT_FROM_WIN32( GetLastError());

                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"Failed to allocate memory for rename operation. status %1!08X!\n",
                                          hr);
                    }

                    VariantClear( &serverName );
                }
                else {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Failed to get name of DC for computer account %1!ws!. status %2!08X!\n",
                                      OriginalName,
                                      hr);
                }
            }
            else {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Failed to get object options for computer account %1!ws!. "
                                  L"status %2!08X!\n",
                                  OriginalName,
                                  hr);
            }
        }
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Failed to find computer account %1!ws! in Active Directory "
                              L"(status %2!08X!).\n",
                              OriginalName,
                              hr);
        }
    }

    if ( FAILED( hr )) {
        goto cleanup;
    }

    //
    // write the original and new names to the resource's registry area in case
    // we need to recover from a resmon crash.
    //
    status = ClusterRegSetValue(Resource->ResKey,
                                PARAM_NAME__RENAMEORIGINALNAME,
                                REG_SZ,
                                (LPBYTE)OriginalName,
                                ( wcslen(OriginalName) + 1 ) * sizeof(WCHAR) );

    if ( status != ERROR_SUCCESS ) {
        hr = HRESULT_FROM_WIN32( status );
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Failed to write original name to registry for rename recovery - status %1!08X!\n",
                          hr);

        goto cleanup;
    }

    status = ClusterRegSetValue(Resource->ResKey,
                                PARAM_NAME__RENAMENEWNAME,
                                REG_SZ,
                                (LPBYTE)NewName,
                                ( wcslen(NewName) + 1 ) * sizeof(WCHAR) );

    if ( status != ERROR_SUCCESS ) {
        hr = HRESULT_FROM_WIN32( status );
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Failed to write new name to registry for rename recovery - status %1!08X!\n",
                          hr);

        goto cleanup;
    }

    //
    // build the dollar sign names
    //
    originalDollarName[ COUNT_OF( originalDollarName ) - 1 ] = UNICODE_NULL;
    _snwprintf( originalDollarName, COUNT_OF( originalDollarName ) - 1, L"%ws$", OriginalName );

    newDollarName[ COUNT_OF( newDollarName ) - 1 ] = UNICODE_NULL;
    _snwprintf( newDollarName, COUNT_OF( newDollarName ) - 1, L"%ws$", NewName );

    if ( performRename ) {
        //
        // Since we've successfully bound to the object on a DC, we give renaming
        // one chance, i.e., if this should fail, we don't try to find yet another
        // DC and retry.
        //
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Attempting rename of computer account %1!ws! to %2!ws! with DC %3!ws!.\n",
                          OriginalName,
                          NewName,
                          Resource->Params.CreatingDC);

        netUI0.usri0_name = newDollarName;
        status = NetUserSetInfo( Resource->Params.CreatingDC,
                                 originalDollarName,
                                 0,
                                 (LPBYTE)&netUI0,
                                 &paramInError);
    }

    if ( status == NERR_Success ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Updating DnsHostName attribute.\n");

        //
        // remove RenameOriginalName from the registry; we leave RenameNewName
        // in place since resmon could still croak before writing the Name
        // property back to the registry. Once the Name property has been
        // updated, the RenameNewName value can be deleted.
        //
        status = ClusterRegDeleteValue(Resource->ResKey,
                                       PARAM_NAME__RENAMEORIGINALNAME);

        if ( status != ERROR_SUCCESS ) {
            hr = HRESULT_FROM_WIN32( status );
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Failed to delete "
                              PARAM_NAME__RENAMEORIGINALNAME
                              L" from registry - status %1!08X!\n",
                              hr);

            goto cleanup;
        }

        //
        // if resmon crashes now, the recovery routines will find the object
        // with the new name and try to update DnsHostName then.
        //
        hr = AddDnsHostNameAttribute( resourceHandle, compObj, NewName, TRUE );

        if ( SUCCEEDED( hr )) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"DnsHostName attribute update succeeded.\n");
        } else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to set DnsHostName attribute for Computer account %1!ws!, "
                              L"status %2!08X!.\n",
                              NewName,
                              hr);

            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"Attempting rename back to original name (%1!ws!) with DC %2!ws!.\n",
                              OriginalName,
                              Resource->Params.CreatingDC);

            netUI0.usri0_name = originalDollarName;
            status = NetUserSetInfo( Resource->Params.CreatingDC,
                                     newDollarName,
                                     0,
                                     (LPBYTE)&netUI0,
                                     &paramInError);

            if ( status == NERR_Success ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_INFORMATION,
                                  L"Rename back to original name (%1!ws!) succeeded.\n",
                                  OriginalName);
            }
            else {
                //
                // since we were able to rename the object in the first place,
                // I can't imagine why this would fail. If it does, it is bad
                // since the name of the object is now out of synch with the
                // network name.
                //
                // We'll log to the system event log that something bad happened.
                //
                hr = HRESULT_FROM_WIN32( status );

                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Rename back to original name (%1!ws!) with DC %2!ws! failed, status %3!08X!.\n",
                                  OriginalName,
                                  Resource->Params.CreatingDC,
                                  hr);

                ClusResLogSystemEventByKeyData2(Resource->ResKey,
                                                LOG_CRITICAL,
                                                RES_NETNAME_RENAME_RESTORE_FAILED,
                                                sizeof( status ),
                                                &status,
                                                NewName,
                                                OriginalName);
                goto cleanup;
            }
        }
    }
    else {
        //
        // failed; log status and exit
        //
        hr = HRESULT_FROM_WIN32( status );

        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Failed to rename computer account %1!ws! to %2!ws! using DC %3!ws! "
                          L"(status %4!08X!).\n",
                          OriginalName,
                          NewName,
                          Resource->Params.CreatingDC,
                          hr);
        goto cleanup;
    }

cleanup:
    if ( compObj != NULL ) {
        compObj->Release();
    }

    if ( objOpts != NULL ) {
        objOpts->Release();
    }

    if ( freeOriginalName ) {
        LocalFree( OriginalName );
    }

    if ( renameNewName ) {
        LocalFree( renameNewName );
    }

    if ( renameOriginalName ) {
        LocalFree( renameOriginalName );
    }

    return hr;
} // RenameComputerObject

DWORD
DuplicateVSToken(
    PNETNAME_RESOURCE           Resource,
    PCLUS_NETNAME_VS_TOKEN_INFO TokenInfo,
    PHANDLE                     DuplicatedToken
    )

/*++

Routine Description:

    Duplicate the VS Token for this resource into the process identified in
    the TokenInfo structure.

Arguments:

    Resource - pointer to netname resource context struct

    TokenInfo - pointer to struct containing info about where and how to dup
                the token

    DuplicatedToken - pointer to handle that receives the dup'ed token

Return Value:

    Win32 error code...

--*/

{
    DWORD   status = ERROR_SUCCESS;
    HANDLE  targetProcess;
    BOOL    success;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    //
    // do some validation
    //
    if ( Resource->Params.RequireKerberos == 0 ) {
        return ERROR_NO_TOKEN;
    }

    //
    // do we have a otoken already?
    //
    if ( Resource->VSToken == NULL ) {
        DWORD   tokenStatus;
        LPWSTR  machinePwd;
        DWORD   pwdBufferByteLength = ((LM20_PWLEN + 1) * sizeof( WCHAR ));
        WCHAR   virtualDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
        WCHAR   domainName[ DNS_MAX_NAME_BUFFER_LENGTH ];
        DWORD   domainNameChars = COUNT_OF( domainName );

        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Getting a virtual computer account token.\n");

        //
        // didn't get one during online. get the password and try to log in
        // the account. get a buffer to hold the machine Pwd
        //
        virtualDollarName[ COUNT_OF( virtualDollarName ) - 1 ] = UNICODE_NULL;
        _snwprintf( virtualDollarName, COUNT_OF( virtualDollarName ) - 1, L"%ws$", Resource->Params.NetworkName );

        success = GetComputerNameEx( ComputerNameDnsDomain, domainName, &domainNameChars );
        if ( success ) {

            machinePwd = (PWCHAR)LocalAlloc( LMEM_FIXED, pwdBufferByteLength );
            if ( machinePwd != NULL ) {

                //
                // Extract the password from the ResourceData property.
                //
                status = DecryptNNResourceData(Resource,
                                               Resource->Params.ResourceData,
                                               Resource->ResDataSize,
                                               machinePwd);

                if ( status == ERROR_SUCCESS ) {
                    //
                    // get the token
                    //
                    status = NNLogonUser(resourceHandle,
                                         virtualDollarName,
                                         domainName,
                                         machinePwd,
                                         &Resource->VSToken,
                                         &tokenStatus);

                    if ( status == ERROR_SUCCESS ) {
                        if ( tokenStatus != ERROR_SUCCESS ) {
                            (NetNameLogEvent)(resourceHandle,
                                              LOG_ERROR,
                                              L"Unable to get token for computer account  - status %1!u!\n",
                                              tokenStatus);

                            status = tokenStatus;
                        }
                    }
                    else {
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_WARNING,
                                          L"Couldn't log the computer account into the domain. status 0x%1!08X!\n",
                                          status);
                    }

                } // was able to decrypt the password
                else {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Unable to decrypt resource data. status %1!u!\n",
                                      status );
                }

                RtlSecureZeroMemory( machinePwd, pwdBufferByteLength );
                LocalFree( machinePwd );

            } // allocated buffer for password
            else {
                status = GetLastError();
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Unable to allocate memory for resource data. status %1!u!.\n",
                                  status);
            }
        } // got DNS domain name
        else {
            status = GetLastError();
        }

        if ( status != ERROR_SUCCESS ) {
            return status;
        }
    }

    //
    // get a handle to the target process
    //
    targetProcess = OpenProcess(PROCESS_DUP_HANDLE,
                                FALSE,                      // no inherit
                                TokenInfo->ProcessID);

    if ( targetProcess == NULL ) {
        NTSTATUS    ntStatus;
        BOOLEAN     debugWasEnabled;
        DWORD       openProcessStatus;

        openProcessStatus = GetLastError();

        //
        // enable debug priv and try again
        //
        ntStatus = ClRtlEnableThreadPrivilege( SE_DEBUG_PRIVILEGE, &debugWasEnabled );
        if ( NT_SUCCESS( ntStatus )) {
            targetProcess = OpenProcess(PROCESS_DUP_HANDLE,
                                        FALSE,                      // no inherit
                                        TokenInfo->ProcessID);

            if ( targetProcess == NULL ) {
                openProcessStatus = GetLastError();
            }

            ntStatus = ClRtlRestoreThreadPrivilege( SE_DEBUG_PRIVILEGE, debugWasEnabled );

            if ( !NT_SUCCESS( ntStatus )) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Failed to disable DEBUG privilege, status %1!08X!.\n",
                                  ntStatus);
            }

        }
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Failed to enable DEBUG privilege, status %1!08X!.\n",
                              ntStatus);
        }

        if ( targetProcess == NULL ) {
            SetLastError( openProcessStatus );
        }
    }

    if ( targetProcess != NULL ) {
        DWORD   options = 0;

        //
        // if no specific access was requested, then dup the same access that
        // our impersonation token has
        //
        if ( TokenInfo->DesiredAccess == 0 ) {
            options = DUPLICATE_SAME_ACCESS;
        }

        success = DuplicateHandle(GetCurrentProcess(),
                                  Resource->VSToken,
                                  targetProcess,
                                  DuplicatedToken,
                                  TokenInfo->DesiredAccess,
                                  TokenInfo->InheritHandle,
                                  options);

        if ( !success ) {
            status = GetLastError();
        }

        CloseHandle( targetProcess );
    }
    else {
        status = GetLastError();
    }

    return status;

} // DuplicateVSToken


#ifdef PASSWORD_ROTATION
DWORD
UpdateCompObjPassword(
    IN  PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    return ERROR_SUCCESS;
} // UpdateCompObjPassword
#endif  // PASSWORD_ROTATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\netname\crypto.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    crypto.c

Abstract:

    routines for encrypting/decrypting resource data blob. uses crypto API to
    generate the key used to encrypt/decrypt the CO password. Key is stored as
    a crypto checkpoint associated with the resource.

Author:

    Charlie Wickham (charlwi) 14-Feb-2001

Environment:

    User Mode

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#include "clusres.h"
#include "clusrtl.h"
#include "netname.h"

#include <wincrypt.h>
#include <lm.h>

//
// defines
//

#define NN_GUID_STRING_BUFFER_LENGTH   37      // includes the terminating NULL

//
// header for encrypted data.
//

typedef struct _NETNAME_ENCRYPTED_DATA {
    DWORD Version;
    BYTE Data[0];
} NETNAME_ENCRYPTED_DATA, *PNETNAME_ENCRYPTED_DATA;

#define NETNAME_ENCRYPTED_DATA_VERSION     1

//
// Container name is the resource's GUID followed by this decoration
//
WCHAR   KeyDecoration[] = L"-Netname Resource Data";

DWORD
BuildKeyName(
    IN HRESOURCE    ResourceHandle,
    IN LPWSTR       KeyName,
    IN DWORD        KeyNameChars
    )

/*++

Routine Description:

    build the key name (resource GUID followed by decoration)

Arguments:

    ResourceHandle - handle to the cluster resource (not the one given to us
                     by resmon)

    KeyName - buffer to receive the constructed name

    KeyNameChars - size, in characteres, of KeyName

Return Value:

    success, otherwise Win32 error

--*/

{
    DWORD   status;
    DWORD   bytesReturned;
    DWORD   charsReturned;

    //
    // sanity check
    //
    if ( KeyNameChars < ( NN_GUID_STRING_BUFFER_LENGTH + COUNT_OF( KeyDecoration ))) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // get our GUID (ID) to uniquely identify this resource throughout renames
    //
    status = ClusterResourceControl(ResourceHandle,
                                    NULL,
                                    CLUSCTL_RESOURCE_GET_ID,
                                    NULL,
                                    0,
                                    KeyName,
                                    KeyNameChars * sizeof( WCHAR ),
                                    &bytesReturned);

    charsReturned = bytesReturned / sizeof( WCHAR );

    if ( status == ERROR_SUCCESS ) {
        if (( charsReturned + COUNT_OF( KeyDecoration )) <= KeyNameChars ) {
            wcscat( KeyName, KeyDecoration );
        } else {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    return status;
} // BuildKeyName

DWORD
FindNNCryptoContainer(
    IN  PNETNAME_RESOURCE   Resource,
    OUT LPWSTR *            ContainerName
    )

/*++

Routine Description:

    find our key name in the list of crypto checkpoints associated with this
    resource.

Arguments:

    Resource - pointer to resource context info

    ContainerName - address of pointer that gets pointer to container name

Return Value:

    success if it worked, otherwise Win32 error

--*/

{
    DWORD   status;
    DWORD   bytesReturned;
    LPWSTR  checkpointInfo = NULL;
    LPWSTR  chkpt;
    WCHAR   keyName[ NN_GUID_STRING_BUFFER_LENGTH + COUNT_OF( KeyDecoration ) ];

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    //
    // get our GUID (ID) to uniquely identify this resource throughout renames
    //
    status = ClusterResourceControl(Resource->ClusterResourceHandle,
                                    NULL,
                                    CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS,
                                    NULL,
                                    0,
                                    NULL,
                                    0,
                                    &bytesReturned);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't get size of crypto checkpoint info. status %1!u!.\n",
                          status);

        return status;
    }

    if ( bytesReturned == 0 ) {
        return ERROR_FILE_NOT_FOUND;
    }

    checkpointInfo = LocalAlloc( LMEM_FIXED, bytesReturned );
    if ( checkpointInfo == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't allocate memory for resource's crypto checkpoint info. status %1!u!.\n",
                          status);
        return status;
    }

    status = ClusterResourceControl(Resource->ClusterResourceHandle,
                                    NULL,
                                    CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS,
                                    NULL,
                                    0,
                                    checkpointInfo,
                                    bytesReturned,
                                    &bytesReturned);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't get crypto checkpoint info. status %1!u!.\n",
                          status);

        goto cleanup;
    }

    //
    // build our key name and look for it by walking the list of checkpoints
    //
    status = BuildKeyName(Resource->ClusterResourceHandle, keyName, COUNT_OF( keyName ));
    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't build key name for crypto checkpoint. status %1!u!.\n",
                          status);

        goto cleanup;
    }

    chkpt = wcsstr( checkpointInfo, keyName );
    if ( chkpt == NULL ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't find key name (%1!ws!) in list of crypto checkpoints.\n",
                          keyName);

        status = ERROR_INVALID_DATA;
        goto cleanup;
    }

    //
    // find the beginning of the string or the buffer, get the size, and move
    // our string to the beginning of the buffer (which is freed by the
    // caller)
    //
    while ( chkpt != checkpointInfo && *chkpt != UNICODE_NULL ) {
        --chkpt;
    }

    if ( chkpt != checkpointInfo ) {
        DWORD   stringBytes;

        ++chkpt;
        stringBytes = (wcslen( chkpt ) + 1 ) * sizeof( WCHAR );
        memmove( checkpointInfo, chkpt, stringBytes );
    }

    *ContainerName = checkpointInfo;

cleanup:
    if ( status != ERROR_SUCCESS && checkpointInfo != NULL ) {
        LocalFree( checkpointInfo );
        *ContainerName = NULL;
    }

    return status;
} // FindNNCryptoContainer


//
// exported routines
//

DWORD
EncryptNNResourceData(
    PNETNAME_RESOURCE   Resource,
    LPWSTR              MachinePwd,
    PBYTE *             EncryptedInfo,
    PDWORD              EncryptedInfoLength
    )

/*++

Routine Description:

    encrypt the password, set a pointer to the encrypted data and store it in
    the registry.

Arguments:

    ResourceHandle - for logging to the cluster log

    MachinePwd - pointer to unicode string password

    EncryptedInfo - address of a pointer that receives a pointer to the encrypted blob

    EncryptedInfoLength - pointer to a DWORD that receives the length of the blob

    Key - handle to netname parameters key where the data is stored

Return Value:

    ERROR_SUCCESS, otherwise Win32 error

--*/

{
    DWORD   status;
    DWORD   encInfoLength;
    DWORD   encDataLength = 0;
    BOOL    success;
    DWORD   pwdLength = ( wcslen( MachinePwd ) + 1 ) * sizeof( WCHAR );
    DWORD   provNameLength = 0;
    PCHAR   provName = NULL;
    DWORD   provTypeLength;
    WCHAR   typeBuffer[ 256 ];
    DWORD   containerNameChars;
    PWCHAR  containerName = NULL;
    WCHAR   keyName[ NN_GUID_STRING_BUFFER_LENGTH + COUNT_OF( KeyDecoration ) ];

    HCRYPTPROV  cryptoProvider = 0;
    HCRYPTKEY   encryptKey = 0;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    NETNAME_ENCRYPTED_DATA  keyGenBuffer;           // temp header buffer to generate key
    PNETNAME_ENCRYPTED_DATA encryptedInfo = NULL;   // final data area

    //
    // there shouldn't be a checkpoint on the resource but just in case, let's
    // cleanup what might be there.
    //
    RemoveNNCryptoCheckpoint( Resource );

    //
    // get our GUID (ID) to uniquely identify this resource throughout renames
    //
    status = BuildKeyName( Resource->ClusterResourceHandle, keyName, COUNT_OF( keyName ));
    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't get resource ID to build crypto container name. status %1!u!.\n",
                          status);

        return status;
    }

    //
    // get a handle to the full RSA provider
    //
    if ( !CryptAcquireContext(&cryptoProvider,
                              keyName,
                              MS_ENHANCED_PROV,
                              PROV_RSA_FULL,
                              CRYPT_MACHINE_KEYSET | CRYPT_SILENT))
    {
        status = GetLastError();
        if ( status == NTE_BAD_KEYSET ) {
            success = CryptAcquireContext(&cryptoProvider,
                                          keyName,
                                          MS_ENHANCED_PROV,
                                          PROV_RSA_FULL,
                                          CRYPT_MACHINE_KEYSET  |
                                          CRYPT_SILENT          |
                                          CRYPT_NEWKEYSET);

            status = success ? ERROR_SUCCESS : GetLastError();
        }

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Can't acquire crypto context for encrypt. status %1!u!.\n",
                              status);
            return status;
        }
    }

    //
    // generate a 1024 bit, exportable exchange key pair
    //
    if ( !CryptGenKey(cryptoProvider,
                      AT_KEYEXCHANGE,
                      ( 1024 << 16 ) | CRYPT_EXPORTABLE,
                      &encryptKey)) {

        status = GetLastError();
        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Can't generate exchange key for encryption. status %1!u!.\n",
                              status);
            goto cleanup;
        }
    }

    //
    // find the size we need for the buffer to receive the encrypted data
    //
    encDataLength = pwdLength;
    if ( CryptEncrypt(encryptKey,
                      0,
                      TRUE,
                      0,
                      NULL,
                      &encDataLength,
                      0))
    {
        //
        // alloc a buffer large enough to hold the data and copy the password into it.
        //
        ASSERT( encDataLength >= pwdLength );

        encInfoLength = sizeof( NETNAME_ENCRYPTED_DATA ) + encDataLength;

        encryptedInfo = LocalAlloc( LMEM_FIXED, encInfoLength );
        if ( encryptedInfo != NULL ) {
            wcscpy( (PWCHAR)encryptedInfo->Data, MachinePwd );

            if ( CryptEncrypt(encryptKey,
                              0,
                              TRUE,
                              0,
                              encryptedInfo->Data,
                              &pwdLength,
                              encDataLength))            
            {
                encryptedInfo->Version = NETNAME_ENCRYPTED_DATA_VERSION;

                status = ResUtilSetBinaryValue(Resource->ParametersKey,
                                               PARAM_NAME__RESOURCE_DATA,
                                               (const LPBYTE)encryptedInfo,
                                               encInfoLength,
                                               NULL,
                                               NULL);

                if ( status != ERROR_SUCCESS ) {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Can't write %1!u! bytes of data to registry. status %2!u!.\n",
                                      encInfoLength,
                                      status);
                    goto cleanup;
                }
            }
            else {
                status = GetLastError();
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Can't encrypt %1!u! bytes. status %2!u!.\n",
                                  pwdLength,
                                  status);
                goto cleanup;
            }
        }
        else {
            status = ERROR_NOT_ENOUGH_MEMORY;
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Can't allocate %1!u! bytes for encrypted data. status %2!u!.\n",
                              encInfoLength,
                              status);
            goto cleanup;
        }
    }
    else {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Can't determine size of encrypted data buffer for %1!u! bytes of data. status %2!u!.\n",
                          pwdLength,
                          status);
        goto cleanup;
    }

    *EncryptedInfoLength = encInfoLength;
    *EncryptedInfo = (PBYTE)encryptedInfo;

    //
    // it all worked; build the key container string and add a crypto
    // checkpoint to the resource. Note that provider name is always returned
    // as an ANSI string.
    //
    typeBuffer[ COUNT_OF( typeBuffer ) - 1 ] = UNICODE_NULL;
    _snwprintf( typeBuffer, COUNT_OF( typeBuffer ) - 1, L"%u", PROV_RSA_FULL );

    if ( !CryptGetProvParam(cryptoProvider,
                            PP_NAME,
                            NULL,
                            &provNameLength,
                            0))
    {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't get length of provider name. status %1!u!.\n",
                          status);
        goto cleanup;
    }

    provName = LocalAlloc( LMEM_FIXED, provNameLength );
    if ( provName == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't allocate memory for provider name. status %1!u!.\n",
                          status);
        goto cleanup;
    }

    if ( !CryptGetProvParam(cryptoProvider,
                            PP_NAME,
                            provName,
                            &provNameLength,
                            0))
    {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't get provider name. status %1!u!.\n",
                          status);
        goto cleanup;
    }

    //
    // add 2 for the slashes in the key name plus one for the trailing null
    //
    containerNameChars = wcslen( typeBuffer ) + provNameLength + wcslen( keyName ) + 3;
    containerName = LocalAlloc( LMEM_FIXED, containerNameChars * sizeof( WCHAR ));
    if ( containerName == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't allocate memory for checkpoint name. status %1!u!.\n",
                          status);
        goto cleanup;
    }

    containerName[ containerNameChars - 1 ] = UNICODE_NULL;
    containerNameChars = _snwprintf(containerName,
                                    containerNameChars,
                                    L"%ws%\\%hs\\%ws",
                                    typeBuffer,
                                    provName,
                                    keyName );

    status = ClusterResourceControl(Resource->ClusterResourceHandle,
                                    NULL,
                                    CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                    (PVOID)containerName,
                                    ( containerNameChars + 1 ) * sizeof( WCHAR ),
                                    NULL,
                                    0,
                                    NULL);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't set crypto checkpoint. status %1!u!.\n",
                          status);
    }

cleanup:

    if ( status != ERROR_SUCCESS && encryptedInfo != NULL ) {
        LocalFree( encryptedInfo );
        *EncryptedInfo = NULL;
    }

    if ( encryptKey != 0 ) {
        if ( !CryptDestroyKey( encryptKey )) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_WARNING,
                              L"Couldn't destory encryption key. status %1!u!.\n",
                              GetLastError());
        }
    }

    if ( !CryptReleaseContext( cryptoProvider, 0 )) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Can't release crypto context. status %1!u!.\n",
                          GetLastError());
    }

    if ( provName != NULL ) {
        LocalFree( provName );
    }

    if ( containerName != NULL ) {
        LocalFree( containerName );
    }

    return status;
} // EncryptNNResourceData

DWORD
DecryptNNResourceData(
    PNETNAME_RESOURCE   Resource,
    PBYTE               EncryptedInfo,
    DWORD               EncryptedInfoLength,
    LPWSTR              MachinePwd
    )

/*++

Routine Description:

    Reverse of encrypt routine - find our crypto checkpoint container and
    decrypt random blob and hand back the password

Arguments:

    resourceHandle - used to log into the cluster log

    EncryptedInfo - pointer to encrypted info header and data

    EncryptedInfoLength - # of bytes in EncryptedInfo

    MachinePwd -  pointer to buffer that receives the unicode password

Return Value:

    ERROR_SUCCESS, otherwise Win32 error

--*/

{
    DWORD   status = ERROR_SUCCESS;
    DWORD   encDataLength = EncryptedInfoLength - sizeof( NETNAME_ENCRYPTED_DATA );
    DWORD   pwdByteLength;
    DWORD   pwdBufferSize;
    PWCHAR  machinePwd = NULL;
    PWCHAR  containerName = NULL;
    DWORD   providerType;
    PWCHAR  providerName;
    PWCHAR  keyName;
    PWCHAR  p;                  // for scanning checkpointInfo
    DWORD   scanCount;

    HCRYPTPROV  cryptoProvider = 0;
    HCRYPTKEY   encryptKey = 0;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    PNETNAME_ENCRYPTED_DATA encryptedInfo = (PNETNAME_ENCRYPTED_DATA)EncryptedInfo;

    //
    // find our container name in this resource's list of crypto checkpoints
    //
    status = FindNNCryptoContainer( Resource, &containerName );
    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't find resource's container in crypto checkpoint info. status %1!u!.\n",
                          status);

        return status;
    }

    //
    // break returned data into component parts
    //
    scanCount = swscanf( containerName, L"%d", &providerType );
    if ( scanCount == 0 || scanCount == EOF ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Improperly formatted crypto checkpoint info \"%1!ws!\"\n",
                          containerName);

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    p = containerName;
    while ( *p != L'\\' && *p != UNICODE_NULL ) ++p;    // find backslash
    if ( *p == UNICODE_NULL ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Improperly formatted crypto checkpoint info \"%1!ws!\"\n",
                          containerName);

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ++p;                                                // skip over slash
    providerName = p;                                   // remember beginning of provider name
    while ( *p != L'\\' && *p != UNICODE_NULL ) ++p;    // find backslash
    if ( *p == UNICODE_NULL ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Improperly formatted crypto checkpoint info \"%1!ws!\"\n",
                          containerName);

        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    *p++ = UNICODE_NULL;                                // terminate provider name and skip over NULL
    keyName = p;                                     // remember container name
    
    //
    // get a handle to what was checkpointed
    //
    if ( !CryptAcquireContext(&cryptoProvider,
                              keyName,
                              providerName,
                              providerType,
                              CRYPT_MACHINE_KEYSET | CRYPT_SILENT))
    {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Can't acquire crypto context for container %1!ws! with provider "
                          L"\"%2!u!\\%3!ws!\". status %4!u!.\n",
                          keyName,
                          providerType,
                          providerName,
                          status);

        goto cleanup;
    }

    //
    // now get a handle to the exchange key
    //
    if ( ! CryptGetUserKey(cryptoProvider,
                           AT_KEYEXCHANGE,
                           &encryptKey))
    {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Couldn't get size of crypto checkpoint info. status %1!u!.\n",
                          status);
        goto cleanup;
    }

    //
    // CryptDecrypt writes the decrypted data back into the buffer that was
    // holding the encrypted data. For this reason, allocate a new buffer that
    // will eventually contain the password.
    //
    pwdByteLength = ( LM20_PWLEN + 1 ) * sizeof( WCHAR );
    pwdBufferSize = ( pwdByteLength > encDataLength ? pwdByteLength : encDataLength );

    machinePwd = LocalAlloc( LMEM_FIXED, pwdBufferSize );
    if ( machinePwd != NULL ) {
        RtlCopyMemory( machinePwd, encryptedInfo->Data, encDataLength );

        if ( CryptDecrypt(encryptKey,
                          0,
                          TRUE,
                          0,
                          (PBYTE)machinePwd,
                          &encDataLength))
        {
            p = machinePwd;

            ASSERT( pwdByteLength == encDataLength );
            wcscpy( MachinePwd, machinePwd );

            while ( *p != UNICODE_NULL ) {
                *p++ = UNICODE_NULL;
            }
        }
        else {
            status = GetLastError();
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Can't decrypt %1!u! bytes of data. status %2!u!.\n",
                              encDataLength,
                              status);
            goto cleanup;
        }
    }
    else {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Can't allocate %1!u! bytes for decrypt. status %2!u!.\n",
                          pwdBufferSize,
                          status);
    }

cleanup:

    if ( machinePwd != NULL) {
        LocalFree( machinePwd );
    }

    if ( encryptKey != 0 ) {
        if ( !CryptDestroyKey( encryptKey )) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_WARNING,
                              L"Couldn't destory session key. status %1!u!.\n",
                              GetLastError());
        }
    }

    if ( cryptoProvider != 0 ) {
        if ( !CryptReleaseContext( cryptoProvider, 0 )) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_WARNING,
                              L"Can't release crypto context. status %1!u!.\n",
                              GetLastError());
        }
    }

    if ( containerName != NULL ) {
        LocalFree( containerName );
    }

    return status;
} // DecryptNNResourceData

VOID
RemoveNNCryptoCheckpoint(
    PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    Remove any crypto checkpoints associated with this resource. Delete the
    crypto container.

Arguments:

    Resource - pointer to resource context block

Return Value:

    None

--*/

{
    PWCHAR  containerName = NULL;
    DWORD   containerLength;
    DWORD   status;
    WCHAR   keyName[ NN_GUID_STRING_BUFFER_LENGTH + COUNT_OF( KeyDecoration ) ];

    HCRYPTPROV  cryptoProvider;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    //
    // find our container name in this resource's list of crypto checkpoints
    //
    status = FindNNCryptoContainer( Resource, &containerName );
    if ( status != ERROR_SUCCESS ) {
        return;
    }

    //
    // remove our container
    //
    containerLength = ( wcslen( containerName ) + 1 ) * sizeof( WCHAR );
    status = ClusterResourceControl(Resource->ClusterResourceHandle,
                                    NULL,
                                    CLUSCTL_RESOURCE_DELETE_CRYPTO_CHECKPOINT,
                                    containerName,
                                    containerLength,
                                    NULL,
                                    0,
                                    NULL);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Couldn't remove crypto checkpoint \"%1!ws!\". status %2!u!.\n",
                          containerName,
                          status);
    }

    //
    // now delete the container; first, reconstruct the key name
    //
    status = BuildKeyName(Resource->ClusterResourceHandle, keyName, COUNT_OF( keyName ));
    if ( status == ERROR_SUCCESS ) {

        if ( CryptAcquireContext(&cryptoProvider,
                                  keyName,
                                  MS_ENHANCED_PROV,
                                  PROV_RSA_FULL,
                                  CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET))
        {
            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"Deleted crypto container \"%1!ws!\".\n",
                              keyName);
        } else {
            status = GetLastError();
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Couldn't delete crypto container \"%1!ws!\". status %2!08X!.\n",
                              keyName,
                              status);
        }
    } else {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Couldn't build key container name to delete crypto container. status %1!u!.\n",
                          status);
    }

    if ( containerName != NULL ) {
        LocalFree( containerName );
    }

} // RemoveNNCryptoCheckpoint


/* end crypto.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\netname\nameutil.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    nameutil.h

Abstract:

    Routines for manipulating LM workstation and server names.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/

#include <windns.h>
#include <dnsapi.h>

#define NetNameSetResourceStatus    ClusResSetResourceStatus

//
// definitions
//

//
// function definitions
//

NET_API_STATUS
AddAlternateComputerName(
    IN     PCLUS_WORKER             Worker,
    IN     PNETNAME_RESOURCE        Resource,
    IN     LPWSTR *                 TransportList,
    IN     DWORD                    TransportCount,
    IN     PDOMAIN_ADDRESS_MAPPING  DomainMapList,
    IN     DWORD                    DomainMapCount
    );

VOID
DeleteAlternateComputerName(
    IN LPWSTR           AlternateComputerName,
    IN LPWSTR           DomainName                  OPTIONAL,
    IN HANDLE *         NameHandleList,
    IN DWORD            NameHandleCount,
    IN RESOURCE_HANDLE  ResourceHandle
    );

NET_API_STATUS
DeleteServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName
    );

DWORD
RegisterDnsRecords(
    IN  PDNS_LISTS       DnsLists,
    IN  LPWSTR           NetworkName,
    IN  HKEY             ResourceKey,
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  BOOL             LogRegistration,
    OUT PULONG           NumberOfRegisteredNames
    );

LPWSTR
BuildUnicodeReverseName(
    IN  LPWSTR  IpAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\netname\nameutil.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    nameutil.c

Abstract:

    Routines for manipulating LM workstation and server names.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/

#define UNICODE 1

#include "clusres.h"
#include "clusrtl.h"
#include <tdi.h>
#include <lm.h>
#include <stdlib.h>
#include "netname.h"
#include "nameutil.h"
#include <dnsapi.h>
#include <dnslib.h>
#include <adserr.h>
#include <kerberos.h>

//
// Constants
//
#define LOG_CURRENT_MODULE LOG_MODULE_NETNAME

//
// Local types
//
typedef enum _NETNAME_CREDENTIAL_OPERATION {
    NNAddCredential = 1,
    NNRemoveCredential
} NETNAME_CREDENTIAL_OPERATION;

//
// forward declarations
//
VOID
LogDnsFailureToEventLog(
    IN  HKEY    ResourceKey,
    IN  LPWSTR  DnsName,
    IN  LPWSTR  ResourceName,
    IN  DWORD   Status,
    IN  LPWSTR  ConnectoidName
    );

//
// Local Utility Routines
//

NET_API_STATUS
CheckForServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName,
    IN  POEM_STRING      OemServerNameString,
    OUT PBOOLEAN         IsNameRegistered
    )
{
    PSERVER_TRANSPORT_INFO_0   psti0 = NULL;
    DWORD                      entriesRead = 0;
    DWORD                      totalEntries = 0;
    DWORD                      resumeHandle = 0;
    NET_API_STATUS             status;
    DWORD                      i;


    *IsNameRegistered = FALSE;

    status = NetServerTransportEnum(
                NULL,
                0,
                (LPBYTE *) &psti0,
                (DWORD) -1,
                &entriesRead,
                &totalEntries,
                &resumeHandle
                );

    if (status != NERR_Success) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_WARNING,
            L"Unable to enumerate server tranports, error %1!u!.\n",
            status
            );
        return(status);
    }

    for ( i=0; i < entriesRead; i++ ) {
        if ( ( psti0[i].svti0_transportaddresslength ==
               OemServerNameString->Length
             )
             &&
             ( RtlCompareMemory(
                   psti0[i].svti0_transportaddress,
                   OemServerNameString->Buffer,
                   OemServerNameString->Length
                   ) == OemServerNameString->Length
             )
           )
        {
            *IsNameRegistered = TRUE;
            break;
        }
    }

    if (psti0 != NULL) {
        LocalFree(psti0);
    }

    return(status);

}  // CheckForServerName


NET_API_STATUS
pDeleteServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName,
    IN  POEM_STRING      OemServerNameString
    )
{
    NET_API_STATUS    status;
    BOOLEAN           isNameRegistered;
    DWORD             count;

    //
    // Delete the name
    //
    status = NetServerComputerNameDel(NULL, ServerName);

    if (status != NERR_Success) {
        if (status != ERROR_BAD_NET_NAME) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Failed to delete server name %1!ws!, status %2!u!.\n",
                ServerName,
                status
                );
        }

        return(status);
    }

    //
    // Check to make sure the name was really deleted. We'll wait up
    // to 2 seconds.
    //
    for (count = 0; count < 8; count++) {

        status = CheckForServerName(
                     ResourceHandle,
                     ServerName,
                     OemServerNameString,
                     &isNameRegistered
                     );

        if (status != NERR_Success) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Unable to verify that server name %1!ws! was deleted, status %2!u!.\n",
                ServerName,
                status
                );
            return(NERR_Success);
        }

        if (isNameRegistered == FALSE) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_INFORMATION,
                L"Deleted server name %1!ws! from all transports.\n",
                ServerName
                );

            return(NERR_Success);
        }

        Sleep(250);
    }

    (NetNameLogEvent)(
        ResourceHandle,
        LOG_WARNING,
        L"Delete of server name %1!ws! succeeded, but name still has not gone away. "
        L"Giving up.\n",
        ServerName
        );

    return(ERROR_IO_PENDING);

}  // pDeleteServerName

DWORD
NNCredentialOperation(
    RESOURCE_HANDLE                 ResourceHandle,
    LPWSTR                          ComputerName,
    LPWSTR                          DomainName,
    LPWSTR                          Password            OPTIONAL,
    NETNAME_CREDENTIAL_OPERATION    CredOp
    )

/*++

Routine Description:

    Add or remove the specified credentials as alternates for the LocalSystem
    and NetworkService accounts.

    Remove will remove all passwords associated with the account. Repeated
    Adds will move the current password into the old password, obliterating
    it, and make the supplied password the new one. The password cache is 2
    deep FIFO.

Arguments:

    ResourceHandle - for logging to cluster log

    ComputerName - pointer to the computer account principal name

    DomainName - FQDN of domain associated with ComputerName

    Password - the password associated with this account. Not used for remove

    CredOp - indicates whether to add or remove credential

Return Value:

    ERROR_SUCCESS if ok, otherwise Win32 error

--*/

{
    HANDLE  lsaHandle;
    ULONG   packageId;
    LUID    networkServiceLuid = NETWORKSERVICE_LUID;
    LUID    localSystemLuid = SYSTEM_LUID;
    PWCHAR  opTypeString;
    BOOLEAN tcbWasEnabled;
    DWORD   requestSize;

    NTSTATUS    ntStatus;
    NTSTATUS    subStatus;

    LSA_STRING  packageName;

    PKERB_ADD_CREDENTIALS_REQUEST    addCredsRequest;

    //
    // compute the total size of the request buffer and allocate that space
    //
    requestSize = sizeof( KERB_ADD_CREDENTIALS_REQUEST )
                  +
                  ( wcslen( ComputerName ) + 2          // 2 for dollar sign and null
                    +
                    wcslen( DomainName ) + 1
                  )
                  * sizeof( WCHAR );

    if ( ARGUMENT_PRESENT( Password )) {
        requestSize += ( wcslen( Password ) + 1 ) * sizeof( WCHAR );
    }

    addCredsRequest = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, requestSize );
    if ( addCredsRequest == NULL ) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Unable to allocate memory for LSA credential operation.\n");
        return GetLastError();
    }

    //
    // validate type of operation
    //
    if ( CredOp == NNAddCredential ) {
        opTypeString = L"add";
        addCredsRequest->Flags = KERB_REQUEST_ADD_CREDENTIAL;
    }
    else if ( CredOp == NNRemoveCredential ) {
        opTypeString = L"remove";
        addCredsRequest->Flags = KERB_REQUEST_REMOVE_CREDENTIAL;
    } else {
        LocalFree( addCredsRequest );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // enable TCB for this thread
    //
    ntStatus = ClRtlEnableThreadPrivilege( SE_TCB_PRIVILEGE, &tcbWasEnabled );
    if ( NT_SUCCESS( ntStatus )) {
        NTSTATUS    privStatus;

        //
        // get handle to LSA
        //
        ntStatus = LsaConnectUntrusted( &lsaHandle );
        if ( NT_SUCCESS( ntStatus )) {

            //
            // get kerb package ID
            //
            RtlInitString( &packageName, MICROSOFT_KERBEROS_NAME_A );
            ntStatus = LsaLookupAuthenticationPackage( lsaHandle, &packageName, &packageId );
            if ( NT_SUCCESS( ntStatus )) {

                PCHAR   response = NULL;
                ULONG   responseSize;
                PWCHAR  credStrings = (PWCHAR)( addCredsRequest + 1 );

                addCredsRequest->MessageType = KerbAddExtraCredentialsMessage;

                //
                // build the request by appending the strings after the
                // request structure and initializing the UNICODE_STRING
                // structs to the strings in that area.
                //
                wcscpy( credStrings, ComputerName );
                wcscat( credStrings, L"$" );
                RtlInitUnicodeString( &addCredsRequest->UserName, credStrings );

                credStrings = credStrings + wcslen( credStrings ) + 1;
                wcscpy( credStrings, DomainName );
                RtlInitUnicodeString( &addCredsRequest->DomainName, credStrings );

                if ( CredOp == NNAddCredential ) {
                    credStrings = credStrings + wcslen( credStrings ) + 1;
                    wcscpy( credStrings, Password );
                    RtlInitUnicodeString( &addCredsRequest->Password, credStrings );
                } else {
                    addCredsRequest->Password.Length = 0;
                    addCredsRequest->Password.MaximumLength = 0;
                    addCredsRequest->Password.Buffer = NULL;
                }

                //
                // add creds to LocalSystem
                //
                addCredsRequest->LogonId = localSystemLuid;

                ntStatus = LsaCallAuthenticationPackage(lsaHandle,
                                                        packageId,
                                                        addCredsRequest,
                                                        requestSize,
                                                        (PVOID *) &response,
                                                        &responseSize,
                                                        &subStatus);

                if ( NT_SUCCESS( ntStatus ) && NT_SUCCESS( subStatus )) {
                    if ( response != NULL ) {
                        LsaFreeReturnBuffer( response );
                        response = NULL;
                    }

                    //
                    // now add them for the NetworkService account
                    //
                    addCredsRequest->LogonId = networkServiceLuid;
                    ntStatus = LsaCallAuthenticationPackage(lsaHandle,
                                                            packageId,
                                                            addCredsRequest,
                                                            requestSize,
                                                            (PVOID *) &response,
                                                            &responseSize,
                                                            &subStatus);

                    if ( NT_SUCCESS( ntStatus ) && NT_SUCCESS( subStatus )) {
                        if ( response != NULL ) {
                            LsaFreeReturnBuffer( response );
                        }
                    } else {
                        if ( NT_SUCCESS( ntStatus )) {
                            ntStatus = subStatus;
                        }
                        (NetNameLogEvent)(ResourceHandle,
                                          LOG_ERROR,
                                          L"Unable to %1!ws! credentials for NetworkService "
                                          L"- status %2!08X!\n",
                                          opTypeString,
                                          ntStatus);
                    }

                }       // if credentials were added to LocalSystem
                else {
                    if ( NT_SUCCESS( ntStatus )) {
                        ntStatus = subStatus;
                    }

                    (NetNameLogEvent)(ResourceHandle,
                                      LOG_ERROR,
                                      L"Unable to %1!ws! credentials for LocalSystem "
                                      L"- status %2!08X!\n",
                                      opTypeString,
                                      ntStatus);
                }

            }       // if we found the kerb package in LSA
            else {
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_ERROR,
                                  L"Unable to get package ID of Kerberos package from LSA - status %1!08X!\n",
                                  ntStatus);
            }

            LsaDeregisterLogonProcess( lsaHandle );

        }       // if an untrusted handle to LSA was obtained
        else {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Unable to get an untrusted handle to LSA - status %1!08X!\n",
                              ntStatus);
        }

        privStatus = ClRtlRestoreThreadPrivilege( SE_TCB_PRIVILEGE, tcbWasEnabled );

        if ( !NT_SUCCESS( privStatus )) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Failed to disable TCB privilege, "
                              L"status %1!08X!.\n",
                              privStatus);
        }

    }       // if TCB was enabled
    else {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Failed to enable TCB privilege, status %1!08X!.\n",
                          ntStatus);
    }

    LocalFree( addCredsRequest );

    return LsaNtStatusToWinError( ntStatus );
} // NNCredentialOperation

NET_API_STATUS
AddServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName,
    IN  BOOL             RemapPipeNames,
    IN  LPWSTR           TransportName,
    IN  BOOLEAN          CheckNameFirst
    )
{
    SERVER_TRANSPORT_INFO_2   sti2;
    UCHAR                     netBiosName[ NETBIOS_NAME_LEN ];
    OEM_STRING                netBiosNameString;
    UNICODE_STRING            unicodeName;
    NET_API_STATUS            status;
    NTSTATUS                  ntStatus;


    //
    // Convert the ServerName to an OEM string
    //
    RtlInitUnicodeString( &unicodeName, ServerName );

    netBiosNameString.Buffer = (PCHAR)netBiosName;
    netBiosNameString.MaximumLength = sizeof( netBiosName );

    ntStatus = RtlUpcaseUnicodeStringToOemString(
                   &netBiosNameString,
                   &unicodeName,
                   FALSE
                   );

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to convert name %1!ws! to an OEM string, status %2!u!\n",
            ServerName,
            status
            );
        return(status);
    }

    if (CheckNameFirst) {
        BOOLEAN  isNameRegistered;

        //
        // Check to see if the name is already registered.
        //
        status = CheckForServerName(
                     ResourceHandle,
                     ServerName,
                     &netBiosNameString,
                     &isNameRegistered
                     );

        if (status != NERR_Success) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Unable to verify that server name %1!ws! does not already exist.\n",
                ServerName
                );
            isNameRegistered = TRUE;   // just to be safe
        }

        if (isNameRegistered) {
            (NetNameLogEvent)(
                ResourceHandle,
                LOG_INFORMATION,
                L"Deleting old registration for server name %1!ws!.\n",
                ServerName
                );

            status = pDeleteServerName(
                         ResourceHandle,
                         ServerName,
                         &netBiosNameString
                         );

            if (status != NERR_Success) {
                if (status == ERROR_IO_PENDING) {
                    status = ERROR_GEN_FAILURE;
                }

                return(status);
            }
        }
    }

    //
    // Register the name on the specified transport.
    //
    RtlZeroMemory( &sti2, sizeof(sti2) );
    sti2.svti2_transportname = TransportName;
    sti2.svti2_transportaddress = netBiosName;
    sti2.svti2_transportaddresslength = strlen(netBiosName);

    if (RemapPipeNames) {
        sti2.svti2_flags = SVTI2_REMAP_PIPE_NAMES;
    }

    status = NetServerTransportAddEx( NULL, 2, (LPBYTE)&sti2 );

    if (status != NERR_Success) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to add server name %1!ws! to transport %2!ws!, status %3!u!.\n",
            ServerName,
            TransportName,
            status
            );
    }
    else {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Registered server name %1!ws! on transport %2!ws!.\n",
            ServerName,
            TransportName
            );
    }

    return(status);

}  // AddServerName

NET_API_STATUS
DeleteServerName(
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  LPWSTR           ServerName
    )
{
    NET_API_STATUS             status;
    NTSTATUS                   ntStatus;
    UCHAR                      netBiosName[ NETBIOS_NAME_LEN ];
    OEM_STRING                 netBiosNameString;
    UNICODE_STRING             unicodeName;
    BOOLEAN                    isNameRegistered;
    DWORD                      count;


    //
    // Convert the ServerName to an OEM string
    //
    RtlInitUnicodeString( &unicodeName, ServerName );

    netBiosNameString.Buffer = (PCHAR)netBiosName;
    netBiosNameString.MaximumLength = sizeof( netBiosName );

    ntStatus = RtlUpcaseUnicodeStringToOemString(
                   &netBiosNameString,
                   &unicodeName,
                   FALSE
                   );

    if (ntStatus != STATUS_SUCCESS) {
        status = RtlNtStatusToDosError(ntStatus);
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to convert name %1!ws! to an OEM string, status %2!u!\n",
            ServerName,
            status
            );
        return(status);
    }

    //
    // Delete the name
    //
    status = pDeleteServerName(
                 ResourceHandle,
                 ServerName,
                 &netBiosNameString
                 );

    if (status == ERROR_IO_PENDING) {
        status = NERR_Success;
    }

    return(status);

}  // DeleteServerName


DWORD
AddWorkstationName(
    IN LPWSTR WorkstationName,
    IN LPWSTR TransportName,
    IN RESOURCE_HANDLE ResourceHandle,
    OUT HANDLE * WorkstationNameHandle
    )

/*++

Routine Description:

    This function adds an alternate workstation ( <0> ) name on a netbios
    transport by opening a TDI address object. The name remains registered
    as long as the address object is open.

Arguments:

    WorkstationName - Alternate computer name to add.

    TransportName - Transport to add the computer name on.

Return Value:

    Status - The status of the operation.

--*/

{
    DWORD                      status;
    PFILE_FULL_EA_INFORMATION  eaBuffer;
    DWORD                      eaLength;
    OBJECT_ATTRIBUTES          objectAttributes;
    IO_STATUS_BLOCK            ioStatusBlock;
    UNICODE_STRING             transportString;
    DWORD                      i;
    PTA_NETBIOS_ADDRESS        taAddress;
    UNICODE_STRING             unicodeName;
    OEM_STRING                 oemName;
    PUCHAR                     nameBuffer;


    *WorkstationNameHandle = NULL;

    //
    // Allocate an extended attribute to hold the TDI address
    //
    eaLength = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
               TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
               sizeof(TA_NETBIOS_ADDRESS);

    eaBuffer = LocalAlloc( LMEM_FIXED, eaLength);

    if (eaBuffer == NULL) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate memory for name registration.\n"
            );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    eaBuffer->NextEntryOffset = 0;
    eaBuffer->Flags = 0;
    eaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    eaBuffer->EaValueLength = sizeof(TA_NETBIOS_ADDRESS);

    CopyMemory(
        eaBuffer->EaName,
        TdiTransportAddress,
        eaBuffer->EaNameLength+1
        );


    //
    // Build the TDI NetBIOS Address structure
    //
    taAddress = (PTA_NETBIOS_ADDRESS) (eaBuffer->EaName +
                                       TDI_TRANSPORT_ADDRESS_LENGTH + 1);
    taAddress->TAAddressCount = 1;
    taAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    taAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    taAddress->Address[0].Address[0].NetbiosNameType =
                                                 TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    //
    // Canonicalize the name by converting to an upper case OEM string,
    // padding with spaces, and ending with a 0x0.
    //
    nameBuffer =  &(taAddress->Address[0].Address[0].NetbiosName[0]);

    oemName.Buffer = nameBuffer;
    oemName.Length = 0;
    oemName.MaximumLength = NETBIOS_NAME_LEN;

    RtlInitUnicodeString(&unicodeName, WorkstationName);

    status = RtlUpcaseUnicodeStringToOemString(
                                &oemName,
                                &unicodeName,
                                FALSE
                                );

    if (status != STATUS_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to convert name %1!ws! to an OEM string, status %2!u!\n",
            WorkstationName,
            status
            );
        LocalFree(eaBuffer);
        return(RtlNtStatusToDosError(status));
    }

    for (i=oemName.Length; i < (NETBIOS_NAME_LEN - 1); i++) {
        nameBuffer[i] = 0x20;
    }

    nameBuffer[NETBIOS_NAME_LEN-1] = 0;

    //
    // Open an address object handle.
    //
    RtlInitUnicodeString(&transportString, TransportName);

    InitializeObjectAttributes(
        &objectAttributes,
        &transportString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile(
                 WorkstationNameHandle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 0,
                 eaBuffer,
                 eaLength
                 );

    if (status == STATUS_SUCCESS) {
        status = ioStatusBlock.Status;
    }

    LocalFree(eaBuffer);

    status = RtlNtStatusToDosError(status);

    if (status != ERROR_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to register workstation name %1!ws! on transport %2!ws!, "
            L"error %3!u!.\n",
            WorkstationName,
            TransportName,
            status
            );
    }
    else {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Registered workstation name %1!ws! on transport %2!ws!.\n",
            WorkstationName,
            TransportName
            );
    }

    return(status);

} // AddWorkstationName

DNS_STATUS
AddDnsNames(
    IN     PCLUS_WORKER             Worker,
    IN     LPWSTR                   AlternateComputerName,
    IN     HKEY                     ResourceKey,
    IN     RESOURCE_HANDLE          ResourceHandle,
    IN     PDOMAIN_ADDRESS_MAPPING  DomainMapList,
    IN     DWORD                    DomainMapCount,
    IN     BOOL                     FailOnAnyError,
    OUT    PULONG                   NumberOfDnsLists,
    OUT    PDNS_LISTS *             DnsLists,
    OUT    PULONG                   NumberOfRegisteredNames
    )

/*++

Routine Description:

    For the given set of IP addresses and their corresponding DNS domains,
    build DNS records that will register the network name in the domain(s)
    associated with the IP address. Lists of A and PTR records are built which
    are used by RegisterDnsRecords to publish the name/address associations at
    the DNS server. If the names can't be registered now,
    NetNameUpdateDnsServer will attempt to register them. This is the only
    shot at building the lists; if this portion fails, then the resource is
    failed.

    This routine also checks for whether a DNS zone accepts dynamic
    updates. DnsUpdateTest will tell us if the zone is dynamic or not, and if
    dynamic and integrated with the DS as a secure zone, whether the caller
    has sufficient permission to modify the entry.

    For non-dynamic zones, Netbios ends up being the only mechanism by which a
    name gets registered and therefore, DNS registration failures are not
    fatal unless the RequireDNS property is set to true.

    If the zone is dynamic but the caller lacks sufficient permission, we view
    that as DNS having precedence over Netbios. In that case, the resource is
    failed.

 Arguments:

    Worker - used to check if we should terminate early

    AlternateComputerName - NetBIOS network name to be registered

    ResourceKey - used to log events to the system event log

    ResourceHandle - for logging to the cluster log

    DomainMapList - list of IP address domain names pairs for registration

    DomainMapCount - # of entries in DomainMapList

    FailOnAnyError - used to enforce RequireDNS; true if we should bail on any
                     error

    NumberOfDnsLists - pointer to location of final count of entries in DnsLists

    DnsLists - array of lists that contain A and PTR listheads

    NumberOfRegisteredNames - pointer to location of final count of names that
                              actually got registered

Return Value:

    DNS_STATUS indicating whether it worked or not. If the DNS lists couldn't
    be built, always return an error.

--*/

{
    LPWSTR          fqNameARec = NULL;
    LPWSTR          fqNamePTRRec = NULL;
    DWORD           fqNameLength;
    DWORD           listheadFreeEntries = 0;
    DWORD           listheadCount = 0;
    PDNS_LISTS      dnsLists = NULL;
    DWORD           mapIndex;
    DWORD           index;
    DNS_STATUS      dnsStatus = DNS_ERROR_RCODE_NO_ERROR;
    DNS_STATUS      ptrRecStatus;
    PDNS_RECORD     PTRRecord;
    PDNS_RECORD     ARecord;
    LPWSTR          PTRName = NULL;
    BOOL            ARecTimeout;
    BOOL            PTRRecTimeout;

    //
    // run through the list of domain map structs and register the names where
    // appopriate
    //
    for ( mapIndex = 0; mapIndex < DomainMapCount; ++mapIndex ) {

        if ( ClusWorkerCheckTerminate( Worker )) {
            dnsStatus = ERROR_OPERATION_ABORTED;
            goto error_exit;
        }

        ASSERT( DomainMapList[ mapIndex ].DomainName != NULL );

        //
        // create the fully qualified DNS name and make a copy for the PTR
        // records. DnsRecordListFree operates in a way that makes it
        // difficult to use the same buffer multiple times. It is easier to
        // allocate separate buffers for everything and let DnsRecordListFree
        // clean up.
        //
        fqNameLength = (wcslen( DomainMapList[ mapIndex ].DomainName ) +
                        wcslen( AlternateComputerName ) +
                        2                                   // one for "." and one for null
                       )
                       * sizeof( WCHAR );

        fqNameARec = LocalAlloc( LMEM_FIXED, fqNameLength );
        fqNamePTRRec = LocalAlloc( LMEM_FIXED, fqNameLength );
        if ( fqNameARec == NULL || fqNamePTRRec == NULL ) {
            dnsStatus = GetLastError();
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Can't allocate memory for DNS name for address %1!ws!, "
                              L"status %2!u!.\n",
                              DomainMapList[ mapIndex ].IpAddress,
                              dnsStatus);
            goto error_exit;
        }

        wcscpy( fqNameARec, AlternateComputerName );
        wcscat( fqNameARec, L"." );
        wcscat( fqNameARec, DomainMapList[ mapIndex ].DomainName );
        _wcslwr( fqNameARec );

        wcscpy( fqNamePTRRec, fqNameARec );

        //
        // see if this domain is updatable.
        //
        ARecTimeout = FALSE;
        dnsStatus = DnsUpdateTest(NULL,
                                  fqNameARec,
                                  0,
                                  DomainMapList[ mapIndex ].DnsServerList);

#if DBG_DNSLIST
        {
            WCHAR buf[DNS_MAX_NAME_BUFFER_LENGTH + 64];
            struct in_addr addr;

            addr.s_addr = DomainMapList[ mapIndex ].DnsServerList->AddrArray[0];
            buf[ COUNT_OF( buf ) - 1 ] = UNICODE_NULL;
            _snwprintf(buf, COUNT_OF( buf ) - 1,
                       L"AddDnsNames UPDATETEST: %ws on %.32ws (%hs) returned %u\n",
                       fqNameARec,
                       DomainMapList[ mapIndex ].ConnectoidName,
                       inet_ntoa( addr ),
                       dnsStatus);
            OutputDebugStringW( buf );
        }
#endif

        if ( dnsStatus == DNS_ERROR_RCODE_NOT_IMPLEMENTED ) {
            //
            // zone does not accept dynamic updates.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_INFORMATION,
                              L"%1!ws! does not accept dynamic DNS registration updates over "
                              L"adapter '%2!ws!'.\n",
                              DomainMapList[ mapIndex ].DomainName,
                              DomainMapList[ mapIndex ].ConnectoidName);

            //
            // by freeing the name storage, we'll never to be able to register
            // the name. On the other hand, if the zone was changed to be
            // dynamic while the name was online, the admin would have to wait
            // 20 minutes before we would retry the registration. I suspect
            // that cycling the name would be preferred.
            //
            LocalFree( fqNameARec );
            LocalFree( fqNamePTRRec );

            fqNameARec = NULL;
            fqNamePTRRec = NULL;

            if ( FailOnAnyError ) {
                goto error_exit;
            } else {
                continue;
            }
        } else if ( dnsStatus == DNS_ERROR_RCODE_REFUSED ) {
            //
            // secure zone and we don't have credentials to change the
            // name. fail the resource.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"%1!ws! is a secure zone and has refused the registration of "
                              L"%2!ws! over adapter '%3!ws!'.\n",
                              DomainMapList[ mapIndex ].DomainName,
                              fqNameARec,
                              DomainMapList[ mapIndex ].ConnectoidName);

            LogDnsFailureToEventLog(ResourceKey,
                                    fqNameARec,
                                    AlternateComputerName,
                                    dnsStatus,
                                    DomainMapList[ mapIndex ].ConnectoidName);

            if ( FailOnAnyError ) {
                goto error_exit;
            } else {
                continue;
            }

        } else if ( dnsStatus == ERROR_TIMEOUT ) {
            //
            // couldn't contact a server so we're not sure if it allows
            // updates or not. build the records anyway and we'll deal with it
            // during the query period
            //
            if ( FailOnAnyError ) {
                goto error_exit;
            } else {
                ARecTimeout = TRUE;
            }

        } else if ( dnsStatus == DNS_ERROR_RCODE_YXDOMAIN ) {
            //
            // the record we asked about in DnsUpdateTest is not there but it
            // can be dynamically registered.
            //
        } else if ( dnsStatus != ERROR_SUCCESS ) {
            //
            // bad juju but only fail to bring the name online if DNS is
            // required. If any one of the registrations is successful, then
            // we consider that goodness.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"Testing %1!ws! for dynamic updates failed over adapter "
                              L"'%3!ws!', status %2!u!.\n",
                              fqNameARec,
                              dnsStatus,
                              DomainMapList[ mapIndex ].ConnectoidName);

            LogDnsFailureToEventLog(ResourceKey,
                                    fqNameARec,
                                    AlternateComputerName,
                                    dnsStatus,
                                    DomainMapList[ mapIndex ].ConnectoidName);

            if ( FailOnAnyError ) {
                goto error_exit;
            } else {
                continue;
            }
        }

        //
        // allocate memory to hold an array of DNS list data for the A and PTR
        // records. Separate lists are maintained for the different record types.
        //
        if (listheadFreeEntries == 0) {

            dnsStatus = GrowBlock((PCHAR *)&dnsLists,
                                  listheadCount,
                                  sizeof( *dnsLists ),
                                  &listheadFreeEntries);

            if ( dnsStatus != ERROR_SUCCESS) {
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_ERROR,
                                  L"Unable to allocate memory (1).\n");
                goto error_exit;
            }
        }

        //
        // if the FQDN is already in use in another DNS record and the
        // connectoid names for the two FQDNs we're adding are the same, then
        // we have to add this new IP address entry to the existing DNS list.
        //
        for ( index = 0; index < listheadCount; ++index ) {
            if ( ClRtlStrICmp( dnsLists[index].A_RRSet.pFirstRR->pName,
                           fqNameARec
                         ) == 0 )
            {
#if DBG_DNSLIST
                {
                    WCHAR   buf[DNS_MAX_NAME_BUFFER_LENGTH + 50];

                    buf[ COUNT_OF( buf ) - 1 ] = UNICODE_NULL;
                    _snwprintf( buf, COUNT_OF( buf ) - 1,
                                L"DNS NAME MATCH w/ index %d: %ws\n",
                                index, fqNameARec );
                    OutputDebugStringW(buf);
                }
#endif
                //
                // FQDNs are equal; how about the connectoids?
                //
                if (ClRtlStrICmp(DomainMapList[ mapIndex ].ConnectoidName,
                             dnsLists[index].ConnectoidName )
                    ==
                    0 )
                {
                        break;
                }
            }
        }

#if DBG_DNSLIST
        {
            WCHAR   buf[DNS_MAX_NAME_BUFFER_LENGTH + 80];

            buf[ COUNT_OF( buf ) - 1 ] = UNICODE_NULL;
            _snwprintf(buf, COUNT_OF( buf ) - 1,
                       L"ADDING (%ws, %ws, %.32ws) to dnsList[%d], lhCount = %d, DomMapList index = %d\n",
                       fqNameARec,
                       DomainMapList[mapIndex].IpAddress,
                       DomainMapList[mapIndex].ConnectoidName,
                       index,
                       listheadCount,
                       mapIndex );
            OutputDebugStringW(buf);
        }
#endif

        if ( index == listheadCount ) {

            //
            // it's not, so init a new pair of listheads and adjust the
            // distinct listhead count
            //
            DNS_RRSET_INIT( dnsLists[ index ].A_RRSet );
            DNS_RRSET_INIT( dnsLists[ index ].PTR_RRSet );
            ++listheadCount;
            --listheadFreeEntries;
        }

        dnsLists[ index ].UpdateTestTimeout = ARecTimeout;

        if ( ClusWorkerCheckTerminate( Worker )) {
            dnsStatus = ERROR_OPERATION_ABORTED;
            goto error_exit;
        }

        //
        // build the PTR records. Per DNS dev, this should be considered a
        // warning instead of a failure. We note the failures and bring the
        // name online.
        //
        PTRName = BuildUnicodeReverseName( DomainMapList[ mapIndex ].IpAddress );
        if ( PTRName != NULL ) {

            PTRRecTimeout = FALSE;
            ptrRecStatus = DnsUpdateTest(NULL,
                                         PTRName,
                                         0,
                                         DomainMapList[ mapIndex ].DnsServerList);

#if DBG_DNSLIST
            {
                WCHAR buf[DNS_MAX_NAME_BUFFER_LENGTH + 64];
                struct in_addr addr;

                addr.s_addr = DomainMapList[ mapIndex ].DnsServerList->AddrArray[0];
                buf[ COUNT_OF( buf ) - 1 ] = UNICODE_NULL;
                _snwprintf(buf, COUNT_OF( buf ) - 1,
                           L"AddDnsNames UPDATETEST: %ws on %.32ws (%hs) returned %u\n",
                           PTRName,
                           DomainMapList[ mapIndex ].ConnectoidName,
                           inet_ntoa( addr ),
                           ptrRecStatus);
                OutputDebugStringW( buf );
            }
#endif

            if ( ptrRecStatus == DNS_ERROR_RCODE_NOT_IMPLEMENTED ) {
                //
                // zone does not accept dynamic updates.
                //
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_INFORMATION,
                                  L"The zone for %1!ws! does not accept dynamic DNS "
                                  L"registration updates over adapter '%2!ws!'.\n",
                                  PTRName,
                                  DomainMapList[ mapIndex ].ConnectoidName);

                LocalFree( PTRName );
                LocalFree( fqNamePTRRec );

                PTRName = NULL;
                fqNamePTRRec = NULL;

            } else if ( ptrRecStatus == DNS_ERROR_RCODE_REFUSED ) {
                //
                // secure zone and we don't have credentials to change the
                // name. fail the resource.
                //
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_WARNING,
                                  L"%1!ws! is a secure zone and has refused the registration of "
                                  L"%2!ws! over adapter '%3!ws!'.\n",
                                  DomainMapList[ mapIndex ].DomainName,
                                  PTRName,
                                  DomainMapList[ mapIndex ].ConnectoidName);

            } else if ( ptrRecStatus == ERROR_TIMEOUT ) {
                //
                // couldn't contact a server so we're not sure if it allows
                // updates or not. build the records anyway and we'll deal
                // with it during the query period
                //
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_WARNING,
                                  L"The server for %1!ws! could not be contacted over adapter '%2!ws!' "
                                  L"to determine whether it accepts DNS registration updates. "
                                  L"Retrying at a later time.\n",
                                  PTRName,
                                  DomainMapList[ mapIndex ].ConnectoidName);

                PTRRecTimeout = TRUE;
                ptrRecStatus = ERROR_SUCCESS;

            } else if ( ptrRecStatus == DNS_ERROR_RCODE_YXDOMAIN ) {
                //
                // the record we asked about in DnsUpdateTest is not there but
                // it can be dynamically registered.
                //
                ptrRecStatus = ERROR_SUCCESS;

            } else if ( ptrRecStatus != ERROR_SUCCESS ) {
                //
                // bad juju - log the error but don't fail the name since
                // these are just lowly PTR records.
                //
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_WARNING,
                                  L"Testing %1!ws! for dynamic updates over adapter '%3!ws!' "
                                  L"failed, status %2!u!.\n",
                                  PTRName,
                                  ptrRecStatus,
                                  DomainMapList[ mapIndex ].ConnectoidName);
            }

            if ( ptrRecStatus == ERROR_SUCCESS ) {
                //
                // build the PTR rec
                //
                PTRRecord = DnsRecordBuild_W(&dnsLists[ index ].PTR_RRSet,
                                             PTRName,
                                             DNS_TYPE_PTR,
                                             TRUE,
                                             0,
                                             1,
                                             &fqNamePTRRec);

                if (PTRRecord != NULL) {

                    //
                    // BUGBUG - DNS doesn't free the owner and data fields for
                    // us in DnsRecordListFree. Set these flags until we sort
                    // out what is happening
                    //
                    SET_FREE_OWNER( PTRRecord );
                    SET_FREE_DATA( PTRRecord );

                    //
                    // set the time to live so clients don't beat up the
                    // server
                    //
                    PTRRecord->dwTtl = 20 * 60;   // 20 minutes

                    //
                    // "consume" the pointers to name strings. If we got this
                    // far, then these pointers have been captured in the DNS
                    // record and will be freed when the record is freed by
                    // DnsRecordListFree.
                    //
                    PTRName = NULL;
                    fqNamePTRRec = NULL;
                }
                else {
                    (NetNameLogEvent)(ResourceHandle,
                                      LOG_WARNING,
                                      L"Error building PTR record for owner %1!ws!, addr %2!ws!, status %3!u!\n",
                                      fqNameARec,
                                      DomainMapList[ mapIndex ].IpAddress,
                                      ptrRecStatus = GetLastError());

                    LocalFree( PTRName );
                    LocalFree( fqNamePTRRec );

                    PTRName = NULL;
                    fqNamePTRRec = NULL;
                }

            } // if ptrRecStatus == ERROR_SUCCESS

        } // if PTRName != NULL
        else {
            ptrRecStatus = GetLastError();
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Error building PTR name for owner %1!ws!, addr %2!ws!, status %3!u!\n",
                              fqNameARec,
                              DomainMapList[ mapIndex ].IpAddress,
                              ptrRecStatus);

            LocalFree( fqNamePTRRec );
            fqNamePTRRec = NULL;
        }

        //
        // build the A rec
        //
        ARecord = DnsRecordBuild_W(&dnsLists[ index ].A_RRSet,
                                   fqNameARec,
                                   DNS_TYPE_A,
                                   TRUE,
                                   0,
                                   1,
                                   &DomainMapList[ mapIndex ].IpAddress);

        if ( ARecord == NULL ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Error building A rec for owner %1!ws!, addr %2!ws!, status %3!u!\n",
                              fqNameARec,
                              DomainMapList[ mapIndex ].IpAddress,
                              dnsStatus = GetLastError());

            goto error_exit;
        }

        //
        // set the time to live so clients don't beat up the server
        //
        ARecord->dwTtl = 20 * 60;   // 20 minutes

        //
        // BUGBUG - DNS doesn't free the owner and data fields for us in
        // DnsRecordListFree. Set these flags until we sort out what is
        // happening
        //

        SET_FREE_OWNER( ARecord );
        SET_FREE_DATA( ARecord );

        //
        // "consume" this pointer as well
        //
        fqNameARec = NULL;

        //
        // capture the DNS server list and connectoid name for this entry
        //
        dnsLists[ index ].DnsServerList = DomainMapList[ mapIndex ].DnsServerList;
        DomainMapList[ mapIndex ].DnsServerList = NULL;

        dnsLists[ index ].ConnectoidName = ResUtilDupString( DomainMapList[ mapIndex ].ConnectoidName );
        if ( dnsLists[ index ].ConnectoidName == NULL ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Unable to allocate memory .\n");
            goto error_exit;
        }
    } // end of for each entry in DomainMapCount

    //
    // update the DNS server with the records that were just created
    //
    *NumberOfRegisteredNames = 0;
    for( index = 0; index < listheadCount; ++index ) {

        if ( ClusWorkerCheckTerminate( Worker )) {
            dnsStatus = ERROR_OPERATION_ABORTED;
            goto error_exit;
        }

        //
        // if we made it this far, we know that the server is dynamic or we
        // timed out trying to figure that out. For the timeout case, we'll
        // assume that the servers are dynamic and let NetNameUpdateDnsServer
        // discover otherwise.
        //
        dnsLists[ index ].ForwardZoneIsDynamic = TRUE;
        dnsLists[ index ].ReverseZoneIsDynamic = TRUE;

        dnsStatus = RegisterDnsRecords(&dnsLists[ index ],
                                       AlternateComputerName,
                                       ResourceKey,
                                       ResourceHandle,
                                       TRUE,                    /* LogRegistration */
                                       NumberOfRegisteredNames);

        if ( dnsStatus != ERROR_SUCCESS && FailOnAnyError ) {
            goto error_exit;
        }
    }

    *NumberOfDnsLists = listheadCount;
    *DnsLists = dnsLists;

    return dnsStatus;

error_exit:

    if ( dnsLists != NULL ) {
        while ( listheadCount-- ) {
            DnsRecordListFree(
                dnsLists[listheadCount].PTR_RRSet.pFirstRR,
                DnsFreeRecordListDeep );

            DnsRecordListFree(
                dnsLists[listheadCount].A_RRSet.pFirstRR,
                DnsFreeRecordListDeep );

            if ( dnsLists[listheadCount].DnsServerList != NULL ) {
                LocalFree( dnsLists[listheadCount].DnsServerList );
            }

            if ( dnsLists[listheadCount].ConnectoidName != NULL ) {
                LocalFree( dnsLists[listheadCount].ConnectoidName );
            }
        }

        LocalFree( dnsLists );
    }

    if ( PTRName != NULL ) {
        LocalFree( PTRName );
    }

    if ( fqNamePTRRec != NULL ) {
        LocalFree( fqNamePTRRec );
    }

    if ( fqNameARec != NULL ) {
        LocalFree( fqNameARec );
    }

    *NumberOfDnsLists = 0;
    *NumberOfRegisteredNames = 0;
    *DnsLists = NULL;

    return dnsStatus;
} // AddDnsNames

VOID
LogDnsFailureToEventLog(
    IN  HKEY    ResourceKey,
    IN  LPWSTR  DnsName,
    IN  LPWSTR  ResourceName,
    IN  DWORD   Status,
    IN  LPWSTR  ConnectoidName
    )

/*++

Routine Description:

    Log dns name failures to the event log

Arguments:

    DnsName - FQ DNS name that failed to be registered

    ResourceName - associated resource

    Status - status returned by DNSAPI

Return Value:

    NONE

--*/

{
    LPWSTR  msgBuff;
    DWORD   msgBytes;

    msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                             FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             Status,
                             0,
                             (LPWSTR)&msgBuff,
                             0,
                             NULL);

    if ( msgBytes > 0 ) {
        ClusResLogSystemEventByKeyData3(ResourceKey,
                                        LOG_UNUSUAL,
                                        RES_NETNAME_DNS_REGISTRATION_MISSING,
                                        sizeof( Status ),
                                        &Status,
                                        DnsName,
                                        msgBuff,
                                        ConnectoidName);

        LocalFree( msgBuff );
    }

} // LogDnsFailureToEventLog

//
// Exported Routines
//

LPWSTR
BuildUnicodeReverseName(
    IN  LPWSTR  IpAddress
    )

/*++

Routine Description:

    Given an Ip address, build a reverse DNS name for publishing as
    a PTR record

Arguments:

    IpAddress - unicode version of dotted decimal IP address

Return Value:

    address of pointer to buffer with reverse name. Null if an error occured

--*/

{
    ULONG ipAddress;
    PCHAR ansiReverseName;
    PCHAR pAnsi;
    ULONG ansiNameLength;
    PWCHAR unicodeReverseName;
    PWCHAR pUni;

    CHAR ansiIpAddress[ 64 ];

    //
    // allocate enough space for both the ANSI and Unicode versions
    //
    ansiReverseName = LocalAlloc( LMEM_FIXED, DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH );
    if ( ansiReverseName == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    unicodeReverseName = LocalAlloc( LMEM_FIXED, DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH * sizeof(WCHAR));

    if ( unicodeReverseName == NULL ) {
        LocalFree( ansiReverseName );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    //
    // convert to ansi, have DNS create the name, and then convert back to
    // unicode
    //

    wcstombs( ansiIpAddress, IpAddress, sizeof( ansiIpAddress ));
    ipAddress = inet_addr( ansiIpAddress );

    DnsWriteReverseNameStringForIpAddress( ansiReverseName, ipAddress );

    //
    // convert to Unicode
    //
    ansiNameLength = strlen( ansiReverseName ) + 1;
    mbstowcs( unicodeReverseName, ansiReverseName, ansiNameLength );

    LocalFree( ansiReverseName );

    return unicodeReverseName;
} // BuildUnicodeReverseName

DWORD
RegisterDnsRecords(
    IN  PDNS_LISTS       DnsLists,
    IN  LPWSTR           NetworkName,
    IN  HKEY             ResourceKey,
    IN  RESOURCE_HANDLE  ResourceHandle,
    IN  BOOL             LogRegistration,
    OUT PULONG           NumberOfRegisteredNames
    )

/*++

Routine Description:

    Register the A and PTR records specified in DnsLists with the DNS server.

Arguments:

    DnsLists - pointer to the list of structs holding the record sets to
               be registered

    NetworkName - host name portion of name being registered 

    ResourceKey - used to log events to the event viewer

    ResourceHandle - used to log messages in the cluster log

    LogRegistration - TRUE if the successful registration should be logged to the cluster log

    NumberOfRegisteredNames - pointer that receives count of successful registrations

Return Value:

    None

--*/

{
    DNS_STATUS      ARecStatus;
    DNS_STATUS      PTRRecStatus;
    DNS_STATUS      dnsStatus;
    PDNS_RECORD     dnsRecord;
    PDNS_RECORD     nextDnsRecord;
    ULONG           registeredCount = 0;

    //
    // check the status of DnsUpdateTest on this name. If we've previously
    // timed out, then try again.
    //
    if ( DnsLists->UpdateTestTimeout ) {

        DnsLists->UpdateTestTimeout = FALSE;
        dnsStatus = DnsUpdateTest(NULL,
                                  DnsLists->A_RRSet.pFirstRR->pName,
                                  0,
                                  DnsLists->DnsServerList);

#if DBG_DNSLIST
        {
            WCHAR buf[DNS_MAX_NAME_BUFFER_LENGTH + 64];
            struct in_addr addr;

            addr.s_addr = DnsLists->DnsServerList->AddrArray[0];
            buf[ COUNT_OF( buf ) - 1 ] = UNICODE_NULL;
            _snwprintf(buf, COUNT_OF( buf ) - 1,
                       L"RegisterDnsRecords UPDATETEST: %ws on %.32ws (%hs) returned %u\n",
                       DnsLists->A_RRSet.pFirstRR->pName,
                       DnsLists->ConnectoidName,
                       inet_ntoa( addr ),
                       dnsStatus);
            OutputDebugStringW( buf );
        }
#endif

        if ( dnsStatus == DNS_ERROR_RCODE_NOT_IMPLEMENTED ) {
            //
            // zone does not accept dynamic updates. Invalidate this entry
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_INFORMATION,
                              L"%1!ws! does not accept dynamic DNS registration updates over "
                              L"adapter '%2!ws!'.\n",
                              DnsLists->A_RRSet.pFirstRR->pName,
                              DnsLists->ConnectoidName);

            DnsLists->ForwardZoneIsDynamic = FALSE;
            return dnsStatus;

        } else if ( dnsStatus == DNS_ERROR_RCODE_REFUSED ) {
            //
            // secure zone and we don't have credentials to change the
            // name. fail the resource.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"The registration of %1!ws! in a secure zone was refused "
                              L"because the record was already registered but owned by a "
                              L"different user.\n",
                              DnsLists->A_RRSet.pFirstRR->pName);

            if (!DnsLists->AErrorLogged ||
                dnsStatus != DnsLists->LastARecQueryStatus ) {

                LogDnsFailureToEventLog(ResourceKey,
                                        DnsLists->A_RRSet.pFirstRR->pName,
                                        NetworkName,
                                        dnsStatus,
                                        DnsLists->ConnectoidName);

                DnsLists->AErrorLogged = TRUE;
            }

            DnsLists->LastARecQueryStatus = dnsStatus;
            return dnsStatus;

        } else if ( dnsStatus == ERROR_TIMEOUT ) {

            //
            // couldn't contact a server so we're not sure if it allows
            // updates or not.
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"The server for %1!ws! could not be contacted over adapter "
                              L"'%2!ws!' to determine whether it accepts DNS registration "
                              L"updates. Retrying at a later time.\n",
                              DnsLists->A_RRSet.pFirstRR->pName,
                              DnsLists->ConnectoidName);

            if (!DnsLists->AErrorLogged ) {
                LogDnsFailureToEventLog(ResourceKey,
                                        DnsLists->A_RRSet.pFirstRR->pName,
                                        NetworkName,
                                        dnsStatus,
                                        DnsLists->ConnectoidName);

                DnsLists->AErrorLogged = TRUE;
            }

            DnsLists->UpdateTestTimeout = TRUE;
            return dnsStatus;

        } else if ( dnsStatus == DNS_ERROR_RCODE_YXDOMAIN ) {
            //
            // the record we asked about in DnsUpdateTest is not there but it
            // can be dynamically registered.
            //
        } else if ( dnsStatus != ERROR_SUCCESS ) {
            //
            // bad juju
            //
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"Testing %1!ws! for dynamic updates failed over adapter "
                              L"'%3!ws!', status %2!u!.\n",
                              DnsLists->A_RRSet.pFirstRR->pName,
                              dnsStatus,
                              DnsLists->ConnectoidName);

            if (!DnsLists->AErrorLogged ||
                dnsStatus != DnsLists->LastARecQueryStatus ) {

                LogDnsFailureToEventLog(ResourceKey,
                                        DnsLists->A_RRSet.pFirstRR->pName,
                                        NetworkName,
                                        dnsStatus,
                                        DnsLists->ConnectoidName);

                DnsLists->AErrorLogged = TRUE;
            }
            DnsLists->LastARecQueryStatus = dnsStatus;
            return dnsStatus;
        }

        //
        // since we previously timed out but (at this point) are going to
        // register the records, adjust the logging flag so we get this time
        // recorded.
        //
        LogRegistration = TRUE;

    } // end if the update test had previously timed out

#if DBG
    (NetNameLogEvent)(ResourceHandle,
                      LOG_INFORMATION,
                      L"Registering %1!ws! over '%2!ws!'\n",
                      DnsLists->A_RRSet.pFirstRR->pName,
                      DnsLists->ConnectoidName);
#endif

    //
    // register the A Recs
    //
    ARecStatus = DnsReplaceRecordSetW(DnsLists->A_RRSet.pFirstRR,
                                      DNS_UPDATE_SECURITY_USE_DEFAULT,
                                      NULL,
                                      DnsLists->DnsServerList,
                                      NULL);

    if ( ARecStatus == DNS_ERROR_RCODE_NO_ERROR ) {

        ++registeredCount;
        DnsLists->AErrorLogged = FALSE;

        if ( LogRegistration ) {
            dnsRecord = DnsLists->A_RRSet.pFirstRR;
            while ( dnsRecord != NULL ) {
                struct in_addr ipAddress;

                ipAddress.s_addr = dnsRecord->Data.A.IpAddress;
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_INFORMATION,
                                  L"Registered DNS name %1!ws! with IP Address %2!hs! "
                                  L"over adapter '%3!ws!'.\n",
                                  dnsRecord->pName,
                                  inet_ntoa( ipAddress ),
                                  DnsLists->ConnectoidName);

                dnsRecord = dnsRecord->pNext;
            }
        }
    } else {
        //
        // it failed. log an error to the cluster log and change the worker
        // thread polling period. If we haven't logged an event before or the
        // error is different from the previous error, log it in the event log
        //
        if ( ARecStatus == ERROR_TIMEOUT ) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"The DNS server couldn't be contacted to update the registration "
                              L"for %1!ws!. Retrying at a later time.\n",
                              DnsLists->A_RRSet.pFirstRR->pName);
        }
        else {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_ERROR,
                              L"Failed to register DNS A records for owner %1!ws! over "
                              L"adapter '%3!ws!', status %2!u!\n",
                              DnsLists->A_RRSet.pFirstRR->pName,
                              ARecStatus,
                              DnsLists->ConnectoidName);
        }

        NetNameWorkerCheckPeriod = NETNAME_WORKER_PROBLEM_CHECK_PERIOD;

        if (!DnsLists->AErrorLogged ||
            ARecStatus != DnsLists->LastARecQueryStatus ) {

            LogDnsFailureToEventLog(ResourceKey,
                                    DnsLists->A_RRSet.pFirstRR->pName,
                                    NetworkName,
                                    ARecStatus,
                                    DnsLists->ConnectoidName);

            DnsLists->AErrorLogged = TRUE;
        }
    }

    //
    // Record the status of the registration in the list for this
    // owner. NetnameLooksAlive will check this value to determine the health
    // of this set of registrations. Use interlocked to co-ordinate with
    // Is/LooksAlive.
    //
    InterlockedExchange( &DnsLists->LastARecQueryStatus, ARecStatus );

    //
    // don't bother with PTR recs if bad juju happened with the A recs. we'll
    // try to register them the next time the DNS check thread runs
    //
    if ( ARecStatus == DNS_ERROR_RCODE_NO_ERROR ) {

        //
        // dynamic DNS requires that the pName must be the same for a given
        // set of records in an RRSET. The pName for a set of PTR records will
        // always be different. Maintaining a huge pile of RRSets, one per PTR
        // record is ridiculous (or at least I thought so when I orginally
        // wrote this; in hind sight, this was a bad decision - charlwi).
        //
        // AddDnsNames linked all these recs together. Now we have to register
        // them one at time by remembering the link, breaking it, registering,
        // restoring the link and moving on to the next record.
        //
        // The ErrorLogged logic is broken since we don't keep the status for
        // each (separate) registration. It's an approximation at best.
        //
        // In addition, it is possible for the server to accept A records
        // dynamically but disallow PTR records hence the check to see if we
        // have records to register is up front.
        //
        // Finally, we use ModifyRecordsInSet instead of ReplaceRecordSet due
        // to the organization of the PTR RRSET. When two names map to the
        // same IP address, we have identical reverse addr strings in more
        // than one DNS_LIST entry. If ReplaceRecordSet were used instead, it
        // would delete all but one of the reverse address mappings. In hind
        // sight, each DNS_LIST entry should have hosted either an A or PTR
        // RRSet but not both.
        //

        dnsRecord = DnsLists->PTR_RRSet.pFirstRR;
        while ( dnsRecord != NULL ) {

            nextDnsRecord = dnsRecord->pNext;
            dnsRecord->pNext = NULL;

            PTRRecStatus = DnsModifyRecordsInSet_W(dnsRecord,
                                                   NULL,
                                                   DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                   NULL,
                                                   DnsLists->DnsServerList,
                                                   NULL);

            if ( PTRRecStatus == DNS_ERROR_RCODE_NO_ERROR ) {
                DnsLists->PTRErrorLogged = FALSE;

                if ( LogRegistration ) {
                    (NetNameLogEvent)(ResourceHandle,
                                      LOG_INFORMATION,
                                      L"Registered DNS PTR record %1!ws! for host %2!ws! "
                                      L"over adapter '%3!ws!'\n",
                                      dnsRecord->pName,
                                      DnsLists->A_RRSet.pFirstRR->pName,
                                      DnsLists->ConnectoidName);
                }
            } else {
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_WARNING,
                                  L"Failed to register DNS PTR record %1!ws! for host "
                                  L"%2!ws! over adapter '%4!ws!', status %3!u!\n",
                                  dnsRecord->pName,
                                  DnsLists->A_RRSet.pFirstRR->pName,
                                  PTRRecStatus,
                                  DnsLists->ConnectoidName);

                if (!DnsLists->PTRErrorLogged ||
                    PTRRecStatus != DnsLists->LastPTRRecQueryStatus )
                {
                    DnsLists->PTRErrorLogged = TRUE;
                }
            }

            InterlockedExchange(&DnsLists->LastPTRRecQueryStatus,
                                PTRRecStatus);

            dnsRecord->pNext = nextDnsRecord;
            dnsRecord = nextDnsRecord;
        }
    } // end if A rec registration was successful
    else {
        //
        // since we don't end up trying the PTR records because of the A rec
        // failure, we'll propagate the A rec error code in the PTR status.
        //
        InterlockedExchange(&DnsLists->LastPTRRecQueryStatus,
                            ARecStatus);
    }

    *NumberOfRegisteredNames = registeredCount;

    return ARecStatus;
} // RegisterDnsRecords

VOID
DeleteAlternateComputerName(
    IN LPWSTR           AlternateComputerName,
    IN LPWSTR           DomainName                  OPTIONAL,
    IN HANDLE *         NameHandleList,
    IN DWORD            NameHandleCount,
    IN RESOURCE_HANDLE  ResourceHandle
    )
{
    NET_API_STATUS  status;

    if ( NameHandleCount > 0 ) {
        status = DeleteServerName(ResourceHandle, AlternateComputerName);

        if (status != ERROR_SUCCESS) {
            (NetNameLogEvent)(ResourceHandle,
                              LOG_WARNING,
                              L"Failed to delete server name %1!ws!, status %2!u!.\n",
                              AlternateComputerName,
                              status);
        }

        //
        // now remove the creds associated with this name
        //
        if ( DomainName != NULL ) {
            status = NNCredentialOperation(ResourceHandle,
                                           AlternateComputerName,
                                           DomainName,
                                           NULL,
                                           NNRemoveCredential);

            if (status != ERROR_SUCCESS) {
                (NetNameLogEvent)(ResourceHandle,
                                  LOG_WARNING,
                                  L"Failed to remove credentials for %1!ws!, status %2!u!.\n",
                                  AlternateComputerName,
                                  status);
            }
        }                                   
    }

    while ( NameHandleCount-- ) {
        CloseHandle(NameHandleList[NameHandleCount]);
        NameHandleList[NameHandleCount] = NULL;

        (NetNameLogEvent)(ResourceHandle,
                          LOG_INFORMATION,
                          L"Deleted workstation name %1!ws! from transport %2!u!.\n",
                          AlternateComputerName,
                          NameHandleCount
                          );
    }

} // DeleteAlternateComputerName

DWORD
AddAlternateComputerName(
    IN     PCLUS_WORKER             Worker,
    IN     PNETNAME_RESOURCE        Resource,
    IN     LPWSTR *                 TransportList,
    IN     DWORD                    TransportCount,
    IN     PDOMAIN_ADDRESS_MAPPING  DomainMapList,
    IN     DWORD                    DomainMapCount
    )

/*++

Routine Description:

    Instantiate the cluster name on this node. This will create the <00> and
    <20> Netbios endpoints, register A and PTR records with DNS and create a
    backing computer object in the DS if appropriate.

Arguments:

    Worker - used to check if we should terminate early

    Resource - pointer to resource context data

    TransportList - list of Netbios transports on which to add the names

    TransportCount - count of transports in TransportList

    DomainMapList - list of name to IP address mappings for building DNS records

    DomainMapCount - count of entries in DomainMapList

Return Value:

    ERROR_SUCCESS if ok, otherwise Win32 error

--*/

{
    LPWSTR  alternateComputerName = Resource->Params.NetworkName;
    DWORD   status = ERROR_SUCCESS;
    DWORD   setValueStatus;
    DWORD   i;
    DWORD   handleCount = 0;
    LONG    numberOfDnsNamesRegistered = 0;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    //
    // clear all the status values so we don't show left over crud if we fail
    // early on.
    //
    setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                          PARAM_NAME__STATUS_NETBIOS,
                                          0,
                                          NULL);

    if ( setValueStatus != ERROR_SUCCESS ) {
        (NetNameLogEvent)(Resource->ResourceHandle,
                          LOG_ERROR,
                          L"Failed to clear StatusNetbios property - status %1!u!\n",
                          setValueStatus);
        return setValueStatus;
    }

    setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                          PARAM_NAME__STATUS_DNS,
                                          0,
                                          NULL);

    if ( setValueStatus != ERROR_SUCCESS ) {
        (NetNameLogEvent)(Resource->ResourceHandle,
                          LOG_ERROR,
                          L"Failed to clear StatusDNS property - status %1!u!\n",
                          setValueStatus);
        return setValueStatus;
    }

    setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                          PARAM_NAME__STATUS_KERBEROS,
                                          0,
                                          NULL);

    if ( setValueStatus != ERROR_SUCCESS ) {
        (NetNameLogEvent)(Resource->ResourceHandle,
                          LOG_ERROR,
                          L"Failed to clear StatusKerberos property - status %1!u!\n",
                          setValueStatus);
        return setValueStatus;
    }

    //
    // register DNS name(s) with server
    //
    status = AddDnsNames(Worker,
                         alternateComputerName,
                         Resource->ResKey,
                         resourceHandle,
                         DomainMapList,
                         DomainMapCount,
                         Resource->Params.RequireDNS,       // FailOnAnyError
                         &Resource->NumberOfDnsLists,
                         &Resource->DnsLists,
                         &numberOfDnsNamesRegistered);

    if ( status != ERROR_SUCCESS ) {
        setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                              PARAM_NAME__STATUS_DNS,
                                              status,
                                              NULL);

        if ( setValueStatus != ERROR_SUCCESS ) {
            (NetNameLogEvent)(Resource->ResourceHandle,
                              LOG_ERROR,
                              L"Failed to register DNS records and can't set StatusDNS property - "
                              L"DNS status: %1!u!, property status %2!u!\n",
                              status,
                              setValueStatus);
            return setValueStatus;
        }
    }

    if ( status == ERROR_OPERATION_ABORTED ) {
        return status;
    }

    if ( status != ERROR_SUCCESS && Resource->Params.RequireDNS ) {
        LPWSTR  msgBuff;
        DWORD   msgBytes;

        //
        // log a message if we weren't terminated and DNS registration failed
        // and was required
        //
        msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 status,
                                 0,
                                 (LPWSTR)&msgBuff,
                                 0,
                                 NULL);

        if ( msgBytes > 0 ) {
            ClusResLogSystemEventByKey1(Resource->ResKey,
                                        LOG_CRITICAL,
                                        RES_NETNAME_DNS_REGISTRATION_FAILED,
                                        msgBuff);

            LocalFree( msgBuff );
        } else {
            ClusResLogSystemEventByKeyData(Resource->ResKey,
                                           LOG_CRITICAL,
                                           RES_NETNAME_DNS_REGISTRATION_FAILED_STATUS,
                                           sizeof( status ),
                                           &status);
        }

        return status;
    }

    //
    // see if we need to fiddle with a computer object
    //
    Resource->DoKerberosCheck = FALSE;

    if ( Resource->Params.RequireKerberos ) {
        PWCHAR  machinePwd = NULL;
        PWCHAR  domainName;

        //
        // CreatingDC indicates whether we think we have a CO or not.
        //
        if ( Resource->Params.CreatingDC == NULL ) {
            status = AddComputerObject( Worker, Resource, &machinePwd );
        } else {
            status = UpdateComputerObject( Worker, Resource, &machinePwd );
        }

        Resource->KerberosStatus = status;

        if ( status == ERROR_SUCCESS ) {

            //
            // add the credentials to the LocalSystem and NetworkService
            // LUIDs. use the domain name that is part of CreatingDC.
            //
            // ISSUE: have to find out if this works for domains where domain
            // name is different from DNS name
            //
            domainName = wcschr( Resource->Params.CreatingDC, L'.' );
            if ( domainName ) {
                ++domainName;
            }

            status = NNCredentialOperation(Resource->ResourceHandle,
                                           alternateComputerName,
                                           domainName,
                                           machinePwd,
                                           NNAddCredential);

            if ( status == ERROR_SUCCESS ) {
                Resource->DoKerberosCheck = TRUE;
            } else {
                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_ERROR,
                                  L"Failed to add credentials to LSA for computer account "
                                  L"%1!ws! - status %2!u!\n",
                                  alternateComputerName,
                                  status);

                if ( status == ERROR_PRIVILEGE_NOT_HELD ) {
                    ClusResLogSystemEventByKey1(Resource->ResKey,
                                                LOG_CRITICAL,
                                                RES_NETNAME_TCB_NOT_HELD,
                                                Resource->Params.NetworkName);
                }
                else {
                    ClusResLogSystemEventByKeyData1(Resource->ResKey,
                                                    LOG_CRITICAL,
                                                    RES_NETNAME_LSA_ERROR,
                                                    sizeof( status ),
                                                    &status,
                                                    Resource->Params.NetworkName);
                }
            }
        } else {
            setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                                  PARAM_NAME__STATUS_KERBEROS,
                                                  status,
                                                  NULL);

            if ( setValueStatus != ERROR_SUCCESS ) {
                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_ERROR,
                                  L"Kerberos operation failed and unable to set StatusKerberos property. "
                                  L"Kerberos status: %1!u! - property status %2!u!\n",
                                  status,
                                  setValueStatus);
                status = setValueStatus;
            }
        }

        if ( machinePwd != NULL ) {
            volatile PWCHAR  p = machinePwd;

            while ( *p != UNICODE_NULL ) {
                *p++ = UNICODE_NULL;
            }

            LocalFree( machinePwd );
        }

        if ( status != ERROR_SUCCESS ) {
            return status;
        }
    } else {
        BOOL    objectFound = FALSE;
        HRESULT hr;
        LPWSTR  hostingDCName = NULL;

        //
        // see if a CO exists with this name. If it does, don't go online.
        //
        hr = IsComputerObjectInDS(Resource->ResourceHandle,
                                  Resource->NodeName,
                                  Resource->Params.NetworkName,
                                  NULL,
                                  &objectFound,
                                  NULL,
                                  &hostingDCName);

        if ( SUCCEEDED( hr ) && objectFound ) {
            (NetNameLogEvent)(Resource->ResourceHandle,
                              LOG_ERROR,
                              L"Kerberos authentication is disabled for this resource "
                              L"but a computer account named %1!ws! was found on %2!ws!. "
                              L"Authentication based on Kerberos to this network "
                              L"name will fail while this is the case. To bring "
                              L"the resource online, set the RequireKerberos property "
                              L"to one or delete the computer account from Active "
                              L"Directory.\n",
                              Resource->Params.NetworkName,
                              hostingDCName);

            ClusResLogSystemEventByKey1(Resource->ResKey,
                                        LOG_CRITICAL,
                                        RES_NETNAME_COMPOBJ_IN_DS,
                                        Resource->Params.NetworkName);

            //
            // ISSUE: depending on how 402981 is fixed, we might be able to
            // remove this restriction. ToddS might fix it such that kerb will
            // ignore disabled accounts and let the negotiate package fall
            // back to NTLM. If this is the case, then we can remove this as
            // long as the DCs are running Windows Server 2003. Hmm....
            //
            // When a CO exists, clients will get a ticket. If the name goes
            // online without a password, the server will fail to decrypt its
            // portion of the ticket. Since this is an authoritative failure,
            // negotitate won't fallback and retry with NTLM. This penalizes
            // explicit NTLM users but I'm guessing they are far outnumbered by
            // Kerb and Negotiate users.
            //
            status = E_ADS_OBJECT_EXISTS;

            setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                                  PARAM_NAME__STATUS_KERBEROS,
                                                  status,
                                                  NULL);

            if ( setValueStatus != ERROR_SUCCESS ) {
                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_ERROR,
                                  L"Unable to set StatusKerberos property. Kerberos status: "
                                  L"%1!u! - property status %2!u!\n",
                                  status,
                                  setValueStatus);
                status = setValueStatus;
            }

            LocalFree( hostingDCName );

            return status;
        }
    }

    //
    // bring NetBT names online
    //
    status = ERROR_SUCCESS;
    for (i=0; i<TransportCount; i++) {

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;
            goto cleanup;
        }

        status = AddServerName(resourceHandle,
                               alternateComputerName,
                               Resource->Params.NetworkRemap,
                               TransportList[i],
                               (BOOLEAN) ((i == 0) ? TRUE : FALSE));    // CheckNameFirst

        if ( status == NERR_ServerNotStarted ) {
            status = ERROR_SUCCESS;
        }

        if ( status != ERROR_SUCCESS ) {
            goto cleanup;
        }

        if ( ClusWorkerCheckTerminate( Worker )) {
            status = ERROR_OPERATION_ABORTED;
            goto cleanup;
        }

        status = AddWorkstationName(
                     alternateComputerName,
                     TransportList[i],
                     resourceHandle,
                     &(Resource->NameHandleList[i])
                     );

        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }

        handleCount++;
    }

    //
    // if didn't register any NetBt or DNS names, then fail the netname.
    //
    if ( TransportCount == 0 && numberOfDnsNamesRegistered == 0 ) {
        ClusResLogSystemEvent1(LOG_CRITICAL,
                               RES_NETNAME_NOT_REGISTERED,
                               alternateComputerName);

        status = ERROR_RESOURCE_FAILED;
    }

cleanup:
    if ( status != ERROR_SUCCESS ) {
        LPWSTR  msgBuff;
        DWORD   msgBytes;

        setValueStatus = ResUtilSetDwordValue(Resource->ParametersKey,
                                              PARAM_NAME__STATUS_NETBIOS,
                                              status,
                                              NULL);

        if ( setValueStatus != ERROR_SUCCESS ) {
            (NetNameLogEvent)(Resource->ResourceHandle,
                              LOG_ERROR,
                              L"Adding network name failed and unable to set "
                              L"StatusNetbios property. Netbios status: %1!u! - property "
                              L"status %2!u!\n",
                              status,
                              setValueStatus);

            status = setValueStatus;
        }

        //
        // lookup error message text
        //
        msgBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM,
                                 NULL,
                                 status,
                                 0,
                                 (LPWSTR)&msgBuff,
                                 0,
                                 NULL);

        if ( msgBytes > 0 ) {
            ClusResLogSystemEventByKey1(Resource->ResKey,
                                        LOG_CRITICAL,
                                        RES_NETNAME_CANT_ADD_NAME2,
                                        msgBuff);

            LocalFree( msgBuff );
        } else {
            ClusResLogSystemEventByKeyData(Resource->ResKey,
                                           LOG_CRITICAL,
                                           RES_NETNAME_CANT_ADD_NAME_STATUS,
                                           sizeof(status),
                                           &status);
        }
    }

    return status;

} // AddAlternateComputerName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\resutils\resprop.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    resprop.c

Abstract:

    Implements the management of properties.

Author:

    Rod Gamache (rodga) 19-Mar-1997

Revision History:

--*/

#pragma warning( push )
#pragma warning( disable : 4115 )       //  Clusrtl - struct def in parentheses
#pragma warning( disable : 4201 )       //  SDK - nameless struct/union

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "stdio.h"
#include "stdlib.h"

#pragma warning( pop )

//
// Cluster Registry API function pointers
//
CLUSTER_REG_APIS
ResUtilClusterRegApis = {
    (PFNCLRTLCREATEKEY) ClusterRegCreateKey,
    (PFNCLRTLOPENKEY) ClusterRegOpenKey,
    (PFNCLRTLCLOSEKEY) ClusterRegCloseKey,
    (PFNCLRTLSETVALUE) ClusterRegSetValue,
    (PFNCLRTLQUERYVALUE) ClusterRegQueryValue,
    (PFNCLRTLENUMVALUE) ClusterRegEnumValue,
    (PFNCLRTLDELETEVALUE) ClusterRegDeleteValue,
    NULL,
    NULL,
    NULL
};



DWORD
WINAPI
ResUtilEnumProperties(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Enumerates the properties for a given object.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pszOutProperties - Supplies the output buffer.

    cbOutPropertiesSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pszOutProperties.

    pcbRequired - The required number of bytes if pszOutProperties is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    A Win32 error code on failure.

--*/

{
    return( ClRtlEnumProperties( pPropertyTable,
                                 pszOutProperties,
                                 cbOutPropertiesSize,
                                 pcbBytesReturned,
                                 pcbRequired ) );


} // ResUtilEnumProperties



DWORD
WINAPI
ResUtilEnumPrivateProperties(
    IN HKEY hkeyClusterKey,
    OUT LPWSTR pszOutProperties,
    IN DWORD cbOutPropertiesSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Enumerates the properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pszOutProperties - Supplies the output buffer.

    cbOutPropertiesSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pszOutProperties.

    pcbRequired - The required number of bytes if pszOutProperties is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    A Win32 error code on failure.

--*/

{
    return( ClRtlEnumPrivateProperties( hkeyClusterKey,
                                        &ResUtilClusterRegApis,
                                        pszOutProperties,
                                        cbOutPropertiesSize,
                                        pcbBytesReturned,
                                        pcbRequired ) );


} // ResUtilEnumProperties



DWORD
WINAPI
ResUtilGetProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPWSTR pPropertyList,
    IN DWORD cbPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pPropertyTable - Pointer to the property table to process.

    pPropertyList - Supplies the output buffer.

    cbPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pPropertyList.

    pcbRequired - The required number of bytes if pPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    return( ClRtlGetProperties( hkeyClusterKey,
                                &ResUtilClusterRegApis,
                                pPropertyTable,
                                pPropertyList,
                                cbPropertyListSize,
                                pcbBytesReturned,
                                pcbRequired ) );

} // ResUtilGetProperties



DWORD
WINAPI
ResUtilGetAllProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the default and 'unknown' properties for a given object.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pPropertyTable - Pointer to the property table to process.

    pPropertyList - Supplies the output buffer.

    cbPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pPropertyList.

    pcbRequired - The required number of bytes if pPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    return( ClRtlGetAllProperties( hkeyClusterKey,
                                   &ResUtilClusterRegApis,
                                   pPropertyTable,
                                   pPropertyList,
                                   cbPropertyListSize,
                                   pcbBytesReturned,
                                   pcbRequired ) );

} // ResUtilGetAllProperties



DWORD
WINAPI
ResUtilGetPropertiesToParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    )

/*++

Routine Description:

    Gets the default and 'unknown' properties for a given object and stores
    them in a parameter block.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pPropertyTable - Pointer to the property table to process.

    pOutParams - Supplies the output parameter block.

    bCheckForRequiredProperties - Boolean value specifying whether missing
        required properties should cause an error.

    pszNameOfPropInError - String pointer in which to return the name of the
        property in error (optional).

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    status = ClRtlGetPropertiesToParameterBlock( hkeyClusterKey,
                                                 &ResUtilClusterRegApis,
                                                 pPropertyTable,
                                                 pOutParams,
                                                 bCheckForRequiredProperties,
                                                 pszNameOfPropInError );
    return(status);

} // ResUtilGetPropertiesToParameterBlock



DWORD
WINAPI
ResUtilPropertyListFromParameterBlock(
    IN const  PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID  pOutPropertyList,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN const LPBYTE pInParams,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Constructs a property list from a parameter block.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    pcbOutPropertyListSize - Supplies the size of the output buffer.

    pInParams - Supplies the input parameter block.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_BAD_ARGUMENTS - An argument passed to the function was bad.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    status = ClRtlPropertyListFromParameterBlock( pPropertyTable,
                                                  pOutPropertyList,
                                                  pcbOutPropertyListSize,
                                                  pInParams,
                                                  pcbBytesReturned,
                                                  pcbRequired );
    return(status);

} // ResUtilPropertyListFromParameterBlock



DWORD
WINAPI
ResUtilGetPrivateProperties(
    IN HKEY hkeyClusterKey,
    OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Gets the private properties for a given object.

    This routine assumes that it uses the Cluster Registry API's for
    access to registry info.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - The number of bytes returned in pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    return( ClRtlGetPrivateProperties( hkeyClusterKey,
                                       &ResUtilClusterRegApis,
                                       pOutPropertyList,
                                       cbOutPropertyListSize,
                                       pcbBytesReturned,
                                       pcbRequired ) );

} // ResUtilGetPrivateProperties



DWORD
WINAPI
ResUtilGetPropertySize(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    )

/*++

Routine Description:

    Get the total number of bytes required for this property.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

Return Value:

--*/

{
    return( ClRtlGetPropertySize( hkeyClusterKey,
                                  &ResUtilClusterRegApis,
                                  pPropertyTableItem,
                                  pcbOutPropertyListSize,
                                  pnPropertyCount ) );

} // ResUtilGetPropertySize



DWORD
WINAPI
ResUtilGetProperty(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    OUT PVOID * pOutPropertyItem,
    IN OUT LPDWORD pcbOutPropertyItemSize
    )

/*++

Routine Description:

Arguments:

Return Value:

Notes:

    The buffer size has already been determined to be large enough to hold
    the return data.

--*/

{
    return( ClRtlGetProperty( hkeyClusterKey,
                              &ResUtilClusterRegApis,
                              pPropertyTableItem,
                              pOutPropertyItem,
                              pcbOutPropertyItemSize ) );

} // ResUtilGetProperty



DWORD
WINAPI
ResUtilVerifyPropertyTable(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

    Validate a property list.

Arguments:

    pPropertyTable - Pointer to the property table to process.

    Reserved - Possible pointer to a future ReadOnly property table.

    bAllowUnknownProperties - TRUE if unknown properties should be accepted.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

    pOutParams - Parameters block in which to return the data.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlVerifyPropertyTable( pPropertyTable,
                                      Reserved,
                                      bAllowUnknownProperties,
                                      pInPropertyList,
                                      cbInPropertyListSize,
                                      pOutParams ) );

} // ResUtilVerifyPropertyTable



DWORD
WINAPI
ResUtilSetPropertyTable(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    Reserved - Possible pointer to a future ReadOnly property table.

    bAllowUnknownProperties - TRUE if unknown properties should be accepted.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

    pOutParams - Parameters block in which to return the data.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPropertyTable( NULL,
                                   hkeyClusterKey,
                                   &ResUtilClusterRegApis,
                                   pPropertyTable,
                                   Reserved,
                                   bAllowUnknownProperties,
                                   pInPropertyList,
                                   cbInPropertyListSize,
                                   FALSE, // bForceWrite
                                   pOutParams ) );

} // ResUtilSetPropertyTable



DWORD
WINAPI
ResUtilSetPropertyTableEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    Reserved - Possible pointer to a future ReadOnly property table.

    bAllowUnknownProperties - TRUE if unknown properties should be accepted.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameters block in which to return the data.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPropertyTable( NULL,
                                   hkeyClusterKey,
                                   &ResUtilClusterRegApis,
                                   pPropertyTable,
                                   Reserved,
                                   bAllowUnknownProperties,
                                   pInPropertyList,
                                   cbInPropertyListSize,
                                   bForceWrite,
                                   pOutParams ) );

} // ResUtilSetPropertyTableEx



DWORD
WINAPI
ResUtilSetPropertyParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    pInParams - Parameters block to set.

    pInPropertyList - Full Property list.

    cbInPropertyListSize - Size of the input full property list.

    pOutParams - Parameters block to copy pInParams to.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPropertyParameterBlock( NULL, // IN HANDLE hXsaction, 
                                            hkeyClusterKey,
                                            &ResUtilClusterRegApis,
                                            pPropertyTable,
                                            Reserved,
                                            pInParams,
                                            pInPropertyList,
                                            cbInPropertyListSize,
                                            FALSE, // bForceWrite
                                            pOutParams ) );

} // ResUtilSetPropertyParameterBlock



DWORD
WINAPI
ResUtilSetPropertyParameterBlockEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL PBYTE pOutParams
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    pInParams - Parameters block to set.

    pInPropertyList - Full Property list.

    cbInPropertyListSize - Size of the input full property list.

    bForceWrite - TRUE = always write the properties to the cluster database.
        FALSE = only write the properties if they changed.

    pOutParams - Parameters block to copy pInParams to.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPropertyParameterBlock( NULL, // IN HANDLE hXsaction, 
                                            hkeyClusterKey,
                                            &ResUtilClusterRegApis,
                                            pPropertyTable,
                                            Reserved,
                                            pInParams,
                                            pInPropertyList,
                                            cbInPropertyListSize,
                                            bForceWrite,
                                            pOutParams ) );

} // ResUtilSetPropertyParameterBlockEx



DWORD
WINAPI
ResUtilSetUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:

    Set items that are not in the property table list.

Arguments:

    hkeyClusterKey - The opened registry key for this object's parameters.
        If not specified, the property list will only be validated.

    pPropertyTable - Pointer to the property table to process.

    pInPropertyList - Full Property list.

    cbInPropertyListSize - Size of the input full property list.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlpSetNonPropertyTable( NULL, // IN HANDLE hXsaction
                                       hkeyClusterKey,
                                       &ResUtilClusterRegApis,
                                       pPropertyTable,
                                       NULL,
                                       pInPropertyList,
                                       cbInPropertyListSize ) );

} // ResUtilSetUnknownProperties



DWORD
WINAPI
ResUtilVerifyPrivatePropertyList(
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:

    Validate a private property list.

Arguments:

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlVerifyPrivatePropertyList( pInPropertyList, cbInPropertyListSize ) );

} // ResUtilVerifyPrivatePropertyList



DWORD
WINAPI
ResUtilSetPrivatePropertyList(
    IN HKEY hkeyClusterKey,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize
    )

/*++

Routine Description:

Arguments:

    hkeyClusterKey - The opened registry key for this resource's parameters.
        If not specified, the property list will only be validated.

    pInPropertyList - The input buffer.

    cbInPropertyListSize - The input buffer size.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 Error on failure.

--*/

{
    return( ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                         hkeyClusterKey,
                                         &ResUtilClusterRegApis,
                                         pInPropertyList,
                                         cbInPropertyListSize ) );

} // ResUtilSetPrivatePropertyList



DWORD
WINAPI
ResUtilAddUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD cbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    )

/*++

Routine Description:

    Adds the unknown properties for a given object to the end of a property
    list.

Arguments:

    hkeyClusterKey - Supplies the handle to the key in the cluster database
        to read from.

    pPropertyTable - Pointer to the property table to process.

    pOutPropertyList - Supplies the output buffer.

    cbOutPropertyListSize - Supplies the size of the output buffer.

    pcbBytesReturned - On input, contains the number of bytes in use in the
        output buffer.  On output, contains the total number of bytes in
        pOutPropertyList.

    pcbRequired - The required number of bytes if pOutPropertyList is too small.

Return Value:

    ERROR_SUCCESS - Operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;

    status = ClRtlAddUnknownProperties( hkeyClusterKey,
                                        &ResUtilClusterRegApis,
                                        pPropertyTable,
                                        pOutPropertyList,
                                        cbOutPropertyListSize,
                                        pcbBytesReturned,
                                        pcbRequired );

    return(status);

} // ResUtilAddUnknownProperties




//***************************************************************************
//
//   Utility routines to grovel though a Control Function item list buffer
//
//***************************************************************************



DWORD
WINAPI
ResUtilFindSzProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )

/*++

Routine Description:

    Finds the specified string property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching string value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindSzProperty( pPropertyList,
                                 cbPropertyListSize,
                                 pszPropertyName,
                                 pszPropertyValue ) );

} // ResUtilFindSzProperty



DWORD
WINAPI
ResUtilFindExpandSzProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )

/*++

Routine Description:

    Finds the specified EXPAND_SZ string property in the Property List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching string value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindExpandSzProperty(
                pPropertyList,
                cbPropertyListSize,
                pszPropertyName,
                pszPropertyValue ) );

} // ResUtilFindExpandSzProperty



DWORD
WINAPI
ResUtilFindExpandedSzProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue
    )

/*++

Routine Description:

    Finds the specified string property in the Property List buffer pointed at
    by pPropertyList and returns it's expanded value.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching string value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindExpandedSzProperty(
                pPropertyList,
                cbPropertyListSize,
                pszPropertyName,
                pszPropertyValue ) );

} // ResUtilFindExpandedSzProperty



DWORD
WINAPI
ResUtilFindDwordProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPDWORD pdwPropertyValue
    )

/*++

Routine Description:

    Finds the specified DWORD property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pdwPropertyValue - the matching DWORD value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindDwordProperty( pPropertyList,
                                    cbPropertyListSize,
                                    pszPropertyName,
                                    pdwPropertyValue ) );

} // ResUtilFindDwordProperty

DWORD
WINAPI
ResUtilFindLongProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPLONG plPropertyValue
    )

/*++

Routine Description:

    Finds the specified string in the Value List buffer pointed at by Buffer.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    plPropertyValue - the matching long value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindLongProperty( pPropertyList,
                                    cbPropertyListSize,
                                    pszPropertyName,
                                    plPropertyValue ) );
} // ResUtilFindLongProperty


DWORD
WINAPI
ResUtilFindBinaryProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPBYTE * pbPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    )

/*++

Routine Description:

    Finds the specified binary property in the Property List buffer pointed at
    by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pbPropertyValue - the matching binary value found.

    pcbPropertyValueSize - the length of the matching binary value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindBinaryProperty( pPropertyList,
                                     cbPropertyListSize,
                                     pszPropertyName,
                                     pbPropertyValue,
                                     pcbPropertyValueSize ) );

} // ResUtilFindBinaryProperty



DWORD
WINAPI
ResUtilFindMultiSzProperty(
    IN PVOID pPropertyList,
    IN DWORD cbPropertyListSize,
    IN LPCWSTR pszPropertyName,
    OUT LPWSTR * pszPropertyValue,
    OUT LPDWORD pcbPropertyValueSize
    )

/*++

Routine Description:

    Finds the specified multiple string property in the Proprety List buffer
    pointed at by pPropertyList.

Arguments:

    pPropertyList - a property list.

    cbPropertyListSize - the size in bytes of the data in pPropertyList.

    pszPropertyName - the property name to look for in the buffer.

    pszPropertyValue - the matching multiple string value found.

    pcbPropertyValueSize - the length of the matching multiple string value found.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    return( ClRtlFindMultiSzProperty( pPropertyList,
                                      cbPropertyListSize,
                                      pszPropertyName,
                                      pszPropertyValue,
                                      pcbPropertyValueSize ) );

} // ResUtilFindMultiSzProperty



DWORD
WINAPI
ResUtilDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    )

/*++

Routine Description:

    Deallocates any buffers allocated for a parameter block that are
    different than the buffers used for the input parameter block.

Arguments:

    pOutParams - Parameter block to return.

    pInParams - Reference parameter block.

    pPropertyTable - Pointer to the property table to process.

Return Value:

    ERROR_SUCCESS - Parameter block duplicated successfully.

--*/

{
    DWORD   status;

    status = ClRtlDupParameterBlock( pOutParams, pInParams, pPropertyTable );

    return(status);

} // ResUtilDupParameterBlock



void
WINAPI
ResUtilFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    )

/*++

Routine Description:

    Deallocates any buffers allocated for a parameter block that are
    different than the buffers used for the input parameter block.

Arguments:

    pOutParams - Parameter block to free.

    pInParams - Reference parameter block.

    pPropertyTable - Pointer to the property table to process.

Return Value:

    None.

--*/

{
    ClRtlFreeParameterBlock( pOutParams, pInParams, pPropertyTable );

} // ResUtilFreeParameterBlock


#define __INITIAL_NAME_LENGTH 256

BOOL
WINAPI
ResUtilResourceTypesEqual(
    IN LPCWSTR      lpszResourceTypeName,
    IN HRESOURCE    hResource
    )

/*++

Routine Description:
    Checks to see if the resource names type matches

Arguments:
    lpszResourceTypeName - The type of resource to check for

    hResource - A handle to the resource to check

Return Value:
    TRUE - the resource type matches
    FALSE - the resource types do not match

--*/
{
    BOOL    bIsEqual = FALSE;
    DWORD   dwError;
    WCHAR   szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR  pszName = szName;
    DWORD   cbNameBufSize = __INITIAL_NAME_LENGTH * sizeof( szName[ 0 ] );
    DWORD   cbRetSize;

    // Get the resource type name
    dwError = ClusterResourceControl(
                hResource,            //Handle to the resource
                NULL,                 //Don't care about node
                CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, //Get the type
                0,                    // &InBuffer
                0,                    // nInBufferSize,
                pszName,              // &OutBuffer
                cbNameBufSize,        // nOutBufferSize,
                &cbRetSize );         // returned size

    if ( dwError == ERROR_MORE_DATA ) 
    {
        //
        // Output name buffer is too small.  Allocate a new one.
        //
        cbNameBufSize = cbRetSize + sizeof( WCHAR );
        pszName = LocalAlloc( LMEM_FIXED, cbNameBufSize );
        if ( pszName == NULL ) 
        {
            goto Cleanup;
        } // if: error allocating buffer
        dwError = ClusterResourceControl(
                    hResource,            //Handle to the resource
                    NULL,                 //Don't care about node
                    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, //Get the type
                    0,                    // &InBuffer
                    0,                    // nInBufferSize,
                    pszName,              // &OutBuffer
                    cbNameBufSize,        // nOutBufferSize,
                    &cbRetSize );         // returned size
    } // if: name buffer too small
    if ( dwError != ERROR_SUCCESS ) 
    {
        goto Cleanup;
    }

    // See if it's like US
    if ( lstrcmpiW( lpszResourceTypeName, pszName ) == 0 ) 
    {
        bIsEqual = TRUE;
    }

Cleanup:

    if ( pszName != szName ) 
    {
        LocalFree( pszName );
    } // if: we allocated the output name buffer

    return bIsEqual;

} //*** ResUtilResourceTypesEqual()


BOOL
WINAPI
ResUtilResourcesEqual(
    IN HRESOURCE    hSelf,
    IN HRESOURCE    hResource
    )

/*++

Routine Description:
    Check to See if the resources are the same

Arguments:
    IN hSelf - a handle to the callee, or NULL to indicate not equal.

    IN hResource - a handle to the resource to compare

Return Value:

    TRUE - Resource are equal
    FALSE - otherwise

--*/
{
    BOOL    bIsEqual = FALSE;
    DWORD   sc;
    LPWSTR  pwszSelfName = NULL;
    DWORD   cbSelfName = 0; 
    LPWSTR  pwszResName = NULL;
    DWORD   cbResName = 0; 
    DWORD   cbRetSize = 0;

    if ( ( hSelf == NULL ) || ( hResource == NULL ) ) 
    {
        goto Cleanup;
    }

    // "Self" - Get the resource name
    sc = ClusterResourceControl(
                hSelf,                //Handle to the resource
                NULL,                 //Don't care about node
                CLUSCTL_RESOURCE_GET_NAME, //Get the name
                NULL,                 // &InBuffer
                0,                    // nInBufferSize,
                NULL,                 // &OutBuffer
                0,                    // OutBufferSize,
                &cbRetSize            // returned size
                );
    if ( sc != ERROR_SUCCESS ) 
    {
        goto Cleanup;
    }

    //
    // Allocate the necessary buffer.
    //
    cbSelfName = cbRetSize + sizeof( WCHAR );   // Add one for NULL.
    pwszSelfName = LocalAlloc( LMEM_FIXED, cbSelfName );
    if ( pwszSelfName == NULL ) 
    {
        goto Cleanup;
    } // if: error allocating buffer

    sc = ClusterResourceControl(
                hSelf,                      // Handle to the resource
                NULL,                       // Don't care about node
                CLUSCTL_RESOURCE_GET_NAME,  // Get the name
                0,                          // &InBuffer
                0,                          // nInBufferSize,
                pwszSelfName,               // &OutBuffer
                cbSelfName,                 // OutBufferSize,
                &cbRetSize                  // returned size
                );
    if ( sc != ERROR_SUCCESS ) 
    {
        goto Cleanup;
    }

    // "Res" - Get the resource type name
    sc = ClusterResourceControl(
                hResource,            //Handle to the resource
                NULL,                 //Don't care about node
                CLUSCTL_RESOURCE_GET_NAME, //Get the name
                NULL,                 // &InBuffer
                0,                    // nInBufferSize,
                NULL,                 // &OutBuffer
                0,                    // OutBufferSize,
                &cbRetSize            // returned size
                );
    if ( sc != ERROR_SUCCESS ) 
    {
        goto Cleanup;
    }

    //
    // Output name buffer is too small.  Allocate a new one.
    //
    cbResName = cbRetSize + sizeof( WCHAR );    // Add one for NULL.
    pwszResName = LocalAlloc( LMEM_FIXED, cbResName );
    if ( pwszResName == NULL ) 
    {
        goto Cleanup;
    } // if: error allocating buffer

    sc = ClusterResourceControl(
                hResource,                  // Handle to the resource
                NULL,                       // Don't care about node
                CLUSCTL_RESOURCE_GET_NAME,  // Get the name
                NULL,                       // &InBuffer
                0,                          // nInBufferSize,
                pwszResName,                // &OutBuffer
                cbResName   ,               // OutBufferSize,
                &cbRetSize                  // returned size
                );
    if ( sc != ERROR_SUCCESS ) 
    {
        goto Cleanup;
    }

    // See if were looking in a mirror
    if ( ClRtlStrNICmp( pwszResName, pwszSelfName, cbResName ) == 0 ) 
    {
        bIsEqual = TRUE;
    }

Cleanup:

    LocalFree( pwszSelfName );
    LocalFree( pwszResName );

    return bIsEqual;

} //*** ResUtilResourcesEqual()


BOOL
WINAPI
ResUtilIsResourceClassEqual(
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN HRESOURCE                    hResource
    )

/*++

Routine Description:
    Checks to see if the resource names type matches

Arguments:
    prci - The resource class info to check for.

    hResource - A handle to the resource to check.

Return Value:
    TRUE - the resource type matches
    FALSE - the resource types do not match

--*/
{
    BOOL                        bIsEqual = FALSE;
    DWORD                       sc;
    DWORD                       cbRetSize;
    CLUS_RESOURCE_CLASS_INFO    rci;

    // Get the resource class info
    sc = ClusterResourceControl(
                hResource,            // Handle to the resource
                NULL,                 // Don't care about node
                CLUSCTL_RESOURCE_GET_CLASS_INFO, // Get the class info
                0,                    // &InBuffer
                0,                    // nInBufferSize,
                &rci,                 // &OutBuffer
                sizeof( rci ),        // nOutBufferSize,
                &cbRetSize );         // returned size

    if ( sc != ERROR_SUCCESS ) 
    {
        goto Cleanup;
    }

    // See if it's like US
    if ( rci.rc == prci->rc ) 
    {
        bIsEqual = TRUE;
    }

Cleanup:

    return bIsEqual;

} //*** ResUtilIsResourceClassEqual()


DWORD
WINAPI
ResUtilEnumResources(
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    )
/*++

Routine Description:
    This is a generic resource walking routine. It enumerates all resources in
    the cluster and invokes the callback function for each resource.


Arguments:

    IN [OPTIONAL] hSelf
                    - A handle to the resource. When enumerating resources do
                      not invoke the callback when the enumerated resource is
                      hSelf.
                      IF NULL then invoke the callback for all resources

    IN [OPTIONAL] lpszResTypeName
                    - This is an optional resource type name. If specified the
                      callback function will only be invoked for resources of
                      this type.

    IN pResCallBack - Pointer to function that gets called for each enumerated
                      resource in the cluster

    IN pParameter   - An Opaque callback parameter

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           dwStatus    = ERROR_SUCCESS;
    HCLUSTER        hCluster    = NULL;
    HCLUSENUM       hClusEnum   = NULL;
    HRESOURCE       hResource   = NULL;
    BOOL            fExecuteCallBack;
    WCHAR           szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR          lpszName = szName;
    DWORD           cchSize = __INITIAL_NAME_LENGTH;
    DWORD           cchRetSize;
    DWORD           dwIndex;
    DWORD           dwType;

    //
    // Open the cluster
    //
    hCluster = OpenCluster( NULL );
    if( hCluster == NULL )
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Get a resource enumeration handle
    //
    hClusEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );
    if ( hClusEnum == NULL )
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Enumerate each resource in the cluster
    //
    dwIndex = 0;

    do
    {
        cchRetSize  = cchSize;
        dwStatus = ClusterEnum(
                        hClusEnum,  //handle to enum
                        dwIndex,    //Index
                        &dwType,    //Type
                        lpszName,   //Name
                        &cchRetSize  //Size of name (in characters)
                        );

        if ( dwStatus == ERROR_MORE_DATA )
        {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating NULL
            if ( lpszName != szName )
            {
                LocalFree( lpszName );
            }
            lpszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( lpszName == NULL )
            {
                dwStatus = GetLastError();
                break;
            }
            cchRetSize = cchSize;
            dwStatus = ClusterEnum(
                            hClusEnum,  //handle to enum
                            dwIndex,    //Index
                            &dwType,    //Type
                            lpszName,   //Name
                            &cchRetSize  //Size of name
                            );
        }
        if ( dwStatus == ERROR_SUCCESS )
        {
            //
            // Try to open this resource
            //
            hResource = OpenClusterResource( hCluster, lpszName );

            if ( hResource == NULL )
            {
                dwStatus = GetLastError();
                if ( dwStatus == ERROR_RESOURCE_NOT_FOUND )
                {
                    //
                    //  If the resource cannot be found, assume it got deleted after
                    //  you opened the enumeration. So, skip the resource and proceed.
                    //
                    dwIndex ++;
                    dwStatus = ERROR_SUCCESS;
                    continue;
                }
                break;
            }

            //
            // Indicate that will invoke the callback
            //
            fExecuteCallBack = TRUE;

            // Determine if we need to check the type
            //
            if ( lpszResTypeName != NULL )
            {
                fExecuteCallBack = ResUtilResourceTypesEqual( lpszResTypeName, hResource );

            } //if lpszResTypeName


            if ( fExecuteCallBack && ( hSelf != NULL ) )
            {
                // Don't execute callback if hResource is callee (i.e., hSelf)
                fExecuteCallBack = !(ResUtilResourcesEqual( hSelf, hResource ));

            } //if fExecuteCallBack && hSelf

            if ( fExecuteCallBack )
            {
                dwStatus = pResCallBack( hSelf, hResource, pParameter );

                if ( dwStatus != ERROR_SUCCESS )
                {
                    break;
                }

            } //if fExecuteCallBack

            CloseClusterResource( hResource );
            hResource = NULL;

        } // If ERROR_SUCCESS

        dwIndex++;
    } while ( dwStatus == ERROR_SUCCESS );

Cleanup:

    if ( hClusEnum != NULL )
    {
        ClusterCloseEnum( hClusEnum );
    }

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    }

    if ( hResource != NULL )
    {
        CloseClusterResource( hResource );
    }

    if ( lpszName != szName )
    {
        LocalFree( lpszName );
    }

    if ( dwStatus == ERROR_NO_MORE_ITEMS )
    {
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;

} //*** ResUtilEnumResources()


DWORD
WINAPI
ResUtilEnumResourcesEx(
    IN HCLUSTER                 hCluster,
    IN HRESOURCE                hSelf,
    IN LPCWSTR                  lpszResTypeName,
    IN LPRESOURCE_CALLBACK_EX   pResCallBack,
    IN PVOID                    pParameter
    )
/*++

Routine Description:
    This is a generic resource walking routine. It enumerates all resources in
    the cluster and invokes the callback function for each resource.


Arguments:

    IN hCluster     - A handle to the cluster to enumerate resources on.

    IN [OPTIONAL] hSelf
                    - A handle to the resource. When enumerating resources do
                      not invoke the callback when the enumerated resource is
                      hSelf.
                      IF NULL then invoke the callback for all resources

    IN [OPTIONAL] lpszResTypeName
                    - This is an optional resource type name. If specified the
                      callback function will only be invoked for resources of
                      this type.

    IN pResCallBack - Pointer to function that gets called for each enumerated
                      resource in the cluster

    IN pParameter   - An Opaque callback parameter

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD           dwStatus    = ERROR_SUCCESS;
    HCLUSENUM       hClusEnum   = NULL;
    HRESOURCE       hResource   = NULL;
    BOOL            fExecuteCallBack;
    WCHAR           szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR          lpszName = szName;
    DWORD           cchSize = __INITIAL_NAME_LENGTH;
    DWORD           cchRetSize;
    DWORD           dwIndex;
    DWORD           dwType;

    //
    // Get a resource enumeration handle
    //
    hClusEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );
    if ( hClusEnum == NULL )
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Enumerate each resource in the cluster
    //
    dwIndex = 0;

    do
    {
        cchRetSize  = cchSize;
        dwStatus = ClusterEnum(
                        hClusEnum,  //handle to enum
                        dwIndex,    //Index
                        &dwType,    //Type
                        lpszName,   //Name
                        &cchRetSize  //Size of name
                        );

        if ( dwStatus == ERROR_MORE_DATA )
        {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating null
            if ( lpszName != szName )
            {
                LocalFree( lpszName );
            }
            lpszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( lpszName == NULL )
            {
                dwStatus = GetLastError();
                break;
            }
            cchRetSize = cchSize;
            dwStatus = ClusterEnum(
                            hClusEnum,  //handle to enum
                            dwIndex,    //Index
                            &dwType,    //Type
                            lpszName,   //Name
                            &cchRetSize  //Size of name
                            );
        }
        if ( dwStatus == ERROR_SUCCESS )
        {
            //
            // Try to open this resource
            //
            hResource = OpenClusterResource( hCluster, lpszName );

            if ( hResource == NULL )
            {
                dwStatus = GetLastError();
                if ( dwStatus == ERROR_RESOURCE_NOT_FOUND )
                {
                    //
                    //  If the resource cannot be found, assume it got deleted after
                    //  you opened the enumeration. So, skip the resource and proceed.
                    //
                    dwIndex ++;
                    dwStatus = ERROR_SUCCESS;
                    continue;
                }
                break;
            }

            //
            // Indicate that will invoke the callback
            //
            fExecuteCallBack = TRUE;

            // Determine if we need to check the type
            //
            if ( lpszResTypeName != NULL )
            {
                fExecuteCallBack = ResUtilResourceTypesEqual( lpszResTypeName, hResource );

            } //if lpszResTypeName


            if ( fExecuteCallBack && ( hSelf != NULL ) )
            {
                // Don't execute callback if hResource is callee (i.e., hSelf)
                fExecuteCallBack = !(ResUtilResourcesEqual( hSelf, hResource ));

            } //if fExecuteCallBack && hSelf

            if ( fExecuteCallBack )
            {
                dwStatus = pResCallBack( hCluster, hSelf, hResource, pParameter );

                if ( dwStatus != ERROR_SUCCESS )
                {
                    break;
                }

            } //if fExecuteCallBack

            CloseClusterResource( hResource );
            hResource = NULL;

        } // If ERROR_SUCCESS

        dwIndex++;
    } while ( dwStatus == ERROR_SUCCESS );

Cleanup:

    if ( hClusEnum != NULL )
    {
        ClusterCloseEnum( hClusEnum );
    }

    if ( hResource != NULL )
    {
        CloseClusterResource( hResource );
    }

    if ( lpszName != szName )
    {
        LocalFree( lpszName );
    }

    if ( dwStatus == ERROR_NO_MORE_ITEMS )
    {
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;

} //*** ResUtilEnumResourcesEx()



HRESOURCE
WINAPI
ResUtilGetResourceDependency(
    IN HANDLE       hSelf,
    IN LPCWSTR      lpszResourceType
    )

/*++

Routine Description:

    Returns a dependent resource for the local cluster.

Arguments:

    hSelf    - A handle to the original resource.

    lpszResourceType - the type of resource that it depends on


Return Value:

    NULL - error (use GetLastError() to get further info)

    NON-NULL - Handle to a resource of type ResourceType

--*/
{
    HRESOURCE   hResDepends = NULL;
    HCLUSTER    hCluster    = NULL;
    HRESENUM    hResEnum    = NULL;
    WCHAR       szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR      pszName     = szName;
    DWORD       cchSize      = __INITIAL_NAME_LENGTH;
    DWORD       cchRetSize;
    DWORD       dwType      = 0;
    DWORD       dwIndex     = 0;
    DWORD       status      = ERROR_SUCCESS;


    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL ) {
        return( NULL );
    }

    //
    // Open the depends on enum (get resource dependencies)
    //
    hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

    if ( hResEnum == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Enumerate all the depends on keys
    //
    do {
        cchRetSize = cchSize;
        status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        if ( status == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating null
            if ( pszName != szName ) {
                LocalFree( pszName );
            }
            pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( pszName == NULL ) {
                status = GetLastError();
                break;
            } // if:  error allocating memory
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Determine the type of resource found
        //
        hResDepends = OpenClusterResource( hCluster, pszName );
        if ( hResDepends == NULL ) {
            status = GetLastError();
            break;
        }

        if ( hResDepends != NULL ) {
            //
            // Valid resource now open the reg and get it's type
            //
            if ( ResUtilResourceTypesEqual( lpszResourceType, hResDepends ) ) {
                break;
            }

        } //if !hResDepends

        //
        // Close all handles, key's
        //
        if ( hResDepends != NULL ) {
            CloseClusterResource( hResDepends );
            hResDepends = NULL;
        }

        dwIndex++;
    } while ( status == ERROR_SUCCESS );

error_exit:
//
// At this point hResDepends is NULL if no match or non-null (success)
//
    if ( hCluster != NULL ) {
        CloseCluster( hCluster );
    }

    if ( hResEnum != NULL ) {
        ClusterResourceCloseEnum( hResEnum );
    }

    if ( pszName != szName ) {
        LocalFree( pszName );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }
    return(hResDepends);

} //*** ResUtilGetResourceDependency()


HRESOURCE
WINAPI
ResUtilGetResourceDependencyByName(
    IN HCLUSTER hCluster,
    IN HANDLE   hSelf,
    IN LPCWSTR  lpszResourceType,
    IN BOOL     bRecurse
    )

/*++

Routine Description:

    Returns a dependent resource for a specified cluster based on the resource
    type name.

Arguments:

    hCluster - Cluster to query.

    hSelf    - A handle to the original resource.

    lpszResourceType - The name of the resource type of the resource that the
        specified resource depends on.

    bRecurse - TRUE = check dependents of dependents.  An immediate dependency
        will be returned if there is one.

Return Value:

    NULL - error (use GetLastError() to get further info)

    NON-NULL - Handle to a resource of type lpszResourceType

--*/
{
    HRESOURCE   hResDepends = NULL;
    HRESOURCE   hResDepends2 = NULL;
    HRESENUM    hResEnum    = NULL;
    WCHAR       szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR      pszName     = szName;
    DWORD       cchSize      = __INITIAL_NAME_LENGTH;
    DWORD       cchRetSize;
    DWORD       dwType      = 0;
    DWORD       dwIndex     = 0;
    DWORD       status      = ERROR_SUCCESS;

    if ( ( hCluster == NULL ) || ( lpszResourceType == NULL ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    } // if: no cluster handle or resource type name specified

    //
    // Open the depends on enum (get resource dependencies)
    //
    hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

    if ( hResEnum == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Enumerate all the depends on keys
    //
    do {
        //
        // Get the next dependent resource.
        //
        cchRetSize = cchSize;
        status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        if ( status == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating null
            if ( pszName != szName ) {
                LocalFree( pszName );
            }
            pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( pszName == NULL ) {
                status = GetLastError();
                break;
            } // if:  error allocating memory
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Open the resource.
        //
        hResDepends = OpenClusterResource( hCluster, pszName );
        if ( hResDepends == NULL ) {
            status = GetLastError();
            break;
        }

        //
        // Resource is valid.  Now see if it is the right type.
        //
        if ( ResUtilResourceTypesEqual( lpszResourceType, hResDepends ) ) {
            break;
        }

        //
        // Close all handles, key's
        //
        if ( hResDepends != NULL ) {
            CloseClusterResource( hResDepends );
            hResDepends = NULL;
        }

        dwIndex++;
    } while ( status == ERROR_SUCCESS );

    //
    // If a match was not found, recurse the dependencies again looking for a
    // dependency of the dependencies if the bDeep argument was specified.
    //
    if ( ( status == ERROR_SUCCESS ) && ( hResDepends == NULL ) && bRecurse ) {

        //
        // Open the depends on enum (get resource dependencies)
        //
        ClusterResourceCloseEnum( hResEnum );
        hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

        if ( hResEnum == NULL ) {
            status = GetLastError();
            goto error_exit;
        }

        //
        // Enumerate all the depends on keys
        //
        dwIndex = 0;
        do {
            //
            // Get the next dependent resource.
            //
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
            if ( status == ERROR_MORE_DATA ) {
                //
                // Output name buffer is too small.  Allocate a new one.
                //
                cchSize = cchRetSize + 1; // Add room for terminating null
                if ( pszName != szName ) {
                    LocalFree( pszName );
                }
                pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
                if ( pszName == NULL ) {
                    status = GetLastError();
                    break;
                } // if:  error allocating memory
                cchRetSize = cchSize;
                status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
            }
            if ( status != ERROR_SUCCESS ) {
                break;
            }

            //
            // Open the resource.
            //
            hResDepends2 = OpenClusterResource( hCluster, pszName );
            if ( hResDepends2 == NULL ) {
                status = GetLastError();
                break;
            }

            //
            // Recursively call ourselves with this resource.
            //
            hResDepends = ResUtilGetResourceDependencyByName(
                                hCluster,
                                hResDepends2,
                                lpszResourceType,
                                bRecurse
                                );
            if ( hResDepends != NULL ) {
                break;
            }
            status = GetLastError();
            if ( status != ERROR_RESOURCE_NOT_FOUND ) {
                break;
            }
            status = ERROR_SUCCESS;

            //
            // Close all handles, key's
            //
            if ( hResDepends2 != NULL ) {
                CloseClusterResource( hResDepends2 );
                hResDepends2 = NULL;
            }

            dwIndex++;
        } while ( status == ERROR_SUCCESS );
    }

error_exit:
    if ( hResEnum != NULL ) {
        ClusterResourceCloseEnum( hResEnum );
    }

    if ( hResDepends2 != NULL ) {
        CloseClusterResource( hResDepends2 );
    }

    if ( pszName != szName ) {
        LocalFree( pszName );
    }

    if ( ( status == ERROR_SUCCESS ) && ( hResDepends == NULL ) ) {
        status = ERROR_RESOURCE_NOT_FOUND;
    }
    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return hResDepends;

} //*** ResUtilGetResourceDependencyByName()


HRESOURCE
WINAPI
ResUtilGetResourceDependencyByClass(
    IN HCLUSTER                     hCluster,
    IN HANDLE                       hSelf,
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN BOOL                         bRecurse
    )

/*++

Routine Description:

    Returns a dependent resource for a specified cluster based on the resource
    type class information.

Arguments:

    hCluster - Cluster to query.

    hSelf    - A handle to the original resource.

    prci - The resource class info of the resource type of the resource that
        the specified resource depends on.

    bRecurse - TRUE = check dependents of dependents.  An immediate dependency
        will be returned if there is one.

Return Value:

    NULL - error (use GetLastError() to get further info)

    NON-NULL - Handle to a resource whose class is specified by prci.

--*/
{
    HRESOURCE   hResDepends = NULL;
    HRESOURCE   hResDepends2 = NULL;
    HRESENUM    hResEnum    = NULL;
    WCHAR       szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR      pszName     = szName;
    DWORD       cchSize     = __INITIAL_NAME_LENGTH;
    DWORD       cchRetSize;
    DWORD       dwType      = 0;
    DWORD       dwIndex     = 0;
    DWORD       status      = ERROR_SUCCESS;

    if ( ( hCluster == NULL ) || ( prci == NULL ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    } // if: no cluster handle or class info specified

    //
    // Open the depends on enum (get resource dependencies)
    //
    hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

    if ( hResEnum == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Enumerate all the depends on keys
    //
    do {
        //
        // Get the next dependent resource.
        //
        cchRetSize = cchSize;
        status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        if ( status == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1; // Add room for terminating null
            if ( pszName != szName ) {
                LocalFree( pszName );
            }
            pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( pszName == NULL ) {
                status = GetLastError();
                break;
            } // if:  error allocating memory
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Determine the type of resource found
        //
        hResDepends = OpenClusterResource( hCluster, pszName );
        if ( hResDepends == NULL ) {
            status = GetLastError();
            break;
        }

        //
        // Resource is valid.  Now see if it is the right class.
        //
        if ( ResUtilIsResourceClassEqual( prci, hResDepends ) ) {
            break;
        }

        //
        // Close all handles, key's
        //
        if ( hResDepends != NULL ) {
            CloseClusterResource( hResDepends );
            hResDepends = NULL;
        }

        dwIndex++;
    } while ( status == ERROR_SUCCESS );

    //
    // If a match was not found, recurse the dependencies again looking for a
    // dependency of the dependencies if the bDeep argument was specified.
    //
    if ( ( status == ERROR_SUCCESS ) && ( hResDepends == NULL ) && bRecurse ) {

        //
        // Open the depends on enum (get resource dependencies)
        //
        ClusterResourceCloseEnum( hResEnum );
        hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );

        if ( hResEnum == NULL ) {
            status = GetLastError();
            goto error_exit;
        }

        //
        // Enumerate all the depends on keys
        //
        dwIndex = 0;
        do {
            //
            // Get the next dependent resource.
            //
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
            if ( status == ERROR_MORE_DATA ) {
                //
                // Output name buffer is too small.  Allocate a new one.
                //
                cchSize = cchRetSize + 1; // Add room for terminating null
                if ( pszName != szName ) {
                    LocalFree( pszName );
                }
                pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
                if ( pszName == NULL ) {
                    status = GetLastError();
                    break;
                } // if:  error allocating memory
                cchRetSize = cchSize;
                status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
            }
            if ( status != ERROR_SUCCESS ) {
                break;
            }

            //
            // Open the resource.
            //
            hResDepends2 = OpenClusterResource( hCluster, pszName );
            if ( hResDepends2 == NULL ) {
                status = GetLastError();
                break;
            }

            //
            // Recursively call ourselves with this resource.
            //
            hResDepends = ResUtilGetResourceDependencyByClass(
                                hCluster,
                                hResDepends2,
                                prci,
                                bRecurse
                                );
            if ( hResDepends != NULL ) {
                break;
            }
            status = GetLastError();
            if ( status != ERROR_RESOURCE_NOT_FOUND ) {
                break;
            }
            status = ERROR_SUCCESS;

            //
            // Close all handles, key's
            //
            if ( hResDepends2 != NULL ) {
                CloseClusterResource( hResDepends2 );
                hResDepends2 = NULL;
            }

            dwIndex++;
        } while ( status == ERROR_SUCCESS );
    }

error_exit:
    if ( hResEnum != NULL ) {
        ClusterResourceCloseEnum( hResEnum );
    }

    if ( hResDepends2 != NULL ) {
        CloseClusterResource( hResDepends2 );
    }

    if ( pszName != szName ) {
        LocalFree( pszName );
    }

    if ( ( status == ERROR_SUCCESS ) && ( hResDepends == NULL ) ) {
        status = ERROR_RESOURCE_NOT_FOUND;
    }
    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return hResDepends;

} //*** ResUtilGetResourceDependencyByClass()


HRESOURCE
WINAPI
ResUtilGetResourceNameDependency(
            IN LPCWSTR      lpszResourceName,
            IN LPCWSTR      lpszResourceType
            )

/*++

Routine Description:

    Returns a dependent resource

Arguments:

    lpszResourceName - the name of the resource

    lpszResourceType - the type of the resource that it depends on


Return Value:

    NULL - error (use GetLastError() to get further info)

    NON-NULL - Handle to a resource of type ResourceType

--*/
{
    HRESOURCE   hResDepends = NULL;
    HCLUSTER    hCluster    = NULL;
    HRESOURCE   hSelf       = NULL;
    HRESENUM    hResEnum    = NULL;
    WCHAR       szName[ __INITIAL_NAME_LENGTH ];
    LPWSTR      pszName     = szName;
    DWORD       cchSize      = __INITIAL_NAME_LENGTH;
    DWORD       cchRetSize;
    DWORD       dwType      = 0;
    DWORD       dwIndex     = 0;
    DWORD       status = ERROR_SUCCESS;

    if ( lpszResourceName == NULL )  {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    hCluster = OpenCluster( NULL );
    if ( hCluster == NULL ) {
        return( NULL );
    }

    //
    // Open a handle to the passed in resource name.
    //
    hSelf = OpenClusterResource( hCluster, lpszResourceName );
    if ( hSelf == NULL ) {
        goto error_exit;
    }

    //
    // Open the depends on enum (get resource dependencies)
    //
    hResEnum = ClusterResourceOpenEnum( hSelf, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if ( hResEnum == NULL ) {
        goto error_exit;
    }

    //
    // Enumerate all the depends on keys
    //
    do {
        cchRetSize = cchSize;
        status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        if ( status == ERROR_MORE_DATA ) {
            //
            // Output name buffer is too small.  Allocate a new one.
            //
            cchSize = cchRetSize + 1;   // Add room for terminating NULL
            if ( pszName != szName ) {
                LocalFree( pszName );
            }
            pszName = LocalAlloc( LMEM_FIXED, cchSize * sizeof(WCHAR) );
            if ( pszName == NULL ) {
                status = GetLastError();
                break;
            } // if:  error allocating memory
            cchRetSize = cchSize;
            status = ClusterResourceEnum( hResEnum, dwIndex, &dwType, pszName, &cchRetSize );
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Determine the type of resource found
        //
        hResDepends = OpenClusterResource( hCluster, pszName );
        if ( hResDepends == NULL ) {
            break;
        }

        //
        // Valid resource now open the reg and get it's type
        //
        if ( ResUtilResourceTypesEqual( lpszResourceType, hResDepends ) ) {
            break;
        }

        //
        // Close all handles, key's
        //
        if ( hResDepends != NULL ) {
            CloseClusterResource( hResDepends );
            hResDepends = NULL;
        }

        dwIndex++;
    } while (status == ERROR_SUCCESS);

error_exit:
//
// At this point hResDepends is NULL if no match or non-null (success)
//
    if ( hCluster != NULL ) {
        CloseCluster( hCluster );
    }

    if ( hSelf != NULL ) {
        CloseClusterResource( hSelf );
    }

    if ( hResEnum != NULL ) {
        ClusterResourceCloseEnum( hResEnum );
    }

    if ( pszName != szName ) {
        LocalFree( pszName );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return hResDepends;

} //*** ResUtilGetResourceNameDependency()


DWORD
WINAPI
ResUtilGetPropertyFormats(
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT PVOID pOutPropertyFormatList,
    IN DWORD cbPropertyFormatListSize,
    OUT LPDWORD pcbBytesReturned,
    OUT LPDWORD pcbRequired
    )
{
    return( ClRtlGetPropertyFormats( pPropertyTable,
                                     pOutPropertyFormatList,
                                     cbPropertyFormatListSize,
                                     pcbBytesReturned,
                                     pcbRequired ) );

} // ResUtilGetPropertyFormats()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\netname\netname.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    netname.h

Abstract:

    defines for netname resource DLL

Author:

    Charlie Wickham (charlwi) 21-Jan-2001

Environment:

    User Mode

Revision History:

--*/

#include <windns.h>
#include <dsgetdc.h>

//
// local defines
//
#define COUNT_OF( x )   ( sizeof( x ) / sizeof( x[0] ))

#define NetNameLogEvent             ClusResLogEvent

//
// module externs
//
extern ULONG    NetNameWorkerCheckPeriod;
extern LPWSTR   NetNameCompObjAccountDesc;

//
// entries at the Resource Key level (not under Parameters key)
//

#define PARAM_NAME__NAME                CLUSREG_NAME_NET_NAME
#define PARAM_NAME__FLAGS               CLUSREG_NAME_FLAGS

#define PARAM_NAME__CORECURRENTNAME     L"CoreCurrentName"

#define PARAM_NAME__RENAMEORIGINALNAME  L"RenameOriginalName"
#define PARAM_NAME__RENAMENEWNAME       L"RenameNewName"

//
// Resource Property constants
//

#define PARAM_NAME__REMAP               L"RemapPipeNames"
#define PARAM_DEFAULT__REMAP            FALSE

#define PARAM_NAME__RESOURCE_DATA       L"ResourceData"
#define PARAM_NAME__STATUS_NETBIOS      L"StatusNetBIOS"
#define PARAM_NAME__STATUS_DNS          L"StatusDNS"
#define PARAM_NAME__STATUS_KERBEROS     L"StatusKerberos"

#define PARAM_NAME__REQUIRE_DNS         L"RequireDNS"
#define PARAM_DEFAULT__REQUIRE_DNS      0

#define PARAM_NAME__REQUIRE_KERBEROS    L"RequireKerberos"
#define PARAM_DEFAULT__REQUIRE_KERBEROS 0

#ifdef PASSWORD_ROTATION

#define PARAM_NAME__NEXT_UPDATE         L"NextUpdate"

#define PARAM_NAME__UPDATE_INTERVAL     L"UpdateInterval"
#define PARAM_DEFAULT__UPDATE_INTERVAL  ( 30 )          // 30 days
#define PARAM_MINIMUM__UPDATE_INTERVAL  ( 0 )           // no password update is done
#define PARAM_MAXIMUM__UPDATE_INTERVAL  ( 0xFFFFFFFF )  // many years...

#endif  // PASSWORD_ROTATION

#define PARAM_NAME__CREATING_DC         L"CreatingDC"

//
// netname worker thread check frequencies for when talking to the DNS server
// goes as expected and when they don't. periods are in seconds. Short periods
// are for testing.
//
//#define _SHORT_PERIODS

#ifdef _SHORT_PERIODS
#define NETNAME_WORKER_NORMAL_CHECK_PERIOD      60
#define NETNAME_WORKER_PROBLEM_CHECK_PERIOD     60
#define NETNAME_WORKER_PENDING_PERIOD            2
#else
#define NETNAME_WORKER_NORMAL_CHECK_PERIOD      (60 * 60 * 24)      // 24 hours
#define NETNAME_WORKER_PROBLEM_CHECK_PERIOD     (60 * 10)           // 10 minutes
#define NETNAME_WORKER_PENDING_PERIOD            60
#endif

//
// this struct is used to hold the matched set of DNS A and PTR records with
// which the network name's DNS name and reverse name are registered.
// {Fwd,Rev}ZoneIsDynamic is used as a validity flag in the case where the
// initial DnsUpdateTest call timed out and we later discover that this server
// doesn't except updates. In that case, ZoneIsDynamic is set to FALSE and the
// worker thread checks for these records are skipped.
//
// In hind sight, each record type should have had its own DNS_LIST entry
// instead of putting both A and PTR together in one structure. This has led
// to constructing an invalid list of PTR records in its
// DNS_RRSET. Consequently, there is some ugly code in RegisterDnsRecords that
// has to build a fake DNS_RRSET in order to get the PTR records registered.
//

typedef struct _DNS_LISTS {
    DNS_RRSET   A_RRSet;
    DNS_STATUS  LastARecQueryStatus;
    DNS_RRSET   PTR_RRSet;
    DNS_STATUS  LastPTRRecQueryStatus;  // not used
    PIP4_ARRAY  DnsServerList;
    LPWSTR      ConnectoidName;

    //
    // TRUE if we couldn't contact the server during record build time. This
    // means that the worker thread will need to call DnsUpdateTest to
    // determine if the server is dynamic
    //
    BOOL        UpdateTestTimeout;

    //
    // used to "invalidate" this entry if we discovered after online that the
    // server isn't dynamic
    //
    BOOL        ForwardZoneIsDynamic;

    //
    // TRUE if we've already logged an error about this entry in the system
    // event log
    //
    BOOL        AErrorLogged;

    //
    // PTR corresponding vars with same functionality as their A counterparts
    //
    BOOL        ReverseZoneIsDynamic;
    BOOL        PTRErrorLogged;
} DNS_LISTS, *PDNS_LISTS;

//
// set this define to one to get addt'l debug spew to see the interaction with
// the DNS server and determine if the RRSet structures are getting built
// correctly.
//
#define DBG_DNSLIST 0

//
// this struct is used to hold the mapping between a cluster IP address and a
// DNS domain name. The FQDN is built using these domain suffixes and the
// cluster netname. The connectoid name is included so we can log over which
// NIC we did the registration.
//

typedef struct _DOMAIN_ADDRESS_MAPPING {
    LPWSTR      ConnectoidName;
    LPWSTR      IpAddress;
    LPWSTR      DomainName;
    PIP4_ARRAY  DnsServerList;
} DOMAIN_ADDRESS_MAPPING, *PDOMAIN_ADDRESS_MAPPING;

//
// backing structure for resource properties
//
typedef struct _NETNAME_PARAMS {
    //
    // the name that is currently online
    //
    LPWSTR      NetworkName;

    //
    // true if RemapPipeNames set to one; used by SQL to remap virtual pipe
    // names to the node's name (?)
    //
    DWORD       NetworkRemap;

    //
    // pointer to r/o encrypted computer object password
    //
    PBYTE       ResourceData;

    //
    // R/W props: if set to TRUE, the respective section must succeed for the
    // resource to go online. RequireKerberos implies RequireDNS.
    //
    BOOL        RequireDNS;
    BOOL        RequireKerberos;

    //
    // read-only props that reflect final status codes for the corresponding
    // functionality
    //
    DWORD       StatusNetBIOS;
    DWORD       StatusDNS;
    DWORD       StatusKerberos;

#ifdef PASSWORD_ROTATION
    //
    // read-only timestamp of when to perform next password update
    //
    FILETIME    NextUpdate;

    //
    // R/W pwd update interval in days
    //
    DWORD   UpdateInterval;
#endif  // PASSWORD_ROTATION

    //
    // r/o prop that holds name of DC on which computer object was created
    //
    LPWSTR  CreatingDC;

} NETNAME_PARAMS, *PNETNAME_PARAMS;

//
// netname resource context block. One per instance of a netname resource.
//
typedef struct {
    LIST_ENTRY              Next;
    LONG                    RefCount;               // ref count on entire resource block
    CLUSTER_RESOURCE_STATE  State;
    RESOURCE_HANDLE         ResourceHandle;         // handle for logging to cluster log
    DWORD                   dwFlags;
    HANDLE *                NameHandleList;         // array of netbios w/s handles
    DWORD                   NameHandleCount;
    CLUS_WORKER             PendingThread;
    LPWSTR                  NodeName;
    LPWSTR                  NodeId;

    //
    // handles to our resource key, resource's parameters key as the resource
    // itself
    //
    HKEY        ResKey;
    HKEY        ParametersKey;
    HRESOURCE   ClusterResourceHandle;

    //
    // used during online pending processing so we can keep increasing the
    // checkpoint value for each individual resource
    //
    ULONG   StatusCheckpoint;

    //
    // count and pointer to the DNS publishing information; mutex is used to
    // sync access to DnsLists and NumberOfDnsLists
    //
    HANDLE      DnsListMutex;
    DWORD       NumberOfDnsLists;
    PDNS_LISTS  DnsLists;

    //
    // holder of resource properties
    //
    NETNAME_PARAMS  Params;
    
    //
    // used to handle case where the name property has changed while the
    // resource is online. If TRUE, then offline processing will take
    // appropriate steps to handle this condition.
    //
    BOOL    NameChangedWhileOnline;

    //
    // number of bytes pointed to by Params.ResourceData
    //
    DWORD   ResDataSize;

    //
    // objectGUID attribute of the computer object from DS. Using the GUID
    // frees us from having to track object moves in the DS.
    //
    LPWSTR  ObjectGUID;

    //
    // DoKerberosCheck is TRUE if Add/UpdateComputerObject was
    // successful. This is used by the worker thread to determine if it should
    // check on the computer object. The status returned by that check is
    // stored in KerberosStatus. VSToken is a primary token representing the
    // virtual computer object. It is dup'ed when another resource requests a
    // token representing the account.
    //
    // For upgrades to Windows Server 2003, we have to force RequireKerberos on if the
    // netname has a dependent MSMQ resource. The CheckForKerberosUpgrade flag
    // is used during online to flag the existing resources to make that check.
    //
    BOOL    DoKerberosCheck;
    DWORD   KerberosStatus;
    HANDLE  VSToken;
    BOOL    CheckForKerberosUpgrade;

} NETNAME_RESOURCE, *PNETNAME_RESOURCE;

//
// public routines
//
DWORD
GrowBlock(
    PCHAR * Block,
    DWORD   UsedEntries,
    DWORD   BlockSize,
    PDWORD  FreeEntries
    );

DWORD
NetNameCheckNbtName(
    IN LPCWSTR         NetName,
    IN DWORD           NameHandleCount,
    IN HANDLE *        NameHandleList,
    IN RESOURCE_HANDLE ResourceHandle
    );


#ifdef __cplusplus
extern "C" {
#endif

DWORD
AddComputerObject(
    IN  PCLUS_WORKER        Worker,
    IN  PNETNAME_RESOURCE   Resource,
    OUT PWCHAR *            MachinePwd
    );

DWORD
UpdateComputerObject(
    IN  PCLUS_WORKER        Worker,
    IN  PNETNAME_RESOURCE   Resource,
    OUT PWCHAR *            MachinePwd
    );

DWORD
DisableComputerObject(
    IN  PNETNAME_RESOURCE   Resource
    );

HRESULT
CheckComputerObjectAttributes(
    IN  PNETNAME_RESOURCE   Resource,
    IN  LPWSTR              DCName      OPTIONAL
    );

HRESULT
IsComputerObjectInDS(
    IN  RESOURCE_HANDLE ResourceHandle,
    IN  LPWSTR          NodeName,
    IN  LPWSTR          NewObjectName,
    IN  LPWSTR          DCName              OPTIONAL,
    OUT PBOOL           ObjectExists,
    OUT LPWSTR *        DistinguishedName,  OPTIONAL
    OUT LPWSTR *        HostingDCName       OPTIONAL
    );

HRESULT
GetComputerObjectGuid(
    IN PNETNAME_RESOURCE    Resource,
    IN LPWSTR               Name        OPTIONAL
    );

HRESULT
RenameComputerObject(
    IN  PNETNAME_RESOURCE   Resource,
    IN  LPWSTR              CurrentName,
    IN  LPWSTR              NewName
    );

#ifdef PASSWORD_ROTATION
DWORD
UpdateCompObjPassword(
    IN  PNETNAME_RESOURCE   Resource
    );
#endif  // PASSWORD_ROTATION

VOID
RemoveNNCryptoCheckpoint(
    PNETNAME_RESOURCE   Resource
    );

BOOL
DoesMsmqNeedComputerObject(
    VOID
    );

DWORD
UpgradeMSMQDependentNetnameToKerberos(
    PNETNAME_RESOURCE   Resource
    );

DWORD
DuplicateVSToken(
    PNETNAME_RESOURCE           Resource,
    PCLUS_NETNAME_VS_TOKEN_INFO TokenInfo,
    PHANDLE                     DuplicatedToken
    );

#ifdef __cplusplus
}
#endif

/* end netname.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\netname\netname.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    netname.c

Abstract:

    Resource DLL for a network name.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

    Severely whacked on by Charlie Wickham (charlwi)

--*/

#define UNICODE 1

#include "clusres.h"
#include "clusrtl.h"
#include <lm.h>
#include <srvann.h>
#include <dsgetdc.h>
#include <dsgetdcp.h>
#include <adserr.h>
#include "netname.h"
#include "nameutil.h"
#include "namechk.h"
#include "clusudef.h"
#include "clusstrs.h"

//
// Constants
//

#define LOG_CURRENT_MODULE              LOG_MODULE_NETNAME

#define IP_ADDRESS_RESOURCETYPE_NAME    CLUS_RESTYPE_NAME_IPADDR

//
// Macros
//
#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT( ArgumentPointer )   (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#endif


//
// turn on _INSTRUMENTED_LOCKS if you're trying to figure out where the lock
// is getting orphaned
//

//#define _INSTRUMENTED_LOCKS
#ifdef _INSTRUMENTED_LOCKS

#define NetNameAcquireResourceLock()                                \
{                                                                   \
    DWORD status;                                                   \
    status = WaitForSingleObject(NetNameResourceMutex, INFINITE);   \
    if ( status == WAIT_ABANDONED ) {                               \
        OutputDebugStringW( L"Resource List Mutex Abandoned!\n" );  \
        DebugBreak();                                               \
    }                                                               \
    (NetNameLogEvent)(L"rtNetwork Name",                            \
                      LOG_INFORMATION,                              \
                      L"++NNMutex (line %1!u!)\n",                  \
                      __LINE__);                                    \
}

#define NetNameReleaseResourceLock()                                \
{                                                                   \
    BOOL    released;                                               \
    (NetNameLogEvent)(L"rtNetwork Name",                            \
                      LOG_INFORMATION,                              \
                      L"--NNMutex (line %1!u!)\n",                  \
                      __LINE__);                                    \
    released = ReleaseMutex(NetNameResourceMutex);                  \
}

#define NetNameAcquireDnsListLock( _res_ )                          \
{                                                                   \
    DWORD status;                                                   \
    status = WaitForSingleObject((_res_)->DnsListMutex, INFINITE);  \
    if ( status == WAIT_ABANDONED ) {                               \
        OutputDebugStringW( L"DNS List Mutex Abandoned!\n" );       \
        DebugBreak();                                               \
    }                                                               \
    (NetNameLogEvent)(L"rtNetwork Name",                            \
                      LOG_INFORMATION,                              \
                      L"++DNSMutex (res %1!X! line %2!u!)\n",       \
                      _res_, __LINE__);                             \
}

#define NetNameReleaseDnsListLock( _res_ )                      \
{                                                               \
    BOOL    released;                                           \
    (NetNameLogEvent)(L"rtNetwork Name",                        \
                      LOG_INFORMATION,                          \
                      L"--DNSMutex (res %1!X! line %2!u!)\n",   \
                      _res_, __LINE__);                         \
    released = ReleaseMutex((_res_)->DnsListMutex);             \
    if ( !released ) {                                          \
        (NetNameLogEvent)(L"rtNetwork Name",                    \
                          LOG_INFORMATION,                      \
                          L"ERROR %1!d! releasing DNS mutex (res %2!X! line %3!u!)\n", \
                          GetLastError(), _res_, __LINE__);     \
    }                                                           \
}

#else       // _INSTRUMENTED_LOCKS

#define NetNameAcquireResourceLock()                                \
{                                                                   \
    DWORD status;                                                   \
    status = WaitForSingleObject(NetNameResourceMutex, INFINITE);   \
}

#define NetNameReleaseResourceLock()                \
{                                                   \
    BOOL    released;                               \
    released = ReleaseMutex(NetNameResourceMutex);  \
}

#define NetNameAcquireDnsListLock( _res_ )                                  \
{                                                                           \
    DWORD status;                                                           \
    status = WaitForSingleObject((_res_)->DnsListMutex, INFINITE);          \
}

#define NetNameReleaseDnsListLock( _res_ )                                  \
{                                                                           \
    BOOL    released;                                                       \
    released = ReleaseMutex((_res_)->DnsListMutex);                         \
}
#endif  // _INSTRUMENTED_LOCKS

//
// Local Variables
//
// Mutex for sync'ing access to the list of resources as well as each resource
// block
//
HANDLE  NetNameResourceMutex = NULL;

//
// The checking of DNS names requires talking to a DNS server, hence this work
// is spun off to a separate thread. The resource context blocks are linked
// together on a doubly linked list and are ref counted to make sure that a
// block isn't changed during offline processing while its DNS name records
// are being checked.
//
// The NetNameWorkerTerminate event signals the worker routine to exit.
//
HANDLE  NetNameWorkerTerminate;

//
// NetNameWorkerPendingResources is used to signal the worker thread that a
// name is moving through a pending state. It is possible for an online
// operation to time out when lots of names go online
// simultaneously. Similarly, an offline might require communication with a DC
// which could take a while. The worker thread will periodically report back
// to resmon that we're making progress.
//
HANDLE  NetNameWorkerPendingResources;

//
// list head for resource context block linkage
//
LIST_ENTRY  NetNameResourceListHead;

//
// the amount of seconds the worker thread waits before doing something. This
// includes querying the DNS server to make sure registrations are correct and
// reporting back to resmon when names are going online. This value gets
// smaller when server communication is suspect.
//
ULONG   NetNameWorkerCheckPeriod;

//
// ladies and gentlemen, the worker thread
//
HANDLE  NetNameWorkerThread;

//
// Count of opened NetName resources.
//   Incremented in NetNameOpen
//   Decremented in NetNameClose
//
DWORD   NetNameOpenCount = 0;

//
// account description string used for computer objects
//
LPWSTR  NetNameCompObjAccountDesc;

//
// argh. If you have r/w and r/o props, you have to combine them into a
// combined prop table in order to support unknown properties correctly. For
// this reason, we use #defines to keep only one list of properties.
//
#define NETNAME_RW_PROPERTIES                           \
    {                                                   \
        PARAM_NAME__NAME,                               \
        NULL,                                           \
        CLUSPROP_FORMAT_SZ,                             \
        0, 0, 0,                                        \
        RESUTIL_PROPITEM_REQUIRED,                      \
        FIELD_OFFSET(NETNAME_PARAMS,NetworkName)        \
    },                                                  \
    {                                                   \
        PARAM_NAME__REMAP,                              \
        NULL,                                           \
        CLUSPROP_FORMAT_DWORD,                          \
        PARAM_DEFAULT__REMAP,                           \
        0, 1, 0,                                        \
        FIELD_OFFSET(NETNAME_PARAMS,NetworkRemap)       \
    },                                                  \
    {                                                   \
        PARAM_NAME__REQUIRE_DNS,                        \
        NULL,                                           \
        CLUSPROP_FORMAT_DWORD,                          \
        PARAM_DEFAULT__REQUIRE_DNS,                     \
        0, 1, 0,                                        \
        FIELD_OFFSET(NETNAME_PARAMS,RequireDNS)         \
    },                                                  \
    {                                                   \
        PARAM_NAME__REQUIRE_KERBEROS,                   \
        NULL,                                           \
        CLUSPROP_FORMAT_DWORD,                          \
        PARAM_DEFAULT__REQUIRE_KERBEROS,                \
        0, 1, 0,                                        \
        FIELD_OFFSET(NETNAME_PARAMS,RequireKerberos)    \
    }

#define NETNAME_RO_PROPERTIES                       \
    {                                               \
        PARAM_NAME__RESOURCE_DATA,                  \
        NULL,                                       \
        CLUSPROP_FORMAT_BINARY,                     \
        0, 0, 0,                                    \
        RESUTIL_PROPITEM_READ_ONLY,                 \
        FIELD_OFFSET(NETNAME_PARAMS,ResourceData)   \
    },                                              \
    {                                               \
        PARAM_NAME__STATUS_NETBIOS,                 \
        NULL,                                       \
        CLUSPROP_FORMAT_DWORD,                      \
        0, 0, 0xFFFFFFFF,                           \
        RESUTIL_PROPITEM_READ_ONLY,                 \
        FIELD_OFFSET(NETNAME_PARAMS,StatusNetBIOS)  \
    },                                              \
    {                                               \
        PARAM_NAME__STATUS_DNS,                     \
        NULL,                                       \
        CLUSPROP_FORMAT_DWORD,                      \
        0, 0, 0xFFFFFFFF,                           \
        RESUTIL_PROPITEM_READ_ONLY,                 \
        FIELD_OFFSET(NETNAME_PARAMS,StatusDNS)      \
    },                                              \
    {                                               \
        PARAM_NAME__STATUS_KERBEROS,                \
        NULL,                                       \
        CLUSPROP_FORMAT_DWORD,                      \
        0, 0, 0xFFFFFFFF,                           \
        RESUTIL_PROPITEM_READ_ONLY,                 \
        FIELD_OFFSET(NETNAME_PARAMS,StatusKerberos) \
    },                                              \
    {                                               \
        PARAM_NAME__CREATING_DC,                    \
        NULL,                                       \
        CLUSPROP_FORMAT_SZ,                         \
        0, 0, 0,                                    \
        RESUTIL_PROPITEM_READ_ONLY,                 \
        FIELD_OFFSET(NETNAME_PARAMS,CreatingDC)     \
    }

/*
#ifdef PASSWORD_ROTATION
// r/w
    {                                                   \
        PARAM_NAME__UPDATE_INTERVAL,                    \
        NULL,                                           \
        CLUSPROP_FORMAT_DWORD,                          \
        PARAM_DEFAULT__UPDATE_INTERVAL,                 \
        PARAM_MINIMUM__UPDATE_INTERVAL,                 \
        PARAM_MAXIMUM__UPDATE_INTERVAL,                 \
        0,                                              \
        FIELD_OFFSET(NETNAME_PARAMS,UpdateInterval)     \
    }

// read-only
    {                                               \
        PARAM_NAME__NEXT_UPDATE,                    \
        NULL,                                       \
        CLUSPROP_FORMAT_BINARY,                     \
        0, 0, 0,                                    \
        RESUTIL_PROPITEM_READ_ONLY,                 \
        FIELD_OFFSET(NETNAME_PARAMS,NextUpdate)     \
    },                                              \
#endif  // PASSWORD_ROTATION
*/

//
// Network Name resource read-write private properties.
//
// DON'T ADD PROPERTIES DIRECTLY TO THIS TABLE. ADD TO THE APPROPRIATE MACRO
// DEFINED ABOVE.
//
RESUTIL_PROPERTY_ITEM
NetNameResourcePrivateProperties[] = {
    NETNAME_RW_PROPERTIES,
    { NULL, NULL, 0, 0, 0, 0 }
};

//
// Network Name resource read-only private properties.
//
// DON'T ADD PROPERTIES DIRECTLY TO THIS TABLE. ADD TO THE APPROPRIATE MACRO
// DEFINED ABOVE.
//
RESUTIL_PROPERTY_ITEM
NetNameResourceROPrivateProperties[] = {
    NETNAME_RO_PROPERTIES,
    { NULL, NULL, 0, 0, 0, 0 }
};

//
// Network Name resource combined private properties.
//
// DON'T ADD PROPERTIES DIRECTLY TO THIS TABLE. ADD TO THE APPROPRIATE MACRO
// DEFINED ABOVE.
//
RESUTIL_PROPERTY_ITEM
NetNameResourceCombinedPrivateProperties[] = {
    NETNAME_RW_PROPERTIES,
    NETNAME_RO_PROPERTIES,
    { NULL, NULL, 0, 0, 0, 0 }
};

//
// static variables
//

//
// after an upgrade, this var will be true if MSMQ dependent netnames should
// be upgraded to kerberos support.
//
static BOOL CheckForKerberosUpgrade = FALSE;

//
// forward declarations
//

CLRES_FUNCTION_TABLE NetNameFunctionTable;

//
// Forward references
//

DWORD
NetNameGetPrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN BOOL ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
NetNameValidatePrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PNETNAME_PARAMS Params,
    OUT PBOOL NetnameHasChanged,
    OUT PBOOL CompObjRenameIsRequired
    );

DWORD
NetNameSetPrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NetNameClusterNameChanged(
    IN PNETNAME_RESOURCE Resource
    );

DWORD
NetNameGetNetworkName(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

VOID
NetNameCleanupDnsLists(
    IN  PNETNAME_RESOURCE   Resource
    );

VOID
RemoveDnsRecords(
    PNETNAME_RESOURCE Resource
    );

//
// Local utility functions
//


VOID
WINAPI
NetNameReleaseResource(
    IN RESID Resource
    )

/*++

Routine Description:

    Cleanup all handles and memory allocations in the netname context block

Arguments:

    Resource - supplies resource id to be cleaned up.

Return Value:

    None.

--*/

{
    PNETNAME_RESOURCE   resource = (PNETNAME_RESOURCE) Resource;
    PLIST_ENTRY         entry;


    if ( resource == NULL ) {
        return;
    }

    if (resource->Params.NetworkName != NULL) {
        LocalFree( resource->Params.NetworkName );
    }

    if (resource->Params.ResourceData != NULL) {
        LocalFree( resource->Params.ResourceData );
    }

    if (resource->Params.CreatingDC != NULL) {
        LocalFree( resource->Params.CreatingDC );
    }

    if (resource->NodeName != NULL) {
        LocalFree( resource->NodeName );
    }

    if (resource->NodeId != NULL) {
        LocalFree( resource->NodeId );
    }

    if (resource->ParametersKey != NULL) {
        ClusterRegCloseKey(resource->ParametersKey);
    }

    if (resource->ResKey != NULL){
        ClusterRegCloseKey(resource->ResKey);
    }

    if (resource->ClusterResourceHandle != NULL){
        CloseClusterResource(resource->ClusterResourceHandle);
    }

    if (resource->ObjectGUID != NULL) {
        LocalFree( resource->ObjectGUID );
    }

    if ( resource->DnsLists != NULL ) {
        NetNameCleanupDnsLists( resource );
    }

    if ( resource->DnsListMutex != NULL ) {
#if DBG
        {
            DWORD status;

            status = WaitForSingleObject( resource->DnsListMutex, 0 );
            if ( status == WAIT_TIMEOUT ) {
                WCHAR   buf[64];

                buf[ COUNT_OF( buf ) - 1 ] = UNICODE_NULL;
                _snwprintf(buf, COUNT_OF( buf ) - 1,
                           L"res %08X DNS list mutex still signalled at delete!\n",
                           (DWORD_PTR)resource);
                OutputDebugStringW( buf );
                DebugBreak();
            } else {
                ReleaseMutex( resource->DnsListMutex );
            }
        }
#endif

        CloseHandle( resource->DnsListMutex );
    }

    (NetNameLogEvent)(resource->ResourceHandle,
                      LOG_INFORMATION,
                      L"ResID %1!u! closed.\n",
                      Resource
                      );

    LocalFree( resource );

} // NetNameReleaseResource

VOID
NetNameUpdateDnsServer(
    PNETNAME_RESOURCE Resource
    )

/*++

Routine Description:

    Update this resource's A and PTR records at its DNS server

Arguments:

    Resource - pointer to netname resource context block

Return Value:

    None

--*/

{
    PDNS_LISTS      dnsLists;
    DWORD           numberOfDnsLists;
    ULONG           numberOfRegisteredNames;

    NetNameAcquireDnsListLock( Resource );

    numberOfDnsLists = Resource->NumberOfDnsLists;
    dnsLists = Resource->DnsLists;
    while ( numberOfDnsLists-- ) {

        if ( dnsLists->ForwardZoneIsDynamic ) {
#if DBG_DNSLIST
            {
                PDNS_RECORD dnsRec = dnsLists->A_RRSet.pFirstRR;
                WCHAR buf[DNS_MAX_NAME_BUFFER_LENGTH + 64];
                struct in_addr addr;

                if ( dnsRec != NULL ) {
                    addr.s_addr = dnsLists->DnsServerList->AddrArray[0];
                    buf[ COUNT_OF( buf ) - 1 ] = UNICODE_NULL;
                    _snwprintf(buf, COUNT_OF( buf ) - 1,
                               L"REGISTERING ON adapter %.32ws (%hs)\n",
                               dnsLists->ConnectoidName,
                               inet_ntoa( addr ) );
                    OutputDebugStringW( buf );

                    do {
                        addr.s_addr = dnsRec->Data.A.IpAddress;
                        buf[ COUNT_OF( buf ) - 1 ] = UNICODE_NULL;
                        _snwprintf(buf, COUNT_OF( buf ) - 1,
                                   L"\t(%ws, %hs)\n",
                                   dnsRec->pName, inet_ntoa( addr ));
                        OutputDebugStringW( buf );

                        dnsRec = dnsRec->pNext;
                    } while ( dnsRec != NULL );
                }
            }
#endif

            //
            // resource went or is going offline; no point in
            // continueing. don't need to grab resource lock since we have a
            // refcount on the resource block
            //
            if (Resource->State != ClusterResourceOnline) {
                break;
            }

            //
            // register the records to update their timestamp (if there is
            // something to register). Before we used to query but eventually
            // the records would time out and be scavenged (deleted). This can
            // cause lots of grief (or in Exchange's case, lots of undelivered
            // mail).
            //
            // we don't worry about logging errors or update the
            // LastARecQueryStatus since all of that is done in
            // RegisterDnsRecords.
            //
            if ( dnsLists->A_RRSet.pFirstRR != NULL ) {
                RegisterDnsRecords(dnsLists,
                                   Resource->Params.NetworkName,
                                   Resource->ResKey,
                                   Resource->ResourceHandle,
                                   FALSE,                   /* LogRegistration */
                                   &numberOfRegisteredNames);
            }
        } // Is Forward zone dynamic?

        ++dnsLists;

    } // while numberOfDnsLists != 0

    NetNameReleaseDnsListLock( Resource );

} // NetNameUpdateDnsServer

DWORD WINAPI
NetNameWorker(
    IN LPVOID NotUsed
    )

/*++

Routine Description:

    background worker thread. Checks on the health of the DNS registrations
    and reports back to resmon while names are in the online pending
    state. The netname Is/LooksAlive checks are too frequent such that they
    would cause alot of DNS traffic on the network. This routine runs through
    the linked list of netname resource blocks and queries the server for the
    records that should be registered. Any discrepancies will cause the
    records to be registered again. The success of each operation is left in
    the DNS_LIST area for the particular record type.

    In addition, when prompted, it will run down the list of resources and
    report back the resource's status to resmon. Name registration is
    serialized through srv.sys causing some names to time out before they get
    registered.

Arguments:

    NotUsed - not used...

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD               status = ERROR_SUCCESS;
    PLIST_ENTRY         entry;
    PNETNAME_RESOURCE   resource;
    DNS_STATUS          dnsStatus;
    BOOL                reportPending;
    DWORD               oldCheckPeriod = NetNameWorkerCheckPeriod;
    DWORD               pendingResourceCount;
    RESOURCE_STATUS     resourceStatus;
    HANDLE              waitHandles[ 2 ] = { NetNameWorkerTerminate,
                                             NetNameWorkerPendingResources };

    ResUtilInitializeResourceStatus( &resourceStatus );

    do {
        status = WaitForMultipleObjects(2,
                                        waitHandles,
                                        FALSE,
                                        NetNameWorkerCheckPeriod * 1000);


        if ( status == WAIT_OBJECT_0 ) {
            return ERROR_SUCCESS;
        }

        if ( status == ( WAIT_OBJECT_0 + 1 )) {
            reportPending = TRUE;
#if DBG
            (NetNameLogEvent)(L"rtNetwork Name",
                              LOG_INFORMATION,
                              L"Start of pending resource reporting\n");
#endif
        }

        //
        // reset check frequency back to normal. if something goes wrong,
        // other code will set it back to the problem check period.
        //
        NetNameWorkerCheckPeriod = NETNAME_WORKER_NORMAL_CHECK_PERIOD;

        pendingResourceCount = 0;

        NetNameAcquireResourceLock();

        entry = NetNameResourceListHead.Flink;
        while ( entry != &NetNameResourceListHead ) {
            //
            // get a pointer to the resource block
            //
            resource = CONTAINING_RECORD( entry, NETNAME_RESOURCE, Next );

            if ( resource->State > ClusterResourcePending ) {

                //
                // bringing lots (40) of names online simultaneously caused
                // some names to hit their pending timeouts. Each time a name
                // enters a pending state, the NetNameWorkerPendingResources
                // event is set to wake up this thread. The timeout is changed
                // so we can report back to resmon that the operation is
                // continuing. This should prevent resmon from timing out the
                // resource and causing much thrashing. No other checking (DNS
                // or Kerb) is done while this is happening.
                //
#if DBG
                (NetNameLogEvent)(resource->ResourceHandle,
                                  LOG_INFORMATION,
                                  L"Reporting resource pending\n");
#endif

                oldCheckPeriod = NetNameWorkerCheckPeriod;
                NetNameWorkerCheckPeriod = NETNAME_WORKER_PENDING_PERIOD;

                resourceStatus.CheckPoint = ++resource->StatusCheckpoint;
                resourceStatus.ResourceState = resource->State;

                //
                // never hold the resource lock when calling
                // SetResourceStatus. You'll end up with deadlocks when resmon
                // calls back in to the Looks/IsAlive routines. However, the
                // resource state is always synch'ed by this lock. No need to
                // bump refcount since this resource is still in a Pending
                // state and resmon won't allow the resource delete cluster
                // control to be issued.
                //
                NetNameReleaseResourceLock();

                (NetNameSetResourceStatus)(resource->ResourceHandle,
                                           &resourceStatus);

                NetNameAcquireResourceLock();

                ++pendingResourceCount;
            }
            else if ( resource->State == ClusterResourceOnline && !reportPending ) {
                //
                // up the ref count so this resource doesn't go away while we
                // re-register the records with the DNS server. This keeps
                // them from getting scavenged (deleted).
                //
                ++resource->RefCount;
                NetNameReleaseResourceLock();

                NetNameUpdateDnsServer( resource );

                //
                // check the status of the computer object and see if it is
                // time to generate a new password.
                //
                if ( resource->DoKerberosCheck ) {
                    FILETIME    currentFileTime;

                    if ( resource->ObjectGUID == NULL ) {
                        //
                        // wasn't able to get the GUID during online; let's try now
                        //
                        GetComputerObjectGuid( resource, NULL );
                    }

                    if ( resource->ObjectGUID != NULL ) {
                        status = CheckComputerObjectAttributes( resource, NULL );
                        InterlockedExchange( &resource->KerberosStatus, status );
                    }

#ifdef PASSWORD_ROTATION
                    GetSystemTimeAsFileTime( &currentFileTime );
                    if ( CompareFileTime( &currentFileTime, &resource->Params.NextUpdate ) == 1 ) {
                        ULARGE_INTEGER  updateTime;
                        DWORD           setValueStatus;

                        status = UpdateCompObjPassword( resource );

                        updateTime.LowPart = currentFileTime.dwLowDateTime;
                        updateTime.HighPart = currentFileTime.dwHighDateTime;
                        updateTime.QuadPart += ( resource->Params.UpdateInterval * 60 * 1000 * 100 );
                        currentFileTime.dwLowDateTime = updateTime.LowPart;
                        currentFileTime.dwHighDateTime = updateTime.HighPart;

                        setValueStatus = ResUtilSetBinaryValue(resource->ParametersKey,
                                                               PARAM_NAME__NEXT_UPDATE,
                                                               (const LPBYTE)&updateTime,  
                                                               sizeof( updateTime ),
                                                               NULL,
                                                               NULL);
                        //
                        // not sure how we should handle an error here; any
                        // type of error generally indicates that the cluster
                        // service has croaked. Since this is our worker
                        // thread, there isn't much we can do until we've been
                        // asked to terminate.
                        //
//                        ASSERT( setValueStatus == ERROR_SUCCESS );
                    }
#endif  // PASSWORD_ROTATION
                }

                //
                // reacquire the mutex so we can release our reference. If the
                // resource went offline and was deleted during the
                // registration, then perform "last ref" cleanup. If the
                // resource just went offline, we need to inform resmon that
                // we're finally going offline. This is synchronized with the
                // resource delete code by not having the DNS lists in use
                // when a delete resource control is sent.
                //
                NetNameAcquireResourceLock();

                ASSERT( resource->RefCount > 0 );  /* Ruihu: 11/04/2000 */
                if (resource->RefCount == 1) {
                    //
                    // we hold the last reference to this resource so it must
                    // have been deleted while the registration was taking
                    // place. Clean up and free our context block for this
                    // resource. Restart the loop since we don't know if the
                    // flink for this entry is still valid.
                    //
                    NetNameReleaseResource( resource );

                    entry = NetNameResourceListHead.Flink; /* start over */

                    continue;
                } 
                else 
                {
                    if ( resource->State == ClusterResourceOfflinePending ) {
                        BOOL    nameChanged;

                        //
                        // The resource state was changed while we were
                        // dealing with DNS. Set the state to offline.
                        //
                        resourceStatus.ResourceState = ClusterResourceOffline;
                        resource->State = ClusterResourceOffline;

                        //
                        // note whatever cleanup we need to do while we hold the lock
                        //
                        nameChanged = resource->NameChangedWhileOnline;
                        resource->NameChangedWhileOnline = FALSE;

                        //
                        // ok to release lock since we haven't released our
                        // reference to this block
                        //
                        NetNameReleaseResourceLock();

                        // 
                        // if appropriate, do cleanup processing
                        //
                        if ( nameChanged ) {
                            RemoveDnsRecords( resource );
                            resource->NameChangedWhileOnline = FALSE;
                        }

                        (NetNameSetResourceStatus)(resource->ResourceHandle,
                                                   &resourceStatus);

                        (NetNameLogEvent)(resource->ResourceHandle,
                                          LOG_INFORMATION,
                                          L"Resource is now offline\n");

                        NetNameAcquireResourceLock();
                    }  // ( resource->State == ClusterResourceOfflinePending )

                    /* Ruihu: 11/04/2000 */
                    --resource->RefCount; 
                    ASSERT(resource->RefCount >=0 );
                    if (resource->RefCount == 0) {
                        NetNameReleaseResource( resource );
                        entry = NetNameResourceListHead.Flink; /* start over */
                        continue;
                    } 
                    /* Ruihu: 11/04/2000 */
                } // end if resource count != 1
            } // resource is online

            entry = entry->Flink;
        } // while entries in the resource block list

        NetNameReleaseResourceLock();

        if ( reportPending && pendingResourceCount == 0 ) {
            //
            // no resources are left in a pending state so revert back to
            // checking DNS registrations
            //
            NetNameWorkerCheckPeriod = oldCheckPeriod;
            reportPending = FALSE;
#if DBG
            (NetNameLogEvent)(L"rtNetwork Name",
                              LOG_INFORMATION,
                              L"End of pending resource reporting\n");
#endif
        }

    } while ( TRUE );

} // NetNameWorker

BOOLEAN
NetNameInit(
    IN HINSTANCE    DllHandle
    )
/*++

Routine Description:

    Process attach initialization routine.

Arguments:

    DllHandle - handle to clusres module

Return Value:

    TRUE if initialization succeeded. FALSE otherwise.

--*/
{
    DWORD   status;
    DWORD   charsCopied;
    DWORD   charsAllocated = 0;

    NetNameResourceMutex = CreateMutex(NULL, FALSE, NULL);

    if (NetNameResourceMutex == NULL) {
        return(FALSE);
    }

    //
    // create worker thread terminate event with no special security,
    // auto-reset, initially nonsignalled, and no name
    //
    NetNameWorkerTerminate = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( NetNameWorkerTerminate == NULL ) {
        CloseHandle( NetNameResourceMutex );
        return FALSE;
    }

    //
    // create worker thread online pending event with no special security,
    // auto-reset, initially nonsignalled, and no name
    //
    NetNameWorkerPendingResources = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( NetNameWorkerPendingResources == NULL ) {
        CloseHandle( NetNameWorkerTerminate );
        CloseHandle( NetNameResourceMutex );
        return FALSE;
    }

    //
    // init the list head of the list of resources to check for DNS
    // registrations
    //
    InitializeListHead( &NetNameResourceListHead );

    //
    // lookup the account description string resource; start with 64 char
    // buffer and double until we fail or we get all of the string. Not
    // considered fatal if we can't load the string
    //
    charsAllocated = 64;

realloc:
    charsCopied = 0;
    NetNameCompObjAccountDesc = LocalAlloc( LMEM_FIXED, charsAllocated * sizeof( WCHAR ));
    if ( NetNameCompObjAccountDesc ) {

        charsCopied = LoadString(DllHandle,
                                 RES_NETNAME_COMPUTER_ACCOUNT_DESCRIPTION,
                                 NetNameCompObjAccountDesc,
                                 charsAllocated);

        if ( charsCopied != 0 && charsCopied == ( charsAllocated - 1 )) {
            LocalFree( NetNameCompObjAccountDesc );
            charsAllocated *= 2;
            goto realloc;
        }
    }

    if ( charsCopied == 0 && NetNameCompObjAccountDesc != NULL ) {
        LocalFree( NetNameCompObjAccountDesc );
        NetNameCompObjAccountDesc = NULL;
    }

    return(TRUE);
} // NetNameInit


VOID
NetNameCleanup(
    VOID
    )
/*++

Routine Description:

    Process detach cleanup routine.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (NetNameResourceMutex != NULL) {
        CloseHandle(NetNameResourceMutex);
        NetNameResourceMutex = NULL;
    }

    if ( NetNameWorkerTerminate ) {
        CloseHandle( NetNameWorkerTerminate );
        NetNameWorkerTerminate = NULL;
    }

    if ( NetNameWorkerPendingResources ) {
        CloseHandle( NetNameWorkerPendingResources );
        NetNameWorkerPendingResources = NULL;
    }

} // NetNameCleanup


PNETNAME_RESOURCE
NetNameAllocateResource(
    IN  RESOURCE_HANDLE ResourceHandle
    )
/*++

Routine Description:

    Allocates a resource object.

Arguments:

    ResourceHandle - A pointer to the Resource Monitor handle to be associated
                     with this resource.

Return Value:

    A pointer to the new resource if successful. NULL otherwise.

--*/
{
    PNETNAME_RESOURCE  resource = NULL;

    resource = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof(NETNAME_RESOURCE) );

    if (resource == NULL) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Resource allocation failed\n");
        return(NULL);
    }

    resource->ResourceHandle = ResourceHandle;

    return(resource);
} // NetNameAllocateResource

DWORD
NetNameCheckForCompObjRenameRecovery(
    IN PNETNAME_RESOURCE    Resource
    )

/*++

Routine Description:

    Using the Rename keys in the resource's GUID registry area, determine if a
    rename operation was interrupted. All operations in this function center
    around the Creating DC. If it is not available, we don't know the state of
    the rename since the name could have been changed but the change hasn't
    replicated to other DCs just yet. Consequently, the name will not go
    online until netname can resolve the outcome of the rename.

    If the object was renamed but the Name property wasn't updated, then the
    object is renamed to be consistent with the current value of the Name
    property.

Arguments:

    Resource - pointer to netname resource context block/structure...

Return Value:

    ERROR_SUCCESS if everything worked as expected.

--*/

{
    LPWSTR  originalName;
    LPWSTR  newName;
    DWORD   status;
    DWORD   functionStatus = ERROR_SUCCESS;
    DWORD   errorTextID;
    WCHAR   originalDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    WCHAR   newDollarName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    DWORD   paramInError;
    BOOL    renameObject = FALSE;

    USER_INFO_0 netUI0;

    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;

    //
    // read the rename keys from the regsitry
    //
    originalName = ResUtilGetSzValue( Resource->ResKey, PARAM_NAME__RENAMEORIGINALNAME );
    if ( originalName == NULL ) {
        status = GetLastError();
        if ( status != ERROR_FILE_NOT_FOUND ) {
            return status;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    newName = ResUtilGetSzValue( Resource->ResKey, PARAM_NAME__RENAMENEWNAME );
    if ( newName == NULL ) {
        status = GetLastError();
        if ( status != ERROR_FILE_NOT_FOUND ) {
            return status;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    if ( newName == NULL ) {
        //
        // never got far enough to do the rename. Clean up, if necessary, and
        // return success
        //
        if ( originalName ) {

            status = ClusterRegDeleteValue( Resource->ResKey, PARAM_NAME__RENAMEORIGINALNAME );
            if ( status != ERROR_SUCCESS ) {
                (NetNameLogEvent)(resourceHandle,
                                  LOG_WARNING,
                                  L"Failed to delete "
                                  PARAM_NAME__RENAMEORIGINALNAME
                                  L" from registry - status %1!u!\n",
                                  status);
            }

            LocalFree( originalName );
        }

        return status;
    }

    (NetNameLogEvent)(resourceHandle,
                      LOG_INFORMATION,
                      L"Previous rename operation interrupted; attempting recovery.\n");

    if ( originalName && newName ) {
        HRESULT hr;
        BOOL    originalNameObjectExists;
        BOOL    newNameObjectExists;

        //
        // have to find which version of the object is in the DS to determine
        // which name we're going to keep. Try the original name first
        //
        hr = IsComputerObjectInDS( resourceHandle,
                                   Resource->NodeName,
                                   originalName,
                                   Resource->Params.CreatingDC,
                                   &originalNameObjectExists,
                                   NULL,                        // don't need FQDN
                                   NULL);                       // don't need HostingDCName

        if ( SUCCEEDED( hr )) {
            if ( originalNameObjectExists ) {
                //
                // this means resmon croaked after writing the new name to the
                // registry but before the rename was issued. We do nothing in
                // this case.
                //
                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_INFORMATION,
                                  L"The computer account (%1!ws!) for this resource is correct.\n",
                                  originalName);
            }
            else {
                //
                // couldn't find an object with the original (old) name; try
                // with the new name.
                //
                hr = IsComputerObjectInDS( resourceHandle,
                                           Resource->NodeName,
                                           newName,
                                           Resource->Params.CreatingDC,
                                           &newNameObjectExists,
                                           NULL,                        // don't need FQDN
                                           NULL);                       // don't need HostingDCName

                if ( SUCCEEDED( hr )) {
                    if ( newNameObjectExists) {
                        //
                        // found the object with the new name so that means we
                        // renamed the object but resmon died before the Name
                        // property was updated. Make object name consistent
                        // with Name property
                        //
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_INFORMATION,
                                          L"The computer account is currently %1!ws!. It will be"
                                          L"renamed back to its original name (%2!ws!)\n",
                                          newName,
                                          originalName);

                        renameObject = TRUE;
                    }
                    else {
                        //
                        // this is bad; no object could be found for either
                        // the original or new name. Have to assume the admin
                        // deleted it.
                        //
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"The computer account for this resource cannot be found on DC "
                                          L"%1!ws! during rename recovery. The original name (%2!ws!) was "
                                          L"being renamed to %3!ws! and neither computer account "
                                          L"could be found. The resource cannot go online until the "
                                          L"object is recreated. This can be accomplished by disabling and "
                                          L"re-enabling Kerberos Authentication for this resource.\n",
                                          Resource->Params.CreatingDC,
                                          originalName,
                                          newName);

                        ClusResLogSystemEventByKey3(Resource->ResKey,
                                                    LOG_CRITICAL,
                                                    RES_NETNAME_ONLINE_RENAME_RECOVERY_MISSING_ACCOUNT,
                                                    Resource->Params.CreatingDC,
                                                    originalName,
                                                    newName);

                        functionStatus = ERROR_DS_OBJ_NOT_FOUND;
                    }
                }
                else {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"The AD search to find computer account %1!ws! on DC %2!ws! failed - "
                                      L"status %3!08X!. The computer account for this resource was in the "
                                      L"process of being renamed which did not complete. The account "
                                      L"was being renamed on DC %2!ws! which appears to be unavailable "
                                      L"or is preventing access in order to find the account. This DC must "
                                      L"be made available before this resource can go online in order "
                                      L"to reconcile the rename operation.\n",
                                      newName,
                                      Resource->Params.CreatingDC,
                                      hr);

                    ClusResLogSystemEventByKeyData2(Resource->ResKey,
                                                    LOG_CRITICAL,
                                                    RES_NETNAME_ONLINE_RENAME_DC_NOT_FOUND,
                                                    sizeof( hr ),
                                                    &hr,
                                                    newName,
                                                    Resource->Params.CreatingDC);

                    functionStatus = hr;
                }
            }
        }
        else {
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"The AD search to find computer account %1!ws! on DC %2!ws! failed - "
                              L"status %3!08X!. The computer account for this resource was in the "
                              L"process of being renamed which did not complete. The account was "
                              L"being renamed on DC %2!ws! which appears to be unavailable or is "
                              L"preventing access in order to find the account. This DC must be "
                              L"made available before this resource can go online in order to "
                              L"reconcile the rename operation.\n",
                              originalName,
                              Resource->Params.CreatingDC,
                              hr);

            ClusResLogSystemEventByKeyData2(Resource->ResKey,
                                            LOG_CRITICAL,
                                            RES_NETNAME_ONLINE_RENAME_DC_NOT_FOUND,
                                            sizeof( hr ),
                                            &hr,
                                            originalName,
                                            Resource->Params.CreatingDC);

            functionStatus = hr;
        }
    }
    else if ( originalName == NULL && newName ) {
        if ( ClRtlStrICmp( newName, Resource->Params.NetworkName ) != 0 ) {
            //
            // made it through RenameComputerObject but crashed before Name
            // property got stored. Change name of object back to Name
            // property
            //
            renameObject = TRUE;
        }
    }

    if ( renameObject ) {
        //
        // don't call RenameComputerObject to do the rename. In order to call
        // it, we'd need to delete the Rename keys prior to the call. If
        // resmon failed in between the delete and create of the keys, our
        // Rename state would be lost. We don't try to fix up the DnsHostName
        // attribute. It will be detected in Online that it is wrong and will
        // be fixed up there.
        //

        //
        // build the dollar sign names
        //
        originalDollarName[ COUNT_OF( originalDollarName ) - 1 ] = UNICODE_NULL;
        _snwprintf( originalDollarName, COUNT_OF( originalDollarName ) - 1, L"%ws$", newName );

        newDollarName[ COUNT_OF( newDollarName ) - 1 ] = UNICODE_NULL;
        _snwprintf( newDollarName, COUNT_OF( newDollarName ) - 1, L"%ws$", Resource->Params.NetworkName );

        (NetNameLogEvent)(resourceHandle,
                          LOG_INFORMATION,
                          L"Attempting rename of computer account %1!ws! to %2!ws! with DC %3!ws!.\n",
                          newName,
                          Resource->Params.NetworkName,
                          Resource->Params.CreatingDC);

        netUI0.usri0_name = newDollarName;
        status = NetUserSetInfo( Resource->Params.CreatingDC,
                                 originalDollarName,
                                 0,
                                 (LPBYTE)&netUI0,
                                 &paramInError);

        if ( status == NERR_Success ) {
            (NetNameLogEvent)(resourceHandle,
                              LOG_INFORMATION,
                              L"Renamed computer account from %1!ws! to %2!ws!.\n",
                              newName,
                              Resource->Params.NetworkName);
        } else {
            //
            // "now this is fine situation you've gotten us into, Ollie."
            //
            // Failed to rename. Bail out of routine, leaving the Rename keys
            // intact so it might work the next time once the problem
            // (probably access to the object) is fixed.
            //
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Failed to rename computer account %1!ws! to %2!ws! using DC %3!ws! "
                              L"(status %4!08X!).\n",
                              newName,
                              Resource->Params.NetworkName,
                              Resource->Params.CreatingDC,
                              status);

            ClusResLogSystemEventByKeyData3(Resource->ResKey,
                                            LOG_CRITICAL,
                                            RES_NETNAME_ONLINE_RENAME_RECOVERY_FAILED,
                                            sizeof( status ),
                                            &status,
                                            newName,
                                            Resource->Params.NetworkName,
                                            Resource->Params.CreatingDC);

            functionStatus = status;
            goto cleanup;
        }
    }

    //
    // clean up Rename keys from registry
    //
    status = ClusterRegDeleteValue( Resource->ResKey, PARAM_NAME__RENAMEORIGINALNAME );
    if ( status != ERROR_SUCCESS && status != ERROR_FILE_NOT_FOUND ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Failed to delete "
                          PARAM_NAME__RENAMEORIGINALNAME
                          L" from registry - status %1!u!\n",
                          status);
    }

    status = ClusterRegDeleteValue( Resource->ResKey, PARAM_NAME__RENAMENEWNAME );
    if ( status != ERROR_SUCCESS && status != ERROR_FILE_NOT_FOUND ) {
        (NetNameLogEvent)(resourceHandle,
                          LOG_WARNING,
                          L"Failed to delete "
                          PARAM_NAME__RENAMENEWNAME
                          L" from registry - status %1!u!\n",
                          status);
    }

cleanup:
    if ( newName != NULL ) {
        LocalFree( newName );
    }

    if ( originalName != NULL ) {
        LocalFree( originalName );
    }

    return functionStatus;

} // NetNameCheckForCompObjRenameRecovery

DWORD
NetNameGetParameters(
    IN  HKEY            ResourceKey,
    IN  HKEY            ParametersKey,
    IN  RESOURCE_HANDLE ResourceHandle,
    OUT PNETNAME_PARAMS ParamBlock,
    OUT DWORD *         ResDataSize,
    OUT DWORD  *        pdwFlags
    )
/*++

Routine Description:

    Reads the registry parameters for a netname resource.

Arguments:


    ParametersKey - An open handle to the resource's parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

    ParamBlock - A pointer to a buffer into which to place the private properties read
                 from the registry

    ResDataSize - A pointer to a buffer into which to place the number of bytes
                  pointed to by ParamBlock->ResourceData

    pdwFlags - a pointer to a DWORD that receives the flags data. Used to store the
               core resource flag.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

--*/
{
    DWORD   status;
    DWORD   bytesReturned;

    //
    // get the Flags parameter; hold core resource flag for cluster name
    //
    status = ResUtilGetDwordValue(ResourceKey,
                                  PARAM_NAME__FLAGS,
                                  pdwFlags,
                                  0);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Unable to read Flags parameter, error=%1!u!\n",
                          status);
        *pdwFlags = 0;
    }

    //
    // Read the private parameters. always free the existing storage areas
    //
    if ( ParamBlock->NetworkName != NULL ) {
        LocalFree( ParamBlock->NetworkName );
        ParamBlock->NetworkName = NULL;
    }

    ParamBlock->NetworkName = ResUtilGetSzValue( ParametersKey, PARAM_NAME__NAME );

    if (ParamBlock->NetworkName == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Unable to read NetworkName parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }

    status = ResUtilGetDwordValue(ParametersKey,
                                  PARAM_NAME__REMAP,
                                  &ParamBlock->NetworkRemap,
                                  PARAM_DEFAULT__REMAP);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Unable to read NetworkRemap parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }

    if ( ParamBlock->ResourceData != NULL ) {
        LocalFree( ParamBlock->ResourceData );
        ParamBlock->ResourceData = NULL;
    }

    //
    // it is not fatal if this resource isn't in the registry. It will only
    // have a value if RequireKerberos is set to one
    //
    status = ResUtilGetBinaryValue(ParametersKey,
                                   PARAM_NAME__RESOURCE_DATA,
                                   &ParamBlock->ResourceData,
                                   ResDataSize);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Unable to read ResourceData parameter, error=%1!u!\n",
                          status);
    }

    status = ResUtilGetDwordValue(ParametersKey,
                                  PARAM_NAME__REQUIRE_DNS,
                                  &ParamBlock->RequireDNS,
                                  PARAM_DEFAULT__REQUIRE_DNS);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Unable to read RequireDNS parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }

    status = ResUtilGetDwordValue(ParametersKey,
                                  PARAM_NAME__REQUIRE_KERBEROS,
                                  &ParamBlock->RequireKerberos,
                                  PARAM_DEFAULT__REQUIRE_KERBEROS);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Unable to read RequireKerberos parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }

#ifdef PASSWORD_ROTATION
    status = ResUtilGetBinaryValue(ParametersKey,
                                   PARAM_NAME__NEXT_UPDATE,
                                   (LPBYTE *)&ParamBlock->NextUpdate,
                                   &bytesReturned);

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Unable to read NextUpdate parameter, error=%1!u!\n",
                          status);
    }

    status = ResUtilGetDwordValue(ParametersKey,
                                  PARAM_NAME__UPDATE_INTERVAL,
                                  &ParamBlock->UpdateInterval,
                                  PARAM_DEFAULT__UPDATE_INTERVAL);

    if ( status != ERROR_SUCCESS) {
        (NetNameLogEvent)(ResourceHandle,
                          LOG_ERROR,
                          L"Unable to read UpdateInterval parameter, error=%1!u!\n",
                          status);
        goto error_exit;
    }
#endif  // PASSWORD_ROTATION

    if ( ParamBlock->CreatingDC != NULL ) {
        LocalFree( ParamBlock->CreatingDC );
        ParamBlock->CreatingDC = NULL;
    }

    //
    // it is not fatal if this resource isn't in the registry. It will only
    // have a value if RequireKerberos is set to one
    //
    ParamBlock->CreatingDC = ResUtilGetSzValue( ParametersKey, PARAM_NAME__CREATING_DC );

    if (ParamBlock->CreatingDC == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(ResourceHandle,
                          LOG_WARNING,
                          L"Unable to read CreatingDC parameter, error=%1!u!\n",
                          status);

        status = ERROR_SUCCESS;
    }

error_exit:

    if (status != ERROR_SUCCESS) {
        if (ParamBlock->NetworkName != NULL) {
            LocalFree( ParamBlock->NetworkName );
            ParamBlock->NetworkName = NULL;
        }

        if (ParamBlock->ResourceData != NULL) {
            LocalFree( ParamBlock->ResourceData );
            ParamBlock->ResourceData = NULL;
        }

        if ( ParamBlock->CreatingDC != NULL ) {
            LocalFree( ParamBlock->CreatingDC );
            ParamBlock->CreatingDC = NULL;
        }
    }

    return(status);
} // NetNameGetParameters

#define TRANSPORT_BLOCK_SIZE  4

DWORD
GrowBlock(
    PCHAR * Block,
    DWORD   UsedEntries,
    DWORD   BlockSize,
    PDWORD  FreeEntries
    )

/*++

Routine Description:

    Grow the specified block to hold more entries. Block might end up pointing
    to different chunk of memory as a result

Arguments:

    None

Return Value:

    None

--*/

{
    PVOID tmp;

    tmp = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                     (UsedEntries + TRANSPORT_BLOCK_SIZE) * BlockSize);

    if (tmp == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (*Block != NULL) {
        CopyMemory( tmp, *Block, UsedEntries * BlockSize );
        LocalFree( *Block );
    }

    *Block = tmp;
    *FreeEntries = TRANSPORT_BLOCK_SIZE;

    return ERROR_SUCCESS;
} // GrowBlock

DWORD
UpdateDomainMapEntry(
    PDOMAIN_ADDRESS_MAPPING DomainEntry,
    LPWSTR                  IpAddress,
    LPWSTR                  DomainName,
    LPWSTR                  ConnectoidName,
    DWORD                   DnsServerCount,
    PDWORD                  DnsServerList
    )

/*++

Routine Description:

    Update the specified DomainMap entry by making copies of the supplied
    parameters

Arguments:

    None

Return Value:

    None

--*/

{

    //
    // make copies of the address and domain and connectoid names
    //
    DomainEntry->IpAddress = ResUtilDupString ( IpAddress );
    DomainEntry->DomainName = ResUtilDupString( DomainName );
    DomainEntry->ConnectoidName = ResUtilDupString( ConnectoidName );

    if ( DomainEntry->IpAddress == NULL
         ||
         DomainEntry->DomainName == NULL
         ||
         DomainEntry->ConnectoidName == NULL )
    {
        if ( DomainEntry->IpAddress != NULL ) {
            LocalFree( DomainEntry->IpAddress );
        }

        if ( DomainEntry->DomainName != NULL ) {
            LocalFree( DomainEntry->DomainName );
        }

        if ( DomainEntry->ConnectoidName != NULL ) {
            LocalFree( DomainEntry->ConnectoidName );
        }

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // make a copy of the DNS server addresses to use when registering
    //
    if ( DnsServerCount > 0 ) {
        DomainEntry->DnsServerList = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                sizeof( IP4_ARRAY ) + 
                                                (sizeof(IP4_ADDRESS) * (DnsServerCount - 1)));

        if ( DomainEntry->DnsServerList == NULL ) {
            LocalFree( DomainEntry->IpAddress );
            LocalFree( DomainEntry->DomainName );
            LocalFree( DomainEntry->ConnectoidName );

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DomainEntry->DnsServerList->AddrCount = DnsServerCount;
        RtlCopyMemory(DomainEntry->DnsServerList->AddrArray,
                      DnsServerList,
                      DnsServerCount * sizeof( IP4_ADDRESS ));
    } else {
        DomainEntry->DnsServerList = NULL;
    }
        
    return ERROR_SUCCESS;
} // UpdateDomainMapEntry

DWORD
NetNameGetLists(
    IN   PNETNAME_RESOURCE          Resource,
    IN   PCLRTL_NET_ADAPTER_ENUM    AdapterEnum     OPTIONAL,
    OUT  LPWSTR **                  TransportList,
    OUT  LPDWORD                    TransportCount,
    OUT  PDOMAIN_ADDRESS_MAPPING *  DomainMapList   OPTIONAL,     
    OUT  LPDWORD                    DomainMapCount  OPTIONAL
    )

/*++

    Build a list of NetBT transports, IP addresses, and Domain names on which
    this name is dependent. The transport devices are used to register NETBios
    names while the IP addresses and Domain Names are used if the adapter
    associated with the IP address is the member of a DNS domain. Each IP
    address can have a different domain name associated with it hence the need
    to maintain a separate list.

--*/

{
    DWORD                       status;
    HRESOURCE                   providerHandle = NULL;
    HKEY                        providerKey = NULL;
    HRESENUM                    resEnumHandle = NULL;
    DWORD                       i;
    DWORD                       objectType;
    DWORD                       providerNameSize = 0;
    LPWSTR                      providerName = NULL;
    LPWSTR                      providerType = NULL;
    DWORD                       transportFreeEntries = 0;
    LPWSTR *                    transportList = NULL;
    DWORD                       transportCount = 0;
    LPWSTR                      transportName = NULL;
    HCLUSTER                    clusterHandle = NULL;
    DWORD                       enableNetbios;
    PDOMAIN_ADDRESS_MAPPING     domainMapList = NULL;
    DWORD                       domainMapCount = 0;
    DWORD                       domainMapFreeEntries = 0;
    LPWSTR                      ipAddress;
    PCLRTL_NET_ADAPTER_INFO     adapterInfo;
    PCLRTL_NET_INTERFACE_INFO   interfaceInfo;
    WCHAR                       primaryDomain[ DNS_MAX_NAME_BUFFER_LENGTH ] = { 0 };
    DWORD                       primaryDomainSize = DNS_MAX_NAME_BUFFER_LENGTH;

    //
    // get the node's primary domain name, if any. Domains with only NT4 DCs
    // won't necessarily have a PDN
    //
    if ( !GetComputerNameEx(ComputerNamePhysicalDnsDomain,
                            primaryDomain,
                            &primaryDomainSize))
    {
        status = GetLastError();
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_WARNING,
            L"Unable to get primary domain name, status %1!u!.\n",
            status
            );

        primaryDomainSize = 0;
    }
 
    //
    // Open a handle to the cluster.
    //
    clusterHandle = OpenCluster(NULL);

    if (clusterHandle == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to open handle to cluster, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Enumerate the dependencies to find the IP Addresses
    //
    resEnumHandle = ClusterResourceOpenEnum(
                        Resource->ClusterResourceHandle,
                        CLUSTER_RESOURCE_ENUM_DEPENDS
                        );

    if (resEnumHandle == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to open enum handle for this resource, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // enum all the dependent resources for this netname resource
    //

    for (i=0; ;i++) {
        status = ClusterResourceEnum(
                     resEnumHandle,
                     i,
                     &objectType,
                     providerName,
                     &providerNameSize
                     );

        if (status == ERROR_NO_MORE_ITEMS) {
            break;
        }

        if ((status == ERROR_MORE_DATA) ||
            ((status == ERROR_SUCCESS) && (providerName == NULL))) {
            if (providerName != NULL) {
                LocalFree( providerName );
            }

            providerNameSize++;

            providerName = LocalAlloc( LMEM_FIXED, providerNameSize * sizeof(WCHAR) );

            if (providerName == NULL) {
                (NetNameLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Unable to allocate memory.\n"
                    );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto error_exit;
            }

            status = ClusterResourceEnum(
                         resEnumHandle,
                         i,
                         &objectType,
                         providerName,
                         &providerNameSize
                         );

            ASSERT(status != ERROR_MORE_DATA);
        }

        if (status != ERROR_SUCCESS) {
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to enumerate resource dependencies, status %1!u!.\n",
                status
                );
            goto error_exit;
        }

        //
        // Open the resource
        //
        providerHandle = OpenClusterResource(clusterHandle, providerName);

        if (providerHandle == NULL) {
            status = GetLastError();
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to open handle to provider resource %1!ws!, status %2!u!.\n",
                providerName,
                status
                );
            goto error_exit;
        }

        //
        // Figure out what type it is.
        //
        providerKey = GetClusterResourceKey(providerHandle, KEY_READ);

        status = GetLastError();

        CloseClusterResource(providerHandle);

        if (providerKey == NULL) {
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to open provider resource key, status %1!u!.\n",
                status
                );
            goto error_exit;
        }

        providerType = ResUtilGetSzValue(providerKey, CLUSREG_NAME_RES_TYPE);

        if (providerType == NULL) {
            status = GetLastError();
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to get provider resource type, status %1!u!.\n",
                status
                );
            goto error_exit;
        }

        //
        // make sure it's an IP address resource
        //

        if (wcscmp(providerType, IP_ADDRESS_RESOURCETYPE_NAME) == 0) {
            HKEY parametersKey;

            //
            // Open the provider's parameters key.
            //
            status = ClusterRegOpenKey(
                         providerKey,
                         CLUSREG_KEYNAME_PARAMETERS,
                         KEY_READ,
                         &parametersKey
                         );

            if (status != ERROR_SUCCESS) {
                (NetNameLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Unable to open provider's parameters key, status %1!u!.\n",
                    status
                    );
                goto error_exit;
            }

            if ( ARGUMENT_PRESENT( DomainMapList )) {
                ASSERT( ARGUMENT_PRESENT( DomainMapCount ));
                ASSERT( ARGUMENT_PRESENT( AdapterEnum ));

                //
                // build a list of IP address strings that we can use for
                // building the appropriate DNS records
                //
                ipAddress = ResUtilGetSzValue( parametersKey, CLUSREG_NAME_IPADDR_ADDRESS );

                if (ipAddress == NULL) {
                    status = GetLastError();
                    ClusterRegCloseKey(parametersKey);
                    (NetNameLogEvent)(
                        Resource->ResourceHandle,
                        LOG_ERROR,
                        L"Unable to get provider's Address value, status %1!u!.\n",
                        status
                        );
                    goto error_exit;
                }

                //
                // find the corresponding adapter/interface over which packets
                // for this IP address would be sent. Get the domain name (if
                // any) from the adapter info.
                //
                adapterInfo = ClRtlFindNetAdapterByInterfaceAddress(
                                  AdapterEnum,
                                  ipAddress,
                                  &interfaceInfo);

                if ( adapterInfo != NULL ) {
                    LPWSTR deviceGuid;
                    DWORD guidLength;

                    //
                    // argh. DeviceGuid is not bracketed by braces which the
                    // following Dns routines require. Dup the string and make
                    // it all nice and pretty for DNS.
                    //
                    guidLength = wcslen( adapterInfo->DeviceGuid );
                    deviceGuid = LocalAlloc( LMEM_FIXED, (guidLength + 3) * sizeof(WCHAR) );

                    if ( deviceGuid == NULL ) {
                        status = GetLastError();

                        (NetNameLogEvent)(
                            Resource->ResourceHandle,
                            LOG_ERROR,
                            L"Unable to allocate memory.\n"
                            );
                        goto error_exit;
                    }

                    deviceGuid[0] = L'{';
                    wcscpy( &deviceGuid[1], adapterInfo->DeviceGuid );
                    wcscpy( &deviceGuid[ guidLength + 1 ],  L"}" );

                    //
                    // see if dynamic DNS is enabled for this adapter and that
                    // they are DNS servers associated with this adapter. Bail
                    // if not. This check corresponds to the "register this
                    // connection's addresses in DNS" checkbox in the DNS
                    // proppage in the advanced TCP properties
                    //
                    if ( DnsIsDynamicRegistrationEnabled( deviceGuid ) &&
                         adapterInfo->DnsServerCount > 0)
                    {

                        //
                        // set up a mapping with the Primary Domain Name if
                        // apropriate
                        //
                        if ( primaryDomainSize != 0 ) {

                            if (domainMapFreeEntries == 0) {

                                status = GrowBlock((PCHAR *)&domainMapList,
                                                   domainMapCount,
                                                   sizeof( *domainMapList ),
                                                   &domainMapFreeEntries);

                                if ( status != ERROR_SUCCESS) {
                                    (NetNameLogEvent)(
                                        Resource->ResourceHandle,
                                        LOG_ERROR,
                                        L"Unable to allocate memory.\n"
                                        );
                                    goto error_exit;
                                }
                            }

                            //
                            // make copies of the address and name
                            //
                            status = UpdateDomainMapEntry(&domainMapList[ domainMapCount ],
                                                          ipAddress,
                                                          primaryDomain,
                                                          adapterInfo->ConnectoidName,
                                                          adapterInfo->DnsServerCount,
                                                          adapterInfo->DnsServerList);

                            if ( status != ERROR_SUCCESS ) {
                                (NetNameLogEvent)(
                                    Resource->ResourceHandle,
                                    LOG_ERROR,
                                    L"Unable to allocate memory.\n"
                                    );
                                goto error_exit;
                            }

                            domainMapCount++;
                            domainMapFreeEntries--;
                        }

                        //
                        // now check if we should care about the adapter
                        // specific name. It must be different from the
                        // primary domain name and have the "use this
                        // connection's DNS suffix" checkbox checked.
                        //
                        if ( DnsIsAdapterDomainNameRegistrationEnabled( deviceGuid ) &&
                             adapterInfo->AdapterDomainName != NULL &&
                             ClRtlStrICmp(adapterInfo->AdapterDomainName, primaryDomain) != 0)
                        {

                            if (domainMapFreeEntries == 0) {

                                status = GrowBlock((PCHAR *)&domainMapList,
                                                   domainMapCount,
                                                   sizeof( *domainMapList ),
                                                   &domainMapFreeEntries);

                                if ( status != ERROR_SUCCESS) {
                                    (NetNameLogEvent)(
                                        Resource->ResourceHandle,
                                        LOG_ERROR,
                                        L"Unable to allocate memory.\n"
                                        );
                                    goto error_exit;
                                }
                            }

                            //
                            // make copies of the address and name
                            //
                            status = UpdateDomainMapEntry(&domainMapList[ domainMapCount ],
                                                          ipAddress,
                                                          adapterInfo->AdapterDomainName,
                                                          adapterInfo->ConnectoidName,
                                                          adapterInfo->DnsServerCount,
                                                          adapterInfo->DnsServerList);

                            if ( status != ERROR_SUCCESS ) {
                                (NetNameLogEvent)(
                                    Resource->ResourceHandle,
                                    LOG_ERROR,
                                    L"Unable to allocate memory.\n"
                                    );
                                goto error_exit;
                            }

                            domainMapCount++;
                            domainMapFreeEntries--;
                        } // if register adapter domain is true and one has been specified

                    } // if dynamic DNS is enabled for this adapter

                    LocalFree( deviceGuid );
                } // if we found the matching adapter in our adapter info

                LocalFree( ipAddress );
            } // if DomainMapList present

            //
            // Figure out if this resource supports NetBios.
            //
            status = ResUtilGetDwordValue(
                         parametersKey,
                         CLUSREG_NAME_IPADDR_ENABLE_NETBIOS,
                         &enableNetbios,
                         1
                         );

            if (status != ERROR_SUCCESS) {
                ClusterRegCloseKey(parametersKey);
                (NetNameLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Unable to get provider's EnableNetbios value, status %1!u!.\n",
                    status
                    );
                goto error_exit;
            }

            if (enableNetbios) {
                HKEY nodeParametersKey;

                //
                // Open the provider's node-specific parameters key.
                //
                status = ClusterRegOpenKey(
                             parametersKey,
                             Resource->NodeId,
                             KEY_READ,
                             &nodeParametersKey
                             );

                ClusterRegCloseKey(parametersKey);

                if (status != ERROR_SUCCESS) {
                    (NetNameLogEvent)(
                        Resource->ResourceHandle,
                        LOG_ERROR,
                        L"Unable to open provider's node parameters key, status %1!u!.\n",
                        status
                        );
                    goto error_exit;
                }

                transportName = ResUtilGetSzValue(
                                            nodeParametersKey,
                                            L"NbtDeviceName"
                                            );

                status = GetLastError();

                ClusterRegCloseKey(nodeParametersKey);

                if (transportName == NULL) {
                    (NetNameLogEvent)(
                        Resource->ResourceHandle,
                        LOG_ERROR,
                        L"Unable to get provider's transport name, status %1!u!.\n",
                        status
                        );
                    goto error_exit;
                }

                if (transportFreeEntries == 0) {

                    status = GrowBlock((PCHAR *)&transportList,
                                       transportCount,
                                       sizeof( *transportList ),
                                       &transportFreeEntries);

                    if ( status != ERROR_SUCCESS) {
                        (NetNameLogEvent)(
                            Resource->ResourceHandle,
                            LOG_ERROR,
                            L"Unable to allocate memory.\n"
                            );
                        goto error_exit;
                    }
                }

                transportList[transportCount] = transportName;
                transportName = NULL;
                transportCount++;
                transportFreeEntries--;
            }
            else {
                ClusterRegCloseKey(parametersKey);
            }
        }

        ClusterRegCloseKey(providerKey);
        providerKey = NULL;
        LocalFree( providerType );
        providerType = NULL;
    }

    if (providerName != NULL) {
        LocalFree( providerName );
        providerName = NULL;
    }

    CloseCluster(clusterHandle);
    ClusterResourceCloseEnum(resEnumHandle);

    *TransportList = transportList;
    *TransportCount = transportCount;

    if ( ARGUMENT_PRESENT( DomainMapList )) {
        *DomainMapList = domainMapList;
        *DomainMapCount = domainMapCount;
    }

    return(ERROR_SUCCESS);

error_exit:

    if (transportList != NULL) {
        ASSERT(transportCount > 0);

        while (transportCount > 0) {
            LocalFree( transportList[--transportCount] );
        }

        LocalFree( transportList );
    }

    if ( domainMapList != NULL ) {
        while (domainMapCount--) {
            if ( domainMapList[ domainMapCount ].IpAddress != NULL ) {
                LocalFree( domainMapList[ domainMapCount ].IpAddress );
            }
            if ( domainMapList[ domainMapCount ].DomainName != NULL ) {
                LocalFree( domainMapList[ domainMapCount ].DomainName );
            }
            if ( domainMapList[ domainMapCount ].DnsServerList != NULL ) {
                LocalFree( domainMapList[ domainMapCount ].DnsServerList );
            }
        }
        LocalFree( domainMapList );
    }

    if (clusterHandle != NULL) {
        CloseCluster(clusterHandle);
    }

    if (resEnumHandle != NULL) {
        ClusterResourceCloseEnum(resEnumHandle);
    }

    if (providerName != NULL) {
        LocalFree( providerName );
    }

    if (providerKey != NULL) {
        ClusterRegCloseKey(providerKey);
    }

    if (providerType != NULL) {
        LocalFree( providerType );
    }

    if (transportName != NULL) {
        LocalFree( transportName );
    }

    return(status);

} // NetNameGetLists


void
FreeDNSRecordpName(PDNS_RECORDW DnsRecord)
{

    PDNS_RECORDW Next;

    //
    // Rui: 02/24/2002
    // BUG: 553148. DnsRecord->pName is allocated using LocalAlloc(), 
    // (DnsRecordBuild_W()). While DnsRecordListFree() uses HeapFree().
    // This fix is a work around. MSDN suggests using DnsQuery(), instead of
    // unpublished DnsRecordBuild_W().
    //
    Next = DnsRecord;
    while (Next != NULL) 
    {
        if (Next->pName != NULL)
        {
            LocalFree(Next->pName);
        }
        Next->pName = NULL;
        Next = Next->pNext;
    }
}


void
FreeDNSRecordPTRpNameHost(PDNS_RECORDW DnsRecord)
{

    PDNS_RECORDW Next;

    //
    // Rui: 02/24/2002
    // BUG: 553148. DnsRecord->Data.PTR.pNameHost is allocated using LocalAlloc(), 
    // (DnsRecordBuild_W()). While DnsRecordListFree() uses HeapFree().
    // This fix is a work around. MSDN suggests using DnsQuery(), instead of
    // unpublished DnsRecordBuild_W().
    //
    Next = DnsRecord;
    while (Next != NULL) 
    {

        if ( Next->Data.PTR.pNameHost != NULL )
        {
            LocalFree( Next->Data.PTR.pNameHost );
        }
        Next->Data.PTR.pNameHost = NULL;
        Next = Next->pNext;
    }
}


VOID
NetNameCleanupDnsLists(
    IN  PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    Clean up the DNS list structures associated with the resource.

Arguments:

    Resource - pointer to internal resource struct

Return Value:

    None

--*/

{
    PDNS_LISTS  dnsLists;
    DNS_STATUS  dnsStatus;
    PDNS_RECORD dnsRecord;

    dnsLists = Resource->DnsLists;
    while ( Resource->NumberOfDnsLists-- ) {

#if 0
        //
        // we have to free the args we handed to the DNS record build routines
        //
        dnsRecord = dnsLists->A_RRSet.pFirstRR;
        while ( dnsRecord != NULL ) {
            LocalFree( dnsRecord->pName );
            dnsRecord->pName = NULL;

            dnsRecord = dnsRecord->pNext;
        }

        dnsRecord = dnsLists->PTR_RRSet.pFirstRR;
        while ( dnsRecord != NULL ) {
            LocalFree( dnsRecord->Data.PTR.pNameHost );
            dnsRecord->Data.PTR.pNameHost = NULL;

            dnsRecord = dnsRecord->pNext;
        }
#endif

        //
        // have DNSAPI clean up its structs
        //

        //
        // BUG: 553148. Rui, 02/24/2002.
        //
        FreeDNSRecordpName(dnsLists->PTR_RRSet.pFirstRR);
        FreeDNSRecordPTRpNameHost(dnsLists->PTR_RRSet.pFirstRR);
        DnsRecordListFree( dnsLists->PTR_RRSet.pFirstRR, DnsFreeRecordListDeep );

        FreeDNSRecordpName(dnsLists->A_RRSet.pFirstRR);
        DnsRecordListFree( dnsLists->A_RRSet.pFirstRR, DnsFreeRecordListDeep );

        //
        // free server address info and connectoid name string
        //
        if ( dnsLists->DnsServerList != NULL ) {
            LocalFree( dnsLists->DnsServerList );
        }

        if ( dnsLists->ConnectoidName != NULL ) {
            LocalFree( dnsLists->ConnectoidName );
        }

        ++dnsLists;
    }
    Resource->NumberOfDnsLists = 0;

    if ( Resource->DnsLists != NULL ) {
        LocalFree( Resource->DnsLists );
        Resource->DnsLists = NULL;
    }

} // NetNameCleanupDnsLists

VOID
NetNameOfflineNetbios(
    IN PNETNAME_RESOURCE Resource
    )

/*++

Routine Description:

    do final clean up when taking this resource offline.

Arguments:

    Resource - A pointer to the NETNAME_RESOURCE block for this resource.

Returns:

    None.

--*/

{
    DWORD           status;
    DWORD           i;
    LPWSTR *        transportList = NULL;
    DWORD           transportCount = 0;
    LPWSTR          domainName = NULL;

    //
    // Now we can finally do the real work of taking the netbios name
    // offline. Get the domain name so we can deregister the extra credentials
    // with kerberos
    //
    if ( Resource->Params.CreatingDC ) {
        domainName = wcschr( Resource->Params.CreatingDC, L'.' );
        if ( domainName != NULL ) {
            ++domainName;
        }
    }

    DeleteAlternateComputerName(Resource->Params.NetworkName,
                                domainName,
                                Resource->NameHandleList,
                                Resource->NameHandleCount,
                                Resource->ResourceHandle);

    if (Resource->NameHandleList != NULL) {
        LocalFree( Resource->NameHandleList );
        Resource->NameHandleList = NULL;
        Resource->NameHandleCount = 0;
    }

    //
    // Remove the cluster service type bits
    //
    status = NetNameGetLists(Resource,
                             NULL,
                             &transportList,
                             &transportCount,
                             NULL,
                             NULL);

    if (status == ERROR_SUCCESS) {
        DWORD serviceBits;

        serviceBits = SV_TYPE_CLUSTER_VS_NT | SV_TYPE_CLUSTER_NT;

        for (i=0; i<transportCount; i++) {
            I_NetServerSetServiceBitsEx(NULL,                          // target server
                                        Resource->Params.NetworkName,  // emulated server name
                                        transportList[i],              // transport name
                                        serviceBits,                   // bits of interest
                                        0,                             // bits
                                        TRUE );                        // Update immediately
        }

        while (transportCount > 0) {
            LocalFree( transportList[--transportCount] );
        }

        LocalFree( transportList );
    }
} // NetNameOfflineNetbios


DWORD
NetNameOnlineThread(
    IN PCLUS_WORKER Worker,
    IN PNETNAME_RESOURCE Resource
    )
/*++

Routine Description:

    Brings a network name resource online.

Arguments:

    Worker - Supplies the worker structure

    Resource - A pointer to the NETNAME_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    DWORD                    status;
    CLUSTER_RESOURCE_STATE   finalState = ClusterResourceFailed;
    LPWSTR *                 transportList = NULL;
    DWORD                    transportCount = 0;
    PDOMAIN_ADDRESS_MAPPING  domainMapList = NULL;
    DWORD                    domainMapCount = 0;
    DWORD                    i;
    DWORD                    dwFlags;
    PCLRTL_NET_ADAPTER_ENUM  adapterEnum = NULL;
    RESOURCE_STATUS          resourceStatus;
    DWORD                    serviceBits;

    ResUtilInitializeResourceStatus( &resourceStatus );

    ASSERT(Resource->State == ClusterResourceOnlinePending);

    (NetNameLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"Bringing resource online...\n"
        );

    //
    // If this is the first resource to be brought online then spin up the DNS
    // check thread at this point
    //
    NetNameAcquireResourceLock();
    if ( NetNameWorkerThread == NULL ) {
        NetNameWorkerThread = CreateThread(NULL,
                                              0,
                                              NetNameWorker,
                                              NULL,
                                              0,
                                              NULL);

        if ( NetNameWorkerThread == NULL ) {
            status = GetLastError();
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Can't start Netname worker thread. status = %1!u!\n",
                status
                );
            NetNameReleaseResourceLock();
            goto error_exit;
        }
    }
    NetNameReleaseResourceLock();

    //
    // initialize the checkpoint var that is used to communicate back to
    // resmon that we're still working on bringing the resource online
    //
    Resource->StatusCheckpoint = 0;

    //
    // notify the worker thread that we're bringing a name online.
    //
    SetEvent( NetNameWorkerPendingResources );

    //
    // This is an old comment but I'm leaving it in. Netname does handle set
    // private props but there are other issues.
    //
    // This read must continue to be here as long as adminstrative agents
    // (like cluster.exe) continue to write to the registry behind the back of
    // the resource dll. We need to migrate to writing all registry parameters
    // via the SET_COMMON/PRIVATE_PROPERTIES control function. That way,
    // resource dll's can read their parameters in the open (allowing for the
    // possibility that they may fail), and then update the parameters
    // whenever the SET_PRIVATE_PROPERTIES control code is delivered and
    // (optionally) on the SET_COMMON_PROPERTIES as needed.
    //
    // Fetch our parameters from the registry.
    //
    status = NetNameGetParameters(
                Resource->ResKey,
                Resource->ParametersKey,
                Resource->ResourceHandle,
                &Resource->Params,
                &Resource->ResDataSize,
                &Resource->dwFlags
                );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    if ( Resource->Params.NetworkName == NULL ) {
        status = ERROR_RESOURCE_NOT_FOUND;
        goto error_exit;
    }

    //
    // if we just went through an upgrade and this resource is a provider for
    // an MSMQ resource, then we need to force kerb support
    //
    if ( Resource->CheckForKerberosUpgrade ) {
        Resource->CheckForKerberosUpgrade = FALSE;

        status = UpgradeMSMQDependentNetnameToKerberos( Resource );
        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)( Resource->ResourceHandle,
                               LOG_ERROR,
                               L"Unable to set RequireKerberos property after an upgrade - status %1!u!. "
                               L"This resource requires that the RequireKerberos property be set to "
                               L"one in order for its dependent MSMQ resource to be successfully "
                               L"brought online.\n",
                               status);

            ClusResLogSystemEventByKeyData(Resource->ResKey,
                                           LOG_CRITICAL,
                                           RES_NETNAME_UPGRADE_TO_KERBEROS_SUPPORT_FAILED,
                                           sizeof( status ),
                                           &status);

            goto error_exit;
        }
    }

    //
    // check to see if recovery from a half-baked rename is needed
    //
    if ( Resource->Params.CreatingDC ) {
        status = NetNameCheckForCompObjRenameRecovery( Resource );
        if ( status != ERROR_SUCCESS ) {
            goto error_exit;
        }
    }

    //
    // Ensure that the specified network name is not the same as the
    // computername of this node.
    //
    if ( lstrcmpiW(Resource->Params.NetworkName, Resource->NodeName) == 0 ) {
        ClusResLogSystemEventByKey1(Resource->ResKey,
                                    LOG_CRITICAL,
                                    RES_NETNAME_DUPLICATE,
                                    Resource->Params.NetworkName);
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"The specified network name is the same as the local computername.\n"
            );
        status = ERROR_DUP_NAME;
        goto error_exit;
    }

    //
    // get the adapter configuration and determine which adapters are
    // participating in a DNS domain
    //

    adapterEnum = ClRtlEnumNetAdapters();

    if ( adapterEnum == NULL ) {

        status = GetLastError();
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Couldn't acquire network adapter configuration, status %1!u!\n",
            status
            );

        goto error_exit;
    }

    //
    // Search our dependencies and return the list of NBT devices to which we
    // need to bind the server. Also get the IP addresses this resource
    // depends on so we can publish them in DNS.
    //
    status = NetNameGetLists(
                 Resource,
                 adapterEnum,
                 &transportList,
                 &transportCount,
                 &domainMapList,
                 &domainMapCount
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // transportCount could be zero in the case where NetBIOS names are turned
    // off for all IP addr resources. In any case, a network name must have at
    // least one IP address associated with it.
    //
    if (( transportCount + domainMapCount ) == 0 ) {
        ClusResLogSystemEventByKey(Resource->ResKey,
                                   LOG_CRITICAL,
                                   RES_NETNAME_NO_IP_ADDRESS);
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"This resource is configured such that its name will not be registered "
            L"with a name service or it could not be registered with either "
            L"NetBIOS or a DNS name server at this time. This condition prevents "
            L"the resource from changing its state to online.\n"
            );
        status = ERROR_DEPENDENCY_NOT_FOUND;
        goto error_exit;
    }

    if ( transportCount > 0 ) {
        //
        // Allocate an array to hold the handles for the registered name
        //
        Resource->NameHandleList = LocalAlloc(
                                       LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(HANDLE) * transportCount
                                       );

        if (Resource->NameHandleList == NULL) {
            (NetNameLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to allocate memory for name registration.\n"
                );
            goto error_exit;
        }
    }

    Resource->NameHandleCount = transportCount;

    //
    // if we have DNS related data from a previous online, free it up now
    // since AddAlternateComputerName will be reconstructing with current
    // info. DnsLists is synchronized with offline worker thread since
    // offline doesn't report offline complete until RemoveDnsRecords has
    // completed.
    //
    if ( Resource->DnsLists != NULL ) {
        NetNameCleanupDnsLists( Resource );
    }

    //
    // Add the name/transport combinations.
    //
    status = AddAlternateComputerName(
                 Worker,
                 Resource,
                 transportList,
                 transportCount,
                 domainMapList,
                 domainMapCount
                 );

    if (status != NERR_Success) {
        NetNameOfflineNetbios( Resource );

        //
        // don't need to synchronize with worker thread since it only checks
        // online resources
        //
        NetNameCleanupDnsLists( Resource );
        goto error_exit;
    }

    finalState = ClusterResourceOnline;

    //
    // set the appropriate service type bit(s) for this name. core cluster
    // name resource additionally gets the cluster bit.
    //
    serviceBits = SV_TYPE_CLUSTER_VS_NT;
    if (Resource->dwFlags & CLUS_FLAG_CORE) {
        serviceBits |= SV_TYPE_CLUSTER_NT;
    }
        
    for (i=0; i<transportCount; i++) {
        I_NetServerSetServiceBitsEx(NULL,                   // Local server serv
                                    Resource->Params.NetworkName,
                                    transportList[i],       //transport name
                                    serviceBits,
                                    serviceBits,
                                    TRUE );                 // Update immediately
    }

    (NetNameLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"Network Name %1!ws! is now online\n",
        Resource->Params.NetworkName
        );

error_exit:

    if ( status != ERROR_SUCCESS ) {
        if ( Resource->NameHandleList != NULL ) {
            LocalFree( Resource->NameHandleList );
            Resource->NameHandleList = NULL;
            Resource->NameHandleCount = 0;
        }
    }

    if (transportList != NULL) {
        ASSERT(transportCount > 0);

        while (transportCount > 0) {
            LocalFree( transportList[--transportCount] );
        }

        LocalFree( transportList );
    }

    if (domainMapList != NULL) {

        while (domainMapCount--) {
            LocalFree( domainMapList[domainMapCount].IpAddress );
            LocalFree( domainMapList[domainMapCount].DomainName );
            LocalFree( domainMapList[domainMapCount].ConnectoidName );

            if ( domainMapList[domainMapCount].DnsServerList != NULL ) {
                LocalFree( domainMapList[domainMapCount].DnsServerList );
            }
        }

        LocalFree( domainMapList );
    }

    if ( adapterEnum != NULL ) {
        ClRtlFreeNetAdapterEnum( adapterEnum );
    }

    ASSERT(Resource->State == ClusterResourceOnlinePending);

    //
    // set the final state accordingly. We acquire the lock to synch with the
    // worker thread
    //
    NetNameAcquireResourceLock();

    Resource->State = finalState;
    resourceStatus.ResourceState = finalState;

    NetNameReleaseResourceLock();

    (NetNameSetResourceStatus)( Resource->ResourceHandle, &resourceStatus );

    return(status);

} // NetNameOnlineThread



DWORD
WINAPI
NetNameOfflineWorker(
    IN PNETNAME_RESOURCE    Resource,
    IN BOOL                 Terminate,
    IN PCLUS_WORKER         Worker      OPTIONAL
    )

/*++

Routine Description:

    Internal offline routine for Network Name resource. This routine is called
    by both the offline and terminate routines. Terminate calls it directly
    with Worker set to NULL, while Offline spins a worker thread and then has
    the worker thread call it.

    If terminate is true, we bag any long running operations like removing DNS
    records. We'll figure out how to deal with the resource's carcass the next
    time it is brought online.

 Arguments:

    Resource - supplies the resource it to be taken offline

    Terminate - indicates whether call is result of NetNameTerminate or NetNameOffline

    Worker - pointer to cluster work thread struct. NULL if called by Terminate

Return Value:

    None.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    nameChanged = FALSE;

    //
    // Terminate any pending thread if it is running.
    //
    if ( Terminate ) {
        ClusWorkerTerminate(&(Resource->PendingThread));
    }

    //
    // Synchronize offline/terminate and worker thread
    //
    NetNameAcquireResourceLock();

    if (Resource->State != ClusterResourceOffline) {
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_INFORMATION,
            L"Offline of resource continuing...\n"
            );

        Resource->State = ClusterResourceOfflinePending;

        NetNameOfflineNetbios( Resource );

        if ( Resource->RefCount > 1 ) {
            //
            // DNS registration is still in progress. If we don't synchronize
            // with the worker thread, then it is possible to delete the
            // resource while the worker routine still had a pointer to the
            // freed memory. kaboom....
            //
            (NetNameLogEvent)(Resource->ResourceHandle,
                              LOG_INFORMATION,
                              L"Waiting for Worker thread operation to finish\n");

            status = ERROR_IO_PENDING;
        }

        if ( status == ERROR_SUCCESS ) {
            if ( !Terminate ) {
                //
                // If the name was changed while we were still online, do the
                // appropriate clean up after we release the netname lock. We
                // have to maintain a reference since a delete can be issued
                // after the resource has gone offline.
                //
                if ( Resource->NameChangedWhileOnline ) {
                    ++Resource->RefCount;
                    nameChanged = TRUE;
                    Resource->NameChangedWhileOnline = FALSE;
                }
            }

            Resource->State = ClusterResourceOffline;
        }
    }
    else {
        (NetNameLogEvent)(
            Resource->ResourceHandle,
            LOG_INFORMATION,
            L"Resource is already offline.\n"
            );
    }

    //
    // release VS token
    //
    if ( Resource->VSToken ) {
        CloseHandle( Resource->VSToken );
        Resource->VSToken = NULL;
    }

    NetNameReleaseResourceLock();

    if ( !Terminate ) {
        RESOURCE_STATUS resourceStatus;

        if ( nameChanged ) {
            //
            // we're not terminating the resource and we need to do some
            // cleanup work. Before each major operation, check if we need to
            // get out due to our Terminate routine being called.
            //
            if ( !ClusWorkerCheckTerminate( Worker )) {
                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_INFORMATION,
                                  L"Attempting removal of DNS records\n");

                RemoveDnsRecords( Resource );
            }

            NetNameAcquireResourceLock();

            --Resource->RefCount;

            ASSERT( Resource->RefCount >= 0 );
            if ( Resource->RefCount == 0 ) {
                NetNameReleaseResource( Resource );
            }

            NetNameReleaseResourceLock();
        }

        //
        // report we're offline here; any sooner and RemoveDnsRecords and the
        // online thread could collide and cause bad things to happen
        //
        ResUtilInitializeResourceStatus( &resourceStatus );
        resourceStatus.ResourceState = ClusterResourceOffline;
        (NetNameSetResourceStatus)( Resource->ResourceHandle, &resourceStatus );

        (NetNameLogEvent)(Resource->ResourceHandle,
                          LOG_INFORMATION,
                          L"Resource is now offline\n");
    }

    return status;

}  // NetNameOfflineWorker

DWORD
NetNameOfflineThread(
    IN PCLUS_WORKER Worker,
    IN PNETNAME_RESOURCE Resource
    )

/*++

Routine Description:

    stub routine to call common offline routine used by both terminate and
    offline

Arguments:

    Worker - pointer to cluster work thread

    Resource - pointer to netname resource context block that is going offline

Return Value:

    None

--*/

{
    DWORD   status;

    //
    // notify the worker thread that we're bringing a name offline.
    //
    SetEvent( NetNameWorkerPendingResources );

    status = NetNameOfflineWorker( Resource, FALSE, Worker );

    return status;

} // NetNameOfflineThread

DWORD
RemoveDependentIpAddress(
    PNETNAME_RESOURCE   Resource,
    LPWSTR              DependentResourceId
    )

/*++

Routine Description:

    A dependent IP address resource is being removed. Delete the associated
    DNS records for this address and the netbt device.

Arguments:

    Resource - pointer to private netname resource data

    DependentResourceId - pointer to Unicode string of dependent resource's name

Return Value:

    None

--*/

{
    HCLUSTER        clusterHandle;
    HRESOURCE       ipResourceHandle = NULL;
    RESOURCE_HANDLE resourceHandle = Resource->ResourceHandle;
    DWORD           status;
    HKEY            ipResourceKey;
    HKEY            parametersKey;
    LPWSTR          reverseName;
    PDNS_LISTS      dnsList;
    DWORD           numberOfDnsLists = Resource->NumberOfDnsLists;
    LPWSTR          ipAddressBuffer;
    IP4_ADDRESS     ipAddress;
    UNICODE_STRING  ipAddressStringW;
    ANSI_STRING     ipAddressStringA;

    //
    // work our way through the miriad of Cluster APIs to read the IP address
    // resource's address from the registry
    //
    clusterHandle = OpenCluster(NULL);
    if (clusterHandle != NULL) {
        ipResourceHandle = OpenClusterResource( clusterHandle, DependentResourceId );
        CloseCluster( clusterHandle );

        if ( ipResourceHandle != NULL ) {
            ipResourceKey = GetClusterResourceKey( ipResourceHandle, KEY_READ );
            CloseClusterResource( ipResourceHandle );

            if ( ipResourceKey != NULL ) {
                status = ClusterRegOpenKey(ipResourceKey,
                                           CLUSREG_KEYNAME_PARAMETERS,
                                           KEY_READ,
                                           &parametersKey);

                ClusterRegCloseKey( ipResourceKey );

                if (status == ERROR_SUCCESS) {
                    ipAddressBuffer = ResUtilGetSzValue( parametersKey, CLUSREG_NAME_IPADDR_ADDRESS );
                    ClusterRegCloseKey( parametersKey );

                    if (ipAddressBuffer == NULL) {
                        status = GetLastError();
                        (NetNameLogEvent)(resourceHandle,
                                          LOG_ERROR,
                                          L"Unable to get resource's Address value for resource "
                                          L"'%1!ws!', status %2!u!.\n",
                                          DependentResourceId,
                                          status);
                        return status;
                    }
                } else {
                    (NetNameLogEvent)(resourceHandle,
                                      LOG_ERROR,
                                      L"Unable to open parameters key for resource '%1!ws!', "
                                      L"status %2!u!.\n",
                                      DependentResourceId,
                                      status);
                    return status;
                }
            } else {
                status = GetLastError();
                (NetNameLogEvent)(resourceHandle,
                                  LOG_ERROR,
                                  L"Unable to obtain registry key to resource '%1!ws!', "
                                  L"status %2!u!.\n",
                                  DependentResourceId,
                                  status);
                return status;
            }
        } else {
            status = GetLastError();
            (NetNameLogEvent)(resourceHandle,
                              LOG_ERROR,
                              L"Unable to open handle to resource '%1!ws!', status %2!u!.\n",
                              DependentResourceId,
                              status);
            return status;
        }
    } else {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to open handle to cluster, status %1!u!.\n",
                          status);
        return status;
    }

    //
    // argh. dependencies can be removed while the two resources are in a
    // stable state, i.e., not pending. Furthermore, the remove dependency
    // control is issued to all nodes in the cluster (double argh). This
    // really complicates matters since we're not tracking add dependency
    // which means we potentially don't have current DNS data on all nodes
    // except for the one that owns the resource. Consequently, if all nodes
    // handle the remove then we may use stale DNS info and remove the wrong
    // records at the server.
    //
    // Since this is our only chance to clean up PTR records at the server
    // (due to the fact that the PTR logic uses ModifyRecordSet instead of
    // ReplaceRecordSet), we can only process this request on a node where the
    // resource is online (along with the fact that if the resource is online,
    // then its DNS lists are correct). This is sort of ok since the resource
    // will either 1) go online again at which point the DNS A records will be
    // corrected at the server or 2) the resource will be deleted in which
    // case the last node hosting resource will clean up at the server if
    // possible.
    //
    // In any case, if we can't delete the records, we should log it.
    //
    if ( Resource->State != ClusterResourceOnline || numberOfDnsLists == 0 ) {
        WCHAR   msgBuffer[64];

        msgBuffer[ COUNT_OF( msgBuffer ) - 1] = UNICODE_NULL;
        if ( status == ERROR_SUCCESS ) {
            _snwprintf(msgBuffer,
                       COUNT_OF( msgBuffer ) - 1,
                       L"IP Address %ws",
                       ipAddressBuffer);

        } else {
            _snwprintf(msgBuffer,
                       COUNT_OF( msgBuffer ) - 1,
                       L"Cluster IP Address resource %ws",
                       DependentResourceId);

        }

        ClusResLogSystemEventByKey1(Resource->ResKey,
                                    LOG_UNUSUAL,
                                    RES_NETNAME_CANT_DELETE_DEPENDENT_RESOURCE_DNS_RECORDS,
                                    msgBuffer);

        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to delete DNS records associated with IP resource '%1!ws!'. "
                          L"The DNS Administrator can delete these records through the DNS "
                          L"management snapin.\n",
                          DependentResourceId);

        if ( ipAddressBuffer != NULL ) {
            LocalFree( ipAddressBuffer );
        }
        return ERROR_SUCCESS;
    }

    (NetNameLogEvent)(resourceHandle,
                      LOG_INFORMATION,
                      L"RemoveDependentIpAddress: Deleting DNS records associated with resource '%1!ws!'.\n",
                      DependentResourceId);

    RtlInitUnicodeString( &ipAddressStringW, ipAddressBuffer );
    RtlUnicodeStringToAnsiString( &ipAddressStringA,
                                  &ipAddressStringW,
                                  TRUE );
    ipAddress = inet_addr( ipAddressStringA.Buffer );
    RtlFreeAnsiString( &ipAddressStringA );
    
    //
    // finally, we know what to delete. Convert the address into reverse zone
    // format and find it in the resource's DNS list structures.
    //
    reverseName = BuildUnicodeReverseName( ipAddressBuffer );

    if ( reverseName == NULL ) {
        status = GetLastError();
        (NetNameLogEvent)(resourceHandle,
                          LOG_ERROR,
                          L"Unable to build DNS reverse zone name for resource '%1!ws!', status %2!u!.\n",
                          DependentResourceId,
                          status);
        return status;
    }

    //
    // co-ordinate changes to DnsLists with the worker thread
    //
    NetNameAcquireDnsListLock( Resource );

    dnsList = Resource->DnsLists;
    while ( numberOfDnsLists-- ) {
        PDNS_RECORD dnsRecord;
        PDNS_RECORD lastDnsRecord;
        PDNS_RECORD nextDnsRecord;
        DNS_STATUS  dnsStatus;

        if ( dnsList->ForwardZoneIsDynamic ) {
            dnsRecord = dnsList->A_RRSet.pFirstRR;
            lastDnsRecord = NULL;

            while( dnsRecord != NULL ) {
                if ( dnsRecord->Data.A.IpAddress == ipAddress ) {
                    //
                    // found a match. we need to whack just that record from
                    // the server and from our DNS lists.
                    //
                    nextDnsRecord = dnsRecord->pNext;
                    dnsRecord->pNext = NULL;

                    dnsStatus = DnsModifyRecordsInSet_W(NULL,
                                                        dnsRecord,
                                                        DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                        NULL,
                                                        dnsList->DnsServerList,
                                                        NULL);

                    if ( dnsStatus == DNS_ERROR_RCODE_NO_ERROR ) {
                        (NetNameLogEvent)(Resource->ResourceHandle,
                                          LOG_INFORMATION,
                                          L"Deleted DNS A record at server: name: %1!ws! IP Address: %2!ws!\n",
                                          dnsRecord->pName,
                                          ipAddressBuffer);

                    } else {
                        WCHAR   statusBuf[ 32 ];

                        statusBuf[ COUNT_OF( statusBuf ) - 1 ] = UNICODE_NULL;
                        _snwprintf(statusBuf, COUNT_OF( statusBuf ) - 1,
                                   L"%d",
                                   dnsStatus );
                        ClusResLogSystemEventByKey3(Resource->ResKey,
                                                    LOG_UNUSUAL,
                                                    RES_NETNAME_DNS_SINGLE_A_RECORD_DELETE_FAILED,
                                                    dnsRecord->pName,
                                                    ipAddressBuffer,
                                                    statusBuf);

                        (NetNameLogEvent)(Resource->ResourceHandle,
                                          LOG_ERROR,
                                          L"Failed to delete DNS A record at server: owner: %1!ws!, "
                                          L"IP Address: %2!ws!. status %3!u!\n",
                                          dnsRecord->pName,
                                          ipAddressBuffer,
                                          dnsStatus);
                    }

                    //
                    // fix up forward ptrs
                    //
                    if ( lastDnsRecord != NULL ) {
                        lastDnsRecord->pNext = nextDnsRecord;
                    } else {
                        dnsList->A_RRSet.pFirstRR = nextDnsRecord;
                    }

                    //
                    // fix up last ptr if necessary
                    //
                    if ( dnsList->A_RRSet.pLastRR == dnsRecord ) {
                        dnsList->A_RRSet.pLastRR = lastDnsRecord;
                    }

                    //
                    // have DNS clean up its allocations and free the record
                    DnsRecordListFree( dnsRecord, DnsFreeRecordListDeep );
                    break;
                }

                lastDnsRecord = dnsRecord;
                dnsRecord = dnsRecord->pNext;

            } // while dnsRecord != NULL
        } // if forward zone is dynamic

        if ( dnsList->ReverseZoneIsDynamic ) {
            dnsRecord = dnsList->PTR_RRSet.pFirstRR;
            lastDnsRecord = NULL;

            while( dnsRecord != NULL ) {
                if ( ClRtlStrICmp( reverseName, dnsRecord->pName ) == 0 ) {
                    //
                    // found a match. we need to whack that record from the
                    // server and from our DNS lists. This also means that we
                    // have to fix up the RRSet struct if the record we're
                    // whacking is either first and/or last.
                    //
                    nextDnsRecord = dnsRecord->pNext;
                    dnsRecord->pNext = NULL;

                    dnsStatus = DnsModifyRecordsInSet_W(NULL,
                                                        dnsRecord,
                                                        DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                        NULL,
                                                        dnsList->DnsServerList,
                                                        NULL);

                    if ( dnsStatus == DNS_ERROR_RCODE_NO_ERROR ) {
                        (NetNameLogEvent)(Resource->ResourceHandle,
                                          LOG_INFORMATION,
                                          L"Deleted DNS PTR record at server: name: %1!ws! host: %2!ws!\n",
                                          dnsRecord->pName,
                                          dnsRecord->Data.PTR.pNameHost
                                          );
                    } else {
                        WCHAR   statusBuf[ 32 ];

                        statusBuf[ COUNT_OF( statusBuf ) - 1 ] = UNICODE_NULL;
                        _snwprintf(statusBuf, COUNT_OF( statusBuf ) - 1,
                                   L"%d",
                                   dnsStatus );
                        ClusResLogSystemEventByKey3(Resource->ResKey,
                                                    LOG_UNUSUAL,
                                                    RES_NETNAME_DNS_PTR_RECORD_DELETE_FAILED,
                                                    dnsRecord->pName,
                                                    dnsRecord->Data.PTR.pNameHost,
                                                    statusBuf);

                        (NetNameLogEvent)(Resource->ResourceHandle,
                                          LOG_ERROR,
                                          L"Failed to delete DNS PTR record: owner %1!ws! "
                                          L"host: %2!ws!, status %3!u!\n",
                                          dnsRecord->pName,
                                          dnsRecord->Data.PTR.pNameHost,
                                          dnsStatus
                                          );
                    }

                    //
                    // fix up forward ptrs
                    //
                    if ( lastDnsRecord != NULL ) {
                        lastDnsRecord->pNext = nextDnsRecord;
                    } else {
                        dnsList->PTR_RRSet.pFirstRR = nextDnsRecord;
                    }

                    //
                    // fix up last ptr if necessary
                    //
                    if ( dnsList->PTR_RRSet.pLastRR == dnsRecord ) {
                        dnsList->PTR_RRSet.pLastRR = lastDnsRecord;
                    }

                    //
                    // have DNS clean up its allocations and free the record
                    DnsRecordListFree( dnsRecord, DnsFreeRecordListDeep );
                    break;
                }

                lastDnsRecord = dnsRecord;
                dnsRecord = dnsRecord->pNext;

            } // while dnsRecord != NULL
        } // if reverse zone is dynamic

        ++dnsList;

    } // while more dns lists to process

    NetNameReleaseDnsListLock( Resource );

    LocalFree( reverseName );
    LocalFree( ipAddressBuffer );

    return ERROR_SUCCESS;
} // RemoveDependentIpAddress

VOID
RemoveDnsRecords(
    PNETNAME_RESOURCE Resource
    )

/*++

Routine Description:

    delete all the DNS records associated with this resource.

Arguments:

    Resource - pointer to private netname resource data

Return Value:

    None

--*/

{
    PDNS_LISTS  dnsLists;
    DNS_STATUS  dnsStatus;
    PDNS_RECORD dnsRecord;
    PDNS_RECORD nextDnsRecord;
    ULONG       numberOfDnsLists;

    if ( Resource->NumberOfDnsLists == 0 ) {
        //
        // nothing to cleanup; log an entry in the event log so they know what
        // to do
        //
        ClusResLogSystemEventByKey(Resource->ResKey,
                                   LOG_UNUSUAL,
                                   RES_NETNAME_CANT_DELETE_DNS_RECORDS);
        return;
    }

    NetNameAcquireDnsListLock( Resource );

    dnsLists = Resource->DnsLists;
    numberOfDnsLists = Resource->NumberOfDnsLists;

    while ( numberOfDnsLists-- ) {

        if ( dnsLists->ReverseZoneIsDynamic ) {
            //
            // whack the PTR records; see the write up in RegisterDnsRecords
            // for this bit of funkiness
            //
            dnsRecord = dnsLists->PTR_RRSet.pFirstRR;
            while ( dnsRecord != NULL ) {

                nextDnsRecord = dnsRecord->pNext;
                dnsRecord->pNext = NULL;

                dnsStatus = DnsModifyRecordsInSet_W(NULL,
                                                    dnsRecord,
                                                    DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                    NULL,
                                                    dnsLists->DnsServerList,
                                                    NULL);

                if ( dnsStatus == DNS_ERROR_RCODE_NO_ERROR ) {
                    (NetNameLogEvent)(Resource->ResourceHandle,
                                      LOG_INFORMATION,
                                      L"Deleted DNS PTR record at server: owner: %1!ws! host: %2!ws!\n",
                                      dnsRecord->pName,
                                      dnsRecord->Data.PTR.pNameHost
                                      );
                } else {
                    WCHAR   statusBuf[ 32 ];

                    statusBuf[ COUNT_OF( statusBuf ) - 1 ] = UNICODE_NULL;
                    _snwprintf(statusBuf, COUNT_OF( statusBuf ) - 1,
                               L"%d",
                               dnsStatus );
                    ClusResLogSystemEventByKey3(Resource->ResKey,
                                                LOG_UNUSUAL,
                                                RES_NETNAME_DNS_PTR_RECORD_DELETE_FAILED,
                                                dnsRecord->pName,
                                                dnsRecord->Data.PTR.pNameHost,
                                                statusBuf);

                    (NetNameLogEvent)(Resource->ResourceHandle,
                                      LOG_ERROR,
                                      L"Failed to delete DNS PTR record: owner %1!ws! host: %2!ws!, status %3!u!\n",
                                      dnsRecord->pName,
                                      dnsRecord->Data.PTR.pNameHost,
                                      dnsStatus
                                      );
                }

                dnsRecord->pNext = nextDnsRecord;
                dnsRecord = nextDnsRecord;
            }
        }

        //
        // it's possible to remove all dependencies from the netname
        // resource. In that situation, we're left with no DNS records.
        //
        if ( dnsLists->ForwardZoneIsDynamic && dnsLists->A_RRSet.pFirstRR != NULL ) {
            //
            // delete the A records from the DNS server
            //
            dnsStatus = DnsModifyRecordsInSet_W(NULL,
                                                dnsLists->A_RRSet.pFirstRR,
                                                DNS_UPDATE_SECURITY_USE_DEFAULT,
                                                NULL,
                                                dnsLists->DnsServerList,
                                                NULL);

            if ( dnsStatus == DNS_ERROR_RCODE_NO_ERROR ) {

                dnsRecord = dnsLists->A_RRSet.pFirstRR;
                while ( dnsRecord != NULL ) {
                    struct in_addr ipAddress;

                    ipAddress.s_addr = dnsRecord->Data.A.IpAddress;
                    (NetNameLogEvent)(Resource->ResourceHandle,
                                      LOG_INFORMATION,
                                      L"Deleted DNS A record at server: owner: %1!ws! IP Address: %2!hs!\n",
                                      dnsRecord->pName,
                                      inet_ntoa( ipAddress ));

                    dnsRecord = dnsRecord->pNext;
                }
            } else {
                WCHAR   statusBuf[ 32 ];

                statusBuf[ COUNT_OF( statusBuf ) - 1 ] = UNICODE_NULL;
                _snwprintf(statusBuf, COUNT_OF( statusBuf ) - 1,
                           L"%d",
                           dnsStatus );
                ClusResLogSystemEventByKey2(Resource->ResKey,
                                            LOG_UNUSUAL,
                                            RES_NETNAME_DNS_A_RECORD_DELETE_FAILED,
                                            dnsLists->A_RRSet.pFirstRR->pName,
                                            statusBuf);

                (NetNameLogEvent)(Resource->ResourceHandle,
                                  LOG_ERROR,
                                  L"Failed to delete DNS A record at server: owner: %1!ws!, status %2!u!\n",
                                  dnsLists->A_RRSet.pFirstRR->pName,
                                  dnsStatus
                                  );
            }
        }

        ++dnsLists;
    }

    NetNameCleanupDnsLists( Resource );

    NetNameReleaseDnsListLock( Resource );

} // RemoveDnsRecords

DWORD
NetNameGetNetworkName(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_NETWORK_NAME control function
    for resources of type Network Name.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_MORE_DATA - More data is available than can fit in OutBuffer.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       required;

    //
    // Calculate the required number of bytes required for
    // the network name string.
    //
    required = (lstrlenW( ResourceEntry->Params.NetworkName ) + 1) * sizeof( WCHAR );

    //
    // Make sure we can return the required number of bytes.
    //
    if ( BytesReturned == NULL ) {
        status = ERROR_INVALID_PARAMETER;
    } else {
        //
        // Copy the required number of bytes to the output parameter.
        //
        *BytesReturned = required;

        //
        // If there is no output buffer, the call just wanted the size.
        //
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            //
            // If the output buffer is large enough, copy the data.
            // Otherwise return an error.
            //
            if ( OutBufferSize >= required ) {
                lstrcpyW( OutBuffer, ResourceEntry->Params.NetworkName );
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        }
    }

    return(status);

} // NetNameGetNetworkName

//
// Public Functions
//
BOOLEAN
WINAPI
NetNameDllEntryPoint(
    IN HINSTANCE DllHandle,
    IN DWORD     Reason,
    IN LPVOID    Reserved
    )
{
    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        return(NetNameInit( DllHandle ));
        break;

    case DLL_PROCESS_DETACH:
        NetNameCleanup();
        break;

    default:
        break;
    }

    return(TRUE);

} // NetNameDllEntryPoint



RESID
WINAPI
NetNameOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for Network Name resource

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - a registry key for access registry information for this
            resource.

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    NULL on failure

--*/

{
    DWORD               status;
    HKEY                parametersKey = NULL;
    HKEY                ResKey=NULL;
    PNETNAME_RESOURCE   resource = NULL;
    LPWSTR              nodeName = NULL;
    DWORD               nameSize = MAX_COMPUTERNAME_LENGTH + 1;
    LPWSTR              nodeId = NULL;
    DWORD               nodeIdSize = 6;
    NETNAME_PARAMS      paramBlock;
    DWORD               dwFlags;
    DWORD               resDataSize;
    HCLUSTER            clusterHandle;
    HRESOURCE           clusterResourceHandle = NULL;

    RtlZeroMemory( &paramBlock, sizeof( paramBlock ));

    //
    // Open a handle to the resource and remember it.
    //
    clusterHandle = OpenCluster(NULL);

    if (clusterHandle == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open handle to cluster, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    clusterResourceHandle = OpenClusterResource(
                                    clusterHandle,
                                    ResourceName
                                    );

    CloseCluster( clusterHandle );
    if (clusterResourceHandle == NULL) {
        status = GetLastError();
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open handle to resource <%1!ws!>, status %2!u!.\n",
            ResourceName,
            status
            );
        goto error_exit;
    }

    //
    // Figure out what node we are running on.
    //
    nodeName = LocalAlloc( LMEM_FIXED, nameSize * sizeof(WCHAR));

    if (nodeName == NULL) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate memory.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    if ( !GetComputerNameW(nodeName, &nameSize) ) {
        status = GetLastError();
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to get local node name, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    nodeId = LocalAlloc( LMEM_FIXED, nodeIdSize * sizeof(WCHAR));

    if (nodeId == NULL) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate memory.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    status = GetCurrentClusterNodeId(nodeId, &nodeIdSize);

    if (status != ERROR_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to get local node name, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Open handles to our key, our parameters key, and our node parameters
    // key in the registry
    //
    status = ClusterRegOpenKey(ResourceKey,
                               L"",
                               KEY_ALL_ACCESS,
                               &ResKey);

    if (status != ERROR_SUCCESS)
    {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open the top level key,status %1!u!.\n",
            status
        );
        goto error_exit;
    }

    status = ClusterRegOpenKey(ResourceKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               KEY_ALL_ACCESS,
                               &parametersKey);

    if (status != NO_ERROR) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key, status %1!u!.\n",
            status);
        goto error_exit;
    }

    //
    // Fetch our parameters from the registry.
    //
    status = NetNameGetParameters(ResourceKey,
                                  parametersKey,
                                  ResourceHandle,
                                  &paramBlock,
                                  &resDataSize,
                                  &dwFlags);

    //
    // Now we're ready to create a resource.
    //
    resource = NetNameAllocateResource(ResourceHandle);

    if (resource == NULL) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource structure.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    } else {
        status = ERROR_SUCCESS;
    }


    resource->RefCount = 1;
    resource->NodeName = nodeName;
    resource->NodeId = nodeId;
    resource->State = ClusterResourceOffline;
    resource->ResKey = ResKey;
    resource->ParametersKey = parametersKey;
    resource->Params = paramBlock;
    resource->ResDataSize = resDataSize;
    resource->dwFlags = dwFlags;
    resource->ClusterResourceHandle = clusterResourceHandle;
    resource->NameChangedWhileOnline = FALSE;

    if ( resource->dwFlags & CLUS_FLAG_CORE ) {
        LPWSTR  currentName;

        //
        // for the core resource, we have to remember the current name in a
        // separate location: FM will clobber the Name property directly in
        // order to perserve the updating of the cluster name in a
        // transaction. To that end, the CurrentName registry entry is used
        // to store the current name.
        //
        // This entry is written in NetnameSetPrivateResProperties whenever
        // the name changes. It is possible for that update to fail hence this
        // update. We also have to write if this is the first time this name
        // is opened since an upgrade from W2K.
        //
        currentName = ResUtilGetSzValue( resource->ResKey, PARAM_NAME__CORECURRENTNAME );
        if ( currentName == NULL ) {
            status = ClusterRegSetValue(resource->ResKey,
                                        PARAM_NAME__CORECURRENTNAME,
                                        REG_SZ,
                                        (LPBYTE)resource->Params.NetworkName,
                                        ( wcslen(resource->Params.NetworkName) + 1 ) * sizeof(WCHAR)
                                        );

            if (status != ERROR_SUCCESS) {
                (NetNameLogEvent)(resource->ResourceHandle,
                                  LOG_ERROR,
                                  L"Failed to write CurrentName to registry, status %1!u!\n",
                                  status
                                  );

                goto error_exit;
            }
        } else {
            LocalFree( currentName );
        }
    }

    //
    // initialize the mutex used to protect the DNS list data.
    //
    resource->DnsListMutex = CreateMutex(NULL, FALSE, NULL);
    if ( resource->DnsListMutex == NULL ) {
        status = GetLastError();
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to initialize DNS list mutex: %1!d!.\n",
            status);
        goto error_exit;
    }

    //
    // insert resource in list for DNS check routine
    //
    NetNameAcquireResourceLock();
    InsertHeadList( &NetNameResourceListHead, &resource->Next );
    NetNameReleaseResourceLock();

    InterlockedIncrement(&NetNameOpenCount);

#if 0
    //
    // If a computer object already exists for this name, get its object
    // GUID. We can't fail the open if this doesn't succeed: while the
    // resource may have its name property set, it may have never gone online,
    // therefore there maybe no CO in the DS at this point in time.
    //
    // turned off for now until we figure out what to do with the GUID. It is
    // only valid while the resource is online (assuming the CO doesn't get
    // whacked) and we don't do any kind of health check for the CO right
    // now. Besides, Open is probably not the best place to do this due to
    // latency related to contacting the DS.
    //
    if ( resource->Params.NetworkName != NULL ) {
        GetComputerObjectGuid( resource );
    }
#endif

error_exit:
    if (status == ERROR_SUCCESS) {
        (NetNameLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Successful open of resid %1!u!\n",
            resource
            );
    } else {

        if (paramBlock.NetworkName != NULL) {
            LocalFree( paramBlock.NetworkName );
        }

        if (paramBlock.ResourceData != NULL) {
            LocalFree( paramBlock.ResourceData );
        }

        if (paramBlock.CreatingDC != NULL) {
            LocalFree( paramBlock.CreatingDC );
        }

        if (parametersKey != NULL) {
            ClusterRegCloseKey(parametersKey);
        }

        if (ResKey != NULL){
            ClusterRegCloseKey(ResKey);
        }

        if (clusterResourceHandle != NULL) {
            CloseClusterResource(clusterResourceHandle);
        }

        if (nodeName != NULL) {
            LocalFree( nodeName );
        }

        if (nodeId != NULL) {
            LocalFree( nodeId );
        }

        if (resource != NULL) {
            LocalFree( resource );
            resource = NULL;
        }

        (NetNameLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Open failed, status %1!u!\n",
            status
            );

        SetLastError(status);
    }

    return resource;
} // NetNameOpen



DWORD
WINAPI
NetNameOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Network Name resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PNETNAME_RESOURCE      resource = (PNETNAME_RESOURCE) Resource;
    DWORD                  threadId;
    DWORD                  status=ERROR_SUCCESS;


    if (resource == NULL) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    NetNameAcquireResourceLock();

    resource->State = ClusterResourceOnlinePending;

    status = ClusWorkerCreate(
                 &resource->PendingThread,
                 NetNameOnlineThread,
                 resource
                 );

    if (status != ERROR_SUCCESS) {
        resource->State = ClusterResourceFailed;

        (NetNameLogEvent)(
            resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to start online thread, status %1!u!.\n",
            status
            );
    }
    else {
        status = ERROR_IO_PENDING;
    }

    NetNameReleaseResourceLock();

    return(status);

} // NetNameOnline

DWORD
WINAPI
NetNameOffline(
    IN RESID Resource
    )

/*++

Routine Description:

    Offline routine for Network Name resource. Spin a worker thread and return
    pending.

Arguments:

    Resource - supplies resource id to be taken offline.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

--*/
{
    DWORD                   status;
    PNETNAME_RESOURCE       resource = (PNETNAME_RESOURCE) Resource;

    if (resource != NULL) {
        (NetNameLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Taking resource offline...\n"
            );

        status = ClusWorkerCreate(&resource->PendingThread,
                                  NetNameOfflineThread,
                                  resource);

        if (status != ERROR_SUCCESS) {
            resource->State = ClusterResourceFailed;

            (NetNameLogEvent)(
                resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to start offline thread, status %1!u!.\n",
                status
                );
        }
        else {
            status = ERROR_IO_PENDING;
        }
    }
    else {
        status = ERROR_RESOURCE_NOT_FOUND;
    }

    return(status);

}  // NetNameOffline


VOID
WINAPI
NetNameTerminate(
    IN RESID Resource
    )

/*++

Routine Description:

    Terminate routine for Network Name resource.

Arguments:

    Resource - supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PNETNAME_RESOURCE       resource = (PNETNAME_RESOURCE) Resource;

    if (resource != NULL) {
        (NetNameLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Terminating resource...\n"
            );

        /* Ruihu: 11/06/2000 */
        NetNameAcquireResourceLock();
        if ((resource->State != ClusterResourceOffline)  && 
            (resource->State != ClusterResourceOfflinePending))
        {
            //
            // only call private offline routine if we haven't called it
            // already
            //
            NetNameReleaseResourceLock();
            NetNameOfflineWorker( resource, TRUE, NULL );
            NetNameAcquireResourceLock();
        }
        resource->State = ClusterResourceOffline;
        NetNameReleaseResourceLock();
        /* Ruihu: 11/06/2000 */
    }

    return;

} // NetNameTerminate



BOOL
WINAPI
NetNameLooksAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    LooksAlive routine for Network Name resource.

    Check that any Netbt plumbing is still intact. Then check the status of
    the last DNS operation. Finally check the kerberos status and fail if
    appropriate to do so.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PNETNAME_RESOURCE   resource = (PNETNAME_RESOURCE) Resource;
    BOOL                isHealthy = TRUE;
    DWORD               status;
    DWORD               numberOfFailures = 0;
    ULONG               numberOfDnsLists;
    PDNS_LISTS          dnsLists;
    BOOL                dnsFailure = FALSE;

    if (resource == NULL) {
         return(FALSE);
    }

    NetNameAcquireResourceLock();

    //
    // avoid gotos by breaking out of fake do loop
    //
    do {

        status = NetNameCheckNbtName(resource->Params.NetworkName,
                                     resource->NameHandleCount,
                                     resource->NameHandleList,
                                     resource->ResourceHandle);

        if ( status != ERROR_SUCCESS ) {
            ClusResLogSystemEventByKey1(resource->ResKey,
                                        LOG_CRITICAL,
                                        RES_NETNAME_NOT_REGISTERED_WITH_RDR,
                                        resource->Params.NetworkName);

            (NetNameLogEvent)(resource->ResourceHandle,
                              LOG_INFORMATION,
                              L"Name %1!ws! failed IsAlive/LooksAlive check, error %2!u!.\n",
                              resource->Params.NetworkName,
                              status);

            isHealthy = FALSE;
            break;
        }

        //
        // check how many of the DNS A record registrations are correct. We
        // don't acquire the resource's DNS list lock since we're only reading
        // the status out of a struct. The resource can't be deleted while
        // we're in this routine and we're not walking the DNS records
        // associated with this list so the number of lists won't change out
        // from underneath of us.
        //
        numberOfDnsLists = resource->NumberOfDnsLists;
        dnsLists = resource->DnsLists;

        while ( numberOfDnsLists-- ) {
            if (dnsLists->LastARecQueryStatus != DNS_ERROR_RCODE_NO_ERROR
                &&
                dnsLists->LastARecQueryStatus != ERROR_TIMEOUT )
            {
                dnsFailure = TRUE;
                ++numberOfFailures;
            }

            ++dnsLists;
        }

        //
        // If DNS is required and we detected a failure other than timeout or all
        // DNS name registrations failed and there are no netbt names associated
        // with this name, then we need to fail the resource
        //
        if ( ( resource->Params.RequireDNS && dnsFailure )
             ||
             ( numberOfFailures == resource->NumberOfDnsLists
               &&
               resource->NameHandleCount == 0 ) )
        {
            isHealthy = FALSE;
            break;
        }

#if 0
        if ( resource->DoKerberosCheck ) {
            //
            // ISSUE-01/03/13 charlwi - should resource fail if can't reach DS?
            //
            // The problem here is that we might have lost our connection to a
            // DC. Does that mean we fail the name? Not sure, since we don't know
            // if replication has been late. On the other hand, if the object has
            // been deleted from the DS, we should take some sort of action. This
            // will affect clients that do not have tickets at this point, i.e.,
            // existing clients with tickets will continue to work.
            //
            // see if our kerb plumbing is intact by getting a handle to the
            // computer object and checking its DnsHostName and
            // SecurityPrincipalName attributes
            //
            if ( resource->KerberosStatus != ERROR_SUCCESS ) {
                isHealthy = FALSE;
            }
        }
#endif

    } while ( FALSE );

    NetNameReleaseResourceLock();

    return isHealthy;

} // NetNameLooksAlive



BOOL
WINAPI
NetNameIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for Network Name resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    return(NetNameLooksAlive(Resource));

} // NetNameIsAlive



VOID
WINAPI
NetNameClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for Network Name resource.

Arguments:

    Resource - supplies resource id to be closed.

Return Value:

    None.

--*/

{
    PNETNAME_RESOURCE   resource = (PNETNAME_RESOURCE) Resource;
    PLIST_ENTRY         entry;


    if (resource != NULL) {

        ClusWorkerTerminate( &resource->PendingThread );
        if ( InterlockedDecrement(&NetNameOpenCount) == 0 ) {
            // This is the last resource //
            // Kill NetNameWorker        //
            //
            // set the event to terminate the worker thread and wait for it to
            // terminate.
            //
            if ( NetNameWorkerThread != NULL ) {
                DWORD status;
                SetEvent( NetNameWorkerTerminate );
                status = WaitForSingleObject(NetNameWorkerThread, 3 * 60 * 1000);
                if ( status == WAIT_TIMEOUT ) {
                    (NetNameLogEvent)(
                        resource->ResourceHandle,
                        LOG_ERROR,
                        L"Worker routine failed to stop. Terminating resrcmon.\n");
                    ClusResLogSystemEventByKey(resource->ResKey,
                                               LOG_CRITICAL,
                                               RES_NETNAME_DNS_CANNOT_STOP
                                               );
                    ExitProcess(WAIT_TIMEOUT);
                }
            
                CloseHandle( NetNameWorkerThread );
                NetNameWorkerThread = NULL;
            }
        }

        NetNameAcquireResourceLock();

        //
        // release our reference to this block. If the DNS worker thread
        // doesn't have an outstanding reference to it, then we can zap the
        // block now. Otherwise the DNS check routine will detect that the ref
        // count went to zero and get rid of it then. In either case, remove
        // it from the resource block list to avoid the problem where an
        // identical resource is recreated and both blocks are on the list.
        //
        RemoveEntryList(&resource->Next); 

        ASSERT( resource->RefCount > 0 );
        if ( --resource->RefCount == 0 ) {
            NetNameReleaseResource( resource );
        }

        NetNameReleaseResourceLock();
    }

    return;

} // NetNameClose


DWORD
NetNameGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for resources of type Network Name.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    typedef struct DEP_DATA {
        CLUSPROP_SZ_DECLARE( ipaddrEntry, sizeof(IP_ADDRESS_RESOURCETYPE_NAME) / sizeof(WCHAR) );
        CLUSPROP_SYNTAX endmark;
    } DEP_DATA, *PDEP_DATA;
    PDEP_DATA   pdepdata = (PDEP_DATA)OutBuffer;
    DWORD       status;

    *BytesReturned = sizeof(DEP_DATA);
    if ( OutBufferSize < sizeof(DEP_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( pdepdata, sizeof(DEP_DATA) );
        pdepdata->ipaddrEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->ipaddrEntry.cbLength = sizeof(IP_ADDRESS_RESOURCETYPE_NAME);
        lstrcpyW( pdepdata->ipaddrEntry.sz, IP_ADDRESS_RESOURCETYPE_NAME );
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return status;

} // NetNameGetRequiredDependencies

DWORD
NetNameResourceControl(
    IN RESID Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Network Name resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PNETNAME_RESOURCE   resourceEntry = (PNETNAME_RESOURCE)Resource;
    DWORD               required;
    BOOL                readOnly = FALSE;
    BOOL                nameHasChanged;
    BOOL                compObjNeedsRenaming;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( NetNameResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = NetNameGetRequiredDependencies( OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned
                                                     );
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( NetNameResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES:
            //
            // NOTE: fallthrough is the required behavior here.
            //
            readOnly = TRUE;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = NetNameGetPrivateResProperties( resourceEntry,
                                                     readOnly,
                                                     OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = NetNameValidatePrivateResProperties( resourceEntry,
                                                          InBuffer,
                                                          InBufferSize,
                                                          NULL,
                                                          &nameHasChanged,
                                                          &compObjNeedsRenaming);
            break;

        case CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED:
        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = NetNameSetPrivateResProperties( resourceEntry,
                                                     InBuffer,
                                                     InBufferSize );
            break;

        case CLUSCTL_RESOURCE_GET_NETWORK_NAME:
            status = NetNameGetNetworkName( resourceEntry,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned );
            break;

        case CLUSCTL_RESOURCE_DELETE:
            RemoveDnsRecords( resourceEntry );

            //
            // if resource was created but has no properities, then
            // NetworkName can be NULL. Otherwise, try to disable the object
            // and remove any crypto checkpoints that may have been created
            //
            if ( resourceEntry->Params.NetworkName != NULL ) {
                DisableComputerObject( resourceEntry );
                RemoveNNCryptoCheckpoint( resourceEntry );
            }

            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_REMOVE_DEPENDENCY:
            //
            // argh! resource dependencies can be removed without any veto
            // power by the resource DLL. We could be deleting the last
            // dependent resource which leaves netname with nothing.
            //
            RemoveDependentIpAddress( resourceEntry, InBuffer );
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_NETNAME_GET_VIRTUAL_SERVER_TOKEN:
            //
            // dup an impersonation token of the virtual computer account for
            // the caller.
            //
            // caller provides a structure indicating their process ID,
            // desired access and whether the handle should be
            // inheritable. This process must have PROCESS_DUP_HANDLE access
            // to the target process.
            //

            if ( InBufferSize >= sizeof( CLUS_NETNAME_VS_TOKEN_INFO )) {
                if ( OutBufferSize >= sizeof( HANDLE )) {
                    PCLUS_NETNAME_VS_TOKEN_INFO tokenInfo = (PCLUS_NETNAME_VS_TOKEN_INFO)InBuffer;
                    PHANDLE dupVSToken = (PHANDLE)OutBuffer;

                    if ( resourceEntry->State == ClusterResourceOnline ) {

                        status = DuplicateVSToken( resourceEntry, tokenInfo, dupVSToken );
                        if ( status == ERROR_SUCCESS ) {
                            *BytesReturned = sizeof( HANDLE );
                        } else {
                            *BytesReturned = 0;
                        }
                    } else {
                        return ERROR_INVALID_STATE;
                    }
                }
                else {
                    status = ERROR_MORE_DATA;
                    *BytesReturned = sizeof( HANDLE );
                }
            }
            else {
                status = ERROR_INVALID_PARAMETER;
            }

            break;

        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
            //
            // global flag was set during restype control. If appropriate, set
            // it on existing resources so that during their first online,
            // they do the upgrade check.
            //
            if ( CheckForKerberosUpgrade ) {
                resourceEntry->CheckForKerberosUpgrade = TRUE;
            }

            status = ERROR_SUCCESS;
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // NetNameResourceControl

DWORD
NetNameResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Network Name resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD   status;
    DWORD   required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( NetNameResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = NetNameGetRequiredDependencies( OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned
                                                     );
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( NetNameResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_CLUSTER_VERSION_CHANGED:
            {
                PDOMAIN_CONTROLLER_INFO     dcInfo = NULL;
                
                //
                // if there is no DS based DC, don't add a computer object
                // even if MSMQ dependent resources exist. Here we use
                // DsGetDcName as opposed to DsGetDcNameWithAccount since the
                // former API is documented to be successful even if all the
                // DCs are down. That is the semantics we want here.
                //
                status = DsGetDcName( NULL,                             // Use local computer
                                      NULL,                             // Use primary domain of this node
                                      NULL,                             // Domain GUID
                                      NULL,                             // Site name
                                      DS_DIRECTORY_SERVICE_REQUIRED,    // Needs W2k or higher DC
                                      &dcInfo );                        // Output DC info

                if ( status == ERROR_SUCCESS ) {
                    //
                    // if MSMQ is in workgroup mode, then don't bother with
                    // individual resource upgrade checks
                    //
                    CheckForKerberosUpgrade = DoesMsmqNeedComputerObject();

                    (NetNameLogEvent)( L"rtNetwork Name",
                                       LOG_INFORMATION,
                                       L"Upgrade detected - Network Name resources will %1!ws!be checked "
                                       L"for dependent MSMQ resources.\n",
                                       CheckForKerberosUpgrade ? L"" : L"not " );

                    NetApiBufferFree ( dcInfo );
                }
                else {
                    (NetNameLogEvent)( L"rtNetwork Name",
                                       LOG_WARNING,
                                       L"Upgrade detected: Active Directory is not available in this "
                                       L"domain. No Kerberos support upgrade check will be done. status %1!u!\n",
                                       status);
                }

            }

            status = ERROR_SUCCESS;
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // NetNameResourceTypeControl

DWORD
NetNameGetPrivateResProperties(
    IN OUT PNETNAME_RESOURCE    ResourceEntry,
    IN     BOOL                 ReadOnly,
    OUT    PVOID                OutBuffer,
    IN     DWORD                OutBufferSize,
    OUT    LPDWORD              BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type Network Name.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    ReadOnly - true if we're selecting read only property table

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD   status;
    DWORD   required;

    //
    // The resutil routines don't support resources with r/w, r/o, and unknown
    // props very well. There is no easy way to get just the unknown
    // properties. For the r/o request, the props are separated out into a
    // separate table. For the r/w case, if we call RUGetAllProperties using
    // the r/w table, we get the r/o props back since they weren't in the
    // table. If we combine the two tables into one, then the r/o case is
    // broken, i.e., it returns the r/w props as well as the r/o ones.
    //
    // The current (yucky) solution is to have 3 tables: r/w, r/o, and
    // combined. Combined is used to get any unknown props that are associated
    // with the resource. It would be nice to have a resutils routine that
    // gathers the unknown props using a list of prop list tables as input.
    //
    if ( ReadOnly ) {
        status = ResUtilGetProperties(ResourceEntry->ParametersKey,
                                      NetNameResourceROPrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    } else {
        //
        // get the r/w props first; after the call, required will be non-zero
        // if the buffer wasn't large enough. Regardless, we have to continue
        // to get the amount of space for any unknown props
        //
        status = ResUtilGetProperties(ResourceEntry->ParametersKey,
                                      NetNameResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );

        //
        // Add unknown properties to the property list.
        //
        if ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA ) {
            status = ResUtilAddUnknownProperties(ResourceEntry->ParametersKey,
                                                 NetNameResourceCombinedPrivateProperties,
                                                 OutBuffer,
                                                 OutBufferSize,
                                                 BytesReturned,
                                                 &required);
        }
    } // end of if getting r/w props

    //
    // This is kinda wierd: if null is passed in for the input buffer, the
    // return status is success and required reflects how many bytes are
    // needed.  If a buffer was specified but it was too small, then more data
    // is returned. It appears that the thing to watch is required indicating
    // that more space is needed regardless of whether a buffer was specified
    // or not.
    //
    if ( required > 0 && ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA )) {
        *BytesReturned = required;
    }

    return(status);

} // NetNameGetPrivateResProperties

DWORD
NetNameValidatePrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PNETNAME_PARAMS Params          OPTIONAL,
    OUT PBOOL NewNameIsDifferent,
    OUT PBOOL CompObjRenameIsRequired
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Network Name.

    This routine imposes a set of rules on when netname's properties can be
    changed. Currently, this is limited to:

    1) changing RequireKerberos requires the resource to be offline and

    2) changing the Name property when RequireKerberos equals one requires the
    resource to be offline

    These restrictions are in place in order to simplify the coding of
    netname. Both of these properties have direct implication for
    communicating with the domain's DS. Consequently, limiting property
    changes to when the resource is offline provides immediate feedback on the
    success or failure of the requested change.

    Changing the Name property when the resource is offline is a little tricky
    due to qualfication issues. Since the name can change and then change back
    to its original value, we have to detect and act on that.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing the property list of
        changed property values to validate.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies a pointer to an optional parameter block to fill in.

    NewNameIsDifferent - TRUE if the new name is different than the current name

    CompObjRenameIsRequired - TRUE if the new name is different from the stored
        name and a corresponding CO needs to be renamed

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_DATA - No input data.

    ERROR_INVALID_NETNAME - The specified network name has invalid characters.

    RPC_S_STRING_TOO_LONG - The specified network name is too long.

    ERROR_BUSY - The specified network name is already in use.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    CLRTL_NAME_STATUS   netnameStatus;
    NETNAME_PARAMS      currentProps;       // as stored in the registry
    NETNAME_PARAMS      newProps;           // storage for updated props if Params is null
    PNETNAME_PARAMS     pParams;            // pointer to the block of updated props
    LPWSTR              nameOfPropInError;

    //
    // The NewNameIsDifferent flag can (eventually) drive the offline cleanup
    // routine. If the name has truly changed while it was online, then we
    // want to do the appropriate cleanup when it goes offline. The problem is
    // that the name can change many times while it is online; it could return
    // to its current value so the overall appearance is that it never
    // changed. In that case, we want to avoid cleanup.
    //
    *NewNameIsDifferent = FALSE;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Retrieve the current set of private read/write properties from the
    // cluster database. This may be different from what is stored in
    // ResourceEntry since the name could be online at this point in time.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 NetNameResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(NETNAME_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       NetNameResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties that are changing.
    //
    status = ResUtilVerifyPropertyTable( NetNameResourcePrivateProperties,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    //
    // now make validation checks
    //
    if ( status == ERROR_SUCCESS ) {
        //
        // can't change RequireKerberos while we're online
        //
        if ( ResourceEntry->State == ClusterResourceOnline 
             &&
             ResourceEntry->Params.RequireKerberos != pParams->RequireKerberos
           )
        {
            status = ERROR_INVALID_STATE;
        }
    }

    if ( status == ERROR_SUCCESS ) {
        //
        // if Kerb is on, we have to be offline to change the name
        //
        if ( ResourceEntry->State == ClusterResourceOnline 
             &&
             ResourceEntry->Params.RequireKerberos
             &&
             pParams->NetworkName != NULL
           )
        {
            if ( ClRtlStrICmp( pParams->NetworkName, ResourceEntry->Params.NetworkName ) != 0 ) {
                status = ERROR_INVALID_STATE;
            }
        }
    }

    if ( status == ERROR_SUCCESS && pParams->NetworkName != NULL ) {
        BOOL    validateName = FALSE;
        LPWSTR  currentName;

        //
        // got a request to change the network name property. if this is the
        // core resource, then it is possible our name has already been
        // changed by FM. Look it up in the registry. Otherwise, use the one
        // stored as the Name property.
        //
        if ( ResourceEntry->dwFlags & CLUS_FLAG_CORE ) {
            currentName = ResUtilGetSzValue( ResourceEntry->ResKey, PARAM_NAME__CORECURRENTNAME );
            if ( currentName == NULL ) {
                //
                // this is bad; we've lost track of the old name for the core
                // resource so we can't rename it
                //
                status = GetLastError();
                (NetNameLogEvent)(ResourceEntry->ResourceHandle,
                                  LOG_ERROR,
                                  L"Unable to find core resource's current name. status %1!u!\n",
                                  status );
            }
        } else {
            currentName = currentProps.NetworkName;
        }

        if ( currentName != NULL ) {

            //
            // a name has been specified. validate the new name if:
            //     the name has never been set  (ResourceEntry and currentProps value is null)
            // OR
            //     resource hasn't been online yet (RE is null) but the new name is different
            //     from the stored name (currentProps)
            // OR
            // (   the new name is different from the future name (currentProps).
            //   AND
            //     the new name is different from the name currently online (ResourceEntry)
            // )
            //
            // ClRtlIsNetNameValid will fail if the name hasn't changed and
            // the name is online.
            //
            // currentProps value is NULL only when the name is created and
            // hasn't had its Name property set, i.e., no data in the
            // registry. Once brought online, the currentProps value is always
            // non-NULL hence no need to test if the pointer is valid.
            //
            if ( ResourceEntry->Params.NetworkName == NULL ) {
                if ( currentName == NULL ) {
                    validateName = TRUE;
                } else if ( ClRtlStrICmp( pParams->NetworkName, currentName ) != 0 ) {
                    validateName = TRUE;
                }
            }
            else if ( ClRtlStrICmp( pParams->NetworkName, currentName ) != 0
                      &&
                      ClRtlStrICmp( pParams->NetworkName, ResourceEntry->Params.NetworkName ) != 0
                    )
            {
                validateName = TRUE;
            }

            if ( validateName ) {
                *NewNameIsDifferent = TRUE;

                //
                // Validate the syntax of the new name
                //
                if ( !ClRtlIsNetNameValid( pParams->NetworkName, &netnameStatus, TRUE /* CheckIfExists */ ) ) {
                    switch ( netnameStatus ) {
                    case NetNameTooLong:
                        status = RPC_S_STRING_TOO_LONG;
                        break;
                    case NetNameInUse:
                        status = ERROR_DUP_NAME;
                        break;
                    case NetNameDNSNonRFCChars:
                        //
                        // we leave it up to the calling application to do the
                        // validation and ask the user if non-RFC chars
                        // (underscores) are acceptable.
                        //
                        status = ERROR_SUCCESS;
                        break;
                    case NetNameInvalidChars:
                    default:
                        status = ERROR_INVALID_NETNAME;
                        break;
                    }
                }
            }   // end if validateName

            if ( status == ERROR_SUCCESS                    // everything is ok so far
                 &&
                 ResourceEntry->Params.CreatingDC != NULL   // we have a CO
                 &&
                 pParams->RequireKerberos != 0              // and we're not disabling kerb
               )
            {
                //
                // check if the new name is different from the stored name. If
                // so, inform the caller that the CO needs to be renamed.
                //
                *CompObjRenameIsRequired = ClRtlStrICmp( pParams->NetworkName, currentName );
            }

#if 0
            //
            // ISSUE: not sure how to handle this. Under some circumstances,
            // we want the resource to hijack the object but under others we
            // don't. Most of the problem stems from having two resources with
            // the same Name property and they are both offline. One
            // possibility is to run the list of resources on this cluster and
            // see if there are any dups but that isn't always effective since
            // the NetworkName field in ResourceEntry->Params might be
            // NULL. This still wouldn't work for a cluster in the same domain
            // using the same name and it was offline.
            //
            // for now, we'll avoid this check to avoid causing a situation
            // where it is valid to set the Name property but it would be
            // disallowed by this check.
            //
            if ( status == ERROR_SUCCESS                        // everything is ok so far
                 &&
                 pParams->RequireKerberos                       // RK is set to one
                 &&
                 *NewNameIsDifferent                            // and we're changing the name
               )
            {
                BOOL    objectExists;
                HRESULT hr;

                //
                // check if the new name has a corresponding computer object
                // and fail it it does. We allow hijacking of a CO only if
                // RequireKerberos was zero and is now one or if the resource
                // has never created a CO.
                //
                hr = IsComputerObjectInDS(ResourceEntry->ResourceHandle,
                                          ResourceEntry->NodeName,
                                          pParams->NetworkName,
                                          NULL,
                                          &objectExists,
                                          NULL,                        // don't need FQDN
                                          NULL);                       // don't need HostingDCName

                if ( SUCCEEDED( hr ) && objectExists ) {
                    status = E_ADS_OBJECT_EXISTS;
                }
                else {

                    //
                    // check if the new name is different from the stored
                    // name. If so, inform the caller that the CO needs to be
                    // renamed. This handles the case where the name was
                    // changed and then changed back to what it originally
                    // was. The first rename caused a CO rename so we have to
                    // undo that operation.
                    //
                    if ( currentProps.NetworkName != NULL ) {
                        *CompObjRenameIsRequired = ClRtlStrICmp( pParams->NetworkName, currentProps.NetworkName );
                    }
                }   // end of there is no existing object
            }       // end of if successful so far and RK is set to one and new name is different

#endif  // 0

            if ( currentName != currentProps.NetworkName ) {
                LocalFree( currentName );
            }
        }       // end of if currentName != NULL
    }           // end of if successful so far and new name is specified

FnExit:
    //
    // Cleanup our parameter block.
    //
    if (( status != ERROR_SUCCESS && pParams != NULL )
        || 
        pParams == &newProps
       )
    {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   NetNameResourcePrivateProperties );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        NetNameResourcePrivateProperties
        );

    return(status);

} // NetNameValidatePrivateResProperties

DWORD
NetNameSetPrivateResProperties(
    IN OUT PNETNAME_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Network Name.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing the property list of
        changed property values to set.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    BOOL    newNameIsDifferent = FALSE;
    BOOL    disablingKerberos;
    BOOL    compObjNeedsRenaming = FALSE;
    LPWSTR  creatingDC = NULL;
    BOOL    coreName = ResourceEntry->dwFlags & CLUS_FLAG_CORE;

    NETNAME_PARAMS  params;

    ZeroMemory( &params, sizeof(NETNAME_PARAMS) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = NetNameValidatePrivateResProperties( ResourceEntry,
                                                  InBuffer,
                                                  InBufferSize,
                                                  &params,
                                                  &newNameIsDifferent,
                                                  &compObjNeedsRenaming);
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // If network name is one of the parameters to be set, convert the name
    // to uppercase.
    //
    if ( params.NetworkName != NULL ) {
        _wcsupr( params.NetworkName );
    }

    //
    // if kerb is currently required and we're turning it off, then note that
    // now.
    //
    disablingKerberos = ( ResourceEntry->Params.RequireKerberos && !params.RequireKerberos );

    if ( ResourceEntry->State == ClusterResourceOnline ||
         ResourceEntry->State == ClusterResourceOnlinePending )
    {
        //
        // If the resource is online, remember that the name property has
        // truly changed (it can change and then be set back to its original
        // value while online). When the resource goes offline, this flag is
        // used to cleanup stuff with the old name.
        //
        ResourceEntry->NameChangedWhileOnline = newNameIsDifferent;
        status = ERROR_RESOURCE_PROPERTIES_STORED;
    }
    else {

        //
        // read the CreatingDC parameter. If it is NULL, then that indicates
        // that no CO has been created for this name.
        //
        creatingDC = ResUtilGetSzValue( ResourceEntry->ParametersKey, PARAM_NAME__CREATING_DC );
        if ( creatingDC == NULL ) {
            status = GetLastError();
            if ( status != ERROR_FILE_NOT_FOUND ) {
                goto cleanup;
            }

            status = ERROR_SUCCESS;
        }

        if ( newNameIsDifferent ) {
            //
            // name change; try to cleanup the old name's DNS records
            //
            RemoveDnsRecords( ResourceEntry );
        }

        //
        // do renaming first before disabling the CO: you can't rename a
        // disabled CO via NetUserSetInfo
        //
        if ( compObjNeedsRenaming && creatingDC ) {
            LPWSTR  currentName;

            if ( coreName ) {
                currentName = ResUtilGetSzValue( ResourceEntry->ResKey, PARAM_NAME__CORECURRENTNAME );
                if ( currentName == NULL ) {
                    //
                    // this is bad; we've lost track of the old name for the
                    // core resource so we can't rename it
                    //
                    status = GetLastError();
                    (NetNameLogEvent)(ResourceEntry->ResourceHandle,
                                      LOG_ERROR,
                                      L"Unable to find core resource's current name. status %1!u!\n",
                                      status );
                }
            }
            else {

                //
                // get the name parameter out of the registry since it
                // represents the current setting, i.e., if the name is
                // changed multiple times while the resource is offline, the
                // registry holds the last value.
                //
                currentName = ResUtilGetSzValue( ResourceEntry->ParametersKey, PARAM_NAME__NAME );
                if (currentName == NULL) {
                    status = GetLastError();
                    (NetNameLogEvent)(ResourceEntry->ResourceHandle,
                                      LOG_ERROR,
                                      L"Unable to read NetworkName parameter to rename computer "
                                      L"account, status %1!u!\n",
                                      status);
                }
            }

            if ( currentName != NULL ) {
                status = RenameComputerObject( ResourceEntry, currentName, params.NetworkName );

                LocalFree( currentName );
            }
        }

        if ( status == ERROR_SUCCESS && disablingKerberos ) {

            if ( creatingDC ) {

                status = DisableComputerObject( ResourceEntry );
                if ( status == NERR_UserNotFound ) {
                    //
                    // it's not an error if the CO is already gone
                    //
                    status = ERROR_SUCCESS;
                }
                else if ( status != NERR_Success ) {
                    //
                    // failed for some reason (probably access denied).
                    //
                    (NetNameLogEvent)(ResourceEntry->ResourceHandle,
                                      LOG_WARNING,
                                      L"Unable to disable computer account for %1!ws!. Kerberos authentication "
                                      L"to this name will fail. Set RequireKerberos back to one or, if "
                                      L"appropriate, delete the CO from Active Directory. status %2!u!\n",
                                      ResourceEntry->Params.NetworkName,
                                      status );
                }
            }       // end of if creatingDC != NULL

            //
            // clean up the resource's param block; delete the creating DC
            // property so we don't think that we still have a CO. Do the
            // cluster registry stuff first to make sure the resource will
            // work the next time it goes online.
            //
            status = ClusterRegDeleteValue(ResourceEntry->ParametersKey,
                                           PARAM_NAME__CREATING_DC);

            if ( status == ERROR_SUCCESS || status == ERROR_FILE_NOT_FOUND ) {

                status = ClusterRegDeleteValue(ResourceEntry->ParametersKey,
                                               PARAM_NAME__RESOURCE_DATA);

                if ( status == ERROR_SUCCESS || status == ERROR_FILE_NOT_FOUND ) {

                    ResourceEntry->Params.RequireKerberos = 0;

                    if ( ResourceEntry->Params.CreatingDC != NULL ) {
                        LocalFree( ResourceEntry->Params.CreatingDC );
                        ResourceEntry->Params.CreatingDC = NULL;
                    }

                    if ( ResourceEntry->Params.ResourceData != NULL ) {
                        LocalFree( ResourceEntry->Params.ResourceData );
                        ResourceEntry->Params.ResourceData = NULL;
                    }

                    RemoveNNCryptoCheckpoint( ResourceEntry );
                } else {
                    (NetNameLogEvent)(ResourceEntry->ResourceHandle,
                                      LOG_ERROR,
                                      L"Unable to clear the "
                                      PARAM_NAME__RESOURCE_DATA
                                      L" property for %1!ws!. status %2!u!\n",
                                      ResourceEntry->Params.NetworkName,
                                      status );
                }
            } else {
                (NetNameLogEvent)(ResourceEntry->ResourceHandle,
                                  LOG_ERROR,
                                  L"Unable to clear the "
                                  PARAM_NAME__CREATING_DC
                                  L" property for %1!ws!. status %2!u!\n",
                                  ResourceEntry->Params.NetworkName,
                                  status );
            }

            //
            // all this can fail due to lack of access rights; don't make it a
            // fatal error for the routine
            //
            status = ERROR_SUCCESS;

        }       // end of if disabling Kerberos

        if ( creatingDC ) {
            //
            // free but don't clear the pointer; it is used as a flag later on
            // to indicate that we did a rename on a CO
            //
            LocalFree( creatingDC );
        }
    }       // end if resource state is not online or online pending

    if ( coreName && ( status == ERROR_SUCCESS || status == ERROR_RESOURCE_PROPERTIES_STORED )) {
        DWORD   regStatus;

        //
        // Remember the name of the core resource in a different area to deal with
        // FM changing the Name property as a result of calling SetClusterName.
        //
        regStatus = ClusterRegSetValue(ResourceEntry->ResKey,
                                       PARAM_NAME__CORECURRENTNAME,
                                       REG_SZ,
                                       (LPBYTE)params.NetworkName,
                                       ( wcslen(params.NetworkName) + 1 ) * sizeof(WCHAR) );

        if ( regStatus != ERROR_SUCCESS ) {
            status = regStatus;

            (NetNameLogEvent)(ResourceEntry->ResourceHandle,
                              LOG_ERROR,
                              L"Failed to write "
                              PARAM_NAME__CORECURRENTNAME,
                              L" to registry, status %1!u!\n",
                              status
                              );
        }
    }

    if ( status == ERROR_SUCCESS || status == ERROR_RESOURCE_PROPERTIES_STORED ) {
        DWORD   resUtilStatus;

        //
        // Save the parameter values.
        //
        resUtilStatus = ResUtilSetPropertyParameterBlock(ResourceEntry->ParametersKey,
                                                         NetNameResourcePrivateProperties,
                                                         NULL,
                                                         (LPBYTE) &params,
                                                         InBuffer,
                                                         InBufferSize,
                                                         NULL );

        if ( resUtilStatus == ERROR_SUCCESS && newNameIsDifferent ) {
            (NetNameLogEvent)(ResourceEntry->ResourceHandle,
                              LOG_INFORMATION,
                              L"Name property changed from %1!ws! to %2!ws!\n",
                              ResourceEntry->Params.NetworkName,
                              params.NetworkName);

            ClusResLogSystemEventByKey2( ResourceEntry->ResKey,
                                         LOG_NOISE,
                                         RES_NETNAME_RENAME,
                                         ResourceEntry->Params.NetworkName,
                                         params.NetworkName);
        } else {
            status = resUtilStatus;
        }
    }

    if ( compObjNeedsRenaming && creatingDC ) {
        DWORD   deleteStatus;

        //
        // ok to whack RenameNewName from the registry
        //
        deleteStatus = ClusterRegDeleteValue( ResourceEntry->ResKey, PARAM_NAME__RENAMENEWNAME );

        if ( deleteStatus != ERROR_SUCCESS && deleteStatus != ERROR_FILE_NOT_FOUND ) {
            (NetNameLogEvent)(ResourceEntry->ResourceHandle,
                              LOG_WARNING,
                              L"Failed to delete "
                              PARAM_NAME__RENAMENEWNAME
                              L" from registry - status %1!u!\n",
                              deleteStatus);
        }
    }

cleanup:
    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               NetNameResourcePrivateProperties );

    return status;

} // NetNameSetPrivateResProperties

//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( NetNameFunctionTable,      // Name
                         CLRES_VERSION_V1_00,       // Version
                         NetName,                   // Prefix
                         NULL,                      // Arbitrate
                         NULL,                      // Release
                         NetNameResourceControl,    // ResControl
                         NetNameResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\resutils\resutils.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    resutils.c

Abstract:

    Common utility routines for clusters resources

Author:

    John Vert (jvert) 12/15/1996

Revision History:

--*/

#pragma warning( push )
#pragma warning( disable : 4115 )       //  Clusrtl - struct def in parentheses
#pragma warning( disable : 4201 )       //  SDK - nameless struct/union

#include "clusres.h"
#include "clusrtl.h"
#include "winbase.h"
#include <windows.h>
#include "userenv.h"
#include <strsafe.h>

#pragma warning( push )
#pragma warning( disable: 4214 )
#include <windns.h>
#pragma warning( pop )

#pragma warning( pop )

//
// For some reason this doesn't get pulled in from winnt.h.
//
#ifndef RTL_NUMBER_OF
#define RTL_NUMBER_OF(A) (sizeof(A)/sizeof((A)[0]))
#endif


//#define DBG_PRINT printf
#define DBG_PRINT

typedef struct _WORK_CONTEXT {
    PCLUS_WORKER Worker;
    PVOID lpParameter;
    PWORKER_START_ROUTINE lpStartRoutine;
} WORK_CONTEXT, *PWORK_CONTEXT;


//
// Local Data
//
CRITICAL_SECTION ResUtilWorkerLock;


BOOLEAN
WINAPI
ResUtilDllEntry(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )

/*++

Routine Description:

    Main DLL entry for resource utility helper module.

Arguments:

    DllHandle - Supplies the DLL Handle.

    Reason - Supplies the call reason.

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    BOOLEAN fSuccess = TRUE;

    UNREFERENCED_PARAMETER( Reserved );

    if ( Reason == DLL_PROCESS_ATTACH )
    {
        fSuccess = (BOOLEAN) ( InitializeCriticalSectionAndSpinCount(&ResUtilWorkerLock,1000) != 0 ) ? TRUE : FALSE;
        DisableThreadLibraryCalls(DllHandle);
    }

    if ( Reason == DLL_PROCESS_DETACH )
    {
        DeleteCriticalSection(&ResUtilWorkerLock);
    }

    return fSuccess;

} // ResUtilDllEntry


DWORD
WINAPI
ResUtilStartResourceService(
    IN LPCWSTR pszServiceName,
    OUT LPSC_HANDLE phServiceHandle
    )

/*++

Routine Description:

    Start a service.

Arguments:

    pszServiceName - The name of the service to start.

    phServiceHandle - Pointer to a handle to receive the service handle
        for this service.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    SC_HANDLE       serviceHandle;
    SC_HANDLE       scManagerHandle;
    DWORD           status = ERROR_SUCCESS;
    SERVICE_STATUS  serviceStatus;

    scManagerHandle = OpenSCManager( NULL,        // local machine
                                     NULL,        // ServicesActive database
                                     SC_MANAGER_ALL_ACCESS ); // all access

    if ( scManagerHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT( "ResUtilStartResourceService: Cannot access service controller! Error: %u.\n",
                   status );
        return(status);
    }

    serviceHandle = OpenService( scManagerHandle,
                                 pszServiceName,
                                 SERVICE_ALL_ACCESS );

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT( "ResUtilStartResourceService: Cannot open service %ws. Error: %u.\n",
                   pszServiceName,
                   status );
        CloseServiceHandle( scManagerHandle );
        return(status);
    }
    CloseServiceHandle( scManagerHandle );

    if ( !StartService( serviceHandle,
                        0,
                        NULL) ) {
        status = GetLastError();
        if ( status == ERROR_SERVICE_ALREADY_RUNNING ) {
            status = ERROR_SUCCESS;
        } else {
            DBG_PRINT( "ResUtilStartResourceService: Failed to start %ws service. Error: %u.\n",
                       pszServiceName,
                       status );
        }
    } else {
        //
        // Wait for the service to start.
        //
        for (;;)
        {
            status = ERROR_SUCCESS;
            if ( !QueryServiceStatus(serviceHandle, &serviceStatus) ) {
                status = GetLastError();
                DBG_PRINT("ResUtilStartResourceService: Failed to query status of %ws service. Error: %u.\n",
                    pszServiceName,
                    status);
                break;
            }

            if ( serviceStatus.dwCurrentState == SERVICE_RUNNING ) {
                break;
            } else if ( serviceStatus.dwCurrentState != SERVICE_START_PENDING ) {
                status = ERROR_SERVICE_NEVER_STARTED;
                DBG_PRINT("ResUtilStartResourceService: Failed to start %ws service. CurrentState: %u.\n",
                    pszServiceName,
                    serviceStatus.dwCurrentState);
                break;
            }
            Sleep(200);         // Try again in a little bit
        } // for: ever
    } // else:

    if ( (status == ERROR_SUCCESS) &&
         ARGUMENT_PRESENT(phServiceHandle) ) {
        *phServiceHandle = serviceHandle;
    } else {
        CloseServiceHandle( serviceHandle );
    }

    return(status);

} // ResUtilStartResourceService


DWORD
WINAPI
ResUtilStopResourceService(
    IN LPCWSTR pszServiceName
    )

/*++

Routine Description:

    Stop a service.

Arguments:

    pszServiceName - The name of the service to stop.

Return Value:

    ERROR_SUCCESS - Service stopped successfully.

    Win32 error code - Error stopping service.

--*/

{
    SC_HANDLE       serviceHandle = NULL;
    SC_HANDLE       scManagerHandle = NULL;
    DWORD           sc = ERROR_SUCCESS;
    int             retryTime = 30*1000;  // wait 30 secs for shutdown
    int             retryTick = 300;      // 300 msec at a time
    BOOL            didStop = FALSE;
    SERVICE_STATUS  serviceStatus;

    scManagerHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

    if ( scManagerHandle == NULL )
    {
        sc = GetLastError();
        DBG_PRINT( "ResUtilStartResourceService: Cannot access service controller! Error: %u.\n", sc );
        goto Cleanup;
    }

    serviceHandle = OpenService( scManagerHandle, pszServiceName, SERVICE_ALL_ACCESS );
    if ( serviceHandle == NULL )
    {
        sc = GetLastError();
        DBG_PRINT( "ResUtilStartResourceService: Cannot open service %ws. Error: %u.\n", pszServiceName, sc );
        CloseServiceHandle(scManagerHandle);
        goto Cleanup;
    }
    CloseServiceHandle(scManagerHandle);

    for (;;)
    {
        sc = ERROR_SUCCESS;
        if ( !ControlService(serviceHandle,
                             (didStop ? SERVICE_CONTROL_INTERROGATE : SERVICE_CONTROL_STOP),
                             &serviceStatus) ) {
            sc = GetLastError();
            if ( sc == ERROR_SUCCESS )
            {
                didStop = TRUE;
                if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    DBG_PRINT( "ResUtilStartResourceService: service %ws successfully stopped.\n", pszServiceName );
                    goto Cleanup;
                }
            }
        }

        if ( (sc == ERROR_EXCEPTION_IN_SERVICE) ||
             (sc == ERROR_PROCESS_ABORTED) ||
             (sc == ERROR_SERVICE_NOT_ACTIVE) )
        {
            DBG_PRINT( "ResUtilStartResourceService: service %ws stopped or died; sc = %u.\n", pszServiceName, sc );
            sc = ERROR_SUCCESS;
            goto Cleanup;
        }

        if ( (retryTime -= retryTick) <= 0 )
        {
            DBG_PRINT( "ResUtilStartResourceService: service %ws did not stop; giving up.\n", pszServiceName, sc );
            sc = ERROR_TIMEOUT;
            goto Cleanup;
        }

        DBG_PRINT("ResUtilStartResourceService: StopResourceService retrying...\n");
        Sleep(retryTick);
    } // for: ever

Cleanup:

    CloseServiceHandle( scManagerHandle );
    CloseServiceHandle( serviceHandle );

    return sc;

} // ResUtilStopResourceService

DWORD
WINAPI
ResUtilVerifyResourceService(
    IN LPCWSTR pszServiceName
    )

/*++

Routine Description:

    Verify that a service is alive.

Arguments:

    pszServiceName - The name of the service to verify.

Return Value:

    ERROR_SUCCESS - Service is alive.

    Win32 error code - Error verifying service, or service is not alive.

--*/

{
    BOOL            success;
    SC_HANDLE       serviceHandle;
    SC_HANDLE       scManagerHandle;
    DWORD           status = ERROR_SUCCESS;
    SERVICE_STATUS  serviceStatus;

    scManagerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if ( scManagerHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT("ResUtilStartResourceService: Cannot access service controller! Error: %u.\n",
            status);
        return(status);
    }

    serviceHandle = OpenService( scManagerHandle,
                                 pszServiceName,
                                 SERVICE_QUERY_STATUS );

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        DBG_PRINT("ResUtilStartResourceService: Cannot open service %ws. Error: %u.\n",
            pszServiceName,
            status);
        CloseServiceHandle(scManagerHandle);
        return(status);
    }
    CloseServiceHandle(scManagerHandle);

    success = QueryServiceStatus( serviceHandle,
                                  &serviceStatus );

    status = GetLastError();
    CloseServiceHandle(serviceHandle);
    if ( !success ) {
        DBG_PRINT("ResUtilStartResourceService: Cannot query service %ws. Error: %u.\n",
            pszServiceName,
            status);
        return(status);
    }

    if ( (serviceStatus.dwCurrentState != SERVICE_RUNNING) &&
         (serviceStatus.dwCurrentState != SERVICE_START_PENDING) ) {
        DBG_PRINT("ResUtilStartResourceService: Service %ws is not alive: dwCurrentState: %u.\n",
            pszServiceName,
            serviceStatus.dwCurrentState);
        return(ERROR_SERVICE_NOT_ACTIVE);
    }

    return(ERROR_SUCCESS);

} // ResUtilVerifyResourceService


DWORD
WINAPI
ResUtilStopService(
    IN SC_HANDLE hServiceHandle
    )

/*++

Routine Description:

    Stop a service.

Arguments:

    hServiceHandle - The handle of the service to stop.

Return Value:

    ERROR_SUCCESS - Service stopped successfully.

    Win32 error code - Error stopping service.

Notes:

    The hServiceHandle is closed as a side effect of this routine.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       retryTime = 30*1000;  // wait 30 secs for shutdown
    DWORD       retryTick = 300;      // 300 msec at a time
    BOOL        didStop = FALSE;
    SERVICE_STATUS serviceStatus;


    for (;;)
    {

        status = ERROR_SUCCESS;
        if ( !ControlService(hServiceHandle,
                             (didStop ? SERVICE_CONTROL_INTERROGATE : SERVICE_CONTROL_STOP),
                             &serviceStatus) ) {
            status = GetLastError();
            if ( status == ERROR_SUCCESS ) {
                didStop = TRUE;
                if ( serviceStatus.dwCurrentState == SERVICE_STOPPED ) {
                    DBG_PRINT("ResUtilStartResourceService: service successfully stopped.\n" );
                    break;
                }
            }
        }

        if ( (status == ERROR_EXCEPTION_IN_SERVICE) ||
             (status == ERROR_PROCESS_ABORTED) ||
             (status == ERROR_SERVICE_NOT_ACTIVE) ) {
            DBG_PRINT("ResUtilStartResourceService: service stopped or died; status = %u.\n",
                status);
            status = ERROR_SUCCESS;
            break;
        }

        if ( (retryTime -= retryTick) <= 0 ) {
            DBG_PRINT("ResUtilStartResourceService: service did not stop; giving up.\n",
                status);
            status = ERROR_TIMEOUT;
            break;
        }

        DBG_PRINT("ResUtilStartResourceService: StopResourceService retrying...\n");
        Sleep(retryTick);
    } // for: ever

    CloseServiceHandle(hServiceHandle);

    return(status);

} // ResUtilStopResourceService

DWORD
WINAPI
ResUtilVerifyService(
    IN SC_HANDLE hServiceHandle
    )

/*++

Routine Description:

    Verify that a service is alive.

Arguments:

    hServiceHandle - The handle of the service to verify.

Return Value:

    ERROR_SUCCESS - Service is alive.

    Win32 error code - Error verifying service, or service is not alive.

--*/

{
    BOOL        success;
    DWORD       status = ERROR_SUCCESS;
    SERVICE_STATUS serviceStatus;

    success = QueryServiceStatus( hServiceHandle,
                                  &serviceStatus );
    if ( !success ) {
        status = GetLastError();
        DBG_PRINT("ResUtilStartResourceService: Cannot query service. Error: %u.\n",
            status);
        return(status);
    }

    if ( (serviceStatus.dwCurrentState != SERVICE_RUNNING) &&
         (serviceStatus.dwCurrentState != SERVICE_START_PENDING) ) {
        DBG_PRINT("ResUtilStartResourceService: Service is not alive: dwCurrentState: %u.\n",
            serviceStatus.dwCurrentState);
        return(ERROR_SERVICE_NOT_ACTIVE);
    }

    return(ERROR_SUCCESS);

} // ResUtilVerifyService


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilTerminateServiceProcessFromResDll
//
//  Description:
//      Attempt to terminate a service process from a resource DLL.
//
//  Arguments:
//      dwServicePid [IN]
//          The process ID of the service process to terminate.
//
//      bOffline [IN]
//          TRUE = called from the offline thread.
//
//      pdwResourceState [OUT]
//          State of the resource.  Optional.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
ResUtilTerminateServiceProcessFromResDll(
    IN  DWORD               dwServicePid,
    IN  BOOL                bOffline,
    OUT PDWORD              pdwResourceState,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    )
{
    DWORD   sc     = ERROR_SUCCESS;
    HANDLE  hSvcProcess = NULL;
    BOOLEAN bWasEnabled;
    DWORD   dwResourceState = ClusterResourceFailed;

    (pfnLogEvent)(
        hResourceHandle,
        LOG_INFORMATION,
        L"ResUtilTerminateServiceProcessFromResDll: Process with id=%1!u! might be terminated...\n",
        dwServicePid
        );

    //
    // Adjust the privilege to allow debug.  This is to allow termination
    // of a service process which runs in a local system account from a
    // different service process which runs in a domain user account.
    //
    sc = ClRtlEnableThreadPrivilege(
                SE_DEBUG_PRIVILEGE,
                &bWasEnabled
                );
    if ( sc != ERROR_SUCCESS )
    {
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilTerminateServiceProcessFromResDll: Unable to set debug privilege for process with id=%1!u!, status=%2!u!...\n",
            dwServicePid,
            sc
            );
        goto Cleanup;
    } // if: error enabling thread privilege

    //
    // Open the process so we can terminate it.
    //
    hSvcProcess = OpenProcess(
                        PROCESS_TERMINATE,
                        FALSE,
                        dwServicePid
                        );

    if ( hSvcProcess == NULL )
    {
        //
        //  Did this happen because the process terminated
        //  too quickly after we sent out one control request ?
        //
        sc = GetLastError();
        (pfnLogEvent)(
            hResourceHandle,
            LOG_INFORMATION,
            L"ResUtilTerminateServiceProcessFromResDll: Unable to open pid=%1!u! for termination, status=%2!u!...\n",
            dwServicePid,
            sc
            );
    } // if: error opening the process
    else
    {
        if ( ! bOffline )
        {
            (pfnLogEvent)(
                hResourceHandle,
                LOG_INFORMATION,
                L"ResUtilTerminateServiceProcessFromResDll: Pid=%1!u! will be terminated by brute force...\n",
                dwServicePid
                );
        } // if: called from Terminate
        else
        {
            //
            // Wait 3 seconds for the process to shutdown gracefully.
            //
            if ( WaitForSingleObject( hSvcProcess, 3000 )
                       == WAIT_OBJECT_0 )
            {
                (pfnLogEvent)(
                    hResourceHandle,
                    LOG_INFORMATION,
                    L"ResUtilTerminateServiceProcessFromResDll: Process with id=%1!u! shutdown gracefully...\n",
                    dwServicePid
                    );
                dwResourceState = ClusterResourceOffline;
                sc = ERROR_SUCCESS;
                goto RestoreAndCleanup;
            } // if: process exited on its own
        } // else: called from Offline

        if ( ! TerminateProcess( hSvcProcess, 0 ) )
        {
            sc = GetLastError();
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilTerminateServiceProcessFromResDll: Unable to terminate process with id=%1!u!, status=%2!u!...\n",
                dwServicePid,
                sc
                );
        } // if: error terminating the process
        else
        {
            (pfnLogEvent)(
                hResourceHandle,
                LOG_INFORMATION,
                L"ResUtilTerminateServiceProcessFromResDll: Process with id=%1!u! was terminated...\n",
                dwServicePid
                );
            dwResourceState = ClusterResourceOffline;
        } // else: process terminated successfully

    } // else: process opened successfully

RestoreAndCleanup:
    ClRtlRestoreThreadPrivilege(
        SE_DEBUG_PRIVILEGE,
        bWasEnabled
        );

Cleanup:
    if ( hSvcProcess != NULL )
    {
        CloseHandle( hSvcProcess );
    } // if: process was opened successfully

    if ( pdwResourceState != NULL )
    {
        *pdwResourceState = dwResourceState;
    } // if: caller wants the resource state

    (pfnLogEvent)(
        hResourceHandle,
        LOG_INFORMATION,
        L"ResUtilTerminateServiceProcessFromResDll: Process id=%1!u!, status=%2!u!, state=%3!u!.\n",
        dwServicePid,
        sc,
        dwResourceState
        );

    return sc;

} //*** ResUtilTerminateServiceProcessFromResDll()


LPWSTR
WINAPI
ResUtilDupString(
    IN LPCWSTR pszInString
    )

/*++

Routine Description:

    Duplicates a string.

Arguments:

    pszInString - Supplies the string to be duplicated.

Return Value:

    A pointer to a buffer containing the duplicate if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    PWSTR   pszNewString = NULL;
    size_t  cbString;
    DWORD   sc = ERROR_SUCCESS;
    HRESULT hr;

    //
    // Get the size of the parameter so we know how much to allocate.
    //
    cbString = (wcslen( pszInString ) + 1) * sizeof(WCHAR);

    //
    // Allocate a buffer to copy the string into.
    //
    pszNewString = (PWSTR) LocalAlloc( LMEM_FIXED, cbString );
    if ( pszNewString == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Copy the in string to the new string.
    //
    hr = StringCbCopyW( pszNewString, cbString, pszInString );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    }

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LocalFree( pszNewString );
        pszNewString = NULL;
    }

    SetLastError( sc );
    return pszNewString;

} // ResUtilDupString


DWORD
WINAPI
ResUtilGetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPBYTE * ppbOutValue,
    OUT LPDWORD pcbOutValueSize
    )

/*++

Routine Description:

    Queries a REG_BINARY or REG_MULTI_SZ value out of the cluster
    database and allocates the necessary storage for it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    ppbOutValue - Supplies the address of a pointer in which to return the value.

    pcbOutValueSize - Supplies the address of a DWORD in which to return the
        size of the value.

Return Value:

    ERROR_SUCCESS - The value was read successfully.

    ERROR_NOT_ENOUGH_MEMORY - Error allocating memory for the value.

    Win32 error code - The operation failed.

--*/

{
    LPBYTE value;
    DWORD valueSize;
    DWORD valueType;
    DWORD status;

    //
    // Initialize the output parameters.
    //
    *ppbOutValue = NULL;
    *pcbOutValueSize = 0;

    //
    // Get the size of the value so we know how much to allocate.
    //
    valueSize = 0;
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   NULL,
                                   &valueSize );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) ) {
        return(status);
    }

    //
    // Allocate a buffer to read the value into.
    //
    value = LocalAlloc( LMEM_FIXED, valueSize );
    if ( value == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Read the value from the cluster database.
    //
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   (LPBYTE)value,
                                   &valueSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( value );
    } else {
        *ppbOutValue = value;
        *pcbOutValueSize = valueSize;
    }

    return(status);

} // ResUtilGetBinaryValue


PWSTR
WINAPI
ResUtilGetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName
    )

/*++

Routine Description:

    Queries a REG_SZ or REG_EXPAND_SZ value out of the cluster database
    and allocates the necessary storage for it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    PWSTR   value;
    DWORD   valueSize;
    DWORD   valueType;
    DWORD   status;

    //
    // Get the size of the value so we know how much to allocate.
    //
    valueSize = 0;
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   NULL,
                                   &valueSize );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) ) {
        SetLastError( status );
        return(NULL);
    }

    //
    // Add on the size of the null terminator.
    //
    valueSize += sizeof(UNICODE_NULL);

    //
    // Allocate a buffer to read the string into.
    //
    value = LocalAlloc( LMEM_FIXED, valueSize );
    if ( value == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(NULL);
    }

    //
    // Read the value from the cluster database.
    //
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   (LPBYTE)value,
                                   &valueSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( value );
        value = NULL;
    } else if ( (valueType != REG_SZ) &&
                (valueType != REG_EXPAND_SZ) &&
                (valueType != REG_MULTI_SZ) ) {
        status = ERROR_INVALID_PARAMETER;
        LocalFree( value );
        value = NULL;
    }

    return(value);

} // ResUtilGetSzValue


PWSTR
WINAPI
ResUtilGetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN BOOL bExpand
    )

/*++

Routine Description:

    Queries a REG_EXPAND_SZ value out of the cluster database and allocates
    the necessary storage for it, optionally expanding it.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    bExpand - TRUE = return the expanded string.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    PWSTR   value;
    PWSTR   pwszExpanded = NULL;
    DWORD   valueSize;
    DWORD   valueType;
    size_t  cchExpanded;
    size_t  cchExpandedReturned;
    DWORD   sc;

    //
    // Get the size of the value so we know how much to allocate.
    //
    valueSize = 0;
    sc = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   NULL,
                                   &valueSize );
    if ( (sc != ERROR_SUCCESS) &&
         (sc != ERROR_MORE_DATA) )
    {
        SetLastError( sc );
        return(NULL);
    }

    //
    // Add on the size of the null terminator.
    //
    valueSize += sizeof(UNICODE_NULL);

    //
    // Allocate a buffer to read the string into.
    //
    value = LocalAlloc( LMEM_FIXED, valueSize );
    if ( value == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(NULL);
    }

    //
    // Read the value from the cluster database.
    //
    sc = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   (LPBYTE)value,
                                   &valueSize );
    if ( sc != ERROR_SUCCESS )
    {
        LocalFree( value );
        value = NULL;
    }
    else if ( ( valueType != REG_EXPAND_SZ ) &&
              ( valueType != REG_SZ ) )
    {
        sc = ERROR_INVALID_PARAMETER;
        LocalFree( value );
        value = NULL;
    }
    else if ( bExpand )
    {
        //
        // Expand the environment variable strings in the
        // value that was just read.
        //
        cchExpanded = valueSize / sizeof( WCHAR );
        for (;;)
        {
            //
            // Allocate the buffer for the expansion string.  This will
            // get double each time we are told it is too small.
            //
            pwszExpanded = LocalAlloc( LMEM_FIXED, cchExpanded * sizeof( WCHAR ) );
            if ( pwszExpanded == NULL )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            else
            {
                //
                // Expand the environment variables in the value.
                // If the buffer isn't big enough, we will loop up to
                // the top of the loop and allocate a bigger buffer.
                //
                cchExpandedReturned = ExpandEnvironmentStringsW(
                                                        value,
                                                        pwszExpanded,
                                                        (DWORD)cchExpanded );

                if ( cchExpandedReturned == 0 )
                {
                    sc = GetLastError();
                    break;
                }
                else if ( cchExpandedReturned > cchExpanded )
                {
                    cchExpanded *= 2;
                    LocalFree( pwszExpanded );
                    pwszExpanded = NULL;
                    continue;
                }
                else
                {
                    sc = ERROR_SUCCESS;
                    break;
                }
            }
        } // for: ever

        //
        // If any errors occurred, cleanup.
        // Otherwise, return expanded string.
        //
        if ( sc != ERROR_SUCCESS )
        {
            LocalFree( pwszExpanded );
            LocalFree( value );
            value = NULL;
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }
        else
        {
            LocalFree( value );
            value = pwszExpanded;
        }
    } // else: expand

    return(value);

} // ResUtilGetExpandSzValue


DWORD
WINAPI
ResUtilGetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    OUT LPDWORD pdwOutValue,
    IN DWORD dwDefaultValue
    )

/*++

Routine Description:

    Queries a REG_DWORD value out of the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored

    pszValueName - Supplies the name of the value.

    pdwOutValue - Supplies the address of a DWORD in which to return the value.

    dwDefaultValue - Value to return if the parameter is not found.

Return Value:

    ERROR_SUCCESS - The value was read successfully.

    Win32 error code - The operation failed.

--*/

{
    DWORD value;
    DWORD valueSize;
    DWORD valueType;
    DWORD status;

    //
    // Initialize the output value.
    //
    *pdwOutValue = 0;

    //
    // Read the value from the cluster database.
    //
    valueSize = sizeof(DWORD);
    status = ClusterRegQueryValue( hkeyClusterKey,
                                   pszValueName,
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueSize );
    if ( status == ERROR_SUCCESS ) {
        if ( valueType != REG_DWORD ) {
            status = ERROR_INVALID_PARAMETER;
        } else {
            *pdwOutValue = value;
        }
    } else if ( status == ERROR_FILE_NOT_FOUND ) {
        *pdwOutValue = dwDefaultValue;
        status = ERROR_SUCCESS;
    }

    return(status);

} // ResUtilGetDwordValue


DWORD
WINAPI
ResUtilSetBinaryValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN const LPBYTE pbNewValue,
    IN DWORD cbNewValueSize,
    IN OUT LPBYTE * ppbOutValue,
    IN OUT LPDWORD pcbOutValueSize
    )

/*++

Routine Description:

    Sets a REG_BINARY value in a pointer, deallocating a previous value
    if necessary, and sets the value in the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored.

    pszValueName - Supplies the name of the value.

    pbNewValue - Supplies the new binary value.

    cbNewValueSize - Supplies the size of the new value.

    ppbOutValue - Supplies pointer to the binary pointer in which to set
        the value.

    pcbOutValueSize - Supplies a pointer to a size DWORD in which to set
        the size of the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred attempting to allocate memory.

    Win32 error code - The operation failed.

--*/

{
    DWORD       status;
    LPBYTE      allocedValue = NULL;

    if ( ppbOutValue != NULL )
    {
        //
        // Allocate memory for the new value.
        //
        allocedValue = LocalAlloc( LMEM_FIXED, cbNewValueSize );
        if ( allocedValue == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    status = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_BINARY,
                                 pbNewValue,
                                 cbNewValueSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( allocedValue );
        return(status);
    }

    if ( ppbOutValue != NULL )
    {
        //
        // Copy the new value to the output buffer.
        //
        CopyMemory( allocedValue, pbNewValue, cbNewValueSize );

        // Set the new value in the output pointer.
        if ( *ppbOutValue != NULL ) {
            LocalFree( *ppbOutValue );
        }
        *ppbOutValue = allocedValue;
        *pcbOutValueSize = cbNewValueSize;
    }

    return(ERROR_SUCCESS);

} // ResUtilSetBinaryValue


DWORD
WINAPI
ResUtilSetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN OUT LPWSTR * ppszOutValue
    )

/*++

Routine Description:

    Sets a REG_SZ value in a pointer, deallocating a previous value
    if necessary, and sets the value in the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored.

    pszValueName - Supplies the name of the value.

    pszNewValue - Supplies the new string value.

    ppszOutValue - Supplies pointer to the string pointer in which to set
        the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred attempting to allocate memory.

    Win32 error code - The operation failed.

--*/

{
    DWORD       sc = ERROR_SUCCESS;
    size_t      cbData;
    LPWSTR      pwszAllocedValue = NULL;
    HRESULT     hr;

    cbData = (wcslen( pszNewValue ) + 1) * sizeof(WCHAR);

    if ( ppszOutValue != NULL )
    {
        //
        // Allocate memory for the new value string.
        //
        pwszAllocedValue = LocalAlloc( LMEM_FIXED, cbData );
        if ( pwszAllocedValue == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    sc = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_SZ,
                                 (CONST BYTE*)pszNewValue,
                                 (DWORD)cbData );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    if ( ppszOutValue != NULL )
    {
        //
        // Copy the new value to the output buffer.
        //
        hr = StringCbCopyW( pwszAllocedValue, cbData, pszNewValue );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        // Set the new value in the output string pointer.
        if ( *ppszOutValue != NULL )
        {
            LocalFree( *ppszOutValue );
        }
        *ppszOutValue = pwszAllocedValue;
        pwszAllocedValue = NULL;
    }

    sc = ERROR_SUCCESS;

Cleanup:

    LocalFree( pwszAllocedValue );

    return sc;

} // ResUtilSetSzValue


DWORD
WINAPI
ResUtilSetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN OUT LPWSTR * ppszOutValue
    )

/*++

Routine Description:

    Sets a REG_EXPAND_SZ value in a pointer, deallocating a previous value
    if necessary, and sets the value in the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the value is stored.

    pszValueName - Supplies the name of the value.

    pszNewValue - Supplies the new string value.

    ppszOutValue - Supplies pointer to the string pointer in which to set
        the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred attempting to allocate memory.

    Win32 error code - The operation failed.

--*/

{
    DWORD       sc;
    DWORD       dataSize;
    PWSTR       allocedValue = NULL;
    HRESULT     hr;

    dataSize = ((DWORD) wcslen( pszNewValue ) + 1) * sizeof(WCHAR);

    if ( ppszOutValue != NULL ) {
        //
        // Allocate memory for the new value string.
        //
        allocedValue = LocalAlloc( LMEM_FIXED, dataSize );
        if ( allocedValue == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    sc = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_EXPAND_SZ,
                                 (CONST BYTE*)pszNewValue,
                                 dataSize );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    if ( ppszOutValue != NULL )
    {
        //
        // Copy the new value to the output buffer.
        //
        hr = StringCbCopyW( allocedValue, dataSize, pszNewValue );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        }

        // Set the new value in the output string pointer.
        if ( *ppszOutValue != NULL )
        {
            LocalFree( *ppszOutValue );
        }
        *ppszOutValue = allocedValue;
        allocedValue = NULL;
    }

    sc = ERROR_SUCCESS;

Cleanup:

    LocalFree( allocedValue );

    return sc;

} // ResUtilSetSzValue


DWORD
WINAPI
ResUtilSetMultiSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN LPCWSTR pszNewValue,
    IN DWORD cbNewValueSize,
    IN OUT LPWSTR * ppszOutValue,
    IN OUT LPDWORD pcbOutValueSize
    )

/*++

Routine Description:

    Sets a REG_MULTI_SZ value in a pointer, deallocating a previous value
    if necessary, and sets the value in the cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the ValueName is stored.

    pszValueName - Supplies the name of the value.

    pszNewValue - Supplies the new MULTI_SZ value.

    cbNewValueSize - Supplies the size of the new value.

    ppszOutValue - Supplies a pointer to the string pointer in which to set
        the value.

    pcbOutValueSize - Supplies a pointer to a size DWORD in which to set
        the size of the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred attempting to allocate memory.

    Win32 error code - The operation failed.

--*/

{
    DWORD       status;
    LPWSTR      allocedValue = NULL;

    if ( ppszOutValue != NULL )
    {
        //
        // Allocate memory for the new value.
        //
        allocedValue = LocalAlloc( LMEM_FIXED, cbNewValueSize );
        if ( allocedValue == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    status = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_MULTI_SZ,
                                 (CONST BYTE*)pszNewValue,
                                 cbNewValueSize );
    if ( status != ERROR_SUCCESS ) {
        LocalFree(allocedValue);
        return(status);
    }

    if ( ppszOutValue != NULL )
    {
        //
        // Copy the new value to the output buffer.
        //
        CopyMemory( allocedValue, pszNewValue, cbNewValueSize );

        // Set the new value in the output pointer.
        if ( *ppszOutValue != NULL ) {
            LocalFree( *ppszOutValue );
        }
        *ppszOutValue = allocedValue;
        *pcbOutValueSize = cbNewValueSize;
    }

    return(ERROR_SUCCESS);

} // ResUtilSetMultiSzValue


DWORD
WINAPI
ResUtilSetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN DWORD dwNewValue,
    IN OUT LPDWORD pdwOutValue
    )

/*++

Routine Description:

    Sets a REG_DWORD value in a pointer and sets the value in the
    cluster database.

Arguments:

    hkeyClusterKey - Supplies the cluster key where the property is stored.

    pszValueName - Supplies the name of the value.

    dwNewValue - Supplies the new DWORD value.

    pdwOutValue - Supplies pointer to the DWORD pointer in which to set
        the value.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    Win32 error code - The operation failed.

--*/

{
    DWORD       status;

    //
    // Set the value in the cluster database.
    //
    // _ASSERTE( hkeyClusterKey != NULL );
    // _ASSERTE( pszValueName != NULL );
    status = ClusterRegSetValue( hkeyClusterKey,
                                 pszValueName,
                                 REG_DWORD,
                                 (CONST BYTE*)&dwNewValue,
                                 sizeof(DWORD) );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    if ( pdwOutValue != NULL )
    {
        //
        // Copy the new value to the output buffer.
        //
        *pdwOutValue = dwNewValue;
    }

    return(ERROR_SUCCESS);

} // ResUtilSetDwordValue


DWORD
WINAPI
ResUtilGetBinaryProperty(
    OUT LPBYTE * ppbOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSPROP_BINARY pValueStruct,
    IN const LPBYTE pbOldValue,
    IN DWORD cbOldValueSize,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    )

/*++

Routine Description:

    Gets a binary property from a property list and advances the pointers.

Arguments:

    ppbOutValue - Supplies the address of a pointer in which to return a
        pointer to the binary value in the property list.

    pcbOutValueSize - Supplies the address of the output value size.

    pValueStruct - Supplies the binary value from the property list.

    pbOldValue - Supplies the previous value for this property.

    cbOldValueSize - Supplies the previous value's size.

    ppPropertyList - Supplies the address of the pointer to the property list
        buffer which will be advanced to the beginning of the next property.

    pcbPropertyListSize - Supplies a pointer to the buffer size which will be
        decremented to account for this property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    Win32 error code - The operation failed.

--*/

{
    BOOL    propChanged = FALSE;
    DWORD   arrayIndex;
    DWORD   dataSize;

    //
    // Make sure the buffer is big enough and
    // the value is formatted correctly.
    //
    dataSize = sizeof(*pValueStruct) + ALIGN_CLUSPROP( pValueStruct->cbLength );
    if ( (*pcbPropertyListSize < dataSize) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_BINARY) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // If the value changed, point to the new value.
    //
    if ( (pbOldValue == NULL) ||
         (cbOldValueSize != pValueStruct->cbLength) ) {
        propChanged = TRUE;
    } else {
        for ( arrayIndex = 0 ; arrayIndex < cbOldValueSize ; arrayIndex++ ) {
            if ( pValueStruct->rgb[arrayIndex] != pbOldValue[arrayIndex] ) {
                propChanged = TRUE;
                break;
            }
        }
    }
    if ( propChanged ) {
        *ppbOutValue = pValueStruct->rgb;
        *pcbOutValueSize = pValueStruct->cbLength;
    }

    //
    // Decrement remaining buffer size and move to the next property.
    //
    *pcbPropertyListSize -= dataSize;
    *ppPropertyList += dataSize;

    return(ERROR_SUCCESS);

} // ResUtilGetBinaryProperty


DWORD
WINAPI
ResUtilGetSzProperty(
    OUT LPWSTR * ppszOutValue,
    IN const PCLUSPROP_SZ pValueStruct,
    IN LPCWSTR pszOldValue,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    )

/*++

Routine Description:

    Gets a string property from a property list and advances the pointers.

Arguments:

    ppszOutValue - Supplies the address of a pointer in which to return a
        pointer to the string in the property list.

    pValueStruct - Supplies the string value from the property list.

    pszOldValue - Supplies the previous value for this property.

    ppPropertyList - Supplies the address of the pointer to the property list
        buffer which will be advanced to the beginning of the next property.

    pcbPropertyListSize - Supplies a pointer to the buffer size which will be
        decremented to account for this property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    Win32 error code - The operation failed.

--*/

{
    DWORD   dataSize;
    DWORD   sc = ERROR_SUCCESS;

    //
    // Make sure the buffer is big enough and
    // the value is formatted correctly.
    //
    dataSize = sizeof(*pValueStruct) + ALIGN_CLUSPROP( pValueStruct->cbLength );
    if ( (*pcbPropertyListSize < dataSize) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_SZ) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_EXPAND_SZ) )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If the value changed, point to the new value.
    // Do this even if only the case of the value changed.
    //
    if ( (pszOldValue == NULL) ||
         (wcsncmp( pValueStruct->sz, pszOldValue, pValueStruct->cbLength / sizeof( WCHAR ) ) != 0)
       )
    {
        *ppszOutValue = pValueStruct->sz;
    }

    //
    // Decrement remaining buffer size and move to the next property.
    //
    *pcbPropertyListSize -= dataSize;
    *ppPropertyList += dataSize;

Cleanup:

    return sc;

} // ResUtilGetSzProperty


DWORD
WINAPI
ResUtilGetMultiSzProperty(
    OUT LPWSTR * ppszOutValue,
    OUT LPDWORD pcbOutValueSize,
    IN const PCLUSPROP_SZ pValueStruct,
    IN LPCWSTR pszOldValue,
    IN DWORD cbOldValueSize,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    )

/*++

Routine Description:

    Gets a binary property from a property list and advances the pointers.

Arguments:

    ppszOutValue - Supplies the address of a pointer in which to return a
        pointer to the binary value in the property list.

    pcbOutValueSize - Supplies the address of the output value size.

    pValueStruct - Supplies the string value from the property list.

    pszOldValue - Supplies the previous value for this property.

    cbOldValueSize - Supplies the previous value's size.

    ppPropertyList - Supplies the address of the pointer to the property list
        buffer which will be advanced to the beginning of the next property.

    pcbPropertyListSize - Supplies a pointer to the buffer size which will be
        decremented to account for this property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    Win32 error code - The operation failed.

--*/

{
    BOOL    propChanged = FALSE;
    DWORD   dataSize;

    //
    // Make sure the buffer is big enough and
    // the value is formatted correctly.
    //
    dataSize = sizeof(*pValueStruct) + ALIGN_CLUSPROP( pValueStruct->cbLength );
    if ( (*pcbPropertyListSize < dataSize) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_MULTI_SZ) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // If the value changed, point to the new value.
    //
    if ( (pszOldValue == NULL) ||
         (cbOldValueSize != pValueStruct->cbLength) ) {
        propChanged = TRUE;
    } else if ( memcmp( pValueStruct->sz, pszOldValue, cbOldValueSize ) != 0 ) {
        propChanged = TRUE;
    }
    if ( propChanged ) {
        *ppszOutValue = pValueStruct->sz;
        *pcbOutValueSize = pValueStruct->cbLength;
    }

    //
    // Decrement remaining buffer size and move to the next property.
    //
    *pcbPropertyListSize -= dataSize;
    *ppPropertyList += dataSize;

    return(ERROR_SUCCESS);

} // ResUtilGetMultiSzProperty


DWORD
WINAPI
ResUtilGetDwordProperty(
    OUT LPDWORD pdwOutValue,
    IN const PCLUSPROP_DWORD pValueStruct,
    IN DWORD dwOldValue,
    IN DWORD dwMinimum,
    IN DWORD dwMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    )

/*++

Routine Description:

    Gets a DWORD property from a property list and advances the pointers.

Arguments:

    pdwOutValue - Supplies the address of a pointer in which to return a
        pointer to the string in the property list.

    pValueStruct - Supplies the DWORD value from the property list.

    dwOldValue - Supplies the previous value for this property.

    dwMinimum - Minimum value the value can have. If both Minimum and Maximum
        are 0, no range check will be done.

    dwMaximum - Maximum value the value can have.

    ppPropertyList - Supplies the address of the pointer to the property list
        buffer which will be advanced to the beginning of the next property.

    pcbPropertyListSize - Supplies a pointer to the buffer size which will be
        decremented to account for this property.

Return Value:

    ERROR_SUCCESS - The operation completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    Win32 error code - The operation failed.

--*/

{
    size_t  cbData;
    DWORD   sc = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER( dwOldValue );

    //
    // Make sure the buffer is big enough and
    // the value is formatted correctly.
    //
    cbData = sizeof(*pValueStruct);
    if ( (*pcbPropertyListSize < cbData) ||
         (pValueStruct->Syntax.wFormat != CLUSPROP_FORMAT_DWORD) ||
         (pValueStruct->cbLength != sizeof(DWORD)) )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Make sure the value is in range.
    //
    if ( (dwMinimum != 0) && (dwMaximum != 0) )
    {
        if ( (pValueStruct->dw < dwMinimum) ||
             (pValueStruct->dw > dwMaximum) )
        {
            sc = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    //
    // Set to the new value.
    //
    *pdwOutValue = pValueStruct->dw;

    //
    // Decrement remaining buffer size and move to the next property.
    //
    *pcbPropertyListSize -= (DWORD) cbData;
    *ppPropertyList += cbData;

Cleanup:

    return sc;

} // ResUtilGetDwordProperty

static DWORD
ScBuildNetNameEnvironment(
    IN      LPWSTR      pszNetworkName,
    IN      DWORD       cchNetworkNameBufferSize,
    IN OUT  LPVOID *    ppvEnvironment              OPTIONAL
    )
{
    UNICODE_STRING  usValueName;
    UNICODE_STRING  usValue;
    DWORD           sc = ERROR_SUCCESS;
    NTSTATUS        ntStatus;
    DWORD           cchDomain;
    DWORD           cchNetworkName = (DWORD)wcslen( pszNetworkName );
    PVOID           pvEnvBlock = NULL;

    //
    // validate parameters
    //
    if ( cchNetworkName == 0 ||
         cchNetworkNameBufferSize == 0 ||
         pszNetworkName == NULL ||
         *pszNetworkName == UNICODE_NULL
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // if no env. block was passed in, create one since the RTL routines will
    // modify the current process' environment if NULL is passed into
    // RtlSetEnvironmentVariable
    //
    if ( *ppvEnvironment == NULL )
    {
        ntStatus = RtlCreateEnvironment( FALSE,                 // don't clone current environment
                                         &pvEnvBlock );

        if ( ! NT_SUCCESS( ntStatus ))
        {
            sc = RtlNtStatusToDosError( ntStatus );
            goto Error;
        }
    }
    else
    {
        pvEnvBlock = *ppvEnvironment;
    }

    //
    // Add the virtual netname to the cloned environment
    //
    RtlInitUnicodeString( &usValueName, L"_CLUSTER_NETWORK_NAME_" );
    RtlInitUnicodeString( &usValue, pszNetworkName );

    ntStatus = RtlSetEnvironmentVariable(
                    &pvEnvBlock,
                    &usValueName,
                    &usValue
                    );
    if ( ! NT_SUCCESS( ntStatus ) )
    {
        sc = RtlNtStatusToDosError( ntStatus );
        goto Error;
    }

    //
    // add the netname as the DNS hostname
    //
    RtlInitUnicodeString( &usValueName, L"_CLUSTER_NETWORK_HOSTNAME_" );

    ntStatus = RtlSetEnvironmentVariable(
                    &pvEnvBlock,
                    &usValueName,
                    &usValue
                    );
    if ( ! NT_SUCCESS( ntStatus ) )
    {
        sc = RtlNtStatusToDosError( ntStatus );
        goto Error;
    }

    //
    // Change the COMPUTERNAME environment variable to match.
    //
    RtlInitUnicodeString( &usValueName, L"COMPUTERNAME" );
    ntStatus = RtlSetEnvironmentVariable(
                    &pvEnvBlock,
                    &usValueName,
                    &usValue
                    );
    if ( ! NT_SUCCESS( ntStatus ) )
    {
        sc = RtlNtStatusToDosError( ntStatus );
        goto Error;
    }

    //
    // Now generate the string for the FQDN
    //
    RtlInitUnicodeString( &usValueName, L"_CLUSTER_NETWORK_FQDN_" );

    pszNetworkName[ cchNetworkName ] = L'.';
    cchDomain = cchNetworkNameBufferSize - cchNetworkName - 1;

    if ( GetComputerNameExW(
                ComputerNameDnsDomain,
                &pszNetworkName[ cchNetworkName + 1 ],
                &cchDomain )
                )
    {
        if ( cchDomain == 0 )
        {
            pszNetworkName[ cchNetworkName ] = L'\0';
        }
    }
    else
    {
        //
        // Error from trying to get the DNS Domain name.
        // Just don't set the DnsDomain name!
        //
        goto Error;
    }

    RtlInitUnicodeString( &usValue, pszNetworkName );

    //
    // Add in the FQDN name
    //
    ntStatus = RtlSetEnvironmentVariable(
                    &pvEnvBlock,
                    &usValueName,
                    &usValue
                    );
    if ( ! NT_SUCCESS( ntStatus ) )
    {
        sc = RtlNtStatusToDosError( ntStatus );
        goto Error;
    }

Exit:
    *ppvEnvironment = pvEnvBlock;
    return sc;

Error:
    if ( pvEnvBlock != NULL )
    {
        RtlDestroyEnvironment( pvEnvBlock );
        pvEnvBlock = NULL;
    }
    goto Exit;

} // ScBuildNetNameEnvironment

static DWORD
ScGetNameFromNetnameResource(
    HRESOURCE   hNetNameResource,
    LPWSTR *    ppszNetworkName
    )
{
    DWORD           sc = ERROR_SUCCESS;
    BOOL            fSuccess = FALSE;
    LPWSTR          pszNetworkName = NULL;
    DWORD           cchNetworkName = 0;
    DWORD           cchAllocSize = 0;

    //
    // First find out the network name
    //
    cchNetworkName = DNS_MAX_NAME_BUFFER_LENGTH;
    cchAllocSize = cchNetworkName;
    pszNetworkName = LocalAlloc( LMEM_FIXED, cchAllocSize * sizeof( pszNetworkName[ 0 ] ) );
    if ( pszNetworkName == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    fSuccess = GetClusterResourceNetworkName(
                      hNetNameResource
                    , pszNetworkName
                    , &cchNetworkName
                    );
    if ( ! fSuccess )
    {
        sc = GetLastError();
        if ( sc == ERROR_MORE_DATA )
        {
            LocalFree( pszNetworkName );
            cchNetworkName++;
            cchNetworkName *= 2;
            cchAllocSize = cchNetworkName;
            pszNetworkName = LocalAlloc( LMEM_FIXED, cchAllocSize * sizeof( pszNetworkName[ 0 ] ) );
            if ( pszNetworkName == NULL )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            } // if:
            fSuccess = GetClusterResourceNetworkName(
                              hNetNameResource
                            , pszNetworkName
                            , &cchNetworkName
                            );
        }
        if ( ! fSuccess )
        {
            sc = GetLastError();
            goto Cleanup;
        }
    } // if: !fSuccess

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        LocalFree( pszNetworkName );
        pszNetworkName = NULL;
        SetLastError( sc );
    }

    *ppszNetworkName = pszNetworkName;

    return cchAllocSize;
} // ScGetNameFromNetnameResource

LPVOID
WINAPI
ResUtilGetEnvironmentWithNetName(
    IN HRESOURCE hResource
    )
/*++

Routine Description:

    Creates an environment block based on the current thread or process
    token's environment block, but with the addition of a
    _CLUSTER_NETWORK_NAME=xxx environment value. xxx in this case represents
    the network name of the supplied resource. This environment block is
    suitable for passing to CreateProcess to create an environment that will
    cause GetComputerName to lie to the application.

    THIS API SHOULDN'T BE USED TO CREATE A SERVICE'S ENVIRONMENT unless the
    service runs in the same user account context as that of the caller. The
    service will end up with the caller's environment instead of the account
    associated with the service. Use ResUtilSetResourceServiceEnvironment for
    this purpose.
 
    _CLUSTER_NETWORK_FQDN_ will be set to the fully qualified DNS name using
    the primary DNS suffix for this node.

Arguments:

    hResource - Supplies the resource

Return Value:

    pointer to the environment block if successful.

    NULL otherwise

--*/

{
    PVOID           pvEnvironment = NULL;
    DWORD           sc = ERROR_SUCCESS;
    NTSTATUS        ntStatus;
    BOOL            fSuccess;
    LPWSTR          pszNetworkName = NULL;
    DWORD           cchNetworkNameBufferSize;
    HANDLE          hToken = NULL;

    //
    // get the Name property of the netname represented by hResource
    //
    cchNetworkNameBufferSize = ScGetNameFromNetnameResource( hResource, &pszNetworkName );
    if ( pszNetworkName == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    //
    // see if the calling thread has a token. If so, we'll use that token's
    // identity for getting the environment. If not, get the current process
    // token. If that fails, we revert to using just the system environment
    // area.
    //
    fSuccess = OpenThreadToken(GetCurrentThread(),
                               TOKEN_IMPERSONATE | TOKEN_QUERY,
                               TRUE,
                               &hToken);
    if ( !fSuccess )
    {
        OpenProcessToken(GetCurrentProcess(),
                         TOKEN_IMPERSONATE | TOKEN_QUERY,
                         &hToken );
    }

    //
    // Clone the current environment, picking up any changes that might have
    // been made after resmon started
    //
    fSuccess = CreateEnvironmentBlock( &pvEnvironment, hToken, FALSE );

    if ( ! fSuccess )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    ntStatus = ScBuildNetNameEnvironment( pszNetworkName, cchNetworkNameBufferSize, &pvEnvironment );
    if ( ! NT_SUCCESS( ntStatus ) )
    {
        sc = RtlNtStatusToDosError( ntStatus );
        goto Error;
    }

Cleanup:
    CloseHandle( hToken );
    LocalFree( pszNetworkName );

    SetLastError( sc );
    return pvEnvironment;

Error:
    if ( pvEnvironment != NULL )
    {
        RtlDestroyEnvironment( pvEnvironment );
        pvEnvironment = NULL;
    }
    goto Cleanup;

} // ResUtilGetEnvironmentWithNetName


//***************************************************************************
//
//     Worker thread routines
//
//***************************************************************************


DWORD
WINAPI
ClusWorkerStart(
    IN PWORK_CONTEXT pContext
    )
/*++

Routine Description:

    Wrapper routine for cluster resource worker startup

Arguments:

    Context - Supplies the context block. This will be freed.

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD Status;
    WORK_CONTEXT Context;

    //
    // Capture our parameters and free the work context.
    //
    Context = *pContext;
    LocalFree(pContext);

    //
    // Call the worker routine
    //
    Status = (Context.lpStartRoutine)(Context.Worker, Context.lpParameter);

    //
    // Synchronize and clean up properly.
    //
    EnterCriticalSection(&ResUtilWorkerLock);
    if (!Context.Worker->Terminate) {
        CloseHandle(Context.Worker->hThread);
        Context.Worker->hThread = NULL;
    }
    Context.Worker->Terminate = TRUE;
    LeaveCriticalSection(&ResUtilWorkerLock);

    return(Status);

} // ClusWorkerStart

DWORD
WINAPI
ClusWorkerCreate(
    OUT PCLUS_WORKER lpWorker,
    IN PWORKER_START_ROUTINE lpStartAddress,
    IN PVOID lpParameter
    )
/*++

Routine Description:

    Common wrapper for resource DLL worker threads. Provides
    "clean" terminate semantics

Arguments:

    lpWorker - Returns an initialized worker structure

    lpStartAddress - Supplies the worker thread routine

    lpParameter - Supplies the parameter to be passed to the
        worker thread routine

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PWORK_CONTEXT Context;
    DWORD ThreadId;
    DWORD Status;

    Context = LocalAlloc(LMEM_FIXED, sizeof(WORK_CONTEXT));
    if (Context == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Context->Worker = lpWorker;
    Context->lpParameter = lpParameter;
    Context->lpStartRoutine = lpStartAddress;

    lpWorker->Terminate = FALSE;
    lpWorker->hThread = CreateThread(NULL,
                                   0,
                                   ClusWorkerStart,
                                   Context,
                                   0,
                                   &ThreadId);
    if (lpWorker->hThread == NULL) {
        Status = GetLastError();
        LocalFree(Context);
        return(Status);
    }
    return(ERROR_SUCCESS);

} // ClusWorkerCreate


BOOL
WINAPI
ClusWorkerCheckTerminate(
    IN PCLUS_WORKER lpWorker
    )
/*++

Routine Description:

    Checks to see if the specified Worker thread should exit ASAP.

Arguments:

    lpWorker - Supplies the worker

Return Value:

    TRUE if the thread should exit.

    FALSE otherwise

--*/

{
    return(lpWorker->Terminate);

} // ClusWorkerCheckTerminate


VOID
WINAPI
ClusWorkerTerminate(
    IN PCLUS_WORKER lpWorker
    )
/*++

Routine Description:

    Checks to see if the specified Worker thread should exit ASAP.

Arguments:

    lpWorker - Supplies the worker

Return Value:

    None.

--*/

{
    //
    // N.B.  There is a race condition here if multiple threads
    //       call this routine on the same worker. The first one
    //       through will set Terminate. The second one will see
    //       that Terminate is set and return immediately without
    //       waiting for the Worker to exit. Not really any nice
    //       way to fix this without adding another synchronization
    //       object.
    //

    if ((lpWorker->hThread == NULL) ||
        (lpWorker->Terminate)) {
        return;
    }
    EnterCriticalSection(&ResUtilWorkerLock);
    if (!lpWorker->Terminate) {
        lpWorker->Terminate = TRUE;
        LeaveCriticalSection(&ResUtilWorkerLock);
        WaitForSingleObject(lpWorker->hThread, INFINITE);
        CloseHandle(lpWorker->hThread);
        lpWorker->hThread = NULL;
    } else {
        LeaveCriticalSection(&ResUtilWorkerLock);
    }
    return;

} // ClusWorkerTerminate


DWORD
WINAPI
ResUtilCreateDirectoryTree(
    IN LPCWSTR pszPath
    )

/*++

Routine Description:

    Creates all the directories in the specified path.
    ERROR_ALREADY_EXISTS will never be returned by this routine.

Arguments:

    pszPath - String containing a path.

Return Value:

    ERROR_SUCCESS - The operation completed successfully

    Win32 error code - The operation failed.

--*/

{
    return( ClRtlCreateDirectory( pszPath ) );

} // ResUtilCreateDirectoryTree


BOOL
WINAPI
ResUtilIsPathValid(
    IN LPCWSTR pszPath
    )

/*++

Routine Description:

    Returns true if the given path looks syntactically valid.

    This call is NOT network-aware.

Arguments:

    pszPath - String containing a path.

Return Value:

    TRUE if the path looks valid, otherwise FALSE.

--*/

{
    return( ClRtlIsPathValid( pszPath ) );

} // ResUtilIsPathValid


DWORD
WINAPI
ResUtilFreeEnvironment(
    IN LPVOID lpEnvironment
    )

/*++

Routine Description:

    Destroys an environment variable block.

Arguments:

    Environment - the environment variable block to destroy.

Return Value:

    A Win32 error code.

--*/

{
    NTSTATUS  ntStatus;

    ntStatus = RtlDestroyEnvironment( lpEnvironment );

    return( RtlNtStatusToDosError(ntStatus) );

} // ResUtilFreeEnvironment


LPWSTR
WINAPI
ResUtilExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    )

/*++

Routine Description:

    Expands environment strings and returns an allocated buffer containing
    the result.

Arguments:

    pszSrc - Source string to expand.

Return Value:

    A pointer to a buffer containing the value if successful.

    NULL if unsuccessful.  Call GetLastError() to get more details.

--*/

{
    return( ClRtlExpandEnvironmentStrings( pszSrc ) );

} // ResUtilExpandEnvironmentStrings


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilSetResourceServiceEnvironment
//
//  Description:
//      Write an additional netname based environment for the specified
//      service. SCM will add these vars to the target service's environment
//      such that the hostname APIs (GetComputerName, et. al.) will provide
//      the netname as the hostname instead of the normal hostname.
//
//  Arguments:
//      pszServiceName [IN]
//          Name of service whose environment is to be augmented.
//
//      hResource [IN]
//          Handle to resource that is dependent on a netname resource.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      hResourceHandle [IN]
//          Handle of hResource for logging.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ResUtilSetResourceServiceEnvironment(
    IN  LPCWSTR             pszServiceName,
    IN  HRESOURCE           hResource,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    )
{
    DWORD       sc = ERROR_SUCCESS;
    DWORD       cbEnvironment = 0;
    PVOID       pvEnvironment = NULL;
    LPWSTR      pszEnvString = NULL;
    HKEY        hkeyServicesKey = NULL;
    HKEY        hkeyServiceName = NULL;
    LPWSTR      pszNetworkName = NULL;
    DWORD       cchNetworkNameBufferSize = 0;

    //
    // get the Name property from the netname resource represented by
    // hResource
    //
    cchNetworkNameBufferSize = ScGetNameFromNetnameResource( hResource, &pszNetworkName );
    if ( pszNetworkName == NULL )
    {
        sc = GetLastError();
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceEnvironment: Failed to get the Name property "
            L"of this resource, error = %1!u!.\n",
            sc
            );
        goto Cleanup;
    }

    //
    // now get only the env. vars that cause the hostname APIs to report the
    // netname as the hostname
    //
    sc = ScBuildNetNameEnvironment( pszNetworkName, cchNetworkNameBufferSize, &pvEnvironment );
    if ( sc != ERROR_SUCCESS )
    {
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceEnvironment: Failed to build the target service's "
            L"environment for this resource, error = %1!u!.\n",
            sc
            );
        goto Cleanup;
    }

    //
    // Compute the size of the environment. We are looking for
    // the double NULL terminator that ends the environment block.
    //
    pszEnvString = (LPWSTR) pvEnvironment;
    while ( *pszEnvString != L'\0' )
    {
        while ( *pszEnvString++ != L'\0')
        {
        } // while: more characters in this environment string
    } // while: more environment strings
    cbEnvironment = (DWORD)((PUCHAR)pszEnvString - (PUCHAR)pvEnvironment) + sizeof( WCHAR );

    //
    // Open the Services key in the registry.
    //
    sc = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    L"System\\CurrentControlSet\\Services",
                    0,
                    KEY_READ,
                    &hkeyServicesKey
                    );
    if ( sc != ERROR_SUCCESS )
    {
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceEnvironment: Failed to open services key, error = %1!u!.\n",
            sc
            );
        goto Cleanup;
    } // if: error opening the Services key in the registry

    //
    // Open the service name key in the registry
    //
    sc = RegOpenKeyExW(
                    hkeyServicesKey,
                    pszServiceName,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkeyServiceName
                    );
    RegCloseKey( hkeyServicesKey );
    if ( sc != ERROR_SUCCESS )
    {
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceEnvironment: Failed to open service key, error = %1!u!.\n",
            sc
            );
        goto Cleanup;
    } // if: error opening the service name key in the registry

    //
    // Set the environment value in the service's registry key.
    //
    sc = RegSetValueExW(
                    hkeyServiceName,
                    L"Environment",
                    0,
                    REG_MULTI_SZ,
                    (const BYTE *) pvEnvironment,
                    cbEnvironment
                    );
    RegCloseKey( hkeyServiceName );
    if ( sc != ERROR_SUCCESS )
    {
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceEnvironment: Failed to set service environment value, error = %1!u!.\n",
            sc
            );
        goto Cleanup;
    } // if: error setting the Environment value in the registry

Cleanup:

    LocalFree( pszNetworkName );

    if ( pvEnvironment != NULL )
    {
        ResUtilFreeEnvironment( pvEnvironment );
    } // if: environment block allocated

    return sc;

} //*** ResUtilSetResourceServiceEnvironment()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilRemoveResourceServiceEnvironment
//
//  Description:
//      Remove the "netname" environment variables for the specified service.
//
//  Arguments:
//      pszServiceName [IN]
//          Name of service whose environment is to be set.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ResUtilRemoveResourceServiceEnvironment(
    IN  LPCWSTR             pszServiceName,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    )
{
    DWORD       sc;
    HKEY        hkeyServicesKey;
    HKEY        hkeyServiceName;

    //
    // Open the Services key in the registry.
    //
    sc = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    L"System\\CurrentControlSet\\Services",
                    0,
                    KEY_READ,
                    &hkeyServicesKey
                    );

    if ( sc != ERROR_SUCCESS )
    {
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilRemoveResourceServiceEnvironment: Failed to open Services key, error = %1!u!.\n",
            sc
            );
        goto Cleanup;
    } // if: error opening the Services key in the registry

    //
    // Open the service name key in the registry
    //
    sc = RegOpenKeyExW(
                    hkeyServicesKey,
                    pszServiceName,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkeyServiceName
                    );

    RegCloseKey( hkeyServicesKey );

    if ( sc != ERROR_SUCCESS )
    {
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilRemoveResourceServiceEnvironment: Failed to open %1!ws! key, error = %2!u!.\n",
            pszServiceName,
            sc
            );
        goto Cleanup;
    } // if: error opening the service name key in the registry

    //
    // Delete the environment value in the service's registry key.
    //
    sc = RegDeleteValueW(
                    hkeyServiceName,
                    L"Environment"
                    );

    RegCloseKey( hkeyServiceName );

    if ( sc != ERROR_SUCCESS )
    {
        (pfnLogEvent)(
            hResourceHandle,
            LOG_WARNING,
            L"ResUtilRemoveResourceServiceEnvironment: Failed to remove environment "
            L"value from service %1!ws!, error = %1!u!.\n",
            pszServiceName,
            sc
            );
        goto Cleanup;
    } // if: error setting the Environment value in the registry

Cleanup:

    return sc;

} //*** ResUtilRemoveResourceServiceEnvironment()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilSetResourceServiceStartParameters
//
//  Description:
//      Set the start parameters for the specified service.
//
//  Arguments:
//      pszServiceName [IN]
//          Name of service whose start parameters are to be set.
//
//      schSCMHandle [IN]
//          Handle to the Service Control Manager.  Can be specified as NULL.
//
//      phService [OUT]
//          Service handle.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ResUtilSetResourceServiceStartParameters(
    IN      LPCWSTR             pszServiceName,
    IN      SC_HANDLE           schSCMHandle,
    IN OUT  LPSC_HANDLE         phService,
    IN      PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN      RESOURCE_HANDLE     hResourceHandle
    )
{
    DWORD                       sc;
    DWORD                       cbBytesNeeded;
    DWORD                       cbQueryServiceConfig;
    DWORD                       idx;
    BOOL                        bWeOpenedSCM = FALSE;
    LPQUERY_SERVICE_CONFIG      pQueryServiceConfig = NULL;
    LPSERVICE_FAILURE_ACTIONS   pSvcFailureActions = NULL;

    //
    // Open the Service Control Manager if necessary.
    //
    if ( schSCMHandle == NULL )
    {
        schSCMHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
        if ( schSCMHandle == NULL )
        {
            sc = GetLastError();
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceStartParameters: Failed to open Service Control Manager. Error: %1!u!.\n",
                sc
                );
            goto Cleanup;
        } // if: error opening the Service Control Manager
        bWeOpenedSCM = TRUE;
    } // if: Service Control Manager not open yet

    //
    // Open the service.
    //
    *phService = OpenService(
                        schSCMHandle,
                        pszServiceName,
                        SERVICE_ALL_ACCESS
                        );
    if ( *phService == NULL )
    {
        sc = GetLastError();
        // TODO: Log event to the event log.
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceStartParameters: Failed to open the '%1' service. Error: %2!u!.\n",
            pszServiceName,
            sc
            );
        goto Cleanup;
    } // if: error opening the service

    //
    // Query the service to make sure it is not disabled.
    //
    cbQueryServiceConfig = sizeof( QUERY_SERVICE_CONFIG );
    do
    {
        //
        // Allocate memory for the config info structure.
        //
        pQueryServiceConfig = (LPQUERY_SERVICE_CONFIG) LocalAlloc( LMEM_FIXED, cbQueryServiceConfig );
        if ( pQueryServiceConfig == NULL )
        {
            sc = GetLastError();
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceStartParameters: Failed to allocate memory for query_service_config. Error: %1!u!.\n",
                sc
                );
            break;
        } // if: error allocating memory

        //
        // Query for the config info.  If it fails because the buffer
        // is too small, reallocate and try again.
        //
        if ( ! QueryServiceConfig(
                        *phService,
                        pQueryServiceConfig,
                        cbQueryServiceConfig,
                        &cbBytesNeeded
                        ) )
        {
            sc = GetLastError();
            if ( sc != ERROR_INSUFFICIENT_BUFFER )
            {
                (pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"ResUtilSetResourceServiceStartParameters: Failed to query service configuration for the '%1' service. Error: %2!u!.\n",
                    pszServiceName,
                    sc
                    );
                break;
            }

            sc = ERROR_SUCCESS;
            LocalFree( pQueryServiceConfig );
            pQueryServiceConfig = NULL;
            cbQueryServiceConfig = cbBytesNeeded;
            continue;
        } // if: error querying for service config info
        else
        {
            sc = ERROR_SUCCESS;
            cbBytesNeeded = 0;
        } // else: query was successful

        //
        // Check to see if the service is disabled or not.
        //
        if ( pQueryServiceConfig->dwStartType == SERVICE_DISABLED )
        {
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceStartParameters: The service '%1' is DISABLED.\n",
                pszServiceName
                );
            sc = ERROR_SERVICE_DISABLED;
            break;
        } // if: service is disabled
    } while ( cbBytesNeeded != 0 );

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error occurred checking to see if service is disabled

    //
    // Set the service to manual start.
    //
    if ( ! ChangeServiceConfig(
                *phService,
                SERVICE_NO_CHANGE,
                SERVICE_DEMAND_START, // Manual start
                SERVICE_NO_CHANGE,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                ) )
    {
        sc = GetLastError();
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceStartParameters: Failed to set service '%1' to manual start. Error: %2!u!.\n",
            pszServiceName,
            sc
            );
        goto Cleanup;
    } // if: error setting service to manual start

    //
    // Query for the size of the service failure actions array.
    // Use sc as the dummy buffer since the QueryServiceConfig2 API
    // is not that friendly.
    //
    if ( ! QueryServiceConfig2(
                    *phService,
                    SERVICE_CONFIG_FAILURE_ACTIONS,
                    (LPBYTE) &sc,
                    sizeof( DWORD ),
                    &cbBytesNeeded
                    ) )
    {
        sc = GetLastError();
        if ( sc == ERROR_INSUFFICIENT_BUFFER )
        {
            sc = ERROR_SUCCESS;
        } // if: expected "buffer too small" error occurred
        else
        {
            (pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ResUtilSetResourceServiceStartParameters: Failed to query service configuration for size for the '%1' service. Error: %2!u!.\n",
                pszServiceName,
                sc
                );
            goto Cleanup;
        } // else: an unexpected error occurred
    } // if: error querying for service failure actions buffer size

    //
    // Allocate memory for the service failure actions array.
    //
    pSvcFailureActions = (LPSERVICE_FAILURE_ACTIONS) LocalAlloc( LMEM_FIXED, cbBytesNeeded );
    if ( pSvcFailureActions == NULL )
    {
        sc = GetLastError();
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceStartParameters: Failed to allocate memory of size %1!u!. Error: %2!u!.\n",
            cbBytesNeeded,
            sc
            );
        goto Cleanup;
    } // if: error allocating memory for the service failure actions array

    //
    // Query for the service failure actions array.
    //
    if ( ! QueryServiceConfig2(
                    *phService,
                    SERVICE_CONFIG_FAILURE_ACTIONS,
                    (LPBYTE) pSvcFailureActions,
                    cbBytesNeeded,
                    &cbBytesNeeded
                    ) )
    {
        sc = GetLastError();
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceStartParameters: Failed to query service configuration for the '%1' service. Error: %2!u!.\n",
            pszServiceName,
            sc
            );
        goto Cleanup;
    } // if: error querying for service failure actions

    //
    // If any of the service action is set to service restart,
    // set it to  none.
    //
    for ( idx = 0 ; idx < pSvcFailureActions->cActions ; idx++ )
    {
        if ( pSvcFailureActions->lpsaActions[ idx ].Type == SC_ACTION_RESTART )
        {
            pSvcFailureActions->lpsaActions[ idx ].Type = SC_ACTION_NONE;
        } // if: action set to restart
    } // for: each service failure action array entry

    //
    // Set the changes to the service failure actions array.
    //
    if ( ! ChangeServiceConfig2(
            *phService,
            SERVICE_CONFIG_FAILURE_ACTIONS,
            pSvcFailureActions
            ) )
    {
        sc = GetLastError();
        (pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"ResUtilSetResourceServiceStartParameters: Failed to set service failure actions for the '%1' service. Error: %2!u!.\n",
            pszServiceName,
            sc
            );
        goto Cleanup;
    } // if: error saving service failure actions

Cleanup:

    //
    // Cleanup.
    //
    LocalFree( pQueryServiceConfig );
    LocalFree( pSvcFailureActions );
    if ( bWeOpenedSCM )
    {
        CloseServiceHandle( schSCMHandle );
    } // if: we opened the Server Control Manager
    if ( ( sc != ERROR_SUCCESS ) && ( *phService != NULL ) )
    {
        CloseServiceHandle( *phService );
        *phService = NULL;
    } // if: error occurred after opening service

    return sc;

} //*** ResUtilSetResourceServiceStartParameters()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilGetResourceDependentIPAddressProps
//
//  Description:
//      Get the properties from the first IP Address resource on which the
//      specified resource is dependent.
//
//  Arguments:
//      hResource [IN]
//          Handle to the resource to query.
//
//      pszAddress [OUT]
//          Output buffer for returning the address.
//
//      pcchAddress [IN OUT]
//          On input contains the size in characters of the pszAddress buffer.
//          On output contains the size in characters, including the terminating
//          NULL, of the string for the Address property.  If pszAddress is
//          specified as NULL and this is not specified as NULL, ERROR_SUCCESS
//          be returned.  Otherwise, ERROR_MORE_DATA will be returned.
//
//      pszSubnetMask [OUT]
//          Output buffer for returning the subnet mask.
//
//      pcchSubnetMask [IN OUT]
//          On input contains the size in characters of the pszSubnetMask buffer.
//          On output contains the size in characters, including the terminating
//          NULL, of the string for the SubnetMask property.  If pszSubnetMask is
//          specified as NULL and this is not specified as NULL, ERROR_SUCCESS
//          be returned.  Otherwise, ERROR_MORE_DATA will be returned.
//
//      pszNetwork [OUT]
//          Output buffer for returning the network.
//
//      pcchNetwork [IN OUT]
//          On input contains the size in characters of the pszNetwork buffer.
//          On output contains the size in characters, including the terminating
//          NULL, of the string for the Network property.  If pszNetwork is
//          specified as NULL and this is not specified as NULL, ERROR_SUCCESS
//          be returned.  Otherwise, ERROR_MORE_DATA will be returned.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The size of one of the buffers was too small.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ResUtilGetResourceDependentIPAddressProps(
    IN      HRESOURCE   hResource,
    OUT     LPWSTR      pszAddress,
    IN OUT  DWORD *     pcchAddress,
    OUT     LPWSTR      pszSubnetMask,
    IN OUT  DWORD *     pcchSubnetMask,
    OUT     LPWSTR      pszNetwork,
    IN OUT  DWORD *     pcchNetwork
    )
{
    DWORD       sc = ERROR_SUCCESS;
    HRESENUM    hresenum = NULL;
    HRESOURCE   hresDep = NULL;
    DWORD       idx;
    DWORD       nType;
    DWORD       cchmacName;
    DWORD       cchName;
    LPWSTR      pszName = NULL;
    DWORD       cbProps;
    PBYTE       pbProps = NULL;
    LPWSTR      pszProp;
    DWORD       cchProp;
    HCLUSTER    hCluster;
    HRESULT     hr;

    //
    // Enumerate dependent resources.
    //
    hresenum = ClusterResourceOpenEnum( hResource, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if ( hresenum == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    } // if: error opening the enumeration

    //
    // Allocate the initial name buffer.
    //
    cchmacName = 256;
    cchName = cchmacName;
    pszName = (LPWSTR) LocalAlloc( LMEM_FIXED, cchName * sizeof( pszName[ 0 ] ) );
    if ( pszName == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    } // if: error allocating resource name buffer

    for ( idx = 0 ; ; idx++ )
    {
        //
        // Get the first entry in the enumeration.
        //
        sc = ClusterResourceEnum(
                        hresenum,
                        idx,
                        &nType,
                        pszName,
                        &cchName
                        );
        if ( sc == ERROR_MORE_DATA )
        {
            LocalFree( pszName );
            cchName++;
            cchmacName = cchName;
            pszName = (LPWSTR) LocalAlloc( LMEM_FIXED, cchName * sizeof( pszName[ 0 ] ) );
            if ( pszName == NULL )
            {
                sc = GetLastError();
                break;
            } // if: error allocating resource name buffer
            sc = ClusterResourceEnum(
                            hresenum,
                            idx,
                            &nType,
                            pszName,
                            &cchName
                            );
        } // if: buffer is too small
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if: error getting the dependent resource name

        //
        // Open the resource.
        //
        hCluster = GetClusterFromResource( hResource );
        if ( hCluster == NULL )  {
            sc = GetLastError();
            break;
        }

        hresDep = OpenClusterResource( hCluster, pszName );
        if ( hresDep == NULL )
        {
            sc = GetLastError();
            break;
        } // if: error opening the dependent resource

        //
        // Get the resource type name.
        //
        cchName = cchmacName;
        sc = ClusterResourceControl(
                        hresDep,
                        NULL,
                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                        NULL,
                        0,
                        pszName,
                        cchmacName,
                        &cchName
                        );
        if ( sc == ERROR_MORE_DATA )
        {
            LocalFree( pszName );
            cchName++;
            cchmacName = cchName;
            pszName = (LPWSTR) LocalAlloc( LMEM_FIXED, cchName * sizeof( pszName[ 0 ] ) );
            if ( pszName == NULL )
            {
                sc = GetLastError();
                break;
            } // if: error allocating resource type name buffer
            sc = ClusterResourceControl(
                            hresDep,
                            NULL,
                            CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                            NULL,
                            0,
                            pszName,
                            cchmacName,
                            &cchName
                            );
        } // if: buffer was too small
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if: error getting resource type name

        if ( ClRtlStrNICmp( pszName, CLUS_RESTYPE_NAME_IPADDR, RTL_NUMBER_OF( CLUS_RESTYPE_NAME_IPADDR ) ) == 0 )
        {
            //
            // Get the private properties of the dependent resource.
            //
            cbProps = 1024;
            pbProps = (PBYTE) LocalAlloc( LMEM_FIXED, cbProps );
            if ( pbProps == NULL )
            {
                sc = GetLastError();
                break;
            } // if: error allocating buffer for properties
            sc = ClusterResourceControl(
                                hresDep,
                                NULL,
                                CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                                NULL,
                                0,
                                pbProps,
                                cbProps,
                                &cbProps
                                );
            if ( sc == ERROR_MORE_DATA )
            {
                LocalFree( pbProps );
                pbProps = (PBYTE) LocalAlloc( LMEM_FIXED, cbProps );
                if ( pbProps == NULL )
                {
                    sc = GetLastError();
                    break;
                } // if: error allocating buffer for properties
                sc = ClusterResourceControl(
                                    hresDep,
                                    NULL,
                                    CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                                    NULL,
                                    0,
                                    pbProps,
                                    cbProps,
                                    &cbProps
                                    );
            } // if: properties buffer too small
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if: error getting private properties

            //
            // Return the address.
            //
            if (    ( pszAddress != NULL )
                ||  ( pcchAddress != NULL )
                )
            {
                sc = ResUtilFindSzProperty(
                                    pbProps,
                                    cbProps,
                                    L"Address",
                                    &pszProp
                                    );
                if ( sc != ERROR_SUCCESS )
                {
                    break;
                } // if: error finding the property
                cchProp = (DWORD) wcslen( pszProp ) + 1;
                if ( cchProp > *pcchAddress )
                {
                    if ( pszAddress == NULL )
                    {
                        sc = ERROR_SUCCESS;
                    } // if: no buffer was specified
                    else
                    {
                        sc = ERROR_MORE_DATA;
                    } // else: buffer was specified but was too small
                    *pcchAddress = cchProp;
                    break;
                } // if: buffer is too small
                hr = StringCchCopy( pszAddress, *pcchAddress, pszProp );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    break;
                }
                *pcchAddress = cchProp;
            } // if: address requested by caller

            //
            // Return the subnet mask.
            //
            if (    ( pszSubnetMask != NULL )
                ||  ( pcchSubnetMask != NULL )
                )
            {
                sc = ResUtilFindSzProperty(
                                    pbProps,
                                    cbProps,
                                    L"SubnetMask",
                                    &pszProp
                                    );
                if ( sc != ERROR_SUCCESS )
                {
                    break;
                } // if: error finding the property
                cchProp = (DWORD) wcslen( pszProp ) + 1;
                if ( cchProp > *pcchSubnetMask )
                {
                    if ( pszSubnetMask == NULL )
                    {
                        sc = ERROR_SUCCESS;
                    } // if: no buffer was specified
                    else
                    {
                        sc = ERROR_MORE_DATA;
                    } // else: buffer was specified but was too small
                    *pcchSubnetMask = cchProp;
                    break;
                } // if: buffer is too small
                hr = StringCchCopy( pszSubnetMask, *pcchSubnetMask, pszProp );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    break;
                }
                *pcchSubnetMask = cchProp;
            } // if: subnet mask requested by caller

            //
            // Return the network.
            //
            if (    ( pszNetwork != NULL )
                ||  ( pcchNetwork != NULL )
                )
            {
                sc = ResUtilFindSzProperty(
                                    pbProps,
                                    cbProps,
                                    L"Network",
                                    &pszProp
                                    );
                if ( sc != ERROR_SUCCESS )
                {
                    break;
                } // if: error finding the property
                cchProp = (DWORD) wcslen( pszProp ) + 1;
                if ( cchProp > *pcchNetwork )
                {
                    if ( pszNetwork == NULL )
                    {
                        sc = ERROR_SUCCESS;
                    } // if: no buffer was specified
                    else
                    {
                        sc = ERROR_MORE_DATA;
                    } // else: buffer was specified but was too small
                    *pcchNetwork = cchProp;
                    break;
                } // if: buffer is too small
                hr = StringCchCopy( pszNetwork, *pcchNetwork, pszProp );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    break;
                }
                *pcchNetwork = cchProp;
            } // if: network requested by caller

            //
            // Exit the loop since we found a match.
            //
            break;
        } // if: IP Address resource found

        //
        // Close the dependent resource.
        //
        CloseClusterResource( hresDep );
        hresDep = NULL;

    } // for: each dependency

Cleanup:

    //
    // Cleanup.
    //
    LocalFree( pszName );
    LocalFree( pbProps );

    if ( hresenum != NULL )
    {
        ClusterResourceCloseEnum( hresenum );
    } // if: we opened the enumerator
    if ( hresDep != NULL )
    {
        CloseClusterResource( hresDep );
    } // if: opened dependent resource

    return sc;

} //*** ResUtilGetResourceDependentIPAddressProps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilFindDependentDiskResourceDriveLetter
//
//  Description:
//      Finds a disk resource in the dependent resources and retrieves the
//      the drive letter associated with it.
//
//  Arguments:
//      hCluster [IN]
//          Handle to the cluster.
//
//      hResource [IN]
//          Handle to the resource to query for dependencies.
//
//      pszDriveLetter [IN/RETVAL]
//          The drive letter of a dependent disk resource that was found.
//          If a resource is not found, this value is untouched.
//
//      pcchDriverLetter [IN/OUT]
//          [IN] The number of characters that pszDriverLetter points to.
//          [OUT] The number of characters written to the buffer
//          (including NULL). If ERROR_MORE_DATA is returned, this value
//          is the size of the buffer required to store the value.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully and the drive letter was
//          set.
//
//      ERROR_NO_MORE_ITEMS
//      ERROR_RESOURCE_NOT_PRESENT
//          A dependent disk resource was not found or the resource is
//          not dependent on a disk resource.
//
//      ERROR_MORE_DATA
//          The buffer passed in is too small. pcchDriveLetter will
//          contain the size of the buffer (WCHARs) needed to fulfill
//          the request.
//
//      Win32 error code
//          Other possible failures.
//
//  SPECIAL NOTE:
//      Do _NOT_ call this from a Resource DLL. It will cause a deadlock.
//      You should have your Resource Extension call this function and
//      write the results out as a private property that your Resource
//      DLL can then read.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ResUtilFindDependentDiskResourceDriveLetter(
    IN     HCLUSTER  hCluster,             // handle to cluster
    IN     HRESOURCE hResource,            // handle to resource to query for dependencies
    IN     LPWSTR    pszDriveLetter,       // buffer to store drive letter (ex. "X:")
    IN OUT DWORD *   pcchDriveLetter       // IN size of the pszDriveLetter buffer, OUT size of buffer required
    )
{
    BOOL     fFoundDriveLetter  = FALSE;
    DWORD    status             = ERROR_SUCCESS;
    HRESENUM hresenum = NULL;
    HRESOURCE hRes = NULL;
    DWORD    cchName;
    DWORD    dwRetType;
    WCHAR    szName[ MAX_PATH ];
    INT      iCount;
    HRESULT  hr;
    PBYTE    pDiskInfo = NULL;

    // validate arguments
    if ( !pszDriveLetter || !pcchDriveLetter )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    hresenum = ClusterResourceOpenEnum( hResource, CLUSTER_RESOURCE_ENUM_DEPENDS );
    if ( hresenum != NULL )
    {
        // Scan the dependencies until we find a disk resource or we hit
        // the end of the dependency list.
        for( iCount = 0 ; ! fFoundDriveLetter && ( status == ERROR_SUCCESS ) ; iCount++ )
        {
            cchName = RTL_NUMBER_OF( szName );
            status = ClusterResourceEnum( hresenum, iCount, &dwRetType, szName, &cchName );
            if ( status == ERROR_SUCCESS )
            {
                // Interrogate the resource to see if it is a disk resource.
                hRes = OpenClusterResource( hCluster, szName );
                if ( hRes != NULL )
                {
                    DWORD cbDiskInfo = sizeof(CLUSPROP_DWORD)
                                       + sizeof(CLUSPROP_SCSI_ADDRESS)
                                       + sizeof(CLUSPROP_DISK_NUMBER)
                                       + sizeof(CLUSPROP_PARTITION_INFO)
                                       + sizeof(CLUSPROP_SYNTAX);
                    pDiskInfo = (PBYTE) LocalAlloc( LMEM_FIXED, cbDiskInfo );
                    if ( !pDiskInfo )
                    {
                        status = ERROR_OUTOFMEMORY;
                        goto Cleanup;
                    } // if: !pDiskInfo

                    status = ClusterResourceControl( hRes,
                                                     NULL,
                                                     CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                                                     NULL,
                                                     0,
                                                     pDiskInfo,
                                                     cbDiskInfo,
                                                     &cbDiskInfo
                                                     );
                    if ( status == ERROR_MORE_DATA )
                    {
                        LocalFree( pDiskInfo );

                        // get a bigger block
                        pDiskInfo = (PBYTE) LocalAlloc( LMEM_FIXED, cbDiskInfo );
                        if ( !pDiskInfo )
                        {
                            status = ERROR_OUTOFMEMORY;
                            goto Cleanup;
                        } // if: !pDiskInfo

                        status = ClusterResourceControl( hRes,
                                                         NULL,
                                                         CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                                                         NULL,
                                                         0,
                                                         pDiskInfo,
                                                         cbDiskInfo,
                                                         &cbDiskInfo
                                                         );
                    } // if: more data

                    if ( status == ERROR_SUCCESS )
                    {
                        DWORD                       dwValueSize;
                        CLUSPROP_BUFFER_HELPER      props;
                        PCLUSPROP_PARTITION_INFO    pPartitionInfo;

                        props.pb = pDiskInfo;

                        // Loop through each property.
                        while ( ! fFoundDriveLetter
                             && ( status == ERROR_SUCCESS )
                             && ( cbDiskInfo > sizeof(CLUSPROP_SYNTAX ) )
                             && ( props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK) )
                        {
                            // Get the size of this value and verify there is enough buffer left.
                            dwValueSize = sizeof(*props.pValue) + ALIGN_CLUSPROP( props.pValue->cbLength );
                            if ( dwValueSize > cbDiskInfo )
                            {
                                goto Cleanup;
                            } // if: data is not valid

                            if ( props.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO )
                            {
                                // Validate the data.  There must be a device name.
                                pPartitionInfo = props.pPartitionInfoValue;
                                if ( ( dwValueSize != sizeof(*pPartitionInfo) )
                                  || ( pPartitionInfo->szDeviceName[0] == L'\0' ) )
                                {
                                    goto Cleanup;
                                } // if: data is not valid

                                // Make sure it fits
                                if ( wcslen( pPartitionInfo->szDeviceName ) < *pcchDriveLetter )
                                {
                                    hr = StringCchCopy( pszDriveLetter, *pcchDriveLetter, pPartitionInfo->szDeviceName );
                                    if ( FAILED( hr ) )
                                    {
                                        status = HRESULT_CODE( hr );
                                        goto Cleanup;
                                    }
                                    fFoundDriveLetter = TRUE;
                                } // if: drive letter fits into buffer
                                else
                                {
                                    status = ERROR_MORE_DATA;
                                } // else: does not fit into buffer

                                // set the size written and/or size needed
                                *pcchDriveLetter = (DWORD) wcslen( pPartitionInfo->szDeviceName ) + 1;

                            } // if props.pSyntax->dw

                            cbDiskInfo -= dwValueSize;
                            props.pb += dwValueSize;
                        } // while

                    } // if status
                    else if ( status == ERROR_INVALID_FUNCTION )
                    {
                        // Ignore resources that don't support the control
                        // code.  Only storage-class resources will support
                        // the control code.
                        status = ERROR_SUCCESS;
                    } // else if: resource doesn't support the control code

                    LocalFree( pDiskInfo );
                    pDiskInfo = NULL;

                    CloseClusterResource( hRes );
                    hRes = NULL;
                } // if hRes

            } // if status
            else if ( status == ERROR_NO_MORE_ITEMS )
            {
                goto Cleanup;
            } // if status

        } // for ( i )

        ClusterResourceCloseEnum( hresenum );
        hresenum = NULL;

    } // if: opened hresenum
    else
    {
        status = GetLastError( );
    } // else: failed to open hresenum

Cleanup:

    // Make sure if we did not find a disk resource that we don't
    // return ERROR_SUCCESS or ERROR_NO_MORE_ITEMS.
    if ( ! fFoundDriveLetter
      && ( ( status == ERROR_SUCCESS )
        || ( status == ERROR_NO_MORE_ITEMS ) ) )
    {
        status = ERROR_RESOURCE_NOT_PRESENT;
    } // if: sanity check

    LocalFree( pDiskInfo );

    if ( hRes != NULL )
    {
        CloseClusterResource( hRes );
    }

    if ( hresenum != NULL )
    {
        ClusterResourceCloseEnum( hresenum );
    }

    return status;

} //*** ResUtilFindDependentDiskResourceDriveLetter()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScIsResourceOfType()
//
//  Description:
//      Is the resource of the type passed in?
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The resource is of the type requested.
//
//      S_FALSE
//          The resource is not of the type requested.
//
//      Other HRESULT
//          Win32 error as HRESULT.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static DWORD
ScIsResourceOfType(
      HRESOURCE     hResIn
    , const WCHAR * pszResourceTypeIn
    , BOOL *        pbIsResourceOfTypeOut
    )
{
    DWORD       sc = ERROR_SUCCESS;
    WCHAR *     psz = NULL;
    DWORD       cbpsz = 33 * sizeof( WCHAR );
    DWORD       cb;
    int         idx;

    if ( pbIsResourceOfTypeOut == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // else

    for ( idx = 0; idx < 2; idx++ )
    {
        psz = (WCHAR *) LocalAlloc( LPTR, cbpsz );
        if ( psz == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        } // if:

        sc = ClusterResourceControl( hResIn, NULL, CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, NULL, 0, psz, cbpsz, &cb );
        if ( sc == ERROR_MORE_DATA )
        {
            LocalFree( psz );
            psz = NULL;
            cbpsz = cb + 1;
            continue;
        } // if:

        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if:

        break;
    } // for:

    *pbIsResourceOfTypeOut = ( ClRtlStrNICmp( psz, pszResourceTypeIn, (cbpsz / sizeof( WCHAR )) ) == 0 );

Cleanup:

    LocalFree( psz );

    return sc;

} //*** ScIsResourceOfType()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScIsCoreResource()
//
//  Description:
//      Is the passed in resource a core resource?
//
//  Arguments:
//
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation succeeded.
//
//      Other Win32 error
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static DWORD
ScIsCoreResource(
      HRESOURCE hResIn
    , BOOL *    pfIsCoreResourceOut
    )
{
    DWORD   sc;
    DWORD   dwFlags = 0;
    DWORD   cb;
    BOOL    fIsCoreResource = FALSE;

    sc = ClusterResourceControl( hResIn, NULL, CLUSCTL_RESOURCE_GET_FLAGS, NULL, 0, &dwFlags, sizeof( dwFlags ), &cb );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    fIsCoreResource = ( dwFlags & CLUS_FLAG_CORE );

    if ( pfIsCoreResourceOut != NULL )
    {
        *pfIsCoreResourceOut = fIsCoreResource;
    } // if:
    else
    {
        sc = ERROR_INVALID_PARAMETER;
    } // else

Cleanup:

    return sc;

} //*** ScIsCoreResource()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScIsQuorumCapableResource()
//
//  Description:
//      Is the passed in resource quorum capable?
//
//  Arguments:
//      hResIn
//          The resource to check for quorum capability.
//
//      pfIsQuorumCapableResource
//          True if the resource is quorum capable, false if it is not.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation succeeded.
//
//      Other Win32 error
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static DWORD
ScIsQuorumCapableResource(
      HRESOURCE hResIn
    , BOOL *    pfIsQuorumCapableResource
    )
{
    DWORD   sc;
    DWORD   cb;
    DWORD   dwFlags = 0;

    if ( hResIn == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

    if ( pfIsQuorumCapableResource == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

    sc = ClusterResourceControl( hResIn, NULL, CLUSCTL_RESOURCE_GET_CHARACTERISTICS, NULL, 0, &dwFlags, sizeof( dwFlags ), &cb );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    *pfIsQuorumCapableResource = ( dwFlags & CLUS_CHAR_QUORUM );

Cleanup:

    return sc;

} //*** ScIsQuorumCapableResource()


static WCHAR * g_pszCoreResourceTypes[] =
{
    CLUS_RESTYPE_NAME_NETNAME,
    CLUS_RESTYPE_NAME_IPADDR,
    L"\0"
};

#define CLUSTER_NAME        0
#define CLUSTER_IP_ADDRESS  1

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilGetCoreClusterResources()
//
//  Description:
//      Find the core cluster resources.
//
//  Arguments:
//      hClusterIn
//          The cluster whose core resource are sought.
//
//      phClusterNameResourceOut
//          The resource handle of the cluster name resource.
//
//      phClusterIPAddressResourceOut
//          The resource handle of the cluster IP address resource.
//
//      phClusterQuorumResourceOut
//          The resource handle of the cluster quorum resource.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
ResUtilGetCoreClusterResources(
      HCLUSTER      hClusterIn
    , HRESOURCE *   phClusterNameResourceOut
    , HRESOURCE *   phClusterIPAddressResourceOut
    , HRESOURCE *   phClusterQuorumResourceOut
    )
{
    DWORD       sc;
    HCLUSENUM   hEnum = NULL;
    DWORD       idxResource;
    DWORD       idx;
    DWORD       dwType;
    WCHAR *     psz = NULL;
    DWORD       cchpsz = 33;
    DWORD       cch;
    HRESOURCE   hRes = NULL;
    BOOL        fIsCoreResource = FALSE;
    BOOL        fIsResourceOfType = FALSE;
    BOOL        fCloseResource = FALSE;
    BOOL        fIsQuorumCapableResource = FALSE;

    if ( hClusterIn == NULL )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

    hEnum = ClusterOpenEnum( hClusterIn, CLUSTER_ENUM_RESOURCE );
    if ( hEnum == NULL )
    {
        sc =  GetLastError();
        goto Cleanup;
    } // if:

    psz = (WCHAR *) LocalAlloc( LPTR, cchpsz * sizeof( WCHAR ) );
    if ( psz == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if:

    //
    //  KB: 10-JUL-2002 GalenB
    //
    //  Using cch in the ClusterEnum() call below because using cchpsz causes extra allocations.
    //  ClusterEnum() changes cch when the buffer is big enough to hold the data and returns
    //  ERROR_SUCCESS to be the size of the data that was just copied into the buffer.  Now
    //  cch no longer reflects the amount of memory allocated to psz...
    //

    for ( idxResource = 0; ; )
    {
        //
        //  Reset cch to the real size of the buffer to avoid extra allocations...
        //

        cch = cchpsz;

        sc = ClusterEnum( hEnum, idxResource, &dwType, psz, &cch );
        if ( sc == ERROR_MORE_DATA )
        {
            LocalFree( psz );
            psz = NULL;

            cch++;          // need space for the NULL...
            cchpsz = cch;

            psz = (WCHAR *) LocalAlloc( LPTR, cchpsz * sizeof( WCHAR ) );
            if ( psz == NULL )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            } // if:

            sc = ClusterEnum( hEnum, idxResource, &dwType, psz, &cch );
        } // if: sc == ERROR_MORE_DATA

        if ( sc == ERROR_SUCCESS )
        {
            hRes = OpenClusterResource( hClusterIn, psz );
            if ( hRes == NULL )
            {
                sc = GetLastError();
                goto Cleanup;
            } // if:

            fCloseResource = TRUE;

            sc = ScIsCoreResource( hRes, &fIsCoreResource );
            if ( sc != ERROR_SUCCESS )
            {
                goto Cleanup;
            } // if:

            //
            //  If the resource is not a core resource then close it and go around again.
            //

            if ( !fIsCoreResource )
            {
                CloseClusterResource( hRes );
                hRes = NULL;
                idxResource++;
                continue;
            } // if:

            sc = ScIsQuorumCapableResource( hRes, &fIsQuorumCapableResource );
            if ( sc != ERROR_SUCCESS )
            {
                goto Cleanup;
            } // if:

            //
            //  If this core resource is a quorum capable resource then it must be the quorom.  If the caller
            //  has asked for the quorom resource then pass it back and leave the resource open, other wise
            //  close the resource and go around again.
            //

            if ( fIsQuorumCapableResource )
            {
                if ( phClusterQuorumResourceOut != NULL)
                {
                    *phClusterQuorumResourceOut = hRes;
                } // if:
                else
                {
                    CloseClusterResource( hRes );
                } // else:

                hRes = NULL;
                idxResource++;
                continue;
            } // if:

            //
            //  Since this core resource is not a quorum capable resource it is either the cluster
            //  name or the cluster IP address resource.
            //

            for ( idx = 0; *( g_pszCoreResourceTypes[ idx ] ) != '\0'; idx++ )
            {
                sc = ScIsResourceOfType( hRes, g_pszCoreResourceTypes[ idx ], &fIsResourceOfType );
                if ( sc != ERROR_SUCCESS )
                {
                    goto Cleanup;
                } // if:

                if ( !fIsResourceOfType )
                {
                    continue;
                } // if:

                switch ( idx )
                {
                    case CLUSTER_NAME :
                        if ( phClusterNameResourceOut != NULL )
                        {
                            *phClusterNameResourceOut = hRes;
                            fCloseResource = FALSE;
                        } // if:
                        break;

                    case CLUSTER_IP_ADDRESS :
                        if ( phClusterIPAddressResourceOut != NULL )
                        {
                            *phClusterIPAddressResourceOut = hRes;
                            fCloseResource = FALSE;
                        } // if:
                        break;

                    default:
                        goto Cleanup;
                } // switch:

                //
                //  If we get here then we broke from the switch above and we want out of
                //  this loop.
                //

                break;
            } // for:

            if ( fCloseResource )
            {
                CloseClusterResource( hRes );
            } // if:

            hRes = NULL;
            idxResource++;
            continue;
        } // if: sc == ERROR_SUCCESS
        else if ( sc == ERROR_NO_MORE_ITEMS )
        {
            sc = ERROR_SUCCESS;
            break;
        } // else if: sc == ERROR_NO_MORE_ITEMS
        else
        {
            goto Cleanup;
        } // else: sc has some other error...

        break;
    } // for:

Cleanup:

    LocalFree( psz );

    if ( hRes != NULL )
    {
        CloseClusterResource( hRes );
    } // if:

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    } // if:

    return sc;

} //*** ResUtilGetCoreClusterResources


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ResUtilGetResourceName()
//
//  Description:
//      Get the name of the resource that is passed in.
//
//  Arguments:
//      hResourceIn
//          The resource whose name is sought.
//
//      pszResourceNameOut
//          Buffer to hold the resource's name.
//
//      pcchResourceNameInOut
//          The size of the buffer on input and the size required on output.
//
//
//  Return Value:
//      ERROR_SUCCESS
//      ERROR_MORE_DATA
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
ResUtilGetResourceName(
      HRESOURCE hResourceIn
    , WCHAR *   pszResourceNameOut
    , DWORD *   pcchResourceNameInOut
    )
{
    DWORD       sc = ERROR_INVALID_PARAMETER;
    WCHAR *     psz = NULL;
    DWORD       cb;
    HRESULT     hr;

    if ( hResourceIn == NULL )
    {
        goto Cleanup;
    } // if:

    if ( ( pszResourceNameOut == NULL ) || ( pcchResourceNameInOut == NULL ) )
    {
        goto Cleanup;
    } // if:

    psz = (WCHAR *) LocalAlloc( LPTR, (*pcchResourceNameInOut) * sizeof( WCHAR ) );
    if ( psz == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if:

    sc = ClusterResourceControl(
                  hResourceIn
                , NULL
                , CLUSCTL_RESOURCE_GET_NAME
                , NULL
                , 0
                , psz
                , (*pcchResourceNameInOut) * sizeof( WCHAR )
                , &cb
                );
    if ( sc == ERROR_MORE_DATA )
    {
        *pcchResourceNameInOut = ( cb / sizeof( WCHAR ) ) + 1;
        goto Cleanup;
    } // if:

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    hr = StringCchCopy( pszResourceNameOut, *pcchResourceNameInOut, psz );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    }

Cleanup:

    LocalFree( psz );

    return sc;

} //*** ResUtilGetResourceName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\netname\upgrade.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    upgrade.c

Abstract:

    code related to upgrade situations.

    This currently covers upgrades to Windows Server 2003 either from NT4 or W2K. In
    Windows Server 2003, netname now creates a computer object which is used by apps
    like MSMQ. In the upgrade case, MSMQ has already create the computer object. If
    Netname detects an existing computer object and Kerberos support is disabled, the
    netname resource will not go online. This code enums the MSMQ resources
    and enables Kerberos support on their dependent netname resources.

    Test for MSMQ DS vs workgroup mode supplied by IlanH

Author:

    Charlie Wickham (charlwi) 07-Nov-2001

Environment:

    User Mode

Revision History:

--*/

#define UNICODE 1

#include "clusres.h"
#include "netname.h"

#define FALCON_REG_KEY                      TEXT("SOFTWARE\\Microsoft\\MSMQ\\Parameters")
#define MSMQ_WORKGROUP_REGNAME              TEXT("Workgroup")

//
// private routines
//

DWORD
NetNameMSMQEnumCallback( 
    HRESOURCE hSelf, 
    HRESOURCE MSMQRes, 
    PVOID pParameter 
    )

/*++

Routine Description:

    Callback routine for FixupNetnamesOnUpgrade. For a given MSMQ resource
    (MSMQRes), get its dependent netname resource and set the RequireKerberos
    property to one.

    REMOVE AFTER THE NEXT MAJOR RELEASE OF NT AFTER RELEASE OF 
    WINDOWS XP/SERVER 2003

Arguments:

    standard ResUtilEnumResources args - hSelf is not used; pParameter is a
    pointer to a DWORD which is incremented when the RequireKerberos property
    is set.

Return Value:

    None

--*/

{
#define RESNAME_CHARS  64

    WCHAR   msmqResNameBuffer[ RESNAME_CHARS ];
    PWCHAR  msmqResName = msmqResNameBuffer;
    DWORD   msmqBufferSize = RESNAME_CHARS * sizeof( *msmqResName );
    WCHAR   nnResName[ RESNAME_CHARS ];
    DWORD   status;
    DWORD   bytesReturned;
    DWORD   bufSize;
    DWORD   bytesRequired;
    PDWORD  updateCount = pParameter;

    PVOID   propList = NULL;
    DWORD   propListSize = 0;

    HRESOURCE   nnHandle = NULL;

    struct _RESOURCE_PRIVATEPROPS {
        DWORD   RequireKerberos;
    } privateProps;

    RESUTIL_PROPERTY_ITEM privatePropTable[] = {
        { L"RequireKerberos", NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, 0,
          FIELD_OFFSET( struct _RESOURCE_PRIVATEPROPS, RequireKerberos ) },
        { 0 }
    };

    //
    // get the name of the MSMQ resource
    //
retry_get_msmq_resname:
    status = ClusterResourceControl( MSMQRes,
                                     NULL,
                                     CLUSCTL_RESOURCE_GET_NAME,
                                     NULL,
                                     0,
                                     msmqResName,
                                     msmqBufferSize,
                                     &bytesReturned );

    if ( status == ERROR_MORE_DATA ) {
        msmqResName = (PWCHAR)LocalAlloc( LMEM_FIXED, bytesReturned );
        if ( msmqResName == NULL ) {
            status = GetLastError();
        } else {
            msmqBufferSize = bytesReturned;
            goto retry_get_msmq_resname;
        }
    }

    if ( status != ERROR_SUCCESS ) {
        (NetNameLogEvent)( L"rtNetwork Name",
                           LOG_ERROR,
                           L"Couldn't get name of MSMQ resource - status %u\n",
                           status );
        msmqResName = NULL;
    }

    //
    // get a handle to its dependent netname resource
    //
    nnHandle = ResUtilGetResourceDependency( MSMQRes, L"Network Name" );
    if ( nnHandle != NULL ) {

        //
        // get the name of the netname resource
        //
        bufSize = RESNAME_CHARS;
        if ( !GetClusterResourceNetworkName( MSMQRes, nnResName, &bufSize  )) {
            nnResName[ COUNT_OF( nnResName ) - 1 ] = UNICODE_NULL;
            _snwprintf( nnResName,
                        COUNT_OF( nnResName ) - 1,
                        L"Dependent network name resource of '%ws'",
                        msmqResName);
        }

        //
        // set our unknown prop to one
        //
        privateProps.RequireKerberos = 1;

        //
        // get the size of the prop list buffer
        //
        status = ResUtilPropertyListFromParameterBlock(privatePropTable,
                                                       NULL,
                                                       &propListSize,
                                                       (LPBYTE) &privateProps,
                                                       &bytesReturned,
                                                       &bytesRequired );

        if ( status == ERROR_MORE_DATA ) {
            propList = LocalAlloc( LMEM_FIXED, bytesRequired );
            if ( propList == NULL ) {
                (NetNameLogEvent)( L"rtNetwork Name",
                                   LOG_ERROR,
                                   L"Unable to create property list for resource '%1!ws!'. error %2!u!\n",
                                   nnResName,
                                   GetLastError());
                goto cleanup;
            }

            propListSize = bytesRequired;

            status = ResUtilPropertyListFromParameterBlock(privatePropTable,
                                                           propList,
                                                           &propListSize,
                                                           (LPBYTE) &privateProps,
                                                           &bytesReturned,
                                                           &bytesRequired );
        }

        if ( status != ERROR_SUCCESS ) {
            (NetNameLogEvent)( L"rtNetwork Name",
                               LOG_ERROR,
                               L"Couldn't create property list for resource '%1!ws!'. error %2!u!\n",
                               nnResName,
                               status);

            goto cleanup;
        }

        //
        // set the RequireKerberos property to one for the netname resource
        //
        status = ClusterResourceControl( nnHandle,
                                         NULL,
                                         CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                         propList,
                                         propListSize,
                                         NULL,
                                         0,
                                         NULL );                                            

        if ( status == ERROR_SUCCESS || status == ERROR_RESOURCE_PROPERTIES_STORED ) {
            (NetNameLogEvent)( L"rtNetwork Name",
                               LOG_INFORMATION,
                               L"Successfully set RequireKerberos property for resource '%1!ws!'\n",
                               nnResName );

            ++*updateCount;
        } else {
            (NetNameLogEvent)( L"rtNetwork Name",
                               LOG_ERROR,
                               L"Failed to set RequireKerberos property for resource '%1!ws!' - status %2!u!\n",
                               nnResName,
                               status );
        }

    }
    else {
        (NetNameLogEvent)( L"rtNetwork Name",
                           LOG_ERROR,
                           L"Unable to get handle to dependent network name resource of MSMQ "
                           L"resource '%1!ws!' - status '%2!u!'. This resource may fail to go "
                           L"online.\n",
                           msmqResName,
                           GetLastError() );
    }

cleanup:
    if ( propList ) {
        LocalFree( propList );
    }

    if ( nnHandle ) {
        CloseClusterResource( nnHandle );
    }

    if ( msmqResName != NULL && msmqResName != msmqResNameBuffer ) {
        LocalFree( msmqResName );
    }

    return ERROR_SUCCESS;

} // NetNameMSMQEnumCallback

static BOOL
GetMsmqDWORDKeyValue(
    LPCWSTR RegKey,
    LPCWSTR RegName,
    DWORD * Value
    )

/*++

Routine Description:

    Read falcon DWORD registry key.

Arguments:

    RegName - Registry name (under HKLM\msmq\parameters)

Return Value:

    DWORD key value (0 if the key not exist)

--*/

{
    HKEY    hKey;
    LONG    regStatus;
    DWORD   valueType = REG_DWORD;
    DWORD   valueSize = sizeof(DWORD);

    regStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              RegKey,
                              0,
                              KEY_READ,
                              &hKey
                              );

    if ( regStatus != ERROR_SUCCESS) {
//        printf("At this point MSMQ Registry must exist, rc = 0x%x\n", rc);
        return FALSE;
    }

    *Value = 0;
    regStatus = RegQueryValueEx( hKey,
                                 RegName,
                                 0L,
                                 &valueType,
                                 (BYTE *)Value,
                                 &valueSize
                                 );

    RegCloseKey( hKey );

    if ( regStatus != ERROR_SUCCESS && regStatus != ERROR_FILE_NOT_FOUND ) {
//        printf("We should get either ERROR_SUCCESS or ERROR_FILE_NOT_FOUND, rc = 0x%x\n", rc);
        return FALSE;
    }

//    printf("%ls = %d\n", RegName, *Value);
    return TRUE;

} // GetMsmqDWORDKeyValue


//
// public routines
//

BOOL
DoesMsmqNeedComputerObject(
    VOID
    )
{
    DWORD dwWorkGroup = 0;

    if( !GetMsmqDWORDKeyValue( FALCON_REG_KEY, MSMQ_WORKGROUP_REGNAME, &dwWorkGroup )) {
        return TRUE;
    }

    if(dwWorkGroup != 0) {
//        printf("MSMQ in workgroup mode, no need for computer object\n");
        return FALSE;
    }

//    printf("MSMQ in domain mode, need computer object\n");
    return TRUE;
} // DoesMsmqNeedComputerObject

DWORD
UpgradeMSMQDependentNetnameToKerberos(
    PNETNAME_RESOURCE   Resource
    )

/*++

Routine Description:

    After an upgrade to XP, check if this netname is a provider for an MSMQ
    resource. If so, set a flag that will set the RequireKerberos property to
    one during the next online. We can't set the property at this point in
    time since this routine is called when the API is read-only.

    REMOVE AFTER THE NEXT MAJOR RELEASE OF NT AFTER RELEASE OF 
    WINDOWS XP/SERVER 2003

Arguments:

    None

Return Value:

    None

--*/

{
    HCLUSTER    clusterHandle;
    HRESENUM    providerEnum;
    DWORD       status;

    (NetNameLogEvent)( Resource->ResourceHandle,
                       LOG_INFORMATION,
                       L"Kerberos Support Upgrade Check: this resource will be "
                       L"checked for a dependent MSMQ resources.\n");

    //
    // get a handle to the cluster since we'll need it later on
    //
    clusterHandle = OpenCluster( NULL );
    if ( clusterHandle == NULL ) {
        (NetNameLogEvent)( Resource->ResourceHandle,
                           LOG_ERROR,
                           L"Unable to open handle to the cluster - status %1!u!. Any MSMQ resource "
                           L"dependent on this resource may fail to go online.\n",
                           status = GetLastError() );

        return status;
    }

    //
    // get a enum handle for this netname resource that will provide us a list
    // of the resources that are dependent on this resource
    //
    //  THIS CALL REQUIRES WORKER THREAD ONLY!!!
    //
    providerEnum = ClusterResourceOpenEnum( Resource->ClusterResourceHandle,
                                            CLUSTER_RESOURCE_ENUM_PROVIDES );

    if ( providerEnum != NULL ) {
        DWORD   enumIndex = 0;
        PWCHAR  nameBuffer;
        WCHAR   dependentResName[ 128 ];
        DWORD   nameBufferSize;
        DWORD   enumType;

        do {
            nameBuffer = dependentResName;
            nameBufferSize = COUNT_OF( dependentResName );

        enum_again:
            //
            // WORKER THREAD ONLY!!!!
            //
            status = ClusterResourceEnum( providerEnum,
                                          enumIndex,
                                          &enumType,
                                          nameBuffer,
                                          &nameBufferSize);

            if ( status == ERROR_MORE_DATA ) {
                //
                // need more space for this resource's name; it's very
                // unlikely that this code can be in a loop, but just in case,
                // we'll free any previously allocated memory
                //
                if ( nameBuffer != NULL && nameBuffer != dependentResName ) {
                    LocalFree( nameBuffer );
                }

                nameBuffer = LocalAlloc( LMEM_FIXED, ++nameBufferSize * sizeof( WCHAR ));
                if ( nameBuffer != NULL ) {
                    goto enum_again;
                }

                status = GetLastError();
            }
            else if ( status == ERROR_SUCCESS ) {
                HRESOURCE   dependentResource;

                dependentResource = OpenClusterResource( clusterHandle, nameBuffer );
                if ( dependentResource != NULL ) {
                    //
                    // if this resource is MSMQ, then mark this netname for kerberos support
                    //
                    if ( ResUtilResourceTypesEqual( CLUS_RESTYPE_NAME_MSMQ, dependentResource ) ||
                         ResUtilResourceTypesEqual( CLUS_RESTYPE_NAME_NEW_MSMQ, dependentResource ))
                    {
                        Resource->Params.RequireKerberos = TRUE;

                        status = ResUtilSetDwordValue( Resource->ParametersKey,
                                                       PARAM_NAME__REQUIRE_KERBEROS,
                                                       1,
                                                       NULL);

                        if ( status != ERROR_SUCCESS ) {
                            (NetNameLogEvent)( Resource->ResourceHandle,
                                               LOG_ERROR,
                                               L"Unable to set RequireKerberos property after an "
                                               L"upgrade - status %1!u!. This resource requires that "
                                               L"the RequireKerberos property be set to one in order "
                                               L"for its dependent MSMQ resource to be successfully "
                                               L"brought online.\n",
                                               status);
                        } else {
                            (NetNameLogEvent)( Resource->ResourceHandle,
                                               LOG_INFORMATION,
                                               L"This resource has been upgraded for Kerberos Support due to "
                                               L"the presence of a dependent MSMQ resource\n");
                            //
                            // stop enum'ing dependent resources
                            //
                            status = ERROR_NO_MORE_ITEMS;
                        }
                    }

                    CloseClusterResource( dependentResource );
                } else {
                    (NetNameLogEvent)( Resource->ResourceHandle,
                                       LOG_ERROR,
                                       L"Unable to get a handle to cluster resource '%1!ws!' - status "
                                       L"'%2!u!'. Any MSMQ resource dependent on this Network Name resource "
                                       L"may fail to go online.\n",
                                       status = GetLastError() );
                }
            }
            else if ( status != ERROR_SUCCESS && status != ERROR_NO_MORE_ITEMS ) {
                (NetNameLogEvent)( Resource->ResourceHandle,
                                   LOG_ERROR,
                                   L"Unable to enumerate resources dependent on this Network Name resource "
                                   L" - status '%1!u!'. Any MSMQ resource dependent on this resource "
                                   L"may fail to go online.\n",
                                   status );
            }

            if ( nameBuffer != dependentResName ) {
                LocalFree( nameBuffer );
            }

            ++enumIndex;
        } while ( status == ERROR_SUCCESS );

        status = ClusterResourceCloseEnum( providerEnum );
    } else {
        (NetNameLogEvent)( Resource->ResourceHandle,
                           LOG_ERROR,
                           L"Unable to get handle enumerate the MSMQ dependent resources - status '%1!u!'. "
                           L"Any MSMQ resource dependent on this resource may fail to go online.\n",
                           GetLastError() );
    }

    CloseCluster( clusterHandle );

    return status;
} // UpgradeMSMQDependentNetnameToKerberos

/* end upgrade.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\smbshare\smbshare.c ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    smbshare.c

Abstract:

    Resource DLL for File Shares.

Author:

    Rod Gamache (rodga) 8-Jan-1996

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "lm.h"
#include "lmerr.h"
#include "lmshare.h"
#include <dfsfsctl.h>
#include <srvfsctl.h>
#include <lmdfs.h>
#include <validc.h>
#include <strsafe.h>

#define LOG_CURRENT_MODULE LOG_MODULE_SMB

#define SMB_SVCNAME  TEXT("LanmanServer")

#define DFS_SVCNAME  TEXT("Dfs")

#define MAX_RETRIES 20

#define DBG_PRINT printf

#define PARAM_KEYNAME__PARAMETERS       CLUSREG_KEYNAME_PARAMETERS

#define PARAM_NAME__SHARENAME           CLUSREG_NAME_FILESHR_SHARE_NAME
#define PARAM_NAME__PATH                CLUSREG_NAME_FILESHR_PATH
#define PARAM_NAME__REMARK              CLUSREG_NAME_FILESHR_REMARK
#define PARAM_NAME__MAXUSERS            CLUSREG_NAME_FILESHR_MAX_USERS
#define PARAM_NAME__SECURITY            CLUSREG_NAME_FILESHR_SECURITY
#define PARAM_NAME__SD                  CLUSREG_NAME_FILESHR_SD
#define PARAM_NAME__SHARESUBDIRS        CLUSREG_NAME_FILESHR_SHARE_SUBDIRS
#define PARAM_NAME__HIDESUBDIRSHARES    CLUSREG_NAME_FILESHR_HIDE_SUBDIR_SHARES
#define PARAM_NAME__DFSROOT             CLUSREG_NAME_FILESHR_IS_DFS_ROOT
#define PARAM_NAME__CSCCACHE            CLUSREG_NAME_FILESHR_CSC_CACHE

#define PARAM_MIN__MAXUSERS     0
#define PARAM_MAX__MAXUSERS     ((DWORD)-1)
#define PARAM_DEFAULT__MAXUSERS ((DWORD)-1)

#define FREE_SECURITY_INFO()                    \
        LocalFree( params.Security );           \
        params.Security = NULL;                 \
        params.SecuritySize = 0;                \
        LocalFree( params.SecurityDescriptor ); \
        params.SecurityDescriptor = NULL;       \
        params.SecurityDescriptorSize = 0

#define SMBSHARE_EXTRA_LEN              10

typedef struct _SUBDIR_SHARE_INFO {
    LIST_ENTRY      ListEntry;
    WCHAR           ShareName [NNLEN+1];
}SUBDIR_SHARE_INFO,*PSUBDIR_SHARE_INFO;


typedef struct _SHARE_PARAMS {
    LPWSTR          ShareName;
    LPWSTR          Path;
    LPWSTR          Remark;
    ULONG           MaxUsers;
    PUCHAR          Security;
    ULONG           SecuritySize;
    ULONG           ShareSubDirs;
    ULONG           HideSubDirShares;
    ULONG           DfsRoot;
    ULONG           CSCCache;
    PUCHAR          SecurityDescriptor;
    ULONG           SecurityDescriptorSize;
} SHARE_PARAMS, *PSHARE_PARAMS;

typedef struct _SHARE_RESOURCE {
    RESID                   ResId; // for validation
    SHARE_PARAMS            Params;
    HKEY                    ResourceKey;
    HKEY                    ParametersKey;
    RESOURCE_HANDLE         ResourceHandle;
    WCHAR                   ComputerName[MAX_COMPUTERNAME_LENGTH+1];
    CLUS_WORKER             PendingThread;
    CLUSTER_RESOURCE_STATE  State;
    LIST_ENTRY              SubDirList;
    HRESOURCE               hResource;
    CLUS_WORKER             NotifyWorker;
    HANDLE                  NotifyHandle;
    BOOL                    bDfsRootNeedsMonitoring;
    WCHAR                   szDependentNetworkName[MAX_COMPUTERNAME_LENGTH+1];
} SHARE_RESOURCE, *PSHARE_RESOURCE;


typedef struct _SHARE_TYPE_LIST {
    PWSTR    Name;
    ULONG    Type;
} SHARE_TYPE_LIST, *PSHARE_TYPE_LIST;

typedef struct SHARE_ENUM_CONTEXT {
    PSHARE_RESOURCE pResourceEntry;
    PSHARE_PARAMS   pParams;
} SHARE_ENUM_CONTEXT, *PSHARE_ENUM_CONTEXT;

//
// Global data.
//

CRITICAL_SECTION SmbShareLock;

// Log Event Routine

#define g_LogEvent ClusResLogEvent
#define g_SetResourceStatus ClusResSetResourceStatus

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE SmbShareFunctionTable;

//
// SmbShare resource read-write private properties
//
RESUTIL_PROPERTY_ITEM
SmbShareResourcePrivateProperties[] = {
    { PARAM_NAME__SHARENAME,        NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(SHARE_PARAMS,ShareName) },
    { PARAM_NAME__PATH,             NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(SHARE_PARAMS,Path) },
    { PARAM_NAME__REMARK,           NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(SHARE_PARAMS,Remark) },
    { PARAM_NAME__MAXUSERS,         NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__MAXUSERS, PARAM_MIN__MAXUSERS, PARAM_MAX__MAXUSERS, 0, FIELD_OFFSET(SHARE_PARAMS,MaxUsers) },
    { PARAM_NAME__SECURITY,         NULL, CLUSPROP_FORMAT_BINARY, 0, 0, 0, 0, FIELD_OFFSET(SHARE_PARAMS,Security) },
    { PARAM_NAME__SHARESUBDIRS,     NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(SHARE_PARAMS,ShareSubDirs) },
    { PARAM_NAME__HIDESUBDIRSHARES, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(SHARE_PARAMS,HideSubDirShares) },
    { PARAM_NAME__DFSROOT,          NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(SHARE_PARAMS, DfsRoot) },
    { PARAM_NAME__SD,               NULL, CLUSPROP_FORMAT_BINARY, 0, 0, 0, 0, FIELD_OFFSET(SHARE_PARAMS,SecurityDescriptor) },
    { PARAM_NAME__CSCCACHE,         NULL, CLUSPROP_FORMAT_DWORD, CSC_CACHE_MANUAL_REINT, CSC_CACHE_MANUAL_REINT, CSC_CACHE_NONE, 0, FIELD_OFFSET(SHARE_PARAMS,CSCCache) },
    { NULL, NULL, 0, 0, 0, 0 }
};

typedef struct _SMB_DEPEND_SETUP {
    DWORD               Offset;
    CLUSPROP_SYNTAX     Syntax;
    DWORD               Length;
    PVOID               Value;
} SMB_DEPEND_SETUP, *PSMB_DEPEND_SETUP;

typedef struct _SMB_DEPEND_DATA {
#if 0
    CLUSPROP_RESOURCE_CLASS storageEntry;
#endif
    CLUSPROP_SYNTAX endmark;
} SMB_DEPEND_DATA, *PSMB_DEPEND_DATA;

typedef struct _DFS_DEPEND_DATA {
#if 0
    CLUSPROP_RESOURCE_CLASS storageEntry;
#endif
    CLUSPROP_SZ_DECLARE( networkEntry, sizeof(CLUS_RESTYPE_NAME_NETNAME) / sizeof(WCHAR) );
    CLUSPROP_SYNTAX endmark;
} DFS_DEPEND_DATA, *PDFS_DEPEND_DATA;


// This table is for Smb Share dependencies only
SMB_DEPEND_SETUP SmbDependSetup[] = {
#if 0 // rodga - allow for dependency on a local disk
    { FIELD_OFFSET(SMB_DEPEND_DATA, storageEntry), CLUSPROP_SYNTAX_RESCLASS, sizeof(CLUSTER_RESOURCE_CLASS), (PVOID)CLUS_RESCLASS_STORAGE },
#endif
    { 0, 0 }
};

// This table is for DFS Share dependencies only
SMB_DEPEND_SETUP DfsDependSetup[] = {
#if 0 // rodga - allow for dependency on a local disk
    { FIELD_OFFSET(DFS_DEPEND_DATA, storageEntry), CLUSPROP_SYNTAX_RESCLASS, sizeof(CLUSTER_RESOURCE_CLASS), (PVOID)CLUS_RESCLASS_STORAGE },
#endif
    { FIELD_OFFSET(DFS_DEPEND_DATA, networkEntry), CLUSPROP_SYNTAX_NAME, sizeof(CLUS_RESTYPE_NAME_NETNAME), CLUS_RESTYPE_NAME_NETNAME },
    { 0, 0 }
};

BOOL    g_fDfsServiceNeedsRecyling = FALSE;

//
// External references
//
BOOL
SmbExamineSD(
    RESOURCE_HANDLE         ResourceHandle,
    PSECURITY_DESCRIPTOR    psdSD
    );

//
// Forward references
//

BOOL
WINAPI
SmbShareIsAlive(
    IN RESID Resource
    );

DWORD
SmbShareGetPrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
SmbShareValidatePrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PSHARE_PARAMS Params
    );

DWORD
SmbShareSetPrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );


DWORD
SmbpIsDfsRoot(
    IN PSHARE_RESOURCE ResourceEntry,
    OUT PBOOL  pbIsDfsRoot
    );


DWORD 
SmbpPrepareOnlineDfsRoot(
    IN PSHARE_RESOURCE ResourceEntry
    );


DWORD 
SmbpCreateDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry
    );

DWORD 
SmbpDeleteDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry   
    );

DWORD 
SmbpShareNotifyThread(
        IN PCLUS_WORKER pWorker,
        IN PSHARE_RESOURCE pResourceEntry
        );

DWORD 
SmbpCheckForSubDirDeletion (
    IN PSHARE_RESOURCE pResourceEntry
    );

DWORD 
SmbpCheckAndBringSubSharesOnline (
    IN PSHARE_RESOURCE pResourceEntry,
    IN BOOL IsCheckAllSubDirs,
    IN PRESOURCE_STATUS pResourceStatus,
    IN PCLUS_WORKER pWorker,
    OUT LPWSTR *pszRootDirOut
    );

DWORD
SmbpHandleDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry,
    OUT PBOOL pbIsDfsRoot
    );

DWORD
SmbpResetDfs(
    IN PSHARE_RESOURCE pResourceEntry
    );

DWORD
SmbpValidateShareName(
    IN  LPCWSTR  lpszShareName
    );

//
//  Private DFS APIs provided bu UDAYH - 4/26/2001
//
DWORD
GetDfsRootMetadataLocation( 
    LPWSTR RootName,
    LPWSTR *pMetadataNameLocation 
    );

VOID
ReleaseDfsRootMetadataLocation( 
    LPWSTR Buffer 
    );


DWORD
SmbpRecycleDfsService(
    IN PSHARE_RESOURCE pResourceEntry
    );

DWORD
SmbpSetCacheFlags(
    IN PSHARE_RESOURCE      ResourceEntry,
    IN LPWSTR               ShareName
    )
/*++

Routine Description:

    Set the caching flags for the given resource entry.

Arguments:

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

    ShareName - the name of the share to set cache flags for.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. 


--*/

{
    DWORD           status;
    DWORD           invalidParam;
    PSHARE_INFO_1005 shi1005;

    status = NetShareGetInfo( NULL,
                              ShareName,
                              1005,
                              (LPBYTE *)&shi1005 );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SetCacheFlags, error getting CSC info on share '%1!ws!. Error %2!u!.\n",
            ShareName,
            status );
        goto exit;
    } else {
        shi1005->shi1005_flags &= ~CSC_MASK;
        shi1005->shi1005_flags |= (ResourceEntry->Params.CSCCache & CSC_MASK);
        status = NetShareSetInfo( NULL,
                                  ShareName,
                                  1005,
                                  (LPBYTE)shi1005,
                                  &invalidParam );
        NetApiBufferFree((TCHAR FAR *)shi1005);
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SetCacheFlags, error setting CSC info on share '%1!ws!. Error %2!u!, property # %3!d!.\n",
                ShareName,
                status,
                invalidParam );
        }
    }

exit:

    return(status);

} // SmbpSetCacheFlags()



BOOLEAN
WINAPI
SmbShareDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        InitializeCriticalSection( &SmbShareLock );
        break;

    case DLL_PROCESS_DETACH:
        DeleteCriticalSection( &SmbShareLock );
        break;

    default:
        break;
    }

    return(TRUE);

} // SmbShareDllEntryPoint



DWORD
SmbpShareNotifyThread(
    IN PCLUS_WORKER pWorker,
    IN PSHARE_RESOURCE pResourceEntry
    )
/*++

Routine Description:

    Check whether any new subdirs have been added or deleted from
    under the root share.

Arguments:

    pWorker - Supplies the worker structure.
    
    pResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. 

--*/
{
    DWORD  status = ERROR_SUCCESS;
    LPWSTR pszRootDir;

    // 
    // Chittur Subbaraman (chitturs) - 09/25/98
    //
    // This notification thread is activated once a 
    // notification is received. This thread checks for any 
    // new subdir additions or any subdir deletions. If it
    // finds such an occurrence, this thread adds the subdir to
    // or deletes the subdir from the root share. The two
    // Smbp functions this thread calls also checks 
    // whether any termination command has arrived from the
    // offline thread. If such a command has arrived, this thread 
    // terminates immediately, thus releasing the offline thread
    // from the infinite time wait.
    //
    SmbpCheckForSubDirDeletion( pResourceEntry );
    SmbpCheckAndBringSubSharesOnline( pResourceEntry, 
                                      TRUE, 
                                      NULL, 
                                      &pResourceEntry->NotifyWorker,
                                      &pszRootDir );
    LocalFree ( pszRootDir );
      
    return(status);
} // SmbShareNotify

DWORD 
SmbpCheckForSubDirDeletion (
    IN PSHARE_RESOURCE pResourceEntry
    )
/*++

Routine Description:

    Check and remove any deleted subdirectory shares.

Arguments:

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. 

--*/
{
    PLIST_ENTRY         pHead, plistEntry;
    PSUBDIR_SHARE_INFO  pSubShareInfo;
    HANDLE              hFind;
    DWORD               status = ERROR_SUCCESS;
    DWORD               dwLen;
    LPWSTR              pszRootDir = NULL, pszPath = NULL;
    WIN32_FIND_DATA     FindData;
    DWORD               dwCount = 0;

    //
    //  Chittur Subbaraman (chitturs) - 09/25/98
    //
    //  This function first checks to see whether all the subshares
    //  are indeed currently present. If it finds any subdir 
    //  corresponding to a subshare to be absent, then it removes
    //  that subdir from the share list.
    //
    dwLen = lstrlenW( pResourceEntry->Params.Path );
    pszRootDir = ( LPWSTR ) LocalAlloc( LMEM_FIXED, ( dwLen + SMBSHARE_EXTRA_LEN ) * sizeof( WCHAR ) );
    if ( pszRootDir == NULL )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate pszRootDir. Error: %1!u!.\n",
            status = GetLastError() );
        goto error_exit;
    }

    ( void ) StringCchCopy( pszRootDir, dwLen + SMBSHARE_EXTRA_LEN, pResourceEntry->Params.Path );

    //
    // If the path is not already terminated with \\ then add it.
    //
    if ( pszRootDir [dwLen-1] != L'\\' )
        pszRootDir [dwLen++] = L'\\';

    pszRootDir [dwLen] = L'\0' ;

    pszPath = LocalAlloc ( LMEM_FIXED,  ( dwLen + SMBSHARE_EXTRA_LEN + NNLEN ) * sizeof ( WCHAR ) );

    if ( pszPath == NULL )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate pszPath. Error: %1!u!.\n",
            status = GetLastError() );
        goto error_exit;
    }

    pHead = plistEntry = &pResourceEntry->SubDirList;

    for ( plistEntry = pHead->Flink;
          plistEntry != pHead;
          dwCount++)
    {
        if ( ClusWorkerCheckTerminate ( &pResourceEntry->NotifyWorker ) )
        {
            status = ERROR_SUCCESS;
            break;
        }
        pSubShareInfo = CONTAINING_RECORD( plistEntry, SUBDIR_SHARE_INFO, ListEntry );
        plistEntry = plistEntry->Flink;                          
        if ( lstrcmpW( pSubShareInfo->ShareName, pResourceEntry->Params.ShareName ))
        {
            //
            // This is not the root share
            //
            ( void ) StringCchCopy ( pszPath, dwLen + SMBSHARE_EXTRA_LEN + NNLEN, pszRootDir );
            ( void ) StringCchCat ( pszPath, dwLen + SMBSHARE_EXTRA_LEN + NNLEN, pSubShareInfo->ShareName );
            
            //
            // Get rid of the hidden share '$' sign for passing onto
            // FindFirstFile, if present. Only do this if the 
            // "HideSubDirShares" option is chosen.
            //
            if ( pResourceEntry->Params.HideSubDirShares )
            {
                dwLen = lstrlenW( pszPath );
                if ( pszPath [dwLen-1] == L'$' )
                {
                    pszPath [dwLen-1] = L'\0';
                }
            }
            
            hFind = FindFirstFile( pszPath, &FindData );                          
            if ( hFind == INVALID_HANDLE_VALUE ) 
            {    
                status = GetLastError();
                 
                (g_LogEvent)(
                    pResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbpCheckForSubDirDeletion: Dir '%1' not found ...\n",
                    pszPath
                );
                            
                if ( status == ERROR_FILE_NOT_FOUND )
                { 
                    //
                    // Delete the file share
                    //                           
                    status = NetShareDel( NULL, pSubShareInfo->ShareName, 0 );
                    if ( (status != NERR_NetNameNotFound) && 
                         (status != NO_ERROR) )
                    {
                        (g_LogEvent)(
                            pResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"SmbpCheckForSubDirDeletion: Error removing share '%1'. Error code = %2!u!...\n",
                            pSubShareInfo->ShareName,
                            status );                        
                    } else
                    {
                        (g_LogEvent)(
                            pResourceEntry->ResourceHandle,
                            LOG_INFORMATION,
                            L"SmbpCheckForSubDirDeletion: Removing share '%1'...\n",
                            pSubShareInfo->ShareName );
                        RemoveEntryList( &pSubShareInfo->ListEntry );
                        LocalFree ( pSubShareInfo );                         
                    }
                }  
                else 
                {   
                    (g_LogEvent)(
                        pResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"SmbpCheckForSubDirDeletion: Error in FindFirstFile for share '%1'. Error code = %2!u!....\n",
                        pSubShareInfo->ShareName,
                        status );
                }               
            }
            else
            {
                if ( !FindClose ( hFind ) )
                {
                    (g_LogEvent)(
                        pResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"CheckForSubDirDeletion: FindClose Failed. Error: %1!u!.\n",
                        status = GetLastError () );
                }
            }
        } 
   } // end of for loop 

error_exit:
    LocalFree ( pszRootDir );   
    LocalFree ( pszPath );    
    return(status);
} // SmbpCheckForSubDirDeletion

DWORD 
SmbpCheckAndBringSubSharesOnline (
    IN PSHARE_RESOURCE pResourceEntry,
    IN BOOL IsCheckAllSubDirs, 
    IN PRESOURCE_STATUS pResourceStatus,
    IN PCLUS_WORKER pWorker,
    OUT LPWSTR *pszRootDirOut
    )
/*++

Routine Description:

    Check and bring online any newly added subdirectory shares.

Arguments:

    pResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.
    
    IsCheckAllSubDirs - Check whether a subdir is a share or not
    
    pResourceStatus - A pointer to the RESOURCE_STATUS

    pWorker - A pointer to the worker thread
    
    pszRootDirOut - A pointer to the root share store

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. 

--*/
{
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR szPath [MAX_PATH+1];
    DWORD dwLen, dwShareLen;
    DWORD dwCount = 0;
    SHARE_INFO_502  shareInfo;
    PSHARE_INFO_502 pshareInfo = NULL;
    WCHAR szShareName [NNLEN+2];
    DWORD status = ERROR_SUCCESS;
    PSUBDIR_SHARE_INFO  pSubShareInfo;
    PLIST_ENTRY         plistEntry;
    RESOURCE_EXIT_STATE exitState;
    LPWSTR  pszRootDir = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 09/25/98
    //
    //  This function will be called either from SmbpShareOnlineThread
    //  with the input parameter IsCheckAllSubDirs set to FALSE
    //  or from SmbpShareNotifyThread with the parameter set to TRUE.
    //  In the former case, this function will blindly make all the
    //  subdirs under the root share as shares. In the latter case,
    //  this function will first check whether a particular subdir
    //  is a share and if not it will make it as a share. 
    //
   
    dwLen = lstrlenW( pResourceEntry->Params.Path );
    plistEntry = &pResourceEntry->SubDirList;

    // 
    // Allocate memory to store the root share here and
    // free it at the caller
    //
    pszRootDir = ( LPWSTR ) LocalAlloc( LMEM_FIXED, ( dwLen + SMBSHARE_EXTRA_LEN ) * sizeof( WCHAR ) );

    if ( pszRootDir == NULL )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate pszRootDir. Error: %1!u!.\n",
            status = GetLastError() );
        goto error_exit;
    }

    ( void ) StringCchCopy( pszRootDir, dwLen + SMBSHARE_EXTRA_LEN, pResourceEntry->Params.Path );

    //
    // If the path is not already terminated with \\ then add it.
    //
    if ( pszRootDir [dwLen-1] != L'\\' )
        pszRootDir [dwLen++] = L'\\';

    //
    // Add '*' to search all the files.
    //
    pszRootDir [dwLen++] = L'*' ;
    pszRootDir [dwLen] = L'\0' ;

    ZeroMemory( &shareInfo, sizeof( shareInfo ) );
    shareInfo.shi502_path =         szPath;
    shareInfo.shi502_netname =      szShareName;
    shareInfo.shi502_type =         STYPE_DISKTREE;
    shareInfo.shi502_remark =       pResourceEntry->Params.Remark;
    shareInfo.shi502_max_uses =     pResourceEntry->Params.MaxUsers;
    shareInfo.shi502_passwd =       NULL;
    shareInfo.shi502_security_descriptor = pResourceEntry->Params.SecurityDescriptor;

    // 
    // Find the first file in the root dir
    //
    if ( ( hFind = FindFirstFile( pszRootDir, &FindData ) ) == INVALID_HANDLE_VALUE ) {
        status = GetLastError () ;

        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        } else {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"CheckForSubDirAddition: FindFirstFile Failed For Root Share... Error: %1!u!.\n",
                    status );
        }
        goto error_exit;
    }

    //
    // Remove the '*' so the same variable can be used later.
    //
    pszRootDir [dwLen-1] = L'\0' ;


    while ( status == ERROR_SUCCESS ) { 
        if ( ClusWorkerCheckTerminate ( pWorker ) == TRUE ) {
            status = ERROR_SUCCESS;
            goto error_exit;
        }
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) { 
            //
            //  Check only subdirectories, not files
            //
            dwShareLen = lstrlenW( FindData.cFileName );

            if ( dwShareLen <= NNLEN && (dwLen + dwShareLen < MAX_PATH) )   // A safety check for overflow
            {
                ( void ) StringCchCopy( szShareName, RTL_NUMBER_OF ( szShareName ), FindData.cFileName );

                if ( szShareName[0] == L'.' )
                {
                    if ( szShareName [1] == L'\0' ||
                            szShareName[1] == L'.' && szShareName [2] == L'\0' ) {
                        goto skip;
                    }
                }
            

                if ( pResourceEntry->Params.HideSubDirShares )
                    ( void ) StringCchCat( szShareName, RTL_NUMBER_OF ( szShareName ), L"$" );

                ( void ) StringCchCopy ( szPath, RTL_NUMBER_OF ( szPath ), pszRootDir );
                ( void ) StringCchCat ( szPath, RTL_NUMBER_OF ( szPath ), FindData.cFileName );

                if ( IsCheckAllSubDirs == TRUE )
                {  
                    // 
                    // If this call is made from the notify thread,
                    // try to see whether a particular subdir is a
                    // share
                    //
                    status = NetShareGetInfo( NULL,
                                szShareName,
                                502, // return a SHARE_INFO_502 structure
                                (LPBYTE *) &pshareInfo );
                } else
                {
                    //
                    // If this call is made from the online thread,
                    // assume that the subdir is not a share (since
                    // it would have been removed as a share the 
                    // most recent time when it was made offline).
                    //
                    status = NERR_NetNameNotFound;
                }                                                      
                            
                if ( status == NERR_NetNameNotFound )
                {                  
                    status = NetShareAdd( NULL, 502, (PBYTE)&shareInfo, NULL );
             
                    if ( status == ERROR_SUCCESS )
                    {
                        pSubShareInfo = (PSUBDIR_SHARE_INFO) LocalAlloc( LMEM_FIXED, sizeof(SUBDIR_SHARE_INFO) );
                        if ( pSubShareInfo == NULL )
                        {
                            (g_LogEvent)(
                                pResourceEntry->ResourceHandle,
                                LOG_ERROR,
                                L"SmbpCheckAndBringSubSharesOnline: Unable to allocate pSubShareInfo. Error: %1!u!.\n",
                                status = GetLastError() );
                            goto error_exit;
                        }

                        ( void ) StringCchCopy ( pSubShareInfo->ShareName, RTL_NUMBER_OF ( pSubShareInfo->ShareName ), szShareName );
                        InsertTailList( plistEntry, &pSubShareInfo->ListEntry );

                        //
                        // Set the caching flags for this entry.
                        //
                        status = SmbpSetCacheFlags( pResourceEntry,
                                                    szShareName );
                        if ( status != ERROR_SUCCESS ) {
                            goto error_exit;
                        }

                        (g_LogEvent)(
                            pResourceEntry->ResourceHandle,
                            LOG_INFORMATION,
                            L"SmbpCheckAndBringSubSharesOnline: Adding share '%1'...\n",
                            pSubShareInfo->ShareName);
            
                        if ( IsCheckAllSubDirs == FALSE )
                        {
                            if ( (dwCount++ % 100) == 0)
                            {
                                pResourceStatus->CheckPoint++;
                                exitState = (g_SetResourceStatus)( pResourceEntry->ResourceHandle,
                                            pResourceStatus );
                                if ( exitState == ResourceExitStateTerminate ) 
                                {
                                    status = ERROR_OPERATION_ABORTED;
                                    goto error_exit;
                                }
                            } 
                        }
                    }
                    else
                    {
                        //
                        // ignore this error but log that something went wrong
                        //
                        (g_LogEvent)(
                            pResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"SmbpCheckAndBringSubSharesOnline: NetShareAdd failed for %1!ws! Error: %2!u!.\n",
                            szShareName,
                            status );
                        status = ERROR_SUCCESS;
                    }
                } else
                {
                    if ( pshareInfo != NULL )
                    {
                        NetApiBufferFree( pshareInfo );
                    }
                }
            }
            else
            {
                (g_LogEvent)(
                    pResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbpCheckAndBringSubSharesOnline: NetShareAdd Share not added for subdir due to illegal share name length '%1!ws!'.\n",
                    FindData.cFileName );
            }
        }
              
    skip:
        if ( !FindNextFile( hFind, &FindData ) )
        {
            status = GetLastError ();
        }       
    } // end of while loop

    if ( status == ERROR_NO_MORE_FILES )
    {
        status = ERROR_SUCCESS;
    }
    else
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"CheckForSubDirAddition: FindNextFile Failed. Error: %1!u!.\n",
            status );
    }
  
error_exit:
    if ( hFind != INVALID_HANDLE_VALUE  )
    {
        if( !FindClose (hFind) )
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpCheckAndBringSubSharesOnline: FindClose Failed. Error: %1!u!.\n",
                    status = GetLastError () );
        }
    }

    *pszRootDirOut = pszRootDir;
        
    return(status);   
} // SmbpCheckAndBringSubSharesOnline


DWORD
SmbShareOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PSHARE_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a share resource online.

Arguments:

    pWorker - Supplies the worker structure

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    SHARE_INFO_502  shareInfo;
    DWORD           retry = MAX_RETRIES;
    DWORD           status;
    RESOURCE_STATUS resourceStatus;
    LPWSTR          nameOfPropInError;
    BOOL            bIsExistingDfsRoot = FALSE;
    BOOL            bDfsRootCreationFailed = FALSE;
    DWORD           dwLen;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceOnlinePending;
    // resourceStatus.CheckPoint = 1;

    //
    // Read parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ParametersKey,
                                                   SmbShareResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto exit;
    }

    if ( (ResourceEntry->Params.SecurityDescriptorSize != 0) &&
         !IsValidSecurityDescriptor(ResourceEntry->Params.SecurityDescriptor) ) {
        status = GetLastError();
        goto exit;
    }

    while ( retry-- )
    {        
        //
        // Make sure the path does _NOT_ have a trailing backslash or it will fail to
        // come online. But accept paths of the form E:\.
        //
        dwLen = ( DWORD ) wcslen( ResourceEntry->Params.Path );
        if ( ( ResourceEntry->Params.Path[ dwLen - 1 ] == L'\\' ) &&
             ( dwLen > 3 ) ) 
        {
            ResourceEntry->Params.Path[ dwLen - 1 ] = L'\0'; // wack it.
        }

        ZeroMemory( &shareInfo, sizeof( shareInfo ) );
        shareInfo.shi502_netname =      ResourceEntry->Params.ShareName;
        shareInfo.shi502_type =         STYPE_DISKTREE;
        shareInfo.shi502_remark =       ResourceEntry->Params.Remark;
        shareInfo.shi502_max_uses =     ResourceEntry->Params.MaxUsers;
        shareInfo.shi502_path =         ResourceEntry->Params.Path;
        shareInfo.shi502_passwd =       NULL;
        shareInfo.shi502_security_descriptor = ResourceEntry->Params.SecurityDescriptor;

        status = NetShareAdd( NULL, 502, (PBYTE)&shareInfo, NULL );

        if ( status == ERROR_SUCCESS ) {
            status = SmbpSetCacheFlags( ResourceEntry,
                                        ResourceEntry->Params.ShareName );
            if ( status != ERROR_SUCCESS ) {
                goto exit;
            }
            break;
        }

        // If we get a failure about the server not being started, then
        // try to start the server and wait a little while.

        if ( status != ERROR_SUCCESS ) {
            WCHAR errorValue[20];

            ( void ) StringCchPrintf( errorValue, RTL_NUMBER_OF ( errorValue ), L"%u", status );
            ClusResLogSystemEventByKey1(ResourceEntry->ResourceKey,
                                        LOG_CRITICAL,
                                        RES_SMB_SHARE_CANT_ADD,
                                        errorValue);
            if ( status == NERR_ServerNotStarted ) {
                ResUtilStartResourceService( SMB_SVCNAME,
                                             NULL );
                Sleep( 500 );
            } else if ( status == NERR_DuplicateShare ) {

                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"Share %1!ws! is online already; deleting share and creating it again\n",
                    ResourceEntry->Params.ShareName);

                //
                // Delete the share and try again.
                //
                status = NetShareDel( NULL, ResourceEntry->Params.ShareName, 0 );
                if ( status == NERR_IsDfsShare )
                {
                    //
                    // Chittur Subbaraman (chitturs) - 2/12/99
                    // 
                    // Reset the state info in the dfs driver dfs.sys 
                    // and stop it. This will let srv.sys let you delete 
                    // the share.
                    //
                    status = SmbpResetDfs( ResourceEntry ); 
                    //
                    // If we can't do this exit, else retry deleting and
                    // adding the share once again
                    //
                    if (status != ERROR_SUCCESS) {
                        (g_LogEvent)(
                            ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"SmbpResetDfs for Share %1!ws! failed with error %2!u!\n",
                            ResourceEntry->Params.ShareName,
                            status);
                        goto exit;
                    } 
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Informing DFS that share %1!ws! is not a dfs root \n",
                        ResourceEntry->Params.ShareName);
                } else
                {
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"Share %1!ws! deleted successfully ! \n",
                        ResourceEntry->Params.ShareName);
                }
            } else {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Error creating share. Error: %1!u!.\n",
                    status );
                goto exit;
            }
        }
    }  // End for while ( retry-- )

    if ( status == ERROR_SUCCESS )
    {
        // The share is now online, bring the subshares online

        PLIST_ENTRY plistEntry;
        PSUBDIR_SHARE_INFO pSubShareInfo;
        LPWSTR pszRootDir;
        
        plistEntry = &ResourceEntry->SubDirList;

        //
        // Store the Root share. This info is used to delete the share.
        //
        pSubShareInfo = (PSUBDIR_SHARE_INFO) LocalAlloc( LMEM_FIXED, sizeof (SUBDIR_SHARE_INFO) );
        if ( pSubShareInfo == NULL ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to allocate pSubShareInfo. Error: %1!u!.\n",
                status = GetLastError() );
            goto exit;
        }

        ( void ) StringCchCopy ( pSubShareInfo->ShareName, RTL_NUMBER_OF ( pSubShareInfo->ShareName ), ResourceEntry->Params.ShareName );
        InsertTailList( plistEntry, &pSubShareInfo->ListEntry );

        if ( ResourceEntry->Params.ShareSubDirs ) {
            // Chittur Subbaraman (chitturs) - 09/25/98
            //
            // Try to bring the subshares online.
            // If there is a failure in bringing subshares online,
            // pretend all is well since at least the root
            // share has been successfully created. However, we
            // write an entry into the log.
            //
            SmbpCheckAndBringSubSharesOnline ( ResourceEntry, 
                                               FALSE,  
                                               &resourceStatus,
                                               &ResourceEntry->PendingThread,
                                               &pszRootDir
                                             );
            if ( ClusWorkerCheckTerminate( &ResourceEntry->PendingThread ) ) {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"SmbpShareOnlineThread: Terminating... !!!\n"
                );
                status = ERROR_SUCCESS;
                LocalFree ( pszRootDir );
                goto exit;
            }

            // Chittur Subbaraman (chitturs) - 09/25/98
            //
            // Create a change notification handle for any subdirectory
            // additions/deletions and a notify thread which continuously 
            // checks and acts upon any such notifications. Do this
            // only once at the beginning. The notification thread
            // closes the handle at termination time.
            //
            ResourceEntry->NotifyHandle = FindFirstChangeNotification(
                                                pszRootDir,
                                                FALSE,
                                                FILE_NOTIFY_CHANGE_DIR_NAME
                                           );
            
            LocalFree ( pszRootDir );
                        
            if ( ResourceEntry->NotifyHandle == INVALID_HANDLE_VALUE )
            {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbpShareOnlineThread: FindFirstChange Notification Failed. Error: %1!u!.\n",
                    GetLastError ());
                status = ERROR_SUCCESS;
                goto exit;
            }                   
            goto exit;
        }
    } // End for root share successfully created.

    //
    // Chittur Subbaraman (chitturs) - 2/10/99
    //
    // If the user requests for this resource to be a DFS root, the
    // dfs root will be created/accepted and the dfs registry
    // checkpoints will be added. On the other hand, if the user
    // wants this resource not to function as a dfs root any more,
    // that case is also taken care of.
    //
    status = SmbpHandleDfsRoot( ResourceEntry, &bIsExistingDfsRoot );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpHandleDfsRoot for Share %1!ws! failed with error %2!u!\n",
            ResourceEntry->Params.ShareName,
            status);
        bDfsRootCreationFailed = TRUE;
        goto exit;
    }

    if ( bIsExistingDfsRoot ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Share %1!ws! is a dfs root, online dfs\n",
            ResourceEntry->Params.ShareName);
        status = SmbpPrepareOnlineDfsRoot( ResourceEntry );
        if ( status != ERROR_SUCCESS ) {
            bDfsRootCreationFailed = TRUE;
        }
    }

exit:
    if ( status != ERROR_SUCCESS ) {
        if ( bDfsRootCreationFailed ) {
            WCHAR   szErrorString[12];
            
            ( void ) StringCchPrintf ( szErrorString, RTL_NUMBER_OF ( szErrorString ), L"%u", status);
            ClusResLogSystemEventByKeyData1( ResourceEntry->ResourceKey,
                                             LOG_CRITICAL,
                                             RES_SMB_CANT_ONLINE_DFS_ROOT,
                                             sizeof( status ),
                                             &status,
                                             szErrorString );           
        } else {
            ClusResLogSystemEventByKeyData( ResourceEntry->ResourceKey,
                                            LOG_CRITICAL,
                                            RES_SMB_CANT_CREATE_SHARE,
                                            sizeof( status ),
                                            &status );
        }
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error %1!u! bringing share %2!ws!, path %3!ws! online.\n",
            status,
            ResourceEntry->Params.ShareName,
            ResourceEntry->Params.Path );
        resourceStatus.ResourceState = ClusterResourceFailed;
    } else {
        resourceStatus.ResourceState = ClusterResourceOnline;
    }

    ResourceEntry->State = resourceStatus.ResourceState;

    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return(status);

} // SmbShareOnlineThread



RESID
WINAPI
SmbShareOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for SMB share resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - Supplies handle to resource's cluster registry key.

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    DWORD           status;
    RESID           resid = 0;
    HKEY            parametersKey = NULL;
    HKEY            resKey = NULL;
    PSHARE_RESOURCE resourceEntry = NULL;
    DWORD           computerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    HCLUSTER        hCluster;

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey);
    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        SetLastError( status );
        return(0);
    }
    //
    // Open the Parameters key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                PARAM_KEYNAME__PARAMETERS,
                                KEY_ALL_ACCESS,
                                &parametersKey );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open Parameters key. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Allocate a resource entry.
    //

    resourceEntry = (PSHARE_RESOURCE) LocalAlloc( LMEM_FIXED, sizeof(SHARE_RESOURCE) );

    if ( resourceEntry == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Initialize the resource entry..
    //

    ZeroMemory( resourceEntry, sizeof(SHARE_RESOURCE) );

    resourceEntry->ResId = (RESID)resourceEntry; // for validation
    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->State = ClusterResourceOffline;
    resourceEntry->NotifyHandle = INVALID_HANDLE_VALUE;

    InitializeListHead( &resourceEntry->SubDirList );

    hCluster = OpenCluster( NULL );
    if ( !hCluster ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open cluster. Error: %1!u!.\n",
            status );
        goto exit;
    }

    resourceEntry->hResource = OpenClusterResource( hCluster,
                                                    ResourceName );
    CloseCluster( hCluster );
    if ( !resourceEntry->hResource ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open cluster resource. Error: %1!u!.\n",
            status );
        goto exit;
    }

    if ( !GetComputerNameW( &resourceEntry->ComputerName[0],
                            &computerNameSize ) ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to get computer name. Error: %1!u!.\n",
            status );
        goto exit;
    }

    resid = (RESID)resourceEntry;

exit:

    if ( resid == 0 ) {
        if ( parametersKey != NULL ) {
            ClusterRegCloseKey( parametersKey );
        }
        if ( resKey != NULL ) {
            ClusterRegCloseKey( resKey );
        }
        if ( resourceEntry &&
             resourceEntry->hResource ) {
            CloseClusterResource( resourceEntry->hResource );
        }
        LocalFree( resourceEntry );
    }

    SetLastError( status );
    return(resid);

} // SmbShareOpen


DWORD
WINAPI
SmbShareOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for File Share resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    DWORD           status;
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: Online request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n" );
#endif

    resourceEntry->State = ClusterResourceOffline;
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               SmbShareOnlineThread,
                               resourceEntry );
    if ( status != ERROR_SUCCESS ) {
        resourceEntry->State = ClusterResourceFailed;
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // SmbShareOnline


DWORD
SmbShareDoTerminate (
    IN PSHARE_RESOURCE ResourceEntry,
    IN PRESOURCE_STATUS presourceStatus
    )

/*++

Routine Description:

    Do the actual Terminate work for File Share resources.

Arguments:

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.
    presourceStatus - A pointer to the RESOURCE_STATUS. This will be NULL if called from TERMINATE.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure. If more than one share delete fails then
    the last error is returned.

--*/

{
    DWORD               status = ERROR_SUCCESS, dwRet;
    PLIST_ENTRY         pHead, plistEntry;
    PSUBDIR_SHARE_INFO  pSubShareInfo;

#define SMB_DELETED_SHARES_REPORT_FREQ  100

    DWORD               dwSharesDeleted = SMB_DELETED_SHARES_REPORT_FREQ;
    DWORD               dwRetryCount;
    BOOL                bRetry;
    RESOURCE_EXIT_STATE exit;

    //
    // Chittur Subbaraman (chitturs) - 09/25/98
    //
    // Terminate the notification thread first, so you can
    // clean up even if the notification thread is forced to 
    // stop in the middle of its task. Also close the notification
    // handle.
    //
    ClusWorkerTerminate( &ResourceEntry->NotifyWorker );

    if ( ResourceEntry->NotifyHandle )
    {
        FindCloseChangeNotification ( ResourceEntry->NotifyHandle );
        ResourceEntry->NotifyHandle = INVALID_HANDLE_VALUE;
    }
    
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SmbShareDoTerminate: SmbpShareNotifyWorker Terminated... !!!\n"
    );

    pHead = plistEntry = &ResourceEntry->SubDirList;

    for ( plistEntry = pHead->Flink;
          plistEntry != pHead;
          dwSharesDeleted--
        )
    {
        pSubShareInfo = CONTAINING_RECORD( plistEntry, SUBDIR_SHARE_INFO, ListEntry );
        dwRetryCount = 1;
        bRetry = FALSE;
        do
        {
            dwRet = NetShareDel( NULL, pSubShareInfo->ShareName, 0 );
            status = dwRet;
            if ( dwRet != NO_ERROR )
            {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Error removing share '%1'. Error %2!u!.\n",
                    pSubShareInfo->ShareName,
                    dwRet );
                if (dwRet == NERR_IsDfsShare && !bRetry)
                {
                    //
                    // Chittur Subbaraman (chitturs) - 2/12/99
                    //
                    // If this is a dfs root, reset the dfs driver and
                    // stop it. This will let you delete the share.
                    //
                    dwRet = SmbpResetDfs( ResourceEntry );
                    //
                    // If this fails, log an error
                    // else try and offline the resource again.
                    //
                    if (dwRet == ERROR_SUCCESS) 
                    {
                        bRetry = TRUE;
                    }
                    else
                    {
                        (g_LogEvent)(
                            ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"Error in offlining the dfs root at this share '%1'. Error %2!u!.\n",
                            pSubShareInfo->ShareName,
                            dwRet );
                        status = dwRet;
                    }
                } 
            } 
        } while (dwRetryCount-- && bRetry);

        //
        // if we're updating our status to resmon, do so every
        // SMB_DELETED_SHARES_REPORT_FREQ shares
        //
        if ( presourceStatus && ( dwSharesDeleted == 0 )) {
            presourceStatus->CheckPoint++;
            exit = (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                                          presourceStatus );
            if ( exit == ResourceExitStateTerminate ) {
                status = ERROR_OPERATION_ABORTED;
            }

            dwSharesDeleted = SMB_DELETED_SHARES_REPORT_FREQ;
        }

        plistEntry = plistEntry->Flink;

        LocalFree (pSubShareInfo);
    }

    // This should initialize the list back to NULL
    InitializeListHead(pHead);

    ResourceEntry->bDfsRootNeedsMonitoring = FALSE;

    return(status);
} // SmbShareDoTerminate


DWORD
SmbShareOfflineThread (
    IN PCLUS_WORKER pWorker,
    IN PSHARE_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a share resource offline.
    Do the actual Terminate work for File Share resources.

Arguments:

    pWorker - Supplies the worker structure

    ResourceEntry - A pointer to the SHARE_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    RESOURCE_STATUS resourceStatus;
    DWORD           status;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceOfflinePending;

    resourceStatus.ResourceState = (status = SmbShareDoTerminate (ResourceEntry, &resourceStatus)) == ERROR_SUCCESS?
                                                ClusterResourceOffline:
                                                ClusterResourceFailed;


    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    ResourceEntry->State = resourceStatus.ResourceState;
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Smbshare is now offline.\n" );

    return(status);

} // SmbShareOfflineThread



VOID
WINAPI
SmbShareTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for File Share resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: Terminate request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" );
#endif

    ClusWorkerTerminate( &resourceEntry->PendingThread );

    //
    // Terminate the resource.
    //
    SmbShareDoTerminate( resourceEntry, NULL);

} // SmbShareTerminate



DWORD
WINAPI
SmbShareOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for File Share resource.

Arguments:

    ResourceId - Supplies the resource it to be taken offline

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

--*/

{
    DWORD status;
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: Offline request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n" );
#endif

    //
    // Terminate the resource.
    //
    // ClusWorkerTerminate( &resourceEntry->OfflineThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               SmbShareOfflineThread,
                               resourceEntry );

    if ( status != ERROR_SUCCESS ) {
        resourceEntry->State = ClusterResourceFailed;
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline: Unable to start thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return status;

} // SmbShareOffline



BOOL
SmbShareCheckIsAlive(
    IN PSHARE_RESOURCE ResourceEntry,
    IN BOOL     IsAliveCheck
    )

/*++

Routine Description:

    Check to see if the resource is alive for File Share resources.

Arguments:

    ResourceEntry - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    DWORD           status;
    BOOL            success = TRUE;
    PSHARE_INFO_502 shareInfo;
    WCHAR           szErrorString[12];

    EnterCriticalSection( &SmbShareLock );

    //
    // Determine if the resource is online.
    //
    status = NetShareGetInfo( NULL,
                              ResourceEntry->Params.ShareName,
                              502, // return a SHARE_INFO_502 structure
                              (LPBYTE *) &shareInfo );

    if ( status == NERR_NetNameNotFound ) {
        ClusResLogSystemEventByKey(ResourceEntry->ResourceKey,
                                   LOG_CRITICAL,
                                   RES_SMB_SHARE_NOT_FOUND);
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"NERR_NetNameNotFound :share '%1!ws!' no longer exists.\n",
            ResourceEntry->Params.ShareName );
        success = FALSE;
    } else if ( status != ERROR_SUCCESS ) {
        ( void ) StringCchPrintf ( szErrorString, RTL_NUMBER_OF ( szErrorString ), L"%u", status);
        ClusResLogSystemEventByKeyData1(ResourceEntry->ResourceKey,
                                        LOG_CRITICAL,
                                        RES_SMB_SHARE_FAILED,
                                        sizeof(status),
                                        &status,
                                        szErrorString);
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error checking for share. Error %1!u!.\n",
            status );
        success = FALSE;
    }

    LeaveCriticalSection( &SmbShareLock );

    if ( success ) {
        NetApiBufferFree( shareInfo );
        if ( IsAliveCheck ) {
            HANDLE      fileHandle;
            WIN32_FIND_DATA fileData;
            WCHAR       shareName[MAX_COMPUTERNAME_LENGTH + NNLEN + SMBSHARE_EXTRA_LEN];
            DWORD       dwLoopCnt = 0;

            ( void ) StringCchPrintf( shareName,
                             RTL_NUMBER_OF ( shareName ),
                             L"\\\\%ws\\%ws\\*.*\0",
                             ResourceEntry->ComputerName,
                             ResourceEntry->Params.ShareName );

            fileHandle = FindFirstFileW( shareName,
                                         &fileData );

            //
            // If we fail on the first attempt, try again. There seems to be a
            // bug in the RDR where the first attempt to read a share after it
            // has been deleted and reinstated.  The bug is that the RDR
            // returns failure on the first operation following the
            // reinstatement of the share.
            //

            if ( fileHandle == INVALID_HANDLE_VALUE ) {
                fileHandle = FindFirstFileW( shareName,
                                             &fileData );
            }

            //
            // If we succeeded in finding a file, or there were no files in the
            // path, then return success, otherwise we had a failure.
            //
            status = GetLastError();

            //
            // Chittur Subbaraman (chitturs) - 12/6/1999
            //
            // If FindFirstFile returns ERROR_NETNAME_DELETED, it 
            // could possibly because the netname resource deletes
            // all loopback sessions during the offline process. So,
            // sleep and retry the call.
            //
            while( ( fileHandle == INVALID_HANDLE_VALUE ) &&
                   ( status == ERROR_NETNAME_DELETED ) && 
                   ( dwLoopCnt++ < 3 ) ) {
                Sleep( 50 );
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Retrying FindFirstFile on error %1!u! for share %2!ws! !\n",
                    status,
                    shareName);
                fileHandle = FindFirstFileW( shareName,
                                             &fileData );
                status = GetLastError();
            } 

            if ( (fileHandle == INVALID_HANDLE_VALUE) &&
                 (status != ERROR_FILE_NOT_FOUND) &&
                 (status != ERROR_ACCESS_DENIED) ) {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Share has gone offline, Error=%1!u! !\n",
                    status);
                SetLastError(status);          
                ( void ) StringCchPrintf ( szErrorString, RTL_NUMBER_OF ( szErrorString ), L"%u", status);
                ClusResLogSystemEventByKeyData1(ResourceEntry->ResourceKey,
                                                LOG_CRITICAL,
                                                RES_SMB_SHARE_FAILED,
                                                sizeof(status),
                                                &status,
                                                szErrorString);
                return(FALSE);
            }

            FindClose( fileHandle );

        }
    } else {
        SetLastError(status);
    }

    // 
    //  Chittur Subbaraman (chitturs) - 2/18/99
    //
    //  If this share is a dfs root, check whether the root is still alive
    //
    if ( success && ResourceEntry->bDfsRootNeedsMonitoring )
    {
        PDFS_INFO_1     pDfsInfo1 = NULL;
        WCHAR           szDfsEntryPath[MAX_COMPUTERNAME_LENGTH + NNLEN + SMBSHARE_EXTRA_LEN];
        
        //
        //  Prepare a path of the form \\VSName\ShareName to pass into DFS API.
        //
        ( void ) StringCchCopy ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), L"\\\\" );
        ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), ResourceEntry->szDependentNetworkName );
        ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), L"\\" );
        ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), ResourceEntry->Params.ShareName );

        //
        //  Try to see whether the dfs root is alive.
        //
        status = NetDfsGetInfo( szDfsEntryPath,             // Root share
                                NULL,                       // Remote server
                                NULL,                       // Remote share
                                1,                          // Info Level
                                ( LPBYTE * ) &pDfsInfo1 );  // Out buffer

        if ( status == NERR_Success )
        {
            if ( pDfsInfo1 != NULL )
            {
                NetApiBufferFree( pDfsInfo1 );
            }
        } else 
        {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Status of looks alive check for dfs root is %1!u! !\n",
                status);

            ( void ) StringCchPrintf ( szErrorString, RTL_NUMBER_OF ( szErrorString ), L"%u", status);
            ClusResLogSystemEventByKeyData1(ResourceEntry->ResourceKey,
                                      LOG_CRITICAL,
                                      RES_SMB_SHARE_FAILED,
                                      sizeof(status),
                                      &status,
                                      szErrorString);
            SetLastError( status );
            return( FALSE );
        }

        if ( IsAliveCheck )
        {
            //
            //  Make a thorough check to see whether the root share
            //  name matches the resource's share name.
            //
            status = SmbpIsDfsRoot( ResourceEntry, &success );
        
            if ( ( status != ERROR_SUCCESS ) ||
                 ( success == FALSE ) )
            {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Dfs root has been deleted/inaccessible, Error=%1!u! Root existence=%2!u! !\n",
                    status,
                    success);
                if( status != ERROR_SUCCESS ) 
                {   
                    SetLastError( status );
                    ( void ) StringCchPrintf ( szErrorString, RTL_NUMBER_OF ( szErrorString ), L"%u", status);
                    ClusResLogSystemEventByKeyData1(ResourceEntry->ResourceKey,
                                                    LOG_CRITICAL,
                                                    RES_SMB_SHARE_FAILED,
                                                    sizeof(status),
                                                    &status,
                                                    szErrorString);
                }
                return( FALSE );
            }
        }
    }

    return(success);

} // SmbShareCheckIsAlive



BOOL
SmbShareIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for File Share resource. Also creates a 
    notification thread if any outstanding notifications are
    present.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    PSHARE_RESOURCE resourceEntry;
    DWORD           status;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: IsAlive request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" );
#endif
    if ( ( ( resourceEntry->NotifyWorker ).hThread == NULL )
        && ( resourceEntry->NotifyHandle != INVALID_HANDLE_VALUE ) )
    {
        //
        // Chittur Subbaraman (chitturs) - 09/27/98
        //
        // No notify thread is active at this time (we don't want to
        // deal with concurrency issues with multiple notify threads
        // running concurrently since we decided to anyway use the 
        // rather slow approach of checking for and acting upon 
        // notifications within this function which may not be called 
        // frequently)
        //
        status = WaitForSingleObject( resourceEntry->NotifyHandle, 0 );
        if ( status == WAIT_OBJECT_0 )
        {
            FindNextChangeNotification( resourceEntry->NotifyHandle );

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"SmbShareIsAlive: Directory change notification received!!!\n"
            );
        
            status = ClusWorkerCreate(
                    &resourceEntry->NotifyWorker, 
                    SmbpShareNotifyThread,
                    resourceEntry                        
                    );
              
            if (status != ERROR_SUCCESS)
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbShareIsAlive: Unable to start thread for monitoring subdir creations/deletions ! ResourceId = %1!u!.\n",
                    resourceEntry->ResId);
            } 
        }
    }

    //
    // Determine if the resource is online.
    //
    return(SmbShareCheckIsAlive( resourceEntry, TRUE ));

} // SmbShareIsAlive



BOOL
WINAPI
SmbShareLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for File Share resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: LooksAlive request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n" );
#endif

    //
    // Determine if the resource is online.
    //
    return(SmbShareCheckIsAlive( resourceEntry, FALSE ));

} // SmbShareLooksAlive



VOID
WINAPI
SmbShareClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for File Share resource.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PSHARE_RESOURCE resourceEntry;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );
#endif

    //
    //  Chittur Subbaraman (chitturs) - 3/1/99
    //
    //  Attempt to delete the dfs root if necessary
    //
    if ( resourceEntry->Params.DfsRoot ) {
        NetDfsRemoveStdRoot( resourceEntry->ComputerName, 
                             resourceEntry->Params.ShareName,
                             0 );    
    }

    //
    // Close the Parameters key.
    //

    if ( resourceEntry->ParametersKey ) {
        ClusterRegCloseKey( resourceEntry->ParametersKey );
    }

    if ( resourceEntry->ResourceKey ) {
        ClusterRegCloseKey( resourceEntry->ResourceKey );
    }

    if ( resourceEntry->hResource ) {
        CloseClusterResource( resourceEntry->hResource );
    }

    //
    // Deallocate the resource entry.
    //

    LocalFree( resourceEntry->Params.ShareName );
    LocalFree( resourceEntry->Params.Path );
    LocalFree( resourceEntry->Params.Remark );
    LocalFree( resourceEntry->Params.Security );
    LocalFree( resourceEntry->Params.SecurityDescriptor );

    LocalFree( resourceEntry );

} // SmbShareClose



DWORD
SmbShareGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for resources of type File Share.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    PSMB_DEPEND_SETUP pdepsetup = SmbDependSetup;
    PSMB_DEPEND_DATA pdepdata = (PSMB_DEPEND_DATA)OutBuffer;
    CLUSPROP_BUFFER_HELPER value;
    DWORD       status;

    *BytesReturned = sizeof(SMB_DEPEND_DATA);
    if ( OutBufferSize < sizeof(SMB_DEPEND_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( OutBuffer, sizeof(SMB_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 ) {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat ) {

            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
                value.pULargeIntegerValue->li.LowPart = 
                    (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return(status);

} // SmbShareGetRequiredDependencies



DWORD
DfsShareGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for DFS File Share resource.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    PSMB_DEPEND_SETUP pdepsetup = DfsDependSetup;
    PDFS_DEPEND_DATA pdepdata = (PDFS_DEPEND_DATA)OutBuffer;
    CLUSPROP_BUFFER_HELPER value;
    DWORD       status;

    *BytesReturned = sizeof(DFS_DEPEND_DATA);
    if ( OutBufferSize < sizeof(DFS_DEPEND_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( OutBuffer, sizeof(DFS_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 ) {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat ) {

            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
                value.pULargeIntegerValue->li.LowPart = 
                    (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return(status);

} // DfsShareGetRequiredDependencies



DWORD
SmbShareResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for File Share resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PSHARE_RESOURCE     resourceEntry;
    DWORD               required;

    resourceEntry = (PSHARE_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "SmbShare: ResourceControl request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ResourceControl resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"ResourceControl request.\n" );
#endif

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( SmbShareResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( SmbShareResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = SmbShareGetPrivateResProperties( resourceEntry,
                                                      OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = SmbShareValidatePrivateResProperties( resourceEntry,
                                                           InBuffer,
                                                           InBufferSize,
                                                           NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = SmbShareSetPrivateResProperties( resourceEntry,
                                                      InBuffer,
                                                      InBufferSize );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            if ( resourceEntry->Params.DfsRoot ) {
                status = DfsShareGetRequiredDependencies( OutBuffer,
                                                          OutBufferSize,
                                                          BytesReturned );
            } else {
                status = SmbShareGetRequiredDependencies( OutBuffer,
                                                          OutBufferSize,
                                                          BytesReturned );
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // SmbShareResourceControl



DWORD
SmbShareResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for File Share resources.

    Perform the control request specified by ControlCode on the specified
    resource type.

Arguments:

    ResourceTypeName - Supplies the name of the resource type - not useful!

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( SmbShareResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            // rodga 2/15/99
            // CLUSBUG - how do we present DFS Root dependencies???
            status = SmbShareGetRequiredDependencies( OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned );
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( SmbShareResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1:
        {
            PCLUS_STARTING_PARAMS   pStartParams;
                       
            pStartParams = ( PCLUS_STARTING_PARAMS ) InBuffer;

            status = ERROR_SUCCESS;

            //
            //  If this is a form after the first upgrade, then mark the
            //  DFS service as needing a recycling in the first online. We
            //  do this only during form since during a join, the resource
            //  DLL clusres.dll will get unloaded after the phase1 notification
            //  is dropped. So, global vars become meaningless.
            //
            if ( ( pStartParams->bFirst == TRUE ) &&
                 ( pStartParams->bForm == TRUE ) )
            {
                g_fDfsServiceNeedsRecyling = TRUE;
            }
            break;
        }

        case CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2:
        {
            PCLUS_STARTING_PARAMS   pStartParams;
                       
            pStartParams = ( PCLUS_STARTING_PARAMS ) InBuffer;

            status = ERROR_SUCCESS;

            //
            //  In the first join after an install, mark the dfs service as needing a 
            //  recycle in its first online.  This is done in phase 2 notification 
            //  since clusres.dll will not get unloaded after this.
            //
            if ( ( pStartParams->bFirst == TRUE ) &&
                 ( pStartParams->bForm == FALSE ) )
            {
                g_fDfsServiceNeedsRecyling = TRUE;
            }
            break;
        }
        
        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);
} // SmbShareResourceTypeControl




DWORD
SmbShareGetPrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type SmbShare.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      SmbShareResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // SmbShareGetPrivateResProperties


DWORD
SMBValidateUniqueProperties(
    IN HRESOURCE            hSelf,
    IN HRESOURCE            hResource,
    IN PSHARE_ENUM_CONTEXT  pContext
    )

/*++

Routine Description:
    Callback function to validate that a resource's properties are unique.

    For the File Share resource the ShareName property must be unique
    in the cluster.

Arguments:

    hSelf     - A handle to the original resource (or NULL).

    hResource - A handle to a resource of the same Type. Check against this to make sure
                the new properties do not conflict.

    pContext  - Context for the enumeration.

Return Value:

    ERROR_SUCCESS - The function completed successfully, the name is unique

    ERROR_DUP_NAME - The name is not unique (i.e., already claimed by another resource)

    Win32 error code - The function failed.

--*/
{
    DWORD       dwStatus        = ERROR_SUCCESS;
    LPWSTR      lpszShareName   = NULL;
    HKEY        hKey            = NULL;
    HKEY        hParamKey       = NULL;

    //
    //  If there is no share name and we are not testing a DFS root or we are testing a resource with no path, then
    //  we can do nothing in this call. Just return.
    //
    if ( ( !pContext->pParams->ShareName ) &&
          ( ( !pContext->pParams->DfsRoot ) || ( !pContext->pParams->Path ) ) ) {
        return( ERROR_SUCCESS );
    }

    // Get the share name for hResource

    hKey = GetClusterResourceKey( hResource, KEY_READ );

    if (!hKey) {
        (g_LogEvent)(
            pContext->pResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"SMBValidateUniqueProperties: Failed to get the resource key, was resource deleted ? Error: %1!u!...\n",
            GetLastError() );
        return( ERROR_SUCCESS );
    }

    dwStatus = ClusterRegOpenKey( hKey, PARAM_KEYNAME__PARAMETERS, KEY_READ, &hParamKey );

    if (dwStatus != ERROR_SUCCESS) {
        (g_LogEvent)(
            pContext->pResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"SMBValidateUniqueProperties: Failed to open the cluster registry key for the resource, was resource deleted ? Error: %1!u!...\n",
            dwStatus );
        dwStatus = ERROR_SUCCESS;
        goto error_exit;
    }

    lpszShareName = ResUtilGetSzValue( hParamKey, PARAM_NAME__SHARENAME );

    //
    //  Check for uniqueness if both share names exist.
    //
    if ( ( lpszShareName ) && 
         ( pContext->pParams->ShareName ) && 
         ( !( lstrcmpiW( lpszShareName, pContext->pParams->ShareName ) ) ) ) {
        (g_LogEvent)(
            pContext->pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SMBValidateUniqueProperties: Share name '%1' already exists.\n",
            pContext->pParams->ShareName );
        dwStatus = ERROR_DUP_NAME;
        goto error_exit;
    } 
    
    //
    //  If this share is set to be a DFS root share make sure there is no other DFS root
    //  with an overlapping path as this share.
    //
    if ( ( pContext->pParams->DfsRoot ) && ( pContext->pParams->Path ) )
    {
        DWORD   dwIsDfsRoot = 0;
        
        ResUtilGetDwordValue( hParamKey, 
                              PARAM_NAME__DFSROOT,
                              &dwIsDfsRoot,
                              0 );

        if ( dwIsDfsRoot == 1 )
        {
            LPWSTR  lpszPath = NULL;
            WCHAR   cSlash = L'\\';
            
            lpszPath = ResUtilGetSzValue( hParamKey, PARAM_NAME__PATH );            

            if ( lpszPath != NULL )
            {
                //
                //  If the two paths overlap, then return failure. Note that here we make sure
                //  we do not flag paths such as G:\dfs1 and G:\dfs10 as overlapping, that is why we have
                //  the checks after the pattern matching.
                //
                if ( ( lstrcmp( lpszPath, pContext->pParams->Path ) == 0 )
                ||
                     ( ( wcsstr( lpszPath, pContext->pParams->Path ) != NULL ) &&
                        ( lpszPath[lstrlen(pContext->pParams->Path)] == cSlash ) ) 

                || 
                    ( ( ( wcsstr( pContext->pParams->Path, lpszPath ) != NULL ) && 
                         ( pContext->pParams->Path[lstrlen(lpszPath)] == cSlash ) ) ) )
                {
                    dwStatus = ERROR_BAD_PATHNAME;
                    (g_LogEvent)(
                        pContext->pResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"SMBValidateUniqueProperties: Path %1!ws! for existing DFS root %2!ws! conflicts with the specified path %3!ws! for DFS root %4!ws!...\n",
                        lpszPath,
                        (lpszShareName == NULL) ? L"NULL":lpszShareName,
                        pContext->pParams->Path,
                        (pContext->pParams->ShareName == NULL) ? L"NULL":pContext->pParams->ShareName); 
                }               
                LocalFree ( lpszPath );
            }                        
        }       
    }
   
error_exit:
    if (hKey) ClusterRegCloseKey( hKey );

    if (hParamKey)  ClusterRegCloseKey( hParamKey );

    if (lpszShareName) LocalFree( lpszShareName );

    return( dwStatus );

} // SMBValidateUniqueProperties


DWORD
SmbShareValidatePrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PSHARE_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type File Share.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    SHARE_PARAMS        currentProps;
    SHARE_PARAMS        newProps;
    PSHARE_PARAMS       pParams = NULL;
    LPWSTR              nameOfPropInError;
    SHARE_ENUM_CONTEXT  enumContext;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Capture the current set of private properties from the registry.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 SmbShareResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(SHARE_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       SmbShareResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to duplicate the parameter block. Error: %1!u!.\n",
            status );
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( SmbShareResourcePrivateProperties,
                                         NULL,
                                         TRUE,      // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the path
        //
        if ( pParams->Path &&
             !ResUtilIsPathValid( pParams->Path ) ) {
            status = ERROR_INVALID_PARAMETER;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Invalid path specified ('%1'). Error: %2!u!.\n",
                pParams->Path,
                status );
            goto FnExit;
        }

        //
        // Validate the parameter values.
        //
        if ( (pParams->SecurityDescriptorSize != 0) &&
             !IsValidSecurityDescriptor(pParams->SecurityDescriptor) ) {
            status = ERROR_INVALID_PARAMETER;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Invalid parameter specified ('SecurityDescriptor'). Error: %1!u!.\n",
                status );
            goto FnExit;
        }
        if ( (pParams->SecuritySize != 0) &&
             !IsValidSecurityDescriptor(pParams->Security) ) {
            status = ERROR_INVALID_PARAMETER;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Invalid parameter specified ('Security'). Error: %1!u!.\n",
                status );
            goto FnExit;
        }
        if ( pParams->MaxUsers == 0 ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Invalid value for MaxUsers specified (%1!u!).\n",
                pParams->MaxUsers );
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

        //
        // Make sure the share name is  unique
        //
        enumContext.pResourceEntry = ResourceEntry;
        enumContext.pParams = pParams;
        status = ResUtilEnumResources(ResourceEntry->hResource,
                                      CLUS_RESTYPE_NAME_FILESHR,
                                      SMBValidateUniqueProperties,
                                      &enumContext);

        if (status != ERROR_SUCCESS) {
           (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbShareValidatePrivateResProperties: ResUtilEnumResources failed with status=%1!u!...\n",
                status);            
            goto FnExit;
        }

        //
        // Verify that the share name is valid if one is supplied.
        //
        if ( pParams->ShareName )
        {
            status = SmbpValidateShareName( pParams->ShareName );

            if (status != ERROR_SUCCESS) {
               (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbShareValidatePrivateResProperties: Share name %1!ws! contains illegal chars, Status=%2!u!...\n",
                    pParams->ShareName,
                    status);            
                goto FnExit;
            }
        }

        //
        //  Verify that the path is valid if one is supplied.
        //
        if ( pParams->Path )
        {
            //
            // Verify that the directory exists.
            //
            if ( !ClRtlPathFileExists( pParams->Path ) ) {
                status = ERROR_PATH_NOT_FOUND;
                goto FnExit;
            }
        }

        //
        //  If this share needs to be a DFS root, then make sure the path is on an NTFS volume.
        //
        if ( ( pParams->DfsRoot ) && ( pParams->Path ) )
        {
            WCHAR   szRootPathName[4];
            WCHAR   szFileSystem[32];   // Array size stolen from CLUSPROP_PARTITION_INFO

            //
            //  Copy just the drive letter from the supplied path.
            //
            ( void ) StringCchCopy ( szRootPathName, RTL_NUMBER_OF ( szRootPathName ), pParams->Path );

            szRootPathName[2] = L'\\';
            szRootPathName[3] = L'\0';
                
            if ( !GetVolumeInformationW( szRootPathName,
                                         NULL,              // Volume name buffer
                                         0,                 // Volume name buffer size
                                         NULL,              // Volume serial number
                                         NULL,              // Maximum component length
                                         NULL,              // File system flags    
                                         szFileSystem,      // File system name
                                         sizeof(szFileSystem)/sizeof(WCHAR) ) ) 
            {
                status = GetLastError();
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbShareValidatePrivateResProperties: GetVolumeInformation on root path %1!ws! for share %2!ws! failed, Status %3!u!...\n",
                    szRootPathName,
                    ( pParams->ShareName == NULL ) ? L"NULL":pParams->ShareName,
                    status );   
                goto FnExit;
            }

            if ( lstrcmpi( szFileSystem, L"NTFS" ) != 0 )
            {
                status = ERROR_BAD_PATHNAME;
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbShareValidatePrivateResProperties: Root path %1!ws! for share %2!ws! is not NTFS, Status %3!u!...\n",
                    szRootPathName,
                    ( pParams->ShareName == NULL ) ? L"NULL":pParams->ShareName,
                    status );   
                goto FnExit;
            }
        }            
    } else {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Validating properties failed. Error: %1!u!.\n",
            status );
    }

FnExit:
    //
    // Cleanup our parameter block.
    //
    if (   (   (status != ERROR_SUCCESS)
            && (pParams != NULL) )
        || ( pParams == &newProps )
        ) {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   SmbShareResourcePrivateProperties );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        SmbShareResourcePrivateProperties
        );

    return(status);

} // SmbShareValidatePrivateResProperties



DWORD
SmbShareSetPrivateResProperties(
    IN OUT PSHARE_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type File Share.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.


    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

Notes:

    If the share name changes then we must delete the old share and
    create a new one. Otherwise, just set the new info.

--*/

{
    DWORD                   status;
    SHARE_PARAMS            params;
    LPWSTR                  oldName = NULL;
    BOOL                    bNameSubdirPropChange = FALSE;
    BOOL                    bPathChanged = FALSE;
    BOOL                    bFoundSecurity = FALSE;
    BOOL                    bFoundSD = FALSE;
    PSECURITY_DESCRIPTOR    psd = NULL;
    DWORD                   SDSize = 0;
    DWORD                   securitySize = 0;
    BOOL                    bChangeDfsRootProp = FALSE, bShareNameChangeAttempted = FALSE;

    ZeroMemory( &params, sizeof(SHARE_PARAMS) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = SmbShareValidatePrivateResProperties( ResourceEntry,
                                                   InBuffer,
                                                   InBufferSize,
                                                   &params );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // fixup the Security and Security Descriptor properties to match
    //
   
    bFoundSecurity = ( ERROR_SUCCESS == ResUtilFindBinaryProperty( InBuffer,
                                                                   InBufferSize,
                                                                   PARAM_NAME__SECURITY,
                                                                   NULL,
                                                                   &securitySize ) );
   
    if ( bFoundSecurity && (securitySize == 0) ) {
        //
        // The security string could have been passed in, but it may be
        // a zero length buffer. We will delete the buffer and indicate it
        // is not present in that case.
        //
        bFoundSecurity = FALSE;
        FREE_SECURITY_INFO();
    }

    bFoundSD =( ERROR_SUCCESS == ResUtilFindBinaryProperty( InBuffer,
                                                            InBufferSize,
                                                            PARAM_NAME__SD,
                                                            NULL,
                                                            &SDSize ) );

    if ( bFoundSD && (SDSize == 0) ) {
        //
        // The security string could have been passed in, but it may be
        // a zero length buffer. We will delete the buffer and indicate it
        // is not present in that case.
        //
        bFoundSD = FALSE;
        FREE_SECURITY_INFO();
    }

    if ( bFoundSD ) {     // prefer SD, convert SD to Security

        psd = ClRtlConvertFileShareSDToNT4Format( params.SecurityDescriptor );

        //
        //  Bail on error
        //
        if ( psd == NULL ) {
            status = GetLastError();
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Unable to convert SD to NT4 format, status %1!u!\n",
                         status);
            ResUtilFreeParameterBlock( ( LPBYTE ) &params,
                                       ( LPBYTE ) &ResourceEntry->Params,
                                       SmbShareResourcePrivateProperties );
            goto FnExit;
        }

        LocalFree( params.Security );

        params.Security = psd;
        params.SecuritySize = GetSecurityDescriptorLength( psd );

        //
        // if the ACL has changed, dump it to the cluster log
        //
        if ( SDSize == ResourceEntry->Params.SecurityDescriptorSize ) {
            if ( memcmp(params.SecurityDescriptor,
                        ResourceEntry->Params.SecurityDescriptor,
                        SDSize ) != 0 )
            {

                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_INFORMATION,
                             L"Changing share permissions\n");
                SmbExamineSD( ResourceEntry->ResourceHandle, params.SecurityDescriptor );
            }
        }
    }
    else if ( bFoundSecurity ) {            // simply write Security to SD

        psd = ClRtlCopySecurityDescriptor( params.Security );

        //
        //  Bail on error
        //
        if ( psd == NULL ) {
            status = GetLastError();
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Unable to copy SD, status %1!u!\n",
                         status);
            ResUtilFreeParameterBlock( ( LPBYTE ) &params,
                                       ( LPBYTE ) &ResourceEntry->Params,
                                       SmbShareResourcePrivateProperties );
            goto FnExit;
        }

        LocalFree( params.SecurityDescriptor );

        params.SecurityDescriptor = psd;
        params.SecurityDescriptorSize = GetSecurityDescriptorLength( psd );

        //
        // if the ACL has changed, dump it to the cluster log
        //
        if ( securitySize == ResourceEntry->Params.SecuritySize ) {
            if ( memcmp(params.Security,
                        ResourceEntry->Params.Security,
                        securitySize ) != 0 )
            {
                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_INFORMATION,
                             L"Changing share permissions\n");
                SmbExamineSD( ResourceEntry->ResourceHandle, params.Security );
            }
        }
    }

    //
    // Duplicate the share name if it changed.
    // Do this even if only the case of the share name changed.
    //
    if ( ( ResourceEntry->Params.ShareName != NULL ) &&
         ( lstrcmpW( params.ShareName, ResourceEntry->Params.ShareName ) != 0 ) ) {
        bShareNameChangeAttempted = TRUE; 
        if ( ResourceEntry->State == ClusterResourceOnline ) {
            oldName = ResUtilDupString( ResourceEntry->Params.ShareName );
            bNameSubdirPropChange = TRUE;
        }
    } else {
        oldName = ResourceEntry->Params.ShareName;
    }

    if ( (params.HideSubDirShares != ResourceEntry->Params.HideSubDirShares) ||
         (params.ShareSubDirs != ResourceEntry->Params.ShareSubDirs) ||
         (params.ShareSubDirs && lstrcmpW (params.Path, ResourceEntry->Params.Path)) ) {
        bNameSubdirPropChange = TRUE;
    }

    //
    // Find out if the path changed.
    //
    if ( (ResourceEntry->Params.Path != NULL) &&
         (lstrcmpW( params.Path, ResourceEntry->Params.Path ) != 0) ) {
        bPathChanged = TRUE;
    }

    //
    //  Chittur Subbaraman (chitturs) - 2/9/99
    //
    //  Don't welcome any changes if you are dealing with a dfs root. Also
    //  make sure "DfsRoot" is mutually exclusive with "ShareSubDirs"
    //  and "HideSubDirShares" properties.
    //
    if ( ( ( ResourceEntry->Params.DfsRoot ) && 
           ( bNameSubdirPropChange || bPathChanged || bShareNameChangeAttempted ) ) ||
         ( ( params.DfsRoot ) && 
           ( params.ShareSubDirs || params.HideSubDirShares ) ) )
    {
        status = ERROR_RESOURCE_PROPERTY_UNCHANGEABLE;
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   SmbShareResourcePrivateProperties );
        goto FnExit;
    }

    if ( params.DfsRoot && !ResourceEntry->Params.DfsRoot )
    {
        BOOL    fIsDfsRoot = FALSE;

        //
        //  Check if this node has a DFS root already with the same root share name. If so,
        //  don't allow this resource to be promoted as a DFS resource.
        //
        SmbpIsDfsRoot( ResourceEntry, &fIsDfsRoot );

        if( fIsDfsRoot == TRUE ) 
        {
            status = ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT;
            ResUtilFreeParameterBlock( (LPBYTE) &params,
                                       (LPBYTE) &ResourceEntry->Params,
                                       SmbShareResourcePrivateProperties );
            goto FnExit;
        }
    }

    if ( ResourceEntry->Params.DfsRoot != params.DfsRoot ) {
        bChangeDfsRootProp = TRUE;
    }
    
    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               SmbShareResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               SmbShareResourcePrivateProperties );

    //
    // If the resource is online, set the new values.  If online pending,
    // we must wait until the user brings it online again.
    //
    if ( status == ERROR_SUCCESS ) {
        if ( (ResourceEntry->State == ClusterResourceOnline) && !bNameSubdirPropChange && !bPathChanged ) {

            PSHARE_INFO_502  oldShareInfo;
            SHARE_INFO_502   newShareInfo;

            EnterCriticalSection( &SmbShareLock );

            // Get current information.
            status = NetShareGetInfo( NULL,
                                      oldName,
                                      502,
                                      (LPBYTE*)&oldShareInfo );

            if ( status == ERROR_SUCCESS ) {
                DWORD           invalidParam;

                //
                // Set new share info.
                //
                CopyMemory( &newShareInfo, oldShareInfo, sizeof( newShareInfo ) );
                newShareInfo.shi502_netname =   ResourceEntry->Params.ShareName;
                newShareInfo.shi502_remark =    ResourceEntry->Params.Remark;
                newShareInfo.shi502_max_uses =  ResourceEntry->Params.MaxUsers;
                newShareInfo.shi502_path =      ResourceEntry->Params.Path;
                newShareInfo.shi502_security_descriptor = ResourceEntry->Params.SecurityDescriptor;

                //
                // Set new info.
                //
                status = NetShareSetInfo( NULL,
                                          oldName,
                                          502,
                                          (LPBYTE)&newShareInfo,
                                          &invalidParam );
                if ( status != ERROR_SUCCESS ) {
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"SetPrivateProps, error setting info on share '%1!ws!. Error %2!u!, property # %3!d!.\n",
                        oldName,
                        status,
                        invalidParam );
                    status = ERROR_RESOURCE_PROPERTIES_STORED;
                }

                NetApiBufferFree( oldShareInfo );

                if ( (status == ERROR_SUCCESS) ||
                     (status == ERROR_RESOURCE_PROPERTIES_STORED) ) {

                    status = SmbpSetCacheFlags( ResourceEntry,
                                                ResourceEntry->Params.ShareName );
                    if ( status != ERROR_SUCCESS ) {
                        status = ERROR_RESOURCE_PROPERTIES_STORED;
                    }
                }
            } else {
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SetPrivateProps, error getting info on share '%1!ws!. Error %2!u!.\n",
                    oldName,
                    status );
                status = ERROR_RESOURCE_PROPERTIES_STORED;
            }
            
            LeaveCriticalSection( &SmbShareLock );
        } else if ( (ResourceEntry->State == ClusterResourceOnlinePending) ||
                    (ResourceEntry->State == ClusterResourceOnline) ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        }
    }
    
FnExit:
    if ( oldName != ResourceEntry->Params.ShareName ) {
        LocalFree( oldName );
    }

    if ( ( status == ERROR_SUCCESS ) && bChangeDfsRootProp ) {
        if ( (ResourceEntry->State == ClusterResourceOnlinePending) ||
             (ResourceEntry->State == ClusterResourceOnline) ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        }
    }

    return(status);

} // SmbShareSetPrivateResProperties

DWORD
SmbpHandleDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry,
    OUT PBOOL pbIsExistingDfsRoot
    )

/*++

Routine Description:

    Handles an smbshare which is configured as a DFS root.  

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

    pbIsExistingDfsRoot - Specifies whether the dfs root is a wolfpack resource

Return Value:

    None.

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    fStatus;
    LPWSTR  lpszDfsRootCheckpointName = NULL;

    //
    //  Recycle the DFS service if this is the first online after an install. This must be
    //  done before calling GetDfsRootMetadataLocation since in a W2K-Windows Server 2003 cluster on the first 
    //  failover from W2K to Windows Server 2003, the DFS service needs to migrate the W2K root to Windows Server
    //  2003 location and that happens during a restart. Only after that migration, the GetDfsRootMetadataLocation 
    //  will find the right data in the Windows Server 2003 location.
    //
    //
    if ( pResourceEntry->Params.DfsRoot )
    {
        dwStatus = SmbpRecycleDfsService( pResourceEntry );

        if ( dwStatus != ERROR_SUCCESS )
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpHandleDfsRoot: Unable to recycle DFS service for root %1!ws!, status %2!u!\n",
                pResourceEntry->Params.ShareName,
                dwStatus);
            goto FnExit;
        }
    }
        
    //
    //  Check whether this resource represents an existing dfs root. Note that you cannot use
    //  SmbpIsDfsRoot here since that function only assuredly returns roots that are MASTER
    //  in this node. Those roots that are STANDBY may fail to come out of NetDfsEnum if a
    //  checkpoint restore is in progress at the time we invoke the enum.
    //
    //  This is a private API provided by UDAYH of DFS team on 4/26/2001.
    //
    dwStatus = GetDfsRootMetadataLocation( pResourceEntry->Params.ShareName,
                                           &lpszDfsRootCheckpointName );

    if ( dwStatus == ERROR_NOT_FOUND ) 
    {
        *pbIsExistingDfsRoot = FALSE;
        //
        //  Change status to success so that you return the right status from this function if
        //  you happen to bail out early.
        //
        dwStatus = ERROR_SUCCESS;
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SmbpHandleDfsRoot: DFS root %1!ws! NOT found in local node...\n",
            pResourceEntry->Params.ShareName);
    } else if ( dwStatus == ERROR_SUCCESS )
    {
        *pbIsExistingDfsRoot = TRUE;
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SmbpHandleDfsRoot: DFS root %1!ws! found in local node...\n",
            pResourceEntry->Params.ShareName);
    } else
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpHandleDfsRoot: GetDfsRootMetadataLocation(1) for DFS root '%1!ws!' returns %2!u!...\n",
            pResourceEntry->Params.ShareName,
            dwStatus);       
        goto FnExit;
    }

    //
    //  If there is a DFS root on this node that matches the share name of this resource or if
    //  the user is attempting to set up a DFS root, then get the VS name that provides for
    //  this resource so that we can pass it onto DFS APIs.
    //
    if ( ( pResourceEntry->Params.DfsRoot ) ||
         ( *pbIsExistingDfsRoot == TRUE ) )
    {
        //
        //  Get the dependent network name of the dfs root resource. You need to do this in
        //  every online to account for the dependency change while this resource was offline.
        //
        fStatus = GetClusterResourceNetworkName( pResourceEntry->hResource,
                                                 pResourceEntry->szDependentNetworkName,
                                                 &dwSize );

        if ( !fStatus ) 
        {
            dwStatus = GetLastError();
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpHandleDfsRoot: GetClusterResourceNetworkName for share %1!ws! returns %2!u!...\n",
                pResourceEntry->Params.ShareName,
                dwStatus);
            goto FnExit;       
        }

        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SmbpHandleDfsRoot: DFS root share %1!ws! has a provider VS name of %2!ws!...\n",
            pResourceEntry->Params.ShareName,
            pResourceEntry->szDependentNetworkName);
        //
        //  HACKHACK: Chittur Subbaraman (chitturs) - 5/18/2001
        //
        //  Sleep for few secs to mask an issue with the dependent netname not being really usable 
        //  (especially as binding parameter to named pipes done by the DFS APIs we call below) after  
        //  it declares itself to be online. This is due to the fact that netname NBT
        //  registrations are apparently async and it takes a while for that to percolate to other
        //  drivers such as SRV.
        //         
        Sleep ( 4 * 1000 );
    }
    
    if ( !pResourceEntry->Params.DfsRoot )
    {
        if ( *pbIsExistingDfsRoot )
        {
            //
            // This means the user no longer wants the share to be a 
            // DFS root. Delete the registry checkpoints and the
            // corresponding DFS root.
            //
            dwStatus = SmbpDeleteDfsRoot( pResourceEntry );
            if ( dwStatus != ERROR_SUCCESS )
            {
                (g_LogEvent)(
                    pResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"SmbpHandleDfsRoot: Failed to delete DFS root for share %1!ws!, status %2!u!...\n",
                    pResourceEntry->Params.ShareName,
                    dwStatus);
                goto FnExit;
            }
            *pbIsExistingDfsRoot = FALSE;
        }
        pResourceEntry->bDfsRootNeedsMonitoring = FALSE;
        goto FnExit;
    } 

    //
    //  If there is no DFS root with the same rootshare name
    //  as this resource, attempt to create the dfs root. However, the 
    //  user could have mistakenly created a dfs root with a different 
    //  share name. In such a case, the following create call will fail.
    // 
    if ( !( *pbIsExistingDfsRoot ) )
    {
        dwStatus = SmbpCreateDfsRoot( pResourceEntry ); 
    
        if ( dwStatus != ERROR_SUCCESS )
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpHandleDfsRoot: Create dfs root for share %1!ws! returns %2!u!...\n",
                pResourceEntry->Params.ShareName,
                dwStatus);

            if ( dwStatus == ERROR_FILE_EXISTS )
            {
                dwStatus = ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT;
            }
                
            ClusResLogSystemEventByKeyData( pResourceEntry->ResourceKey,
                                            LOG_CRITICAL,
                                            RES_SMB_CANT_CREATE_DFS_ROOT,
                                            sizeof( dwStatus ),
                                            &dwStatus );           
            goto FnExit; 
        }
        (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"SmbpHandleDfsRoot: Create dfs root for share %1!ws!\n",
                pResourceEntry->Params.ShareName);
        *pbIsExistingDfsRoot = TRUE;
    }

    if ( lpszDfsRootCheckpointName == NULL )
    {
        dwStatus = GetDfsRootMetadataLocation( pResourceEntry->Params.ShareName,
                                               &lpszDfsRootCheckpointName );

        if ( dwStatus != ERROR_SUCCESS )
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpHandleDfsRoot: GetDfsRootMetadataLocation(2) for dfs root %1!ws!, status %2!u!...\n",
                pResourceEntry->Params.ShareName,
                dwStatus);
            goto FnExit;
        }
    }

    (g_LogEvent)(
        pResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SmbpHandleDfsRoot: Dfs root %1!ws! metadata location from DFS API is %2!ws!...\n",
        pResourceEntry->Params.ShareName,
        lpszDfsRootCheckpointName);
    
    dwStatus = ClusterResourceControl(
                   pResourceEntry->hResource,
                   NULL,
                   CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                   lpszDfsRootCheckpointName,
                   (lstrlenW(lpszDfsRootCheckpointName) + 1) * sizeof(WCHAR),
                   NULL,
                   0,
                   &dwSize );

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_ALREADY_EXISTS )
        {
            dwStatus = ERROR_SUCCESS;
        }
        else
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpHandleDfsRoot: Failed to set registry checkpoint %1!ws! for share %2!ws!, status %3!u!...\n",
                lpszDfsRootCheckpointName,
                pResourceEntry->Params.ShareName,
                dwStatus);
        }
    } 

    pResourceEntry->bDfsRootNeedsMonitoring = TRUE;
 
FnExit:
    //
    //  Free memory for the checkpoint name buffer for this DFS root resource. This is a private API provided
    //  by UDAYH of DFS team on 4/26/2001.
    //
    if ( lpszDfsRootCheckpointName != NULL ) 
        ReleaseDfsRootMetadataLocation ( lpszDfsRootCheckpointName );

    return( dwStatus );
} // SmbpHandleDfsRoot

DWORD
SmbpIsDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry,
    OUT PBOOL pbIsDfsRoot
    )

/*++

Routine Description:

    Checks if this root share is a dfs root.

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

    pbIsDfsRoot - Specifies whether a dfs root with the same root share
                  name as this resource exists.

Return Value:

    ERROR_SUCCESS or a Win32 error code

--*/

{
    DWORD           dwStatus = ERROR_SUCCESS;
    PDFS_INFO_300   pDfsInfo300 = NULL, pTemp = NULL;
    DWORD           cEntriesRead = 0;
    DWORD           dwResume = 0, i;
    LPWSTR          pLastSlash = NULL;
    WCHAR           cSlash = L'\\';

    //
    //  Chittur Subbaraman (chitturs) - 4/14/2001
    //
    *pbIsDfsRoot = FALSE;
    
    //
    // Call the NetDfsEnum function specifying level 200.
    //
    dwStatus = NetDfsEnum( pResourceEntry->ComputerName,        // Local computer name 
                           300,                                 // Info level  
                           0xFFFFFFFF,                          // Return all info 
                           ( LPBYTE * ) &pDfsInfo300,           // Data buffer
                           &cEntriesRead,                       // Entries read
                           &dwResume );                         // Resume handle
    
    if ( dwStatus != ERROR_SUCCESS )
    {
        //
        //  If we did not find any root return success
        //
        if ( dwStatus == ERROR_FILE_NOT_FOUND ) 
        {
            dwStatus = ERROR_SUCCESS;
        } else
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpIsDfsRoot: NetDfsEnum returns %1!u! for root share %2!ws!...\n",
                dwStatus,
                pResourceEntry->Params.ShareName);
        }
        goto FnExit;
    }

    pTemp = pDfsInfo300;

    //
    //  The enumerated roots will be of the form \server\rootname, so you need to check for the
    //  name after the last \ coming out of the enum.
    //
    for( i=0; i<cEntriesRead; i++, pTemp++ )
    {
        pLastSlash = wcsrchr( pTemp->DfsName, cSlash );

        if ( pLastSlash == NULL ) continue;
        
        if ( lstrcmp( pResourceEntry->Params.ShareName, pLastSlash+1 ) == 0 )
        {
            *pbIsDfsRoot = TRUE;
            break;
        }
    } // for

    //
    // Free the allocated buffer.
    //
    NetApiBufferFree( pDfsInfo300 );
    
FnExit:    
    return( dwStatus );
} // SmbpIsDfsRoot


DWORD 
SmbpPrepareOnlineDfsRoot(
    IN PSHARE_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Prepares the online of the dfs root share.  

Arguments:

    ResourceEntry - Supplies the pointer to the resource block

Return Value:

    ERROR_SUCCESS on success
    Win32 error code otherwise

--*/
{
    DWORD           dwStatus;
    DFS_INFO_101    dfsInfo101;
    WCHAR           szDfsEntryPath[MAX_COMPUTERNAME_LENGTH + NNLEN + SMBSHARE_EXTRA_LEN];

    //
    //  Make sure the DFS service is started. This is necessary since the cluster service does not set 
    //  an explicit dependency on DFS service.
    //
    dwStatus = ResUtilStartResourceService( DFS_SVCNAME,
                                            NULL );
    if ( dwStatus != ERROR_SUCCESS ) 
    {
    	(g_LogEvent)(
        	ResourceEntry->ResourceHandle,
        	LOG_ERROR,
        	L"SmbpPrepareOnlineDfsRoot: Failed to start DFS service, share name %1!ws!, status %2!u!...\n",
        	ResourceEntry->Params.ShareName,
        	dwStatus);
        goto FnExit;
    }       

    dfsInfo101.State = DFS_VOLUME_STATE_RESYNCHRONIZE;

    //
    //  Prepare a path of the form \\VSName\ShareName to pass into DFS API.
    //
    ( void ) StringCchCopy ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), L"\\\\" );
    ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), ResourceEntry->szDependentNetworkName );
    ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), L"\\" );
    ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), ResourceEntry->Params.ShareName );
        
    dwStatus = NetDfsSetInfo( szDfsEntryPath,           // Root share   
                              NULL,                     // Remote server name
                              NULL,                     // Remote share name
                              101,                      // Info level
                              ( PBYTE ) &dfsInfo101 );  // Input buffer
    
    if ( dwStatus != ERROR_SUCCESS ) 
    {
    	(g_LogEvent)(
        	ResourceEntry->ResourceHandle,
        	LOG_ERROR,
        	L"SmbpPrepareOnlineDfsRoot: Failed to set DFS info for root %1!ws!, status %2!u!...\n",
        	ResourceEntry->Params.ShareName,
        	dwStatus);

        ClusResLogSystemEventByKeyData( ResourceEntry->ResourceKey,
                                        LOG_CRITICAL,
                                        RES_SMB_CANT_INIT_DFS_SVC,
                                        sizeof( dwStatus ),
                                        &dwStatus ); 
        goto FnExit;
    }

    //
    //  HACKHACK (chitturs) - 5/21/2001
    //
    //  FFF in liveness check returns ERROR_PATH_NOT_FOUND in the first liveness check after 
    //  online.  This is due to the fact that the RDR caches share info for 10 seconds after 
    //  share creation and if the cache is not invalidated by the time we call FFF, RDR gets confused.
    //
    Sleep( 12 * 1000 );
    
FnExit:   
    return( dwStatus );
} // SmbpPrepareOnlineDfsRoot


DWORD 
SmbpCreateDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry
    )
/*++

Routine Description:

    Create a DFS root.  

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;

    //
    //  Make sure the DFS service is started. This is necessary since the cluster service does not set 
    //  an explicit dependency on DFS service.
    //
    dwStatus = ResUtilStartResourceService( DFS_SVCNAME,
                                            NULL );
    if ( dwStatus != ERROR_SUCCESS ) 
    {
    	(g_LogEvent)(
        	pResourceEntry->ResourceHandle,
        	LOG_ERROR,
        	L"SmbpCreateDfsRoot: Failed to start DFS service, share name %1!ws!, status %2!u!...\n",
        	pResourceEntry->Params.ShareName,
        	dwStatus);
        goto FnExit;
    }       

    //
    // Chittur Subbaraman (chitturs) - 2/14/99
    //
    dwStatus = NetDfsAddStdRoot( pResourceEntry->szDependentNetworkName, 
                                 pResourceEntry->Params.ShareName,
                                 NULL,
                                 0 );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpCreateDfsRoot: Failed to create dfs root for share %1!ws!, status %2!u!...\n",
            pResourceEntry->Params.ShareName,
            dwStatus);
        goto FnExit;
    }
    
FnExit:
    return ( dwStatus );
} // SmbpCreateDfsRoot

DWORD 
SmbpDeleteDfsRoot(
    IN PSHARE_RESOURCE pResourceEntry   
    )
/*++

Routine Description:

    Delete the DFS root and the registry checkpoints.  

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

--*/
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwReturnSize;
    LPWSTR          lpszDfsRootCheckpointName = NULL;

    //
    //  Get the checkpoint name for this DFS root resource. This is a private API provided
    //  by UDAYH of DFS team on 4/26/2001.
    //
    dwStatus = GetDfsRootMetadataLocation( pResourceEntry->Params.ShareName,
                                           &lpszDfsRootCheckpointName );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpDeleteDfsRoot: Failed to get metadata location for dfs root %1!ws!, status %2!u!...\n",
            pResourceEntry->Params.ShareName,
            dwStatus);
        goto FnExit;
    }

    (g_LogEvent)(
        pResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SmbpDeleteDfsRoot: Dfs root %1!ws! metadata location from DFS API is %2!ws!...\n",
        pResourceEntry->Params.ShareName,
        lpszDfsRootCheckpointName);

    dwStatus = ClusterResourceControl(
                    pResourceEntry->hResource,
                    NULL,
                    CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
                    lpszDfsRootCheckpointName,
                    (lstrlenW(lpszDfsRootCheckpointName) + 1) * sizeof(WCHAR),
                    NULL,
                    0,
                    &dwReturnSize );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            dwStatus = ERROR_SUCCESS;
        } else
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpDeleteDfsRoot: Failed to delete registry checkpoint %1!ws! for share %2!ws!, status %3!u!...\n",
                lpszDfsRootCheckpointName,
                pResourceEntry->Params.ShareName,
                dwStatus);
            goto FnExit;
        }
    }

    //
    //  Make sure the DFS service is started. This is necessary since the cluster service does not set 
    //  an explicit dependency on DFS service.
    //
    dwStatus = ResUtilStartResourceService( DFS_SVCNAME,
                                            NULL );
    if ( dwStatus != ERROR_SUCCESS ) 
    {
    	(g_LogEvent)(
        	pResourceEntry->ResourceHandle,
        	LOG_ERROR,
        	L"SmbpDeleteDfsRoot: Failed to start DFS service, share name %1!ws!, status %2!u!...\n",
        	pResourceEntry->Params.ShareName,
        	dwStatus);
        goto FnExit;
    }       
    
    dwStatus = NetDfsRemoveStdRoot( pResourceEntry->szDependentNetworkName, 
                                    pResourceEntry->Params.ShareName,
                                    0 );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpDeleteDfsRoot: Failed to delete dfs root %1!ws!, status %2!u!...\n",
            pResourceEntry->Params.ShareName,
            dwStatus);
        goto FnExit;
    } else
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpDeleteDfsRoot: Delete share %1!ws! as a dfs root\n",
            pResourceEntry->Params.ShareName); 
    }

FnExit:
    //
    //  Free memory for the checkpoint name buffer for this DFS root resource. This is a private API provided
    //  by UDAYH of DFS team on 4/26/2001.
    //
    if ( lpszDfsRootCheckpointName != NULL ) 
        ReleaseDfsRootMetadataLocation ( lpszDfsRootCheckpointName );

    return ( dwStatus );
} // SmbpDeleteDfsRoot

DWORD
SmbpResetDfs(
    IN PSHARE_RESOURCE pResourceEntry
    )
/*++

Routine Description:

    Set the DFS root to standby mode. This will make the root inaccessible as well as allow the
    share to be deleted.

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

--*/
{
    DFS_INFO_101    dfsInfo101;
    WCHAR           szDfsEntryPath[MAX_COMPUTERNAME_LENGTH + NNLEN + SMBSHARE_EXTRA_LEN];
    DWORD           dwStatus;
    WCHAR           szNetworkName[MAX_COMPUTERNAME_LENGTH+1];

    dfsInfo101.State = DFS_VOLUME_STATE_STANDBY;

    //
    //  If this function is invoked from SmbShareOnlineThread, we would not have saved the dependent
    //  network name yet into the resource structure, that happens later in SmbpHandleDfsRoot when
    //  we are sure that we are talking about a DFS root share. Note that we cannot be sure in the online thread 
    //  if a dependent network name even exists. For such cases, use the computer name as parameter to the DFS API. 
    //
    if ( pResourceEntry->szDependentNetworkName[0] == L'\0' )
    {
        ( void ) StringCchCopy ( szNetworkName, RTL_NUMBER_OF ( szNetworkName ), pResourceEntry->ComputerName );
    } else
    {
        ( void ) StringCchCopy ( szNetworkName, RTL_NUMBER_OF ( szNetworkName ), pResourceEntry->szDependentNetworkName );   
    }

    //
    //  Prepare a path of the form \\NetworkName\ShareName to pass into DFS API.
    //
    ( void ) StringCchCopy ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), L"\\\\" );
    ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), szNetworkName );
    ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), L"\\" );
    ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), pResourceEntry->Params.ShareName );

    dwStatus = NetDfsSetInfo( szDfsEntryPath,          // Root share 
                              NULL,                    // Remote server name                      
                              NULL,                    // Remote share name
                              101,                     // Info level 
                              ( PBYTE ) &dfsInfo101 ); // Input buffer

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SmbpResetDfs: NetDfsSetInfo with VS name %1!ws! for root %2!ws!, status %3!u!...\n",
            szNetworkName,
            pResourceEntry->Params.ShareName,
            dwStatus);

        //
        //  If this function was called as a part of resmon rundown, then it is possible that
        //  the VS is terminated by resmon before this call is made. In such a case, we would
        //  fail in the above call. So, retry using computer name. That should succeed.
        //
        //  Prepare a path of the form \\ComputerName\ShareName to pass into DFS API.
        //
        ( void ) StringCchCopy ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), L"\\\\" );
        ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), pResourceEntry->ComputerName );
        ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), L"\\" );
        ( void ) StringCchCat ( szDfsEntryPath, RTL_NUMBER_OF ( szDfsEntryPath ), pResourceEntry->Params.ShareName );   

        dwStatus = NetDfsSetInfo( szDfsEntryPath,          // Root share 
                                  NULL,                    // Remote server name                      
                                  NULL,                    // Remote share name
                                  101,                     // Info level 
                                  ( PBYTE ) &dfsInfo101 ); // Input buffer 

        if ( dwStatus != ERROR_SUCCESS )
        {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SmbpResetDfs: NetDfsSetInfo with computer name %1!ws! for root %2!ws!, status %3!u!...\n",
                pResourceEntry->ComputerName,
                pResourceEntry->Params.ShareName,
                dwStatus);                         
        }
    }

    return ( dwStatus );
} // SmbpResetDfs


DWORD
SmbpValidateShareName(
    IN  LPCWSTR  lpszShareName
    )

/*++

Routine Description:

    Validates the name of a share.

Arguments:

    lpszShareName - The name to validate.

Return Value:

    ERROR_SUCCESS if successful, Win32 error code otherwise.

--*/
{
    DWORD   cchShareName = lstrlenW( lpszShareName );

    //
    // Check the length of the name, return an error if it's out of range
    //
    if ( ( cchShareName < 1 ) || ( cchShareName > NNLEN ) ) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check for illegal characters, return an error if one is found
    //
    if ( wcscspn( lpszShareName, ILLEGAL_NAME_CHARS_STR TEXT("*") ) < cchShareName ) 
    {
        return ERROR_INVALID_NAME;
    }

    //
    // Return an error if the name contains only dots and spaces.
    //
    if ( wcsspn( lpszShareName, DOT_AND_SPACE_STR ) == cchShareName ) 
    {
        return ERROR_INVALID_NAME;
    }

    //
    // If we get here, the name passed all of the tests, so it's valid
    //
    return ERROR_SUCCESS;
}// SmbpValidateShareName

DWORD
SmbpRecycleDfsService(
    IN PSHARE_RESOURCE pResourceEntry
    )
/*++

Routine Description:

    Recycle the DFS service if necessary.

Arguments:

    pResourceEntry - Supplies the pointer to the resource block

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;

    //
    //  Enter a CS to make sure multiple resources in this process do not attempt to recycle the DFS
    //  service at the same time. This does not cover the case where the DFS resource is hosted in a 
    //  separate monitor but this is the best we can do at this stage.
    //
    EnterCriticalSection ( &SmbShareLock );

    if ( g_fDfsServiceNeedsRecyling == FALSE ) 
    {
        goto FnExit;
    }

    (g_LogEvent)(pResourceEntry->ResourceHandle,
                 LOG_INFORMATION,
                 L"SmbpRecycleDfsService: Attempting to recycle %1!ws! service\n",
                 DFS_SVCNAME);
    
    //
    //  If this is the first run after an upgrade/fresh install, just recycle the
    //  DFS service. This is necessary since the DFS service detects if clustering is
    //  installed only in its boot. Thus, if someone installs clustering and does not
    //  reboot the node or recycle the DFS service, all DFS resources will fail. Ideally,
    //  the DFS service should be able to detect if clustering is installed when we call
    //  the first DFS API, but due to risks in changing the dfssvc, we do this here.
    //
    dwStatus = ResUtilStopResourceService( DFS_SVCNAME );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(pResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"SmbpRecycleDfsService: Unable to stop %1!ws! service, status %2!u!\n",
                     DFS_SVCNAME,
                     dwStatus);
        goto FnExit;
    }

    dwStatus = ResUtilStartResourceService( DFS_SVCNAME,
                                          NULL );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(pResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"SmbpRecycleDfsService: Unable to start %1!ws! service, status %2!u!\n",
                     DFS_SVCNAME,
                     dwStatus);
        goto FnExit;
    }

    g_fDfsServiceNeedsRecyling = FALSE;

FnExit:
    LeaveCriticalSection ( &SmbShareLock );

    return ( dwStatus );
}

//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( SmbShareFunctionTable,  // Name
                         CLRES_VERSION_V1_00,    // Version
                         SmbShare,               // Prefix
                         NULL,                   // Arbitrate
                         NULL,                   // Release
                         SmbShareResourceControl,// ResControl
                         SmbShareResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\smbshare\dfsmetaloc.c ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    dfsmetaloc.c

Abstract:

    DFS metadata locating routines.

Author:

    Uday Hegde (udayh) 10-May-2001

Revision History:

--*/
#define  UNICODE 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <shellapi.h>
#include <lm.h>
#include "clstrcmp.h"

#define DFS_REGISTRY_CHILD_NAME_SIZE_MAX 4096
LPWSTR DfsRootShareValueName = L"RootShare";


LPWSTR OldRegistryString = L"SOFTWARE\\Microsoft\\DfsHost\\volumes";
LPWSTR NewRegistryString = L"SOFTWARE\\Microsoft\\Dfs\\Roots\\Standalone";
LPWSTR DfsOldStandaloneChild = L"domainroot";


DWORD
CheckForShareNameMatch(
    HKEY DfsKey,
    LPWSTR ChildName,
    LPWSTR RootName,
    PBOOLEAN pMatch)
{
    DWORD Status = ERROR_SUCCESS;
    HKEY DfsRootKey = NULL;

    LPWSTR DfsRootShare = NULL;
    ULONG DataSize, DataType, RootShareLength;
    
    *pMatch = FALSE;

    Status = RegOpenKeyEx( DfsKey,
                           ChildName,
                           0,
                           KEY_READ,
                           &DfsRootKey );

    if (Status == ERROR_SUCCESS)
    {
        Status = RegQueryInfoKey( DfsRootKey,   // Key
                                  NULL,         // Class string
                                  NULL,         // Size of class string
                                  NULL,         // Reserved
                                  NULL,         // # of subkeys
                                  NULL,         // max size of subkey name
                                  NULL,         // max size of class name
                                  NULL,         // # of values
                                  NULL,         // max size of value name
                                  &DataSize,    // max size of value data,
                                  NULL,         // security descriptor
                                  NULL );       // Last write time

        if (Status == ERROR_SUCCESS) {
            RootShareLength = DataSize + sizeof(WCHAR);
            DfsRootShare = (LPWSTR) malloc(DataSize);
            if (DfsRootShare == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                Status = RegQueryValueEx( DfsRootKey,
                                          DfsRootShareValueName,
                                          NULL,
                                          &DataType,
                                          (LPBYTE)DfsRootShare,
                                          &RootShareLength);

                if (Status == ERROR_SUCCESS)
                {
                    if (ClRtlStrICmp(DfsRootShare, RootName) == 0)
                    {
                        *pMatch = TRUE;
                    }
                }
                free(DfsRootShare);
            }
        }
        RegCloseKey( DfsRootKey );
    }

    //
    // we may be dealing with a new key here: which is just being setup.
    // return success if any of the above returned error not found.
    //
    if ((Status == ERROR_NOT_FOUND)  ||
        (Status == ERROR_FILE_NOT_FOUND))
    {
        Status = ERROR_SUCCESS;
    }

    return Status;
}


DWORD
DfsGetMatchingChild( 
    HKEY DfsKey,
    LPWSTR RootName,
    LPWSTR FoundChild,
    PBOOLEAN pMatch )
{
    DWORD Status =  ERROR_SUCCESS;
    ULONG ChildNum = 0;
    DWORD CchMaxName = 0;
    DWORD CchChildName = 0;
    LPWSTR ChildName = NULL;


    //
    // First find the length of the longest subkey
    // and allocate a buffer big enough for it.
    //
    
    Status = RegQueryInfoKey( DfsKey,   // Key
                          NULL,         // Class string
                          NULL,         // Size of class string
                          NULL,         // Reserved
                          NULL,         // # of subkeys
                          &CchMaxName,  // max size of subkey name in TCHAR
                          NULL,         // max size of class name
                          NULL,         // # of values
                          NULL,         // max size of value name
                          NULL,         // max size of value data,
                          NULL,         // security descriptor
                          NULL );       // Last write time
    if (Status == ERROR_SUCCESS)
    {
        CchMaxName = CchMaxName + 1; // Space for the NULL terminator.
        ChildName = (LPWSTR) malloc (CchMaxName * sizeof(WCHAR));
        if (ChildName == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }   
    }

    if(Status == ERROR_SUCCESS)
    {
        do
        {
            //
            // For each child, get the child name.
            //

            CchChildName = CchMaxName;

            //
            // Now enumerate the children, starting from the first child.
            //
            Status = RegEnumKeyEx( DfsKey,
                                   ChildNum,
                                   ChildName,
                                   &CchChildName,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL );

            ChildNum++;


            if ( Status == ERROR_SUCCESS )
            {

                Status = CheckForShareNameMatch( DfsKey,
                                                 ChildName,
                                                 RootName,
                                                 pMatch );
                if ((Status == ERROR_SUCCESS) && (*pMatch == TRUE))
                {
                    wcscpy(FoundChild, ChildName);
                    break;
                }
            }
        } while (Status == ERROR_SUCCESS);

        if(ChildName)
        {
            free (ChildName);
        }
    }

    //
    // If we ran out of children, then return success code.
    //
    if (Status == ERROR_NO_MORE_ITEMS)
    {
        Status = ERROR_SUCCESS;
    }

    return Status;
}


DWORD
CreateShareNameToReturn (
    LPWSTR Child1,
    LPWSTR Child2,
    LPWSTR *pReturnName )
{
    DWORD Status = 0;
    ULONG LengthNeeded = 0;
    PVOID BufferToReturn = NULL;

    if (Child1 != NULL)
    {
        LengthNeeded += sizeof(WCHAR);
        LengthNeeded += (DWORD) (wcslen(Child1) * sizeof(WCHAR));
    }
    if (Child2 != NULL)
    {
        LengthNeeded += sizeof(WCHAR);
        LengthNeeded += (DWORD) (wcslen(Child2) * sizeof(WCHAR));
    }
    LengthNeeded += sizeof(WCHAR);

    Status = NetApiBufferAllocate( LengthNeeded, &BufferToReturn );

    if (Status == ERROR_SUCCESS)
    {
        if (Child1 != NULL)
        {
            wcscpy(BufferToReturn, Child1);
        }
        if (Child2 != NULL)
        {
            wcscat(BufferToReturn, L"\\");
            wcscat(BufferToReturn, Child2);
        }
        *pReturnName = BufferToReturn;
    }

    return Status;
}


DWORD
DfsCheckNewStandaloneRoots( 
    LPWSTR RootName,
    LPWSTR *pMetadataNameLocation )
{
    BOOLEAN Found = FALSE;
    HKEY DfsKey = NULL;
    WCHAR ChildName[MAX_PATH];
    DWORD Status = ERROR_SUCCESS;

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           NewRegistryString,
                           0,
                           KEY_READ,
                           &DfsKey );
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetMatchingChild( DfsKey,
                                      RootName,
                                      ChildName,
                                      &Found );

        if (Status == ERROR_SUCCESS) 
        {
            if (Found)
            {
                Status = CreateShareNameToReturn(NewRegistryString,
                                                 ChildName,
                                                 pMetadataNameLocation );
            }
            else
            {
                Status = ERROR_NOT_FOUND;
            }
        }
        RegCloseKey( DfsKey );
    }

    return Status;
}



DWORD
GetDfsRootMetadataLocation( 
    LPWSTR RootName,
    LPWSTR *pMetadataNameLocation )
{
    DWORD Status;

    Status = DfsCheckNewStandaloneRoots( RootName,
                                         pMetadataNameLocation );

    return Status;
}




VOID
ReleaseDfsRootMetadataLocation( 
    LPWSTR Buffer )
{
    NetApiBufferFree(Buffer);
}




#if 0
_cdecl
main(
    int argc, 
    char *argv[])
{
    LPWSTR CommandLine;
    LPWSTR *argvw;
    int argcw;
    LPWSTR out;
    DWORD Status;

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);
    printf("Argvw is %wS\n", argvw[1]);

    Status = GetDfsRootMetadataLocation( argvw[1],
                                         &out );

    printf("Status is %x out is %ws\n", Status, out);
    if (Status == ERROR_SUCCESS)
    {
        ReleaseDfsRootMetadataLocation(out);
    }
    exit(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\smbshare\dumpsd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dumpsd.c

Abstract:

    Dump security desc., ACLs, and access masks to the log. This is resource
    specific but otherwise identical to the routines in clusrtl\security.c

Author:

    Charlie Wickham (charlwi) 12/05/00

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "lm.h"
#include "lmerr.h"
#include "lmshare.h"
#include <dfsfsctl.h>
#include <srvfsctl.h>
#include <lmdfs.h>

#define g_LogEvent ClusResLogEvent

static VOID
SmbGetSidTypeDesc(
    SID_NAME_USE    SidType,
    LPSTR           pszSidType,
    size_t          cchSidType
    )

/*++

Routine Description:

    Convert the SidType into a meaningful string.

Arguments:

    SidType -
    pszSidType
    cchSidType

Return Value:

        none

--*/

{

    if ((pszSidType != NULL) && (cchSidType > 0))
    {
        char    szSidType [128];

        switch (SidType) {
        case SidTypeUser:
            lstrcpyA(szSidType, "has a user SID for");
            break;

        case SidTypeGroup:
            lstrcpyA(szSidType, "has a group SID for");
            break;

        case SidTypeDomain:
            lstrcpyA(szSidType, "has a domain SID for");
            break;

        case SidTypeAlias:
            lstrcpyA(szSidType, "has an alias SID for");
            break;

        case SidTypeWellKnownGroup:
            lstrcpyA(szSidType, "has a SID for a well-known group for");
            break;

        case SidTypeDeletedAccount:
            lstrcpyA(szSidType, "has a SID for a deleted account for");
            break;

        case SidTypeInvalid:
            lstrcpyA(szSidType, "has an invalid SID for");
            break;

        case SidTypeUnknown:
            lstrcpyA(szSidType, "has an unknown SID type:");
            break;

        default:
            szSidType [0] = '\0';
            break;

        } // switch: SidType

        strncpy(pszSidType, szSidType, cchSidType);

    } // if: buffer not null and has space allocated

}  //*** SmbGetSidTypeDesc()

static VOID
SmbExamineSid(
    RESOURCE_HANDLE ResourceHandle,
    PSID            pSid,
    LPSTR           lpszOldIndent
    )

/*++

Routine Description:

    Dump the SID.

Arguments:

    pSid -
    lpzOldIndent -

Return Value:

        none

--*/

{
    CHAR            szUserName [128];
    CHAR            szDomainName [128];
    DWORD           cbUser  = sizeof(szUserName);
    DWORD           cbDomain = sizeof(szDomainName);
    SID_NAME_USE    SidType;

    if ( LookupAccountSidA( NULL, pSid, szUserName, &cbUser, szDomainName, &cbDomain, &SidType ) )
    {
        char    szSidType [128];

        SmbGetSidTypeDesc( SidType, szSidType, sizeof( szSidType ) );
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"%1!hs!%2!hs! %3!hs!\\%4!hs!\n",
                     lpszOldIndent, szSidType, szDomainName, szUserName ) ;
    }

}  // *** SmbExamineSid()

VOID
SmbExamineMask(
    RESOURCE_HANDLE ResourceHandle,
    ACCESS_MASK     amMask
    )

/*++

Routine Description:

    Dump the AccessMask context.

Arguments:

    amMask -
    lpzOldIndent -

Return Value:

        none

--*/

{
    #define STANDARD_RIGHTS_ALL_THE_BITS 0x00FF0000L
    #define GENERIC_RIGHTS_ALL_THE_BITS  0xF0000000L

    DWORD dwGenericBits;
    DWORD dwStandardBits;
    DWORD dwSpecificBits;
    DWORD dwAccessSystemSecurityBit;
    DWORD dwExtraBits;

    dwStandardBits            = (amMask & STANDARD_RIGHTS_ALL_THE_BITS);
    dwSpecificBits            = (amMask & SPECIFIC_RIGHTS_ALL         );
    dwAccessSystemSecurityBit = (amMask & ACCESS_SYSTEM_SECURITY      );
    dwGenericBits             = (amMask & GENERIC_RIGHTS_ALL_THE_BITS );

    // **************************************************************************
    // *
    // * Print then decode the standard rights bits
    // *
    // **************************************************************************

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"    Standard Rights        == 0x%1!.8x!\n", dwStandardBits);

    if (dwStandardBits) {

        if ((dwStandardBits & DELETE) == DELETE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                 L"                              0x%1!.8x! DELETE\n", DELETE);
        }

        if ((dwStandardBits & READ_CONTROL) == READ_CONTROL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! READ_CONTROL\n", READ_CONTROL);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_READ) == STANDARD_RIGHTS_READ) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_READ\n", STANDARD_RIGHTS_READ);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_WRITE) == STANDARD_RIGHTS_WRITE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_WRITE\n", STANDARD_RIGHTS_WRITE);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_EXECUTE) == STANDARD_RIGHTS_EXECUTE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_EXECUTE\n", STANDARD_RIGHTS_EXECUTE);
        }

        if ((dwStandardBits & WRITE_DAC) == WRITE_DAC) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! WRITE_DAC\n", WRITE_DAC);
        }

        if ((dwStandardBits & WRITE_OWNER) == WRITE_OWNER) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! WRITE_OWNER\n", WRITE_OWNER);
        }

        if ((dwStandardBits & SYNCHRONIZE) == SYNCHRONIZE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! SYNCHRONIZE\n", SYNCHRONIZE);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_REQUIRED) == STANDARD_RIGHTS_REQUIRED) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_REQUIRED\n", STANDARD_RIGHTS_REQUIRED);
        }

        if ((dwStandardBits & STANDARD_RIGHTS_ALL) == STANDARD_RIGHTS_ALL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! STANDARD_RIGHTS_ALL\n", STANDARD_RIGHTS_ALL);
        }

        dwExtraBits = dwStandardBits & (~(DELETE
                                          | READ_CONTROL
                                          | STANDARD_RIGHTS_READ
                                          | STANDARD_RIGHTS_WRITE
                                          | STANDARD_RIGHTS_EXECUTE
                                          | WRITE_DAC
                                          | WRITE_OWNER
                                          | SYNCHRONIZE
                                          | STANDARD_RIGHTS_REQUIRED
                                          | STANDARD_RIGHTS_ALL));
        if (dwExtraBits) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"    Extra standard bits    == 0x%1!.8x! <-This is a problem, should be all 0s\n",
                         dwExtraBits);
        }
    }

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"    Specific Rights        == 0x%1!.8x!\n", dwSpecificBits);

    // **************************************************************************
    // *
    // * Print then decode the ACCESS_SYSTEM_SECURITY bit
    // *
    // *************************************************************************

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"    Access System Security == 0x%1!.8x!\n", dwAccessSystemSecurityBit);

    // **************************************************************************
    // *
    // * Print then decode the generic rights bits, which will rarely be on
    // *
    // * Generic bits are nearly always mapped by Windows NT before it tries to do
    // *   anything with them.  You can ignore the fact that generic bits are
    // *   special in any way, although it helps to keep track of what the mappings
    // *   are so that you don't have any surprises
    // *
    // * The only time the generic bits are not mapped immediately is if they are
    // *   placed in an inheritable ACE in an ACL, or in an ACL that will be
    // *   assigned by default (such as the default DACL in an access token).  In
    // *   that case they're mapped when the child object is created (or when the
    // *   default DACL is used at object creation time)
    // *
    // **************************************************************************

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"    Generic Rights         == 0x%1!.8x!\n", dwGenericBits);

    if (dwGenericBits) {

        if ((dwGenericBits & GENERIC_READ) == GENERIC_READ) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! GENERIC_READ\n", GENERIC_READ);
        }

        if ((dwGenericBits & GENERIC_WRITE) == GENERIC_WRITE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! GENERIC_WRITE\n", GENERIC_WRITE);
        }

        if ((dwGenericBits & GENERIC_EXECUTE) == GENERIC_EXECUTE) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! GENERIC_EXECUTE\n", GENERIC_EXECUTE);
        }

        if ((dwGenericBits & GENERIC_ALL) == GENERIC_ALL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"                              0x%1!.8x! GENERIC_ALL\n", GENERIC_ALL);
        }

        dwExtraBits = dwGenericBits & (~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL));
        if (dwExtraBits) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"    Extra generic bits     == 0x%1!.8x! <-This is a problem, should be all 0s\n",
                         dwExtraBits);
        }
    }

}  // *** SmbExamineMask()

static BOOL
SmbExamineACL(
    RESOURCE_HANDLE ResourceHandle,
    PACL    paclACL
    )

/*++

Routine Description:

    Dump the Access Control List context.

Return Value:

        none

--*/

{
    ACL_SIZE_INFORMATION       asiAclSize;
    ACL_REVISION_INFORMATION   ariAclRevision;
    DWORD                      dwBufLength;
    DWORD                      dwAcl_i;
    ACCESS_ALLOWED_ACE *       paaAllowedAce;

    if (!IsValidAcl(paclACL)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  SmbExamineACL() - IsValidAcl() failed.\n");
        return FALSE;
    }

    dwBufLength = sizeof(asiAclSize);

    if (!GetAclInformation(paclACL, &asiAclSize, dwBufLength, AclSizeInformation)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  SmbExamineACL() - GetAclInformation failed.\n");
        return FALSE;
    }

    dwBufLength = sizeof(ariAclRevision);

    if (!GetAclInformation(paclACL, (LPVOID) &ariAclRevision, dwBufLength, AclRevisionInformation)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  SmbExamineACL() - GetAclInformation failed\n");
        return FALSE;
    }

    (g_LogEvent)(ResourceHandle,
                 LOG_INFORMATION,
                 L"  ACL has %1!d! ACE(s), %2!d! bytes used, %3!d! bytes free\n",
                 asiAclSize.AceCount,
                 asiAclSize.AclBytesInUse,
                 asiAclSize.AclBytesFree);

    switch (ariAclRevision.AclRevision) {
        case ACL_REVISION1:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACL revision is %1!d! == ACL_REVISION1\n", ariAclRevision.AclRevision);
            break;
        case ACL_REVISION2:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACL revision is %1!d! == ACL_REVISION2\n", ariAclRevision.AclRevision);
            break;
        default:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACL revision is %1!d! == Unrecognized ACL Revision.\n",
                         ariAclRevision.AclRevision);
            return FALSE;
            break;
    }

    for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount;  dwAcl_i++) {

        if (!GetAce(paclACL, dwAcl_i, (LPVOID *) &paaAllowedAce)) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  SmbExamineACL() - GetAce failed.\n");
            return FALSE;
        }

        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  ACE %1!d! size %2!d!\n", dwAcl_i, paaAllowedAce->Header.AceSize);

        {
            char    szBuf [128];

            wsprintfA(szBuf, "  ACE %d ", dwAcl_i);
            SmbExamineSid(ResourceHandle, &(paaAllowedAce->SidStart), szBuf );
        }

        {
            DWORD dwAceFlags = paaAllowedAce->Header.AceFlags;

            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! flags 0x%2!.2x!\n", dwAcl_i, dwAceFlags);

            if (dwAceFlags) {
                 DWORD   dwExtraBits;

                if ((dwAceFlags & OBJECT_INHERIT_ACE) == OBJECT_INHERIT_ACE) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x01 OBJECT_INHERIT_ACE\n");
                }

                if ((dwAceFlags & CONTAINER_INHERIT_ACE) == CONTAINER_INHERIT_ACE) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x02 CONTAINER_INHERIT_ACE\n");
                }

                if ((dwAceFlags & NO_PROPAGATE_INHERIT_ACE) == NO_PROPAGATE_INHERIT_ACE) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x04 NO_PROPAGATE_INHERIT_ACE\n");
                }

                if ((dwAceFlags & INHERIT_ONLY_ACE) == INHERIT_ONLY_ACE) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x08 INHERIT_ONLY_ACE\n");
                }

                if ((dwAceFlags & VALID_INHERIT_FLAGS) == VALID_INHERIT_FLAGS) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x0F VALID_INHERIT_FLAGS\n");
                }

                if ((dwAceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) == SUCCESSFUL_ACCESS_ACE_FLAG) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x40 SUCCESSFUL_ACCESS_ACE_FLAG\n");
                }

                if ((dwAceFlags & FAILED_ACCESS_ACE_FLAG) == FAILED_ACCESS_ACE_FLAG) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"  0x80 FAILED_ACCESS_ACE_FLAG\n");
                }

                dwExtraBits = dwAceFlags & (~(OBJECT_INHERIT_ACE
                                              | CONTAINER_INHERIT_ACE
                                              | NO_PROPAGATE_INHERIT_ACE
                                              | INHERIT_ONLY_ACE
                                              | VALID_INHERIT_FLAGS
                                              | SUCCESSFUL_ACCESS_ACE_FLAG
                                              | FAILED_ACCESS_ACE_FLAG));
                if (dwExtraBits) {
                    (g_LogEvent)(ResourceHandle,
                                 LOG_INFORMATION,
                                 L"   Extra AceFlag bits     == 0x%1!.8x! <-This is a problem, should be all 0s\n",
                                 dwExtraBits);
                }
            }
        }

        switch (paaAllowedAce->Header.AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is an ACCESS_ALLOWED_ACE_TYPE\n", dwAcl_i);
            break;
        case ACCESS_DENIED_ACE_TYPE:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is an ACCESS_DENIED_ACE_TYPE\n", dwAcl_i);
            break;
        case SYSTEM_AUDIT_ACE_TYPE:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is a  SYSTEM_AUDIT_ACE_TYPE\n", dwAcl_i);
            break;
        case SYSTEM_ALARM_ACE_TYPE:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is a  SYSTEM_ALARM_ACE_TYPE\n", dwAcl_i);
            break;
        default :
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"  ACE %1!d! is an IMPOSSIBLE ACE_TYPE!!! Run debugger, examine value!\n", dwAcl_i);
            return FALSE;
        }

        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"  ACE %1!d! mask               == 0x%2!.8x!\n", dwAcl_i, paaAllowedAce->Mask);

        SmbExamineMask(ResourceHandle, paaAllowedAce->Mask);
    }

    return TRUE;

}  // *** SmbExamineACL()

BOOL
SmbExamineSD(
    RESOURCE_HANDLE         ResourceHandle,
    PSECURITY_DESCRIPTOR    psdSD
    )

/*++

Routine Description:

    Dump the Security descriptor context.

Arguments:

    psdSD - the SD to dump

Return Value:

    BOOL, TRUE for success, FALSE for failure

--*/

{
    PACL                        paclDACL;
    PACL                        paclSACL;
    BOOL                        bHasDACL        = FALSE;
    BOOL                        bHasSACL        = FALSE;
    BOOL                        bDaclDefaulted  = FALSE;
    BOOL                        bSaclDefaulted  = FALSE;
    BOOL                        bOwnerDefaulted = FALSE;
    BOOL                        bGroupDefaulted = FALSE;
    PSID                        psidOwner;
    PSID                        psidGroup;
    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;
    DWORD                       dwSDRevision;
    DWORD                       dwSDLength;

    if (!IsValidSecurityDescriptor(psdSD)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - IsValidSecurityDescriptor failed.\n");
        return FALSE;
    }

    dwSDLength = GetSecurityDescriptorLength(psdSD);

    if (!GetSecurityDescriptorDacl(psdSD, (LPBOOL) &bHasDACL, (PACL *) &paclDACL, (LPBOOL) &bDaclDefaulted)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorDacl failed.\n");
        return FALSE;
    }

    if (!GetSecurityDescriptorSacl(psdSD, (LPBOOL) &bHasSACL, (PACL *) &paclSACL, (LPBOOL) &bSaclDefaulted)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorSacl failed.\n");
        return FALSE;
    }

    if (!GetSecurityDescriptorOwner(psdSD, (PSID *)&psidOwner, (LPBOOL)&bOwnerDefaulted)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorOwner failed.\n");
        return FALSE;
    }

    if (!GetSecurityDescriptorGroup(psdSD, (PSID *) &psidGroup, (LPBOOL) &bGroupDefaulted)) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorGroup failed.\n");
        return FALSE;
    }

    if (!GetSecurityDescriptorControl(
                                psdSD,
                                (PSECURITY_DESCRIPTOR_CONTROL) &sdcSDControl,
                                (LPDWORD) &dwSDRevision))
    {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SmbExamineSD() - GetSecurityDescriptorControl failed.\n");
        return FALSE;
    }

    switch (dwSDRevision) {
        case SECURITY_DESCRIPTOR_REVISION1:
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD is valid.  SD is %1!d! bytes long.  SD revision is "
                         L"%2!d! == SECURITY_DESCRIPTOR_REVISION1\n",
                         dwSDLength, dwSDRevision);
            break;

        default :
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD is valid.  SD is %1!d! bytes long.  SD revision is "
                         L"%2!d! == ! SD Revision is an IMPOSSIBLE SD revision!!! "
                         L"Perhaps a new revision was added...\n",
                         dwSDLength,
                         dwSDRevision);
            return FALSE;
    }

    if (SE_SELF_RELATIVE & sdcSDControl) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD is in self-relative format (all SDs returned by the system are)\n");
    }

    if (NULL == psidOwner) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's Owner is NULL, so SE_OWNER_DEFAULTED is ignored\n");
    }
    else {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's Owner is Not NULL\n");

        if (bOwnerDefaulted) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's Owner-Defaulted flag is TRUE\n");
        }
        else {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's Owner-Defaulted flag is FALSE\n");
        }
    }

    // **************************************************************************
    // *
    // * The other use for psidGroup is for Macintosh client support
    // *
    // **************************************************************************

    if (NULL == psidGroup) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's Group is NULL, so SE_GROUP_DEFAULTED is ignored. SD's Group "
                     L"being NULL is typical, GROUP in SD(s) is mainly for POSIX compliance\n");
    }
    else {
        if (bGroupDefaulted) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's Group-Defaulted flag is TRUE\n");
        }
        else {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's Group-Defaulted flag is FALSE\n");
        }
    }

    if (SE_DACL_PRESENT & sdcSDControl) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's DACL is Present\n");

        if (bDaclDefaulted) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's DACL-Defaulted flag is TRUE\n");
        } else {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's DACL-Defaulted flag is FALSE\n");
        }

        if (NULL == paclDACL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD has a NULL DACL explicitly specified (allows all access to Everyone). "
                         L"This does not apply to this SD, but for comparison, a non-NULL DACL pointer "
                         L"to a 0-length ACL allows  no access to anyone\n");
        }
        else if(!SmbExamineACL(ResourceHandle, paclDACL))  {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SmbExamineSD() - SmbExamineACL failed.\n");
        }
    }
    else {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's DACL is Not Present, so SE_DACL_DEFAULTED is ignored. SD has no "
                     L"DACL at all (allows all access to Everyone)\n");
    }

    if (SE_SACL_PRESENT & sdcSDControl) {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's SACL is Present\n");

        if (bSaclDefaulted) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's SACL-Defaulted flag is TRUE\n");
        }
        else {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD's SACL-Defaulted flag is FALSE\n");
        }

        if (NULL == paclSACL) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SD has a NULL SACL explicitly specified\n");
        }
        else if (!SmbExamineACL(ResourceHandle, paclSACL)) {
            (g_LogEvent)(ResourceHandle,
                         LOG_INFORMATION,
                         L"SmbExamineSD() - SmbExamineACL failed.\n");
        }
    }
    else {
        (g_LogEvent)(ResourceHandle,
                     LOG_INFORMATION,
                     L"SD's SACL is Not Present, so SE_SACL_DEFAULTED is ignored. SD has no "
                     L"SACL at all (or we did not request to see it)\n");
    }

    return TRUE;

}  // *** SmbExamineSD()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\spooler\splsvc\process.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    genapp.c

Abstract:

    Resource DLL for Generic Applications.

Author:

    Rod Gamache (rodga) 8-Jan-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



DWORD
GetProcessId(
    IN HANDLE ProcessHandle,
    OUT LPDWORD ProcessId
    )

/*++

Routine Description:

    Get the process Id for a process, given its process handle.

Arguments:

    ProcessHandle - the handle for the process to query.

    ProcessId - pointer to a DWORD to receive the process Id.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_PARAMETER on error.

--*/

{
    DWORD   status;
    DWORD   returnLength;
    PROCESS_BASIC_INFORMATION basicProcessInfo;

    //
    // Find the process id.
    //
    status = NtQueryInformationProcess( ProcessHandle,
                                        ProcessBasicInformation,
                                        &basicProcessInfo,
                                        sizeof(PROCESS_BASIC_INFORMATION),
                                        &returnLength );
    if ( !NT_SUCCESS(status) ) {
        *ProcessId = 0;
        return(ERROR_INVALID_PARAMETER);
    }

    *ProcessId = basicProcessInfo.UniqueProcessId;

    return(ERROR_SUCCESS);

} // GetProcessId
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\spooler\splsvc\alloc.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    alloc.c

Abstract:

    Generic realloc code for any api that can fail with
    ERROR_INSUFFICIENT_BUFFER.

Author:

    Albert Ting (AlbertT)  25-Sept-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "alloc.hxx"

PBYTE
pAllocRead(
    HANDLE hUserData,
    ALLOC_FUNC AllocFunc,
    DWORD dwLenHint,
    PDWORD pdwLen OPTIONAL
    )
{
    ALLOC_DATA AllocData;
    PBYTE pBufferOut = NULL;
    DWORD dwLastError;
    DWORD cbActual;

    if( pdwLen ){
        *pdwLen = 0;
    }

    if( !dwLenHint ){

        DBGMSG( DBG_ERROR, ( "ReallocRead: dwLenHint = 0\n" ));

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    AllocData.pBuffer = NULL;
    AllocData.cbBuffer = dwLenHint;

    for( ; ; ){

        cbActual = AllocData.cbBuffer;
        AllocData.pBuffer = (PBYTE)LocalAlloc( LMEM_FIXED, cbActual );

        if( !AllocData.pBuffer ){
            break;
        }

        if( !AllocFunc( hUserData, &AllocData )){

            //
            // Call failed.
            //
            dwLastError = GetLastError();
            LocalFree( (HLOCAL)AllocData.pBuffer );

            if( dwLastError != ERROR_INSUFFICIENT_BUFFER &&
                dwLastError != ERROR_MORE_DATA ){

                break;
            }
        } else {

            pBufferOut = AllocData.pBuffer;

            if( pdwLen ){
                *pdwLen = cbActual;
            }
            break;
        }
    }

    return pBufferOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\spooler\splsvc\splsvc.cxx ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved.

Module Name:

    splsvc.c

Abstract:

    Resource DLL for Spooler

Author:

    Albert Ting (albertt) 17-Sept-1996
    Based on resdll\genapp

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "splsvc.hxx"
#include "spooler.hxx"
#include "clusinfo.hxx"
#include "cleanup.hxx"
#include "clusrtl.h"

MODULE_DEBUG_INIT( DBG_ERROR|DBG_WARN|DBG_TRACE, DBG_ERROR );

#define MAX_SPOOLER 60

#define MAX_GROUP_NAME_LENGTH 120

#define SPOOLER_TERMINATE // Kill the spooler on terminate if pending offline.

#define SplSvcLogEvent ClusResLogEvent
#define SplSvcSetResourceStatus ClusResSetResourceStatus

#define NET_NAME_RESOURCE_NAME CLUS_RESTYPE_NAME_NETNAME

#define PARAM_NAME__DEFAULTSPOOLDIRECTORY CLUSREG_NAME_PRTSPOOL_DEFAULT_SPOOL_DIR
#define PARAM_NAME__JOBCOMPLETIONTIMEOUT CLUSREG_NAME_PRTSPOOL_TIMEOUT

#define KEY_NAME__DEFAULTSPOOLDIRECTORY L"Printers"
#define KEY_NAME__JOBCOMPLETIONTIMEOUT NULL

#define PARAM_MIN__JOBCOMPLETIONTIMEOUT    0
#define PARAM_MAX__JOBCOMPLETIONTIMEOUT    ((DWORD) -1)
#define PARAM_DEFAULT_JOBCOMPLETIONTIMEOUT 160

typedef struct _SPOOLER_PARAMS {
    LPWSTR      DefaultSpoolDirectory;
    DWORD       JobCompletionTimeout;
} SPOOLER_PARAMS, *PSPOOLER_PARAMS;

//
// Properties
//

RESUTIL_PROPERTY_ITEM
SplSvcResourcePrivateProperties[] = {
    { PARAM_NAME__DEFAULTSPOOLDIRECTORY, KEY_NAME__DEFAULTSPOOLDIRECTORY, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(SPOOLER_PARAMS,DefaultSpoolDirectory) },
    { PARAM_NAME__JOBCOMPLETIONTIMEOUT, KEY_NAME__JOBCOMPLETIONTIMEOUT, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT_JOBCOMPLETIONTIMEOUT, PARAM_MIN__JOBCOMPLETIONTIMEOUT, PARAM_MAX__JOBCOMPLETIONTIMEOUT, 0, FIELD_OFFSET(SPOOLER_PARAMS,JobCompletionTimeout) },
    { 0 }
};

//
// Lock to protect the ProcessInfo table
//
CRITICAL_SECTION gProcessLock;

//
// Global count of spooler resource instances.
//
UINT gcSpoolerInfo;

extern CLRES_FUNCTION_TABLE SplSvcFunctionTable;

#define PSPOOLERINFO_FROM_RESID(resid) ((PSPOOLER_INFORMATION)resid)
#define RESID_FROM_SPOOLERINFO(pSpoolerInfo) ((RESID)pSpoolerInfo)

//
// Forward prototypes.
//

#ifdef __cplusplus
extern "C"
#endif

BOOLEAN
WINAPI
SplSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

RESID
WINAPI
SplSvcOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

VOID
WINAPI
SplSvcClose(
    IN RESID Resid
    );

DWORD
WINAPI
SplSvcOnline(
    IN RESID Resid,
    IN OUT PHANDLE EventHandle
    );

DWORD
WINAPI
SplSvcOffline(
    IN RESID Resid
    );

VOID
WINAPI
SplSvcTerminate(
    IN RESID Resource
    );

BOOL
WINAPI
SplSvcIsAlive(
    IN RESID Resource
    );

BOOL
WINAPI
SplSvcLooksAlive(
    IN RESID Resource
    );

DWORD
SplSvcGetPrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
SplSvcValidatePrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PSPOOLER_PARAMS Params
    );

DWORD
SplSvcSetPrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );


PSPOOLER_INFORMATION
pNewSpoolerInfo(
    LPCTSTR pszResource,
    RESOURCE_HANDLE ResourceHandle,
    PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    PLOG_EVENT_ROUTINE LogEvent
    )
{
    PSPOOLER_INFORMATION pSpoolerInfo = NULL;
    LPTSTR pszResourceNew = NULL;

    pSpoolerInfo = (PSPOOLER_INFORMATION)LocalAlloc(
                                             LPTR,
                                             sizeof( SPOOLER_INFORMATION ));

    if( !pSpoolerInfo ){
        goto Fail;
    }

    pszResourceNew = (LPTSTR)LocalAlloc(
                                 LMEM_FIXED,
                                 ( lstrlen( pszResource ) + 1 )
                                     * sizeof( TCHAR ));

    if( !pszResourceNew ){
        goto Fail;
    }

    StringCchCopy(pszResourceNew, 
                  lstrlen(pszResource) + 1,
                  pszResource );

    pSpoolerInfo->pfnLogEvent = LogEvent;
    pSpoolerInfo->ResourceHandle = ResourceHandle;
    pSpoolerInfo->pfnSetResourceStatus = SetResourceStatus;

    pSpoolerInfo->pszResource = pszResourceNew;
    pSpoolerInfo->pszName = NULL;
    pSpoolerInfo->pszAddress = NULL;

    return pSpoolerInfo;

Fail:

    if( pszResourceNew ){
        LocalFree( (HLOCAL)pszResourceNew );
    }

    if( pSpoolerInfo ){
        LocalFree( (HLOCAL)pSpoolerInfo );
    }

    return NULL;
}

VOID
vDeleteSpoolerInfo(
    PSPOOLER_INFORMATION pSpoolerInfo
    )
{
    if( !pSpoolerInfo ){
        return;
    }

    SPLASSERT( !pSpoolerInfo->cRef );

    //
    // Shut down everything.
    //
    if( pSpoolerInfo->pszName ){
        LocalFree( (HLOCAL)pSpoolerInfo->pszName );
    }

    if( pSpoolerInfo->pszAddress ){
        LocalFree( (HLOCAL)pSpoolerInfo->pszAddress );
    }

    if( pSpoolerInfo->pszResource ){
        LocalFree( (HLOCAL)pSpoolerInfo->pszResource );
    }
    
    LocalFree( (HLOCAL)pSpoolerInfo );
}




BOOL
Init(
    VOID
    )
{
    BOOL bRet = FALSE;

    if(bRet = InitializeCriticalSectionAndSpinCount(&gProcessLock,0x80000000))
    {
        bRet = bSplLibInit();
    }

    return bRet;
}

BOOLEAN
WINAPI
SplSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    UNREFERENCED_PARAMETER(DllHandle);
    UNREFERENCED_PARAMETER(Reserved);

    switch( Reason ) {

    case DLL_PROCESS_ATTACH:

        if( !Init() ){

            DBGMSG( DBG_ERROR, ( "DllEntryPoint: failed to init\n" ));
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:
    	 DeleteCriticalSection(&gProcessLock);
        break;

    default:
        break;
    }

    return TRUE;

}


/********************************************************************

    Required exports and function table entries used by clustering.

********************************************************************/




/********************************************************************

    Resource DLL functions.

********************************************************************/



BOOL
bSplRegCopyTree(
    IN HKEY hClusterKey,
    IN HKEY hLocalKey
    )

/*++

Routine Description:

    Recursives copies every key and value from under hLocalKey to hClusterKey 

Arguments:

    hClusterKey - handle to the cluster registry (destination)
    hLocalKey   - handle to the local registry (source)

Return Value:

    TRUE - success
    FALSE - failure

--*/

{
    BOOL    bStatus = FALSE;
    DWORD   dwError, dwIndex, cbValueName, cbData, cbKeyName, dwType;
    DWORD   cbMaxSubKeyLen, cbMaxValueNameLen, cValues, cSubKeys, cbMaxValueLen;
    LPBYTE  lpValueName = NULL, lpData = NULL, lpKeyName = NULL;
    HKEY    hLocalSubKey = NULL, hClusterSubKey = NULL;

    //
    // Retrieve the max buffer sizes required for the copy
    //
    dwError = RegQueryInfoKey( hLocalKey, NULL, NULL, NULL, &cSubKeys,
                               &cbMaxSubKeyLen, NULL, &cValues,
                               &cbMaxValueNameLen, &cbMaxValueLen,
                               NULL, NULL );   
    if( dwError ){

        SetLastError( dwError );
        goto CleanUp;
    }

    // 
    // Add for the terminating NULL character
    //
    ++cbMaxSubKeyLen;
    ++cbMaxValueNameLen;

    //
    // Allocate the buffers
    //
    lpValueName = (LPBYTE) LocalAlloc( LMEM_FIXED, cbMaxValueNameLen * sizeof(WCHAR) );
    lpData      = (LPBYTE) LocalAlloc( LMEM_FIXED, cbMaxValueLen );
    lpKeyName   = (LPBYTE) LocalAlloc( LMEM_FIXED, cbMaxSubKeyLen * sizeof(WCHAR) );

    if( !lpValueName || !lpData || !lpKeyName){

        goto CleanUp;
    }    

    //
    // Copy all the values in the current key
    //
    for (dwIndex = 0; dwIndex < cValues; ++ dwIndex) {

       cbValueName = cbMaxValueNameLen;
       cbData = cbMaxValueLen;
 
       //
       // Retrieve the value name and the data
       //
       dwError = RegEnumValue( hLocalKey, dwIndex, (LPWSTR) lpValueName, &cbValueName,
                               NULL, &dwType, lpData, &cbData );
       
       if( dwError ){

           SetLastError( dwError );
           goto CleanUp;
       }

       // 
       // Set the value in the cluster registry
       //
       dwError = ClusterRegSetValue( hClusterKey, (LPWSTR) lpValueName, dwType,
                                     lpData, cbData );

       if( dwError ){

           SetLastError( dwError );
           goto CleanUp;
       }
    }

    //
    // Recursively copies all the subkeys
    //
    for (dwIndex = 0; dwIndex < cSubKeys; ++ dwIndex) {

        cbKeyName = cbMaxSubKeyLen;

        //
        // Retrieve the key name
        //
        dwError = RegEnumKeyEx( hLocalKey, dwIndex, (LPWSTR) lpKeyName, &cbKeyName,
                                NULL, NULL, NULL, NULL );
        
        if( dwError ){
 
            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Open local subkey
        //
        if( dwError = RegOpenKeyEx( hLocalKey, (LPWSTR) lpKeyName, 0,
                                    KEY_READ, &hLocalSubKey ) ){

            SetLastError( dwError );
            goto CleanUp;
        }

        //
        // Create the cluster subkey
        //

        if(( dwError = ClusterRegOpenKey( hClusterKey, (LPWSTR) lpKeyName, 
                                          KEY_READ|KEY_WRITE,
                                          &hClusterSubKey)) == ERROR_FILE_NOT_FOUND )
        {
            if( dwError = ClusterRegCreateKey( hClusterKey, (LPWSTR) lpKeyName, 
                                               0,KEY_READ|KEY_WRITE,
                                               NULL, &hClusterSubKey, NULL ) )
            {
                SetLastError( dwError );
                goto CleanUp;
            }
        }

        //
        // Copy the subkey tree
        //
        if( !bSplRegCopyTree( hClusterSubKey, hLocalSubKey ) ){
            
            goto CleanUp;
        }

        // 
        // Close the registry handle
        //
        RegCloseKey( hLocalSubKey );
        ClusterRegCloseKey( hClusterSubKey );

        hLocalSubKey = NULL;
        hClusterSubKey = NULL;

    }

    bStatus = TRUE;

CleanUp:

    if( lpValueName ){
        LocalFree( lpValueName );
    }
    if( lpData ){
        LocalFree( lpData );
    }
    if( lpKeyName ){
        LocalFree( lpKeyName );
    }
    if( hLocalSubKey ){
        RegCloseKey( hLocalSubKey );
    }
    if( hClusterSubKey ){
        ClusterRegCloseKey( hClusterSubKey );
    }

    return bStatus;
}

BOOL
bUpdateRegPort(
    IN HKEY hClusterKey,
    OUT LPBOOL pbRegUpdated
    )

/*++

Routine Description:

    Moves Port data from the local to the cluster registry

Arguments:

    hClusterKey - handle to the cluster registry
    pbRegUpdated - flag to indicate if the registry was updated

Return Value:

    TRUE - success
    FALSE - failure

--*/

{
    BOOL   bStatus = FALSE;
    DWORD  dwError, dwType, dwValue, dwSize;
    HKEY   hLocalLPR = NULL, hClusterLPR = NULL;

    WCHAR  szLocalLPRKey[] = L"System\\CurrentControlSet\\Control\\Print\\Monitors\\LPR Port";
    WCHAR  szClusterLPRKey[] = L"Monitors\\LPR Port";
    WCHAR  szSplVersion[] = L"Spooler Version";
    
    //
    // Initialize the bRegUpdate flag
    //
    *pbRegUpdated = FALSE;

    //
    // Check if ports have been migrated already
    //
    dwSize = sizeof(DWORD);
    if( dwError = ClusterRegQueryValue( hClusterKey, szSplVersion, &dwType,
                                        (LPBYTE) &dwValue, &dwSize ) ){

        if( dwError != ERROR_FILE_NOT_FOUND ){

            SetLastError( dwError );
            return FALSE;
        }

    } else {

        if( dwValue == 1 ){
            return TRUE;
        }
    }

    //
    // Open the local LPR Port key, if any
    //
    if( dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szLocalLPRKey, 0,
                                KEY_READ, &hLocalLPR ) ){

        //
        // LPR Port key was not found
        //
        if( dwError == ERROR_FILE_NOT_FOUND ){
             
            bStatus = TRUE;

        } else {
            
            SetLastError( dwError );
        }
        goto CleanUp;
    }

    // 
    // Create the LPR Port key on the cluster registry
    //                                    

    if(( dwError = ClusterRegOpenKey( hClusterKey, szClusterLPRKey, 
                                     KEY_READ|KEY_WRITE,
                                     &hClusterLPR ) ) == ERROR_FILE_NOT_FOUND)
    {


        if( dwError = ClusterRegCreateKey( hClusterKey, szClusterLPRKey, 
                                           0,KEY_READ|KEY_WRITE,
                                           NULL, &hClusterLPR, NULL ) )
        {
            SetLastError( dwError );
            goto CleanUp;
        }
    }
    else if ( dwError )
    {
        SetLastError( dwError );
        goto CleanUp;
    }

    bStatus = bSplRegCopyTree( hClusterLPR, hLocalLPR );

    if( bStatus ){

        //
        // Create a value in the cluster to avoid repeated copying of the port data
        //
        dwValue = 1;
        dwSize  = sizeof(dwValue);
        ClusterRegSetValue( hClusterKey, szSplVersion, REG_DWORD,
                            (LPBYTE) &dwValue, dwSize ); 
        *pbRegUpdated = TRUE;
    }

CleanUp:

    if( hLocalLPR ){
        RegCloseKey( hLocalLPR );
    }

    if( hClusterLPR ){
        ClusterRegCloseKey( hClusterLPR );
    }

    return bStatus;
}

RESID
WINAPI
SplSvcOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Opens the spooler resource.  This will start the spooler
    service if necessary.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo = NULL;
    BOOL bTooMany = FALSE,  bRegUpdated;
    HKEY parametersKey = NULL;
    DWORD status;
    HCLUSTER hCluster;

    UNREFERENCED_PARAMETER(ResourceKey);

    vEnterSem();

    DBGMSG( DBG_WARN, ( ">>> Open: called\n" ));

    if( gcSpoolerInfo == MAX_SPOOLER ){
        bTooMany = TRUE;
        status = ERROR_ALLOTTED_SPACE_EXCEEDED;
        goto FailLeave;
    }

    //
    // Open the Parameters key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                CLUSREG_KEYNAME_PARAMETERS,
                                KEY_READ,
                                &parametersKey );
    if ( status != ERROR_SUCCESS || parametersKey == NULL ) {
        (SplSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key for resource '%1!ws!'. Error: %2!u!.\n",
            ResourceName,
            status );
        goto FailLeave;
    }

    //
    // Move the ports data from local to cluster registry
    //

    if( !bUpdateRegPort( parametersKey, &bRegUpdated ) ){

       (SplSvcLogEvent)(
            ResourceHandle,
            LOG_WARNING,
            L"LPR Port settings could not be moved to cluster registry.\n" );

       DBGMSG( DBG_WARN, ( "Port settings could not be moved to cluster registry" ));
    }

    //
    // Find a free index in the process info table for this new app.
    //

    pSpoolerInfo = pNewSpoolerInfo( ResourceName,
                                    ResourceHandle,
                                    SplSvcSetResourceStatus,
                                    SplSvcLogEvent );

    if( !pSpoolerInfo ){
        status = ERROR_ALLOTTED_SPACE_EXCEEDED;
        goto FailLeave;
    }

    //
    // Save the name of the resource.
    //
    hCluster = OpenCluster( NULL );
    if ( !hCluster ) {
        status = GetLastError();
        goto FailLeave;
    }
    pSpoolerInfo->hResource = OpenClusterResource( hCluster,
                                                   ResourceName );
    status = GetLastError();
    CloseCluster( hCluster );
    if ( pSpoolerInfo->hResource == NULL ) {
        goto FailLeave;
    }
    
    pSpoolerInfo->eState = kOpen;
    pSpoolerInfo->ParametersKey = parametersKey;

    vAddRef( pSpoolerInfo );
    ++gcSpoolerInfo;

    vLeaveSem();

    DBGMSG( DBG_WARN,
            ( "Open: return %x\n", RESID_FROM_SPOOLERINFO( pSpoolerInfo )));

    return RESID_FROM_SPOOLERINFO(pSpoolerInfo);

FailLeave:

    vLeaveSem();

    if( bTooMany ){

        (SplSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Too many spoolers.\n" );

        DBGMSG( DBG_WARN, ( "SplSvcOpen: Too many spoolers.\n" ));

    } else {

        (SplSvcLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to create new spooler. Error: %1!u!.\n",
            GetLastError() );

        DBGMSG( DBG_ERROR, ( "SplSvcOpen: Unable to create spooler %d\n",
                GetLastError()));
    }

    if ( parametersKey != NULL ) {
        ClusterRegCloseKey( parametersKey );
    }

    if ( pSpoolerInfo && (pSpoolerInfo->hResource != NULL) ) {
        CloseClusterResource( pSpoolerInfo->hResource );
    }

    vDeleteSpoolerInfo( pSpoolerInfo );

    SetLastError( status );

    return (RESID)0;
}

VOID
WINAPI
SplSvcClose(
    IN RESID Resid
    )

/*++

Routine Description:

    Close down the open spooler resource ID.  Note that we'll leave
    the spooler running, since it always should be running.

Arguments:

    Resource - supplies resource id to be closed

Return Value:

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo;
    DBGMSG( DBG_WARN, ( ">>> Close: called %x\n", Resid ));

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    //
    // If resource is still online, terminate it.
    //
    if( pSpoolerInfo->eState == kOnline ){
        SplSvcTerminate( Resid );
    }

    vEnterSem();

    --gcSpoolerInfo;
    pSpoolerInfo->eState = kClose;

    vLeaveSem();

    if (pSpoolerInfo->hResource != NULL ) {
        CloseClusterResource( pSpoolerInfo->hResource );
    }

    if (pSpoolerInfo->ParametersKey != NULL ) {
        ClusterRegCloseKey( pSpoolerInfo->ParametersKey );
    }
    
    vDecRef( pSpoolerInfo );
}

DWORD
WINAPI
SplSvcOnline(
    IN RESID Resid,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online the spooler resource.

    This always completes asynchronously with ERROR_IO_PENDING.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    In success case, this returns ERROR_IO_PENDING, else win32
    error code.

--*/

{
    BOOL bStatus;
    DWORD Status = ERROR_IO_PENDING;
    PSPOOLER_INFORMATION pSpoolerInfo;

    UNREFERENCED_PARAMETER( EventHandle );

    DBGMSG( DBG_WARN, ( ">>> Online: called %x\n", Resid ));

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    //
    // Rpc to the spooler to initiate Online.
    //
    bStatus = SpoolerOnline( pSpoolerInfo );

    if( !bStatus ){

        Status = GetLastError();
        SPLASSERT( Status );

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Unable to online spooler resource. Error: %1!u!.\n",
            Status );

        DBGMSG( DBG_ERROR, ( "SplSvcOnline: Unable to online spooler\n" ));
    }

    return Status;
}

DWORD
WINAPI
SplSvcOffline(
    IN RESID Resid
    )

/*++

Routine Description:

    Offline the spooler resource.

Arguments:

    Resid - supplies the resource to be taken offline

Return Value:

    In success case, this returns ERROR_IO_PENDING, else win32
    error code.

--*/

{
    PSPOOLER_INFORMATION  pSpoolerInfo;

    DBGMSG( DBG_WARN, ( ">>> Offline: called %x\n", Resid ));

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    vEnterSem();
    pSpoolerInfo->ClusterResourceState = ClusterResourceOffline;
    vLeaveSem();

    return(SpoolerOffline(pSpoolerInfo));
}

VOID
WINAPI
SplSvcTerminate(
    IN RESID Resid
    )

/*++

Routine Description:

    Terminate and restart the spooler--no waiting.

Arguments:

    Resid - supplies resource id to be terminated

Return Value:

--*/

{
    PSPOOLER_INFORMATION  pSpoolerInfo;

    DBGMSG( DBG_WARN, ( ">>> Terminate: called %x\n", Resid ));

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    vEnterSem();
    pSpoolerInfo->ClusterResourceState = ClusterResourceFailed;
    vLeaveSem();

    SpoolerTerminate(pSpoolerInfo);
    return;

}

BOOL
WINAPI
SplSvcIsAlive(
    IN RESID Resid
    )

/*++

Routine Description:

    IsAlive routine for Generice Applications resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo;

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    return SpoolerIsAlive( pSpoolerInfo );
}


BOOL
WINAPI
SplSvcLooksAlive(
    IN RESID Resid
    )

/*++

Routine Description:

    LooksAlive routine for Generic Applications resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo;

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( Resid );

    return SpoolerLooksAlive( pSpoolerInfo );
}


DWORD
SplSvcGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLCTL_GET_REQUIRED_DEPENDENCIES control function
    for resources of type Print Spooler.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    typedef struct DEP_DATA {
        CLUSPROP_RESOURCE_CLASS storageEntry;
        CLUSPROP_SZ_DECLARE( netnameEntry, sizeof(NET_NAME_RESOURCE_NAME) / sizeof(WCHAR) );
        CLUSPROP_SYNTAX endmark;
    } DEP_DATA, *PDEP_DATA;
    PDEP_DATA   pdepdata = (PDEP_DATA)OutBuffer;
    DWORD       status;

    *BytesReturned = sizeof(DEP_DATA);
    if ( OutBufferSize < sizeof(DEP_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( pdepdata, sizeof(DEP_DATA) );
        pdepdata->storageEntry.Syntax.dw = CLUSPROP_SYNTAX_RESCLASS;
        pdepdata->storageEntry.cbLength = sizeof(DWORD);
        pdepdata->storageEntry.rc = CLUS_RESCLASS_STORAGE;
        pdepdata->netnameEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->netnameEntry.cbLength = sizeof(NET_NAME_RESOURCE_NAME);
        StringCchCopyW( pdepdata->netnameEntry.sz, 
                        COUNTOF(pdepdata->netnameEntry.sz),
                        NET_NAME_RESOURCE_NAME );
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return status;

} // SplSvcGetRequiredDependencies


DWORD
SplSvcResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Print Spooler resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PSPOOLER_INFORMATION pSpoolerInfo;
    DWORD               required;
    LPWSTR              pszResourceNew;

    pSpoolerInfo = PSPOOLERINFO_FROM_RESID( ResourceId );

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_REMOVE_OWNER:
        case CLUSCTL_RESOURCE_ADD_OWNER:
        case CLUSCTL_RESOURCE_INSTALL_NODE:
        {
            status = CleanClusterSpoolerData(pSpoolerInfo->hResource, static_cast<LPCWSTR>(InBuffer));

            break;
        }
        
        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( SplSvcResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            pszResourceNew = (LPWSTR)LocalAlloc(
                                         LMEM_FIXED,
                                         ( lstrlenW( (LPWSTR)InBuffer ) + 1 )
                                             * sizeof( WCHAR ));

            if ( pszResourceNew ) {
                LocalFree( (HLOCAL)pSpoolerInfo->pszResource );
                StringCchCopyW( pszResourceNew, 
                                ( lstrlenW( (LPWSTR)InBuffer ) + 1 ),
                                (LPWSTR)InBuffer );
                pSpoolerInfo->pszResource = (LPTSTR)pszResourceNew;
                status = ERROR_SUCCESS;
            } else {
                status = GetLastError();
            }

            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = SplSvcGetRequiredDependencies( OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned
                                                    );
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( SplSvcResourcePrivateProperties,
                                            (LPWSTR) OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = SplSvcGetPrivateResProperties( pSpoolerInfo,
                                                    OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = SplSvcValidatePrivateResProperties( pSpoolerInfo,
                                                         InBuffer,
                                                         InBufferSize,
                                                         NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = SplSvcSetPrivateResProperties( pSpoolerInfo,
                                                    InBuffer,
                                                    InBufferSize );
            break;

        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
            
            {
                LPWSTR pszResourceGuid = NULL;

                //
                // Retreive the guid of the spooler resource
                //
                if ((status = GetIDFromName(pSpoolerInfo->hResource, &pszResourceGuid)) == ERROR_SUCCESS)
                {
                    status = SpoolerWriteClusterUpgradedKey(pszResourceGuid);
                
                    LocalFree(pszResourceGuid);
                }
            }

            break;

       case CLUSCTL_RESOURCE_DELETE:
       {
           //
           // First we delete the driver repository on the cluster disk
           //
           if ((status = CleanPrinterDriverRepository(pSpoolerInfo->ParametersKey)) == ERROR_SUCCESS)
           {
               LPWSTR pszResourceGuid = NULL;

               //
               // Now we delete any data stored by the cluster spooler on the local node
               // Retreive the guid of the spooler resource
               //
               if ((status = GetIDFromName(pSpoolerInfo->hResource, &pszResourceGuid)) == ERROR_SUCCESS)
               {
                   status = CleanUnusedClusDriverRegistryKey(pszResourceGuid);

                   //
                   // We do not care about the result of this function
                   //
                   CleanUnusedClusDriverDirectory(pszResourceGuid);
    
                   LocalFree(pszResourceGuid);
               } 
           }

           break;           
       }

       default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // SplSvcResourceControl


DWORD
SplSvcResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Print Spooler resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( SplSvcResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = SplSvcGetRequiredDependencies( OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned
                                                    );
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( SplSvcResourcePrivateProperties,
                                            (LPWSTR) OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2:
        {
            //
            // We could launch CleanSpoolerUnusedFilesAndKeys in a seprate thread.
            // But in that case we'd need to bump up the ref count on the DLL
            // and have CleanSpoolerUnusedFilesAndKeys call FreeLibraryAndExitThread.
            // CleanSpoolerUnusedFilesAndKeys usually takes 100 to 200 milliseconds
            // to complete. When the function has to do extenisve clean up, then it
            // can take up to 500 milliseconds. So there is no compelling reason to
            // call the function in a separate thread. For more details see bug 473820.
            //
            status = CleanSpoolerUnusedFilesAndKeys();
            
            break;
        }

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }
    
    return(status);

} // SplSvcResourceTypeControl



DWORD
SplSvcGetPrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control
    function for resources of type Print Spooler.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    *BytesReturned = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Get the common properties.
    //
    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      SplSvcResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );

    if ( *BytesReturned == 0 ) {
        *BytesReturned = required;
    }

    return(status);

} // SplSvcGetPrivateResProperties



DWORD
SplSvcValidateUniqueProperties(
    IN HRESOURCE        hSelf,
    IN HRESOURCE        hResource,
    IN PVOID            GroupName
    )

/*++

Routine Description:

    Callback function to validate that a resources properties are unique.

    For the SplSvc resource we must ensure that only one print spooler
    resource exists in a group.

    We will never be called for the resource we are creating, only for
    other resources of the same type.

Arguments:

    hSelf     - A handle to the original resource.

    hResource - A handle to a resource of the same Type. Check against this
            to make sure the new properties do not conflict.

    lpszGroupName - The name of the Group the creating resource is in.

Return Value:

    ERROR_SUCCESS - The function completed successfully, only one print
            spooler in the given group.

    ERROR_OBJECT_ALREADY_EXISTS - The name is not unique (i.e., already have
            a print spooler in that group).

    A Win32 error code on other failure.

--*/
{
    WCHAR               groupName[MAX_GROUP_NAME_LENGTH + 1];
    DWORD               groupNameSize = MAX_GROUP_NAME_LENGTH * sizeof(WCHAR);
    CLUSTER_RESOURCE_STATE  resourceState;
    LPWSTR              lpszGroupName = (LPWSTR)GroupName;

    UNREFERENCED_PARAMETER(hSelf);

    groupName[0] = L'\0';

    resourceState =  GetClusterResourceState( hResource,
                                              NULL,
                                              0,
                                              groupName,
                                              &groupNameSize );
    if ( !*groupName ) {
        return(GetLastError());
    }

    if ( lstrcmpiW( lpszGroupName, groupName ) == 0 ) {
        return(ERROR_OBJECT_ALREADY_EXISTS);
    }

    return( ERROR_SUCCESS );

} // SplSvcValidateUniqueProperties



DWORD
SplSvcValidatePrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PSPOOLER_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Print Spooler.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    SPOOLER_PARAMS  currentProps;
    SPOOLER_PARAMS  newProps;
    PSPOOLER_PARAMS pParams = NULL;
    WCHAR           groupName[MAX_GROUP_NAME_LENGTH + 1];
    DWORD           groupNameSize = MAX_GROUP_NAME_LENGTH * sizeof(WCHAR);
    CLUSTER_RESOURCE_STATE  resourceState;
    LPWSTR          nameOfPropInError;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Capture the current set of private properties from the registry.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 SplSvcResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (SplSvcLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }

    ZeroMemory( pParams, sizeof(SPOOLER_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       SplSvcResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( SplSvcResourcePrivateProperties,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the Default Spool Directory
        //
        if ( pParams->DefaultSpoolDirectory &&
             !ResUtilIsPathValid( pParams->DefaultSpoolDirectory ) ) {
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

        //
        // Make sure there is only one print spooler in this group.
        //
        resourceState =  GetClusterResourceState( ResourceEntry->hResource,
                                                  NULL,
                                                  0,
                                                  groupName,
                                                  &groupNameSize );
        if ( !*groupName ) {
            status = GetLastError();
            goto FnExit;
        }

        status = ResUtilEnumResources(ResourceEntry->hResource,
                                      CLUS_RESTYPE_NAME_PRTSPLR,
                                      SplSvcValidateUniqueProperties,
                                      (PVOID)groupName);

        if (status != ERROR_SUCCESS) {
            goto FnExit;
        }
    }

FnExit:

    //
    // Cleanup our parameter block.
    //
    if (   (   (status != ERROR_SUCCESS)
            && (pParams != NULL) )
        || ( pParams == &newProps )
        ) {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   SplSvcResourcePrivateProperties );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        SplSvcResourcePrivateProperties
        );

    return(status);

} // SplSvcValidatePrivateResProperties



DWORD
SplSvcSetPrivateResProperties(
    IN OUT PSPOOLER_INFORMATION ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Print Spooler.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
//    SPOOLER_PARAMS  params;

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = SplSvcValidatePrivateResProperties( ResourceEntry,
                                                 InBuffer,
                                                 InBufferSize,
                                                 NULL /*&params*/ );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyTable( ResourceEntry->ParametersKey,
                                      SplSvcResourcePrivateProperties,
                                      NULL,
                                      TRUE,    // Allow unknowns
                                      InBuffer,
                                      InBufferSize,
                                      NULL );
//    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
//                                               SplSvcResourcePrivateProperties,
//                                               NULL,
//                                               (LPBYTE) &params,
//                                               InBuffer,
//                                               InBufferSize,
//                                               (LPBYTE) &ResourceEntry->Params );

//    ResUtilFreeParameterBlock( (LPBYTE) &params,
//                               (LPBYTE) &ResourceEntry->Params,
//                               SplSvcResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( (ResourceEntry->eState == kOnline) ||
             (ResourceEntry->eState == kOnlinePending) ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // SplSvcSetPrivateResProperties


/********************************************************************

    Utility functions

********************************************************************/


VOID
vEnterSem(
    VOID
    )
{
    EnterCriticalSection( &gProcessLock );
}


VOID
vLeaveSem(
    VOID
    )
{
    LeaveCriticalSection( &gProcessLock );
}

VOID
vAddRef(
    PSPOOLER_INFORMATION pSpoolerInfo
    )
{
    vEnterSem();
    ++pSpoolerInfo->cRef;
    vLeaveSem();
}


VOID
vDecRef(
    PSPOOLER_INFORMATION pSpoolerInfo
    )
{
    UINT uRef;

    SPLASSERT( pSpoolerInfo->cRef );

    vEnterSem();
    uRef = --pSpoolerInfo->cRef;
    vLeaveSem();

    if( !uRef ){
        vDeleteSpoolerInfo( pSpoolerInfo );
    }
}


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( SplSvcFunctionTable,
                         CLRES_VERSION_V1_00,
                         SplSvc,
                         NULL,
                         NULL,
                         SplSvcResourceControl,
                         SplSvcResourceTypeControl );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\spooler\splsvc\clusinfo.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    clusinfo.c

Abstract:

    Retrieves cluster information: net name and TCP/IP address.

    Public functions from this module:

        bGetClusterNameInfo

    This code is a total hack.  It relies on internal knowledge about
    the registry structure of clustering and NetworkName and TCP/IP adddress:

    Questionable Assumptions:

        Directly under the resource GUID there will be a value called
        "Type" that holds the fixed resource name string.

        The resource type names "Network Name" and "IP Address" will
        never change or be localized.  (They shouldn't be localized, since
        they are keys, but I don't see a description value in the registry.)

        There will be a key called "Parameters" that will never change
        (or get localized).

    Bad Assumptions:

        IP Address resource stores a value "Address" that holds
        a REG_SZ string of the tcpip address.

        Network Name resource stores a value "Name" that holds a REG_SZ
        string of the network name.

    General strategy:

        1. Open self resource based on resource string from SplSvcOpen.
        2. Enumerate dependencies looking for net name.
        3. Find net name and save group name.
        4. Enumerate dependencies of net name looking for IP addresses.
        5. Save all found IP addresses.

Author:

    Albert Ting (AlbertT)  25-Sept-96

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "clusinfo.hxx"

#define GROUP_NAME_LEN_HINT MAX_PATH
#define RESOURCE_NAME_LEN_HINT MAX_PATH
#define TYPE_NAME_LEN_HINT MAX_PATH

LPCTSTR gszType = TEXT( "Type" );
LPCTSTR gszParameters = TEXT( "Parameters" );
DWORD   kGuidStringByteSize = 100;

/********************************************************************

    Callback for Querying cluster registry.

********************************************************************/

typedef struct _REG_QUERY_VALUE {
    HKEY hKey;
    LPCTSTR pszValue;
} REG_QUERY_VALUE, *PREG_QUERY_VALUE;

BOOL
bAllocClusterRegQueryValue(
    HANDLE hUserData,
    PALLOC_DATA pAllocData
    )
{
    DWORD dwStatus;
    PREG_QUERY_VALUE pRegQueryValue = (PREG_QUERY_VALUE)hUserData;

    dwStatus = ClusterRegQueryValue( pRegQueryValue->hKey,
                                     pRegQueryValue->pszValue,
                                     NULL,
                                     pAllocData->pBuffer,
                                     &pAllocData->cbBuffer );

    if( dwStatus != NO_ERROR ){

        SetLastError( dwStatus );
        return FALSE;
    }

    return TRUE;
}

/********************************************************************

    Callback for retrieving group name: GetClusterResourceState.

********************************************************************/


BOOL
bAllocGetClusterResourceState(
    HANDLE hUserData,
    PALLOC_DATA pAllocData
    )
{
    DWORD cchGroupName = pAllocData->cbBuffer / sizeof( TCHAR );
    CLUSTER_RESOURCE_STATE crs;

    crs = GetClusterResourceState( (HRESOURCE)hUserData,
                                   NULL,
                                   0,
                                   (LPTSTR)pAllocData->pBuffer,
                                   &cchGroupName );

    pAllocData->cbBuffer = cchGroupName * sizeof( TCHAR );

    return crs != ClusterResourceStateUnknown;
}


/********************************************************************

    Callback for enumerating group resources.

********************************************************************/


typedef struct _RESOURCE_ENUM {
    HRESENUM hResEnum;
    DWORD dwIndex;
} RESOURCE_ENUM, *PRESOURCE_ENUM;

BOOL
bAllocClusterResourceEnum(
    HANDLE hUserData,
    PALLOC_DATA pAllocData
    )
{
    PRESOURCE_ENUM pResourceEnum = (PRESOURCE_ENUM)hUserData;
    DWORD dwStatus;
    DWORD cchName = pAllocData->cbBuffer / sizeof( TCHAR );
    DWORD dwType;

    dwStatus = ClusterResourceEnum( pResourceEnum->hResEnum,
                                    pResourceEnum->dwIndex,
                                    &dwType,
                                    (LPTSTR)pAllocData->pBuffer,
                                    &cchName );

    pAllocData->cbBuffer = cchName * sizeof( TCHAR );

    if( dwStatus != NO_ERROR ){

        SetLastError( dwStatus );
        return FALSE;
    }
    return TRUE;
}


/********************************************************************

    End callbacks.

********************************************************************/

typedef struct _CLUSINFO_DATA {
    LPCTSTR pszResource;
    LPCTSTR pszValue;
} CLUSINFO_DATA, *PCLUSINFO_DATA;

CLUSINFO_DATA gaClusInfoDataMain[] = {
    { TEXT( "Network Name" ), TEXT( "Name" ) },
    { NULL, NULL }
};

CLUSINFO_DATA gaClusInfoDataNetName[] = {
    { TEXT( "IP Address" ), TEXT( "Address" ) },
    { NULL, NULL }
};

enum {
    ClusInfoName = 0,
    ClusInfoAddress,
    ClusInfoMax
};

typedef struct _CLUSINFO_DATAOUT {
    UINT cbData;
    LPCTSTR pszData;
} CLUSINFO_DATAOUT, *PCLUSINFO_DATAOUT;




BOOL
bProcessResourceRegKey(
    IN     HKEY hKey,
    IN     PCLUSINFO_DATA pClusInfoData,
    IN OUT PCLUSINFO_DATAOUT pClusInfoDataOut
    )

/*++

Routine Description:

    Checks whether a resource in a cluster matches any of the ClusInfoData
    resources.  If it does, fill one parameter into the ClusInfoDataOut
    parameter (comma delimited string).

Arguments:

    hKey - Key to read.

    pClusInfoData - Array of different ClusInfoData types that we
        want to look for.

    pClusInfoDataOut - Container that receives data we have found.
        This should be valid on input, since we append to form
        a comma delimited string.

Return Value:

    TRUE - Success: this may or may not have filled in one of the OUT
        parameters, but we didn't encounter any errors trying to read
        the resource.

    FALSE - Failure (LastError set).

--*/

{
    HKEY hKeyParameters = NULL;
    LPCTSTR pszType = NULL;
    BOOL bStatus = TRUE;

    REG_QUERY_VALUE rqv;
    DWORD dwStatus;
    UINT i;

    LPCTSTR pszNewSingleData = NULL;
    LPTSTR pszNewData = NULL;
    UINT cbNewSingleData;
    UINT cbNewData;

    rqv.hKey = hKey;
    rqv.pszValue = gszType;

    pszType = (LPCTSTR)pAllocRead( &rqv,
                                   bAllocClusterRegQueryValue,
                                   TYPE_NAME_LEN_HINT,
                                   NULL );

    if( !pszType ){

        DBGMSG( DBG_WARN,
                ( "bProcessResourceRegKey: ClusterRegOpenKey failed %d\n",
                  GetLastError() ));

        bStatus = FALSE;
        goto Done;
    }

    //
    // Walk through the list and check if there is a match.
    //

    for( i=0; bStatus && pClusInfoData[i].pszResource; ++i ){

        UINT cchLen;

        if( lstrcmp( pszType, pClusInfoData[i].pszResource )){

            //
            // No match, continue.
            //
            continue;
        }

        //
        // Found a match, read a value out of the
        // "parameters" key.
        //

        dwStatus = ClusterRegOpenKey( hKey,
                                      gszParameters,
                                      KEY_READ,
                                      &hKeyParameters );

        if( dwStatus != NO_ERROR ){

            DBGMSG( DBG_WARN,
                    ( "bProcessResourceRegKey: ClusterRegOpenKey failed %d\n",
                      dwStatus ));
            bStatus = FALSE;
            goto LoopDone;
        }

        rqv.hKey = hKeyParameters;
        rqv.pszValue = pClusInfoData[i].pszValue;

        pszNewSingleData = (LPCTSTR)pAllocRead( &rqv,
                                                bAllocClusterRegQueryValue,
                                                TYPE_NAME_LEN_HINT,
                                                NULL );
        if( !pszNewSingleData ){

            DBGMSG( DBG_WARN,
                    ( "bProcessResource: Read "TSTR" failed %d\n",
                      pClusInfoData[i].pszResource, GetLastError() ));

            bStatus = FALSE;
            goto LoopDone;
        }

        DBGMSG( DBG_TRACE,
                ( "bProcessResource: Read successful: "TSTR"\n",
                  pszNewSingleData, GetLastError() ));

        cchLen = lstrlen( pszNewSingleData );

        //
        // We have new data in pszNewData, add it to the end.
        //
        cbNewSingleData = ( cchLen + 1 ) * sizeof( TCHAR );
        cbNewData = cbNewSingleData + pClusInfoDataOut[i].cbData;

        pszNewData = (LPTSTR)LocalAlloc( LMEM_FIXED, cbNewData );

        if( !pszNewData ){

            bStatus = FALSE;
            goto Done;
        }


        //
        // If we have something, copy it over then add a ',' character.
        //
        if( pClusInfoDataOut[i].cbData ){

            //
            // Copy it over.
            //
            CopyMemory( (PVOID)pszNewData,
                        (PVOID)pClusInfoDataOut[i].pszData,
                        pClusInfoDataOut[i].cbData );

            //
            // Convert the NULL to a comma in our new data.
            //
            pszNewData[pClusInfoDataOut[i].cbData /
                       sizeof( pClusInfoDataOut[i].pszData[0] ) - 1] = TEXT( ',' );
        }

        //
        // Copy the new string.
        //
        CopyMemory( (PBYTE)pszNewData + pClusInfoDataOut[i].cbData,
                    (PVOID)pszNewSingleData,
                    cbNewSingleData );

        DBGMSG( DBG_TRACE,
                ( "bProcessResourceRegKey: Updated ("TSTR") + ("TSTR") = ("TSTR")\n",
                  DBGSTR(pClusInfoDataOut[i].pszData), pszNewSingleData, pszNewData ));

        //
        // Now swap the newly created memory with the old one.
        // We'll free pszNewSingleData and store the old memory there.
        //
        pClusInfoDataOut[i].cbData = cbNewData;

        LocalFree( (HLOCAL)pszNewSingleData );
        pszNewSingleData = pClusInfoDataOut[i].pszData;

        pClusInfoDataOut[i].pszData = pszNewData;
        pszNewData = NULL;

LoopDone:

        if( pszNewSingleData ){
            LocalFree( (HLOCAL)pszNewSingleData );
        }
        if( pszNewData ){
            LocalFree( (HLOCAL)pszNewData );
        }

        if( hKeyParameters && ClusterRegCloseKey( hKeyParameters )){

            DBGMSG( DBG_WARN,
                    ( "bProcessResource: ClusterRegCloseKey1 failed %x\n",
                      hKey ));
        }
    }

Done:

    if( pszType ){
        LocalFree( (HLOCAL)pszType );
    }

    return bStatus;
}



BOOL
bProcessResource(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN PCLUSINFO_DATA pClusInfoData,
    OUT PCLUSINFO_DATAOUT pClusInfoDataOut
    )

/*++

Routine Description:

    Checks whether a resource in a cluster matches any of the ClusInfoData
    resources.  If it does, fill one parameter into the ClusInfoDataOut
    parameter.

Arguments:

Return Value:

    TRUE - Success: this may or may not have filled in one of the OUT
        parameters, but we didn't encounter any errors trying to read
        the resource.

    FALSE - Failure (LastError set).

--*/

{
    HKEY hKey = NULL;
    LPCTSTR pszType = NULL;
    BOOL bStatus = FALSE;

    UNREFERENCED_PARAMETER( hCluster );

    hKey = GetClusterResourceKey( hResource, KEY_READ );

    if( !hKey ){

        DBGMSG( DBG_WARN,
                ( "bProcessResource: GetClusterResourceKey failed %d\n",
                  GetLastError() ));

        goto Done;
    }

    bStatus = bProcessResourceRegKey( hKey,
                                      pClusInfoData,
                                      pClusInfoDataOut );
Done:

    if( hKey && ClusterRegCloseKey( hKey )){

        DBGMSG( DBG_WARN,
                ( "bProcessResource: ClusterRegCloseKey2 failed %x\n",
                  hKey ));
    }

    return bStatus;
}


/********************************************************************

    Enum dependency support.  This is handled by calling a callback
    with the retieved handle.

********************************************************************/

typedef BOOL (*ENUM_CALLBACK )(
    HCLUSTER hCluster,
    HRESOURCE hResource,
    HANDLE hData
    );

BOOL
bHandleEnumDependencies(
    IN     HCLUSTER hCluster,
    IN     HRESOURCE hResource,
    IN     ENUM_CALLBACK pfnEnumCallback,
    IN     HANDLE hData,
       OUT PUINT puSuccess OPTIONAL
    );


/********************************************************************

    Callbacks for EnumDependencies.

********************************************************************/


BOOL
bEnumDependencyCallbackMain(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN HANDLE hData
    );

BOOL
bEnumDependencyCallbackNetName(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN HANDLE hData
    );


/********************************************************************

    Functions.

********************************************************************/

BOOL
bHandleEnumDependencies(
    IN     HCLUSTER hCluster,
    IN     HRESOURCE hResource,
    IN     ENUM_CALLBACK pfnEnumCallback,
    IN     HANDLE hData,
       OUT PUINT puSuccess OPTIONAL
    )

/*++

Routine Description:

    Takes a resource and calls pfnEnumCallback for each of the dependent
    resources.

Arguments:

    hResource - Resource that holds dependencies to check.

    pfnEnumCallback - Callback routine.

    hData - Private data.

    puSuccess - Number of successful hits.

Return Value:

    TRUE - success, FALSE - failure.

--*/

{
    RESOURCE_ENUM ResourceEnum;
    LPCTSTR pszResource;
    HRESOURCE hResourceDependency;

    UINT uSuccess = 0;
    BOOL bStatus = TRUE;

    ResourceEnum.hResEnum = ClusterResourceOpenEnum(
                                hResource,
                                CLUSTER_RESOURCE_ENUM_DEPENDS );

    if( !ResourceEnum.hResEnum ){

        DBGMSG( DBG_WARN,
                ( "bHandleEnumDependencies: ClusterResourceOpenEnum failed %d\n",
                  GetLastError() ));

        bStatus = FALSE;

    } else {

        //
        // Walk through all the dependent resources and call
        // the callback function to process them.
        //
        for( ResourceEnum.dwIndex = 0; ; ++ResourceEnum.dwIndex ){

            pszResource = (LPCTSTR)pAllocRead(
                              (HANDLE)&ResourceEnum,
                              bAllocClusterResourceEnum,
                              RESOURCE_NAME_LEN_HINT,
                              NULL );

            if( !pszResource ){

                SPLASSERT( GetLastError() == ERROR_NO_MORE_ITEMS );
                bStatus = FALSE;
                break;
            }

            hResourceDependency = OpenClusterResource( hCluster, pszResource );

            if( !hResourceDependency ){

                DBGMSG( DBG_WARN,
                        ( "bHandleEnumDependencies: OpenClusterResource failed "TSTR" %d\n",
                           pszResource, GetLastError() ));

                bStatus = FALSE;

            } else {

                if( pfnEnumCallback( hCluster, hResourceDependency, hData )){
                    ++uSuccess;
                }

                if( !CloseClusterResource( hResourceDependency )){

                    DBGMSG( DBG_WARN,
                            ( "bProcessResource: CloseClusterResource failed "TSTR" %x %d\n",
                            pszResource, hResourceDependency, GetLastError() ));
                }
            }

            LocalFree( (HLOCAL)pszResource );
        }

        if( ClusterResourceCloseEnum( ResourceEnum.hResEnum )){

            DBGMSG( DBG_WARN,
                    ( "bProcessResource: ClusterResourceCloseEnum failed %x\n",
                      ResourceEnum.hResEnum ));
        }
    }

    if( puSuccess ){
        *puSuccess = uSuccess;
    }

    return bStatus;
}


BOOL
bEnumDependencyCallbackMain(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN HANDLE hData
    )

/*++

Routine Description:

    This routine processes the dependent resources of the main resource.
    It is called once for each.

    When we encounter net name, we'll do the same procedure except
    look for tcpip addresses.

Arguments:

    hResource - This resource is an enumerated dependency.

    hData - User supplied ata.

Return Value:

    TRUE - Found
    FALSE - Not found.

--*/

{
    BOOL bStatus;
    BOOL bReturn = FALSE;
    UINT uSuccess;

    bStatus = bProcessResource( hCluster,
                                hResource,
                                gaClusInfoDataMain,
                                (PCLUSINFO_DATAOUT)hData );

    //
    // If it's successful, it must have been "NetName," since that's
    // the only thing we're looking for.  In that case, build
    // names off of its tcpip addresses.
    //
    if( bStatus ){

        PCLUSINFO_DATAOUT pClusInfoDataOut = (PCLUSINFO_DATAOUT)hData;

        bReturn = TRUE;

        //
        // Use the proper index for tcpip addresses.
        //

        bStatus = bHandleEnumDependencies(
                      hCluster,
                      hResource,
                      bEnumDependencyCallbackNetName,
                      (HANDLE)&pClusInfoDataOut[ClusInfoAddress],
                      &uSuccess );

        if( !bStatus || !uSuccess ){

            DBGMSG( DBG_WARN,
                    ( "bEnumDependencyCallbackMain: failed to get ip addr %d %d %d\n",
                      bStatus, uSuccess, GetLastError() ));
        }
    } else {

        DBGMSG( DBG_WARN,
                ( "bEnumDependencyCallbackMain: failed to find net name %d\n",
                  GetLastError() ));
    }

    return bReturn;
}


BOOL
bEnumDependencyCallbackNetName(
    IN HCLUSTER hCluster,
    IN HRESOURCE hResource,
    IN HANDLE hData
    )

/*++

Routine Description:

    This routine processes the dependent resources of the net name
    resource.

Arguments:

    hResource - This resource is an enumerated dependency.

    hData - User supplied ata.

Return Value:

    TRUE - continue,
    FALSE - stop.

--*/

{
    BOOL bStatus;
    bStatus = bProcessResource( hCluster,
                                hResource,
                                gaClusInfoDataNetName,
                                (PCLUSINFO_DATAOUT)hData );

    return bStatus;
}


/********************************************************************

    Main entry point.

********************************************************************/

BOOL
bGetClusterNameInfo(
    IN LPCTSTR pszResource,
    OUT LPCTSTR* ppszName,
    OUT LPCTSTR* ppszAddress
    )

/*++

Routine Description:

    Retrieves information about a given resource.

Arguments:

    pszResource - Name of the resource.  Must not be NULL.

    ppszName - Receives LocalAlloc'd string of cluster name.

    ppszAddress - Receives LocalAlloc'd TCPIP address name string.

Return Value:

    TRUE - Success, *ppszName, *ppszAddress both valid and
        must be LocalFree'd when no longer needed.

    FALSE - Failed, *ppszName, *ppszAddress both NULL.
        LastError set.

--*/

{
    HCLUSTER  hCluster     = NULL;
    HRESOURCE hResource    = NULL;
    HRESENUM  hResEnum     = NULL;
    LPCTSTR   pszGroupName = NULL;
    UINT      uSuccess     = 0;
    UINT      i;

    CLUSINFO_DATAOUT aClusInfoDataOut[ClusInfoMax];

    //
    // Free the strings if there were allocated earlier so we can
    // start clean.
    //

    if( *ppszName ){
        LocalFree( (HLOCAL)*ppszName );
        *ppszName = NULL;
    }

    if( *ppszAddress ){
        LocalFree( (HLOCAL)*ppszAddress );
        *ppszAddress = NULL;
    }

    ZeroMemory( aClusInfoDataOut, sizeof( aClusInfoDataOut ));

    //
    // Open the cluster and acquire the information.
    //

    hCluster = OpenCluster( NULL );

    if( !hCluster ){

        DBGMSG( DBG_WARN,
                ( "bGetClusterNameInfo: OpenCluster failed %d\n",
                  GetLastError() ));

        goto Done;
    }

    hResource = OpenClusterResource(
                    hCluster,
                    pszResource );

    if( !hResource ){

        DBGMSG( DBG_WARN,
                ( "bGetClusterNameInfo: OpenClusterResource "TSTR" failed %d\n",
                  pszResource, GetLastError() ));

        goto Done;
    }

    //
    // Enum through the dependent resources in the group looking for either
    // type "IP Address" or "Network Name."  These shouldn't be
    // localized since they are registry keys (not values).
    //

    bHandleEnumDependencies( hCluster,
                             hResource,
                             bEnumDependencyCallbackMain,
                             (HANDLE)&aClusInfoDataOut[ClusInfoName],
                             &uSuccess );

Done:

    if( hResource && !CloseClusterResource( hResource )){

        DBGMSG( DBG_WARN,
                ( "bGetCluseterNameInfo: CloseClusterResource failed %d\n",
                  GetLastError() ));
    }

    if( hCluster && !CloseCluster( hCluster )){

        DBGMSG( DBG_WARN,
                ( "bGetClusterNameInfo: CloseCluster failed %d\n",
                  GetLastError() ));
    }

    if( !uSuccess ){

        DBGMSG( DBG_WARN,
                ( "bGetCluseterNameInfo: No NetName enumerated back! %d\n",
                  GetLastError() ));

        for( i=0; i<COUNTOF( aClusInfoDataOut ); ++i ){

            if( aClusInfoDataOut[i].pszData ){
                LocalFree( (HLOCAL)aClusInfoDataOut[i].pszData );
            }
        }
    } else {
        *ppszName = aClusInfoDataOut[ClusInfoName].pszData;
        *ppszAddress = aClusInfoDataOut[ClusInfoAddress].pszData;
    }

    DBGMSG( DBG_TRACE,
            ( "bGetClusterNameInfo: uSuccess %d "TSTR" "TSTR"\n",
              uSuccess, DBGSTR( *ppszName ), DBGSTR( *ppszAddress )));

    return uSuccess != 0;
}

/*++

Routine Description:

    Gets the GUID for a resource.

Arguments:

    hResource - handle obtained via OpenClusterResource

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/
DWORD
GetIDFromName(
    IN     HRESOURCE  hResource,
       OUT LPWSTR    *ppszID
    )
{
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (hResource && ppszID) 
    {
        //
        // Set the out parameter to something known
        //
        *ppszID = NULL;
    
        //
        // Should be able to hold the string representation of a guid
        //
        DWORD cbBuf = kGuidStringByteSize;
        
        if (*ppszID = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf)) 
        {
            if ((dwError = ClusterResourceControl(hResource, 
                                                  NULL,
                                                  CLUSCTL_RESOURCE_GET_ID,
                                                  NULL,                                               
                                                  0,
                                                  *ppszID,
                                                  cbBuf,
                                                  &cbBuf)) == ERROR_MORE_DATA) 
            {
                LocalFree(*ppszID);

                if (*ppszID = (LPWSTR)LocalAlloc(LMEM_FIXED, cbBuf)) 
                {
                    dwError = ClusterResourceControl(hResource, 
                                                     NULL,
                                                     CLUSCTL_RESOURCE_GET_ID,
                                                     NULL,                                               
                                                     0,
                                                     *ppszID,
                                                     cbBuf,
                                                     &cbBuf);
                }
                else
                {
                    dwError = GetLastError();
                }
            }

            //
            // Free the memory if getting the ID failed
            //
            if (dwError != ERROR_SUCCESS && *ppszID) 
            {
                LocalFree(*ppszID);
                *ppszID = NULL;
            }
        }
        else
        {
            dwError = GetLastError();
        }
    }
    
    DBGMSG(DBG_TRACE, ("GetIDFromName returns %u\n", dwError));

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\spooler\splsvc\util.cxx ===
/*++

Copyright (C) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    util.cxx
    
Abstract:

    Contains several utility functions.
    
Author:

    Albert Ting (AlbertT)  25-Sept-1996   pAllocRead()
    Felix Maxa  (AMaxa)    11-Sept-2001   Moved pAllocRead() from alloc.*xx to util.*xx and
                                          added the rest of the functions.
              
--*/

#include "precomp.hxx"
#pragma hdrstop
#include "clusinfo.hxx"

PCWSTR g_pszSpoolerResource  = L"Print Spooler";

/*++

Routine Name:

    pAllocRead

Routine Description:

    Generic realloc code for any api that can fail with ERROR_INSUFFICIENT_BUFFER.

Arguments:

    
Return Value:

    
Last Error:
    
--*/
PBYTE
pAllocRead(
    HANDLE     hUserData,
    ALLOC_FUNC AllocFunc,
    DWORD      dwLenHint,
    PDWORD     pdwLen OPTIONAL
    )
{
    ALLOC_DATA AllocData;
    PBYTE pBufferOut = NULL;
    DWORD dwLastError;
    DWORD cbActual;

    if( pdwLen ){
        *pdwLen = 0;
    }

    if( !dwLenHint ){

        DBGMSG( DBG_ERROR, ( "ReallocRead: dwLenHint = 0\n" ));

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    AllocData.pBuffer = NULL;
    AllocData.cbBuffer = dwLenHint;

    for( ; ; ){

        cbActual = AllocData.cbBuffer;
        AllocData.pBuffer = (PBYTE)LocalAlloc( LMEM_FIXED, cbActual );

        if( !AllocData.pBuffer ){
            break;
        }

        if( !AllocFunc( hUserData, &AllocData )){

            //
            // Call failed.
            //
            dwLastError = GetLastError();
            LocalFree( (HLOCAL)AllocData.pBuffer );

            if( dwLastError != ERROR_INSUFFICIENT_BUFFER &&
                dwLastError != ERROR_MORE_DATA ){

                break;
            }
        } else {

            pBufferOut = AllocData.pBuffer;

            if( pdwLen ){
                *pdwLen = cbActual;
            }
            break;
        }
    }

    return pBufferOut;
}

/*++

Name:

    GetSubkeyBuffer

Description:

    Allocates a buffer that can accomodate the larges subkey under hKey.
    This function is adapted from the library in CSR
    
Arguments:

    hKey     - registry key
    ppBuffer - pointer to where to store pointer to WCHAR
    pnSize   - pointer to where to store the size in WCHARs of the ppBuffer 
    
Return Value:

    ERROR_SUCCESS - a buffer was allocated and needs to be freed by the caller
    other win32 error - an error occurred
    
--*/
LONG
GetSubkeyBuffer(
    IN HKEY     hKey,
    IN PWSTR   *ppBuffer,
    IN DWORD   *pnSize
    )
{
    LONG Status = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, pnSize, NULL, NULL, NULL, NULL, NULL, NULL);

    if (Status == ERROR_SUCCESS)
    {
        *pnSize = *pnSize + 1;
        *ppBuffer = new WCHAR[*pnSize];

        if (!*ppBuffer)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return Status;
}

/*++

Name:

    DeleteKeyRecursive

Description:

    Deletes a regsitry key and all its subkeys. This function is copied from the library in CSR.
    
Arguments:

    kHey      - registry key
    pszSubkey - subkey to be deleted
    
Return Value:

    ERROR_SUCCESS - the subkey was deleted
    other Win32 error - an error occurred
    
--*/
LONG
DeleteKeyRecursive(
    IN HKEY    hKey,
    IN PCWSTR  pszSubkey
    )
{
    HKEY hSubkey    = NULL;
    LONG Status     = ERROR_SUCCESS;

    Status = RegOpenKeyEx(hKey, pszSubkey, 0, KEY_ALL_ACCESS, &hSubkey);

    while (Status == ERROR_SUCCESS)
    {
        PWSTR  pBuffer     = NULL;
        DWORD  nBufferSize = 0;

        Status = GetSubkeyBuffer(hSubkey, &pBuffer, &nBufferSize);

        if (Status == ERROR_SUCCESS)
        {
            Status = RegEnumKeyEx(hSubkey, 0, pBuffer, &nBufferSize, 0, 0, 0, 0);

            if (Status == ERROR_SUCCESS)
            {
                Status = DeleteKeyRecursive(hSubkey, pBuffer);
            }

            delete [] pBuffer;
        }
    }

    if (hSubkey)
    {
        RegCloseKey(hSubkey);
    }

    if (Status == ERROR_NO_MORE_ITEMS)
    {
        Status = ERROR_SUCCESS;
    }

    if (Status == ERROR_SUCCESS)
    {                                                    
        Status = RegDeleteKey (hKey, pszSubkey);
    }

    return Status;
}

/*++

Description:

    This routine concatenates a set of null terminated strings
    into the provided buffer.  The last argument must be a NULL
    to signify the end of the argument list.
    This function is copied from the spllib in printscan

Arguments:

    pszBuffer  - pointer buffer where to place the concatenated
                 string.
    cchBuffer  - character count of the provided buffer including
                 the null terminator.
    ...        - variable number of string to concatenate.

Returns:

    ERROR_SUCCESS if new concatenated string is returned,
    or ERROR_XXX if an error occurred.

Notes:

    The caller must pass valid strings as arguments to this routine,
    if an integer or other parameter is passed the routine will either
    crash or fail abnormally.  Since this is an internal routine
    we are not in try except block for performance reasons.

--*/
DWORD
WINAPIV
StrNCatBuff(
    IN  PWSTR pszBuffer,
    IN  UINT  cchBuffer,
    ...
    )
{
    DWORD   dwRetval    = ERROR_INVALID_PARAMETER;
    PCWSTR  pszTemp     = NULL;
    PWSTR   pszDest     = NULL;
    va_list pArgs;

    //
    // Validate the pointer where to return the buffer.
    //
    if (pszBuffer && cchBuffer)
    {
        //
        // Assume success.
        //
        dwRetval = ERROR_SUCCESS;

        //
        // Get pointer to argument frame.
        //
        va_start(pArgs, cchBuffer);

        //
        // Get temp destination pointer.
        //
        pszDest = pszBuffer;

        //
        // Insure we have space for the null terminator.
        //
        cchBuffer--;

        //
        // Collect all the arguments.
        //
        for ( ; ; )
        {
            //
            // Get pointer to the next argument.
            //
            pszTemp = va_arg(pArgs, PCWSTR);

            if (!pszTemp)
            {
                break;
            }

            //
            // Copy the data into the destination buffer.
            //
            for ( ; cchBuffer; cchBuffer-- )
            {
                if (!(*pszDest = *pszTemp))
                {
                    break;
                }

                pszDest++, pszTemp++;
            }

            //
            // If were unable to write all the strings to the buffer,
            // set the error code and nuke the incomplete copied strings.
            //
            if (!cchBuffer && pszTemp && *pszTemp)
            {
                dwRetval = ERROR_INVALID_PARAMETER;
                *pszBuffer = L'\0';
                break;
            }
        }

        //
        // Terminate the buffer always.
        //
        *pszDest = L'\0';

        va_end(pArgs);
    }

    //
    // Set the last error in case the caller forgets to.
    //
    if (dwRetval != ERROR_SUCCESS)
    {
        SetLastError(dwRetval);
    }

    return dwRetval;

}

TStringArray::
TStringArray(
    VOID
    ) : m_Count(0),
        m_pArray(NULL)
{
}

TStringArray::
~TStringArray(
    VOID
    )
{
    for (DWORD i = 0; i < m_Count; i++)
    {
        delete [] m_pArray[i];
    }

    delete [] m_pArray;
}

/*++

Routine Name

    TStringArray::Count

Routine Description:

    Returns the number of strings in the array
        
Arguments:

    None
    
Return Value:

    DWORD - Numnber of string in the array

--*/
DWORD
TStringArray::
Count(
    VOID
    ) const
{
    return m_Count;
}

/*++

Routine Name

    TStringArray::StringAt

Routine Description:

    Returns the string at the specified position. Position must be
    between 0 and Count(). Otherwise the function fails and returns NULL.
        
Arguments:

    Position - index of the string to be returned
    
Return Value:

    NULL    - if position is out of bounds
    PCWSTR  - valid string pointer

--*/
PCWSTR
TStringArray::
StringAt(
    IN DWORD Position
    ) const
{
    PCWSTR psz = NULL;

    if (Position < m_Count)
    {
        psz = m_pArray[Position];
    }

    return psz;
}

/*++

Routine Name

    TStringArray::AddString

Routine Description:

    Adds a string to the array. The function simply adds the string as the last
    element in the array. The function creates a copy of the string.
        
Arguments:

    pszString - string to be added. Cannot be NULL or empty
    
Return Value:

    ERROR_SUCCESS - the string was added in the array
    Win32 error   - an error occurred and the string was not added

--*/
DWORD
TStringArray::
AddString(
    IN PCWSTR pszString
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (pszString && *pszString)
    {
        PWSTR *pNewArray       = new PWSTR[m_Count + 1];

        if (pNewArray)
        {
            pNewArray[m_Count] = new WCHAR[1 + wcslen(pszString)];

            if (pNewArray[m_Count])
            {
                for (DWORD i = 0; i < m_Count; i++)
                {
                    pNewArray[i] = m_pArray[i];
                }
                
                StringCchCopyW(pNewArray[m_Count],
                               (1 + wcslen(pszString)),
                               pszString);

                m_Count++;
                
                delete [] m_pArray;

                m_pArray = pNewArray;

                Error = ERROR_SUCCESS;
            }
            else
            {
                Error = ERROR_NOT_ENOUGH_MEMORY;

                delete [] pNewArray;
            }
        }
        else
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return Error;
}

/*++

Routine Name

    TStringArray::Exclude

Routine Description:

    Excludes all occurrences of a string from the array. 
        
Arguments:

    pszString - string to be excluded. Cannot be NULL or empty
    
Return Value:

    ERROR_SUCCESS - the string was excluded from the array
    Win32 error   - an error occurred and the string was not excluded

--*/
DWORD
TStringArray::
Exclude(
    IN PCWSTR pszString
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (pszString && *pszString)
    {
        Error = ERROR_SUCCESS;

        for (DWORD i = 0; i < m_Count;)
        {
            if (!ClRtlStrICmp(pszString, m_pArray[i]))
            {
                delete [] m_pArray[i];

                for (DWORD j = i; j < m_Count - 1; j++)
                {
                    m_pArray[j] = m_pArray[j+1];                    
                }

                m_Count--;                
            }
            else
            {
                i++;
            }
        }        
    }

    return Error;
}

/*++

Name:

    GetSpoolerResourceGUID

Description:

    This function checks if pszResource is the name of a cluster spooler. If it is,
    then it returns the GUID associated with the cluster spooler
    
Arguments:

    hCluster    - handle retrieved via OpenCluster
    pszResource - resource name
    ppGUID      - pointer to where to receive sequence of bytes representing a GUID 
                  *ppGUID is NULL terminated and can be used as a string. Must be
                  freed by the caller using delete []

Return Value:

    S_OK - pszResource is not a cluster spooler or
           pszResource is a cluster spooler and then **ppGUID is a valid pointer
    any other HRESULT - failure

--*/
HRESULT
GetSpoolerResourceGUID(
    IN  HCLUSTER    hCluster, 
    IN  PCWSTR      pszResource,
    OUT BYTE      **ppGUID
    )
{
    HRESOURCE hResource;
    HRESULT   hRetval;
    
    hRetval = hCluster && pszResource && ppGUID ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval)) 
    {
        *ppGUID = NULL;

        hResource = OpenClusterResource(hCluster, pszResource);

        hRetval = hResource ? S_OK : GetLastErrorAsHResult();
    }

    if (SUCCEEDED(hRetval)) 
    {
        BYTE *pResType = NULL;
        
        hRetval = ClusResControl(hResource, CLUSCTL_RESOURCE_GET_RESOURCE_TYPE, &pResType, NULL);

        if (SUCCEEDED(hRetval))
        {
            //
            // Check resource type. We are interested only in IP Address resources.
            //
            if (!ClRtlStrICmp(reinterpret_cast<PWSTR>(pResType), g_pszSpoolerResource)) 
            {
                PWSTR  pszIPAddress = NULL;
                DWORD   cbResProp    = 0;
                
                //
                // Get all the private properties of the IP Address resource.
                //
                hRetval = ClusResControl(hResource, 
                                         CLUSCTL_RESOURCE_GET_ID,
                                         ppGUID,
                                         &cbResProp);                               
            }

            delete [] pResType;
        }
                
        CloseClusterResource(hResource);                                                  
    }

    return hRetval;
}

/*++

Name:

    ClusResControl

Description:

    Helper function. Encapsulates a call to ClusterResourceControl. The function
    allocates a buffer. Upon success, the caller nedds to free the buffer using
    delete [].
    
Arguments:

    hResource       - handle to cluster resource
    ControlCode     - control code for ClusterResourceControl
    ppBuffer        - pointer to address where to store byte array
    pcBytesReturned - number of bytes returned by ClusterResourceControl (not
                      necessarily the number of byes allocated for *ppBuffer)

Return Value:

    S_OK - success. ppBuffer can be used and must be freed using delete []
    any other HRESULT - failure

--*/
HRESULT
ClusResControl(
    IN  HRESOURCE      hResource,
    IN  DWORD          ControlCode,
    OUT BYTE         **ppBuffer,
    IN  DWORD         *pcBytesReturned OPTIONAL
    )
{
    HRESULT hRetval;

    hRetval = ppBuffer ? S_OK : E_INVALIDARG;

    if (SUCCEEDED(hRetval))
    {
        DWORD Error;
        DWORD cbBuffer = kBufferAllocHint;
        DWORD cbNeeded = 0;

        *ppBuffer = new BYTE[cbBuffer];

        Error = *ppBuffer ? ERROR_SUCCESS : ERROR_NOT_ENOUGH_MEMORY;

        if (Error == ERROR_SUCCESS)
        {
            Error = ClusterResourceControl(hResource,
                                           NULL, 
                                           ControlCode,
                                           NULL,
                                           0,
                                           *ppBuffer,
                                           cbBuffer,
                                           &cbNeeded);

            if (Error == ERROR_MORE_DATA) 
            {
                cbBuffer = cbNeeded;

                delete [] *ppBuffer;

                *ppBuffer = new BYTE[cbBuffer];

                Error = *ppBuffer ? ERROR_SUCCESS : ERROR_NOT_ENOUGH_MEMORY;
                
                if (Error == ERROR_SUCCESS) 
                {
                    Error = ClusterResourceControl(hResource,
                                                   NULL, 
                                                   ControlCode,
                                                   NULL,
                                                   0,
                                                   *ppBuffer,
                                                   cbBuffer,
                                                   &cbNeeded);
                }
            }

            if (Error != ERROR_SUCCESS)
            {
                delete [] *ppBuffer;

                *ppBuffer = NULL;
                
                cbNeeded = 0;
            }

            if (pcBytesReturned)
            {
                *pcBytesReturned = cbNeeded;
            }
        }

        hRetval = HRESULT_FROM_WIN32(Error);        
    }

    return hRetval;
}

/*++

Routine Name:

    GetCurrentNodeName

Routine Description:

    Allocates a buffer and fills it in with the name of the current node.

Arguments:

    ppOut - pointer to where to store a PWSTR. Must be freed with delete []
    
Return Value:

    ERROR_SUCCESS - a string was allocated, must be freed with delete []
    other Win32 error - an error occurred
    
--*/
DWORD
GetCurrentNodeName(
    OUT PWSTR *ppOut
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (ppOut)
    {
        DWORD cch = 0;

        *ppOut = NULL;

        if (!GetComputerName(NULL, &cch) && GetLastError() == ERROR_BUFFER_OVERFLOW)
        {
            *ppOut = new WCHAR[cch];

            if (*ppOut)
            {
                if (!GetComputerName(*ppOut, &cch))
                {
                    delete [] *ppOut;

                    *ppOut = NULL;

                    Error = GetLastError();
                }
                else
                {
                    Error = ERROR_SUCCESS;
                }
            }
            else
            {
                Error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            Error = ERROR_INVALID_FUNCTION;
        }
    }

    return Error;
}

/*++

Routine Name

    GetLastErrorAsHResult

Routine Description:

    Returns the last error as an HRESULT
        
Arguments:

    NONE
    
Return Value:

    HRESULT

--*/
HRESULT
GetLastErrorAsHResult(
    VOID
    )
{
    DWORD d = GetLastError();

    return HRESULT_FROM_WIN32(d);
}

/*++

Routine Name

    IsGUIDString

Routine Description:

    Checks if a string is a valid GUID of the following format
    361a22fd-9cb0-4d22-8a68-6c6fb3f22363
        
Arguments:

    pszString - string
    
Return Value:

    TRUE  - pszString represents a guid
    FALSE - otherwise

--*/
BOOL
IsGUIDString(
    IN PCWSTR pszString
    )
{
          BOOL  bRet    = FALSE;
    CONST DWORD cchGUID = 36; // number of characters in a GUID of the format 361a22fd-9cb0-4d22-8a68-6c6fb3f22363

    if (pszString && *pszString && wcslen(pszString) == cchGUID)
    {
        bRet = TRUE;

        for (DWORD i = 0; bRet && i < cchGUID; i++)
        {
            if (i == 8 || i == 13 || i == 18 || i == 23)
            {
                bRet = pszString[i] == L'-';
            }
            else
            {
                bRet =  pszString[i] >= L'0' && pszString[i] <= L'9' ||
                        pszString[i] >= L'a' && pszString[i] <= L'f' ||
                        pszString[i] >= L'A' && pszString[i] <= L'F';

            }
        }        
    }

    return bRet;
}

/*++

Routine Name

    DelOrMoveFile

Routine Description:

    Deletes a file or a directory. If the file is read only, the function resets the file
    attrbiutes so the file can be removed. If the file is in use, then it is marked for
    deletion on reboot.
        
Arguments:

    pszFile - directory or file name
    
Return Value:

    ERROR_SUCCESS - the file/directory was deleted or marked for deletion
    other Win32 code - an error occurred. 

--*/
DWORD
DelOrMoveFile(
    IN PCWSTR pszFile
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (pszFile)
    {
        Error = ERROR_SUCCESS;

        DWORD Attributes = GetFileAttributes(pszFile);

        if (Attributes == 0xFFFFFFFF)
        {
            Error = GetLastError();
        }
        else if (Attributes & FILE_ATTRIBUTE_READONLY)
        {
            if (!SetFileAttributes(pszFile, Attributes & ~FILE_ATTRIBUTE_READONLY))
            {
                Error = GetLastError();
            }
        }

        if (Error == ERROR_SUCCESS)
        {
            if (Attributes & FILE_ATTRIBUTE_DIRECTORY ? !RemoveDirectory(pszFile) : !DeleteFile(pszFile))
            {
                if (!MoveFileEx(pszFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
                {
                    Error = GetLastError();
                }
            }
        }
    }

    return Error;
}

/*++

Routine Name

    DelDirRecursively

Routine Description:

    Deletes recursively all the files and subdirectories of a given directory. It also
    deletes the directory itself. If any files are in use, the they are marked for
    deletion on reboot.
    
Arguments:

    pszDir - directory name. cannot be NULL
    
Return Value:

    ERROR_SUCCESS - the files and subdirectories were deleted or marked for deletion
    other Win32 code - an error occurred. 

--*/
DWORD
DelDirRecursively(
    IN PCWSTR pszDir
    )
{
    DWORD   Error = ERROR_INVALID_PARAMETER;
    WCHAR   Scratch[MAX_PATH];

    if (pszDir)
    {
        if ((Error = StrNCatBuff(Scratch, 
                                 MAX_PATH, 
                                 pszDir, 
                                 L"\\*", 
                                 NULL)) == ERROR_SUCCESS)
        {
            HANDLE          hFindFile;
            WIN32_FIND_DATA FindData;
            
            //
            // Enumerate all the files in the directory
            //
            hFindFile = FindFirstFile(Scratch, &FindData);
    
            if (hFindFile != INVALID_HANDLE_VALUE) 
            {
                do
                {
                    if ((Error = StrNCatBuff(Scratch,
                                             MAX_PATH, 
                                             pszDir, 
                                             L"\\", 
                                             FindData.cFileName,
                                             NULL)) == ERROR_SUCCESS)
                    {
                        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                        {
                            //
                            // skip the special . and .. entries
                            //
                            if (wcscmp(FindData.cFileName, L".") && wcscmp(FindData.cFileName, L".."))
                            {
                                Error = DelDirRecursively(Scratch);
                            }
                        }
                        else
                        {
                            Error = DelOrMoveFile(Scratch);        
                        }
                    }
                
                } while (Error == ERROR_SUCCESS && FindNextFile(hFindFile, &FindData));
    
                FindClose(hFindFile);

                //
                // Delete the directory itself
                //
                if (Error == ERROR_SUCCESS)
                {
                    Error = DelOrMoveFile(pszDir);
                }
            }
            else 
            {
                Error = GetLastError();
            }
        } 
    }
    
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\spooler\splsvc\spooler.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved.

Module Name:

    spooler.c

Abstract:

    Handle spooler interaction via RPC.

    Public functions from this module:

        SpoolerOnline
        SpoolerOffline
        SpoolerStart
        SpoolerStop
        SpoolerIsAlive
        SpoolerLooksAlive

    There is a little interface bleed here--this module is aware
    of the cluster SetResourceStatus callback.

Author:

    Albert Ting (AlbertT)  23-Sept-96

Revision History:
    Khaled Sedky (KhaledS) 1998-2001

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "splsvc.hxx"
#include "clusinfo.hxx"
#include "spooler.hxx"

PCWSTR gpszPipePolicyMsg1 = L"Cannot bring print spooler resource online because the \"Allow Print Spooler to accept client connections\" "
                            L"policy is set to \"disabled\". The policy is in effect per node so must be set to \"enabled\" or \"not configured\" "
                            L"for each node that will host a spooler resource.\n";

PCWSTR gpszPipePolicyMsg2 = L"To determine the settings of this policy, look under "
                            L"Computer Configuration/Administrative Template/Printers in rsop.msc. Note that you must stop and restart the print "
                            L"spooler service for any policy change to take effect.\n";


#define TERMINATETHREADONCHECK           \
if ( ClusWorkerCheckTerminate( Worker )) \
{                                        \
   goto Done;                            \
}


/********************************************************************

    Conditional compile defines:

    USE_ISALIVE_THREAD

        Causes the resource DLL to wait on a thread each time the
        IsAlive all is made.  This thread wait for ISALIVE_WAIT_TIME
        to see if the RPC call to the spooler successfully completes.
        If it does not, then we assume that the spooler is deadlocked.

        This is off because it kills the spooler if it's slow or
        being debugged.  There are no scenarios where we should
        be deadlocked (or hold the critical section while doing a
        slow operation like hitting the net).  During stress, however,
        we may appear deadlocked.

    USE_OFFLINE_HACK

        Causes an Offline call to terminate and restart the spooler.
        This will be turned on until we have clean shutdown code.

    USE_STUBS

        Causes us to use stubbed out winspool.drv calls.  Usefule if
        the new winspool.drv isn't available and you want to compile
        a DLL which simulates talking to the spooler.

********************************************************************/

//#define USE_ISALIVE_THREAD
//#define USE_OFFLINE_HACK
//#define USE_STUBS

#define POLL_SLEEP_TIME 500         // Service control poll time.
#define STATUS_SLEEP_TIME 1500
#define ISALIVE_WAIT_TIME 2000      // Time before spooler is deadlocked.

LPCTSTR gszSpooler = TEXT( "Spooler" );
SC_HANDLE ghSpoolerService;
SC_HANDLE ghSC;


/********************************************************************

    Stubs

********************************************************************/

#ifdef USE_STUBS

BOOL
ClusterSplOpen(
    LPCTSTR pszServer,
    LPCTSTR pszResource,
    PHANDLE phSpooler,
    LPCTSTR pszName,
    LPCTSTR pszAddress
    )
{
    UNREFERENCED_PARAMETER( pszServer );
    UNREFERENCED_PARAMETER( pszResource );
    UNREFERENCED_PARAMETER( pszName );
    UNREFERENCED_PARAMETER( pszAddress );
    *phSpooler = (HANDLE)31;
    Sleep( 3200 );
    return TRUE;
}

BOOL
ClusterSplClose(
    HANDLE hSpooler
    )
{
    UNREFERENCED_PARAMETER( hSpooler );
    SPLASSERT( hSpooler==(HANDLE)31 );
    Sleep( 6000 );
    return TRUE;
}

BOOL
ClusterSplIsAlive(
    HANDLE hSpooler
    )
{
    UNREFERENCED_PARAMETER( hSpooler );
    Sleep( 500 );
    return TRUE;
}

#endif

/********************************************************************

    Utility functions

********************************************************************/

BOOL
QuerySpoolerState(
    OUT PDWORD pdwState
    )

/*++

Routine Description:

    Checks the current state of the spooler service.

Arguments:

    pdwState - Receives the state of the spooler.

Return Value:

    TRUE - success
    FALSE - failure.  *pdwState set to SERVICE_STOPPED


--*/

{
    SERVICE_STATUS ServiceStatus;

    SPLASSERT( ghSpoolerService );

    if( !QueryServiceStatus( ghSpoolerService,
                             &ServiceStatus)) {

        DBGMSG( DBG_WARN,
                ( "SpoolerStatus: QueryServiceStatus failed %d\n",
                  GetLastError() ));

        *pdwState = SERVICE_STOPPED;
        return FALSE;
    }

    *pdwState = ServiceStatus.dwCurrentState;

    return TRUE;
}

DWORD
WINAPI
SpoolerStatusReportThread(
    PCLUS_WORKER Worker,
    PVOID        pStatusThreadInfo
    )
{
    HANDLE hStatusEvent = ((STATUSTHREAD_INFO *)pStatusThreadInfo)->hStatusEvent;
    PSPOOLER_INFORMATION pSpoolerInfo = ((STATUSTHREAD_INFO *)pStatusThreadInfo)->pSpoolerInfo;
    PRESOURCE_STATUS pResourceStatus  = ((STATUSTHREAD_INFO *)pStatusThreadInfo)->pResourceStatus;

    while(WaitForSingleObject(hStatusEvent,STATUS_SLEEP_TIME) == WAIT_TIMEOUT)
    {
         pResourceStatus->CheckPoint++;
         (pSpoolerInfo->pfnSetResourceStatus)(pSpoolerInfo->ResourceHandle,
                                              pResourceStatus);
    }
    return (0);
}



/********************************************************************

    Worker threads for SpoolerOnline/Offline.

********************************************************************/

#ifdef USE_ISALIVE_THREAD

DWORD
WINAPI
SpoolerIsAliveThread(
    PVOID pSpoolerInfo_
    )

/*++

Routine Description:

    Async thread to online the resource instance.

    Assumes vAddRef has been called already; we will call vDecRef
    when we are done.

Arguments:

Return Value:

    ERRROR_SUCCESS - Spooler still alive.

    dwError - Spooler dead.

--*/

{
    PSPOOLER_INFORMATION pSpoolerInfo = (PSPOOLER_INFORMATION)pSpoolerInfo_;
    HANDLE hSpooler = pSpoolerInfo->hSpooler;
    BOOL bIsAlive;

    //
    // We've stored all the information we need from pSpoolerInfo;
    // decrement the refcount.
    //
    vDecRef( pSpoolerInfo );

    //
    // RPC to spooler.
    //
    SPLASSERT( hSpooler );

    bIsAlive = ClusterSplIsAlive( hSpooler );

    DBGMSG( DBG_TRACE,
            ( "SpoolerIsAliveThread: return status: h=%x s=%x,%d\n",
              hSpooler, bIsAlive, GetLastError() ));

    if( bIsAlive ){
        return ERROR_SUCCESS;
    }

    //
    // Spooler is dead--return some error code.
    //
    return ERROR_INVALID_PARAMETER;
}

#endif

DWORD
SpoolerOnlineThread(
    IN PCLUS_WORKER Worker,
    IN PVOID pSpoolerInfo_
    )
/*++

Routine Description:

    Async thread to online the resource instance.

    Assumes vAddRef has been called already; we will call vDecRef
    when we are done.

Arguments:

Return Value:

--*/

{
    DWORD  dwState;
    DWORD  dwStatus;
    BOOL   bStatus = FALSE;
    HANDLE hStatusEvent   = NULL;

    RESOURCE_STATUS    ResourceStatus;
    STATUSTHREAD_INFO  StatusThreadInfo;

    if(pSpoolerInfo_)
    {
        PSPOOLER_INFORMATION pSpoolerInfo = (PSPOOLER_INFORMATION)pSpoolerInfo_;

        ResUtilInitializeResourceStatus( &ResourceStatus );

        ResourceStatus.ResourceState = ClusterResourceOnlinePending;
        ResourceStatus.CheckPoint = 1;
        (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                              &ResourceStatus );

        TERMINATETHREADONCHECK

        //
        // Get needed information about net name and tcpip address.
        //
        if( !bGetClusterNameInfo( pSpoolerInfo->pszResource,
                                  &pSpoolerInfo->pszName,
                                  &pSpoolerInfo->pszAddress )){

            (pSpoolerInfo->pfnLogEvent)(
                pSpoolerInfo->ResourceHandle,
                LOG_ERROR,
                L"Unable to retrieve Name and TcpIp address.\n" );

            DBGMSG( DBG_ERROR, ( "SplSvcOpen: Couldn't retrieve name/tcpip addr\n" ));
            goto Done;
        }

        TERMINATETHREADONCHECK


        //
        // Ensure the spooler is started.
        //
        bStatus = SpoolerStart( pSpoolerInfo );

        if( !bStatus ){

            DBGMSG( DBG_WARN, ( "SpoolerOnlineThread: SpoolerStart failed\n" ));
            goto Done;
        }

        while (TRUE)  {

            if( !QuerySpoolerState( &dwState )){

                dwStatus = GetLastError();

                (pSpoolerInfo->pfnLogEvent)(
                    pSpoolerInfo->ResourceHandle,
                    LOG_ERROR,
                    L"Query Service Status failed %1!u!.\n",
                    dwStatus);

                goto Done;
            }



            if( dwState != SERVICE_START_PENDING ){
                break;
            }
            else
            {
                ResourceStatus.CheckPoint ++;
                (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                                      &ResourceStatus );
                TERMINATETHREADONCHECK
            }

            Sleep( POLL_SLEEP_TIME );
        }

        if( dwState != SERVICE_RUNNING) {

            (pSpoolerInfo->pfnLogEvent)(
                pSpoolerInfo->ResourceHandle,
                LOG_ERROR,
                L"Failed to start service. Error: %1!u!.\n",
                ERROR_SERVICE_NEVER_STARTED);

            dwStatus = ERROR_SERVICE_NEVER_STARTED;
            goto Done;
        }

        //
        // Since we have to report the status of being online pending
        // to the cluster everywhile in order not to be considered failing
        // and because ClusterSplOpen takes a while and it is a synchronous
        // call , we hae to create this Status Thread which would keep
        // reporting the status to the cluster in the back ground.
        //
        hStatusEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(hStatusEvent)
        {

            StatusThreadInfo.pResourceStatus = &ResourceStatus;
            StatusThreadInfo.hStatusEvent    = hStatusEvent;
            StatusThreadInfo.pSpoolerInfo    = pSpoolerInfo;

            dwStatus = ClusWorkerCreate(&pSpoolerInfo->OnLineStatusThread,
                                        SpoolerStatusReportThread,
                                        (PVOID)&StatusThreadInfo);

            if( dwStatus != ERROR_SUCCESS )
            {
                //
                // In this case we will unfortunatly fall out of the Reporting thread and
                // behave the same as previously , which might cause the resource to fail
                // since it is not reporing the status properly (not likely to happen)
                //
                DBGMSG( DBG_WARN,
                        ( "SpoolerOnlineThread : ClusWorkerCreate(SpoolerStatusReportThread) failed %d\n", dwStatus ));
            }
        }
        else
        {
            //
            // In this case we will unfortunatly fall out of the Reporting thread and
            // behave the same as previously , which might cause the resource to fail
            // since it is not reporing the status properly (not likely to happen)
            //
            DBGMSG( DBG_WARN,
                    ( "SpoolerOnlineThread: Create StatusEvent failed %d\n", GetLastError() ));
        }

        //
        // RPC to spooler.
        //
        bStatus = ClusterSplOpen( NULL,
                                  pSpoolerInfo->pszResource,
                                  &pSpoolerInfo->hSpooler,
                                  pSpoolerInfo->pszName,
                                  pSpoolerInfo->pszAddress );

        if (!bStatus)
        {
            DWORD LastError = GetLastError();

            if (LastError == ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED)
            {
                (pSpoolerInfo->pfnLogEvent)(pSpoolerInfo->ResourceHandle,
                                            LOG_ERROR,
                                            gpszPipePolicyMsg1);

                (pSpoolerInfo->pfnLogEvent)(pSpoolerInfo->ResourceHandle,
                                            LOG_ERROR,
                                            gpszPipePolicyMsg2);
            }
            else
            {
                (pSpoolerInfo->pfnLogEvent)(pSpoolerInfo->ResourceHandle,
                                            LOG_ERROR,
                                            L"Cannot create print spooler virtual server. Win32 error code %1!u!.\n",
                                            LastError);
            }
        }

        if(hStatusEvent && pSpoolerInfo->OnLineStatusThread.hThread)
        {
            SetEvent(hStatusEvent);
        }

        DBGMSG( DBG_TRACE,
                ( "SpoolerOnlineThread: "TSTR" "TSTR" "TSTR" h=%x s=%x,d\n",
                  DBGSTR( pSpoolerInfo->pszResource ),
                  DBGSTR( pSpoolerInfo->pszName ),
                  DBGSTR( pSpoolerInfo->pszAddress ),
                  pSpoolerInfo->hSpooler,
                  bStatus,
                  GetLastError() ));

    Done:

        //
        // If we are terminating, then we should not set any state
        // and avoid calling SetResourceStatus since clustering doesn't
        // think we are pending online anymore.
        //
        if( pSpoolerInfo->eState != kTerminate ){

            if( bStatus ){

                //
                // Spooler successfully onlined.
                //
                pSpoolerInfo->eState = kOnline;
                ResourceStatus.ResourceState = ClusterResourceOnline;
            }
            else
            {
               ResourceStatus.ResourceState = ClusterResourceFailed;
            }

            ResourceStatus.CheckPoint++;
            (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                                  &ResourceStatus );
        }

        vDecRef( pSpoolerInfo );
        if(hStatusEvent)
        {
            CloseHandle(hStatusEvent);
        }

        ClusWorkerTerminate(&(pSpoolerInfo->OnLineStatusThread));
    }

    return 0;
}

DWORD
SpoolerClose(
    PSPOOLER_INFORMATION pSpoolerInfo,
    EShutDownMethod ShutDownMethod
)
{
    CLUSTER_RESOURCE_STATE ClusterResourceState;
    STATUSTHREAD_INFO      StatusThreadInfo;
    RESOURCE_STATUS        ResourceStatus;
    BOOL                   bStatus      = TRUE;
    HANDLE                 hStatusEvent = NULL;
    HANDLE                 hSpooler     = NULL;
    DWORD                  dwStatus     = ERROR_SUCCESS;

    if(pSpoolerInfo)
    {
        ResUtilInitializeResourceStatus( &ResourceStatus );

        ResourceStatus.CheckPoint = 1;
        ResourceStatus.ResourceState = ClusterResourceOfflinePending;
        (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                              &ResourceStatus );

        vEnterSem();
        {
            ClusterResourceState = pSpoolerInfo->ClusterResourceState;

            if( pSpoolerInfo->hSpooler )
            {
                hSpooler = pSpoolerInfo->hSpooler;
                pSpoolerInfo->hSpooler = NULL;
            }
        }
        vLeaveSem();

        if( hSpooler )
        {
             //
             // Since we have to report the status of being offline pending
             // to the cluster everywhile in order not to be considered failing
             // and because ClusterSplClose takes a while and it is a synchronous
             // call , we have to create this Status Thread which would keep
             // reporting the status to the cluster in the back ground.
             //
             hStatusEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
             if(hStatusEvent)
             {

                 StatusThreadInfo.pResourceStatus = &ResourceStatus;
                 StatusThreadInfo.hStatusEvent    = hStatusEvent;
                 StatusThreadInfo.pSpoolerInfo    = pSpoolerInfo;

                 dwStatus = ClusWorkerCreate((ShutDownMethod == kTerminateShutDown) ?
                                             &pSpoolerInfo->TerminateStatusThread :
                                             &pSpoolerInfo->OffLineStatusThread,
                                             SpoolerStatusReportThread,
                                             (PVOID)&StatusThreadInfo);

                 if( dwStatus != ERROR_SUCCESS )
                 {
                     //
                     // In this case we will unfortunatly fall out of the Reporting thread and
                     // behave the same as previously , which might cause the resource to fail
                     // since it is not reporing the status properly (not likely to happen)
                     //
                     DBGMSG( DBG_WARN,
                             ( "SpoolerClose : ClusWorkerCreate(SpoolerStatusReportThread) failed %d\n", dwStatus ));
                     dwStatus = ERROR_SUCCESS;
                 }
             }
             else
             {
                 //
                 // In this case we will unfortunatly fall out of the Reporting thread and
                 // behave the same as previously , which might cause the resource to fail
                 // since it is not reporing the status properly (not likely to happen)
                 //
                 dwStatus = GetLastError();
                 DBGMSG( DBG_WARN,
                         ( "SpoolerClose: Create StatusEvent failed %d\n", GetLastError() ));
             }

             if(ShutDownMethod == kOffLineShutDown)
             {
                 ClusWorkerTerminate(&(pSpoolerInfo->OnlineThread));
             }

             //
             // RPC to Terminate
             //
             bStatus = ClusterSplClose( hSpooler );

             if(hStatusEvent &&
                (ShutDownMethod == kTerminateShutDown) ?
                pSpoolerInfo->TerminateStatusThread.hThread :
                pSpoolerInfo->OffLineStatusThread.hThread)
             {
                 SetEvent(hStatusEvent);
             }

             DBGMSG( DBG_TRACE,
                     ( "SpoolerClose: h=%x, s=%x,%d\n",
                       hSpooler, bStatus, GetLastError() ));
        }

        if( bStatus ){

            ResourceStatus.ResourceState = ClusterResourceState;
            pSpoolerInfo->hSpooler = NULL;
        }
        else
        {
            ResourceStatus.ResourceState = ClusterResourceFailed;
            dwStatus = ERROR_FUNCTION_FAILED;
        }

        ClusWorkerTerminate((ShutDownMethod == kTerminateShutDown) ?
                            &(pSpoolerInfo->TerminateStatusThread) :
                            &(pSpoolerInfo->OffLineStatusThread));
        //
        // If we are terminating, don't call SetResourceStatus since
        // clustering doesn't expect this after a terminate call.
        //
        if( pSpoolerInfo->eState != kTerminate )
        {
            ResourceStatus.CheckPoint++;
            (pSpoolerInfo->pfnSetResourceStatus)( pSpoolerInfo->ResourceHandle,
                                                  &ResourceStatus );

            pSpoolerInfo->eState = kOffline;
        }

        if(hStatusEvent)
        {
            CloseHandle(hStatusEvent);
        }
    }
    else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}


DWORD
WINAPI
SpoolerOfflineThread(
    IN PCLUS_WORKER Worker,
    IN PVOID pSpoolerInfo_
    )
{
    PSPOOLER_INFORMATION   pSpoolerInfo = (PSPOOLER_INFORMATION)pSpoolerInfo_;
    SpoolerClose(pSpoolerInfo,kOffLineShutDown);
    vDecRef( pSpoolerInfo );
    return 0;
}

DWORD
WINAPI
SpoolerTerminateSync(
    IN PSPOOLER_INFORMATION pSpoolerInfo
    )
{
    return SpoolerClose(pSpoolerInfo,kTerminateShutDown);
}



/********************************************************************

    Spooler routines.

********************************************************************/

BOOL
SpoolerOnline(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Put the spooler service online.  This call completes asynchronously;
    it will use the callback in pSpoolerInfo to update the status.

Arguments:


Return Value:


--*/

{
    DWORD  status=ERROR_SUCCESS;

    pSpoolerInfo->hSpooler = NULL;
    pSpoolerInfo->eState = kOnlinePending;

    vAddRef( pSpoolerInfo );

    //
    // Create a worker thread to start the spooler and poll.
    //
    status = ClusWorkerCreate(&pSpoolerInfo->OnlineThread,
                              SpoolerOnlineThread,
                              (PVOID)pSpoolerInfo
                             );

    if( status != ERROR_SUCCESS ){

        DBGMSG( DBG_WARN,
                ( "SpoolerOnline: ClusWorkerCreate failed %d\n", status ));

        vDecRef( pSpoolerInfo );

        return FALSE;
    }
    return TRUE;
}

DWORD
SpoolerOffline(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Put the spooler service offline.  This call completes asynchronously;
    it will use the callback in pSpoolerInfo to update the status.

Arguments:

Return Value:

--*/

{
    DWORD status = ERROR_SUCCESS;

    DBGMSG( DBG_WARN, ( ">>> SpoolerOffline: called %x\n", Resid ));

    vAddRef( pSpoolerInfo );

    pSpoolerInfo->eState = kOfflinePending;

    //
    // Create a worker thread to stop the spooler.
    //
    if((status = ClusWorkerCreate(&pSpoolerInfo->OfflineThread,
                                  SpoolerOfflineThread,
                                  (PVOID)pSpoolerInfo
                                  ))!=ERROR_SUCCESS)
    {
        DBGMSG( DBG_WARN,
                ( "SpoolerOffline: ClusWorkerCreate failed %d\n", status ));
        DBGMSG( DBG_ERROR,
                ( "SpoolerOffline: Unable to offline spooler\n" ));
        SPLASSERT(status == ERROR_SUCCESS)
        vDecRef( pSpoolerInfo );
    }
    else
    {
        status = ERROR_IO_PENDING;
    }

    return status;
}

VOID
SpoolerTerminate(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Terminates the spooler process.  This call completes asynchronously;
    it will use the callback in pSpoolerInfo to update the status.

Arguments:

Return Value:

--*/

{
    DWORD status = ERROR_SUCCESS;

    DBGMSG( DBG_WARN, ( ">>> SpoolerTerminate: called %x\n", Resid ));

    vAddRef( pSpoolerInfo );
    {
        ClusWorkerTerminate(&(pSpoolerInfo->OnlineThread));
        ClusWorkerTerminate(&(pSpoolerInfo->OfflineThread));

        pSpoolerInfo->eState = kOfflinePending;

        //
        // Create a worker thread to stop the spooler.
        //

        if((status = SpoolerTerminateSync(pSpoolerInfo))!=ERROR_SUCCESS)
        {
            DBGMSG( DBG_WARN,
                    ( "SpoolerTerminate: ClusWorkerCreate failed %d\n", status ));
            DBGMSG( DBG_ERROR,
                    ( "SpoolerTerminate: Unable to offline spooler\n" ));
            SPLASSERT(status == ERROR_SUCCESS)
        }
    }
    vDecRef( pSpoolerInfo );
}


BOOL
SpoolerStart(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Start the spooler.

Arguments:


Return Value:


--*/

{
    BOOL bStatus = TRUE;

    UNREFERENCED_PARAMETER( pSpoolerInfo );

    vEnterSem();

    if( !ghSC ){
        ghSC = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    }

    if( ghSC ){

        if( !ghSpoolerService ){
            ghSpoolerService = OpenService( ghSC,
                                            gszSpooler,
                                            SERVICE_ALL_ACCESS );
        }

        if( !ghSpoolerService ){

            DBGMSG( DBG_WARN,
                    ( "SpoolerStart: Failed to open spooler service %d\n ",
                      GetLastError() ));

            bStatus = FALSE;
            goto Done;
        }

        if( !StartService( ghSpoolerService, 0, NULL )){

            DWORD dwStatus;
            dwStatus = GetLastError();

            if( dwStatus != ERROR_SERVICE_ALREADY_RUNNING ){

                DBGMSG( DBG_WARN,
                        ( "SpoolerStart: StartService failed %d\n",
                          dwStatus ));

                bStatus = FALSE;
            }
        }
    }

Done:

    vLeaveSem();

    return bStatus;
}

BOOL
SpoolerStop(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Stop the spooler.

Arguments:

Return Value:

--*/

{
    BOOL bStatus;
    SERVICE_STATUS ServiceStatus;

    vEnterSem();

    bStatus = ControlService( ghSpoolerService,
                              SERVICE_CONTROL_STOP,
                              &ServiceStatus );

    if( !bStatus ){

        DBGMSG( DBG_WARN,
                ( "SpoolerStop: ControlService failed %d\n", GetLastError() ));

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Stop service failed, Error %1!u!.\n",
            GetLastError() );
    }

    CloseServiceHandle( ghSpoolerService );
    ghSpoolerService = NULL;

    vLeaveSem();

    return TRUE;
}

BOOL
SpoolerIsAlive(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Expensive check to see if the spooler is still alive.

Arguments:

Return Value:

    TRUE - Spooler is alive, and critical section successfully acquired.
    FALSE - Spooler is dead.

--*/

{
#ifdef USE_ISALIVE_THREAD

    HANDLE hThread;
    DWORD dwThreadId;
    DWORD dwExitCode;

    //
    // RPC to spooler.
    //
    SPLASSERT( pSpoolerInfo->hSpooler );

    vAddRef( pSpoolerInfo );

    //
    // Create a worker thread to start the spooler and poll.
    //
    hThread = CreateThread( NULL,
                            0,
                            SpoolerIsAliveThread,
                            (PVOID)pSpoolerInfo,
                            0,
                            &dwThreadId );
    if( !hThread ){

        DBGMSG( DBG_WARN,
                ( "SpoolerOnline: CreateThread failed %d\n", GetLastError() ));

        vDecRef( pSpoolerInfo );

        return FALSE;
    }

    WaitForSingleObject( hThread, ISALIVE_WAIT_TIME );
    if( !GetExitCodeThread( hThread, &dwExitCode )){
        dwExitCode = GetLastError();
    }

    CloseHandle( hThread );

    DBGMSG( DBG_TRACE,
            ( "SpoolerIsAlive: h=%x s=%d\n",
              pSpoolerInfo->hSpooler, dwExitCode ));

    return dwExitCode == ERROR_SUCCESS;

#else // Don't use thread.

    BOOL bIsAlive;

    //
    // RPC to spooler.
    //
    SPLASSERT( pSpoolerInfo->hSpooler );

    bIsAlive = ClusterSplIsAlive( pSpoolerInfo->hSpooler );

    DBGMSG( DBG_TRACE,
            ( "SpoolerIsAlive: h=%x s=%x,%d\n",
              pSpoolerInfo->hSpooler, bIsAlive, GetLastError() ));

    return bIsAlive;

#endif
}

BOOL
SpoolerLooksAlive(
    PSPOOLER_INFORMATION pSpoolerInfo
    )

/*++

Routine Description:

    Quick check to see if the spooler is still alive.

Arguments:

Return Value:

    TRUE - Looks alive.
    FALSE - Looks dead.

--*/

{
    DWORD dwState;

    if( !QuerySpoolerState( &dwState )){

        DBGMSG( DBG_WARN,
                ( "SpoolerLooksAlive: SpoolerStatus failed %d\n",
                  GetLastError() ));

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Query Service Status failed %1!u!.\n",
            GetLastError());

        return FALSE;
    }

    //
    // Now check the status of the service
    //

    if(( dwState != SERVICE_RUNNING ) &&
       ( dwState != SERVICE_START_PENDING )){

        DBGMSG( DBG_WARN,
                ( "SpoolerLooksAlive: QueryServiceStatus bad state %d\n",
                  dwState ));

        (pSpoolerInfo->pfnLogEvent)(
            pSpoolerInfo->ResourceHandle,
            LOG_ERROR,
            L"Failed the IsAlive test.  Current State is %1!u!.\n",
            dwState );

        return FALSE;
    }

    return TRUE;
}

/*++

Routine Name

    SpoolerWriteClusterUpgradedKey

Routine Description:

    After the first reboot following an upgrade of a node, the cluster
    service informs the resdll that a version change occured. At this
    time out spooler resource may be running on  another node or may
    not be actie at all. Thus we write a value in the local registry.
    When the cluster spooler resource fails over on this machine it
    will query for that value to know if it needs to preform post
    upgrade operations, like upgrading the printer drivers.

Arguments:

    pszResourceID - string representation of the GUID of the resoruce

Return Value:

    Win32 error code

--*/
DWORD
SpoolerWriteClusterUpgradedKey(
    IN LPCWSTR pszResourceID
    )
{
    DWORD dwError     = ERROR_INVALID_PARAMETER;
    HKEY  hRootKey    = NULL;
    HKEY  hUpgradeKey = NULL;

    if (pszResourceID &&
        (dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                  SPLREG_CLUSTER_LOCAL_ROOT_KEY,
                                  0,
                                  NULL,
                                  0,
                                  KEY_WRITE,
                                  NULL,
                                  &hRootKey,
                                  NULL)) == ERROR_SUCCESS &&
        (dwError = RegCreateKeyEx(hRootKey,
                                  SPLREG_CLUSTER_UPGRADE_KEY,
                                  0,
                                  NULL,
                                  0,
                                  KEY_WRITE,
                                  NULL,
                                  &hUpgradeKey,
                                  NULL)) == ERROR_SUCCESS)
    {
        DWORD dwValue = 1;

        dwError = RegSetValueEx(hUpgradeKey, pszResourceID, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
    }

    if (hUpgradeKey) RegCloseKey(hUpgradeKey);
    if (hRootKey)    RegCloseKey(hRootKey);

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\spooler\splsvc\cleanup.cxx ===
/*++

Copyright (C) 2001 Microsoft Corporation
All rights reserved.

Module Name:

    cleanup.cxx
    
Abstract:

    Contains functions which perform clean up when a spooler
    resource is deleted, a node is removed as possible owner
    for a spooler resource etc.
    
Author:

    Felix Maxa  (AMaxa)    11-Sept-2001   Created the file
              
--*/

#include "precomp.hxx"
#include "cleanup.hxx"
#include "clusinfo.hxx"

/*++

Name:

    EnumClusterDirectories

Description:

    Enumerates all dirs under system32\spool\drivers. Then it fills in an array
    with all the directories which have the names GUIDs. Ex:
    
    Directory of C:\WINDOWS\system32\spool\drivers
        08/28/2001  02:44 PM    <DIR>          .
        08/28/2001  02:44 PM    <DIR>          ..
        08/28/2001  03:15 PM    <DIR>          0abe4037-88be-4aa1-a714-d6879b4b3a74
        08/28/2001  02:44 PM    <DIR>          13288f3f-901c-4911-8829-695bc9c16e0c
        08/28/2001  12:17 PM    <DIR>          40dda7f1-1127-4ca6-817a-9c5d24633bfa
        08/28/2001  01:55 PM    <DIR>          5c732622-d800-4849-89e1-d5f45d665f30
        08/23/2001  06:10 PM    <DIR>          8de5c2aa-96fc-493c-ba1b-92dafefdfad9
        08/17/2001  04:38 PM    <DIR>          color
        05/22/2001  10:50 AM    <DIR>          IA64
        05/22/2001  10:50 AM    <DIR>          W32ALPHA
        08/17/2001  04:39 PM    <DIR>          w32x86
        05/22/2001  10:50 AM    <DIR>          WIN40
    
    In this case, the function fills in an array with the following names:
        0abe4037-88be-4aa1-a714-d6879b4b3a74
        13288f3f-901c-4911-8829-695bc9c16e0c
        40dda7f1-1127-4ca6-817a-9c5d24633bfa
        5c732622-d800-4849-89e1-d5f45d665f30
        8de5c2aa-96fc-493c-ba1b-92dafefdfad9    
    
Arguments:

    pArray - pointer to array where to store the strings. We can safely
             assume that pArray is always a valid pointer
    
Return Value:

    ERROR_SUCCCESS
    Win32 error

--*/
DWORD
EnumClusterDirectories(
    IN TStringArray *pArray
    )
{
    DWORD Error;
    WCHAR Scratch[MAX_PATH];

    if (GetSystemDirectory(Scratch, MAX_PATH))
    {
        if ((Error =  StrNCatBuff(Scratch, 
                                  MAX_PATH, 
                                  Scratch, 
                                  L"\\spool\\drivers\\*",
                                  NULL)) == ERROR_SUCCESS)
        {
            HANDLE          hFindFile;
            WIN32_FIND_DATA FindData;
            
            //
            // Enumerate all the files in the directory
            //
            hFindFile = FindFirstFile(Scratch, &FindData);
    
            if (hFindFile != INVALID_HANDLE_VALUE) 
            {
                do
                {
                    if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        if (IsGUIDString(FindData.cFileName))
                        {
                            Error = pArray->AddString(FindData.cFileName);
                        }
                    }
                
                } while (Error == ERROR_SUCCESS && FindNextFile(hFindFile, &FindData));
    
                FindClose(hFindFile);
            }
            else
            {
                Error = GetLastError();
            }
        }
    }
    else
    {
        Error = GetLastError();
    }

    return Error;
}

/*++

Name:

    EnumClusterPrintersDriversKeys

Description:

    Enumerates all dirs under system32\spool\drivers. Then it fills in an array
    with all the directories which have the names GUIDs. Ex:
    
    Directory of C:\WINDOWS\system32\spool\drivers
        08/28/2001  02:44 PM    <DIR>          .
        08/28/2001  02:44 PM    <DIR>          ..
        08/28/2001  03:15 PM    <DIR>          0abe4037-88be-4aa1-a714-d6879b4b3a74
        08/28/2001  02:44 PM    <DIR>          13288f3f-901c-4911-8829-695bc9c16e0c
        08/28/2001  12:17 PM    <DIR>          40dda7f1-1127-4ca6-817a-9c5d24633bfa
        08/28/2001  01:55 PM    <DIR>          5c732622-d800-4849-89e1-d5f45d665f30
        08/23/2001  06:10 PM    <DIR>          8de5c2aa-96fc-493c-ba1b-92dafefdfad9
        08/17/2001  04:38 PM    <DIR>          color
        05/22/2001  10:50 AM    <DIR>          IA64
        05/22/2001  10:50 AM    <DIR>          W32ALPHA
        08/17/2001  04:39 PM    <DIR>          w32x86
        05/22/2001  10:50 AM    <DIR>          WIN40
    
    In this case, the function fills in an array with the following names:
        0abe4037-88be-4aa1-a714-d6879b4b3a74
        13288f3f-901c-4911-8829-695bc9c16e0c
        40dda7f1-1127-4ca6-817a-9c5d24633bfa
        5c732622-d800-4849-89e1-d5f45d665f30
        8de5c2aa-96fc-493c-ba1b-92dafefdfad9    
    
Arguments:

    pArray - pointer to array where to store the strings. We can safely
             assume that pArray is always a valid pointer
    
Return Value:

    ERROR_SUCCCESS
    Win32 error

--*/
DWORD
EnumClusterPrinterDriversKeys(
    IN TStringArray *pArray
    )
{
    HKEY  hKey    = NULL;
    DWORD Status  = ERROR_SUCCESS;

    if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                               SPLREG_CLUSTER_LOCAL_ROOT_KEY, 
                               0, 
                               KEY_READ, 
                               &hKey)) == ERROR_SUCCESS)
    {
        LPWSTR  pszBuffer   = NULL;
        DWORD   nBufferSize = 0;

        Status = GetSubkeyBuffer(hKey, &pszBuffer, &nBufferSize);

        if (Status == ERROR_SUCCESS)
        {
            for (DWORD i = 0; Status == ERROR_SUCCESS ; i++)
            {
                DWORD nTempSize = nBufferSize;

                Status = RegEnumKeyEx(hKey, i, pszBuffer, &nTempSize, 0, 0, 0, 0);

                if (Status == ERROR_SUCCESS && IsGUIDString(pszBuffer))
                {
                    Status = pArray->AddString(pszBuffer);
                }
            }
        }

        delete [] pszBuffer;
        

        if (Status == ERROR_NO_MORE_ITEMS)
        {
            Status = ERROR_SUCCESS;
        }
            
        RegCloseKey(hKey);
    }
    
    return Status;
}

/*++

Name:

    EnumClusterSpoolers

Description:

    Fill in a list with the IP addresses used by the cluster service running on the local machine.
    The function returns S_OK if the cluster service is not running. In that case the list will be
    empty.
    
Arguments:

    pClusterIPsList - pointer to list of TStringNodes.
    
Return Value:

    S_OK - success. pClusterIPsList will have 0 or more elements represeting each
           an IP address used by cluster resources
    any other HRESULT - failure

--*/
DWORD
EnumClusterSpoolers(
    IN TStringArray *pArray
    )
{
    HRESULT  hRetval;
    HCLUSTER hCluster;
    
    hCluster = OpenCluster(NULL);

    hRetval = hCluster ? S_OK : GetLastErrorAsHResult();

    if (SUCCEEDED(hRetval)) 
    {
        HCLUSENUM hClusEnum;
    
        hClusEnum = ClusterOpenEnum(hCluster, CLUSTER_ENUM_RESOURCE);
    
        hRetval = hClusEnum ? S_OK : GetLastErrorAsHResult();
    
        if (SUCCEEDED(hRetval)) 
        {
            BOOL   bDone        = FALSE;
            DWORD  Index        = 0;
            LPWSTR pszName      = NULL;
            DWORD  cchName      = 0;
            DWORD  cchNeeded;
            DWORD  ResourceType;
    
            cchName = cchNeeded = kBufferAllocHint;
    
            //
            // We need to initialize pszName to a valid non NULL memory block, otherwise CluserEnum AV's.
            //
            pszName = new WCHAR[cchName];
    
            hRetval = pszName ? S_OK : E_OUTOFMEMORY;
    
            for (Index = 0; !bDone && SUCCEEDED(hRetval);) 
            {
                DWORD Error;
    
                cchNeeded = cchName;
                    
                Error = ClusterEnum(hClusEnum,
                                    Index,   
                                    &ResourceType,
                                    pszName,  
                                    &cchNeeded);

                switch (Error)
                {
                    case ERROR_SUCCESS:
                    {
                        BYTE *pGUID = NULL;
    
                        //
                        // This function allocates memory in pGUID only if pszName is the name
                        // of a cluster spooler. That's why the if statement below checks for pGUID
                        // 
                        hRetval = GetSpoolerResourceGUID(hCluster, pszName,  &pGUID);
    
                        if (pGUID)
                        {
                            Error = pArray->AddString((LPCWSTR)pGUID);

                            hRetval = HRESULT_FROM_WIN32(Error);
                            
                            delete [] pGUID;
                        }
                        
                        Index++;
    
                        break;
                    }
                        
                    case ERROR_MORE_DATA:
                    {
                        delete [] pszName;
        
                        //
                        // cchNeeded returns the number of characters needed, excluding the terminating NULL
                        //
                        cchName = cchNeeded + 1;
        
                        pszName = new WCHAR[cchName];
                            
                        if (!pszName) 
                        {
                            hRetval = E_OUTOFMEMORY;
                        }
        
                        break;
                    }
    
                    case ERROR_NO_MORE_ITEMS:
                    {
                        delete [] pszName;
                        bDone = TRUE;
                        break;
                    }
    
                    default:
                    {
                        delete [] pszName;
                        hRetval = HRESULT_FROM_WIN32(Error);
                    }
                }
            }
            
            ClusterCloseEnum(hClusEnum);
        }
    
        CloseCluster(hCluster);
    }
    
    return hRetval;
}

/*++

Name:

    CleanUnusedClusDriverDirectory

Description:

    A cluster spooler was deleted. Then a GUID direcotry was left over
    in system32\spooler\drivers. This function takes as argument the name
    of a direcotry (a GUID) and deletes recursively all the files in it.
    Basically this function deletes 
    %windir%\system32\spooler\drivers\pszDir
    
Arguments:

    pszDir - name of the directory to delete
    
Return Value:

    ERROR_SUCCESS - the direcotry was deleted or marked for delete on reboot 
                    if files were in use 
    Win32 error code - otherwise

--*/
DWORD
CleanUnusedClusDriverDirectory(
    IN LPCWSTR pszDir
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (pszDir && *pszDir)
    {
        WCHAR Scratch[MAX_PATH];

        if (GetSystemDirectory(Scratch, MAX_PATH))
        {
            if ((Error =  StrNCatBuff(Scratch, 
                                      MAX_PATH, 
                                      Scratch, 
                                      L"\\spool\\drivers\\",
                                      pszDir,
                                      NULL)) == ERROR_SUCCESS)
            {
                Error = DelDirRecursively(Scratch);
            }
        }
        else
        {
            Error = GetLastError();
        }
    }

    return Error;
}

/*++

Name:

    CleanUnusedClusDriverRegistryKey

Description:

    A cluster spooler was deleted. Then a GUID registry key was left over
    under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Cluster. 
    This function takes as argument the name of a reg key (a GUID) and deletes recursively 
    all the keys and values under it.
    Basically this function deletes 
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Cluster\pszName
    
Arguments:

    pszName - name of the key to delete. The key is relative to 
              HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Cluster
    
Return Value:

    ERROR_SUCCESS - the reg key was deleted   
    Win32 error code - otherwise

--*/
DWORD
CleanUnusedClusDriverRegistryKey(
    IN LPCWSTR pszName
    )
{
    DWORD Error = ERROR_INVALID_PARAMETER;

    if (pszName && *pszName)
    {
        HKEY hKey = NULL;

        if ((Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 SPLREG_CLUSTER_LOCAL_ROOT_KEY,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hKey)) == ERROR_SUCCESS)
        {
            Error = DeleteKeyRecursive(hKey, pszName);

            RegCloseKey(hKey);
        }
    }

    return Error;
}

/*++

Name:

    CleanSpoolerUnusedFilesAndKeys

Description:

    Cleans up driver files and registry keys which were used by cluster spooler resources which were deleted.
    Each cluster spooler keeps driver files under system32\drivers\GUID and a reg key under HKLM\Software\...\Print\Cluster.
    This function checks if such "remains" are present on the local node and deletes them.
    
Arguments:

    None
    
Return Value:

    ERROR_SUCCESS - cleanup was done or no clean up was necessary
    other Win32 error - an error occurred
    
--*/
DWORD
CleanSpoolerUnusedFilesAndKeys(
    VOID
    )
{
    DWORD Error = ERROR_SUCCESS;
    DWORD i;

    //
    // Now we enumerate the GUIDS for all the existing cluster spooler resources
    //
    TStringArray ClusSpoolersArray;
    
    Error = EnumClusterSpoolers(&ClusSpoolersArray);
    
    if (Error == ERROR_SUCCESS)
    {
        //
        // We now enumerate all the directories under system32\spool\drivers. We want to 
        // isolate the GUID directories. Those are the directories where the cluster spoolers
        // keep the printer driver files.
        //
        TStringArray UnusedDirsArray;
    
        Error = EnumClusterDirectories(&UnusedDirsArray);
    
        if (Error == ERROR_SUCCESS)
        {
            //
            // Now exlcude all existing spooler GUIDs
            //
            for (i = 0; Error == ERROR_SUCCESS && i < ClusSpoolersArray.Count(); i++)
            {
                Error = UnusedDirsArray.Exclude(ClusSpoolersArray.StringAt(i));
            }   

            if (Error == ERROR_SUCCESS)
            {
                //
                // Now we have the GUIDs of the unused resources. The unused resources
                // are registry keys and file driectories.
                //
                for (i = 0; i < UnusedDirsArray.Count(); i++)
                {
                    CleanUnusedClusDriverDirectory(UnusedDirsArray.StringAt(i));
                }
            }
        }

        //
        // Now we enumerate all the keys under SPLREG_CLUSTER_LOCAL_ROOT_KEY  
        // ("Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Cluster")
        //
        TStringArray UnusedKeysArray;
    
        Error = EnumClusterPrinterDriversKeys(&UnusedKeysArray);
    
        if (Error == ERROR_SUCCESS)
        {
            //
            // Now exlcude all existing spooler GUIDs
            //
            for (i = 0; Error == ERROR_SUCCESS && i < ClusSpoolersArray.Count(); i++)
            {
                Error = UnusedKeysArray.Exclude(ClusSpoolersArray.StringAt(i));
            }   

            if (Error == ERROR_SUCCESS)
            {
                //
                // Now we have the GUIDs of the unused resources. The unused resources
                // are registry keys and file driectories.
                //
                for (i = 0; i < UnusedKeysArray.Count(); i++)
                {
                    CleanUnusedClusDriverRegistryKey(UnusedKeysArray.StringAt(i));                    
                }
            }
        }
    }

    return Error;
}

/*++

Name:

    CleanClusterSpoolerData

Description:

    One can configure the nodes which can host the spooler resource. When you remove a node from that list,
    all nodes currently up receive a CLUSCTL_RESOURCE_REMOVE_OWNER. So, if a node is up, the spooler resource
    DLL needs to preform clean up, i.e. remove the registry key HKLM\Software\...\Print\Cluster. Thus, if you
    immediately add back the node as a possible owner for the spooler resource, all the driver files are
    going to be copied over from the cluster disk (repository). This addresses a problem where there is
    a corruption on the local disk on a node. The admin can remove the node as owner of the spooler resource
    and then add it back as possible owner. This procesdure enusres that the driver files are reinstalled on the
    local node. (We need the driver files on the local node, otherwise apps loaded printer drivers can hit
    in-page errors if they local the drivers directly from the cluster disk)
    
    We have a separate case for a node which is down at the moment when an admin removes it as possible owner 
    for the spooler resource. That node won't receive a CLUSCTL_RESOURCE_REMOVE_OWNER control code. In that case
    we perform the clean up on CLUSCTL_RESOURCE_ADD_OWNER or CLUSCTL_RESOURCE_INSTALL_NODE (we also handle
    the case when a node is down as it is evicted).
 
Arguments:

    hResource   - handle to the spooler resource
    pszNodeName - node node where to perform the clean up
    
Return Value:

    ERROR_SUCCESS - cleanup was done or no clean up was necessary
    other Win32 error - an error occurred
    
--*/
DWORD
CleanClusterSpoolerData(
    IN HRESOURCE hResource, 
    IN LPCWSTR   pszNodeName
    )
{
    DWORD Status = ERROR_INVALID_FUNCTION;

    if (hResource && pszNodeName)
    {
        LPWSTR pszCurrentNode = NULL;

        if ((Status = GetCurrentNodeName(&pszCurrentNode)) == ERROR_SUCCESS)
        {
            if (!ClRtlStrICmp(pszCurrentNode, pszNodeName))
            {
                //
                // Same node, perform clean up
                //
                LPWSTR pszResourceGuid = NULL;

                //
                // Retreive the guid of the spooler resource
                //
                if ((Status = GetIDFromName(hResource, &pszResourceGuid)) == ERROR_SUCCESS)
                {
                    Status = CleanUnusedClusDriverRegistryKey(pszResourceGuid);

                    //
                    // We do not care about the result of this function
                    //
                    CleanUnusedClusDriverDirectory(pszResourceGuid);
    
                    LocalFree(pszResourceGuid);
                } 
            }

            delete [] pszCurrentNode;
        }
    }

    return Status;
}

/*++

Routine Name

    CleanPrinterDriverRepository

Routine Description:

    Thie routine is called when the spooler resource is deleted.
    It will remove from the cluster disk the directory where the 
    spooler keeps the pirnter drivers.

Arguments:

    hKey - handle to the Parameters key of the spooler resource

Return Value:

    Win32 error code

--*/
DWORD
CleanPrinterDriverRepository(
    IN HKEY hKey
    )
{
    DWORD dwError;
    DWORD dwType;
    DWORD cbNeeded = 0;

    //
    // We read the string value (private property) that was written 
    // by the spooler. This is the directory to delete.
    // Note that ClusterRegQueryValue has a bizzare behaviour. If
    // you pass NULL for the buffer and the value exists, then it
    // doesn't return ERROR_MORE_DATA, but ERROR_SUCCESS
    // Should the reg type not be reg_Sz, then we can't do anything 
    // in this function.
    //
    if ((dwError = ClusterRegQueryValue(hKey,
                                        SPLREG_CLUSTER_DRIVER_DIRECTORY,
                                        &dwType,
                                        NULL,
                                        &cbNeeded)) == ERROR_SUCCESS &&
        dwType == REG_SZ) 
    {
        LPWSTR pszDir;
           
        if (pszDir = (LPWSTR)LocalAlloc(LMEM_FIXED, cbNeeded)) 
        {
            if ((dwError = ClusterRegQueryValue(hKey,
                                                SPLREG_CLUSTER_DRIVER_DIRECTORY,
                                                &dwType,
                                                (LPBYTE)pszDir,
                                                &cbNeeded)) == ERROR_SUCCESS)
            {
                //
                // Remove the directory
                //
                DelDirRecursively(pszDir);
            }
    
            LocalFree(pszDir);
        }   
        else
        {
            dwError = GetLastError();
        }        
    }
    
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\spooler\spltest\spltest.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation
All rights reserved.

Module Name:

    spltest.c

Abstract:

    Test program for enabling a spooler group.

Author:

    Albert Ting (AlbertT)  2-Oct-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop


MODULE_DEBUG_INIT( DBG_ERROR|DBG_WARN|DBG_TRACE, DBG_ERROR );

#ifdef __cplusplus
extern "C"
#endif
INT _CRTAPI1
main(
    INT argc,
    CHAR* argv[]
    )
{
    if( !bSplLibInit() )
    {
        return 1;
    }

    BOOL bOpen = FALSE;
    HANDLE hSpooler = NULL;

    HANDLE hStdIn = GetStdHandle( STD_INPUT_HANDLE );

    SetConsoleMode( hStdIn, ENABLE_PROCESSED_INPUT );

    for( ; ; )
    {
        TCHAR c;
        DWORD dwRead;

        printf( "SplTest> " );

        TStatusB bStatus;
        bStatus DBGCHK = ReadConsole( hStdIn,
                                      &c,
                                      1,
                                      &dwRead,
                                      NULL );


        c = TCHAR( CharLower( LPTSTR( c )));

        switch( c )
        {
        case '?':

            printf( "Usage: spltest {action}\n"
                    "       Actions: o - Open\n"
                    "                c - Close\n"
                    "                a - IsAlive\n" );
            break;

        case 'q':

            printf( "q: Exiting\n" );
            return 0;

        case 'o':
        {
            if( bOpen )
            {
                printf( "o: Error: already open %x\n", hSpooler );
                break;
            }


            TStatusB bStatus;
            bStatus DBGCHK = ClusterSplOpen( NULL,
                                             TEXT( "Spooler" ),
                                             &hSpooler,
                                             TEXT( "alberttc,," ),
                                             TEXT( ",1.2.3.4," ));

            if( bStatus )
            {
                printf( "o: Spooler albertt2 NULL opened %x\n", hSpooler );
                bOpen = TRUE;
            }
            else
            {
                printf( "o: Error: %d\n", GetLastError() );
            }
            break;
        }
        case 'c':
        {
            if( !bOpen )
            {
                printf( "c: Error: not open\n" );
                break;
            }

            TStatusB bStatus;
            bStatus DBGCHK = ClusterSplClose( hSpooler );

            if( bStatus )
            {
                printf( "c: Spooler closed %x.\n", hSpooler );
            }
            else
            {
                printf( "c: Error: closing %x %d\n", hSpooler, GetLastError() );
            }

            bOpen = FALSE;

            break;
        }
        case 'a':
        {

            TStatusB bStatus;
            bStatus DBGCHK = ClusterSplIsAlive( hSpooler );

            if( bStatus )
            {
                printf( "a: Spooler alive %x.\n", hSpooler );
            }
            else
            {
                printf( "a: Error: not alive %x %d (%x)\n",
                        hSpooler,
                        GetLastError(),
                        GetLastError() );
            }
            break;
        }
        default:

            printf( "%c: Unknown command\n", c );
            break;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\sources.inc ===
BINPLACE_PLACEFILE=$(PROJECT_ROOT)\cluster\resdll\vsstask\placefil.txt
MSC_WARNING_LEVEL=/W4 /WX

C_DEFINES=$(C_DEFINES) -DSTRSAFE_LIB

MAJORCOMP=cluster

!IF !DEFINED(NO_SPECIAL_DEBUG)
!IF DEFINED(USE_DEBUG_CRTS)
DEBUG_CRTS=1
!ENDIF
!IF !$(FREEBUILD)
RCOPTIONS=$(RCOPTIONS) -D_DEBUG
!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\inc\vsscmn.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    vsscmn.h

Abstract:

    common defines for the VSS task component

Author:

    Charlie Wickham (charlwi) 26-Aug-2002

Environment:

    User Mode

Revision History:

--*/

#ifndef _VSSCMN_
#define _VSSCMN_

//
// Resource type
//
#define CLUS_RESTYPE_NAME_VSSTASK           L"Volume Shadow Copy Service Task"

//
// Resource property names
//
#define CLUSREG_NAME_VSSTASK_CURRENTDIRECTORY       L"CurrentDirectory"
#define CLUSREG_NAME_VSSTASK_APPNAME                L"ApplicationName"
#define CLUSREG_NAME_VSSTASK_APPPARAMS              L"ApplicationParams"
#define CLUSREG_NAME_VSSTASK_TRIGGERARRAY           L"TriggerArray"

#endif  // _VSSCMN_

/* end vsscmn.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\clres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corp.
//
//  Module Name:
//      ClRes.h
//
//  Implementation File:
//      ClRes.cpp
//
//  Description:
//      Main header file for the resource DLL for VSS Task Scheduler.
//
//  Author:
//      Chris Whitaker April 16, 2002
//
//  Revision History:
//      George Potts, August 21, 2002
//          Added ClusCfg managed interfaces to register the resource
//          type and extension DLL during configuration and Startup.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#pragma comment( lib, "clusapi.lib" )
#pragma comment( lib, "resutils.lib" )
#pragma comment( lib, "advapi32.lib" )

#define UNICODE
#define _ATL_APARTMENT_THREADED

#pragma warning( push, 3 )

//
// ATL includes
//
#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>

//
// These two include files contain all ClusCfg interface definitions and CATIDs
//
#include <ClusCfgServer.h>
#include <ClusCfgGuids.h>

//
// MgdResource.h is generated from MgdResource.idl.
//
#include "MgdResource.h"
#include "resource.h"

#include <windows.h>
#include <clusapi.h>
#include <resapi.h>
#include <stdio.h>
#include <vsscmn.h>
#include <assert.h>

//
// Task Scheduler interfaces.
//
#include <mstask.h>
#include <msterr.h>

//
// String safe.
//
#include <strsafe.h>

//
// VSSEvents.h is generated from vssevents.mc.
//
#include "VSSEvents.h"

#pragma warning( pop )

#pragma warning( disable : 4505 )   // unreferenced local function has been removed

#include "StringUtils.h"
#include "guids.h"

/////////////////////////////////////////////////////////////////////////////
// TaskScheduler Resource DLL Definitions
/////////////////////////////////////////////////////////////////////////////

#define VSSTASK_RESNAME L"Volume Shadow Copy Service Task"
#define TASKSCHEDULER_SVCNAME TEXT("schedule")

extern "C" {
BOOLEAN WINAPI ResTypeDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    );

DWORD WINAPI Startup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    );
}

/////////////////////////////////////////////////////////////////////////////
// TaskScheduler Mgd Resource Definitions
/////////////////////////////////////////////////////////////////////////////

//
// This is the name of the cluster resource type.
//
#define RESTYPE_NAME VSSTASK_RESNAME

//
// This is the name of the cluster resource type dll.
//
#define RESTYPE_DLL_NAME L"VSSTask.dll"


/////////////////////////////////////////////////////////////////////////////
// Global Variables and Prototypes
/////////////////////////////////////////////////////////////////////////////

// Event Logging routine.

extern PLOG_EVENT_ROUTINE g_pfnLogEvent;

// Resource Status routine for pending Online and Offline calls.

extern PSET_RESOURCE_STATUS_ROUTINE g_pfnSetResourceStatus;

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Macro's
/////////////////////////////////////////////////////////////////////////////

#define DBG_PRINT printf

#ifndef RTL_NUMBER_OF
#define RTL_NUMBER_OF(A) (sizeof(A)/sizeof((A)[0]))
#endif

//
// COM Macros to gain type checking.
//
#if !defined( TypeSafeParams )
#define TypeSafeParams( _interface, _ppunk ) \
    IID_##_interface, reinterpret_cast< void ** >( static_cast< _interface ** >( _ppunk ) )
#endif // !defined( TypeSafeParams )

#if !defined( TypeSafeQI )
#define TypeSafeQI( _interface, _ppunk ) \
    QueryInterface( TypeSafeParams( _interface, _ppunk ) )
#endif // !defined( TypeSafeQI )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\cmgdcluscfginit.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      CMgdClusCfgInit.cpp
//
//  Description:
//      Implementation of the CMgdClusCfgInit class.
//
//  Author:
//      George Potts, August 21, 2002
//
//  Revision History:
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "clres.h"
#include "CMgdClusCfgInit.h"

//****************************************************************************
//
//  CMgdClusCfgInit class
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdClusCfgInit::CMgdClusCfgInit
//
//  Description:
//      Constructor. Sets all member variables to default values.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CMgdClusCfgInit::CMgdClusCfgInit( void )
{
    m_picccCallback = NULL;
    m_bstrNodeName = NULL;
    m_lcid = GetUserDefaultLCID();

} //*** CMgdClusCfgInit::CMgdClusCfgInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdClusCfgInit::~CMgdClusCfgInit
//
//  Description:
//      Destructor. Frees all previously allocated memory and releases all
//      interface pointers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CMgdClusCfgInit::~CMgdClusCfgInit( void )
{
    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
        m_picccCallback = NULL;
    } // if: m_picccCallback was used

    SysFreeString( m_bstrNodeName );

} //*** CMgdClusCfgInit::~CMgdClusCfgInit

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdClusCfgInit::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      punkCallbackIn
//          Interface on which to query for the IClusCfgCallback interface.
//
//      lcidIn
//          Locale ID.
//
//  Return Value:
//      S_OK            - Success
//      E_POINTER       - Expected pointer argument specified as NULL.
//      E_OUTOFMEMORY   - Out of memory.
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMgdClusCfgInit::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    HRESULT hr                  = S_OK;
    WCHAR   szComputerName[ MAX_PATH ];
    DWORD   cchComputerName     = MAX_PATH;
    DWORD   dwError;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    } // if: Callback pointer is invalid (NULL)

    //
    // Save the callback interface pointer.
    //

    hr = punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: TypeSafeQI failed

    //
    // Save the computer name for use by SendStatusReport.
    //

    if ( GetComputerName( szComputerName, &cchComputerName ) == 0 )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32( dwError );

        HrSendStatusReport(
              TASKID_Major_Find_Devices
            , TASKID_Minor_MgdInitialize
            , 1
            , 1
            , 1
            , hr
            , RES_VSSTASK_ERROR_GETCOMPUTERNAME_FAILED
            , 0
            );
        goto Cleanup;
    } // if: GetComputerName failed

    m_bstrNodeName = SysAllocString( szComputerName );
    if ( m_bstrNodeName == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:

Cleanup:

    return hr;

} //*** CMgdClusCfgInit::Initialize

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdClusCfgInit::HrSendStatusReport
//
//  Description:
//      Wraps IClusCfgCallback::SendStatusReport.
//
//  Arguments:
//       CLSID      clsidTaskMajorIn
//       CLSID      clsidTaskMinorIn
//       ULONG      ulMinIn
//       ULONG      ulMaxIn
//       ULONG      ulCurrentIn
//       HRESULT    hrStatusIn
//       UINT       idsDescriptionIn
//       UINT       idsReferenceIn 
//
//  Return Value:
//      S_OK            - Success
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMgdClusCfgInit::HrSendStatusReport(
      CLSID     clsidTaskMajorIn
    , CLSID     clsidTaskMinorIn
    , ULONG     ulMinIn
    , ULONG     ulMaxIn
    , ULONG     ulCurrentIn
    , HRESULT   hrStatusIn
    , UINT      idsDescriptionIn
    , UINT      idsReferenceIn
    ...
    )
{
    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    BSTR        bstrReference = NULL;
    va_list     valist;

    assert( m_picccCallback != NULL );

    va_start( valist, idsReferenceIn );

    hr = HrFormatStringWithVAListIntoBSTR( _Module.m_hInstResource, idsDescriptionIn, &bstrDescription, valist );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( idsReferenceIn != 0 )
    {
        hr = HrLoadStringIntoBSTR( _Module.m_hInstResource, idsReferenceIn, &bstrReference );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if: valid reference string

    hr = m_picccCallback->SendStatusReport(
              NULL
            , clsidTaskMajorIn
            , clsidTaskMinorIn
            , ulMinIn
            , ulMaxIn
            , ulCurrentIn
            , hrStatusIn
            , bstrDescription
            , 0
            , bstrReference
            );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    SysFreeString( bstrDescription );
    SysFreeString( bstrReference );
    return hr;

} //*** CMgdClusCfgInit::HrSendStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdClusCfgInit::HrSendStatusReport
//
//  Description:
//      Wraps IClusCfgCallback::SendStatusReport.
//
//  Arguments:
//       CLSID      clsidTaskMajorIn
//       CLSID      clsidTaskMinorIn
//       ULONG      ulMinIn
//       ULONG      ulMaxIn
//       ULONG      ulCurrentIn
//       HRESULT    hrStatusIn
//       LPCWSTR    pcszDescriptionIn
//       UINT       idsReferenceIn 
//       ...        optional parameters for pcszDescriptionIn
//
//  Return Value:
//      S_OK            - Success
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMgdClusCfgInit::HrSendStatusReport(
      CLSID     clsidTaskMajorIn
    , CLSID     clsidTaskMinorIn
    , ULONG     ulMinIn
    , ULONG     ulMaxIn
    , ULONG     ulCurrentIn
    , HRESULT   hrStatusIn
    , LPCWSTR   pcszDescriptionIn
    , UINT      idsReferenceIn
    ...
    )
{
    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    BSTR        bstrReference = NULL;
    va_list     valist;

    assert( m_picccCallback != NULL );

    va_start( valist, idsReferenceIn );

    hr = HrFormatStringWithVAListIntoBSTR( pcszDescriptionIn, &bstrDescription, valist );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( idsReferenceIn != 0 )
    {
        hr = HrLoadStringIntoBSTR( _Module.m_hInstResource, idsReferenceIn, &bstrReference );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if: valid reference string

    hr = m_picccCallback->SendStatusReport(
              NULL
            , clsidTaskMajorIn
            , clsidTaskMinorIn
            , ulMinIn
            , ulMaxIn
            , ulCurrentIn
            , hrStatusIn
            , bstrDescription
            , 0
            , bstrReference
            );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    SysFreeString( bstrDescription );
    SysFreeString( bstrReference );
    return hr;

} //*** CMgdClusCfgInit::HrSendStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdClusCfgInit::HrSendStatusReport
//
//  Description:
//      Wraps IClusCfgCallback::SendStatusReport.
//
//  Arguments:
//       CLSID      clsidTaskMajorIn
//       CLSID      clsidTaskMinorIn
//       ULONG      ulMinIn
//       ULONG      ulMaxIn
//       ULONG      ulCurrentIn
//       HRESULT    hrStatusIn
//       LPCWSTR    pcszDescriptionIn
//       LPCWSTR    pcszReferenceIn
//
//  Return Value:
//      S_OK            - Success
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CMgdClusCfgInit::HrSendStatusReport(
      CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , LPCWSTR    pcszReferenceIn
    ...
    )
{
    HRESULT     hr = S_OK;
    BSTR        bstrDescription = NULL;
    va_list     valist;

    assert( m_picccCallback != NULL );

    va_start( valist, pcszReferenceIn );

    hr = HrFormatStringWithVAListIntoBSTR( pcszDescriptionIn, &bstrDescription, valist );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( m_picccCallback != NULL )
    {
        hr = m_picccCallback->SendStatusReport(
                         m_bstrNodeName
                       , clsidTaskMajorIn
                       , clsidTaskMinorIn
                       , ulMinIn
                       , ulMaxIn
                       , ulCurrentIn
                       , hrStatusIn
                       , bstrDescription
                       , 0
                       , pcszReferenceIn
                       );
    } // if: m_picccCallback != NULL

Cleanup:

    SysFreeString( bstrDescription );

    return hr;

} //*** CMgdClusCfgInit::HrSendStatusReport
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\cmgdcluscfginit.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      CMgdClusCfgInit.h
//
//  Description:
//      Header file for the CMgdClusCfgInit class
//
//  Author:
//      George Potts, August 21, 2002
//
//  Revision History:
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "clres.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CMgdClusCfgInit
//
//  Description:
//      The CMgdClusCfgInit class is a base class implementation of the
//      IClusCfgInitialize interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CMgdClusCfgInit : 
    public IClusCfgInitialize,
    public CComObjectRoot
{
public:
    CMgdClusCfgInit( void );
    virtual ~CMgdClusCfgInit( void );

    //
    // IClusCfgInitialize interface
    //
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

private:

    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BSTR                m_bstrNodeName;

    //
    // Private copy constructor to avoid copying.
    //
    CMgdClusCfgInit( const CMgdClusCfgInit & rSrcIn );

    //
    // Private assignment operator to avoid copying.
    //
    const CMgdClusCfgInit & operator = ( const CMgdClusCfgInit & rSrcIn );

public:

    //
    // Public member functions.
    //
    IClusCfgCallback *  GetCallback( void ) { return m_picccCallback; }
    LCID                GetLCID( void )     { return m_lcid; }
    BSTR                GetNodeName( void ) { return m_bstrNodeName; }

    STDMETHOD( HrSendStatusReport )(
          CLSID      clsidTaskMajorIn
        , CLSID      clsidTaskMinorIn
        , ULONG      ulMinIn
        , ULONG      ulMaxIn
        , ULONG      ulCurrentIn
        , HRESULT    hrStatusIn
        , LPCWSTR    pcszDescriptionIn
        , LPCWSTR    pcszReferenceIn
        ...
        );

    STDMETHOD( HrSendStatusReport )(
          CLSID      clsidTaskMajorIn
        , CLSID      clsidTaskMinorIn
        , ULONG      ulMinIn
        , ULONG      ulMaxIn
        , ULONG      ulCurrentIn
        , HRESULT    hrStatusIn
        , LPCWSTR    pcszDescriptionIn
        , UINT       idsReferenceIn
        ...
        );

    STDMETHOD( HrSendStatusReport )(
          CLSID     clsidTaskMajorIn
        , CLSID     clsidTaskMinorIn
        , ULONG     ulMinIn
        , ULONG     ulMaxIn
        , ULONG     ulCurrentIn
        , HRESULT   hrStatusIn
        , UINT      idsDescriptionIn
        , UINT      idsReferenceIn
        ...
        );

}; //*** class CMgdClusCfgInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\clres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      ClRes.cpp
//
//  Description:
//      Entry point module for resource type DLL.
//
//  Author:
//      Chris Whitaker April 16, 2002
//
//  Revision History:
//      Charlie Wickham August 12, 2002
//          changed restype to VSSTask
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include "clres.h"

//
// Global data.
//

// Event Logging routine.

PLOG_EVENT_ROUTINE g_pfnLogEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_pfnSetResourceStatus = NULL;


//
// Function prototypes.
//

BOOLEAN WINAPI VSSTaskDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    );

DWORD WINAPI VSSTaskStartup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    );

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ResTypeDllMain
//
//  Description:
//      Main DLL entry point.
//
//  Arguments:
//      DllHandle   [IN] DLL instance handle.
//      Reason      [IN] Reason for being called.
//      Reserved    [IN] Reserved argument.
//
//  Return Value:
//      TRUE        Success.
//      FALSE       Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI ResTypeDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    )
{
    BOOLEAN bSuccess = TRUE;

    //
    // Perform global initialization.
    //
    switch ( nReason )
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hDllHandle );
            break;

        case DLL_PROCESS_DETACH:
            break;

    } // switch: nReason

    //
    // Pass this request off to the resource type-specific routines.
    //
    if ( ! VSSTaskDllMain( hDllHandle, nReason, Reserved ) )
    {
        bSuccess = FALSE;
    } // if: error calling VSSTaskDllMain routine

    return bSuccess;

} //*** ResTypeDllMain


/////////////////////////////////////////////////////////////////////////////
//++
//
//  Startup
//
//  Description:
//      Startup the resource DLL. This routine verifies that at least one
//      currently supported version of the resource DLL is between
//      nMinVersionSupported and nMaxVersionSupported. If not, then the
//      resource DLL should return ERROR_REVISION_MISMATCH.
//
//      If more than one version of the resource DLL interface is supported
//      by the resource DLL, then the highest version (up to
//      nMaxVersionSupported) should be returned as the resource DLL's
//      interface. If the returned version is not within range, then startup
//      fails.
//
//      The Resource Type is passed in so that if the resource DLL supports
//      more than one Resource Type, it can pass back the correct function
//      table associated with the Resource Type.
//
//  Arguments:
//      pszResourceType [IN]
//          Type of resource requesting a function table.
//
//      nMinVersionSupported [IN]
//          Minimum resource DLL interface version supported by the cluster
//          software.
//
//      nMaxVersionSupported [IN]
//          Maximum resource DLL interface version supported by the cluster
//          software.
//
//      pfnSetResourceStatus [IN]
//          Pointer to a routine that the resource DLL should call to update
//          the state of a resource after the Online or Offline routine
//          have returned a status of ERROR_IO_PENDING.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      pFunctionTable [IN]
//          Returns a pointer to the function table defined for the version
//          of the resource DLL interface returned by the resource DLL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful.
//
//      ERROR_CLUSTER_RESNAME_NOT_FOUND
//          The resource type name is unknown by this DLL.
//
//      ERROR_REVISION_MISMATCH
//          The version of the cluster service doesn't match the version of
//          the DLL.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI Startup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    )
{
    DWORD nStatus = ERROR_CLUSTER_RESNAME_NOT_FOUND;

    //
    // Save callbackup function pointers if they haven't been saved yet.
    //
    if ( g_pfnLogEvent == NULL )
    {
        g_pfnLogEvent = pfnLogEvent;
        g_pfnSetResourceStatus = pfnSetResourceStatus;
    } // if: function pointers specified

    //
    // Call the resource type-specific Startup routine.
    //
    if ( lstrcmpiW( pszResourceType, VSSTASK_RESNAME ) == 0 )
    {
        nStatus = VSSTaskStartup(
                        pszResourceType,
                        nMinVersionSupported,
                        nMaxVersionSupported,
                        pfnSetResourceStatus,
                        pfnLogEvent,
                        pFunctionTable
                        );
    } // if: VSSTask resource type

    return nStatus;

} //*** Startup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\makefile.inc ===
vsstask.rc: $(O)\vssevents.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\guids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      Guids.h
//
//  Description:
//      File for definition of CLSIDs, GUIDs, and logging GUIDs.
//
//  Author:
//      George Potts, August 21, 2002
//
//  Revision History:
//
//  Notes:
//
//
//  Description:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#pragma warning( push )
#include <initguid.h>
#pragma warning( pop )

//////////////////////////////////////////////////////////////////////////////
//
// Reporting GUIDs
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// CMgdClusCfgInit
//////////////////////////////////////////////////////////////////////////////

// {BAF4A171-99EA-4f41-A306-65DF3C9E1573}
DEFINE_GUID( TASKID_Minor_MgdInitialize,
0xbaf4a171, 0x99ea, 0x4f41, 0xa3, 0x6, 0x65, 0xdf, 0x3c, 0x9e, 0x15, 0x73);

//////////////////////////////////////////////////////////////////////////////
// CMgdResType
//////////////////////////////////////////////////////////////////////////////

// {ABA3D0AD-7DB7-497d-8E56-731EB611D2A2}
DEFINE_GUID( TASKID_Minor_MgdResType_CommitChanges,
0xaba3d0ad, 0x7db7, 0x497d, 0x8e, 0x56, 0x73, 0x1e, 0xb6, 0x11, 0xd2, 0xa2);

//////////////////////////////////////////////////////////////////////////////
//
// Registration GUIDs
//
//////////////////////////////////////////////////////////////////////////////

//
// The Resource Type's GUID
//
// {846E19AB-B1FE-42a3-A2ED-28F3379C92DB}
DEFINE_GUID( RESTYPE_MgdRes,
0x846e19ab, 0xb1fe, 0x42a3, 0xa2, 0xed, 0x28, 0xf3, 0x37, 0x9c, 0x92, 0xdb );

//
// This is the Cluster Administrator Extension dll CLSID to register for the type.
// This has to match the UUID of the extension class in ExtObjID.idl.
//
// {C2B2E79F-6908-471D-A5B9-D78A88AD6D32}
DEFINE_GUID(CLSID_CoMgdResDllEx,
0xC2B2E79F, 0x6908, 0x471D, 0xA5, 0xB9, 0xD7, 0x8A, 0x88, 0xAD, 0x6D, 0x32 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\cmgdrestype.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      CMgdResType.h
//
//  Description:
//      Header file for the CMgdResType class
//
//  Author:
//      George Potts, August 21, 2002
//
//  Revision History:
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "clres.h"
#include "CMgdClusCfgInit.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CMgdResType
//
//  Description:
//      The CMgdResType class is an implementation of the
//      IClusCfgResourceTypeInfo interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CMgdResType : 
    public IClusCfgResourceTypeInfo,
    public IClusCfgStartupListener,
    public CMgdClusCfgInit,
    public CComCoClass<CMgdResType,&CLSID_CMgdResType>
{
public:
    CMgdResType( void );
    virtual ~CMgdResType( void );

BEGIN_COM_MAP( CMgdResType )
    COM_INTERFACE_ENTRY( IClusCfgResourceTypeInfo )
    COM_INTERFACE_ENTRY( IClusCfgStartupListener )
    COM_INTERFACE_ENTRY( IClusCfgInitialize )
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE( CMgdResType )

BEGIN_CATEGORY_MAP( CMgdResType )
    IMPLEMENTED_CATEGORY( CATID_ClusCfgResourceTypes )
    IMPLEMENTED_CATEGORY( CATID_ClusCfgStartupListeners )
END_CATEGORY_MAP()

DECLARE_NOT_AGGREGATABLE( CMgdResType )

DECLARE_REGISTRY_RESOURCEID(IDR_CMgdResType)

    //
    // IClusCfgInitialize interface
    //
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgResourceTypeInfo interface
    //
    STDMETHOD( CommitChanges )( IUnknown * punkClusterInfoIn, IUnknown * punkResTypeServicesIn );
    STDMETHOD( GetTypeGUID )( GUID * pguidGUIDOut );
    STDMETHOD( GetTypeName )( BSTR * pbstrTypeNameOut );

    //
    //  IClusCfgStartupListener methods
    //
    STDMETHOD( Notify )( IUnknown * punkIn );

private:

    //
    // Private copy constructor to avoid copying.
    //
    CMgdResType( const CMgdResType & rSrcIn );

    //
    // Private assignment operator to avoid copying.
    //
    const CMgdResType & operator = ( const CMgdResType & rSrcIn );

private:

    //
    // Resource dll, type, and display names.
    //
    BSTR    m_bstrDllName;
    BSTR    m_bstrTypeName;
    BSTR    m_bstrDisplayName;

}; //*** class CMgdResType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\cmgdrestype.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      CMgdResType.cpp
//
//  Description:
//      Implementation for the Managed Resource Type class - this 
//      demonstrates how to implement the IClusCfgResourceTypeInfo interface.
//
//  Author:
//      x
//
//  Revision History:
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "clres.h"
#include "CMgdResType.h"

#pragma warning( push, 3 )
#include <atlimpl.cpp>
#include "MgdResource_i.c"
#pragma warning( pop )

//////////////////////////////////////////////////////////////////////////////
// Define's
//////////////////////////////////////////////////////////////////////////////

//
// some defaults for resource type creation
//
#define CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE     (5 * 1000)
#define CLUSTER_RESTYPE_DEFAULT_IS_ALIVE        (60 * 1000)


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdResType::CMgdResType
//
//  Description:
//      Constructor. Sets all member variables to default values.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CMgdResType::CMgdResType( void )
{
    m_bstrDllName = NULL;
    m_bstrTypeName = NULL;
    m_bstrDisplayName = NULL;

} //*** CMgdResType::CMgdResType

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdResType::~CMgdResType
//
//  Description:
//      Destructor.  Frees all previously allocated memory and releases all
//      interface pointers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CMgdResType::~CMgdResType( void )
{
    SysFreeString( m_bstrDllName );
    SysFreeString( m_bstrTypeName );
    SysFreeString( m_bstrDisplayName );

} //*** CMgdResType::CMgdResType


/////////////////////////////////////////////////////////////////////////////
// CMgdResType -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdResType::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      punkCallbackIn
//          Interface on which to query for the IClusCfgCallback interface.
//
//      lcidIn
//          Locale ID.
//
//  Return Value:
//      S_OK            - Success
//      E_POINTER       - Expected pointer argument specified as NULL.
//      E_OUTOFMEMORY   - Out of memory.
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMgdResType::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    HRESULT hr = S_OK;

    //
    // Initialize the base class first.
    //
    hr = CMgdClusCfgInit::Initialize( punkCallbackIn, lcidIn );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Get the dll name.
    //
    m_bstrDllName = SysAllocString( RESTYPE_DLL_NAME );
    if ( m_bstrDllName == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:

    //
    // Get the resource type name.
    //
    m_bstrTypeName = SysAllocString( RESTYPE_NAME );
    if ( m_bstrTypeName == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:

    //
    // Load the resource type display name.
    //

    //
    // NOTE:    The resource type display name should be localized, but the resource type
    //          name should always remain the same.
    //
    hr = HrLoadStringIntoBSTR( _Module.m_hInstResource, RESTYPE_DISPLAYNAME, &m_bstrDisplayName );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    return hr;

} //*** CMgdClusResType::Initialize


/////////////////////////////////////////////////////////////////////////////
// CMgdResType -- IClusCfgResourceTypeInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdResType::CommitChanges
//
//  Description:
//      Components implement the CommitChanges interface to create or delete 
//      resource types according to the state of the local computer.
//
//  Arguments:
//      punkClusterInfoIn
//          Interface for querying for other interfaces to get information
//          about the cluster (IClusCfgClusterInfo).
//
//      punkResTypeServicesIn
//          Interface for querying for the IClusCfgResourceTypeCreate
//          interface on.
//
//  Return Value:
//      S_OK            - Success
//      E_POINTER       - Expected pointer argument specified as NULL.
//      E_UNEXPECTED    - Unexpected commit mode.
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMgdResType::CommitChanges(
    IUnknown * punkClusterInfoIn,
    IUnknown * punkResTypeServicesIn
    )
{
    HRESULT                         hr          = S_OK;
    IClusCfgClusterInfo *           pccci       = NULL;
    IClusCfgResourceTypeCreate *    pccrtc      = NULL;
    ECommitMode                     ecm = cmUNKNOWN;

    hr = HrSendStatusReport(
          TASKID_Major_Configure_Resource_Types
        , TASKID_Minor_MgdResType_CommitChanges
        , 0
        , 6
        , 0
        , hr
        , RES_VSSTASK_INFO_CONFIGURING_RESTYPE
        , NULL
        , m_bstrDisplayName
        );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Validate arguments
    //
    if ( ( punkClusterInfoIn == NULL ) || ( punkResTypeServicesIn == NULL ) )
    {
        hr = E_POINTER;
        goto Cleanup;
    } // if: one of the arguments is NULL

    hr = HrSendStatusReport(
          TASKID_Major_Configure_Resource_Types
        , TASKID_Minor_MgdResType_CommitChanges
        , 0
        , 6
        , 1
        , hr
        , RES_VSSTASK_INFO_CONFIGURING_RESTYPE
        , NULL
        , m_bstrDisplayName
        );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Find out what event caused this call.
    //

    hr = punkClusterInfoIn->TypeSafeQI( IClusCfgClusterInfo, &pccci );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = HrSendStatusReport(
          TASKID_Major_Configure_Resource_Types
        , TASKID_Minor_MgdResType_CommitChanges
        , 0
        , 6
        , 2
        , hr
        , RES_VSSTASK_INFO_CONFIGURING_RESTYPE
        , NULL
        , m_bstrDisplayName
        );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pccci->GetCommitMode( &ecm );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not determine the commit mode

    hr = HrSendStatusReport(
          TASKID_Major_Configure_Resource_Types
        , TASKID_Minor_MgdResType_CommitChanges
        , 0
        , 6
        , 3
        , hr
        , RES_VSSTASK_INFO_CONFIGURING_RESTYPE
        , NULL
        , m_bstrDisplayName
        );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = S_OK;

    // Check if we are creating or adding
    if ( ( ecm == cmCREATE_CLUSTER ) || ( ecm == cmADD_NODE_TO_CLUSTER ) )
    {
        //
        // We are either creating a cluster on this node or adding it to a cluster.
        // We need to register our resource type and the associated Cluadmin extension dll.
        //

        //
        // Register our resource type.
        //
        hr = punkResTypeServicesIn->TypeSafeQI( IClusCfgResourceTypeCreate, &pccrtc );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = pccrtc->Create(
                          m_bstrTypeName
                        , m_bstrDisplayName
                        , m_bstrDllName
                        , CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE
                        , CLUSTER_RESTYPE_DEFAULT_IS_ALIVE
                        );

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = HrSendStatusReport(
              TASKID_Major_Configure_Resource_Types
            , TASKID_Minor_MgdResType_CommitChanges
            , 0
            , 6
            , 4
            , hr
            , RES_VSSTASK_INFO_CONFIGURING_RESTYPE
            , NULL
            , m_bstrDisplayName
            );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

#define EXTENSION_PAGE
#ifdef EXTENSION_PAGE
        hr = pccrtc->RegisterAdminExtensions(
                          m_bstrTypeName
                        , 1
                        , &CLSID_CoMgdResDllEx
                        );

        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = HrSendStatusReport(
              TASKID_Major_Configure_Resource_Types
            , TASKID_Minor_MgdResType_CommitChanges
            , 0
            , 6
            , 5
            , hr
            , RES_VSSTASK_INFO_CONFIGURING_RESTYPE
            , NULL
            , m_bstrDisplayName
            );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

#endif
    } // if: we are either forming or joining ( but not both )
    else 
    {
        //
        // Check for invalid commit modes.
        //
        if ( ( ecm == cmUNKNOWN ) || ( ecm >= cmMAX ) )
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        } // if: invalid commit mode

        assert( ecm == cmCLEANUP_NODE_AFTER_EVICT );

        // If we are here, then this node has been evicted.

        //
        // TODO: Add code to cleanup the local node after it's been evicted.
        //
        
        hr = S_OK;

    } // else: we are not forming nor joining

    hr = HrSendStatusReport(
          TASKID_Major_Configure_Resource_Types
        , TASKID_Minor_MgdResType_CommitChanges
        , 0
        , 6
        , 6
        , hr
        , RES_VSSTASK_INFO_CONFIGURING_RESTYPE
        , NULL
        , m_bstrDisplayName
        );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( pccci != NULL )
    {
        pccci->Release();
        pccci = NULL;
    } // if:

    if ( pccrtc != NULL )
    {
        pccrtc->Release();
        pccrtc = NULL;
    } // if:

    if ( FAILED( hr ) )
    {
        HrSendStatusReport(
              TASKID_Major_Configure_Resource_Types
            , TASKID_Minor_MgdResType_CommitChanges
            , 0
            , 6
            , 6
            , hr
            , RES_VSSTASK_ERROR_CONFIGURING_RESTYPE_FAILED
            , NULL
            , m_bstrDisplayName
            );
    } // if: FAILED

    return hr;

} //*** CMgdResType::CommitChanges

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdResType::GetTypeGUID
//
//  Description:
//      Retrieves the globally unique identifier of this resource type.
//
//  Arguments:
//      pguidGUIDOut  - The GUID for this resource type.
//
//  Return Value:
//      S_OK        - Success
//      E_POINTER   - Expected pointer argument specified as NULL.
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMgdResType::GetTypeGUID(
    GUID * pguidGUIDOut
    )
{
    HRESULT hr = S_OK;

    if ( pguidGUIDOut == NULL )
    {
        hr = E_POINTER;
    } // if: the output pointer is NULL
    else
    {
        *pguidGUIDOut = RESTYPE_MgdRes;
    } // else: the output pointer is valid

    return hr;

} //*** CMgdResType::GetTypeGUID

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdResType::GetTypeName
//
//  Description:
//      Retrieves the resource type name of this resource type.
//
//  Arguments:
//      pbstrTypeNameOut    - Name of the resource type.
//
//  Return Value:
//      S_OK            - Success
//      E_POINTER       - Expected pointer argument specified as NULL.
//      E_OUTOFMEMORY   - Out of memory.
//      Other HRESULTs
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMgdResType::GetTypeName(
    BSTR* pbstrTypeNameOut
    )
{
    HRESULT hr = S_OK;

    if ( pbstrTypeNameOut == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    } // if: the output pointer is NULL

    *pbstrTypeNameOut = SysAllocString( m_bstrTypeName );
    if ( *pbstrTypeNameOut == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if: memory for the resource type name could allocated

Cleanup:

    return hr;

} //*** CMgdResType::GetTypeName


/////////////////////////////////////////////////////////////////////////////
// CMgdResType -- IClusCfgStartupListener interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMgdResType::Notify
//
//  Description:
//      This method is called to inform a component that the cluster service
//      has started on this computer.
//
//      This component is registered for the cluster service startup notification
//      as a part of the cluster service upgrade (clusocm.inf). This method creates the
//      required resource type and associates the cluadmin extension dll then 
//      deregisters itself from this notification.
//
//  Arguments:
//      IUnknown * punkIn
//          The component that implements this Punk may also provide services
//          that are useful to the implementor of this method. For example,
//          this component usually implements the IClusCfgResourceTypeCreate
//          interface.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CMgdResType::Notify( IUnknown * punkIn )
{
    HRESULT                         hr = S_OK;
    IClusCfgResourceTypeCreate *    piccrtc = NULL;
    const GUID *                    guidAdminEx = &CLSID_CoMgdResDllEx;
    ICatRegister *                  pcrCatReg = NULL;
    CATID                           rgCatId[ 1 ];

    hr = punkIn->TypeSafeQI( IClusCfgResourceTypeCreate, &piccrtc );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Create the resource type.
    //
    hr = piccrtc->Create(
                      m_bstrTypeName
                    , m_bstrDisplayName
                    , m_bstrDllName
                    , 5 *  1000
                    , 60 * 1000
                    );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
    
    //
    // Register the cluadmin extensions.
    //
    hr = piccrtc->RegisterAdminExtensions(
                      m_bstrTypeName
                    , 1
                    , guidAdminEx
                    );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Unregister from StartupListener notifications.
    //
    hr = CoCreateInstance(
              CLSID_StdComponentCategoriesMgr
            , NULL
            , CLSCTX_INPROC_SERVER
            , __uuidof( pcrCatReg )
            , reinterpret_cast< void ** >( &pcrCatReg )
            );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: CoCreate failed

    rgCatId[ 0 ] = CATID_ClusCfgStartupListeners;

    hr = pcrCatReg->UnRegisterClassImplCategories( CLSID_CMgdResType, RTL_NUMBER_OF( rgCatId ), rgCatId );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: deregister failed

Cleanup:

    if ( piccrtc != NULL )
    {
        piccrtc->Release();
    }

    return hr;

} //*** CMgdResType::Notify
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\resource.h ===
#define RES_VSSTASK_INFO_CONFIGURING_RESTYPE            2001
#define RES_VSSTASK_ERROR_CONFIGURING_RESTYPE_FAILED    2002
#define RES_VSSTASK_ERROR_GETCOMPUTERNAME_FAILED        2003
#define IDR_CMgdResType                                 2004
#define RESTYPE_DISPLAYNAME                             2005
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\stringutils.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      StringUtils.h
//
//  Description:
//      Declaration of string manipulation routines.
//
//  Author:
//
//  Revision History:
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Load string routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrLoadStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    );

inline
HRESULT
HrLoadStringIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    )

{
    return HrLoadStringIntoBSTR(
                          hInstanceIn
                        , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                        , idsIn
                        , pbstrInout
                        );

} //*** HrLoadStringIntoBSTR

//////////////////////////////////////////////////////////////////////////////
// Format string ID routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrFormatStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , ...
    );

HRESULT
HrFormatStringWithVAListIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    );

inline
HRESULT
HrFormatStringIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , ...
    )
{
    HRESULT hr;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatStringWithVAListIntoBSTR(
                  hInstanceIn
                , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                , idsIn
                , pbstrInout
                , valist
                );

    va_end( valist );

    return hr;

} //*** HrFormatStringIntoBSTR

inline
HRESULT
HrFormatStringWithVAListIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    return HrFormatStringWithVAListIntoBSTR(
                  hInstanceIn
                , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                , idsIn
                , pbstrInout
                , valistIn
                );

} //*** HrFormatStringWithVAListIntoBSTR

//////////////////////////////////////////////////////////////////////////////
// Format string routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrFormatStringIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , ...
    );

HRESULT
HrFormatStringWithVAListIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\stringutils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      StringUtils.cpp
//
//  Description:
//      Implementation of string manipulation routines.
//
//  Author:
//
//  Revision History:
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "clres.h"

//////////////////////////////////////////////////////////////////////////////
// Globals
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLoadStringIntoBSTR
//
//  Description:
//      Retrieves the string resource idsIn from the string table and makes it
//      into a BSTR. If the BSTR is not NULL coming it, it will assume that
//      you are trying reuse an existing BSTR.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.  If not specified, defaults to
//          _Module_mhInstResource.
//
//      langidIn
//          Language ID of string table resource.
//
//      idsIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      Other HRESULTs
//          The call failed.
//
//  Remarks:
//      This routine uses LoadResource so that it can get the actual length
//      of the string resource.  If we didn't do this, we would need to call
//      LoadString and allocate memory in a loop.  Very inefficient!
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLoadStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    )

{
    HRESULT hr              = S_OK;
    HRSRC   hrsrc           = NULL;
    HGLOBAL hgbl            = NULL;
    int     cch             = 0;
    PBYTE   pbStringData;
    PBYTE   pbStringDataMax;
    PBYTE   pbStringTable;
    int     cbStringTable;
    int     nTable;
    int     nOffset;
    int     idxString;

    assert( idsIn != 0 );
    assert( pbstrInout != NULL );

    if ( pbstrInout == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    } // if:

    if ( hInstanceIn == NULL )
    {
        hInstanceIn = _Module.m_hInstResource;
    } // if:

    // The resource Id specified must be converted to an index into
    // a Windows StringTable.
    nTable = idsIn / 16;
    nOffset = idsIn - (nTable * 16);

    // Internal Table Id's start at 1 not 0.
    nTable++;

    //
    // Find the part of the string table where the string resides.
    //

    // Find the table containing the string.
    // First try to load the language specified.  If we can't find it we
    // try the "neutral" language.
    hrsrc = FindResourceEx( hInstanceIn, RT_STRING, MAKEINTRESOURCE( nTable ), langidIn );
    if ( ( hrsrc == NULL ) && ( GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND ) )
    {
        hrsrc = FindResourceEx(
                      hInstanceIn
                    , RT_STRING
                    , MAKEINTRESOURCE( nTable )
                    , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                    );
    } // if: FindResourceEx failed
    if ( hrsrc == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Cleanup;
    } // if:

    // Load the table.
    hgbl = LoadResource( hInstanceIn, hrsrc );
    if ( hgbl == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Cleanup;
    } // if:

    // Lock the table so we access its data.
    pbStringTable = reinterpret_cast< PBYTE >( LockResource( hgbl ) );
    if ( pbStringTable == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Cleanup;
    } // if:

    cbStringTable = SizeofResource( hInstanceIn, hrsrc );
    assert( cbStringTable != 0 );

    // Set the data pointer to the beginning of the table.
    pbStringData = pbStringTable;
    pbStringDataMax = pbStringTable + cbStringTable;

    //
    // Skip strings in the block of 16 which are before the desired string.
    //

    for ( idxString = 0 ; idxString <= nOffset ; idxString++ )
    {
        assert( pbStringData != NULL );
        assert( pbStringData < pbStringDataMax );

        // Get the number of characters excluding the '\0'.
        cch = * ( (USHORT *) pbStringData );

        // Found the string.
        if ( idxString == nOffset )
        {
            if ( cch == 0 )
            {
                hr = HRESULT_FROM_WIN32( ERROR_RESOURCE_NAME_NOT_FOUND );
                goto Cleanup;
            } // if:

            // Skip over the string length to get the string.
            pbStringData += sizeof( WCHAR );

            break;
        } // if: found the string

        // Add one to account for the string length.
        // A string length of 0 still takes 1 WCHAR for the length portion.
        cch++;

        // Skip over this string to get to the next string.
        pbStringData += ( cch * sizeof( WCHAR ) );

    } // for: each string in the block of 16 strings in the table

    // Note: nStringLen is the number of characters in the string not including the '\0'.
    //assertMsg( cch > 0, "Length of string in resource file cannot be zero." );

    //
    // If previously allocated free it before re-allocating it.
    //

    if ( *pbstrInout != NULL )
    {
        SysFreeString( *pbstrInout );
        *pbstrInout = NULL;
    } // if: string was allocated previously

    //
    // Allocate a BSTR for the string.
    //

    *pbstrInout = SysAllocStringLen( (OLECHAR *) pbStringData, cch );
    if ( *pbstrInout == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:

Cleanup:

    return hr;

} //*** HrLoadStringIntoBSTR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringIntoBSTR
//
//  Description:
//      Format a string (specified by idsIn, a string resource ID) and
//      variable arguments into a BSTR using the FormatMessage() Win32 API.
//      If the BSTR is not NULL on entry, the BSTR will be reused.
//
//      Calls HrFormatStringWithVAListIntoBSTR to perform the actual work.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.
//
//      langidIn
//          Language ID of string table resource.
//
//      idsIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      ...
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , ...
    )
{
    HRESULT hr;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatStringWithVAListIntoBSTR(
                          hInstanceIn
                        , langidIn
                        , idsIn
                        , pbstrInout
                        , valist
                        );

    va_end( valist );

    return hr;

} //*** HrFormatStringIntoBSTR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringWithVAListIntoBSTR
//
//  Description:
//      Format a string (specified by idsIn, a string resource ID) and
//      variable arguments into a BSTR using the FormatMessage() Win32 API.
//      If the BSTR is not NULL on entry, the BSTR will be reused.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.
//
//      langidIn
//          Language ID of string table resource.
//
//      idsIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      valistIn
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringWithVAListIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    HRESULT hr = S_OK;
    BSTR    bstrStringResource = NULL;
    DWORD   cch;
    LPWSTR  psz = NULL;

    assert( pbstrInout != NULL );

    if ( pbstrInout == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    } // if:

    //
    // Load the string resource.
    //

    hr = HrLoadStringIntoBSTR( hInstanceIn, langidIn, idsIn, &bstrStringResource );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Format the message with the arguments.
    //

    cch = FormatMessage(
                      ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_STRING )
                    , bstrStringResource
                    , 0
                    , 0
                    , (LPWSTR) &psz
                    , 0
                    , &valistIn
                    );
    //assertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Cleanup;
    } // if:

    //
    // If previously allocated free it before re-allocating it.
    //

    if ( *pbstrInout != NULL )
    {
        SysFreeString( *pbstrInout );
        *pbstrInout = NULL;
    } // if:

    //
    // Allocate a BSTR for the string.
    //

    *pbstrInout = SysAllocStringLen( psz, cch );
    if ( *pbstrInout == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:

Cleanup:

    SysFreeString( bstrStringResource );
    LocalFree( psz );

    return hr;

} //*** HrFormatStringWithVAListIntoBSTR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringIntoBSTR
//
//  Description:
//      Format a string (specified by pcwszFmtIn) and variable arguments into
//      a BSTR using the FormatMessage() Win32 API.  If the BSTR is not NULL
//      on entry, the BSTR will be reused.
//
//      Calls HrFormatStringWithVAListIntoBSTR to perform the actual work.
//
//  Arguments:
//      pcwszFmtIn
//          Specifies the format string.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      ...
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , ...
    )
{
    HRESULT hr;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatStringWithVAListIntoBSTR( pcwszFmtIn, pbstrInout, valist );

    va_end( valist );

    return hr;

} //*** HrFormatStringIntoBSTR

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringWithVAListIntoBSTR
//
//  Description:
//      Format a string (specified by pcwszFmtIn) and variable arguments into
//      a BSTR using the FormatMessage() Win32 API.  If the BSTR is not NULL
//      on entry, the BSTR will be reused.
//
//  Arguments:
//      pcwszFmtIn
//          Specifies the format string.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      valistIn
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pcwszFmtIn or pbstrInout is NULL.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringWithVAListIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    HRESULT hr = S_OK;
    DWORD   cch;
    LPWSTR  psz = NULL;

    if (    ( pbstrInout == NULL )
        ||  ( pcwszFmtIn == NULL ) )
    {
        hr = E_POINTER;
        goto Cleanup;
    } // if:

    //
    // Format the message with the arguments.
    //

    cch = FormatMessage(
                      ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_STRING )
                    , pcwszFmtIn
                    , 0
                    , 0
                    , (LPWSTR) &psz
                    , 0
                    , &valistIn
                    );
    //assertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Cleanup;
    } // if:

    //
    // If previously allocated free it before re-allocating it.
    //

    if ( *pbstrInout != NULL )
    {
        SysFreeString( *pbstrInout );
        *pbstrInout = NULL;
    } // if:

    //
    // Allocate a BSTR for the string.
    //

    *pbstrInout = SysAllocStringLen( psz, cch );
    if ( *pbstrInout == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:

Cleanup:

    LocalFree( psz );

    return hr;

} //*** HrFormatStringWithVAListIntoBSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\dlghelp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2002 Microsoft Corporation
//
//	Module Name:
//		DlgHelp.cpp
//
//	Abstract:
//		Implementation of the CDialogHelp class.
//
//	Author:
//		David Potter (davidp)	February 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC( CDialogHelp, CObject )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CDialogHelp
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pmap		[IN] Map array mapping control IDs to help IDs.
//		dwMask		[IN] Mask to use for the low word of the help ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDialogHelp::CDialogHelp( IN const DWORD * pdwHelpMap, IN DWORD dwMask )
{
	ASSERT( pdwHelpMap != NULL );

	CommonConstruct();
	SetMap( pdwHelpMap );
	m_dwMask = dwMask;

}  //*** CDialogHelp::CDialogHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::CommonConstruct
//
//	Routine Description:
//		Do common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::CommonConstruct( void )
{
	m_pmap = NULL;
	m_dwMask = 0;
	m_nHelpID = 0;

}  //*** CDialogHelp::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::NHelpFromCtrlID
//
//	Routine Description:
//		Return the help ID from a control ID.
//
//	Arguments:
//		nCtrlID		[IN] ID of control to search for.
//
//	Return Value:
//		nHelpID		Help ID associated with the control.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CDialogHelp::NHelpFromCtrlID( IN DWORD nCtrlID ) const
{
	DWORD						nHelpID = 0;
	const CMapCtrlToHelpID *	pmap = Pmap();

	ASSERT( pmap != NULL );
	ASSERT( nCtrlID != 0 );

	for ( ; pmap->m_nCtrlID != 0 ; pmap++ )
	{
		if ( pmap->m_nCtrlID == nCtrlID )
		{
			nHelpID = pmap->m_nHelpCtrlID;
			break;
		}  // if:  found a match
	}  // for:  each control

	TRACE( _T("NHelpFromCtrlID() - nCtrlID = %x, nHelpID = %x"), nCtrlID, nHelpID );

	return nHelpID;

}  //*** CDialogHelp::NHelpFromCtrlID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDialogHelp::OnContextMenu( CWnd * pWnd, CPoint point )
{
	CWnd *	pwndChild;
	CPoint	ptDialog;
	DWORD	nHelpID = 0;

	ASSERT( pWnd != NULL );

	m_nHelpID = 0;

	// Convert the point into dialog coordinates.
	ptDialog = point;
	pWnd->ScreenToClient( &ptDialog );

	// Find the control the cursor is over.
	{
		DWORD	nCtrlID;

		pwndChild = pWnd->ChildWindowFromPoint( ptDialog );
		if ( ( pwndChild != NULL ) && ( pwndChild->GetStyle() & WS_VISIBLE ) )
		{
			nCtrlID = pwndChild->GetDlgCtrlID();
			if ( nCtrlID != 0 )
			{
				nHelpID = NHelpFromCtrlID( nCtrlID );
			} // if: control ID found
		}  // if:  over a child window
	}  // Find the control the cursor is over

	// Display a popup menu.
	if ( ( nHelpID != 0 ) && ( nHelpID != -1 ) )
	{
		CString	strMenu;
		CMenu	menu;

		try
		{
			strMenu.LoadString( IDS_MENU_WHATS_THIS );
		}  // try
		catch ( CMemoryException * pme )
		{
			pme->Delete();
			return;
		}  // catch:  CMemoryException

		if ( menu.CreatePopupMenu() )
		{
			if ( menu.AppendMenu( MF_STRING | MF_ENABLED, ID_HELP, strMenu ) )
			{
				DWORD	nCmd;
				m_nHelpID = nHelpID;
				nCmd = menu.TrackPopupMenu(
					TPM_RETURNCMD | TPM_NONOTIFY | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
					point.x,
					point.y,
					AfxGetMainWnd()
					);
				if ( nCmd != 0 )
				{
					AfxGetApp()->WinHelp( m_nHelpID, HELP_CONTEXTPOPUP );
				} // if: menu item selected
			}  // if:  menu item added successfully
			menu.DestroyMenu();
		}  // if:  popup menu created successfully
	}  // if:  over a child window of this dialog with a tabstop

}  //*** CDialogHelp::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDialogHelp::OnHelpInfo( HELPINFO * pHelpInfo )
{
	// If this is for a control, display control-specific help.
	if (	( pHelpInfo->iContextType == HELPINFO_WINDOW )
		&&	( pHelpInfo->iCtrlId != 0 ) )
	{
		DWORD	nHelpID = NHelpFromCtrlID( pHelpInfo->iCtrlId );
		if ( nHelpID != 0 )
		{
			if ( nHelpID != -1 )
			{
				AfxGetApp()->WinHelp( nHelpID, HELP_CONTEXTPOPUP );
			} // if: valid help ID found
			return TRUE;
		}  // if:  found the control in the list
	}  // if:  need help on a specific control

	// Display dialog help.
	return FALSE;

}  //*** CDialogHelp::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDialogHelp::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		WPARAM		[IN] Passed on to base class method.
//		lParam		[IN] Help ID.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CDialogHelp::OnCommandHelp( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( wParam );
    UNREFERENCED_PARAMETER( lParam );

	return TRUE;

}  //*** CDialogHelp::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\vsstask.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      vsstask.cpp
//
//  Description:
//      Resource DLL for Volume Snapshot Service Task Scheduler.
//
//  Author:
//      Chris Whitaker April 16, 2002
//
//  Revision History:
//      Charlie Wickham August 12, 2002
//          renamed resource type and fixed bug with SetParameters.
//          added CurrentDirectory property.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include "ClRes.h"

//
// Type and constant definitions.
//

// ADDPARAM: Add new properties here.
#define PROP_NAME__APPLICATIONNAME      CLUSREG_NAME_VSSTASK_APPNAME
#define PROP_NAME__APPLICATIONPARAMS    CLUSREG_NAME_VSSTASK_APPPARAMS
#define PROP_NAME__CURRENTDIRECTORY     CLUSREG_NAME_VSSTASK_CURRENTDIRECTORY
#define PROP_NAME__TRIGGERARRAY         CLUSREG_NAME_VSSTASK_TRIGGERARRAY

// ADDPARAM: Add new properties here.
typedef struct _VSSTASK_PROPS
{
	PWSTR			pszApplicationName;
	PWSTR			pszApplicationParams;
    PWSTR           pszCurrentDirectory;
    LPBYTE          pbTriggerArray;
    DWORD           nTriggerArraySize;
} VSSTASK_PROPS, * PVSSTASK_PROPS;

typedef struct _VSSTASK_RESOURCE
{
    RESID                   resid; // For validation.
    VSSTASK_PROPS           propsActive; // The active props.  Used for program flow and control when the resource is online.
    VSSTASK_PROPS           props; // The props in cluster DB.  May differ from propsActive until OnlineThread reloads them as propsActive.
    HCLUSTER                hCluster;
    HRESOURCE               hResource;
    HKEY                    hkeyParameters;
    RESOURCE_HANDLE         hResourceHandle;
    LPWSTR                  pszResourceName;
    CLUS_WORKER             cwWorkerThread;
    CLUSTER_RESOURCE_STATE  state;
} VSSTASK_RESOURCE, * PVSSTASK_RESOURCE;


//
// Global data.
//

HANDLE  g_LocalEventLog = NULL;

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_VSSTaskFunctionTable;

//
// VSSTask resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
VSSTaskResourcePrivateProperties[] =
{
	{ PROP_NAME__APPLICATIONNAME, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( VSSTASK_PROPS, pszApplicationName ) },
	{ PROP_NAME__APPLICATIONPARAMS, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET( VSSTASK_PROPS, pszApplicationParams ) },
    { PROP_NAME__CURRENTDIRECTORY, NULL, CLUSPROP_FORMAT_EXPAND_SZ, 0, 0, 0, 0, FIELD_OFFSET( VSSTASK_PROPS, pszCurrentDirectory ) },
    { PROP_NAME__TRIGGERARRAY, NULL, CLUSPROP_FORMAT_BINARY, 0, 0, 0, 0, FIELD_OFFSET( VSSTASK_PROPS, pbTriggerArray ) },
    { 0 }
};

//
// Function prototypes.
//

RESID WINAPI VSSTaskOpen(
    IN  LPCWSTR         pszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    );

void WINAPI VSSTaskClose( IN RESID resid );

DWORD WINAPI VSSTaskOnline(
    IN      RESID   resid,
    IN OUT  PHANDLE phEventHandle
    );

DWORD WINAPI VSSTaskOnlineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PVSSTASK_RESOURCE   pResourceEntry
    );

DWORD WINAPI VSSTaskOffline( IN RESID resid );

DWORD WINAPI VSSTaskOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PVSSTASK_RESOURCE       pResourceEntry
    );

void WINAPI VSSTaskTerminate( IN RESID resid );

BOOL WINAPI VSSTaskLooksAlive( IN RESID resid );

BOOL WINAPI VSSTaskIsAlive( IN RESID resid );

BOOL VSSTaskCheckIsAlive(
    IN PVSSTASK_RESOURCE    pResourceEntry,
    IN BOOL                 bFullCheck
    );

DWORD WINAPI VSSTaskResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD VSSTaskGetPrivateResProperties(
    IN OUT  PVSSTASK_RESOURCE   pResourceEntry,
    OUT     PVOID   pOutBuffer,
    IN      DWORD   cbOutBufferSize,
    OUT     LPDWORD pcbBytesReturned
    );

DWORD VSSTaskValidatePrivateResProperties(
    IN OUT  PVSSTASK_RESOURCE   pResourceEntry,
    IN      const PVOID pInBuffer,
    IN      DWORD       cbInBufferSize,
    OUT     PVSSTASK_PROPS  pProps
    );

DWORD VSSTaskSetPrivateResProperties(
    IN OUT  PVSSTASK_RESOURCE   pResourceEntry,
    IN      const PVOID pInBuffer,
    IN      DWORD       cbInBufferSize
    );

DWORD VSSTaskSetNameHandler(
    IN OUT  PVSSTASK_RESOURCE   pResourceEntry,
    IN      LPWSTR              pszName
    );

/////////////////////////////////////////////////////////////////////////////
// 
// Delete the job if it exists
//
/////////////////////////////////////////////////////////////////////////////
static HRESULT DeleteTask(IN RESOURCE_HANDLE  hResourceHandle,
                          IN LPCWSTR          pszTaskName,
                          IN LOG_LEVEL        dwLogLevel,
                          IN BOOL             fLogToEventLog)
{
    HRESULT         hr;
    ITaskScheduler  *pITS = NULL;
    ITask *         pITask = NULL;


    // Get a handle to the Task Scheduler
    //
    hr = CoCreateInstance(CLSID_CTaskScheduler,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITaskScheduler,
                          (void **) &pITS);
    if (FAILED(hr))
    {
       (g_pfnLogEvent)(
            hResourceHandle,
            dwLogLevel,
            L"Failed to get a handle to Scheduler to terminate and delete task. "
            L"status 0x%1!08X!.\n",
            hr );
       goto Cleanup;
    }

    //
    // Get a handle to the task so we can terminate it.
    //
    hr = pITS->Activate(pszTaskName,
                        IID_ITask,
                        (IUnknown**) &pITask);
    if (SUCCEEDED(hr)) {

        hr = pITask->Terminate();
        if (SUCCEEDED(hr))
        {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_INFORMATION,
                L"Task terminated.\n");
        }
        else if ( hr != SCHED_E_TASK_NOT_RUNNING ) {
            (g_pfnLogEvent)(hResourceHandle,
                            dwLogLevel,
                            L"Failed to terminate task. status 0x%1!08X!.\n",
                            hr );

            if ( fLogToEventLog ) {
                ReportEvent(g_LocalEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            RES_VSSTASK_TERMINATE_TASK_FAILED,
                            NULL,
                            1,                        // number of strings to merge
                            sizeof( hr ),             // size of binary data
                            (LPCWSTR *)&pszTaskName,
                            (LPVOID)&hr);
            }
        }

        hr = S_OK;      // not fatal
    }
    else {
       (g_pfnLogEvent)(
            hResourceHandle,
            LOG_WARNING,
            L"Could not find task to terminate it. status 0x%1!08X!.\n",
            hr );
    }

    //
    // Now delete the task
    //
    hr = pITS->Delete(pszTaskName);
    if (SUCCEEDED(hr))
    {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_INFORMATION,
                L"Task Deleted.\n");
    }
    else {
       (g_pfnLogEvent)(
            hResourceHandle,
            dwLogLevel,
            L"Failed to delete task. status 0x%1!08X!.\n",
            hr );
       ReportEvent(g_LocalEventLog,
                   EVENTLOG_WARNING_TYPE,
                   0,
                   RES_VSSTASK_DELETE_TASK_FAILED,
                   NULL,
                   1,                        // number of strings to merge
                   sizeof( hr ),             // size of binary data
                   (LPCWSTR *)&pszTaskName,
                   (LPVOID)&hr);
    } // else:

Cleanup:

    if (pITask != NULL) 
    {
        pITask->Release();
    }

    if (pITS != NULL)
    {
        pITS->Release();
    } // if:

    return hr;

} // DeleteTask

/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskDllMain
//
//  Description:
//      Main DLL entry point for the VSSTask resource type.
//
//  Arguments:
//      DllHandle   [IN] DLL instance handle.
//      Reason      [IN] Reason for being called.
//      Reserved    [IN] Reserved argument.
//
//  Return Value:
//      TRUE        Success.
//      FALSE       Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI VSSTaskDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    )
{
    UNREFERENCED_PARAMETER( hDllHandle );
    UNREFERENCED_PARAMETER( Reserved );

    switch ( nReason )
    {
        case DLL_PROCESS_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

    } // switch: nReason

    return TRUE;

} //*** VSSTaskDllMain


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskStartup
//
//  Description:
//      Startup the resource DLL for the VSSTask resource type.
//      This routine verifies that at least one currently supported version
//      of the resource DLL is between nMinVersionSupported and
//      nMaxVersionSupported. If not, then the resource DLL should return
//      ERROR_REVISION_MISMATCH.
//
//      If more than one version of the resource DLL interface is supported
//      by the resource DLL, then the highest version (up to
//      nMaxVersionSupported) should be returned as the resource DLL's
//      interface. If the returned version is not within range, then startup
//      fails.
//
//      The Resource Type is passed in so that if the resource DLL supports
//      more than one Resource Type, it can pass back the correct function
//      table associated with the Resource Type.
//
//  Arguments:
//      pszResourceType [IN]
//          Type of resource requesting a function table.
//
//      nMinVersionSupported [IN]
//          Minimum resource DLL interface version supported by the cluster
//          software.
//
//      nMaxVersionSupported [IN]
//          Maximum resource DLL interface version supported by the cluster
//          software.
//
//      pfnSetResourceStatus [IN]
//          Pointer to a routine that the resource DLL should call to update
//          the state of a resource after the Online or Offline routine
//          have returned a status of ERROR_IO_PENDING.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      pFunctionTable [IN]
//          Returns a pointer to the function table defined for the version
//          of the resource DLL interface returned by the resource DLL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful.
//
//      ERROR_CLUSTER_RESNAME_NOT_FOUND
//          The resource type name is unknown by this DLL.
//
//      ERROR_REVISION_MISMATCH
//          The version of the cluster service doesn't match the version of
//          the DLL.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI VSSTaskStartup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    )
{
    DWORD nStatus;

    UNREFERENCED_PARAMETER( pfnSetResourceStatus );
    UNREFERENCED_PARAMETER( pfnLogEvent );

    if (   (nMinVersionSupported > CLRES_VERSION_V1_00)
        || (nMaxVersionSupported < CLRES_VERSION_V1_00) )
    {
        nStatus = ERROR_REVISION_MISMATCH;
    } // if: version not supported
    else if ( lstrcmpiW( pszResourceType, VSSTASK_RESNAME ) != 0 )
    {
        //
        // This check is also performed by the Startup() in CLRES.CPP.
        //
        nStatus = ERROR_CLUSTER_RESNAME_NOT_FOUND;
    } // if: resource type name not supported
    else
    {
        *pFunctionTable = &g_VSSTaskFunctionTable;
        nStatus = ERROR_SUCCESS;
    } // else: we support this type of resource

    if ( g_LocalEventLog == NULL ) {
        g_LocalEventLog = RegisterEventSource( NULL, CLUS_RESTYPE_NAME_VSSTASK );
        if ( g_LocalEventLog == NULL ) {
            DWORD logStatus = GetLastError();

            (pfnLogEvent)(  L"rt" CLUS_RESTYPE_NAME_VSSTASK,
                            LOG_WARNING,
                            L"Startup: Unable to get handle to eventlog. This resource will log "
                            L"only to the cluster log. status %1!u!.\n",
                            logStatus);
        }
    }

    return nStatus;

} //*** VSSTaskStartup


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskOpen
//
//  Description:
//      Open routine for VSSTask resources.
//
//      Open the specified resource (create an instance of the resource).
//      Allocate all structures necessary to bring the specified resource
//      online.
//
//  Arguments:
//      pszResourceName [IN]
//          Supplies the name of the resource to open.
//
//      hkeyResourceKey [IN]
//                  Supplies handle to the resource's cluster database key.
//
//      hResourceHandle [IN]
//          A handle that is passed back to the Resource Monitor when the
//          SetResourceStatus or LogEvent method is called.  See the
//          description of the pfnSetResourceStatus and pfnLogEvent arguments
//          to the VSSTaskStartup routine.  This handle should never be
//          closed or used for any purpose other than passing it as an
//          argument back to the Resource Monitor in the SetResourceStatus or
//          LogEvent callbacks.
//
//  Return Value:
//      resid
//          RESID of opened resource.
//
//      NULL
//          Error occurred opening the resource.  Resource Monitor may call
//          GetLastError() to get more details on the error.
//
//--
/////////////////////////////////////////////////////////////////////////////
RESID WINAPI VSSTaskOpen(
    IN  LPCWSTR         pszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    )
{
    DWORD               nStatus;
    RESID               resid = 0;
    HKEY                hkeyParameters = NULL;
    PVSSTASK_RESOURCE   pResourceEntry = NULL;
    HRESULT             hr = ERROR_SUCCESS;

    //
    // Open the Parameters registry key for this resource.
    //
    nStatus = ClusterRegOpenKey(
                    hkeyResourceKey,
                    L"Parameters",
                    KEY_ALL_ACCESS,
                    &hkeyParameters
                    );
    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to open Parameters key. Error: %1!u!.\n",
            nStatus
            );
        goto Cleanup;
    } // if: error creating the Parameters key for the resource

    //
    // Allocate a resource entry.
    //
    pResourceEntry = static_cast< VSSTASK_RESOURCE * >(
        LocalAlloc( LMEM_FIXED, sizeof( VSSTASK_RESOURCE ) )
        );
    if ( pResourceEntry == NULL )
    {
        nStatus = GetLastError();
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to allocate resource entry structure. Error: %1!u!.\n",
            nStatus
            );
        goto Cleanup;
    } // if: error allocating memory for the resource

    //
    // Initialize the resource entry..
    //
    ZeroMemory( pResourceEntry, sizeof( VSSTASK_RESOURCE ) );

    pResourceEntry->resid = static_cast< RESID >( pResourceEntry ); // for validation
    pResourceEntry->hResourceHandle = hResourceHandle;
    pResourceEntry->hkeyParameters = hkeyParameters;
    pResourceEntry->state = ClusterResourceOffline;

    //
    // Save the name of the resource.
    //
    pResourceEntry->pszResourceName = static_cast< LPWSTR >(
        LocalAlloc( LMEM_FIXED, (lstrlenW( pszResourceName ) + 1) * sizeof( WCHAR ) )
        );
    if ( pResourceEntry->pszResourceName == NULL )
    {
        nStatus = GetLastError();
        goto Cleanup;
    } // if: error allocating memory for the name.
    hr = StringCchCopy( pResourceEntry->pszResourceName, lstrlenW( pszResourceName ) + 1, pszResourceName );
    if ( FAILED( hr ) )
    {
        nStatus = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

    //
    // Open the cluster.
    //
    pResourceEntry->hCluster = OpenCluster( NULL );
    if ( pResourceEntry->hCluster == NULL )
    {
        nStatus = GetLastError();
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to open the cluster. Error: %1!u!.\n",
            nStatus
            );
        goto Cleanup;
    } // if: error opening the cluster

    //
    // Open the resource.
    //
    pResourceEntry->hResource = OpenClusterResource(
                                    pResourceEntry->hCluster,
                                    pszResourceName
                                    );
    if ( pResourceEntry->hResource == NULL )
    {
        nStatus = GetLastError();
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Open: Unable to open the resource. Error: %1!u!.\n",
            nStatus
            );
        goto Cleanup;
    } // if: error opening the resource

    //
    // Startup for the resource.
    //
    // Initialize COM
    //
    hr = CoInitialize(NULL);
    if(FAILED(hr)) 
    {
        (g_pfnLogEvent)(
            hResourceHandle,
            LOG_ERROR,
            L"Failed to initialize COM. status 0x%1!08X!.\n",
            hr );
        nStatus = hr;
        goto Cleanup;
    }

    //
    // Incase there was a task left behind, delete it.  Ignore errors since
    // the task may not really be there or the parameters may not be
    // setup. Don't log to the event log if DeleteTask encounters any failures.
    //
    (void) DeleteTask (hResourceHandle, pszResourceName, LOG_INFORMATION, FALSE);

    nStatus = ERROR_SUCCESS;

    resid = static_cast< RESID >( pResourceEntry );

Cleanup:

    // Cleanup
    //

    if ( resid == 0 )
    {
        if ( hkeyParameters != NULL )
        {
            ClusterRegCloseKey( hkeyParameters );
        } // if: registry key was opened
        if ( pResourceEntry != NULL )
        {
            LocalFree( pResourceEntry->pszResourceName );
            LocalFree( pResourceEntry );
        } // if: resource entry allocated
        ReportEvent(g_LocalEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    RES_VSSTASK_OPEN_FAILED,
                    NULL,
                    1,                        // number of strings to merge
                    sizeof( nStatus ),        // size of binary data
                    (LPCWSTR *)&pszResourceName,
                    (LPVOID)&nStatus);

    } // if: error occurred

    SetLastError( nStatus );

    return resid;

} //*** VSSTaskOpen


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskClose
//
//  Description:
//      Close routine for VSSTask resources.
//
//      Close the specified resource and deallocate all structures, etc.,
//      allocated in the Open call.  If the resource is not in the offline
//      state, then the resource should be taken offline (by calling
//      Terminate) before the close operation is performed.
//
//  Arguments:
//      resid       [IN] Supplies the resource ID  of the resource to close.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI VSSTaskClose( IN RESID resid )
{
    PVSSTASK_RESOURCE   pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PVSSTASK_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "VSSTask: Close request for a nonexistent resource id %p\n",
            resid
            );
        return;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! resid = %1!u!.\n",
            resid
            );
        return;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n"
        );
#endif

    //
    // Close the Parameters key and the handle to the cluster.
    //
    if ( pResourceEntry->hkeyParameters )
    {
        ClusterRegCloseKey( pResourceEntry->hkeyParameters );
    } // if: parameters key is open

    if ( pResourceEntry->hCluster )
    {
        CloseCluster( pResourceEntry->hCluster );
    }

    //
    // Deallocate the resource entry.
    //

    // ADDPARAM: Add new properties here.
	LocalFree( pResourceEntry->propsActive.pszApplicationName );
	LocalFree( pResourceEntry->props.pszApplicationName );
	LocalFree( pResourceEntry->propsActive.pszApplicationParams );
	LocalFree( pResourceEntry->props.pszApplicationParams );
    LocalFree( pResourceEntry->propsActive.pszCurrentDirectory );
    LocalFree( pResourceEntry->props.pszCurrentDirectory );
    LocalFree( pResourceEntry->propsActive.pbTriggerArray );
    LocalFree( pResourceEntry->props.pbTriggerArray );

    LocalFree( pResourceEntry->pszResourceName );
    LocalFree( pResourceEntry );

} //*** VSSTaskClose


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskOnline
//
//  Description:
//      Online routine for VSSTask resources.
//
//      Bring the specified resource online (available for use).  The resource
//      DLL should attempt to arbitrate for the resource if it is present on
//      a shared medium, like a shared SCSI bus.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be brought online
//          (available for use).
//
//      phEventHandle [IN OUT]
//          Returns a signalable handle that is signaled when the resource DLL
//          detects a failure on the resource.  This argument is NULL on
//          input, and the resource DLL returns NULL if asynchronous
//          notification of failurs is not supported.  Otherwise this must be
//          the address of a handle that is signaled on resource failures.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now online.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is pending.  A thread has been activated to process
//          the online request.  The thread that is processing the online
//          request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOnline state (or the resource monitor
//          decides to timeout the online request and Terminate the resource.
//          This pending timeout value is settable and has a default value of
//          3 minutes.).
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI VSSTaskOnline(
    IN      RESID       resid,
    IN OUT  PHANDLE     phEventHandle
    )
{
    PVSSTASK_RESOURCE   pResourceEntry;
    DWORD               nStatus;
   
    UNREFERENCED_PARAMETER( phEventHandle );

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PVSSTASK_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "VSSTask: Online request for a nonexistent resource id %p.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! resid = %1!u!.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n"
        );

    //
    // Start the Online thread to perform the online operation.
    //
    pResourceEntry->state = ClusterResourceOffline;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    nStatus = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( VSSTaskOnlineThread ),
                pResourceEntry
                );
    if ( nStatus != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread. Error: %1!u!.\n",
            nStatus
            );
    } // if: error creating the worker thread
    else
    {
        nStatus = ERROR_IO_PENDING;
    } // if: worker thread created successfully

    return nStatus;

} //*** VSSTaskOnline


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskOnlineThread
//
//  Description:
//      Worker function which brings a resource online.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the VSSTASK_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//  Notes:
//      When using properties in this routine it is recommended that you
//      use the properties in propsActive of the VSSTASK_RESOURCE struct
//      instead of the properties in props.  The primary reason you should
//      use propsActive is that the properties in props could be changed by
//      the SetPrivateResProperties() routine.  Using propsActive allows
//      the online state of the resource to be steady while still allowing
//      an administrator to change the stored value of the properties.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI VSSTaskOnlineThread(
    IN  PCLUS_WORKER        pWorker,
    IN  PVSSTASK_RESOURCE   pResourceEntry
    )
{
    RESOURCE_STATUS         resourceStatus;
    DWORD                   nStatus = ERROR_SUCCESS;
    LPWSTR                  pszNameOfPropInError;
    HRESULT                 hr;
    ITaskScheduler         *pITS = NULL;
    ITask                   *pITask = NULL;
    IPersistFile            *pIPersistFile = NULL;
    ITaskTrigger            *pITaskTrigger = NULL;
    PTASK_TRIGGER           pTrigger;
    WORD                    piNewTrigger;
    DWORD                   dwOffset;
    LPWSTR                  pszAppParams = L"";
    WCHAR                   pszDefaultWorkingDir[] = L"%windir%\\system32";
    LPWSTR                  pszWorkingDir = pszDefaultWorkingDir;

    WCHAR   expandedWorkingDirBuffer[ MAX_PATH ];
    PWCHAR  expandedWorkingDir = expandedWorkingDirBuffer;
    DWORD   expandedWorkingDirChars = sizeof( expandedWorkingDirBuffer ) / sizeof( WCHAR );
    DWORD   charsNeeded;


    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //
    // Read properties.
    //
    nStatus = ResUtilGetPropertiesToParameterBlock(
                pResourceEntry->hkeyParameters,
                VSSTaskResourcePrivateProperties,
                reinterpret_cast< LPBYTE >( &pResourceEntry->propsActive ),
                TRUE, // CheckForRequiredProperties
                &pszNameOfPropInError
                );
    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Unable to read the '%1' property. Error: %2!u!.\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            nStatus
            );
        goto Cleanup;
    } // if: error getting properties

    //
    // Start the schedule service
    // The call to ClusWorkerCheckTerminate checks to see if this resource
    // has been terminated, in which case it should not start the service.
    //
    if ( ! ClusWorkerCheckTerminate( pWorker ) )
    {
        nStatus = ResUtilStartResourceService( TASKSCHEDULER_SVCNAME, NULL );
        if ( nStatus == ERROR_SERVICE_ALREADY_RUNNING )
        {
            nStatus = ERROR_SUCCESS;
        } // if: service was already started
        else if ( nStatus != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // else if: error starting the service
    } // if: resource has not been terminated
    else
    {
        goto Cleanup;
    } // else: resource has been terminated

    //
    // Bring the resource online.
    // The call to ClusWorkerCheckTerminate checks to see if this resource
    // has been terminated, in which case it should not be brought online.
    //
    if ( ! ClusWorkerCheckTerminate( pWorker ) )
    {
        //
        // Bring the resource online.
        //

        // Get a handle to the Task Scheduler
        //
        hr = CoCreateInstance(CLSID_CTaskScheduler,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ITaskScheduler,
                              (void **) &pITS);
        if (FAILED(hr))
        {
           (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to get a handle to Scheduler. status 0x%1!08X!.\n",
                hr );
           nStatus = hr;
           goto Cleanup;
        }

        //
        // Create a new task
        //
        hr = pITS->NewWorkItem(pResourceEntry->pszResourceName, // Name of task
                               CLSID_CTask,                     // Class identifier 
                               IID_ITask,                       // Interface identifier
                               (IUnknown**)&pITask);            // Address of task interface

        if (FAILED(hr))
        {
           (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to create a new task. status 0x%1!08X!.\n",
                hr );
           nStatus = hr;
           goto Cleanup;
        }


        // Set the application name and parameters
        //
        hr = pITask->SetApplicationName(pResourceEntry->propsActive.pszApplicationName);
        if (FAILED(hr))
        {
           (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to set the application name. status 0x%1!08X!.\n",
                hr );
           nStatus = hr;
           goto Cleanup;
        }

        //
        // SetParameters barfs if you pass in a NULL; if no parameters are
        // associated with the task, pass in the NULL string. Sheesh!
        //
        if ( pResourceEntry->propsActive.pszApplicationParams != NULL )
        {
            pszAppParams = pResourceEntry->propsActive.pszApplicationParams;
        }

        hr = pITask->SetParameters( pszAppParams );
        if (FAILED(hr))
        {
           (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to set the application parameters. status 0x%1!08X!.\n",
                hr );
           nStatus = hr;
           goto Cleanup;
        }

        // Setup the task to run as SYSTEM. if no working driectory is
        // specified then default to system32
        //
        hr = pITask->SetAccountInformation(L"",NULL);

        if (FAILED(hr))
        {
           (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to set the account to SYSTEM. status 0x%1!08X!.\n",
                hr );
           nStatus = hr;
           goto Cleanup;
        }

        if ( pResourceEntry->propsActive.pszCurrentDirectory != NULL && 
             *pResourceEntry->propsActive.pszCurrentDirectory != NULL
             )
        {
            pszWorkingDir = pResourceEntry->propsActive.pszCurrentDirectory;
        }

        //
        // Since our property (and the default) is an expand SZ, we need
        // to expand it now otherwise the TS will literally interpret it
        // as the directory. It's important to do this since %windir% on a
        // cluster might evaluate to different directories on each node.
        //
reexpand:
        charsNeeded = ExpandEnvironmentStrings(pszWorkingDir,
                                               expandedWorkingDir,
                                               expandedWorkingDirChars);

        if ( expandedWorkingDirChars < charsNeeded ) {
            expandedWorkingDir = (PWCHAR)LocalAlloc( 0, charsNeeded * sizeof( WCHAR ));
            if ( expandedWorkingDir == NULL ) {
                nStatus = GetLastError();
                (g_pfnLogEvent)(pResourceEntry->hResourceHandle,
                                LOG_WARNING,
                                L"VSSTaskOnlineThread: Failed to allocate memory for "
                                L"expanded CurrentDirectory path. status %1!u!.\n",
                                nStatus );
            }

            expandedWorkingDirChars = charsNeeded;
            goto reexpand;
        }
        else if ( charsNeeded == 0 ) {
            nStatus = GetLastError();
            (g_pfnLogEvent)(pResourceEntry->hResourceHandle,
                            LOG_WARNING,
                            L"VSSTaskOnlineThread: Failed to expand environment variables in "
                            L"CurrentDirectory. status %1!u!.\n",
                            nStatus );
        }
                
        hr = pITask->SetWorkingDirectory( expandedWorkingDir );
        if (FAILED(hr))
        {
           (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to set the working directory to %1!ws!. status 0x%2!08X!.\n",
                pszWorkingDir,
                hr );
           nStatus = hr;
           goto Cleanup;
        }

        if ( expandedWorkingDir != expandedWorkingDirBuffer ) {
            LocalFree( expandedWorkingDir );
        }

        //
        // set the creator as the cluster service to distinguish how this
        // task was created. It is non-fatal if it couldn't be set.
        //
        hr = pITask->SetCreator( L"Cluster Service" );
        if (FAILED(hr))
        {
           (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_WARNING,
                L"Failed to set the creator to the Cluster Service. status 0x%1!08X!.\n",
                hr );
        }

        //
        // Create a trigger from the parameters and attach it to the task
        //
        dwOffset = 0;
        while (dwOffset < pResourceEntry->propsActive.nTriggerArraySize)
        {
            pTrigger = (PTASK_TRIGGER)((BYTE *)pResourceEntry->propsActive.pbTriggerArray + dwOffset);
            if (dwOffset + pTrigger->cbTriggerSize > pResourceEntry->propsActive.nTriggerArraySize)
            {
               (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Incomplete Trigger structure stored in parameter block\n");
               nStatus = ERROR_INVALID_PARAMETER;
               break;
            }

            hr = pITask->CreateTrigger(&piNewTrigger, &pITaskTrigger);

            if (FAILED(hr))
            {
               (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Failed to create a trigger. status 0x%1!08X!.\n",
                    hr );
               nStatus = hr;
               break;
            }

            hr = pITaskTrigger->SetTrigger (pTrigger);

            if (FAILED(hr))
            {
               (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Failed to create a trigger. status 0x%1!08X!.\n",
                    hr );
               nStatus = hr;
               break;
            }

            dwOffset += pTrigger->cbTriggerSize;
	
        } // while: 

        if (nStatus != ERROR_SUCCESS) 
        {
            goto Cleanup;
        }

        //
        // Persist the task; when Is/LooksAlive is called, we'll try to
        // find the task. The only way this succeeds is if the task is
        // persisted to the Tasks folder. You'd think the task scheduler
        // would know about these tasks internally but it seems to base
        // task existence on the state of the backing file.
        //
        hr = pITask->QueryInterface(IID_IPersistFile,
                                    (void **)&pIPersistFile);

        if (FAILED(hr))
        {
           (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to QueryInterface for IPersistFile. status 0x%1!08X!.\n",
                hr );
           nStatus = hr;
           goto Cleanup;
        }

        hr = pIPersistFile->Save(NULL, TRUE);
        if (FAILED(hr))
        {
           (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to make the new task persistent. status 0x%1!08X!.\n",
                hr );
           nStatus = hr;
           goto Cleanup;
        }

        if ( nStatus == ERROR_SUCCESS )
        {
            resourceStatus.ResourceState = ClusterResourceOnline;
        } // if: resource brought online
    } // if: resource has not been terminated

Cleanup:

    // Cleanup
    if (pITS != NULL) pITS->Release();
    if (pITask != NULL) pITask->Release();
    if (pIPersistFile != NULL) pIPersistFile->Release();
    if (pITaskTrigger != NULL) pITaskTrigger->Release();

    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Error %1!u! bringing resource online.\n",
            nStatus
            );
            ReportEvent(g_LocalEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        RES_VSSTASK_ONLINE_FAILED,
                        NULL,
                        1,                        // number of strings to merge
                        sizeof( nStatus ),        // size of binary data
                        (LPCWSTR *)&pResourceEntry->pszResourceName,
                        (LPVOID)&nStatus);

    } // if: error occurred

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return nStatus;

} //*** VSSTaskOnlineThread


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskOffline
//
//  Description:
//      Offline routine for VSSTask resources.
//
//      Take the specified resource offline (unavailable for use).  Wait
//      for any cleanup operations to complete before returning.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          gracefully.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now offline.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is still pending.  A thread has been activated to
//          process the offline request.  The thread that is processing the
//          offline request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOffline state (or the resource monitor
//          decides  to timeout the offline request and Terminate the
//          resource).
//
//      Win32 error code
//          The operation failed.  This will cause the Resource Monitor to
//          log an event and call the Terminate routine.
//
//  Notes:
//      When using properties in this routine it is recommended that you
//      use the properties in propsActive of the VSSTASK_RESOURCE struct
//      instead of the properties in props.  The primary reason you should
//      use propsActive is that the properties in props could be changed by
//      the SetPrivateResProperties() routine.  Using propsActive allows
//      the online state of the resource to be steady while still allowing
//      an administrator to change the stored value of the properties.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI VSSTaskOffline( IN RESID resid )
{
    PVSSTASK_RESOURCE   pResourceEntry;
    DWORD               nStatus;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PVSSTASK_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "VSSTask: Offline request for a nonexistent resource id %p\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! resid = %1!u!.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n"
        );

    //
    // Start the Offline thread to perform the offline operation.
    //
    pResourceEntry->state = ClusterResourceOfflinePending;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    nStatus = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( VSSTaskOfflineThread ),
                pResourceEntry
                );
    if ( nStatus != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline: Unable to start thread. Error: %1!u!.\n",
            nStatus
            );
    } // if: error creating the worker thread
    else
    {
        nStatus = ERROR_IO_PENDING;
    } // if: worker thread created successfully

    return nStatus;

} //*** VSSTaskOffline


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskOfflineThread
//
//  Description:
//      Worker function which takes a resource offline.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the VSSTASK_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//  Notes:
//      When using properties in this routine it is recommended that you
//      use the properties in propsActive of the VSSTASK_RESOURCE struct
//      instead of the properties in props.  The primary reason you should
//      use propsActive is that the properties in props could be changed by
//      the SetPrivateResProperties() routine.  Using propsActive allows
//      the online state of the resource to be steady while still allowing
//      an administrator to change the stored value of the properties.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI VSSTaskOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PVSSTASK_RESOURCE   pResourceEntry
    )
{
    RESOURCE_STATUS     resourceStatus;
    DWORD               nStatus = ERROR_SUCCESS;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //
    // Take the resource offline.
    // The call to ClusWorkerCheckTerminate checks to see if this
    // resource has been terminated or not.
    //
    if ( ! ClusWorkerCheckTerminate( pWorker ) )
    {
        // Blow away the task
        //
        nStatus = DeleteTask (pResourceEntry->hResourceHandle,
                              pResourceEntry->pszResourceName,
                              LOG_ERROR,
                              TRUE);           // log to event log

        if ( nStatus == ERROR_SUCCESS )
        {
            resourceStatus.ResourceState = ClusterResourceOffline;
        } // if: resource taken offline successfully
        else
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OfflineThread: Error %1!u! taking resource offline.\n",
                nStatus
                );
        } // else: error taking the resource offline
    } // if: resource not terminated

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return nStatus;

} //*** VSSTaskOfflineThread


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskTerminate
//
//  Description:
//      Terminate routine for VSSTask resources.
//
//      Take the specified resource offline immediately (the resource is
//      unavailable for use).
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          ungracefully.
//
//  Return Value:
//      None.
//
//  Notes:
//      When using properties in this routine it is recommended that you
//      use the properties in propsActive of the VSSTASK_RESOURCE struct
//      instead of the properties in props.  The primary reason you should
//      use propsActive is that the properties in props could be changed by
//      the SetPrivateResProperties() routine.  Using propsActive allows
//      the online state of the resource to be steady while still allowing
//      an administrator to change the stored value of the properties.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI VSSTaskTerminate( IN RESID resid )
{
    PVSSTASK_RESOURCE   pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PVSSTASK_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "VSSTask: Terminate request for a nonexistent resource id %p\n",
            resid
            );
        return;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! resid = %1!u!.\n",
            resid
            );
        return;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n"
        );

    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );

    //
    // Terminate the resource.
    //
    (void) DeleteTask (pResourceEntry->hResourceHandle,
                       pResourceEntry->pszResourceName,
                       LOG_ERROR,
                       TRUE);           // log to event log

    pResourceEntry->state = ClusterResourceOffline;

} //*** VSSTaskTerminate


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskLooksAlive
//
//  Description:
//      LooksAlive routine for VSSTask resources.
//
//      Perform a quick check to determine if the specified resource is
//      probably online (available for use).  This call should not block for
//      more than 300 ms, preferably less than 50 ms.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is probably online and available for use.
//
//      FALSE
//          The specified resource is not functioning normally.  The IsAlive
//          function will be called to perform a more thorough check.
//
//  Notes:
//      When using properties in this routine it is recommended that you
//      use the properties in propsActive of the VSSTASK_RESOURCE struct
//      instead of the properties in props.  The primary reason you should
//      use propsActive is that the properties in props could be changed by
//      the SetPrivateResProperties() routine.  Using propsActive allows
//      the online state of the resource to be steady while still allowing
//      an administrator to change the stored value of the properties.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI VSSTaskLooksAlive( IN RESID resid )
{
    PVSSTASK_RESOURCE   pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PVSSTASK_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "VSSTask: LooksAlive request for a nonexistent resource id %p\n",
            resid
            );
        return FALSE;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! resid = %1!u!.\n",
            resid
            );
        return FALSE;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n"
        );
#endif

    //
    // Check to see if the resource is alive.
    //
    return VSSTaskCheckIsAlive( pResourceEntry, FALSE /* bFullCheck */ );

} //*** VSSTaskLooksAlive


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskIsAlive
//
//  Description:
//      IsAlive routine for VSSTask resources.
//
//      Perform a thorough check to determine if the specified resource is
//      online (available for use).  This call should not block for more
//      more than 300 ms, preferably less than 50 ms.  If it must block for
//      longer than this, create a separate thread dedicated to polling for
//      this information and have this routine return the status of the last
//      poll performed.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is online and functioning normally.
//
//      FALSE
//          The specified resource is not functioning normally.  The resource
//          will be terminated and then Online will be called.
//
//  Notes:
//      When using properties in this routine it is recommended that you
//      use the properties in propsActive of the VSSTASK_RESOURCE struct
//      instead of the properties in props.  The primary reason you should
//      use propsActive is that the properties in props could be changed by
//      the SetPrivateResProperties() routine.  Using propsActive allows
//      the online state of the resource to be steady while still allowing
//      an administrator to change the stored value of the properties.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI VSSTaskIsAlive( IN RESID resid )
{
    PVSSTASK_RESOURCE   pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PVSSTASK_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "VSSTask: IsAlive request for a nonexistent resource id %p\n",
            resid
            );
        return FALSE;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! resid = %1!u!.\n",
            resid
            );
        return FALSE;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n"
        );
#endif

    //
    // Check to see if the resource is alive.
    //
    return VSSTaskCheckIsAlive( pResourceEntry, TRUE /* bFullCheck */ );

} //** VSSTaskIsAlive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskCheckIsAlive
//
//  Description:
//      Check to see if the resource is alive for VSSTask
//      resources.
//
//  Arguments:
//      pResourceEntry  [IN]
//          Supplies the resource entry for the resource to polled.
//
//      bFullCheck [IN]
//          TRUE = Perform a full check.
//          FALSE = Perform a cursory check.
//
//  Return Value:
//      TRUE    The specified resource is online and functioning normally.
//      FALSE   The specified resource is not functioning normally.
//
//  Notes:
//      When using properties in this routine it is recommended that you
//      use the properties in propsActive of the VSSTASK_RESOURCE struct
//      instead of the properties in props.  The primary reason you should
//      use propsActive is that the properties in props could be changed by
//      the SetPrivateResProperties() routine.  Using propsActive allows
//      the online state of the resource to be steady while still allowing
//      an administrator to change the stored value of the properties.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL VSSTaskCheckIsAlive(
    IN PVSSTASK_RESOURCE    pResourceEntry,
    IN BOOL             bFullCheck
    )
{
    BOOL            bIsAlive = TRUE;
    ITaskScheduler  *pITS = NULL;
    ITask           *pITask = NULL;
    HRESULT         hr = ERROR_SUCCESS;

    //
    // Check to see if the resource is alive.
    //

    // Get a handle to the Task Scheduler
    //
    hr = CoCreateInstance(CLSID_CTaskScheduler,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITaskScheduler,
                          (void **) &pITS);
    if (FAILED(hr))
    {
       (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Failed to get a handle to Scheduler. status 0x%1!08X!.\n",
            hr );
       bIsAlive = FALSE;
       goto Cleanup;
    }

    //
    // Get a handle to the task
    //
    hr = pITS->Activate(pResourceEntry->pszResourceName,
                        IID_ITask,
                        (IUnknown**) &pITask);
    if (FAILED(hr))
    {
       (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Could not find the task in IsAlive. status 0x%1!08X!.\n",
            hr );
       bIsAlive = FALSE;
       goto Cleanup;
    }

    if ( bFullCheck )
    {
        // TODO: Add code to perform a full check.
    } // if: performing a full check

Cleanup:

    // Cleanup code
    //
    if (pITask != NULL) pITask->Release();
    if (pITS != NULL) pITS->Release();

    return bIsAlive;

} //*** VSSTaskCheckIsAlive


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskResourceControl
//
//  Description:
//      ResourceControl routine for VSSTask resources.
//
//      Perform the control request specified by nControlCode on the specified
//      resource.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID for the specific resource.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI VSSTaskResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD               nStatus;
    PVSSTASK_RESOURCE   pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PVSSTASK_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "VSSTask: ResourceControl request for a nonexistent resource id %p\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! resid = %1!u!.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    switch ( nControlCode )
    {
        case CLUSCTL_RESOURCE_UNKNOWN:
            *pcbBytesReturned = 0;
            nStatus = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
        {
            DWORD cbRequired = 0;
            nStatus = ResUtilEnumProperties(
                            VSSTaskResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( nStatus == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;
        }

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            nStatus = VSSTaskGetPrivateResProperties(
                            pResourceEntry,
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            nStatus = VSSTaskValidatePrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize,
                            NULL
                            );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            nStatus = VSSTaskSetPrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize
                            );
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            nStatus = VSSTaskSetNameHandler(
                            pResourceEntry,
                            static_cast< LPWSTR >( pInBuffer )
                            );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
        case CLUSCTL_RESOURCE_STORAGE_IS_PATH_VALID:
        case CLUSCTL_RESOURCE_DELETE:
        case CLUSCTL_RESOURCE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_EVICT_NODE:
        case CLUSCTL_RESOURCE_ADD_DEPENDENCY:
        case CLUSCTL_RESOURCE_REMOVE_DEPENDENCY:
        case CLUSCTL_RESOURCE_ADD_OWNER:
        case CLUSCTL_RESOURCE_REMOVE_OWNER:
        case CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED:
        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
        default:
            nStatus = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

    return nStatus;

} //*** VSSTaskResourceControl


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskResourceTypeControl
//
//  Description:
//      ResourceTypeControl routine for VSSTask resources.
//
//      Perform the control request specified by nControlCode.
//
//  Arguments:
//      pszResourceTypeName [IN]
//          Supplies the name of the resource type.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI VSSTaskResourceTypeControl(
    IN  LPCWSTR pszResourceTypeName,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD   nStatus;

    UNREFERENCED_PARAMETER( pszResourceTypeName );
    UNREFERENCED_PARAMETER( pInBuffer );
    UNREFERENCED_PARAMETER( cbInBufferSize );

    switch ( nControlCode )
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *pcbBytesReturned = 0;
            nStatus = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
        {
            DWORD cbRequired = 0;
            nStatus = ResUtilEnumProperties(
                            VSSTaskResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( nStatus == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;
        }

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS:
        case CLUSCTL_RESOURCE_TYPE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_TYPE_EVICT_NODE:
        default:
            nStatus = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

    return nStatus;

} //*** VSSTaskResourceTypeControl


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskGetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control
//      function for resources of type VSSTask.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD VSSTaskGetPrivateResProperties(
    IN OUT  PVSSTASK_RESOURCE   pResourceEntry,
    OUT     PVOID               pOutBuffer,
    IN      DWORD               cbOutBufferSize,
    OUT     LPDWORD             pcbBytesReturned
    )
{
    DWORD   nStatus;
    DWORD   cbRequired = 0;

    nStatus = ResUtilGetAllProperties(
                    pResourceEntry->hkeyParameters,
                    VSSTaskResourcePrivateProperties,
                    pOutBuffer,
                    cbOutBufferSize,
                    pcbBytesReturned,
                    &cbRequired
                    );
    if ( nStatus == ERROR_MORE_DATA )
    {
        *pcbBytesReturned = cbRequired;
    } // if: output buffer is too small

    return nStatus;

} //*** VSSTaskGetPrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskValidatePrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
//      function for resources of type VSSTask.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pProps [OUT]
//          Supplies the parameter block to fill in (optional).
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD VSSTaskValidatePrivateResProperties(
    IN OUT  PVSSTASK_RESOURCE   pResourceEntry,
    IN      PVOID               pInBuffer,
    IN      DWORD               cbInBufferSize,
    OUT     PVSSTASK_PROPS  pProps
    )
{
    DWORD           nStatus = ERROR_SUCCESS;
    VSSTASK_PROPS   propsCurrent;
    VSSTASK_PROPS   propsNew;
    PVSSTASK_PROPS  pLocalProps = NULL;
    LPWSTR          pszNameOfPropInError;
    BOOL            bRetrievedProps = FALSE;

    //
    // Check if there is input data.
    //
    if (    (pInBuffer == NULL)
        ||  (cbInBufferSize < sizeof( DWORD )) )
    {
        nStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    } // if: no input buffer or input buffer not big enough to contain property list

    //
    // Retrieve the current set of private properties from the
    // cluster database.
    //
    ZeroMemory( &propsCurrent, sizeof( propsCurrent ) );

    nStatus = ResUtilGetPropertiesToParameterBlock(
                 pResourceEntry->hkeyParameters,
                 VSSTaskResourcePrivateProperties,
                 reinterpret_cast< LPBYTE >( &propsCurrent ),
                 FALSE, /*CheckForRequiredProperties*/
                 &pszNameOfPropInError
                 );

    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            nStatus
            );
        goto Cleanup;
    } // if: error getting properties
    bRetrievedProps = TRUE;

    //
    // Duplicate the resource parameter block.
    //
    if ( pProps == NULL )
    {
        pLocalProps = &propsNew;
    } // if: no parameter block passed in
    else
    {
        pLocalProps = pProps;
    } // else: parameter block passed in

    ZeroMemory( pLocalProps, sizeof( VSSTASK_PROPS ) );
    nStatus = ResUtilDupParameterBlock(
                    reinterpret_cast< LPBYTE >( pLocalProps ),
                    reinterpret_cast< LPBYTE >( &propsCurrent ),
                    VSSTaskResourcePrivateProperties
                    );
    if ( nStatus != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error duplicating the parameter block

    //
    // Parse and validate the properties.
    //
    nStatus = ResUtilVerifyPropertyTable(
                    VSSTaskResourcePrivateProperties,
                    NULL,
                    TRUE, // AllowUnknownProperties
                    pInBuffer,
                    cbInBufferSize,
                    reinterpret_cast< LPBYTE >( pLocalProps )
                    );
    if ( nStatus == ERROR_SUCCESS )
    {
        //
        // Validate the property values.
        //
        // TODO: Code to validate interactions between properties goes here.
    } // if: property list validated successfully

Cleanup:

    //
    // Cleanup our parameter block.
    //
    if (    (pLocalProps == &propsNew)
        ||  (   (nStatus != ERROR_SUCCESS)
            &&  (pLocalProps != NULL)
            )
        )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( pLocalProps ),
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            VSSTaskResourcePrivateProperties
            );
    } // if: we duplicated the parameter block

    if ( bRetrievedProps )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            NULL,
            VSSTaskResourcePrivateProperties
            );
    } // if: properties were retrieved

    return nStatus;

} // VSSTaskValidatePrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskSetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control
//      function for resources of type VSSTask.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD VSSTaskSetPrivateResProperties(
    IN OUT  PVSSTASK_RESOURCE   pResourceEntry,
    IN      PVOID               pInBuffer,
    IN      DWORD               cbInBufferSize
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    VSSTASK_PROPS   props;

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    nStatus = VSSTaskValidatePrivateResProperties( pResourceEntry, pInBuffer, cbInBufferSize, &props );
    if ( nStatus == ERROR_SUCCESS )
    {
        //
        // Save the property values.
        //
        nStatus = ResUtilSetPropertyParameterBlock(
                        pResourceEntry->hkeyParameters,
                        VSSTaskResourcePrivateProperties,
                        NULL,
                        reinterpret_cast< LPBYTE >( &props ),
                        pInBuffer,
                        cbInBufferSize,
                        reinterpret_cast< LPBYTE >( &pResourceEntry->props )
                        );

        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( &props ),
            reinterpret_cast< LPBYTE >( &pResourceEntry->props ),
            VSSTaskResourcePrivateProperties
            );

        //
        // If the resource is online, return a non-success status.
        //
        if ( nStatus == ERROR_SUCCESS )
        {
            if ( pResourceEntry->state == ClusterResourceOnline )
            {
                nStatus = ERROR_RESOURCE_PROPERTIES_STORED;
            } // if: resource is currently online
            else if ( pResourceEntry->state == ClusterResourceOnlinePending )
            {
                nStatus = ERROR_RESOURCE_PROPERTIES_STORED;
            } // else if: resource is currently in online pending
            else
            {
                nStatus = ERROR_SUCCESS;
            } // else: resource is in some other state
        } // if: properties set successfully
    } // if: no error validating properties

    return nStatus;

} //*** VSSTaskSetPrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  VSSTaskSetNameHandler
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_SET_NAME control code by renaming the
//      backing task file and saving the new name of the resource.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pszName [IN]
//          The new name of the resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD VSSTaskSetNameHandler(
    IN OUT  PVSSTASK_RESOURCE   pResourceEntry,
    IN      LPWSTR              pszName
    )
{
    DWORD   nStatus = ERROR_SUCCESS;
    LPWSTR  oldResourceName = NULL;
    HKEY    taskKey = NULL;
    DWORD   valueType;
    HRESULT hr = S_OK;

    WCHAR   tasksFolderPathBuffer[ MAX_PATH ];
    PWCHAR  tasksFolderPath = tasksFolderPathBuffer;
    DWORD   tasksFolderPathBytes = sizeof( tasksFolderPathBuffer );

    WCHAR   expandedTasksFolderPathBuffer[ MAX_PATH ];
    PWCHAR  expandedTasksFolderPath = expandedTasksFolderPathBuffer;
    DWORD   expandedTasksFolderPathChars = sizeof( expandedTasksFolderPathBuffer ) / sizeof( WCHAR );

    WCHAR   oldTaskFileNameBuffer[ MAX_PATH ];
    PWCHAR  oldTaskFileName = oldTaskFileNameBuffer;
    size_t  oldTaskFileNameChars;

    size_t  newTaskFileNameChars;
    WCHAR   newTaskFileNameBuffer[ MAX_PATH ];
    PWCHAR  newTaskFileName = newTaskFileNameBuffer;

    WCHAR   jobExtension[] = L".job";
    WCHAR   directorySeparator[] = L"\\";
    BOOL    success;
    DWORD   charsNeeded;        // for expanded tasks folder path

    //
    // this stinks. We can't veto the rename so if we can't rename the old
    // task, we'll continue to use the old name.
    //
    // Get the tasks folder (via the registry, ick!) and rename the old
    // task file. The task scheduler automatically picks up the rename.
    //
    nStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           L"SOFTWARE\\Microsoft\\SchedulingAgent",
                           0,
                           KEY_QUERY_VALUE,
                           &taskKey);

    if ( nStatus != ERROR_SUCCESS ) {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_WARNING,
            L"VSSTaskSetNameHandler: Unable to determine location of Tasks folder. "
            L"Continueing to use old resource name for task name. status %1!u!.\n",
            nStatus );
        goto Cleanup;
    }

requery:
    nStatus = RegQueryValueEx(taskKey,
                              L"TasksFolder",
                              0,
                              &valueType,
                              (LPBYTE)tasksFolderPath,
                              &tasksFolderPathBytes);

    if ( nStatus == ERROR_MORE_DATA ) {
        tasksFolderPath = (PWCHAR)LocalAlloc( 0, tasksFolderPathBytes );
        if ( tasksFolderPath == NULL ) {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_WARNING,
                L"VSSTaskSetNameHandler: Failed to allocate memory for Task folder path. "
                L"Continueing to use old resource name for task name. status %1!u!.\n",
                nStatus );
            goto Cleanup;
        }
        goto requery;
    }
    else if ( nStatus != ERROR_SUCCESS ) {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_WARNING,
            L"VSSTaskSetNameHandler: Failed query for location of Tasks folder. "
            L"Continueing to use old resource name for task name. status %1!u!.\n",
            nStatus );
        goto Cleanup;
    }

reexpand:
    charsNeeded = ExpandEnvironmentStrings(
        tasksFolderPath,
        expandedTasksFolderPath,
        expandedTasksFolderPathChars);

    if ( expandedTasksFolderPathChars < charsNeeded ) {
        expandedTasksFolderPath = (PWCHAR)LocalAlloc( 0, charsNeeded * sizeof( WCHAR ));
        if ( expandedTasksFolderPath == NULL ) {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_WARNING,
                L"VSSTaskSetNameHandler: Failed to allocate memory for expanded Task folder path. "
                L"Continueing to use old resource name for task name. status %1!u!.\n",
                nStatus );
            goto Cleanup;
        }

        expandedTasksFolderPathChars = charsNeeded;
        goto reexpand;
    }
    else if ( charsNeeded == 0 ) {
        nStatus = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_WARNING,
            L"VSSTaskSetNameHandler: Failed to expand Tasks folder path. "
            L"Continueing to use old resource name for task name. status %1!u!.\n",
            nStatus );
        goto Cleanup;
    }

    //
    // calc the size of the old and new file names. Each "- 1" is
    // subtracting out the null char associated with the particular char
    // count.
    //
    oldTaskFileNameChars = expandedTasksFolderPathChars - 1 +
        RTL_NUMBER_OF( directorySeparator ) - 1 +
        wcslen( pResourceEntry->pszResourceName ) +
        RTL_NUMBER_OF( jobExtension );

    newTaskFileNameChars = expandedTasksFolderPathChars - 1 +
        RTL_NUMBER_OF( directorySeparator ) - 1 +
        wcslen( pszName ) +
        RTL_NUMBER_OF( jobExtension );

    if ( oldTaskFileNameChars > RTL_NUMBER_OF( oldTaskFileNameBuffer )) {
        oldTaskFileName = (PWCHAR)LocalAlloc( 0, oldTaskFileNameChars * sizeof( WCHAR ));
        if ( oldTaskFileName == NULL ) {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_WARNING,
                L"VSSTaskSetNameHandler: Failed to allocate memory for old Task file name. "
                L"Continueing to use old resource name for task name. status %1!u!.\n",
                nStatus );
            goto Cleanup;
        }
    }

    if ( newTaskFileNameChars > RTL_NUMBER_OF( newTaskFileNameBuffer )) {
        newTaskFileName = (PWCHAR)LocalAlloc( 0, newTaskFileNameChars * sizeof( WCHAR ));
        if ( newTaskFileName == NULL ) {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_WARNING,
                L"VSSTaskSetNameHandler: Failed to allocate memory for new Task file name. "
                L"Continueing to use old resource name for task name. status %1!u!.\n",
                nStatus );
            goto Cleanup;
        }
    }

    oldTaskFileName[ oldTaskFileNameChars - 1 ] = UNICODE_NULL;
    hr = StringCchPrintfW(oldTaskFileName,
               oldTaskFileNameChars,
               L"%ws%ws%ws%ws",
               expandedTasksFolderPath,
               directorySeparator,
               pResourceEntry->pszResourceName,
               jobExtension );
    if ( FAILED( hr ) )
    {
        nStatus = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

    newTaskFileName[ newTaskFileNameChars - 1 ] = UNICODE_NULL;
    hr = StringCchPrintfW(newTaskFileName,
               newTaskFileNameChars,
               L"%ws%ws%ws%ws",
               expandedTasksFolderPath,
               directorySeparator,
               pszName,
               jobExtension );
    if ( FAILED( hr ) )
    {
        nStatus = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

    success = MoveFile( oldTaskFileName, newTaskFileName );
    if ( !success ) {
        nStatus = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_WARNING,
            L"VSSTaskSetNameHandler: Failed to rename Task file %1!ws! to %2!ws!. "
            L"Continueing to use %1!ws! as the task name. status %3!u!.\n",
            oldTaskFileName,
            newTaskFileName,
            nStatus );
        goto Cleanup;
    }

    //
    // new name is available; remember the old resource (task) name so we
    // can clean up later on.
    //
    oldResourceName = pResourceEntry->pszResourceName;

    //
    // Save the name of the resource.
    //
    pResourceEntry->pszResourceName = static_cast< LPWSTR >(
        LocalAlloc( LMEM_FIXED, (lstrlenW( pszName ) + 1) * sizeof( WCHAR ) )
        );

    if ( pResourceEntry->pszResourceName == NULL )
    {
        nStatus = GetLastError();
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"VSSTaskSetNameHandler: Failed to allocate memory for the new resource name '%1'. "
            L"Task name remains %2!ws!. status %3!u!.\n",
            pszName,
            pResourceEntry->pszResourceName,
            nStatus );

        pResourceEntry->pszResourceName = oldResourceName;
        oldResourceName = NULL;
        goto Cleanup;
    } // if: error allocating memory for the name.

    //
    // capture the new name and free the old buffer
    //
    hr = StringCchCopyW( pResourceEntry->pszResourceName, lstrlenW( pszName ) + 1, pszName );
    if ( FAILED( hr ) )
    {
        nStatus = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

Cleanup:

    LocalFree( oldResourceName );

    if ( newTaskFileName != newTaskFileNameBuffer ) {
        LocalFree( newTaskFileName );
    }

    if ( oldTaskFileName != oldTaskFileNameBuffer ) {
        LocalFree( oldTaskFileName );
    }

    if ( expandedTasksFolderPath != expandedTasksFolderPathBuffer ) {
        LocalFree( expandedTasksFolderPath );
    }

    if ( tasksFolderPath != tasksFolderPathBuffer ) {
        LocalFree( tasksFolderPath );
    }

    if ( taskKey != NULL ) {
        RegCloseKey( taskKey );
    }

    return nStatus;

} //*** VSSTaskSetNameHandler


/////////////////////////////////////////////////////////////////////////////
//
// Define Function Table
//
/////////////////////////////////////////////////////////////////////////////

CLRES_V1_FUNCTION_TABLE(
    g_VSSTaskFunctionTable,         // Name
    CLRES_VERSION_V1_00,            // Version
    VSSTask,                        // Prefix
    NULL,                           // Arbitrate
    NULL,                           // Release
    VSSTaskResourceControl,         // ResControl
    VSSTaskResourceTypeControl      // ResTypeControl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      BasePage.cpp
//
//  Description:
//      Implementation of the CBasePropertyPage class.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSSTaskEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CBasePropertyPage, CPropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CBasePropertyPage, CPropertyPage )
    //{{AFX_MSG_MAP(CBasePropertyPage)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage( void )
{
    CommonConstruct();

} //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pdwHelpMap          [IN] Control-to-help ID map.
//      pdwWizardHelpMap    [IN] Control-to-help ID map if this is a wizard page.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN const DWORD *    pdwHelpMap,
    IN const DWORD *    pdwWizardHelpMap
    )
    : m_dlghelp( pdwHelpMap, 0 )
{
    CommonConstruct();
    m_pdwWizardHelpMap = pdwWizardHelpMap;

} //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      nIDTemplate         [IN] Dialog template resource ID.
//      pdwHelpMap          [IN] Control-to-help ID map.
//      pdwWizardHelpMap    [IN] Control-to-help ID map if this is a wizard page.
//      nIDCaption          [IN] Caption string resource ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN UINT             nIDTemplate,
    IN const DWORD *    pdwHelpMap,
    IN const DWORD *    pdwWizardHelpMap,
    IN UINT             nIDCaption
    )
    : CPropertyPage( nIDTemplate, nIDCaption )
    , m_dlghelp( pdwHelpMap, nIDTemplate )
{
    CommonConstruct();
    m_pdwWizardHelpMap = pdwWizardHelpMap;

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, DWORD *, DWORD *, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CommonConstruct
//
//  Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct( void )
{
    //{{AFX_DATA_INIT(CBasePropertyPage)
    //}}AFX_DATA_INIT

    m_peo = NULL;
    m_hpage = NULL;
    m_bBackPressed = FALSE;
    m_bSaved = FALSE;

    m_iddPropertyPage = NULL;
    m_iddWizardPage = NULL;
    m_idsCaption = NULL;

    m_pdwWizardHelpMap = NULL;

    m_bDoDetach = FALSE;

} //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::HrInit
//
//  Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertyPage::HrInit( IN OUT CExtObject * peo )
{
    ASSERT( peo != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    HRESULT     _hr = NOERROR;
    CWaitCursor _wc;

    do
    {
        m_peo = peo;

        // Change the help map if this is a wizard page.
        if ( Peo()->BWizard() )
        {
            m_dlghelp.SetMap( m_pdwWizardHelpMap );
        } // if: in a wizard

        // Don't display a help button.
        m_psp.dwFlags &= ~PSP_HASHELP;

        // Construct the property page.
        if ( Peo()->BWizard() )
        {
            ASSERT( IddWizardPage() != NULL);
            Construct( IddWizardPage(), IdsCaption() );
        } // if: adding page to wizard
        else
        {
            ASSERT( IddPropertyPage() != NULL );
            Construct( IddPropertyPage(), IdsCaption() );
        } // else: adding page to property sheet

        // Read the properties private to this resource and parse them.
        {
            DWORD           _sc = ERROR_SUCCESS;
            CClusPropList   _cpl;

            ASSERT( Peo() != NULL );
            ASSERT( Peo()->PodObjData() );

            // Read the properties.
            switch ( Cot() )
            {
                case CLUADMEX_OT_NODE:
                    ASSERT( Peo()->PndNodeData()->m_hnode != NULL );
                    _sc = _cpl.ScGetNodeProperties(
                                            Peo()->PndNodeData()->m_hnode,
                                            CLUSCTL_NODE_GET_PRIVATE_PROPERTIES
                                            );
                    break;

                case CLUADMEX_OT_GROUP:
                    ASSERT( Peo()->PgdGroupData()->m_hgroup != NULL );
                    _sc = _cpl.ScGetGroupProperties(
                                            Peo()->PgdGroupData()->m_hgroup,
                                            CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES
                                            );
                    break;

                case CLUADMEX_OT_RESOURCE:
                    ASSERT( Peo()->PrdResData()->m_hresource != NULL );
                    _sc = _cpl.ScGetResourceProperties(
                                            Peo()->PrdResData()->m_hresource,
                                            CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                                            );
                    break;

                case CLUADMEX_OT_RESOURCETYPE:
                    ASSERT( Peo()->PodObjData()->m_strName.GetLength() > 0 );
                    _sc = _cpl.ScGetResourceTypeProperties(
                                            Hcluster(),
                                            Peo()->PodObjData()->m_strName,
                                            CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
                                            );
                    break;

                case CLUADMEX_OT_NETWORK:
                    ASSERT( Peo()->PndNetworkData()->m_hnetwork != NULL );
                    _sc = _cpl.ScGetNetworkProperties(
                                            Peo()->PndNetworkData()->m_hnetwork,
                                            CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES
                                            );
                    break;

                case CLUADMEX_OT_NETINTERFACE:
                    ASSERT( Peo()->PndNetInterfaceData()->m_hnetinterface != NULL );
                    _sc = _cpl.ScGetNetInterfaceProperties(
                                            Peo()->PndNetInterfaceData()->m_hnetinterface,
                                            CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES
                                            );
                    break;

                default:
                    ASSERT( 0 );
            } // switch: object type

            // Parse the properties.
            if ( _sc == ERROR_SUCCESS )
            {
                // Parse the properties.
                try
                {
                    _sc = ScParseProperties( _cpl );
                } // try
                catch ( CMemoryException * _pme )
                {
                    _hr = E_OUTOFMEMORY;
                    _pme->Delete();
                } // catch: CMemoryException
            } // if: properties read successfully

            if ( _sc != ERROR_SUCCESS )
            {
                _hr = HRESULT_FROM_WIN32( _sc );
                break;
            } // if: error parsing getting or parsing properties
        } // Read the properties private to this resource and parse them
    } while ( 0 );

    return _hr;

} //*** CBasePropertyPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::HrCreatePage
//
//  Description:
//      Create the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK        Page created successfully.
//      hr          Error creating the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertyPage::HrCreatePage( void )
{
    ASSERT( m_hpage == NULL );

    HRESULT _hr = S_OK;

    m_hpage = CreatePropertySheetPage( reinterpret_cast< LPPROPSHEETPAGEW >( &m_psp ) );
    if ( m_hpage == NULL )
    {
        _hr = HRESULT_FROM_WIN32( GetLastError() );
    } // if: error creating the page

    return _hr;

} //*** CBasePropertyPage::HrCreatePage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScParseProperties
//
//  Description:
//      Parse the properties of the resource.  This is in a separate function
//      from HrInit so that the optimizer can do a better job.
//
//  Arguments:
//      rcpl            [IN] Cluster property list to parse.
//
//  Return Values:
//      ERROR_SUCCESS   Properties were parsed successfully.
//      Any error returns from ScParseUnknownProperty().
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScParseProperties( IN CClusPropList & rcpl )
{
    DWORD                   _sc;
    DWORD                   _cprop;
    const CObjectProperty * _pprop;

    ASSERT( rcpl.PbPropList() != NULL );

    _sc = rcpl.ScMoveToFirstProperty();
    while ( _sc == ERROR_SUCCESS )
    {
        //
        // Parse known properties.
        //
        for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
        {
            if ( lstrcmpiW( rcpl.PszCurrentPropertyName(), _pprop->m_pwszName ) == 0 )
            {
                if ( rcpl.CpfCurrentValueFormat() == _pprop->m_propFormat )
                {
                    switch ( _pprop->m_propFormat )
                    {
                        case CLUSPROP_FORMAT_SZ:
                        case CLUSPROP_FORMAT_EXPAND_SZ:
                            ASSERT(     (rcpl.CbCurrentValueLength() == (lstrlenW( rcpl.CbhCurrentValue().pStringValue->sz ) + 1) * sizeof( WCHAR ))
                                    ||  (   (rcpl.CbCurrentValueLength() == 0)
                                        &&  (rcpl.CbhCurrentValue().pStringValue->sz[ 0 ] == L'\0') ) );
                            *_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                            *_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

                            // See if we need to find an expanded version
                            if ( _pprop->m_valueEx.pstr != NULL )
                            {
                                // Copy the non-expanded one just in case there isn't an expanded version
                                *_pprop->m_valueEx.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

                                // See if they included an expanded version
                                rcpl.ScMoveToNextPropertyValue( );
                                if ( rcpl.CpfCurrentValueFormat( ) == CLUSPROP_FORMAT_EXPANDED_SZ )
                                {
                                    *_pprop->m_valueEx.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                                } // if: found expanded version

                            } // if: *_pprop->m_valueEx.pstr is present
                            break;
                        case CLUSPROP_FORMAT_EXPANDED_SZ:
                            ASSERT(     (rcpl.CbCurrentValueLength() == (lstrlenW( rcpl.CbhCurrentValue().pStringValue->sz ) + 1) * sizeof( WCHAR ))
                                    ||  (   (rcpl.CbCurrentValueLength() == 0)
                                        &&  (rcpl.CbhCurrentValue().pStringValue->sz[ 0 ] == L'\0') ) );
                            *_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                            *_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                            // See if we need to find an expanded version
                            if ( *_pprop->m_valueEx.pstr ) // can not use != NULL because overloading tries to do a string compare!
                            {
                                // Copy the expanded version
                                *_pprop->m_valueEx.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

                                // See if they included a non-expanded version
                                rcpl.ScMoveToNextPropertyValue( );
                                if ( rcpl.CpfCurrentValueFormat( ) == CLUSPROP_FORMAT_SZ )
                                {
                                    *_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                                    *_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                                } // if: found non-expanded version

                            } // if: *_pprop->m_valueEx.pstr is present
                            break;
                        case CLUSPROP_FORMAT_DWORD:
                        case CLUSPROP_FORMAT_LONG:
                            ASSERT( rcpl.CbCurrentValueLength() == sizeof( DWORD ) );
                            *_pprop->m_value.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
                            *_pprop->m_valuePrev.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
                            break;
                        case CLUSPROP_FORMAT_BINARY:
                        case CLUSPROP_FORMAT_MULTI_SZ:
                            *_pprop->m_value.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
                            *_pprop->m_value.ppb = new BYTE[ *_pprop->m_value.pcb ];
                            CopyMemory( *_pprop->m_value.ppb, rcpl.CbhCurrentValue().pBinaryValue->rgb, *_pprop->m_value.pcb );
                            *_pprop->m_valuePrev.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
                            *_pprop->m_valuePrev.ppb = new BYTE[ *_pprop->m_value.pcb ];
                            CopyMemory( *_pprop->m_valuePrev.ppb, rcpl.CbhCurrentValue().pBinaryValue->rgb, *_pprop->m_value.pcb );
                            break;
                        default:
                            ASSERT(0);  // don't know how to deal with this type
                    } // switch: property format

                    // Exit the loop since we found the parameter.
                    break;
                }// if: found a type match

            } // if: found a string match

        } // for: each property that we know about

        //
        // If the property wasn't known, ask the derived class to parse it.
        //
        if ( _cprop == 0 )
        {
            _sc = ScParseUnknownProperty(
                        rcpl.CbhCurrentPropertyName().pName->sz,
                        rcpl.CbhCurrentValue(),
                        rcpl.RPvlPropertyValue().CbDataLeft()
                        );
            if ( _sc != ERROR_SUCCESS )
            {
                return _sc;
            } // if: error parsing the unknown property
        } // if: property not parsed

        //
        // Advance the buffer pointer past the value in the value list.
        //
        _sc = rcpl.ScMoveToNextProperty();
    } // while: more properties to parse

    //
    // If we reached the end of the properties, fix the return code.
    //
    if ( _sc == ERROR_NO_MORE_ITEMS )
    {
        _sc = ERROR_SUCCESS;
    } // if: ended loop after parsing all properties

    return _sc;

} //*** CBasePropertyPage::ScParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCreate
//
//  Description:
//      Handler for the WM_CREATE message.
//
//  Arguments:
//      lpCreateStruct  [IN OUT] Window create structure.
//
//  Return Value:
//      -1      Error.
//      0       Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Attach the window to the property page structure.
    // This has been done once already in the main application, since the
    // main application owns the property sheet.  It needs to be done here
    // so that the window handle can be found in the DLL's handle map.
    if ( FromHandlePermanent( m_hWnd ) == NULL ) // is the window handle already in the handle map
    {
        HWND _hWnd = m_hWnd;
        m_hWnd = NULL;
        Attach( _hWnd );
        m_bDoDetach = TRUE;
    } // if: is the window handle in the handle map

    return CPropertyPage::OnCreate( lpCreateStruct );

} //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnDestroy
//
//  Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Detach the window from the property page structure.
    // This will be done again by the main application, since it owns the
    // property sheet.  It needs to be done here so that the window handle
    // can be removed from the DLL's handle map.
    if ( m_bDoDetach )
    {
        if ( m_hWnd != NULL )
        {
            HWND _hWnd = m_hWnd;

            Detach();
            m_hWnd = _hWnd;
        } // if: do we have a window handle?
    } // if: do we need to balance the attach we did with a detach?

    CPropertyPage::OnDestroy();

} //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DoDataExchange
//
//  Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange( CDataExchange * pDX )
{
    if ( ! pDX->m_bSaveAndValidate || ! BSaved() )
    {
        AFX_MANAGE_STATE( AfxGetStaticModuleState() );

        //{{AFX_DATA_MAP(CBasePropertyPage)
            // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
        DDX_Control( pDX, IDC_PP_ICON, m_staticIcon );
        DDX_Control( pDX, IDC_PP_TITLE, m_staticTitle );

        if ( pDX->m_bSaveAndValidate )
        {
            if ( ! BBackPressed() )
            {
                CWaitCursor _wc;

                // Validate the data.
                if ( ! BSetPrivateProps( TRUE /*bValidateOnly*/ ) )
                {
                    pDX->Fail();
                } // if: error setting private properties
            } // if: Back button not pressed
        } // if: saving data from dialog
        else
        {
            // Set the title.
            DDX_Text( pDX, IDC_PP_TITLE, m_strTitle );
        } // if: not saving data
    }  // if: not saving or haven't saved yet

    // Call the base class method.
    CPropertyPage::DoDataExchange( pDX );

} //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog( void )
{
    ASSERT( Peo() != NULL );
    ASSERT( Peo()->PodObjData() != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Set the title string.
    m_strTitle = Peo()->PodObjData()->m_strName;

    // Call the base class method.
    CPropertyPage::OnInitDialog();

    // Display an icon for the object.
    if ( Peo()->Hicon() != NULL )
    {
        m_staticIcon.SetIcon( Peo()->Hicon() );
    } // if: an icon was specified

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

} //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnSetActive
//
//  Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive( void )
{
    HRESULT     _hr;

    ASSERT( Peo() != NULL);
    ASSERT( Peo()->PodObjData() != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Reread the data.
    _hr = Peo()->HrGetObjectInfo();
    if ( _hr != NOERROR )
    {
        return FALSE;
    } // if: error getting object info

    // Set the title string.
    m_strTitle = Peo()->PodObjData()->m_strName;

    m_bBackPressed = FALSE;
    m_bSaved = FALSE;
    return CPropertyPage::OnSetActive();

} //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnApply
//
//  Description:
//      Handler for the PSM_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply( void )
{
    ASSERT( ! BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor _wc;

    if ( ! BApplyChanges() )
    {
        return FALSE;
    } // if: error applying changes

    return CPropertyPage::OnApply();

} //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardBack
//
//  Description:
//      Handler for the PSN_WIZBACK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack( void )
{
    LRESULT     _lResult;

    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    _lResult = CPropertyPage::OnWizardBack();
    if ( _lResult != -1 )
    {
        m_bBackPressed = TRUE;
    } // if: no error occurred

    return _lResult;

} //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardNext
//
//  Description:
//      Handler for the PSN_WIZNEXT message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext( void )
{
    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor _wc;

    // Update the data in the class from the page.
    // This necessary because, while OnKillActive() will call UpdateData(),
    // it is called after this method is called, and we need to be sure that
    // data has been saved before we apply them.
    if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
    {
        return -1;
    } // if: error updating data

    // Save the data in the sheet.
    if ( ! BApplyChanges() )
    {
        return -1;
    } // if: error applying changes

    // Create the object.

    return CPropertyPage::OnWizardNext();

} //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardFinish
//
//  Description:
//      Handler for the PSN_WIZFINISH message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      FALSE   Don't change the page.
//      TRUE    Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish( void )
{
    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor _wc;

    // BUG! There should be no need to call UpdateData in this function.
    // See BUG: Finish Button Fails Data Transfer from Page to Variables
    // KB Article ID: Q150349

    // Update the data in the class from the page.
    if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
    {
        return FALSE;
    } // if: error updating data

    // Save the data in the sheet.
    if ( ! BApplyChanges() )
    {
        return FALSE;
    } // if: error applying changes

    return CPropertyPage::OnWizardFinish();

} //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnChangeCtrl
//
//  Description:
//      Handler for the messages sent when a control is changed.  This
//      method can be specified in a message map if all that needs to be
//      done is enable the Apply button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    SetModified( TRUE );

} //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::EnableNext
//
//  Description:
//      Enables or disables the NEXT or FINISH button.
//
//  Arguments:
//      bEnable     [IN] TRUE = enable the button, FALSE = disable the button.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext( IN BOOL bEnable /*TRUE*/ )
{
    ASSERT( BWizard() );
    ASSERT( PiWizardCallback() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    PiWizardCallback()->EnableNext( reinterpret_cast< LONG * >( Hpage() ), bEnable );

} //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BApplyChanges
//
//  Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor _wc;

    // Save data.
    return BSetPrivateProps();

} //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BBuildPropList
//
//  Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//      bNoNewProps [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      TRUE        Property list built successfully.
//      FALSE       Error building property list.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::AddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BBuildPropList(
    IN OUT CClusPropList &  rcpl,
    IN BOOL                 bNoNewProps     // = FALSE
    )
{
    BOOL                    _bNewPropsFound = FALSE;
    DWORD                   _cprop;
    const CObjectProperty * _pprop;

    for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
    {
        if ( bNoNewProps && (_pprop->m_fFlags & CObjectProperty::opfNew) )
        {
            _bNewPropsFound = TRUE;
            continue;
        } // if: no new props allowed and this is a new property

        switch ( _pprop->m_propFormat )
        {
            case CLUSPROP_FORMAT_SZ:
                rcpl.ScAddProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.pstr,
                        *_pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_EXPAND_SZ:
                rcpl.ScAddExpandSzProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.pstr,
                        *_pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_DWORD:
                rcpl.ScAddProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.pdw,
                        *_pprop->m_valuePrev.pdw
                        );
                break;
            case CLUSPROP_FORMAT_LONG:
                rcpl.ScAddProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.pl,
                        *_pprop->m_valuePrev.pl
                        );
                break;
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_MULTI_SZ:
                rcpl.ScAddProp(
                        _pprop->m_pwszName,
                        *_pprop->m_value.ppb,
                        *_pprop->m_value.pcb,
                        *_pprop->m_valuePrev.ppb,
                        *_pprop->m_valuePrev.pcb
                        );
                break;
            default:
                ASSERT( 0 ); // don't know how to deal with this type
                return FALSE;
        } // switch: property format
    } // for: each property

    return ( ! bNoNewProps || _bNewPropsFound );

} //*** CBasePropertyPage::BBuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BSetPrivateProps
//
//  Description:
//      Set the private properties for this object.
//
//  Arguments:
//      bValidateOnly   [IN] TRUE = only validate the data.
//      bNoNewProps     [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      ERROR_SUCCESS   The operation was completed successfully.
//      !0              Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BSetPrivateProps(
    IN BOOL bValidateOnly,  // = FALSE
    IN BOOL bNoNewProps     // = FALSE
    )
{
    BOOL            _bSuccess   = TRUE;
    CClusPropList   _cpl( BWizard() /*bAlwaysAddProp*/ );

    ASSERT( Peo() != NULL );
    ASSERT( Peo()->PrdResData() );
    ASSERT( Peo()->PrdResData()->m_hresource );

    // Build the property list.
    try
    {
        _bSuccess = BBuildPropList( _cpl, bNoNewProps );
    } // try
    catch ( CException * pe )
    {
        pe->ReportError();
        pe->Delete();
        _bSuccess = FALSE;
    } // catch: CException

    // Set the data.
    if ( _bSuccess )
    {
        if ( (_cpl.PbPropList() != NULL) && (_cpl.CbPropList() > 0) )
        {
            DWORD       _sc = ERROR_SUCCESS;
            DWORD       _dwControlCode;
            DWORD       _cbProps;

            switch ( Cot() )
            {
                case CLUADMEX_OT_NODE:
                    ASSERT( Peo()->PndNodeData() != NULL );
                    ASSERT( Peo()->PndNodeData()->m_hnode != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_NODE_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterNodeControl(
                                    Peo()->PndNodeData()->m_hnode,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    _cpl.CbPropList(),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_GROUP:
                    ASSERT( Peo()->PgdGroupData() != NULL );
                    ASSERT( Peo()->PgdGroupData()->m_hgroup != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterGroupControl(
                                    Peo()->PgdGroupData()->m_hgroup,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    _cpl.CbPropList(),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_RESOURCE:
                    ASSERT( Peo()->PrdResData() != NULL );
                    ASSERT( Peo()->PrdResData()->m_hresource != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterResourceControl(
                                    Peo()->PrdResData()->m_hresource,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    _cpl.CbPropList(),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_RESOURCETYPE:
                    ASSERT( Peo()->PodObjData() != NULL );
                    ASSERT( Peo()->PodObjData()->m_strName.GetLength() > 0 );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterResourceTypeControl(
                                    Hcluster(),
                                    Peo()->PodObjData()->m_strName,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    _cpl.CbPropList(),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_NETWORK:
                    ASSERT( Peo()->PndNetworkData() != NULL );
                    ASSERT( Peo()->PndNetworkData()->m_hnetwork != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterNetworkControl(
                                    Peo()->PndNetworkData()->m_hnetwork,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    _cpl.CbPropList(),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                case CLUADMEX_OT_NETINTERFACE:
                    ASSERT( Peo()->PndNetInterfaceData() != NULL );
                    ASSERT( Peo()->PndNetInterfaceData()->m_hnetinterface != NULL );

                    // Determine which control code to use.
                    if ( bValidateOnly )
                    {
                        _dwControlCode = CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES;
                    } // if: only validating data
                    else
                    {
                        _dwControlCode = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
                    } // else: setting data

                    // Set private properties.
                    _sc = ClusterNetInterfaceControl(
                                    Peo()->PndNetInterfaceData()->m_hnetinterface,
                                    NULL,   // hNode
                                    _dwControlCode,
                                    _cpl.PbPropList(),
                                    _cpl.CbPropList(),
                                    NULL,   // lpOutBuffer
                                    0,      // nOutBufferSize
                                    &_cbProps
                                    );
                    break;
                default:
                    ASSERT( 0 );
            } // switch: object type

            // Handle errors.
            if ( _sc != ERROR_SUCCESS )
            {
                if ( _sc == ERROR_INVALID_PARAMETER )
                {
                    if ( ! bNoNewProps )
                    {
                        _bSuccess = BSetPrivateProps( bValidateOnly, TRUE /*bNoNewProps*/ );
                    } // if: new props are allowed
                    else
                        _bSuccess = FALSE;
                } // if: invalid parameter error occurred
                else
                {
                    _bSuccess = FALSE;
                } // else: some other error occurred

                //
                // If an error occurred, display an error message.
                //
                if ( ! _bSuccess )
                {
                    DisplaySetPropsError( _sc, bValidateOnly ? IDS_ERROR_VALIDATING_PROPERTIES : IDS_ERROR_SETTING_PROPERTIES );
                    if ( _sc == ERROR_RESOURCE_PROPERTIES_STORED )
                    {
                        _bSuccess = TRUE;
                    } // if: properties only stored
                } // if: error occurred
            } // if: error setting/validating data
        } // if: there is data to set
    } // if: no errors building the property list

    // Save data locally.
    if ( ! bValidateOnly && _bSuccess )
    {
        // Save new values as previous values.
        try
        {
            DWORD                   _cprop;
            const CObjectProperty * _pprop;

            for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
            {
                switch ( _pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        ASSERT(_pprop->m_value.pstr != NULL);
                        ASSERT(_pprop->m_valuePrev.pstr != NULL);
                        *_pprop->m_valuePrev.pstr = *_pprop->m_value.pstr;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                        ASSERT( _pprop->m_value.pdw != NULL );
                        ASSERT( _pprop->m_valuePrev.pdw != NULL );
                        *_pprop->m_valuePrev.pdw = *_pprop->m_value.pdw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        ASSERT( _pprop->m_value.ppb != NULL );
                        ASSERT( *_pprop->m_value.ppb != NULL );
                        ASSERT( _pprop->m_value.pcb != NULL );
                        ASSERT( _pprop->m_valuePrev.ppb != NULL );
                        ASSERT( *_pprop->m_valuePrev.ppb != NULL );
                        ASSERT( _pprop->m_valuePrev.pcb != NULL );
                        delete [] *_pprop->m_valuePrev.ppb;
                        *_pprop->m_valuePrev.ppb = new BYTE[ *_pprop->m_value.pcb ];
                        CopyMemory( *_pprop->m_valuePrev.ppb, *_pprop->m_value.ppb, *_pprop->m_value.pcb );
                        *_pprop->m_valuePrev.pcb = *_pprop->m_value.pcb;
                        break;
                    default:
                        ASSERT( 0 ); // don't know how to deal with this type
                } // switch: property format
            } // for: each property
        } // try
        catch ( CException * _pe )
        {
            _pe->ReportError();
            _pe->Delete();
            _bSuccess = FALSE;
        } // catch: CException
    } // if: not just validating and successful so far

    //
    // Indicate we successfully saved the properties.
    //
    if ( ! bValidateOnly && _bSuccess )
    {
        m_bSaved = TRUE;
    } // if: successfully saved data

    return _bSuccess;

} //*** CBasePropertyPage::BSetPrivateProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DisplaySetPropsError
//
//  Routine Description:
//      Display an error caused by setting or validating properties.
//
//  Arguments:
//      sc      [IN] Status to display error on.
//      idsOper [IN] Operation message.
//
//  Return Value:
//      nStatus ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DisplaySetPropsError(
    IN DWORD    sc,
    IN UINT     idsOper
    ) const
{
    CString _strErrorMsg;
    CString _strOperMsg;
    CString _strMsgIdFmt;
    CString _strMsgId;
    CString _strMsg;

    _strOperMsg.LoadString( IDS_ERROR_SETTING_PROPERTIES );
    FormatError( _strErrorMsg, sc );
    _strMsgIdFmt.LoadString( IDS_ERROR_MSG_ID );
    _strMsgId.Format( _strMsgIdFmt, sc, sc );
    _strMsg.Format( _T("%s\n\n%s%s"), _strOperMsg, _strErrorMsg, _strMsgId );
    AfxMessageBox( _strMsg );

}  //*** CBasePropertyPage::DisplaySetPropsError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU message.
//
//  Arguments:
//      pWnd    Window in which user clicked the right mouse button.
//      point   Position of the cursor, in screen coordinates.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu( CWnd * pWnd, CPoint point )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    m_dlghelp.OnContextMenu( pWnd, point );

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnHelpInfo
//
//  Routine Description:
//      Handler for the WM_HELPINFO message.
//
//  Arguments:
//      pHelpInfo   Structure containing info about displaying help.
//
//  Return Value:
//      TRUE        Help processed.
//      FALSE       Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo( HELPINFO * pHelpInfo )
{
    BOOL    _bProcessed;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    _bProcessed = m_dlghelp.OnHelpInfo( pHelpInfo );
    if ( ! _bProcessed )
    {
        _bProcessed = CPropertyPage::OnHelpInfo( pHelpInfo );
    } // if: message not processed yet
    return _bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCommandHelp
//
//  Routine Description:
//      Handler for the WM_COMMANDHELP message.
//
//  Arguments:
//      wParam      [IN] WPARAM.
//      lParam      [IN] LPARAM.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp( WPARAM wParam, LPARAM lParam )
{
    LRESULT _bProcessed;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    _bProcessed = m_dlghelp.OnCommandHelp( wParam, lParam );
    if ( ! _bProcessed )
    {
        _bProcessed = CPropertyPage::OnCommandHelp( wParam, lParam );
    } // if: message not processed yet

    return _bProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 2002 <company name>
//
//	Module Name:
//		BasePage.inl
//
//	Description:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 2002
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEPAGE_INL__
#define __BASEPAGE_INL__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

inline IWCWizardCallback * CBasePropertyPage::PiWizardCallback( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->PiWizardCallback();

} //*** CBasePropertyPage::PiWizardCallback()

inline BOOL CBasePropertyPage::BWizard( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->BWizard();

} //*** CBasePropertyPage::BWizard()

inline HCLUSTER CBasePropertyPage::Hcluster( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->Hcluster();

} //*** CBasePropertyPage::Hcluster()

inline CLUADMEX_OBJECT_TYPE CBasePropertyPage::Cot( void ) const
{
	ASSERT( Peo() != NULL );
	return Peo()->Cot();

} //*** CBasePropertyPage::Cot()

/////////////////////////////////////////////////////////////////////////////

#endif // __BASEPAGE_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstask\mgdresource.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft
//
//  Module Name:
//      MgdResource.cpp
//
//  Description:
//      Main DLL code. Contains ATL stub code
//
//  Author:
//      George Potts, August 21, 2002
//
//  Revision History:
//
//  Notes:
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "clres.h"
#include "CMgdResType.h"

//
// Defines
//

#define VSSTASK_EVENTLOG_KEY    L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\" CLUS_RESTYPE_NAME_VSSTASK

//
// Forward Declarations
//

STDAPI AddEventSource( void );
STDAPI RemoveEventSource( void );

//
// Main ATL COM module
//
CComModule _Module;

//
// List of all COM classes supported by this DLL
//
BEGIN_OBJECT_MAP( ObjectMap )
    OBJECT_ENTRY( CLSID_CMgdResType,            CMgdResType )
END_OBJECT_MAP()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllMain
//
//  Description:
//      Main DLL entry point function
//
//  Arguments:
//      IN  HINSTANCE   hInstance
//      IN  DWORD       dwReason
//      IN  LPVOID
//
//  Return Value:
//      TRUE    Success
//
//--
//////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL
WINAPI
DllMain(
      HINSTANCE   hInstance
    , DWORD       dwReason
    , LPVOID      pvReserved
    )
{
    UNREFERENCED_PARAMETER( pvReserved );

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        _Module.Init( ObjectMap, hInstance, &LIBID_MGDRESOURCELib );
        DisableThreadLibraryCalls( hInstance );
    } // if: we are being loaded
    else if ( dwReason == DLL_PROCESS_DETACH )
    {
        _Module.Term();
    } // else: we are being unloaded
    
    return ResTypeDllMain( hInstance, dwReason, pvReserved );

} //*** DllMain

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllCanUnloadNow
//
//  Description:
//      Used to determine whether or not this DLL can be unloaded
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK        Yes
//      S_FALSE     No
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllCanUnloadNow( void )
{
    return ( _Module.GetLockCount() == 0 ) ? S_OK : S_FALSE;

} //*** DllCanUnloadNow

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllGetClassObject
//
//  Description:
//      Returns a class factory to create an object of the requested type
//
//  Arguments:
//      rclsidIn
//      riidIn
//      ppvOut
//
//  Return Value:
//      S_OK    Success
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllGetClassObject(
    REFCLSID    rclsidIn,
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    return _Module.GetClassObject( rclsidIn, riidIn, ppvOut );

} //*** DllGetClassObject

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterServer
//
//  Description:
//      Adds entries to the system registry
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    Success
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllRegisterServer( void )
{
    HRESULT hr = S_OK;

    // registers object, typelib and all interfaces in typelib
    hr = _Module.RegisterServer( TRUE );
    if ( SUCCEEDED( hr ) )
    {
        hr = AddEventSource();
    } // if:

    return hr;

} //*** DllRegisterServer

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllUnRegisterServer
//
//  Description:
//      Removes entries to the system registry
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllUnregisterServer( void )
{
    HRESULT hr;

    hr = _Module.UnregisterServer( TRUE );
    if ( SUCCEEDED( hr ) )
    {
        hr = RemoveEventSource();
    } // if:

    return hr;

} //*** DllUnregisterServer

//////////////////////////////////////////////////////////////////////////////
//++
//
//  AddEventSource
//
//  Description:
//      Registers this dll as an event source for the event log.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
AddEventSource( void )
{
    HKEY    hKey = NULL;
    DWORD   dwTypesSupported;
    WCHAR   wszMsgCatalogPath[] = L"%SystemRoot%\\Cluster\\" RESTYPE_DLL_NAME; //vsstask.dll";
    DWORD   sc = ERROR_SUCCESS;

    //
    // Create a key for VSS Task under the System portion of the EventLog master key
    //
    sc = RegCreateKeyW(
                  HKEY_LOCAL_MACHINE
                , VSSTASK_EVENTLOG_KEY
                , &hKey
                );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    //
    // Add the name of the message catalog as the EventMessageFile value
    //
    sc = RegSetValueExW(
                  hKey                          // subkey handle
                , L"EventMessageFile"           // value name
                , 0                             // must be zero
                , REG_EXPAND_SZ                 // value type
                , (BYTE *) wszMsgCatalogPath    // pointer to value data 
                , sizeof( wszMsgCatalogPath )   // length of value data 
                );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    //
    // Set the supported event types in the TypesSupported value
    //
    dwTypesSupported =    EVENTLOG_ERROR_TYPE
                        | EVENTLOG_WARNING_TYPE
                        | EVENTLOG_INFORMATION_TYPE;

    sc = RegSetValueEx(
                  hKey                          // subkey handle
                , L"TypesSupported"             // value name
                , 0                             // must be zero
                , REG_DWORD                     // value type
                , (BYTE *) &dwTypesSupported    // pointer to value data
                , sizeof( DWORD )               // length of value data
                );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

Cleanup:

    RegCloseKey( hKey );

    return HRESULT_FROM_WIN32( sc );

} //*** AddEventSource

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RemoveEventSource
//
//  Description:
//      Unregisters this dll as an event source for the event log.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK    Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
RemoveEventSource( void )
{
    DWORD   sc = ERROR_SUCCESS;

    //
    // Remove the VSS Task subkey under the System subkey of the EventLog master key
    //
    sc = RegDeleteKeyW(
                  HKEY_LOCAL_MACHINE
                , VSSTASK_EVENTLOG_KEY
                );

    return HRESULT_FROM_WIN32( sc );

} //*** RemoveEventSource
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      BasePage.h
//
//  Implementation File:
//      BasePage.cpp
//      BasePage.inl
//
//  Description:
//      Definition of the CBasePropertyPage class.  This class provides base
//      functionality for extension DLL property pages.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEPAGE_H__
#define __BASEPAGE_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _EXTOBJ_H_
#include "ExtObj.h"     // for CExtObject
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CClusPropList, CObjectProperty
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"    // for CDialogHelp
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE( CBasePropertyPage )

// Construction
public:
    CBasePropertyPage( void );
    CBasePropertyPage(
        IN const DWORD *    pdwHelpMap,
        IN const DWORD *    pdwWizardHelpMap
        );
    CBasePropertyPage(
        IN UINT             nIDTemplate,
        IN const DWORD *    pdwHelpMap,
        IN const DWORD *    pdwWizardHelpMap,
        IN UINT             nIDCaption = 0
        );
    virtual ~CBasePropertyPage( void )
    {
    } //*** ~CBasePropertyPage

    // Second phase construction.
    virtual HRESULT         HrInit( IN OUT CExtObject * peo );
    HRESULT                 HrCreatePage( void );

protected:
    void                    CommonConstruct( void );

// Attributes
protected:
    CExtObject *            m_peo;
    HPROPSHEETPAGE          m_hpage;

    IDD                     m_iddPropertyPage;
    IDD                     m_iddWizardPage;
    IDS                     m_idsCaption;

    CExtObject *            Peo( void ) const               { return m_peo; }

    IDD                     IddPropertyPage( void ) const   { return m_iddPropertyPage; }
    IDD                     IddWizardPage( void ) const     { return m_iddWizardPage; }
    IDS                     IdsCaption( void ) const        { return m_idsCaption; }

public:
    HPROPSHEETPAGE          Hpage( void ) const             { return m_hpage; }
    CLUADMEX_OBJECT_TYPE    Cot( void ) const;

// Dialog Data
    //{{AFX_DATA(CBasePropertyPage)
    enum { IDD = 0 };
    //}}AFX_DATA
    CStatic m_staticIcon;
    CStatic m_staticTitle;
    CString m_strTitle;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CBasePropertyPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
    virtual LRESULT OnWizardBack();
    virtual LRESULT OnWizardNext();
    virtual BOOL OnWizardFinish();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual DWORD           ScParseUnknownProperty(
                                IN LPCWSTR                          pwszName,
                                IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                                IN DWORD                            cbBuf
                                )
    {
        return ERROR_SUCCESS;

    } //*** ScParseUnknownProperty()

    virtual BOOL            BApplyChanges( void );
    virtual BOOL            BBuildPropList( IN OUT CClusPropList & rcpl, IN BOOL bNoNewProps = FALSE );
    virtual void            DisplaySetPropsError( IN DWORD sc, IN UINT idsOper ) const;

    virtual const CObjectProperty * Pprops( void ) const    { return NULL; }
    virtual DWORD                   Cprops( void ) const    { return 0; }

// Implementation
protected:
    BOOL                    m_bBackPressed;
    BOOL                    m_bSaved;
    const DWORD *           m_pdwWizardHelpMap;
    BOOL                    m_bDoDetach;

    BOOL                    BBackPressed( void ) const      { return m_bBackPressed; }
    BOOL                    BSaved( void ) const            { return m_bSaved; }
    IWCWizardCallback *     PiWizardCallback( void ) const;
    BOOL                    BWizard( void ) const;
    HCLUSTER                Hcluster( void ) const;
    void                    EnableNext( IN BOOL bEnable = TRUE );

    DWORD                   ScParseProperties( IN CClusPropList & rcpl );
    BOOL                    BSetPrivateProps(
                                IN BOOL bValidateOnly = FALSE,
                                IN BOOL bNoNewProps = FALSE
                                );

    void                    SetHelpMask( IN DWORD dwMask )    { m_dlghelp.SetHelpMask(dwMask); }
    CDialogHelp             m_dlghelp;

    // Generated message map functions
    //{{AFX_MSG(CBasePropertyPage)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    virtual afx_msg void OnContextMenu( CWnd * pWnd, CPoint point );
    afx_msg void OnChangeCtrl();
    DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList< CBasePropertyPage *, CBasePropertyPage * > CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // __BASEPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 2002 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Description:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 2002
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DDXDDV_H__
#define __DDXDDV_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

inline void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT LONG &			rnValue,
	IN LONG					nMin,
	IN LONG					nMax,
	IN BOOL					bSigned
	)
{
	DDX_Number(
		pDX,
		nIDC,
		reinterpret_cast< DWORD & >( rnValue ),
		static_cast< DWORD >( nMin ),
		static_cast< DWORD >( nMax ),
		bSigned
		);

} //*** DDXNumber( LONG )

/////////////////////////////////////////////////////////////////////////////

#endif // __DDXDDV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      HelpData.cpp
//
//  Abstract:
//      Data required for implementing help.
//
//  Author:
//      David Potter (davidp)   February 19, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      DDxDDv.cpp
//
//  Description:
//      Implementation of custom dialog data exchange/dialog data validation
//      routines.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//      The IDS_REQUIRED_FIELD_EMPTY string resource must be defined in
//      the resource file.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DDxDDv.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////
static void CleanupLabel( LPTSTR psz );


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDX_Number
//
//  Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX         [IN OUT] Data exchange object 
//      nIDC        [IN] Control ID.
//      dwValue     [IN OUT] Value to set or get.
//      dwMin       [IN] Minimum value.
//      dwMax       [IN] Maximum value.
//      bSigned     [IN] TRUE = value is signed, FALSE = value is unsigned
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
    IN OUT CDataExchange *  pDX,
    IN int                  nIDC,
    IN OUT DWORD &          rdwValue,
    IN DWORD                dwMin,
    IN DWORD                dwMax,
    IN BOOL                 bSigned
    )
{
    HWND    hwndCtrl;
    DWORD   dwValue;

    ASSERT( pDX != NULL );
#ifdef _DEBUG
    if ( bSigned )
    {
        ASSERT( static_cast< LONG >( dwMin ) < static_cast< LONG >( dwMax ) );
    }
    else
    {
        ASSERT( dwMin < dwMax );
    }
#endif // _DEBUG

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Get the control window handle.
    hwndCtrl = pDX->PrepareEditCtrl( nIDC );

    if ( pDX->m_bSaveAndValidate )
    {
        BOOL    bTranslated;

        // Get the number from the control.
        dwValue = GetDlgItemInt( pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned );

        // If the retrival failed, it is a signed number, and the minimum
        // value is the smallest negative value possible, check the string itself.
        if ( ! bTranslated && bSigned && (dwMin == 0x80000000) )
        {
            UINT    cch;
            TCHAR   szNumber[ 20 ];

            // See if it is the smallest negative number.
            cch = GetDlgItemText( pDX->m_pDlgWnd->m_hWnd, nIDC, szNumber, sizeof( szNumber ) / sizeof( TCHAR ) );
            if ( (cch != 0) && (lstrcmp( szNumber, _T("-2147483648") ) == 0) )
            {
                dwValue = 0x80000000;
                bTranslated = TRUE;
            } // if:  text retrieved successfully and is highest negative number
        } // if:  error translating number and getting signed number

        // If the retrieval failed or the specified number is
        // out of range, display an error.
        if (    ! bTranslated
            ||  (bSigned
                && (    (static_cast< LONG >( dwValue ) < static_cast< LONG >( dwMin ))
                    ||  (static_cast< LONG >( dwValue ) > static_cast< LONG >( dwMax ))
                    )
                )
            ||  (!  bSigned
                &&  (   (dwValue < dwMin)
                    ||  (dwValue > dwMax)
                    )
                )
            )
        {
            TCHAR szMin[ 32 ];
            TCHAR szMax[ 32 ];
            CString strPrompt;

            if ( bSigned )
            {
                wsprintf( szMin, _T("%d%"), dwMin );
                wsprintf( szMax, _T("%d%"), dwMax );
            } // if:  signed number
            else
            {
                wsprintf( szMin, _T("%u%"), dwMin );
                wsprintf( szMax, _T("%u%"), dwMax );
            } // else:  unsigned number
            AfxFormatString2( strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax );
            AfxMessageBox( strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE );
            strPrompt.Empty(); // exception prep
            pDX->Fail();
        } // if:  invalid string
        else
        {
            rdwValue = dwValue;
        } // if:  number is in range
    } // if:  saving data
    else
    {
        CString     strMinValue;
        CString     strMaxValue;
        UINT        cchMax;

        // Set the maximum number of characters that can be entered.
        if ( bSigned )
        {
            strMinValue.Format( _T("%d"), dwMin );
            strMaxValue.Format( _T("%d"), dwMax );
        } // if:  signed value
        else
        {
            strMinValue.Format( _T("%u"), dwMin );
            strMaxValue.Format( _T("%u"), dwMax );
        } // else:  unsigned value
        cchMax = max( strMinValue.GetLength(), strMaxValue.GetLength() );
        SendMessage( hwndCtrl, EM_LIMITTEXT, cchMax, 0 );

        // Set the value into the control.
        if ( bSigned )
        {
            LONG lValue = static_cast< LONG >( rdwValue );
            DDX_Text( pDX, nIDC, lValue );
        } // if:  signed value
        else
            DDX_Text( pDX, nIDC, rdwValue );
    } // else:  setting data onto the dialog

} //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DDV_RequiredText
//
//  Description:
//      Validate that the dialog string is present.
//
//  Arguments:
//      pDX         [IN OUT] Data exchange object 
//      nIDC        [IN] Control ID.
//      nIDCLabel   [IN] Label control ID.
//      rstrValue   [IN] Value to set or get.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
    IN OUT CDataExchange *  pDX,
    IN int                  nIDC,
    IN int                  nIDCLabel,
    IN const CString &      rstrValue
    )
{
    ASSERT( pDX != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    if ( pDX->m_bSaveAndValidate )
    {
        if ( rstrValue.GetLength() == 0 )
        {
            HWND        hwndLabel;
            TCHAR       szLabel[ 1024 ];
            CString     strPrompt;

            // Get the label window handle
            hwndLabel = pDX->PrepareEditCtrl( nIDCLabel );

            // Get the text of the label.
            GetWindowText( hwndLabel, szLabel, sizeof( szLabel ) / sizeof( TCHAR ) );

            // Remove ampersands (&) and colons (:).
            CleanupLabel( szLabel );

            // Format and display a message.
            strPrompt.FormatMessage( IDS_REQUIRED_FIELD_EMPTY, szLabel );
            AfxMessageBox( strPrompt, MB_ICONEXCLAMATION );

            // Do this so that the control receives focus.
            (void) pDX->PrepareEditCtrl( nIDC );

            // Fail the call.
            strPrompt.Empty();  // exception prep
            pDX->Fail();
        } // if:  field not specified
    } // if:  saving data

} //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CleanupLabel
//
//  Description:
//      Prepare a label read from a dialog to be used as a string in a
//      message by removing ampersands (&) and colons (:).
//
//  Arguments:
//      pszLabel    [IN OUT] Label to be cleaned up.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
static void CleanupLabel( LPTSTR pszLabel )
{
    LPTSTR  pIn, pOut;
    LANGID  langid;
    WORD    primarylangid;
    BOOL    bFELanguage;

    // Get the language ID.
    langid = GetUserDefaultLangID();
    primarylangid = static_cast< WORD >( PRIMARYLANGID( langid ) );
    bFELanguage = ((primarylangid == LANG_JAPANESE)
                || (primarylangid == LANG_CHINESE)
                || (primarylangid == LANG_KOREAN) );

    //
    // Copy the name sans '&' and ':' chars
    //

    pIn = pOut = pszLabel;
    do
    {
        //
        // Strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
        //
        if (    bFELanguage
            &&  (pIn[ 0 ] == _T('('))
            &&  (pIn[ 1 ] == _T('&'))
            &&  (pIn[ 2 ] != _T('\0'))
            &&  (pIn[ 3 ] == _T(')')) )
        {
            pIn += 3;
        } // if:  Far East language with accelerator
        else if ( (*pIn != _T('&')) && (*pIn != _T(':')) )
        {
            *pOut++ = *pIn;
        } // else if:  accelerator found
    } while ( *pIn++ != _T('\0') );

} //*** CleanupLabel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2002 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __HELPDATA_H__
#define __HELPDATA_H__

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // __HELPDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\helparr.h ===
// Copyright (c) 1996-2002, Microsoft Corporation, all rights reserved.
//
// cnetharr.h is used by ClNetResEx.rc
// Cluster Admin DHCP and WINs Dialogs
// Help constants & DWORD arrays
//
// 04/29/99 Melissa Simmons
//
//

#define IDH_DISABLEHELP ((DWORD)-1)

#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_PP_VSSTASK_PARAMETERS[]=
{
    IDC_PP_ICON,                            IDH_DISABLEHELP,
    IDC_PP_VSSTASK_APPLICATIONNAME_LABEL,   IDH_VSCSR_COMMAND_RUN,
    IDC_PP_VSSTASK_APPLICATIONNAME,         IDH_VSCSR_COMMAND_RUN,
    IDC_PP_VSSTASK_APPLICATIONPARAMS_LABEL, IDH_VSCSR_COMMAND_PARAM,
    IDC_PP_VSSTASK_APPLICATIONPARAMS,       IDH_VSCSR_COMMAND_PARAM,
    IDC_PP_VSSTASK_CURRENTDIRECTORY_LABEL,  IDH_VSCSR_START_IN,
    IDC_PP_VSSTASK_CURRENTDIRECTORY,        IDH_VSCSR_START_IN,
    IDC_SCHEDULE,                           IDH_VSCSR_SCHEDULE,
    0,                                      0
};

const DWORD g_aHelpIDs_IDD_WIZ_VSSTASK_PARAMETERS[]=
{
    IDC_PP_ICON,                            IDH_DISABLEHELP,
    IDC_PP_VSSTASK_APPLICATIONNAME_LABEL,   IDH_VSCSR_COMMAND_RUN,
    IDC_PP_VSSTASK_APPLICATIONNAME,         IDH_VSCSR_COMMAND_RUN,
    IDC_PP_VSSTASK_APPLICATIONPARAMS_LABEL, IDH_VSCSR_COMMAND_PARAM,
    IDC_PP_VSSTASK_APPLICATIONPARAMS,       IDH_VSCSR_COMMAND_PARAM,
    IDC_PP_VSSTASK_CURRENTDIRECTORY_LABEL,  IDH_VSCSR_START_IN,
    IDC_PP_VSSTASK_CURRENTDIRECTORY,        IDH_VSCSR_START_IN,
    IDC_SCHEDULE,                           IDH_VSCSR_SCHEDULE,
    0,                                      0
};


#else

extern const DWORD g_aHelpIDs_IDD_PP_VSSTASK_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_VSSTASK_PARAMETERS[];


#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\dlghelp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      DlgHelp.h
//
//  Abstract:
//      Definition of the CDialogHelp class.
//
//  Implementation File:
//      DlgHelp.cpp
//
//  Author:
//      David Potter (davidp)   February 6, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __DLGHELP_H__
#define __DLGHELP_H__

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

struct CMapCtrlToHelpID
{
    DWORD   m_nCtrlID;
    DWORD   m_nHelpCtrlID;
};

/////////////////////////////////////////////////////////////////////////////
// CDialogHelp dialog
/////////////////////////////////////////////////////////////////////////////

class CDialogHelp : public CObject
{
    DECLARE_DYNAMIC( CDialogHelp )

// Construction
public:
    CDialogHelp( void ) { CommonConstruct(); }
    CDialogHelp( const DWORD * pdwHelpMap, DWORD dwMask );

    void CommonConstruct(void);

// Attributes
protected:
    const CMapCtrlToHelpID *    m_pmap;
    DWORD                       m_dwMask;
    DWORD                       m_nHelpID;

public:
    const CMapCtrlToHelpID *    Pmap( void ) const      { return m_pmap; }
    DWORD                       DwMask( void ) const    { return m_dwMask; }
    DWORD                       NHelpID( void ) const   { return m_nHelpID; }

    DWORD                       NHelpFromCtrlID( IN DWORD nCtrlID ) const;
    void                        SetMap( IN const DWORD * pdwHelpMap )
    {
        ASSERT( pdwHelpMap != NULL );
        m_pmap = (const CMapCtrlToHelpID *) pdwHelpMap;
    } //*** SetMap()

// Operations
public:
    void        SetHelpMask( IN DWORD dwMask )  { ASSERT( dwMask != 0 ); m_dwMask = dwMask; }

    void        OnContextMenu( CWnd * pWnd, CPoint point );
    BOOL        OnHelpInfo( HELPINFO * pHelpInfo );
    LRESULT     OnCommandHelp( WPARAM wParam, LPARAM lParam );

// Overrides

// Implementation

};  //*** class CDialogHelp

/////////////////////////////////////////////////////////////////////////////

#endif // __DLGHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      ExtObj.cpp
//
//  Description:
//      Implementation of the CExtObject class, which implements the
//      extension interfaces required by a Microsoft Windows NT Cluster
//      Administrator Extension DLL.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSSTaskEx.h"
#include "ExtObj.h"
#include "ResProp.h"

class CStackException : public CException
{
public:
    CStackException( BOOL bAutoDelete )
        : CException( bAutoDelete )
    {
    } //*** CStackException()

    virtual ~CStackException( void )
    {
    } //*** ~CStackException()

}; //*** class CStackException

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
        CLUS_RESTYPE_NAME_VSSTASK L"\0"
        ;

const DWORD g_cchResourceTypeNames  = sizeof( g_wszResourceTypeNames ) / sizeof( WCHAR );

static CRuntimeClass * g_rgprtcResPSPages[] = {
    RUNTIME_CLASS( CVSSTaskParamsPage ),
    NULL
    };
static CRuntimeClass ** g_rgpprtcResPSPages[]   = {
    g_rgprtcResPSPages,
    };
static CRuntimeClass ** g_rgpprtcResWizPages[]  = {
    g_rgprtcResPSPages,
    };

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CExtObject
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject( void )
{
    m_piData = NULL;
    m_piWizardCallback = NULL;
    m_bWizard = FALSE;
    m_istrResTypeName = 0;

    m_lcid = NULL;
    m_hfont = NULL;
    m_hicon = NULL;
    m_hcluster = NULL;
    m_cobj = 0;
    m_podObjData = NULL;

} //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::~CExtObject
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject( void )
{
    // Release the data interface.
    if ( PiData() != NULL )
    {
        PiData()->Release();
        m_piData = NULL;
    } // if:  we have a data interface pointer

    // Release the wizard callback interface.
    if ( PiWizardCallback() != NULL )
    {
        PiWizardCallback()->Release();
        m_piWizardCallback = NULL;
    } // if:  we have a wizard callback interface pointer

    // Delete the pages.
    {
        POSITION    pos;

        pos = Lpg().GetHeadPosition();
        while ( pos != NULL )
        {
            delete Lpg().GetNext(pos);
        } // while:  more pages in the list
    } // Delete the pages

    delete m_podObjData;

} //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//  Routine Description:
//      Indicates whether an interface suportes the IErrorInfo interface.
//      This interface is provided by ATL.
//
//  Arguments:
//      riid        Interface ID.
//
//  Return Value:
//      S_OK        Interface supports IErrorInfo.
//      S_FALSE     Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID * _rgiid[] = 
    {
        &IID_IWEExtendPropertySheet,
        &IID_IWEExtendWizard,
    };
    int     _iiid;

    for ( _iiid = 0 ; _iiid < sizeof( _rgiid ) / sizeof( _rgiid[ 0 ] ) ; _iiid++ )
    {
        if ( ::InlineIsEqualGUID( *_rgiid[ _iiid ], riid ) )
        {
            return S_OK;
        } // if:  found a matching IID
    }
    return S_FALSE;

} //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//  Description:
//      Create property sheet pages and add them to the sheet.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object for which the sheet is being displayed.
//
//      piCallback [IN]
//          Pointer to an IWCPropertySheetCallback interface for adding pages
//          to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      _hr             Any error codes from HrGetUIInfo() or HrSaveData().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
    IN IUnknown *                   piData,
    IN IWCPropertySheetCallback *   piCallback
    )
{
    HRESULT             _hr     = NOERROR;
    CStackException     _exc( FALSE /*bAutoDelete*/ );
    CRuntimeClass **    _pprtc  = NULL;
    int                 _irtc;
    CBasePropertyPage * _ppage;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Validate the parameters.
    if ( (piData == NULL) || (piCallback == NULL) )
    {
        return E_INVALIDARG;
    } // if:  all interfaces not specified

    try 
    {
        // Get info about displaying UI.
        _hr = HrGetUIInfo( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error getting UI info

        // Save the data.
        _hr = HrSaveData( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error saving data from host

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while ( pos != NULL )
            {
                delete Lpg().GetNext( pos );
            } // while:  more pages in the list
            Lpg().RemoveAll();
        } // Delete any previous pages

        // Create property pages.
        ASSERT( PodObjData() != NULL );
        switch ( PodObjData()->m_cot )
        {
            case CLUADMEX_OT_RESOURCE:
                _pprtc = g_rgpprtcResPSPages[ IstrResTypeName() ];
                break;

            default:
                _hr = E_NOTIMPL;
                throw &_exc;
                break;
        } // switch:  object type

        // Create each page.
        for ( _irtc = 0 ; _pprtc[ _irtc ] != NULL ; _irtc++ )
        {
            // Create the page.
            _ppage = static_cast< CBasePropertyPage * >( _pprtc[ _irtc ]->CreateObject() );
            ASSERT( _ppage->IsKindOf( _pprtc[ _irtc ] ) );

            // Add it to the list.
            Lpg().AddTail( _ppage );

            // Initialize the property page.
            _hr = _ppage->HrInit( this );
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error initializing the page

            // Create the page.
            _hr = _ppage->HrCreatePage();
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error creating the page

            // Add it to the property sheet.
            _hr = piCallback->AddPropertySheetPage( reinterpret_cast< LONG * >( _ppage->Hpage() ) );
            if ( _hr != NOERROR )
            {
                throw &_exc;
            } // if:  error adding the page to the sheet
        } // for:  each page in the list

    } // try
    catch ( CMemoryException * _pme )
    {
        TRACE( _T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n") );
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  anything
    catch ( CException * _pe )
    {
        TRACE( _T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n") );
        _pe->Delete();
        if ( _hr == NOERROR )
        {
            _hr = E_FAIL;
        } // if:  _hr hasn't beeen set yet
    } // catch:  anything

    if ( _hr != NOERROR )
    {
        piData->Release();
        m_piData = NULL;
    } // if:  error occurred

    piCallback->Release();
    return _hr;

} //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreateWizardPages (IWEExtendWizard)
//
//  Description:
//      Create property sheet pages and add them to the wizard.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object for which the wizard is being displayed.
//
//      piCallback [IN]
//          Pointer to an IWCPropertySheetCallback interface for adding pages
//          to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      _hr             Any error codes from HrGetUIInfo() or HrSaveData().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
    IN IUnknown *           piData,
    IN IWCWizardCallback *  piCallback
    )
{
    HRESULT             _hr     = NOERROR;
    CStackException     _exc( FALSE /*bAutoDelete*/ );
    CRuntimeClass **    _pprtc  = NULL;
    int                 _irtc;
    CBasePropertyPage * _ppage;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Validate the parameters.
    if ( (piData == NULL) || (piCallback == NULL) )
    {
        return E_INVALIDARG;
    } // if:  all interfaces not specified

    try 
    {
        // Get info about displaying UI.
        _hr = HrGetUIInfo( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error getting UI info

        // Save the data.
        _hr = HrSaveData( piData );
        if ( _hr != NOERROR )
        {
            throw &_exc;
        } // if:  error saving data from host

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while ( pos != NULL )
            {
                delete Lpg().GetNext( pos );
            } // while:  more pages in the list
            Lpg().RemoveAll();
        } // Delete any previous pages

        m_piWizardCallback = piCallback;
        m_bWizard = TRUE;

        // Create property pages.
        ASSERT( PodObjData() != NULL );
        switch ( PodObjData()->m_cot )
        {
            case CLUADMEX_OT_RESOURCE:
                _pprtc = g_rgpprtcResWizPages[ IstrResTypeName() ];
                break;

            default:
                _hr = E_NOTIMPL;
                throw &_exc;
                break;
        } // switch:  object type

        // Create each page.
        for ( _irtc = 0 ; _pprtc[ _irtc ] != NULL ; _irtc++ )
        {
            // Create the page.
            _ppage = static_cast< CBasePropertyPage * >( _pprtc[ _irtc ]->CreateObject() );
            ASSERT( _ppage->IsKindOf( _pprtc[ _irtc ] ) );

            // Add it to the list.
            Lpg().AddTail( _ppage );

            // Initialize the property page.
            _hr = _ppage->HrInit( this );
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error initializing the page

            // Create the page.
            _hr = _ppage->HrCreatePage();
            if ( FAILED( _hr ) )
            {
                throw &_exc;
            } // if:  error creating the page

            // Add it to the property sheet.
            _hr = piCallback->AddWizardPage( reinterpret_cast< LONG * >( _ppage->Hpage() ) );
            if ( _hr != NOERROR )
            {
                throw &_exc;
            } // if:  error adding the page to the sheet
        } // for:  each page in the list

    } // try
    catch ( CMemoryException * _pme )
    {
        TRACE( _T("CExtObject::CreateWizardPages() - Failed to add wizard page\n") );
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  anything
    catch ( CException * _pe )
    {
        TRACE( _T("CExtObject::CreateWizardPages() - Failed to add wizard page\n") );
        _pe->Delete();
        if ( _hr == NOERROR )
        {
            _hr = E_FAIL;
        } // if:  _hr hasn't beeen set yet
    } // catch:  anything

    if ( _hr != NOERROR )
    {
        piCallback->Release();
        if ( m_piWizardCallback == piCallback )
        {
            m_piWizardCallback = NULL;
        } // if: already saved interface pointer
        piData->Release();
        m_piData = NULL;
    } // if:  error occurred

    return _hr;

} //*** CExtObject::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetUIInfo
//
//  Description:
//      Get info about displaying UI.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IUnknown::QueryInterface(),
//          HrGetObjectName(), or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IN IUnknown * piData)
{
    HRESULT     _hr = NOERROR;

    ASSERT( piData != NULL );

    // Save info about all types of objects.
    {
        IGetClusterUIInfo * _pi;

        _hr = piData->QueryInterface( IID_IGetClusterUIInfo, reinterpret_cast< LPVOID * >( &_pi ) );
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error querying for interface

        m_lcid = _pi->GetLocale();
        m_hfont = _pi->GetFont();
        m_hicon = _pi->GetIcon();

        _pi->Release();
    } // Save info about all types of objects

    return _hr;

} //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrSaveData
//
//  Routine Description:
//      Save data from the object so that it can be used for the life
//      of the object.
//
//  Arguments:
//      piData [IN]
//          IUnkown pointer from which to obtain interfaces for obtaining data
//          describing the object.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IUnknown::QueryInterface(),
//          HrGetObjectName(), or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IN IUnknown * piData)
{
    HRESULT     _hr = NOERROR;

    ASSERT( piData != NULL );

    if ( piData != m_piData )
    {
        if ( m_piData != NULL )
        {
            m_piData->Release();
        } // if:  interface queried for previously
        m_piData = piData;
    } // if:  different data interface pointer

    // Save info about all types of objects.
    {
        IGetClusterDataInfo *   _pi;

        _hr = piData->QueryInterface( IID_IGetClusterDataInfo, reinterpret_cast< LPVOID * >( &_pi ) );
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error querying for interface

        m_hcluster = _pi->GetClusterHandle();
        m_cobj = _pi->GetObjectCount();
        if ( Cobj() != 1 )  // Only have support for one selected object.
        {
            _hr = E_NOTIMPL;
        } // if:  too many objects for us to handle

        _pi->Release();
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error occurred before here
    } // Save info about all types of objects

    // Save info about this object.
    _hr = HrGetObjectInfo();

    return _hr;

} //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectInfo
//
//  Description:
//      Get information about the object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_OUTOFMEMORY
///         Error allocating memory.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IUnknown::QueryInterface(),
//          HrGetObjectName(), or HrGetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
    HRESULT                     _hr = NOERROR;
    IGetClusterObjectInfo *     _piGcoi;
    CLUADMEX_OBJECT_TYPE        _cot;
    CStackException             _exc( FALSE /*bAutoDelete*/ );
    const CString *             _pstrResTypeName;

    ASSERT( PiData() != NULL );

    // Get object info.
    {
        // Get an IGetClusterObjectInfo interface pointer.
        _hr = PiData()->QueryInterface( IID_IGetClusterObjectInfo, reinterpret_cast< LPVOID * >( &_piGcoi ) );
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error querying for interface

        // Read the object data.
        try
        {
            // Delete the previous object data.
            delete m_podObjData;
            m_podObjData = NULL;

            // Get the type of the object.
            _cot = _piGcoi->GetObjectType( 0 );
            switch ( _cot )
            {
                case CLUADMEX_OT_RESOURCE:
                    {
                        IGetClusterResourceInfo *   _pi;

                        m_podObjData = new CResData;

                        // Get an IGetClusterResourceInfo interface pointer.
                        _hr = PiData()->QueryInterface( IID_IGetClusterResourceInfo, reinterpret_cast< LPVOID * >( &_pi ) );
                        if ( _hr != NOERROR )
                        {
                            throw &_exc;
                        } // if:  error querying for interface

                        PrdResDataRW()->m_hresource = _pi->GetResourceHandle( 0 );
                        ASSERT( PrdResDataRW()->m_hresource != NULL );
                        if ( PrdResDataRW()->m_hresource == NULL )
                        {
                            _hr = E_INVALIDARG;
                        } // if  invalid resource handle
                        else
                        {
                            _hr = HrGetResourceTypeName( _pi );
                        } // else:  resource handle is valid
                        _pi->Release();
                        if ( _hr != NOERROR )
                        {
                            throw &_exc;
                        } // if:  error occurred above

                        _pstrResTypeName = &PrdResDataRW()->m_strResTypeName;
                    } // if:  object is a resource
                    break;

                default:
                    _hr = E_NOTIMPL;
                    throw &_exc;
            } // switch:  object type

            PodObjDataRW()->m_cot = _cot;
            _hr = HrGetObjectName( _piGcoi );
        } // try
        catch ( CException * _pe )
        {
            _pe->Delete();
        } // catch:  CException

        _piGcoi->Release();
        if ( _hr != NOERROR )
        {
            return _hr;
        } // if:  error occurred above
    } // Get object info

    // If this is a resource or resource type, see if we know about this type.
    if (    (   (_cot == CLUADMEX_OT_RESOURCE)
            ||  (_cot == CLUADMEX_OT_RESOURCETYPE) )
        && (_hr == NOERROR) )
    {
        LPCWSTR _pwszResTypeName;

        // Find the resource type name in our list.
        // Save the index for use in other arrays.
        for ( m_istrResTypeName = 0, _pwszResTypeName = g_wszResourceTypeNames
            ; *_pwszResTypeName != L'\0'
            ; m_istrResTypeName++, _pwszResTypeName += lstrlenW( _pwszResTypeName ) + 1
            )
        {
            if ( _pstrResTypeName->CompareNoCase( _pwszResTypeName ) == 0 )
            {
                break;
            } // if:  found resource type name
        } // for:  each resource type in the list
        if ( *_pwszResTypeName == L'\0' )
        {
            _hr = E_NOTIMPL;
        } // if:  resource type name not found
    } // See if we know about this resource type

    return _hr;

} //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectName
//
//  Description:
//      Get the name of the object.
//
//  Arguments:
//      piData [IN]
//          IGetClusterObjectInfo interface pointer for getting the object
//          name.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_OUTOFMEMORY
//          Error allocating memory.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IGetClusterObjectInfo::GetObjectInfo().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(IN IGetClusterObjectInfo * pi)
{
    HRESULT     _hr         = NOERROR;
    WCHAR *     _pwszName   = NULL;
    LONG        _cchName;

    ASSERT( pi != NULL );

    _hr = pi->GetObjectName( 0, NULL, &_cchName );
    if ( _hr != NOERROR )
    {
        return _hr;
    } // if:  error getting object name

    try
    {
        _pwszName = new WCHAR[ _cchName ];
        _hr = pi->GetObjectName( 0, _pwszName, &_cchName );
        if ( _hr != NOERROR )
        {
            delete [] _pwszName;
            _pwszName = NULL;
        } // if:  error getting object name

        PodObjDataRW()->m_strName = _pwszName;
    } // try
    catch ( CMemoryException * _pme )
    {
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  CMemoryException

    delete [] _pwszName;
    return _hr;

} //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetResourceTypeName
//
//  Routine Description:
//      Get the name of the resource's type.
//
//  Arguments:
//      piData [IN]
//          IGetClusterResourceInfo interface pointer for getting the resource
//          type name.
//
//  Return Value:
//      NOERROR
//          Data saved successfully.
//
//      E_OUTOFMEMORY
//          Error allocating memory.
//
//      E_NOTIMPL
//          Not implemented for this type of data.
//
//      _hr
//          Any error codes from IGetClusterResourceInfo
//          ::GetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(IN IGetClusterResourceInfo * pi)
{
    HRESULT     _hr         = NOERROR;
    WCHAR *     _pwszName   = NULL;
    LONG        _cchName;

    ASSERT( pi != NULL );

    _hr = pi->GetResourceTypeName( 0, NULL, &_cchName );
    if ( _hr != NOERROR )
    {
        return _hr;
    } // if:  error getting resource type name

    try
    {
        _pwszName = new WCHAR[ _cchName ];
        _hr = pi->GetResourceTypeName( 0, _pwszName, &_cchName );
        if ( _hr != NOERROR )
        {
            delete [] _pwszName;
            _pwszName = NULL;
        } // if:  error getting resource type name

        PrdResDataRW()->m_strResTypeName = _pwszName;
    } // try
    catch ( CMemoryException * _pme )
    {
        _pme->Delete();
        _hr = E_OUTOFMEMORY;
    } // catch:  CMemoryException

    delete [] _pwszName;
    return _hr;

} //*** CExtObject::HrGetResourceTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\helpids.h ===
#define IDH_VSCSR_COMMAND_RUN       700001762
#define IDH_VSCSR_COMMAND_PARAM     700001763
#define IDH_VSCSR_START_IN          700001764
#define IDH_VSCSR_SCHEDULE          700001765
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 2002 Microsoft Corporation
//
//	Module Name:
//		ExtObj.h
//
//	Implementation File:
//		ExtObj.cpp
//
//	Description:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 2002
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __EXTOBJ_H__
#define __EXTOBJ_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_OBJECT_TYPE and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"	// for CLSID_CoVSSTaskEx
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList< CBasePropertyPage *, CBasePropertyPage * > CPageList;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** class CObjData

/////////////////////////////////////////////////////////////////////////////
// class CNodeData
/////////////////////////////////////////////////////////////////////////////

class CNodeData : public CObjData
{
public:
	HNODE		m_hnode;

};  //*** class CNodeData

/////////////////////////////////////////////////////////////////////////////
// class CGroupData
/////////////////////////////////////////////////////////////////////////////

class CGroupData : public CObjData
{
public:
	HGROUP		m_hgroup;

};  //*** class CGroupData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** class CResData

/////////////////////////////////////////////////////////////////////////////
// class CNetworkData
/////////////////////////////////////////////////////////////////////////////

class CNetworkData : public CObjData
{
public:
	HNETWORK	m_hnetwork;

};  //*** class CNetworkData

/////////////////////////////////////////////////////////////////////////////
// class CNetInterfaceData
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceData : public CObjData
{
public:
	HNETINTERFACE	m_hnetinterface;

};  //*** class CNetInterfaceData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass< CExtObject, &CLSID_CoVSSTaskEx >
{
public:
	CExtObject( void );
BEGIN_COM_MAP( CExtObject )
	COM_INTERFACE_ENTRY_IID( IID_IWEExtendPropertySheet, IWEExtendPropertySheet )
	COM_INTERFACE_ENTRY_IID( IID_IWEExtendWizard, IWEExtendWizard )
	COM_INTERFACE_ENTRY_IID( IID_ISupportErrorInfo, ISupportErrorInfo )
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE( CExtObject ) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY( CExtObject, _T("CLUADMEX.VSSTaskEx"), _T("CLUADMEX.VSSTaskEx"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT )

// ISupportsErrorInfo
	STDMETHOD( InterfaceSupportsErrorInfo )( REFIID riid );

// IWEExtendPropertySheet
public:
	STDMETHOD( CreatePropertySheetPages )(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD( CreateWizardPages )(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterUIInfo data
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;

	// IGetClusterDataInfo data
	HCLUSTER					m_hcluster;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW( void ) const			{ return m_podObjData; }
	CResData *					PrdResDataRW( void ) const			{ return static_cast< CResData * >( m_podObjData ); }

public:
	IUnknown *					PiData( void ) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback( void ) const		{ return m_piWizardCallback; }
	BOOL						BWizard( void ) const				{ return m_bWizard; }
	DWORD						IstrResTypeName( void ) const		{ return m_istrResTypeName; }

	// IGetClusterUIInfo data
	LCID						Lcid( void ) const					{ return m_lcid; }
	HFONT						Hfont( void ) const					{ return m_hfont; }
	HICON						Hicon( void ) const					{ return m_hicon; }

	// IGetClusterDataInfo data
	HCLUSTER					Hcluster( void ) const				{ return m_hcluster; }
	LONG						Cobj( void ) const					{ return m_cobj; }

	const CObjData *			PodObjData( void ) const			{ return m_podObjData; }
	const CNodeData *			PndNodeData( void ) const			{ ASSERT( Cot() == CLUADMEX_OT_NODE ); return static_cast< CNodeData * >( m_podObjData ); }
	const CGroupData *			PgdGroupData( void ) const			{ ASSERT( Cot() == CLUADMEX_OT_GROUP ); return static_cast< CGroupData * >( m_podObjData ); }
	const CResData *			PrdResData( void ) const			{ ASSERT( Cot() == CLUADMEX_OT_RESOURCE ); return static_cast< CResData * >( m_podObjData ); }
	const CNetworkData *		PndNetworkData( void ) const		{ ASSERT( Cot() == CLUADMEX_OT_NETWORK ); return static_cast< CNetworkData * >( m_podObjData ); }
	const CNetInterfaceData *	PndNetInterfaceData( void ) const	{ ASSERT( Cot() == CLUADMEX_OT_NETINTERFACE ); return static_cast< CNetInterfaceData * >( m_podObjData ); }

	CLUADMEX_OBJECT_TYPE		Cot( void ) const					{ ASSERT( PodObjData() != NULL ); return PodObjData()->m_cot; }

	HRESULT						HrGetUIInfo( IN IUnknown * piData );
	HRESULT						HrSaveData( IN IUnknown * piData );
	HRESULT						HrGetObjectInfo( void );
	HRESULT						HrGetObjectName( IN IGetClusterObjectInfo * pi );
	HRESULT						HrGetResourceTypeName( IN IGetClusterResourceInfo * pi );

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg( void )							{ return m_lpg; }

}; //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // __EXTOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      PropList.h
//
//  Implementation File:
//      PropList.cpp
//
//  Description:
//      Definition of the CClusPropList class.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROPLIST_H__
#define __PROPLIST_H__

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CObjectProperty;
class CClusPropValueList;
class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#if !defined( ASSERT )
#include <crtdbg.h>
#define ASSERT _ASSERTE
#endif // !defined( ASSERT )

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CObjectProperty
//
//  Description:
//      Describes a property in a cluster property list.
//
//  Inheritance:
//      CObjectProperty
//
//--
/////////////////////////////////////////////////////////////////////////////

#if defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )

class CObjectProperty
{
public:
    LPCWSTR                 m_pwszName;
    CLUSTER_PROPERTY_FORMAT m_propFormat;

    union CValue
    {
        CString *   pstr;
        LONG *      pl;
        DWORD *     pdw;
        BOOL *      pb;
        struct
        {
            PBYTE * ppb;
            DWORD * pcb;
        };
    };
    CValue                  m_value;
    CValue                  m_valuePrev;
    CValue                  m_valueEx;      // expand_sz value (if any)

    DWORD                   m_fFlags;

    enum ObjPropFlags
    {
        opfNew = 1
    };

    CObjectProperty::CObjectProperty( void )
    {
        m_value.pstr = NULL;
        m_value.pcb = NULL;
        m_valuePrev.pstr = NULL;
        m_valuePrev.pcb = NULL;
        m_valueEx.pstr = NULL;
        m_valueEx.pcb = NULL;
    };

    void    Set(
                IN LPCWSTR pwszName,
                IN CString & rstrValue,
                IN CString & rstrPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_SZ;
        m_value.pstr = &rstrValue;
        m_valuePrev.pstr = &rstrPrevValue;
        m_fFlags = fFlags;

    } //*** Set( CString & )

    void    SetExpandSz(
                IN LPCWSTR pwszName,
                IN CString & rstrValue,
                IN CString & rstrPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
        m_value.pstr = &rstrValue;
        m_valuePrev.pstr = &rstrPrevValue;
        m_fFlags = fFlags;

    } //*** Set( CString & )

    // Set() to get extra EXPANDED_SZ value
    void    Set(
                IN LPCWSTR pwszName,
                IN CString & rstrValue,
                IN CString & rstrPrevValue,
                IN CString & rstrValueEx,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_SZ;
        m_value.pstr = &rstrValue;
        m_valuePrev.pstr = &rstrPrevValue;
        m_valueEx.pstr = &rstrValueEx;
        m_fFlags = fFlags;

    } //*** Set( CString & )

    // Set() to get extra EXPANDED_SZ value
    void    SetExpandSz(
                IN LPCWSTR pwszName,
                IN CString & rstrValue,
                IN CString & rstrPrevValue,
                IN CString & rstrValueEx,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_EXPAND_SZ;
        m_value.pstr = &rstrValue;
        m_valuePrev.pstr = &rstrPrevValue;
        m_valueEx.pstr = &rstrValueEx;
        m_fFlags = fFlags;

    } //*** Set( CString & )

    void    Set(
                IN LPCWSTR pwszName,
                IN LONG & rnValue,
                IN LONG & rnPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_LONG;
        m_value.pl = &rnValue;
        m_valuePrev.pl = &rnPrevValue;
        m_fFlags = fFlags;

    } //*** Set( LONG & )

    void    Set(
                IN LPCWSTR pwszName,
                IN DWORD & rdwValue,
                IN DWORD & rdwPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_DWORD;
        m_value.pdw = &rdwValue;
        m_valuePrev.pdw = &rdwPrevValue;
        m_fFlags = fFlags;

    } //*** Set( DWORD & )

    void    Set(
                IN LPCWSTR pwszName,
                IN BOOL & rbValue,
                IN BOOL & rbPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_DWORD;
        m_value.pb = &rbValue;
        m_valuePrev.pb = &rbPrevValue;
        m_fFlags = fFlags;

    } //*** Set( BOOL & )

    void    Set(
                IN LPCWSTR pwszName,
                IN PBYTE & rpbValue,
                IN DWORD & rcbValue,
                IN PBYTE & rpbPrevValue,
                IN DWORD & rcbPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_BINARY;
        m_value.ppb = &rpbValue;
        m_value.pcb = &rcbValue;
        m_valuePrev.ppb = &rpbPrevValue;
        m_valuePrev.pcb = &rcbPrevValue;
        m_fFlags = fFlags;

    } //*** Set( PBYTE & )

    void    Set(
                IN LPCWSTR pwszName,
                IN LPWSTR & rpwszValue,
                IN DWORD & rcbValue,
                IN LPWSTR & rpwszPrevValue,
                IN DWORD & rcbPrevValue,
                IN DWORD fFlags = 0
                )
    {
        m_pwszName = pwszName;
        m_propFormat = CLUSPROP_FORMAT_MULTI_SZ;
        m_value.ppb = reinterpret_cast< PBYTE * >( &rpwszValue );
        m_value.pcb = &rcbValue;
        m_valuePrev.ppb = reinterpret_cast< PBYTE * >( &rpwszPrevValue );
        m_valuePrev.pcb = &rcbPrevValue;
        m_fFlags = fFlags;

    } //*** Set( LPWSTR & )

}; //*** class CObjectProperty

#endif  // defined( __AFX_H__ ) || ( defined( __ATLTMP_H__ ) && !defined( _ATL_TMP_NO_CSTRING ) )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusPropValueList
//
//  Description:
//      Describes a cluster property list.
//
//  Inheritance:
//      CClusPropValueList
//      CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusPropValueList
#ifdef __AFX_H__
    : public CObject
#endif // __AFX_H__
{
#ifdef __AFX_H__
    DECLARE_DYNAMIC( CClusPropValueList );
#endif // __AFX_H__

public:
    //
    // Construction.
    //

    // Default constructor
    CClusPropValueList( void )
        : m_cbDataSize( 0 )
        , m_cbDataLeft( 0 )
        , m_cbBufferSize( 0 )
        , m_bAtEnd( FALSE )
    {
        m_cbhValueList.pb = NULL;
        m_cbhCurrentValue.pb = NULL;

    } //*** CClusPropValueList()

    // Copy constructor.
    CClusPropValueList( IN const CClusPropValueList & rcpvl )
        : m_cbBufferSize( 0 )
        , m_bAtEnd( FALSE )
    {
        Init( rcpvl );

    } //*** CClusPropValueList()

    // Buffer helper constructor.
    CClusPropValueList( IN CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
        : m_cbBufferSize( 0 )
        , m_bAtEnd( FALSE )
    {
        Init( cbhValueList, cbDataSize );

    } //*** CClusPropValueList()

    // Destructor
    ~CClusPropValueList( void )
    {
        DeleteValueList();

    } //*** ~CClusPropValueList()

    // Initialize the value list
    void Init( IN const CClusPropValueList & rcpvl )
    {
        ASSERT( m_cbBufferSize == 0 );

        m_cbhValueList      = rcpvl.m_cbhValueList;
        m_cbhCurrentValue   = rcpvl.m_cbhCurrentValue;
        m_cbDataSize        = rcpvl.m_cbDataSize;
        m_cbDataLeft        = rcpvl.m_cbDataLeft;
        m_bAtEnd            = rcpvl.m_bAtEnd;

    } //*** Init()

    // Initialize the value list from a buffer helper
    void Init( IN const CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
    {
        ASSERT( m_cbBufferSize == 0 );

        m_cbhValueList      = cbhValueList;
        m_cbhCurrentValue   = cbhValueList;
        m_cbDataSize        = cbDataSize;
        m_cbDataLeft        = cbDataSize;
        m_bAtEnd            = FALSE;

    } //*** Init()

    // Assignment operator
    void operator=( IN const CClusPropValueList & rcpvl )
    {
        ASSERT( m_cbBufferSize == 0 );

        m_cbhValueList      = rcpvl.m_cbhValueList;
        m_cbhCurrentValue   = rcpvl.m_cbhCurrentValue;
        m_cbDataSize        = rcpvl.m_cbDataSize;
        m_cbDataLeft        = rcpvl.m_cbDataLeft;
        m_bAtEnd            = rcpvl.m_bAtEnd;

    } //*** operator=()

public:
    //
    // Accessor methods.
    //

    // Buffer helper cast operator to access the current value
    operator const CLUSPROP_BUFFER_HELPER( void ) const
    {
        return m_cbhCurrentValue;

    } //*** operator CLUSPROP_BUFFER_HELPER()

    // Access the value list
    CLUSPROP_BUFFER_HELPER CbhValueList( void ) const
    {
        return m_cbhValueList;

    } //*** CbhValueList()

    // Access the current value
    CLUSPROP_BUFFER_HELPER CbhCurrentValue( void ) const
    {
        return m_cbhCurrentValue;

    } //*** CbhCurrentValue()

    // Access the format of the current value
    CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_FORMAT >( m_cbhCurrentValue.pValue->Syntax.wFormat );

    } //*** CpfCurrentValueFormat()

    // Access the type of the current value
    CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_TYPE >( m_cbhCurrentValue.pValue->Syntax.wType );

    } //*** CptCurrentValueType()

    // Access the syntax of the current value
    CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_SYNTAX >( m_cbhCurrentValue.pValue->Syntax.dw );

    } //*** CpsCurrentValueSyntax()

    // Access the length of the data of the current value
    DWORD CbCurrentValueLength( void ) const
    {
        DWORD cbLength;

        if ( m_cbhCurrentValue.pb == NULL )
        {
            cbLength = 0;
        } // if: no value list allocated yet
        else
        {
            cbLength = m_cbhCurrentValue.pValue->cbLength;
        } // else: value list allocated

        return cbLength;

    } //*** CbCurrentValueLength()

    // Access size of the data in the buffer.
    DWORD CbDataSize( void ) const
    {
        return m_cbDataSize;

    } //*** CbDataSize()

    // Access amount of data left in buffer after current value
    DWORD CbDataLeft( void ) const
    {
        return m_cbDataLeft;

    } //*** CbDataLeft()

public:
    //
    // Parsing methods.
    //

    // Move to the first value in the list
    DWORD ScMoveToFirstValue( void );

    // Move the value after the current one in the list
    DWORD ScMoveToNextValue( void );

    // Query whether we are at the last value in the list or not
    DWORD ScCheckIfAtLastValue( void );

public:
    //
    // Methods for building a value list.
    //

    // Allocate a value list
    DWORD ScAllocValueList( IN DWORD cbMinimum );

    // Delete the value list buffer and cleanup support variables
    void DeleteValueList( void )
    {
        //
        // If m_cbBufferSize is greater then 0 then we allocated the value list.
        // If it's zero then the value list is a part of the property list in
        // CClusPropList.
        //
        if ( m_cbBufferSize > 0 )
        {
            delete [] m_cbhValueList.pb;
            m_cbhValueList.pb = NULL;
            m_cbhCurrentValue.pb = NULL;
            m_cbBufferSize = 0;
            m_cbDataSize = 0;
            m_cbDataLeft = 0;
            m_bAtEnd = FALSE;
        } // if: we allocated anything

    } //*** DeletePropList()

    // Get a value list from a resource
    DWORD ScGetResourceValueList(
                        IN HRESOURCE    hResource,
                        IN DWORD        dwControlCode,
                        IN HNODE        hHostNode       = NULL,
                        IN LPVOID       lpInBuffer      = NULL,
                        IN DWORD        cbInBufferSize  = 0
                        );

    // Get a value list from a resource type
    DWORD ScGetResourceTypeValueList(
                        IN HCLUSTER hCluster,
                        IN LPCWSTR  pwszResTypeName,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

private:
    CLUSPROP_BUFFER_HELPER  m_cbhValueList;     // Pointer to the value list for parsing.
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentValue;  // Pointer to the current value for parsing.
    DWORD                  m_cbDataSize;       // Amount of data in the buffer.
    DWORD                   m_cbDataLeft;       // Amount of data left in buffer after current value.
    DWORD                   m_cbBufferSize;     // Size of the buffer if we allocated it.
    BOOL                    m_bAtEnd;           // Indicates whether at last value in list.

}; //*** class CClusPropValueList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusPropList
//
//  Description:
//      Describes a cluster property list.
//
//  Inheritance:
//      CClusPropList
//      CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusPropList
#ifdef __AFX_H__
    : public CObject
#endif // __AFX_H__
{
#ifdef __AFX_H__
    DECLARE_DYNAMIC( CClusPropList );
#endif // __AFX_H__

public:
    //
    // Construction.
    //

    // Default constructor
    CClusPropList( IN BOOL bAlwaysAddProp = FALSE )
        : m_bAlwaysAddProp( bAlwaysAddProp )
        , m_cbBufferSize( 0 )
        , m_cbDataSize( 0 )
        , m_cbDataLeft( 0 )
        , m_nPropsRemaining( 0 )
    {
        m_cbhPropList.pList     = NULL;
        m_cbhCurrentProp.pb     = NULL;
        m_cbhCurrentPropName.pb = NULL;

    } //*** CClusPropList()

    // Destructor
    ~CClusPropList( void )
    {
        DeletePropList();

    } //*** ~CClusPropList()

    // Copy list into this list (like assignment operator)
    DWORD ScCopy( IN const PCLUSPROP_LIST pcplPropList, IN DWORD cbListSize );

    // Delete the property list buffer and cleanup support variables
    void DeletePropList( void )
    {
        delete [] m_cbhPropList.pb;
        m_cbhPropList.pb = NULL;
        m_cbhCurrentProp.pb = NULL;
        m_cbhCurrentPropName.pb = NULL;
        m_cbBufferSize = 0;
        m_cbDataSize = 0;
        m_cbDataLeft = 0;

    } //*** DeletePropList()

protected:
    //
    // Attributes.
    //

    BOOL                    m_bAlwaysAddProp;       // Indicate if properties should be added even if not different.
    CLUSPROP_BUFFER_HELPER  m_cbhPropList;          // Pointer to the beginning of the list.
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentProp;       // Pointer to the current property.
    DWORD                   m_cbBufferSize;         // Allocated size of the buffer.
    DWORD                   m_cbDataSize;           // Amount of data in the buffer.
    DWORD                   m_cbDataLeft;           // Amount of data left in buffer after current value.

private:
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentPropName;   // Pointer to the current name for parsing
    DWORD                   m_nPropsRemaining;      // Used by BMoveToNextProperty() to track end of list.
    CClusPropValueList      m_pvlValues;            // Helper class for value list of current property.

public:
    //
    // Accessor methods.
    //

    // Access the values of the current property
    const CClusPropValueList & RPvlPropertyValue( void )
    {
        return m_pvlValues;

    } //*** RPvlPropertyValue()

    // Access the property list
    operator PCLUSPROP_LIST( void ) const
    {
        return m_cbhPropList.pList;

    } //*** operator PCLUSPROP_LIST()

    // Access allocated size of the buffer
    DWORD CbBufferSize( void ) const
    {
        return m_cbBufferSize;

    } //*** CbBufferSize()

    // Access the name of the current property
    LPCWSTR PszCurrentPropertyName( void ) const
    {
        return m_cbhCurrentPropName.pName->sz;

    } //*** PszCurrentPropertyName()

    // Access the current property name as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentPropertyName( void )
    {
        return m_cbhCurrentPropName;

    } //*** CbhCurrentPropertyName()

    // Access value list of the current property as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentValueList( void )
    {
        return m_pvlValues.CbhValueList();

    } //*** CbhCurrentValueList()

    // Access current value of the current property as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentValue( void )
    {
        return m_pvlValues.CbhCurrentValue();

    } //*** CbhCurrentValue()

    // Access the format of the current value of the current property
    CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
    {
        return m_pvlValues.CpfCurrentValueFormat();

    } //*** CpfCurrentValueFormat()

    // Access the type of the current value of the current property
    CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
    {
        return m_pvlValues.CptCurrentValueType();

    } //*** CptCurrentValueType()

    // Access the syntax of the current value of the current property
    CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
    {
        return m_pvlValues.CpsCurrentValueSyntax();

    } //*** CpsCurrentValueSyntax()

    // Access the length of the current value of the current property
    DWORD CbCurrentValueLength( void ) const
    {
        return m_pvlValues.CbCurrentValueLength();

    } //*** CbCurrentValueLength()

    PCLUSPROP_LIST Plist( void )
    {
        return m_cbhPropList.pList;

    } //*** Plist()

    const CLUSPROP_BUFFER_HELPER CbhPropList( void ) const
    {
        return m_cbhPropList;

    } //*** CbhPropList()

    PBYTE PbPropList( void ) const
    {
        return m_cbhPropList.pb;

    } //*** PbPropList()

    DWORD CbPropList( void ) const
    {
        return m_cbDataSize + sizeof( CLUSPROP_SYNTAX ); /*endmark*/

    } //*** CbPropList()

    // Access amount of data left in buffer after current value
    DWORD CbDataLeft( void ) const
    {
        return m_cbDataLeft;

    } //*** CbDataLeft()

    DWORD Cprops( void ) const
    {
        if ( m_cbhPropList.pb == NULL )
        {
            return 0;
        } // if:  no buffer yet

        return m_cbhPropList.pList->nPropertyCount;

    } //*** Cprops()

public:
    //
    // Parsing methods.
    //

    // Initialize the size after getting properties from an external source
    void InitSize( IN DWORD cbSize )
    {
        ASSERT( m_cbhPropList.pb != NULL );
        ASSERT( m_cbBufferSize > 0 );

        m_cbDataSize = cbSize;
        m_cbDataLeft = cbSize;

    } //*** InitSize()

    // Move to the first property in the list
    DWORD ScMoveToFirstProperty( void );

    // Move the property after the current one in the list
    DWORD ScMoveToNextProperty( void );

    // Move to a property by specifying its name
    DWORD ScMoveToPropertyByName( IN LPCWSTR pwszPropName );

    // Move to the first value in the current property
    DWORD ScMoveToFirstPropertyValue( void )
    {
        return m_pvlValues.ScMoveToFirstValue();

    } //*** ScMoveToFirstPropertyValue()

    // Move the the value after the current on in the current property
    DWORD ScMoveToNextPropertyValue( void )
    {
        return m_pvlValues.ScMoveToNextValue();

    } //*** ScMoveToNextPropertyValue()

    // Query whether we are at the last property in the list or not
    DWORD ScCheckIfAtLastProperty( void ) const
    {
        DWORD _sc;

        if ( m_nPropsRemaining <= 1 )
        {
            _sc = ERROR_NO_MORE_ITEMS;
        } // if:  at the last property
        else
        {
            _sc = ERROR_SUCCESS;
        } // else:  not at the last property

        return _sc;

    } //*** ScCheckIfAtLastProperty()

    // Query whether the list is empty or not
    BOOL BIsListEmpty( void ) const
    {
        ASSERT( m_cbhPropList.pb != NULL );
        ASSERT( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

        return m_cbhPropList.pList->nPropertyCount == 0;

    } //*** BIsListEmpty()

public:
    //
    // Methods for building a property list.
    //

    // Allocate a property list
    DWORD ScAllocPropList( IN DWORD cbMinimum );

    void ClearPropList( void )
    {
        m_cbDataSize = 0;
        m_cbDataLeft = 0;

        if ( m_cbBufferSize != 0 )
        {
            ZeroMemory( m_cbhPropList.pb, m_cbBufferSize );
            m_cbhCurrentProp.pb = m_cbhPropList.pb + sizeof( m_cbhPropList.pList->nPropertyCount );
            m_cbhCurrentPropName = m_cbhCurrentProp;
        } // if:  buffer already allocated

    } //*** ClearPropList()

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddMultiSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN DWORD nValue, IN DWORD nPrevValue );

#if CLUSAPI_VERSION >= 0x0500

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LONG nValue, IN LONG nPrevValue );

#endif // CLUSAPI_VERSION >= 0x0500

    DWORD ScAddProp( IN LPCWSTR pwszName, IN ULONGLONG ullValue, IN ULONGLONG ullPrevValue );

    DWORD ScSetPropToDefault( IN LPCWSTR pwszName, IN CLUSTER_PROPERTY_FORMAT propfmt );

    DWORD ScAddProp(
            IN LPCWSTR      pwszName,
            IN const PBYTE  pbValue,
            IN DWORD        cbValue,
            IN const PBYTE  pbPrevValue,
            IN DWORD        cbPrevValue
            );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
    {
        return ScAddProp( pwszName, pwszValue, NULL );

    } //*** ScAddProp()

    DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
    {
        return ScAddExpandSzProp( pwszName, pwszValue, NULL );

    } //*** ScAddExpandSzProp()

public:
    //
    // Get Property methods.
    //

    DWORD ScGetNodeProperties(
                        IN HNODE    hNode,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

    DWORD ScGetGroupProperties(
                        IN HGROUP   hGroup,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

    DWORD ScGetResourceProperties(
                        IN HRESOURCE    hResource,
                        IN DWORD        dwControlCode,
                        IN HNODE        hHostNode       = NULL,
                        IN LPVOID       lpInBuffer      = NULL,
                        IN DWORD        cbInBufferSize  = 0
                        );

    DWORD ScGetResourceTypeProperties(
                        IN HCLUSTER hCluster,
                        IN LPCWSTR  pwszResTypeName,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

    DWORD ScGetNetworkProperties(
                        IN HNETWORK hNetwork,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

    DWORD ScGetNetInterfaceProperties(
                        IN HNETINTERFACE    hNetInterface,
                        IN DWORD            dwControlCode,
                        IN HNODE            hHostNode       = NULL,
                        IN LPVOID           lpInBuffer      = NULL,
                        IN DWORD            cbInBufferSize  = 0
                        );

#if CLUSAPI_VERSION >= 0x0500

    DWORD ScGetClusterProperties(
                        IN HCLUSTER hCluster,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

#endif // CLUSAPI_VERSION >= 0x0500

// Implementation
protected:
    void CopyProp(
            IN PCLUSPROP_SZ             pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN DWORD                    cbsz = 0
            );

    void CopyExpandSzProp(
            IN PCLUSPROP_SZ             pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN DWORD                    cbsz = 0
            );

    void CopyMultiSzProp(
            IN PCLUSPROP_MULTI_SZ       pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN DWORD                    cbsz = 0
            );

    void CopyProp(
            IN PCLUSPROP_DWORD          pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN DWORD                    nValue
            );

#if CLUSAPI_VERSION >= 0x0500

    void CopyProp(
            IN PCLUSPROP_LONG           pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LONG                     nValue
            );

#endif // CLUSAPI_VERSION >= 0x0500

    void CopyProp(
            OUT PCLUSPROP_ULARGE_INTEGER    pprop,
            IN  CLUSTER_PROPERTY_TYPE       proptype,
            IN  ULONGLONG                   nValue
            );

    void CopyProp(
            IN PCLUSPROP_BINARY         pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN const PBYTE              pb,
            IN DWORD                   cb
            );

    void CopyEmptyProp(
            IN PCLUSPROP_VALUE          pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN CLUSTER_PROPERTY_FORMAT  propfmt
            );

}; //*** class CClusPropList

#pragma warning( default : 4201 )

/////////////////////////////////////////////////////////////////////////////

#endif // __PROPLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\proplist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      PropList.cpp
//
//  Description:
//      Implementation of the CClusPropList class.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.h"

#ifdef _DEBUG
#ifdef __AFX_H__
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif // __AFX_H__
#endif

#ifndef __AFX_H__
class CMemoryException
{
public:
    void Delete( void ) { }

}; //*** class CMemoryException
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

const int BUFFER_GROWTH_FACTOR = 256;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CchMultiSz
//
//  Description:
//      Length of all of the substrings of a multisz string minus the final NULL.
//
//      (i.e., includes the nulls of the substrings, excludes the final null)
//      multiszlen( "abcd\0efgh\0\0" => 5 + 5 = 10
//
//  Arguments:
//      psz     [IN] The string to get the length of.
//
//  Return Value:
//      Count of characters in the multisz or 0 if empty.
//
//--
/////////////////////////////////////////////////////////////////////////////
static DWORD CchMultiSz(
    IN LPCWSTR psz
    )
{
    ASSERT( psz != NULL );

    DWORD  _cchTotal = 0;
    DWORD  _cchChars;

    while ( *psz != _T( '\0' ) )
    {
        _cchChars = lstrlenW( psz ) + 1;

        _cchTotal += _cchChars;
        psz += _cchChars;
    } // while: pointer not stopped on EOS

    return _cchTotal;

} //*** CchMultiSz

/////////////////////////////////////////////////////////////////////////////
//++
//
//  NCompareMultiSz
//
//  Description:
//      Compare two MULTI_SZ buffers.
//
//  Arguments:
//      pszSource   [IN] The source string.
//      pszTarget   [IN] The target string.
//
//  Return Value:
//      If the string pointed to by pszSource is less than the string pointed
//      to by pszTarget, the return value is negative. If the string pointed
//      to by pszSource is greater than the string pointed to by pszTarget,
//      the return value is positive. If the strings are equal, the return value
//      is zero.
//
//--
/////////////////////////////////////////////////////////////////////////////
static int NCompareMultiSz(
    IN LPCWSTR pszSource,
    IN LPCWSTR pszTarget
    )
{
    ASSERT( pszSource != NULL );
    ASSERT( pszTarget != NULL );

    while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') )
    {
        //
        // Move to end of strings.
        //
        while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') && ( *pszSource == *pszTarget ) )
        {
            ++pszSource;
            ++pszTarget;
        } // while: pointer not stopped on EOS

        //
        // If strings are the same, skip past terminating NUL.
        // Otherwise exit the loop.
        if ( ( *pszSource == L'\0' ) && ( *pszTarget == L'\0') )
        {
            ++pszSource;
            ++pszTarget;
        } // if: both stopped on EOS
        else
        {
            break;
        } // else: stopped because something is not equal -- wr are done.

    } // while: pointer not stopped on EOS

    return *pszSource - *pszTarget;

} //*** NCompareMultiSz()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropValueList class
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CClusPropValueList, CObject );
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScMoveToFirstValue
//
//  Description:
//      Move the cursor to the first value in the value list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS   Position moved to the first value successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToFirstValue( void )
{
    ASSERT( m_cbhValueList.pb != NULL );

    DWORD   _sc;

    m_cbhCurrentValue = m_cbhValueList;
    m_cbDataLeft = m_cbDataSize;
    m_bAtEnd = FALSE;

    if ( m_cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
    {
        _sc = ERROR_NO_MORE_ITEMS;
    } // if: no items in the value list
    else
    {
        _sc = ERROR_SUCCESS;
    } // else: items exist in the value list

    return _sc;

} //*** CClusPropValueList::ScMoveToFirstValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScMoveToNextValue
//
//  Description:
//      Move the cursor to the next value in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the next value successfully.
//      ERROR_NO_MORE_ITEMS Already at the end of the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToNextValue( void )
{
    ASSERT( m_cbhCurrentValue.pb != NULL );

    DWORD                   _sc     = ERROR_NO_MORE_ITEMS;
    DWORD                   _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;

    _cbhCurrentValue = m_cbhCurrentValue;

    do
    {
        //
        // Don't try to move if we're already at the end.
        //
        if ( m_bAtEnd )
        {
            break;
        } // if: already at the end of the list

        //
        // Make sure the buffer is big enough for the value header.
        //
        if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Calculate how much to advance buffer pointer.
        //
        _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                    + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

        //
        // Make sure the buffer is big enough for the value header,
        // the data itself, and the endmark.
        //
        if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Move past the current value to the next value's syntax.
        //
        _cbhCurrentValue.pb += _cbDataSize;

        //
        // This test will ensure that the value is always valid since we won't
        // advance if the next thing is the endmark.
        //
        if ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
        {
            m_cbhCurrentValue = _cbhCurrentValue;
            m_cbDataLeft -= _cbDataSize;
            _sc = ERROR_SUCCESS;
        } // if: next value's syntax is not the endmark
        else
        {
            m_bAtEnd = TRUE;
        } // else: next value's syntax is the endmark
    } while ( 0 );

    return _sc;

} //*** CClusPropValueList::ScMoveToNextValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScCheckIfAtLastValue
//
//  Description:
//      Indicate whether we are on the last value in the list or not.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Not currently at the last value in the list.
//      ERROR_NO_MORE_ITEMS Currently at the last value in the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScCheckIfAtLastValue( void )
{
    ASSERT( m_cbhCurrentValue.pb != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;
    DWORD                   _cbDataSize;

    _cbhCurrentValue = m_cbhCurrentValue;

    do
    {
        //
        // Don't try to recalculate if we already know
        // we're at the end of the list.
        //
        if ( m_bAtEnd )
        {
            break;
        } // if: already at the end of the list

        //
        // Make sure the buffer is big enough for the value header.
        //
        if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Calculate how much to advance buffer pointer.
        //
        _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                    + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

        //
        // Make sure the buffer is big enough for the value header,
        // the data itself, and the endmark.
        //
        if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Move past the current value to the next value's syntax.
        //
        _cbhCurrentValue.pb += _cbDataSize;

        //
        // We are on the last value if the next thing after this value
        // is an endmark.
        //
        if ( _cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
        {
            _sc = ERROR_NO_MORE_ITEMS;
        } // if: next value's syntax is the endmark
    } while ( 0 );

    return _sc;

} //*** CClusPropValueList::ScCheckIfAtLastValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScAllocValueList
//
//  Description:
//      Allocate a value list buffer that's big enough to hold the next
//      value.
//
//  Arguments:
//      cbMinimum   [IN] Minimum size of the value list.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by new.  By default, no exceptions are thrown.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScAllocValueList( IN DWORD cbMinimum )
{
    ASSERT( cbMinimum > 0 );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbTotal = 0;

    //
    // Add the size of the item count and final endmark.
    //
    cbMinimum += sizeof( CLUSPROP_VALUE );
    _cbTotal = m_cbDataSize + cbMinimum;

    if ( m_cbBufferSize < _cbTotal )
    {
        PBYTE   _pbNewValuelist = NULL;

        cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
        _cbTotal = m_cbDataSize + cbMinimum;

        //
        // Allocate and zero a new buffer.
        //
        _pbNewValuelist = new BYTE[ _cbTotal ];
        if ( _pbNewValuelist != NULL )
        {
            ZeroMemory( _pbNewValuelist, _cbTotal );

            //
            // If there was a previous buffer, copy it and the delete it.
            //
            if ( m_cbhValueList.pb != NULL )
            {
                if ( m_cbDataSize != 0 )
                {
                    CopyMemory( _pbNewValuelist, m_cbhValueList.pb, m_cbDataSize );
                } // if: data already exists in buffer

                delete [] m_cbhValueList.pb;
                m_cbhCurrentValue.pb = _pbNewValuelist + (m_cbhCurrentValue.pb - m_cbhValueList.pb);
            } // if: there was a previous buffer
            else
            {
                m_cbhCurrentValue.pb = _pbNewValuelist + sizeof( DWORD ); // move past prop count
            } // else: no previous buffer

            //
            // Save the new buffer.
            //
            m_cbhValueList.pb = _pbNewValuelist;
            m_cbBufferSize = _cbTotal;
        } // if: allocation succeeded
        else
        {
            _sc = ERROR_NOT_ENOUGH_MEMORY;
        } // else: allocation failed
    } // if: buffer isn't big enough

    return _sc;

} //*** CClusPropValueList::ScAllocValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScGetResourceValueList
//
//  Description:
//      Get value list of a resource.
//
//  Arguments:
//      hResource       [IN] Handle for the resource to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions CClusPropValueList::ScAllocValueList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceValueList(
    IN HRESOURCE    hResource,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    ASSERT( hResource != NULL );
    ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cb = 512;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get values.
    //
    _sc = ScAllocValueList( _cb );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterResourceControl(
                        hResource,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhValueList.pb,
                        m_cbBufferSize,
                        &_cb
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocValueList( _cb );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterResourceControl(
                                hResource,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhValueList.pb,
                                m_cbBufferSize,
                                &_cb
                                );
            } // if: ScAllocValueList succeeded
        } // if: buffer too small
    } // if: ScAllocValueList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeleteValueList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cb;
        m_cbDataLeft = _cb;
    } // else: no errors

    return _sc;

} //*** CClusPropValueList::ScGetResourceValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScGetResourceTypeValueList
//
//  Description:
//      Get value list of a resource type.
//
//  Arguments:
//      hCluster        [IN] Handle for the cluster in which the resource
//                          type resides.
//      pwszResTypeName [IN] Name of the resource type.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions CClusPropValueList::ScAllocValueList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceTypeValueList(
    IN HCLUSTER hCluster,
    IN LPCWSTR  pwszResTypeName,
    IN DWORD    dwControlCode,
    IN HNODE    hHostNode,
    IN LPVOID   lpInBuffer,
    IN DWORD    cbInBufferSize
    )
{
    ASSERT( hCluster != NULL );
    ASSERT( pwszResTypeName != NULL );
    ASSERT( *pwszResTypeName != L'\0' );
    ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cb = 512;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get values.
    //
    _sc = ScAllocValueList( _cb );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterResourceTypeControl(
                        hCluster,
                        pwszResTypeName,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhValueList.pb,
                        m_cbBufferSize,
                        &_cb
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocValueList( _cb );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterResourceTypeControl(
                                hCluster,
                                pwszResTypeName,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhValueList.pb,
                                m_cbBufferSize,
                                &_cb
                                );
            } // if: ScAllocValueList succeeded
        } // if: buffer too small
    } // if: ScAllocValueList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeleteValueList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cb;
        m_cbDataLeft = _cb;
    } // else: no errors

    return _sc;

} //*** CClusPropValueList::ScGetResourceTypeValueList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////

#ifdef __AFX_H__
IMPLEMENT_DYNAMIC( CClusPropList, CObject );
#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScCopy
//
//  Description:
//      Copy a property list.  This function is equivalent to an assignment
//      operator.  Since this operation can fail, no assignment operator is
//      provided.
//
//  Arguments:
//      pcplPropList    [IN] The proplist to copy into this instance.
//      cbListSize      [IN] The total size of the prop list.
//
//  Return Value:
//      Win32 status code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScCopy(
    IN const PCLUSPROP_LIST pcplPropList,
    IN DWORD                cbListSize
    )
{
    ASSERT( pcplPropList != NULL );

    DWORD   _sc = ERROR_SUCCESS;

    //
    // Clean up any vestiges of a previous prop list.
    //
    if ( m_cbhPropList.pb != NULL )
    {
        DeletePropList();
    } // if: the current list is not empty

    //
    // Allocate the new property list buffer.  If successful,
    // copy the source list.
    //
    m_cbhPropList.pb = new BYTE[ cbListSize ];
    if ( m_cbhPropList.pb != NULL )
    {
        CopyMemory( m_cbhPropList.pList, pcplPropList, cbListSize );
        m_cbBufferSize = cbListSize;
        m_cbDataSize   = cbListSize;
        m_cbDataLeft   = cbListSize;
        _sc = ScMoveToFirstProperty();
    } // if: new succeeded
    else
    {
        _sc = ERROR_NOT_ENOUGH_MEMORY;
    } // else:

    return _sc;

} //*** CClusPropList::ScCopy()

////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScMoveToFirstProperty
//
//  Description:
//      Move the cursor to the first propery in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the first property successfully.
//      ERROR_NO_MORE_ITEMS There are no properties in the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToFirstProperty( void )
{
    ASSERT( m_cbhPropList.pb != NULL );
    ASSERT( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

    DWORD                   _sc;
    DWORD                   _cbDataLeft;
    DWORD                   _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;

    do
    {
        //
        // Make sure the buffer is big enough for the list header.
        //
        if ( m_cbDataSize < sizeof( m_cbhPropList.pList->nPropertyCount ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data

        //
        // Set the property counter to the number of properties in the list.
        //
        m_nPropsRemaining = m_cbhPropList.pList->nPropertyCount;

        //
        // Point the name pointer to the first name in the list.
        //
        m_cbhCurrentPropName.pName = &m_cbhPropList.pList->PropertyName;
        m_cbDataLeft = m_cbDataSize - sizeof( m_cbhPropList.pList->nPropertyCount );

        //
        // Check to see if there are any properties in the list.
        //
        if ( m_nPropsRemaining == 0 )
        {
            _sc = ERROR_NO_MORE_ITEMS;
            break;
        } // if: no properties in the list

        //
        // Make sure the buffer is big enough for the first property name.
        //
        if ( m_cbDataLeft < sizeof( *m_cbhCurrentPropName.pName ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Calculate how much to advance the buffer pointer.
        //
        _cbDataSize = sizeof( *m_cbhCurrentPropName.pName )
                    + ALIGN_CLUSPROP( m_cbhCurrentPropName.pName->cbLength );

        //
        // Make sure the buffer is big enough for the name header
        // and the data itself.
        //
        if ( m_cbDataLeft < _cbDataSize )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Point the value buffer to the first value in the list.
        //
        _cbhCurrentValue.pb = m_cbhCurrentPropName.pb + _cbDataSize;
        _cbDataLeft = m_cbDataLeft - _cbDataSize;
        m_pvlValues.Init( _cbhCurrentValue, _cbDataLeft );

        //
        // Indicate we are successful.
        //
        _sc = ERROR_SUCCESS;

    } while ( 0 );

    return _sc;

} //*** CClusPropList::ScMoveToFirstProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScMoveToNextProperty
//
//  Description:
//      Move the cursor to the next property in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the next property successfully.
//      ERROR_NO_MORE_ITEMS Already at the end of the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToNextProperty( void )
{
    ASSERT( m_cbhPropList.pb != NULL );
    ASSERT( m_pvlValues.CbhValueList().pb != NULL );

    DWORD                   _sc;
    DWORD                   _cbNameSize;
    DWORD                   _cbDataLeft;
    DWORD                   _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;
    CLUSPROP_BUFFER_HELPER  _cbhPropName;

    _cbhCurrentValue = m_pvlValues;
    _cbDataLeft = m_pvlValues.CbDataLeft();

    //
    // If we aren't already at the last property, attempt to move to the next one.
    //
    _sc = ScCheckIfAtLastProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        do
        {
            //
            // Make sure the buffer is big enough for the value header.
            //
            if ( _cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
            {
                _sc = ERROR_INVALID_DATA;
                break;
            } // if: not enough data left

            //
            // Careful!  Add offset only to cbhCurrentValue.pb.  Otherwise
            // pointer arithmetic will give undesirable results.
            //
            while ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
            {
                //
                // Make sure the buffer is big enough for the value
                // and an endmark.
                //
                _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                            + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );
                if ( _cbDataLeft < _cbDataSize + sizeof( *_cbhCurrentValue.pSyntax ) )
                {
                    _sc = ERROR_INVALID_DATA;
                    break;
                } // if: not enough data left

                //
                // Advance past the value.
                //
                _cbhCurrentValue.pb += _cbDataSize;
                _cbDataLeft -= _cbDataSize;
            } // while: not at endmark

            if ( _sc != ERROR_SUCCESS )
            {
                break;
            } // if: error occurred in loop

            //
            // Advanced past the endmark.
            // Size check already performed in above loop.
            //
            _cbDataSize = sizeof( *_cbhCurrentValue.pSyntax );
            _cbhCurrentValue.pb += _cbDataSize;
            _cbDataLeft -= _cbDataSize;

            //
            // Point the name pointer to the next name in the list.
            //
            _cbhPropName = _cbhCurrentValue;
            ASSERT( _cbDataLeft == m_cbDataSize - (_cbhPropName.pb - m_cbhPropList.pb) );

            //
            // Calculate the size of the name with header.
            // Make sure the buffer is big enough for the name and an endmark.
            //
            if ( _cbDataLeft < sizeof( *_cbhPropName.pName ) )
            {
                _sc = ERROR_INVALID_DATA;
                break;
            } // if: not enough data
            _cbNameSize = sizeof( *_cbhPropName.pName )
                        + ALIGN_CLUSPROP( _cbhPropName.pName->cbLength );
            if ( _cbDataLeft < _cbNameSize + sizeof( CLUSPROP_SYNTAX ) )
            {
                _sc = ERROR_INVALID_DATA;
                break;
            } // if: not enough data

            //
            // Point the value buffer to the first value in the list.
            //
            _cbhCurrentValue.pb = _cbhPropName.pb + _cbNameSize;
            m_cbhCurrentPropName = _cbhPropName;
            m_cbDataLeft = _cbDataLeft - _cbNameSize;
            m_pvlValues.Init( _cbhCurrentValue, m_cbDataLeft );

            //
            // We've successfully advanced to the next property,
            // so there is now one fewer property remaining.
            //
            --m_nPropsRemaining;
            ASSERT( m_nPropsRemaining >= 1 );

            _sc = ERROR_SUCCESS;

        } while ( 0 );
    } // if: not at last property

    return _sc;

} //*** CClusPropList::ScMoveToNextProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScMoveToPropertyByName
//
//  Description:
//      Find the passed in property name in the proplist.  Note that the
//      cursor is reset to the beginning at the beginning of the routine and
//      the current state of the cursor is lost.
//
//  Arguments:
//      pwszPropName    [IN] Name of the property
//
//  Return Value:
//      TRUE if the property was found, FALSE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToPropertyByName( IN LPCWSTR pwszPropName )
{
    ASSERT( m_cbhPropList.pb != NULL );

    DWORD   _sc;

    _sc = ScMoveToFirstProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        do
        {
            //
            // See if this is the specified property.  If so, we're done.
            //
            if ( lstrcmpiW( m_cbhCurrentPropName.pName->sz, pwszPropName ) == 0 )
            {
                break;
            } // if: property found

            //
            // Advance to the next property.
            //
            _sc = ScMoveToNextProperty();

        } while ( _sc == ERROR_SUCCESS );   // do-while: not end of list
    } // if: successfully moved to the first property

    return _sc;

} //*** ClusPropList::ScMoveToPropertyByName( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAllocPropList
//
//  Description:
//      Allocate a property list buffer that's big enough to hold the next
//      property.
//
//  Arguments:
//      cbMinimum   [IN] Minimum size of the property list.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by new.  By default, no exceptions are thrown.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAllocPropList( IN DWORD cbMinimum )
{
    ASSERT( cbMinimum > 0 );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbTotal = 0;

    //
    // Add the size of the item count and final endmark.
    //
    cbMinimum += sizeof( CLUSPROP_VALUE );
    _cbTotal = m_cbDataSize + cbMinimum;

    if ( m_cbBufferSize < _cbTotal )
    {
        PBYTE   _pbNewProplist = NULL;

        cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
        _cbTotal = m_cbDataSize + cbMinimum;

        //
        // Allocate and zero a new buffer.
        //
        _pbNewProplist = new BYTE[ _cbTotal ];
        if ( _pbNewProplist != NULL )
        {
            ZeroMemory( _pbNewProplist, _cbTotal );

            //
            // If there was a previous buffer, copy it and the delete it.
            //
            if ( m_cbhPropList.pb != NULL )
            {
                if ( m_cbDataSize != 0 )
                {
                    CopyMemory( _pbNewProplist, m_cbhPropList.pb, m_cbDataSize );
                } // if: data already exists in buffer

                delete [] m_cbhPropList.pb;
                m_cbhCurrentProp.pb = _pbNewProplist + (m_cbhCurrentProp.pb - m_cbhPropList.pb);
            } // if: there was a previous buffer
            else
            {
                m_cbhCurrentProp.pb = _pbNewProplist + sizeof( DWORD ); // move past prop count
            } // else: no previous buffer

            //
            // Save the new buffer.
            //
            m_cbhPropList.pb = _pbNewProplist;
            m_cbBufferSize = _cbTotal;
        } // if: allocation succeeded
        else
        {
            _sc = ERROR_NOT_ENOUGH_MEMORY;
        } // else: allocation failed
    } // if: buffer isn't big enough

    return _sc;

} //*** CClusPropList::ScAllocPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    ASSERT( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_SZ            _pValue;

    if (( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ))
    {
        _bValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_bAlwaysAddProp || _bValuesDifferent )
    {
        DWORD   _cbNameSize;
        DWORD   _cbDataSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pStringValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddMultiSzProp
//
//  Description:
//      Add a string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddMultiSzProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    ASSERT( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_MULTI_SZ      _pValue;

    if ( ( pwszPrevValue != NULL ) && ( NCompareMultiSz( pwszValue, pwszPrevValue ) == 0 ) )
    {
        _bValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_bAlwaysAddProp || _bValuesDifferent )
    {
        DWORD   _cbNameSize;
        DWORD  _cbDataSize;
        DWORD  _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbDataSize = (CchMultiSz( pwszValue ) + 1) * sizeof( WCHAR );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pMultiSzValue;
            CopyMultiSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddMultiSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddExpandSzProp
//
//  Description:
//      Add an EXPAND_SZ string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddExpandSzProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    ASSERT( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_SZ            _pValue;

    if ( ( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ) )
    {
        _bValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_bAlwaysAddProp || _bValuesDifferent )
    {
        DWORD   _cbNameSize;
        DWORD   _cbDataSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pStringValue;
            CopyExpandSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddExpandSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a DWORD property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      nValue          [IN] Value of the property to set in the list.
//      nPrevValue      [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN DWORD    nValue,
    IN DWORD    nPrevValue
    )
{
    ASSERT( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_DWORD         _pValue;

    if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_DWORD )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pDwordValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( DWORD )

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a LONG property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      nValue          [IN] Value of the property to set in the list.
//      nPrevValue      [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN LONG     nValue,
    IN LONG     nPrevValue
    )
{
    ASSERT( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_LONG          _pValue;

    if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_LONG )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pLongValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( LONG )

#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a binary property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pbValue         [IN] Value of the property to set in the list.
//      cbValue         [IN] Count of bytes in pbValue.
//      pbPrevValue     [IN] Previous value of the property.
//      cbPrevValue     [IN] Count of bytes in pbPrevValue.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR          pwszName,
    IN const PBYTE      pbValue,
    IN DWORD            cbValue,
    IN const PBYTE      pbPrevValue,
    IN DWORD            cbPrevValue
    )
{
    ASSERT( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bChanged = FALSE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_BINARY        _pValue;

    //
    // Determine if the buffer has changed.
    //
    if ( m_bAlwaysAddProp || (cbValue != cbPrevValue) )
    {
        _bChanged = TRUE;
    } // if: always adding the property or the value size changed
    else if ( ( cbValue != 0 ) && ( cbPrevValue != 0 ) )
    {
        _bChanged = memcmp( pbValue, pbPrevValue, cbValue ) != 0;
    } // else if: value length changed

    if ( _bChanged )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_BINARY )
                    + ALIGN_CLUSPROP( cbValue )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pBinaryValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Routine Description:
//      Add a ULONGLONG property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      ullValue        [IN] Value of the property to set in the list.
//      ullPrevValue    [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR      pwszName,
    IN ULONGLONG    ullValue,
    IN ULONGLONG    ullPrevValue
    )
{
    ASSERT( pwszName != NULL );

    DWORD                       _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME     _pName;
    PCLUSPROP_ULARGE_INTEGER    _pValue;

    if ( m_bAlwaysAddProp || ( ullValue != ullPrevValue ) )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_ULARGE_INTEGER )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pULargeIntegerValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, ullValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScSetPropToDefault
//
//  Description:
//      Add a property to the property list so that it will revert to its
//      default value.
//
//  Arguments:
//      pwszName    [IN] Name of the property.
//      cpfPropFmt  [IN] Format of property
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScSetPropToDefault(
    IN LPCWSTR                  pwszName,
    IN CLUSTER_PROPERTY_FORMAT  cpfPropFmt
    )
{
    ASSERT( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    DWORD                   _cbNameSize;
    DWORD                   _cbValueSize;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_VALUE         _pValue;

    // Calculate sizes and make sure we have a property list.
    _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
    _cbValueSize = sizeof( CLUSPROP_BINARY )
                + sizeof( CLUSPROP_SYNTAX ); // value list endmark

    _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
    if ( _sc == ERROR_SUCCESS )
    {
        //
        // Set the property name.
        //
        _pName = m_cbhCurrentProp.pName;
        CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
        m_cbhCurrentProp.pb += _cbNameSize;

        //
        // Set the property value.
        //
        _pValue = m_cbhCurrentProp.pValue;
        CopyEmptyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, cpfPropFmt );
        m_cbhCurrentProp.pb += _cbValueSize;

        //
        // Increment the property count and buffer size.
        //
        m_cbhPropList.pList->nPropertyCount++;
        m_cbDataSize += _cbNameSize + _cbValueSize;
    } // if:

    return _sc;

} //*** CClusPropList::ScSetPropToDefault()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in pwsz string.  If specified as 0,
//                      the the length will be determined by a call to strlen.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_SZ            pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN DWORD                    cbsz        // = 0
    )
{
    ASSERT( pprop != NULL );
    ASSERT( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
    } // if: zero size specified
    ASSERT( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
    pprop->cbLength = cbsz;
    lstrcpyW( pprop->sz, psz );

    //
    // Set an endmark.
    //
    _cbhProps.pStringValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyMultiSzProp
//
//  Description:
//      Copy a MULTI_SZ string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in psz string.  If specified as 0,
//                      the the length will be determined by calls to strlen.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyMultiSzProp(
    OUT PCLUSPROP_MULTI_SZ      pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN DWORD                    cbsz
    )
{
    ASSERT( pprop != NULL );
    ASSERT( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_MULTI_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (CchMultiSz( psz ) + 1) * sizeof( WCHAR );
    } // if: zero size specified
    ASSERT( cbsz == (CchMultiSz( psz ) + 1) * sizeof( WCHAR ) );
    pprop->cbLength = cbsz;
    CopyMemory( pprop->sz, psz, cbsz );

    //
    // Set an endmark.
    //
    _cbhProps.pMultiSzValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pMultiSzValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyMultiSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyExpandSzProp
//
//  Description:
//      Copy an EXPAND_SZ string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in psz string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyExpandSzProp(
    OUT PCLUSPROP_SZ            pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN DWORD                   cbsz
    )
{
    ASSERT( pprop != NULL );
    ASSERT( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
    } // if: cbsz == 0
    ASSERT( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
    pprop->cbLength = cbsz;
    lstrcpyW( pprop->sz, psz );

    //
    // Set an endmark.
    //
    _cbhProps.pStringValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyExpandSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a DWORD property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of DWORD.
//      nValue      [IN] Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_DWORD         pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN DWORD                    nValue
    )
{
    ASSERT( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = sizeof( DWORD );
    pprop->dw = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pDwordValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pDwordValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( DWORD )

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a LONG property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of LONG.
//      nValue      [IN] Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_LONG          pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LONG                     nValue
    )
{
    ASSERT( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_LONG;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = sizeof( LONG );
    pprop->l = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pLongValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pLongValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( LONG )

#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a ULONGLONG property to a property structure.
//
//  Arguments:
//      pprop       [OUT]   Property structure to fill.
//      proptype    [IN]    Type of LONG.
//      nValue      [IN]    Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_ULARGE_INTEGER    pprop,
    IN  CLUSTER_PROPERTY_TYPE       proptype,
    IN  ULONGLONG                   nValue
    )
{
    ASSERT( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
    pprop->Syntax.wType = static_cast< WORD >( proptype );
    pprop->cbLength = sizeof( ULONGLONG );
    pprop->li.QuadPart = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pULargeIntegerValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pULargeIntegerValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a binary property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      pb          [IN] Block to copy.
//      cbsz        [IN] Count of bytes in pb buffer.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_BINARY        pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN const PBYTE              pb,
    IN DWORD                    cb
    )
{
    ASSERT( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = cb;
    if ( cb > 0 )
    {
        CopyMemory( pprop->rgb, pb, cb );
    } // if: non-zero data length

    //
    // Set an endmark.
    //
    _cbhProps.pBinaryValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cb );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyEmptyProp
//
//  Description:
//      Copy an empty property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of property.
//      cpfPropFmt  [IN] Format of property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyEmptyProp(
    OUT PCLUSPROP_VALUE         pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN CLUSTER_PROPERTY_FORMAT  cptPropFmt
    )
{
    ASSERT( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = static_cast< WORD >( cptPropFmt );
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = 0;

    //
    // Set an endmark.
    //
    _cbhProps.pValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyEmptyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetNodeProperties
//
//  Description:
//      Get properties on a node.
//
//  Arguments:
//      hNode           [IN] Handle for the node to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNodeProperties(
    IN HNODE        hNode,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    ASSERT( hNode != NULL );
    ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterNodeControl(
                        hNode,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterNodeControl(
                                hNode,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                            );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetNodeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetGroupProperties
//
//  Description:
//      Get properties on a group.
//
//  Arguments:
//      hGroup          [IN] Handle for the group to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetGroupProperties(
    IN HGROUP       hGroup,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    ASSERT( hGroup != NULL );
    ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterGroupControl(
                        hGroup,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterGroupControl(
                                hGroup,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetResourceProperties
//
//  Description:
//      Get properties on a resource.
//
//  Arguments:
//      hResource       [IN] Handle for the resource to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceProperties(
    IN HRESOURCE    hResource,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    ASSERT( hResource != NULL );
    ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterResourceControl(
                        hResource,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterResourceControl(
                                hResource,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetResourceProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetResourceTypeProperties
//
//  Description:
//      Get properties on a resource type.
//
//  Arguments:
//      hCluster        [IN] Handle for the cluster in which the resource
//                          type resides.
//      pwszResTypeName [IN] Name of the resource type.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceTypeProperties(
    IN HCLUSTER     hCluster,
    IN LPCWSTR      pwszResTypeName,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    ASSERT( hCluster != NULL );
    ASSERT( pwszResTypeName != NULL );
    ASSERT( *pwszResTypeName != L'\0' );
    ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterResourceTypeControl(
                        hCluster,
                        pwszResTypeName,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterResourceTypeControl(
                                hCluster,
                                pwszResTypeName,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetResourceTypeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetNetworkProperties
//
//  Description:
//      Get properties on a network.
//
//  Arguments:
//      hNetwork        [IN] Handle for the network to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetworkProperties(
    IN HNETWORK     hNetwork,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    ASSERT( hNetwork != NULL );
    ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterNetworkControl(
                        hNetwork,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterNetworkControl(
                                hNetwork,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting private properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetNetworkProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetNetInterfaceProperties
//
//  Description:
//      Get properties on a network interface.
//
//  Arguments:
//      hNetInterface   [IN] Handle for the network interface to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetInterfaceProperties(
    IN HNETINTERFACE    hNetInterface,
    IN DWORD            dwControlCode,
    IN HNODE            hHostNode,
    IN LPVOID           lpInBuffer,
    IN DWORD            cbInBufferSize
    )
{
    ASSERT( hNetInterface != NULL );
    ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc= ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterNetInterfaceControl(
                        hNetInterface,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterNetInterfaceControl(
                                hNetInterface,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting private properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetNetInterfaceProperties()

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetClusterProperties
//
//  Description:
//      Get properties on a cluster.
//
//  Arguments:
//      hCluster        [IN] Handle for the cluster to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions CClusPropList::ScAllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetClusterProperties(
    IN HCLUSTER hCluster,
    IN DWORD    dwControlCode,
    IN HNODE    hHostNode,
    IN LPVOID   lpInBuffer,
    IN DWORD    cbInBufferSize
    )
{
    ASSERT( hCluster != NULL );
    ASSERT( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_CLUSTER << CLUSCTL_OBJECT_SHIFT) );
    ASSERT( dwControlCode == CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES );

    DWORD   _sc= ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterControl(
                        hCluster,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterControl(
                                hCluster,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting private properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetClusterProperties()

#endif // CLUSAPI_VERSION >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	VSSTaskEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\regext.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      RegExt.cpp
//
//  Description:
//      Implementation of routines for extension registration.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ole2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define REG_VALUE_ADMIN_EXTENSIONS L"AdminExtensions"

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    );
static HRESULT RegisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    );
static HRESULT UnregisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    );
static HRESULT UnregisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    );
static DWORD ReadValue(
    IN HKEY         hkey,
    IN LPCWSTR      pwszValueName,
    OUT LPWSTR *    ppwszValue,
    OUT DWORD *     pcbSize
    );

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminClusterExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends the cluster object.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminClusterExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the cluster registry key.
    hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
    if ( hkey == NULL )
    {
        hr = GetLastError();
    } // if:  error getting cluster key
    else
    {
        // Register the extension.
        hr = RegisterAnyCluAdminExtension( hkey, pClsid );

        ClusterRegCloseKey( hkey );
    } // else:  GetClusterKey succeeded

    return hr;

} //*** RegisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllNodesExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all nodes.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNodesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"Nodes", pClsid );

    return hr;

} //*** RegisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllGroupsExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all groups.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllGroupsExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"Groups", pClsid );

    return hr;

} //*** RegisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllResourcesExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all resources.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourcesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"Resources", pClsid );

    return hr;

} //*** RegisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllResourceTypesExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all resource types.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourceTypesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"ResourceTypes", pClsid );

    return hr;

} //*** RegisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllNetworksExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all networks.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetworksExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"Networks", pClsid );

    return hr;

} //*** RegisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminAllNetInterfacesExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends all network interfaces.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetInterfacesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = RegisterAnyCluAdminExtension( hCluster, L"NetInterfaces", pClsid );

    return hr;

} //*** RegisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterCluAdminResourceTypeExtension
//
//  Description:
//      Register with the cluster database a Cluster Administrator Extension
//      DLL that extends resources of a specific type, or the resource type
//      itself.
//
//  Arguments:
//      hCluster            [IN] Handle to the cluster to modify.
//      pwszResourceType    [IN] Resource type name.
//      pClsid              [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminResourceTypeExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszResourceType,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the resource type registry key.
    hkey = GetClusterResourceTypeKey( hCluster, pwszResourceType, KEY_ALL_ACCESS );
    if ( hkey == NULL )
    {
        hr = GetLastError();
    } // if:  error getting resource type key
    else
    {
        // Register the extension.
        hr = RegisterAnyCluAdminExtension( hkey, pClsid );

        ClusterRegCloseKey( hkey );
    } // else:  GetClusterResourceTypeKey succeeded

    return hr;

} //*** RegisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminClusterExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends the cluster object.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminClusterExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the cluster registry key.
    hkey = GetClusterKey( hCluster, KEY_ALL_ACCESS );
    if ( hkey == NULL )
    {
        hr = GetLastError();
    } // if:  error getting cluster key
    else
    {
        // Unregister the extension.
        hr = UnregisterAnyCluAdminExtension( hkey, pClsid );

        ClusterRegCloseKey( hkey );
    } // else:  GetClusterKey succeeded

    return hr;

} //*** UnregisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllNodesExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all nodes.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNodesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"Nodes", pClsid );

    return hr;

} //*** UnregisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllGroupsExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all groups.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllGroupsExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"Groups", pClsid );

    return hr;

} //*** UnregisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllResourcesExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all resources.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourcesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"Resources", pClsid );

    return hr;

} //*** UnregisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllResourceTypesExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all resource types.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourceTypesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"ResourceTypes", pClsid );

    return hr;

} //*** UnregisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllNetworksExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all networks.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetworksExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"Networks", pClsid );

    return hr;

} //*** UnregisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminAllNetInterfacesExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends all network interfaces.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetInterfacesExtension(
    IN HCLUSTER         hCluster,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;

    hr = UnregisterAnyCluAdminExtension( hCluster, L"NetInterfaces", pClsid );

    return hr;

} //*** UnregisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterCluAdminResourceTypeExtension
//
//  Description:
//      Unregister with the cluster database a Cluster Administrator Extension
//      DLL that extends resources of a specific type, or the resource type
//      itself.
//
//  Arguments:
//      hCluster            [IN] Handle to the cluster to modify.
//      pwszResourceType    [IN] Resource type name.
//      pClsid              [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminResourceTypeExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszResourceType,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkey;

    // Get the resource type registry key.
    hkey = GetClusterResourceTypeKey( hCluster, pwszResourceType, KEY_ALL_ACCESS );
    if ( hkey == NULL )
    {
        hr = GetLastError();
    } // if:  error getting resource type key
    else
    {
        // Unregister the extension.
        hr = UnregisterAnyCluAdminExtension( hkey, pClsid );

        ClusterRegCloseKey( hkey );
    } // else:  GetClusterResourceTypeKey succeeded

    return hr;

} //*** UnregisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterAnyCluAdminExtension
//
//  Description:
//      Register any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pwszKeyName     [IN] Key name.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkeyCluster;
    HKEY        hkey;

    // Get the cluster key.
    hkeyCluster = GetClusterKey( hCluster, KEY_ALL_ACCESS );
    if ( hkeyCluster == NULL )
    {
        hr = GetLastError();
    } // if:  error getting cluster key
    else
    {
        // Get the specified key.
        hr = ClusterRegOpenKey( hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( hr == ERROR_SUCCESS )
        {
            // Register the extension.
            hr = RegisterAnyCluAdminExtension( hkey, pClsid );

            ClusterRegCloseKey( hkey );
        } // else:  GetClusterResourceTypeKey succeeded

        ClusterRegCloseKey( hkeyCluster );
    } // if:  cluster key retrieved successfully

    return hr;

} //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  RegisterAnyCluAdminExtension
//
//  Description:
//      Register any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hkey            [IN] Cluster database key.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    LPOLESTR    pwszClsid;
    DWORD       cbSize;
    DWORD       cbNewSize;
    LPWSTR      pwszValue;
    LPWSTR      pwszNewValue;
    BOOL        bAlreadyRegistered;

    // Convert the CLSID to a string.
    hr = StringFromCLSID( *pClsid, &pwszClsid );
    if ( hr == S_OK )
    {
        // Read the current value.
        hr = ReadValue( hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize );
        if (hr == S_OK)
        {
            // Check to see if the extension has been registered yet.
            if ( pwszValue == NULL )
            {
                bAlreadyRegistered = FALSE;
            } // if:  empty value found
            else
            {
                LPCWSTR pwszValueBuf = pwszValue;

                while ( *pwszValueBuf != L'\0' )
                {
                    if ( lstrcmpiW( pwszClsid, pwszValueBuf ) == 0 )
                    {
                        break;
                    } // if:  CLSID for this extension already in list
                    pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
                } // while:  more strings in the extension list
                bAlreadyRegistered = (*pwszValueBuf != L'\0');
            } // else:  extension value exists

            // Register the extension.
            if ( ! bAlreadyRegistered )
            {
                // Allocate a new buffer.
                cbNewSize = cbSize + (lstrlenW( pwszClsid ) + 1) * sizeof( WCHAR );
                if ( cbSize == 0 ) // Add size of final NULL if first entry.
                {
                    cbNewSize += sizeof( WCHAR );
                } // if:  no previous value
                pwszNewValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbNewSize ) );
                if ( pwszNewValue == NULL )
                {
                    hr = GetLastError();
                } // if:  error allocating memory
                else
                {
                    LPCWSTR pwszValueBuf    = pwszValue;
                    LPWSTR  pwszNewValueBuf = pwszNewValue;
                    DWORD   cch;
                    DWORD   dwType;

                    // Copy the existing extensions to the new buffer.
                    if ( pwszValue != NULL)
                    {
                        while ( *pwszValueBuf != L'\0' )
                        {
                            lstrcpyW( pwszNewValueBuf, pwszValueBuf );
                            cch = lstrlenW( pwszValueBuf );
                            pwszValueBuf += cch + 1;
                            pwszNewValueBuf += cch + 1;
                        } // while:  more strings in the extension list
                    } // if:  previous value buffer existed

                    // Add the new CLSID to the list.
                    lstrcpyW( pwszNewValueBuf, pwszClsid );
                    pwszNewValueBuf += lstrlenW( pwszClsid ) + 1;
                    *pwszNewValueBuf = L'\0';

                    // Write the value to the cluster database.
                    dwType = REG_MULTI_SZ;
                    hr = ClusterRegSetValue(
                                    hkey,
                                    REG_VALUE_ADMIN_EXTENSIONS,
                                    dwType,
                                    reinterpret_cast< LPBYTE >( pwszNewValue ),
                                    cbNewSize
                                    );

                    LocalFree( pwszNewValue );
                } // else:  new buffer allocated successfully

            } // if:  extension not registered yet

            LocalFree( pwszValue );
        } // if:  value read successfully

        CoTaskMemFree( pwszClsid );
    } // if:  CLSID converted to a string successfully

    return hr;

} //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterAnyCluAdminExtension
//
//  Description:
//      Unregister any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//      pwszKeyName     [IN] Key name.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
    IN HCLUSTER         hCluster,
    IN LPCWSTR          pwszKeyName,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    HKEY        hkeyCluster;
    HKEY        hkey;

    // Get the cluster key.
    hkeyCluster = GetClusterKey( hCluster, KEY_ALL_ACCESS );
    if ( hkeyCluster == NULL )
    {
        hr = GetLastError();
    } // if:  error getting cluster key
    else
    {
        // Get the specified key.
        hr = ClusterRegOpenKey( hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( hr == ERROR_SUCCESS )
        {
            // Unregister the extension.
            hr = UnregisterAnyCluAdminExtension( hkey, pClsid );

            ClusterRegCloseKey( hkey );
        } // else:  GetClusterResourceTypeKey succeeded

        ClusterRegCloseKey( hkeyCluster );
    } // if:  cluster key retrieved successfully

    return hr;

} //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  UnregisterAnyCluAdminExtension
//
//  Description:
//      Unregister any Cluster Administrator Extension DLL with the cluster
//      database.
//
//  Arguments:
//      hkey            [IN] Cluster database key.
//      pClsid          [IN] Extension's CLSID.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
    IN HKEY             hkey,
    IN const CLSID *    pClsid
    )
{
    HRESULT     hr;
    LPOLESTR    pwszClsid;
    DWORD       cbSize;
    DWORD       cbNewSize;
    LPWSTR      pwszValue;
    LPWSTR      pwszNewValue;
    BOOL        bAlreadyUnregistered;

    // Convert the CLSID to a string.
    hr = StringFromCLSID( *pClsid, &pwszClsid );
    if ( hr == S_OK )
    {
        // Read the current value.
        hr = ReadValue( hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize );
        if ( hr == S_OK )
        {
            // Check to see if the extension has been unregistered yet.
            if ( pwszValue == NULL )
            {
                bAlreadyUnregistered = TRUE;
            } // if:  empty value found
            else
            {
                LPCWSTR pwszValueBuf = pwszValue;

                while ( *pwszValueBuf != L'\0' )
                {
                    if ( lstrcmpiW( pwszClsid, pwszValueBuf ) == 0 )
                    {
                        break;
                    } // if:  CLSID for this extension found in list
                    pwszValueBuf += lstrlenW( pwszValueBuf ) + 1;
                } // while:  more strings in the extension list
                bAlreadyUnregistered = (*pwszValueBuf == L'\0');
            } // else:  extension value exists

            // Unregister the extension.
            if ( ! bAlreadyUnregistered )
            {
                // Allocate a new buffer.
                cbNewSize = cbSize - (lstrlenW( pwszClsid ) + 1) * sizeof( WCHAR );
                if ( cbNewSize == sizeof( WCHAR ) )
                {
                    cbNewSize = 0;
                } // if:  no previous value
                pwszNewValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbNewSize ) );
                if ( pwszNewValue == NULL )
                {
                    hr = GetLastError();
                } // if:  error allocating memory
                else
                {
                    LPCWSTR pwszValueBuf    = pwszValue;
                    LPWSTR  pwszNewValueBuf = pwszNewValue;
                    DWORD   dwType;

                    // Copy the existing extensions to the new buffer.
                    if ( (cbNewSize > 0) && (pwszValue != NULL) )
                    {
                        while ( *pwszValueBuf != L'\0' )
                        {
                            if ( lstrcmpiW( pwszClsid, pwszValueBuf ) != 0 )
                            {
                                lstrcpyW( pwszNewValueBuf, pwszValueBuf );
                                pwszNewValueBuf += lstrlenW( pwszNewValueBuf ) + 1;
                            } // if:  not CLSID being removed
                            pwszValueBuf += lstrlenW( pwszValueBuf ) + 1;
                        } // while:  more strings in the extension list
                        *pwszNewValueBuf = L'\0';
                    } // if:  previous value buffer existed

                    // Write the value to the cluster database.
                    dwType = REG_MULTI_SZ;
                    hr = ClusterRegSetValue(
                                    hkey,
                                    REG_VALUE_ADMIN_EXTENSIONS,
                                    dwType,
                                    reinterpret_cast< LPBYTE >( pwszNewValue ),
                                    cbNewSize
                                    );

                    LocalFree( pwszNewValue );
                } // else:  new buffer allocated successfully

            } // if:  extension not unregistered yet

            LocalFree( pwszValue );
        } // if:  value read successfully

        CoTaskMemFree( pwszClsid );
    } // if:  CLSID converted to a string successfully

    return hr;

} //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ReadValue
//
//  Description:
//      Reads a value from the cluster database.
//
//  Arguments:
//      hkey [IN]
//          Handle for the key to read from.
//
//      pwszValueName [IN]
//          Name of value to read.
//
//      ppwszValue [OUT]
//          Address of pointer in which to return data.  The string is
//          allocated using LocalAlloc and must be deallocated by the calling
//          LocalFree.
//
//      pcbSize [OUT]
//          Size in bytes of the allocated value buffer.
//
//  Return Value:
//      Any return values from ClusterRegQueryValue or errors from new.
//
//--
/////////////////////////////////////////////////////////////////////////////

static DWORD ReadValue(
    IN HKEY         hkey,
    IN LPCWSTR      pwszValueName,
    OUT LPWSTR *    ppwszValue,
    OUT DWORD *     pcbSize
    )
{
    DWORD       dwStatus;
    DWORD       cbSize;
    DWORD       dwType;
    LPWSTR      pwszValue;

    *ppwszValue = NULL;
    *pcbSize = 0;

    // Get the length of the value.
    dwStatus = ClusterRegQueryValue(
                    hkey,
                    pwszValueName,
                    &dwType,
                    NULL,
                    &cbSize
                    );
    if (    (dwStatus != ERROR_SUCCESS)
        &&  (dwStatus != ERROR_MORE_DATA) )
    {
        if ( dwStatus  == ERROR_FILE_NOT_FOUND )
        {
            dwStatus = ERROR_SUCCESS;
        } // if:  value not found
        return dwStatus;
    } // if:  error occurred

    if ( cbSize > 0 )
    {
        // Allocate a value string.
        pwszValue = reinterpret_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbSize ) );
        if ( pwszValue == NULL )
        {
            dwStatus = GetLastError();
            return dwStatus;
        } // if:  error allocating memory

        // Read the the value.
        dwStatus = ClusterRegQueryValue(
                        hkey,
                        pwszValueName,
                        &dwType,
                        reinterpret_cast< LPBYTE >( pwszValue ),
                        &cbSize
                        );
        if ( dwStatus != ERROR_SUCCESS )
        {
            LocalFree( pwszValue );
            pwszValue = NULL;
            cbSize = 0;
        } // if:  error occurred

        *ppwszValue = pwszValue;
        *pcbSize = cbSize;
    } // if:  value is not empty

    return dwStatus;

} //*** ReadValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\resprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      ResProp.cpp
//
//  Description:
//      Implementation of the resource extension property page classes.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSSTaskEx.h"
#include "ResProp.h"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "BasePage.inl"
#include "HelpData.h"

#include <mstask.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVSSTaskParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CVSSTaskParamsPage, CBasePropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CVSSTaskParamsPage, CBasePropertyPage )
    //{{AFX_MSG_MAP(CVSSTaskParamsPage)
    ON_EN_CHANGE( IDC_PP_VSSTASK_APPLICATIONNAME, OnChangeRequiredField )
    ON_BN_CLICKED(IDC_SCHEDULE, OnSchedule)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
    ON_EN_CHANGE( IDC_PP_VSSTASK_APPLICATIONPARAMS, CBasePropertyPage::OnChangeCtrl )
    ON_EN_CHANGE( IDC_PP_VSSTASK_CURRENTDIRECTORY, CBasePropertyPage::OnChangeCtrl )
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVSSTaskParamsPage::CVSSTaskParamsPage
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CVSSTaskParamsPage::CVSSTaskParamsPage( void )
    : CBasePropertyPage( 
            CVSSTaskParamsPage::IDD,
            g_aHelpIDs_IDD_PP_VSSTASK_PARAMETERS,
            g_aHelpIDs_IDD_WIZ_VSSTASK_PARAMETERS
            )
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CVSSTaskParamsPage)
    m_strCurrentDirectory = _T("");
    m_strApplicationName = _T("");
    m_strApplicationParams = _T("");
    m_pbTriggerArray = NULL;
    m_dwTriggerArraySize = 0;

    //}}AFX_DATA_INIT

    // Setup the property array.
    {
        m_rgProps[ epropCurrentDirectory ].SetExpandSz( REGPARAM_VSSTASK_CURRENTDIRECTORY, m_strCurrentDirectory, m_strPrevCurrentDirectory );
        m_rgProps[ epropApplicationName ].Set( REGPARAM_VSSTASK_APPLICATIONNAME, m_strApplicationName, m_strPrevApplicationName );
        m_rgProps[ epropApplicationParams ].Set( REGPARAM_VSSTASK_APPLICATIONPARAMS, m_strApplicationParams, m_strPrevApplicationParams );
        m_rgProps[ epropTriggerArray ].Set ( REGPARAM_VSSTASK_TRIGGERARRAY, m_pbTriggerArray, m_dwTriggerArraySize, m_pbPrevTriggerArray, m_dwPrevTriggerArraySize, 0);

    } // Setup the property array

    m_iddPropertyPage = IDD_PP_VSSTASK_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_VSSTASK_PARAMETERS;

} //*** CVSSTaskParamsPage::CVSSTaskParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVSSTaskParamsPage::DoDataExchange
//
//  Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CVSSTaskParamsPage::DoDataExchange( CDataExchange * pDX )
{
    if ( ! pDX->m_bSaveAndValidate || ! BSaved() )
    {
        AFX_MANAGE_STATE( AfxGetStaticModuleState() );

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CVSSTaskParamsPage)
        DDX_Control( pDX, IDC_PP_VSSTASK_CURRENTDIRECTORY, m_editCurrentDirectory );
        DDX_Control( pDX, IDC_PP_VSSTASK_APPLICATIONNAME, m_editApplicationName );
        DDX_Text( pDX, IDC_PP_VSSTASK_CURRENTDIRECTORY, m_strCurrentDirectory );
        DDX_Text( pDX, IDC_PP_VSSTASK_APPLICATIONNAME, m_strApplicationName );
        DDX_Text( pDX, IDC_PP_VSSTASK_APPLICATIONPARAMS, m_strApplicationParams );
        //}}AFX_DATA_MAP

        // Handle numeric parameters.
        if ( ! BBackPressed() )
        {
        } // if: back button not pressed

        // TODO: Add any additional field validation here.
        if ( pDX->m_bSaveAndValidate )
        {
            // Make sure all required fields are present.
            if ( ! BBackPressed() )
            {
                DDV_RequiredText( pDX, IDC_PP_VSSTASK_APPLICATIONNAME, IDC_PP_VSSTASK_APPLICATIONNAME_LABEL, m_strApplicationName );
            } // if: back button not pressed
        } // if: saving data from dialog
    } // if: not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange( pDX );

} //*** CVSSTaskParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVSSTaskParamsPage::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CVSSTaskParamsPage::OnInitDialog( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CBasePropertyPage::OnInitDialog();

    // TODO:
    // Limit the size of the text that can be entered in edit controls.

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

} //*** CVSSTaskParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVSSTaskParamsPage::OnSetActive
//
//  Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CVSSTaskParamsPage::OnSetActive( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Enable/disable the Next/Finish button.
    if ( BWizard() )
    {
        EnableNext( BAllRequiredFieldsPresent() );
    } // if: displaying a wizard

    return CBasePropertyPage::OnSetActive();

} //*** CVSSTaskParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVSSTaskParamsPage::OnChangeRequiredField
//
//  Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CVSSTaskParamsPage::OnChangeRequiredField( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    OnChangeCtrl();

    if ( BWizard() )
    {
        EnableNext( BAllRequiredFieldsPresent() );
    } // if: displaying a wizard

} //*** CVSSTaskParamsPage::OnChangeRequiredField()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVSSTaskParamsPage::BAllRequiredFieldsPresent
//
//  Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CVSSTaskParamsPage::BAllRequiredFieldsPresent( void ) const
{
    BOOL    _bPresent;

    if ( 0
        || (m_editApplicationName.GetWindowTextLength() == 0)
        )
    {
        _bPresent = FALSE;
    } // if: required field not present
    else
    {
        _bPresent = TRUE;
    } // else: all required fields are present

    return _bPresent;

} //*** CVSSTaskParamsPage::BAllRequiredFieldsPresent()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVSSTaskParamsPage::OnSchedule
//
//  Description:
//      Handler for "Schedule" button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CVSSTaskParamsPage::OnSchedule() 
{
    HRESULT             hr = S_OK;
    TASKPAGE            tpType = TASKPAGE_SCHEDULE;
    BOOL                fTaskCreated = FALSE;
    HPROPSHEETPAGE      phPage; 
    PROPSHEETHEADER     psh;
    LPCWSTR             pwszTaskName = L"$CluAdmin$Task$";
    INT_PTR             psResult;
    ITaskScheduler      *pITS = NULL;
    ITask               *pITask = NULL;
    IProvideTaskPage    *pIProvTaskPage = NULL;
    ITaskTrigger        *pITaskTrigger = NULL;
    DWORD               dwOffset;
    PTASK_TRIGGER       pTrigger;
    TASK_TRIGGER        aTrigger;
    WORD                iTriggerEnum, iTriggerCount;

    do {
        try { // catch any exceptions

            hr = CoCreateInstance(CLSID_CTaskScheduler,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_ITaskScheduler,
                                  (void **) &pITS);
            if (FAILED(hr)) break; 

            /////////////////////////////////////////////////////////////////
            // Call ITaskScheduler::NewWorkItem to create a temporary task.
            /////////////////////////////////////////////////////////////////

            hr = pITS->NewWorkItem(pwszTaskName,           // Name of task
                                   CLSID_CTask,            // Class identifier 
                                   IID_ITask,              // Interface identifier
                                   (IUnknown**)&pITask); // Address of task interface

            if (FAILED(hr)) break; 

            fTaskCreated = TRUE;

            ///////////////////////////////////////////////////////////////////
            // Fill in the trigger info from the parameters
            ///////////////////////////////////////////////////////////////////
            dwOffset = 0;
            while (dwOffset < m_dwTriggerArraySize)
            {
                pTrigger = (PTASK_TRIGGER)((BYTE *)m_pbTriggerArray + dwOffset);
                if (dwOffset + pTrigger->cbTriggerSize > m_dwTriggerArraySize)
                {
                    hr = ERROR_INVALID_DATA;
                    break;
                }

                hr = pITask->CreateTrigger(&iTriggerEnum, &pITaskTrigger);
                if (FAILED(hr)) break;

                hr = pITaskTrigger->SetTrigger (pTrigger);
                if (FAILED(hr)) break;

                dwOffset += pTrigger->cbTriggerSize;
            }
            if (FAILED(hr)) break;

            ///////////////////////////////////////////////////////////////////
            // Call ITask::QueryInterface to retrieve the IProvideTaskPage 
            // interface, and call IProvideTaskPage::GetPage to retrieve the 
            // task page.
            ///////////////////////////////////////////////////////////////////

            hr = pITask->QueryInterface(IID_IProvideTaskPage,
                                      (void **)&pIProvTaskPage);
            if (FAILED(hr)) break;

            hr = pIProvTaskPage->GetPage(tpType,
                                         FALSE,
                                         &phPage);

            ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
            psh.dwSize = sizeof(PROPSHEETHEADER);
            psh.dwFlags = PSH_DEFAULT | PSH_NOAPPLYNOW;
            psh.phpage = &phPage;
            psh.nPages = 1;
            psResult = PropertySheet(&psh);
            if (psResult <= 0) break;

            ///////////////////////////////////////////////////////////////////
            // Fill in the new trigger info
            ///////////////////////////////////////////////////////////////////

            hr = pITask->GetTriggerCount(&iTriggerCount);
            if (FAILED(hr)) break;

            pTrigger = (PTASK_TRIGGER) new BYTE [iTriggerCount * sizeof(TASK_TRIGGER)];
            for (iTriggerEnum = 0; iTriggerEnum < iTriggerCount; iTriggerEnum++)
            {
                hr = pITask->GetTrigger(iTriggerEnum, &pITaskTrigger);
                if (FAILED(hr)) break;

                hr = pITaskTrigger->GetTrigger(&aTrigger);
                if (FAILED(hr)) break;

                pTrigger[iTriggerEnum] = aTrigger;
            }

            if (FAILED(hr)) break;

            ///////////////////////////////////////////////////////////////////
            // Switch the trigger info with the old data
            ///////////////////////////////////////////////////////////////////
        
            delete [] m_pbTriggerArray;
            m_dwTriggerArraySize = iTriggerCount * sizeof(TASK_TRIGGER);
            m_pbTriggerArray = (BYTE *) pTrigger;
        }

        catch ( CMemoryException * exc )
        {
            exc->Delete();
            hr = E_OUTOFMEMORY;
        }

    } while (0);

    // If anything failed, dump a message
    //
    if (FAILED(hr))
    {
        CString strMsg;
        CString strMsgId;
        strMsgId.Format(L"%08.8x", hr);
        strMsg.FormatMessage(IDS_FAILED_TO_SETUP_SCHEDULE, strMsgId, 1, 2, 3);
        AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
        strMsgId.Empty();
        strMsg.Empty();
    }

    // Cleanup
    //
    if (fTaskCreated) pITS->Delete(pwszTaskName);
    if (pITaskTrigger != NULL) pITaskTrigger->Release();
    if (pIProvTaskPage != NULL) pIProvTaskPage->Release();
    if (pITask != NULL) pITask->Release();
    if (pITS != NULL) pITS->Release();  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\resprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 2002 Microsoft Corporation
//
//	Module Name:
//		ResProp.h
//
//	Implementation File:
//		ResProp.cpp
//
//	Description:
//		Definition of the resource extension property page classes.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 2002
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESPROP_H__
#define __RESPROP_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectPropert
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CVSSTaskParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CVSSTaskParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CVSSTaskParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE( CVSSTaskParamsPage )

// Construction
public:
	CVSSTaskParamsPage( void );

// Dialog Data
	//{{AFX_DATA(CVSSTaskParamsPage)
	enum { IDD = IDD_PP_VSSTASK_PARAMETERS };
	CEdit	m_editCurrentDirectory;
	CEdit	m_editApplicationName;
	CString	m_strCurrentDirectory;
	CString	m_strApplicationName;
	CString	m_strApplicationParams;
	PBYTE	m_pbTriggerArray;
	DWORD	m_dwTriggerArraySize;
	//}}AFX_DATA
	CString	m_strPrevCurrentDirectory;
	CString	m_strPrevApplicationName;
	CString	m_strPrevApplicationParams;
	PBYTE	m_pbPrevTriggerArray;
	DWORD	m_dwPrevTriggerArraySize;

protected:
	enum
	{
		epropCurrentDirectory,
		epropApplicationName,
		epropApplicationParams,
        epropTriggerArray,
		epropMAX
	};
	CObjectProperty		m_rgProps[ epropMAX ];

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CVSSTaskParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops( void ) const	{ return m_rgProps; }
	virtual DWORD					Cprops( void ) const	{ return sizeof( m_rgProps ) / sizeof( CObjectProperty ); }

// Implementation
protected:
	BOOL	BAllRequiredFieldsPresent( void ) const;

	// Generated message map functions
	//{{AFX_MSG(CVSSTaskParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeRequiredField();
	afx_msg void OnSchedule();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CVSSTaskParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // __RESPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VSSTaskEx.rc
//
#define IDD_PP_VSSTASK_PARAMETERS 130
#define IDD_WIZ_VSSTASK_PARAMETERS 131
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001

#define IDC_PP_VSSTASK_CURRENTDIRECTORY_LABEL   1010
#define IDC_PP_VSSTASK_CURRENTDIRECTORY         1011
#define IDC_PP_VSSTASK_APPLICATIONNAME_LABEL    1012
#define IDC_PP_VSSTASK_APPLICATIONNAME          1013
#define IDC_PP_VSSTASK_APPLICATIONPARAMS_LABEL  1014
#define IDC_PP_VSSTASK_APPLICATIONPARAMS        1015

#define IDC_SCHEDULE                    1200

#define IDS_CLUADMEX_COMOBJ_DESC        31100
#define IDS_ERROR_MSG_ID                31101
#define IDS_REQUIRED_FIELD_EMPTY        31102
#define IDS_ERROR_SETTING_PROPERTIES    31103
#define IDS_ERROR_VALIDATING_PROPERTIES 31104

#define IDS_APPLY_PARAM_CHANGES_ERROR   31200
#define IDS_FAILED_TO_SETUP_SCHEDULE    31201

#define IDS_MENU_WHATS_THIS             31300

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1202
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\regext.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 2002 Microsoft Corporation
//
//	Module Name:
//		RegExt.h
//
//	Implementation File:
//		RegExt.cpp
//
//	Description:
//		Definitions of routines for extension registration.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 2002
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __REGEXT_H__
#define __REGEXT_H__

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

// Registration routines.

STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

// Unregistration routines.

STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

/////////////////////////////////////////////////////////////////////////////

#endif // __REGEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE            // Microsoft Windows NT Cluster Administrator
                            //   Extension DLLs need to be Unicode
                            //   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment( lib, "clusapi.lib" )

// Link against the Cluster Administrator Extensions library.
#pragma comment( lib, "cluadmex.lib" )

// Link against Resource Utilities library.
#pragma comment( lib, "resutils.lib" )

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)     // unreferenced formal parameters
#pragma warning(disable : 4702)     // unreachable code
#pragma warning(disable : 4711)     // function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <clusapi.h>

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT    IDS;
typedef UINT    IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\vsstaskex.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      VSSTaskEx.cpp
//
//  Description:
//      Implementation of the CVSSTaskApp class and DLL initialization
//      routines.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "VSSTaskEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning( disable : 4701 ) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning( default : 4701 )

BEGIN_OBJECT_MAP( ObjectMap )
    OBJECT_ENTRY( CLSID_CoVSSTaskEx, CExtObject )
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow( void );
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID * ppv );
STDAPI DllRegisterServer( void );
STDAPI DllUnregisterServer( void );
STDAPI DllRegisterCluAdminExtension( IN HCLUSTER hcluster );
STDAPI DllUnregisterCluAdminExtension( IN HCLUSTER hcluster );

/////////////////////////////////////////////////////////////////////////////
// class CVSSTaskApp
/////////////////////////////////////////////////////////////////////////////

class CVSSTaskApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();

}; //*** class CVSSTaskApp

/////////////////////////////////////////////////////////////////////////////
// The one and only CVSSTaskApp object

CVSSTaskApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVSSTaskApp::InitInstance
//
//  Description:
//      Initialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Any return codes from CWinApp::InitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CVSSTaskApp::InitInstance( void )
{
    _Module.Init( ObjectMap, m_hInstance );

    // Construct the help path.
    {
        TCHAR   szPath[_MAX_PATH];
        TCHAR   szDrive[_MAX_PATH];
        TCHAR   szDir[_MAX_DIR];
        size_t  cchPath;
        BOOL    fEnable;
        wchar_t *copyReturn;

        VERIFY(::GetSystemWindowsDirectory(szPath, _MAX_PATH));
        cchPath = _tcslen(szPath);
        if (szPath[cchPath - 1] != _T('\\'))
        {
            szPath[cchPath++] = _T('\\');
            szPath[cchPath] = _T('\0');
        } // if: no backslash on the end of the path
        copyReturn = wcsncpy( &szPath[ cchPath ], _T("Help\\"), RTL_NUMBER_OF( szPath ) - cchPath );
        ASSERT( copyReturn == &szPath[ cchPath ] );
        _tsplitpath(szPath, szDrive, szDir, NULL, NULL);
        _tmakepath(szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp"));
        free((void *) m_pszHelpFilePath);
        fEnable = AfxEnableMemoryTracking(FALSE);
        m_pszHelpFilePath = _tcsdup(szPath);
        AfxEnableMemoryTracking(fEnable);
    }  // Construct the help path

    return CWinApp::InitInstance();

}  //*** CVSSTaskApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVSSTaskApp::ExitInstance
//
//  Description:
//      Deinitialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Any return codes from CWinApp::ExitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
int CVSSTaskApp::ExitInstance( void )
{
    _Module.Term();
    return CWinApp::ExitInstance();

}  //*** CVSSTaskApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  FormatError
//
//  Description:
//      Format an error.
//
//  Arguments:
//      rstrError   [OUT] String in which to return the error message.
//      dwError     [IN] Error code to format.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError( CString & rstrError, DWORD dwError )
{
    DWORD   _cch;
    TCHAR   _szError[512];

    // Format the NT status code from CLUSAPI.  This is necessary
    // for the cases where cluster messages haven't been added to
    // the system message file yet.
    _cch = FormatMessage(
                    FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                    ::GetModuleHandle(_T("CLUSAPI.DLL")),
                    dwError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                    _szError,
                    sizeof(_szError) / sizeof(TCHAR),
                    0
                    );
    if (_cch == 0)
    {
        _cch = FormatMessage(
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        dwError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                        _szError,
                        sizeof(_szError) / sizeof(TCHAR),
                        0
                        );
        if (_cch == 0)
        {
            // Format the NT status code from NTDLL since this hasn't been
            // integrated into the system yet.
            _cch = FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                            ::GetModuleHandle(_T("NTDLL.DLL")),
                            dwError,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                            _szError,
                            sizeof(_szError) / sizeof(TCHAR),
                            0
                            );
        }  // if:  error formatting status code from system
    }  // if:  error formatting status code from ClusApi

    if (_cch > 0)
    {
        rstrError = _szError;
    }  // if:  no error
    else
    {
        TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), GetLastError(), dwError);
        rstrError.Format(_T("Error 0x%08.8x"), dwError);
    }  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );
    return ( AfxDllCanUnloadNow() && _Module.GetLockCount() == 0 ) ? S_OK : S_FALSE;

}  //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID * ppv )
{
    return _Module.GetClassObject( rclsid, riid, ppv );

}  //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer( void )
{
    HRESULT hRes = S_OK;
    // registers object, typelib and all interfaces in typelib
    hRes = _Module.RegisterServer( FALSE /*bRegTypeLib*/ );
    return hRes;

}  //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer( void )
{
    HRESULT hRes = S_OK;
    _Module.UnregisterServer();
    return hRes;

}  //*** DllUnregisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterCluAdminExtension
//
//  Description:
//      Register the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension( IN HCLUSTER hCluster )
{
    HRESULT     hr;
    HRESULT     hrReturn = S_OK;
    LPCWSTR     pwszResTypes = g_wszResourceTypeNames;

    while ( *pwszResTypes != L'\0' )
    {
        wprintf( L"  %s\n", pwszResTypes );
        hr = RegisterCluAdminResourceTypeExtension(
                    hCluster,
                    pwszResTypes,
                    &CLSID_CoVSSTaskEx
                    );
        if ( hr != S_OK )
        {
            hrReturn = hr;
        } // if:  error registering the extension
        pwszResTypes += lstrlenW( pwszResTypes ) + 1;
    }  // while:  more resource types

    return hrReturn;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllUnregisterCluAdminExtension
//
//  Description:
//      Unregister the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension( IN HCLUSTER hCluster )
{
    HRESULT     hr;
    HRESULT     hrReturn = S_OK;
    LPCWSTR     pwszResTypes = g_wszResourceTypeNames;

    while ( *pwszResTypes != L'\0' )
    {
        wprintf( L"  %s\n", pwszResTypes );
        hr = UnregisterCluAdminResourceTypeExtension(
                    hCluster,
                    pwszResTypes,
                    &CLSID_CoVSSTaskEx
                    );
        if ( hr != S_OK )
        {
            hrReturn = hr;
        } // if:  error unregistering the extension
        pwszResTypes += lstrlenW( pwszResTypes ) + 1;
    }  // while:  more resource types

    return hrReturn;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\vsstask\vsstaskex\vsstaskex.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2002 Microsoft Corporation
//
//  Module Name:
//      VSSTaskEx.h
//
//  Implementation File:
//      VSSTaskEx.cpp
//
//  Description:
//      Global definitions across the DLL.
//
//  Author:
//      <name> (<e-mail name>) Mmmm DD, 2002
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSSTASKEX_H__
#define __VSSTASKEX_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include <vsscmn.h>         // resource type and property defines

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_VSSTASK_CURRENTDIRECTORY   CLUSREG_NAME_VSSTASK_CURRENTDIRECTORY
#define REGPARAM_VSSTASK_APPLICATIONNAME    CLUSREG_NAME_VSSTASK_APPNAME
#define REGPARAM_VSSTASK_APPLICATIONPARAMS  CLUSREG_NAME_VSSTASK_APPPARAMS
#define REGPARAM_VSSTASK_TRIGGERARRAY       CLUSREG_NAME_VSSTASK_TRIGGERARRAY

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError( CString & rstrError, DWORD dwError );

// Defined in Extensn.cpp
extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;

/////////////////////////////////////////////////////////////////////////////

#endif // __VSSTASKEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\dlock.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corporation

Module Name:

    dlock.c

Abstract:

    Functions for detecting deadlocked resource dll entry point calls.

Author:

    Chittur Subbaraman

Revision History:

    04-11-2002          Created

--*/
#define UNICODE 1

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "resmonp.h"
#include <strsafe.h>

#define RESMON_MODULE           RESMON_MODULE_DLOCK
#define FILETIMES_PER_SEC       ((__int64) 10000000)   // (1 second)/(100 ns)

//
//  Globals
//
PRM_DUE_TIME_FREE_LIST_HEAD             g_pRmDueTimeFreeListHead = NULL;
PRM_DUE_TIME_MONITORED_LIST_HEAD        g_pRmDueTimeMonitoredListHead = NULL;
CRITICAL_SECTION                        g_RmDeadlockListLock;
BOOL                                    g_RmDeadlockMonitorInitialized = FALSE;
    
PRM_DUE_TIME_ENTRY
RmpInsertDeadlockMonitorList(
    IN LPCWSTR  lpszResourceDllName,
    IN LPCWSTR  lpszResourceTypeName,
    IN LPCWSTR  lpszResourceName,   OPTIONAL
    IN LPCWSTR lpszEntryPointName
    )

/*++

Routine Description:

    Inserts an entry into the deadlock monitoring list.

Arguments:

    lpszResourceDllName - Resource dll name.

    lpszResourceTypeName - Resource type name.

    lpszResourceName - Resource name, OPTIONAL

    lpszEntryPointName - Entry point name.

Return Value:

    A valid due time entry pointer on success, NULL on failure. Use GetLastError() to
    get error code.

--*/

{
    PRM_DUE_TIME_ENTRY          pDueTimeEntry = NULL;
    DWORD                       dwStatus = ERROR_SUCCESS;
    PLIST_ENTRY                 pListEntry;

    if ( !g_RmDeadlockMonitorInitialized ) 
    {
        SetLastError ( ERROR_INVALID_STATE );
        return ( NULL );
    }

    //
    //  Get an entry from the free list.
    //
    EnterCriticalSection ( &g_RmDeadlockListLock );

    if ( IsListEmpty ( &g_pRmDueTimeFreeListHead->leDueTimeEntry ) )
    {
        dwStatus = ERROR_NO_MORE_ITEMS;
        ClRtlLogPrint(LOG_CRITICAL,
                      "[RM] RmpInsertDeadlockMonitorList: Unable to insert DLL '%1!ws!', Type '%2!ws!', Resource '%3!ws!',"
                      " Entry point '%4!ws!' info into deadlock monitoring list\n",
                      lpszResourceDllName,
                      lpszResourceTypeName,
                      (lpszResourceName == NULL) ? L"Unknown" : lpszResourceName,
                      lpszEntryPointName);
        LeaveCriticalSection ( &g_RmDeadlockListLock );
        goto FnExit;
    }

    pListEntry = RemoveHeadList( &g_pRmDueTimeFreeListHead->leDueTimeEntry );

    pDueTimeEntry = CONTAINING_RECORD( pListEntry,
                                       RM_DUE_TIME_ENTRY,
                                       leDueTimeEntry );
    
    LeaveCriticalSection ( &g_RmDeadlockListLock );

    //
    //  Populate the entry. No locks needed for that.
    //
    StringCchCopy ( pDueTimeEntry->szResourceDllName, 
                    RTL_NUMBER_OF ( pDueTimeEntry->szResourceDllName ),
                    lpszResourceDllName );

    StringCchCopy ( pDueTimeEntry->szResourceTypeName, 
                    RTL_NUMBER_OF ( pDueTimeEntry->szResourceTypeName ),
                    lpszResourceTypeName );

    StringCchCopy ( pDueTimeEntry->szEntryPointName, 
                    RTL_NUMBER_OF ( pDueTimeEntry->szEntryPointName ),
                    lpszEntryPointName );

    if ( ARGUMENT_PRESENT ( lpszResourceName ) )
    {
        StringCchCopy ( pDueTimeEntry->szResourceName, 
                        RTL_NUMBER_OF ( pDueTimeEntry->szResourceName ),
                        lpszResourceName );
    } else
    {
        StringCchCopy ( pDueTimeEntry->szResourceName, 
                        RTL_NUMBER_OF ( pDueTimeEntry->szResourceName ),
                        L"None" );
    }

    pDueTimeEntry->dwSignature = RM_DUE_TIME_MONITORED_ENTRY_SIGNATURE;  
    GetSystemTimeAsFileTime( ( FILETIME * ) &pDueTimeEntry->uliDueTime );
    pDueTimeEntry->dwThreadId = GetCurrentThreadId ();

    //
    //  Insert it into the monitoring list
    //
    EnterCriticalSection ( &g_RmDeadlockListLock );
    pDueTimeEntry->uliDueTime.QuadPart += g_pRmDueTimeMonitoredListHead->ullDeadLockTimeoutSecs * FILETIMES_PER_SEC;
    InsertTailList ( &g_pRmDueTimeMonitoredListHead->leDueTimeEntry, &pDueTimeEntry->leDueTimeEntry );
    LeaveCriticalSection ( &g_RmDeadlockListLock );
       
FnExit:
    if ( dwStatus != ERROR_SUCCESS )
    {
        SetLastError ( dwStatus );
    }
    return ( pDueTimeEntry );
} // RmpInsertDeadlockMonitorList

VOID
RmpRemoveDeadlockMonitorList(
    IN PRM_DUE_TIME_ENTRY   pDueTimeEntry
    )

/*++

Routine Description:

    Removes an entry from the deadlock monitoring list.

Arguments:

    pDueTimeEntry - Due time entry to be removed.

Return Value:

    None.

--*/

{
    if ( !g_RmDeadlockMonitorInitialized ) 
    {
        goto FnExit;
    }

    if ( pDueTimeEntry == NULL )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[RM] RmpRemoveDeadlockMonitorList: Unable to remove NULL entry from deadlock monitoring list\n");
        goto FnExit;       
    }

    //
    //  Remove from the monitoring list and add it into the free list.
    //
    EnterCriticalSection ( &g_RmDeadlockListLock );
    RemoveEntryList ( &pDueTimeEntry->leDueTimeEntry );
    ZeroMemory ( pDueTimeEntry, sizeof ( RM_DUE_TIME_ENTRY ) );
    pDueTimeEntry->dwSignature = RM_DUE_TIME_FREE_ENTRY_SIGNATURE;
    InsertTailList ( &g_pRmDueTimeFreeListHead->leDueTimeEntry, &pDueTimeEntry->leDueTimeEntry );
    LeaveCriticalSection ( &g_RmDeadlockListLock );
    
FnExit:
    return;
} // RmpRemoveDeadlockMonitorList

DWORD
RmpDeadlockMonitorInitialize(
    IN DWORD dwDeadlockDetectionTimeout
    )

/*++

Routine Description:

    Initialize the deadlock monitoring system.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

--*/

{
    DWORD                       i, dwStatus = ERROR_SUCCESS;
    HANDLE                      hDeadlockTimerThread = NULL;
    PRM_DUE_TIME_ENTRY          pDueTimeEntryStart = NULL;

    //
    //  If the deadlock monitoring susbsystem is already initialized, you are done.
    //
    if ( g_RmDeadlockMonitorInitialized )
    {
        return ( ERROR_SUCCESS );
    }

    //
    //  Adjust timeouts so that it is at least equal to the minimum allowed.
    //
    dwDeadlockDetectionTimeout = ( dwDeadlockDetectionTimeout < CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_TIMEOUT_SECS ) ?
                                  CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_TIMEOUT_SECS : dwDeadlockDetectionTimeout;

    //
    //  Initialize the critsec. Catch low memory conditions and return error to caller.
    //
    try
    {
        InitializeCriticalSection( &g_RmDeadlockListLock );
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwStatus = GetExceptionCode();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[RM] RmpDeadlockMonitorInitialize: Initialize critsec returned %1!u!\n",
                      dwStatus);
        return ( dwStatus );
    }

    //
    //  Build the list heads.  All are one time only allocs that are never freed.
    //
    g_pRmDueTimeMonitoredListHead = LocalAlloc ( LPTR, sizeof ( RM_DUE_TIME_MONITORED_LIST_HEAD ) );

    if ( g_pRmDueTimeMonitoredListHead == NULL )
    {
        dwStatus = GetLastError ();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[RM] RmpDeadlockMonitorInitialize: Unable to alloc memory for monitor list head, status %1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    InitializeListHead ( &g_pRmDueTimeMonitoredListHead->leDueTimeEntry );
    g_pRmDueTimeMonitoredListHead->ullDeadLockTimeoutSecs = dwDeadlockDetectionTimeout;
    g_pRmDueTimeMonitoredListHead->dwSignature = RM_DUE_TIME_MONITORED_LIST_HEAD_SIGNATURE;

    g_pRmDueTimeFreeListHead = LocalAlloc ( LPTR, sizeof ( RM_DUE_TIME_FREE_LIST_HEAD ) );

    if ( g_pRmDueTimeFreeListHead == NULL )
    {
        dwStatus = GetLastError ();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[RM] RmpDeadlockMonitorInitialize: Unable to alloc memory for free list head, status %1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    InitializeListHead ( &g_pRmDueTimeFreeListHead->leDueTimeEntry );
    g_pRmDueTimeFreeListHead->dwSignature = RM_DUE_TIME_FREE_LIST_HEAD_SIGNATURE;

    //
    //  Build the free list
    //
    pDueTimeEntryStart = LocalAlloc ( LPTR,
                                      RESMON_MAX_DEADLOCK_MONITOR_ENTRIES * 
                                            sizeof ( RM_DUE_TIME_ENTRY ) );
    

    if ( pDueTimeEntryStart == NULL )
    {
        dwStatus = GetLastError ();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[RM] RmpDeadlockMonitorInitialize: Unable to alloc memory for monitor list entries, status %1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Populate the free list
    //
    for ( i = 0; i < RESMON_MAX_DEADLOCK_MONITOR_ENTRIES; i++ )
    {
        pDueTimeEntryStart[i].dwSignature = RM_DUE_TIME_FREE_ENTRY_SIGNATURE;
        InsertTailList ( &g_pRmDueTimeFreeListHead->leDueTimeEntry, &pDueTimeEntryStart[i].leDueTimeEntry );
    }

    //
    //  Create the monitor thread
    //
    hDeadlockTimerThread = CreateThread( NULL,                      // Security attributes
                                         0,                         // Use default process stack size
                                         RmpDeadlockTimerThread,    // Function address
                                         NULL,                      // Context
                                         0,                         // Flags
                                         NULL );                    // Thread ID -- not interested

    if ( hDeadlockTimerThread == NULL )
    {
        dwStatus = GetLastError ();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[RM] RmpDeadlockMonitorInitialize: Unable to create monitor thread, status %1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Try to set the thread priority to highest. Continue even in case of an error.
    //
    if ( !SetThreadPriority( hDeadlockTimerThread, THREAD_PRIORITY_HIGHEST ) )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpDeadlockMonitorInitialize: Unable to set monitor thread priority, status %1!u!\n",
                      GetLastError());
    }

    CloseHandle( hDeadlockTimerThread );

    g_RmDeadlockMonitorInitialized = TRUE;

    ClRtlLogPrint(LOG_NOISE, "[RM] RmpDeadlockMonitorInitialize: Successfully initialized with a timeout of %1!u! secs\n",
                 dwDeadlockDetectionTimeout);

FnExit:
    if ( dwStatus != ERROR_SUCCESS )
    {
        LocalFree ( g_pRmDueTimeMonitoredListHead );
        g_pRmDueTimeMonitoredListHead = NULL;
        LocalFree ( g_pRmDueTimeFreeListHead );
        g_pRmDueTimeFreeListHead = NULL;
        DeleteCriticalSection ( &g_RmDeadlockListLock ); 
    }

    return ( dwStatus );
} // RmDeadlockMonitorInitialize

DWORD
RmpDeadlockTimerThread(
    IN LPVOID pContext
    )
/*++

Routine Description:

    Timer thread that monitors for deadlocks in resource dll entry points.

Arguments:

    pContext - Context, Unused.

Returns:

    ERROR_SUCCESS on success. Win32 error code of failure.

--*/

{
    PRM_DUE_TIME_ENTRY      pDueTimeEntry;
    PLIST_ENTRY             pListEntry;
    ULARGE_INTEGER          uliCurrentTime;
    
    while ( TRUE )
    {
        Sleep ( RESMON_DEADLOCK_TIMER_INTERVAL );

        GetSystemTimeAsFileTime ( ( FILETIME * ) &uliCurrentTime );

        EnterCriticalSection ( &g_RmDeadlockListLock );

        pListEntry = g_pRmDueTimeMonitoredListHead->leDueTimeEntry.Flink;

        //
        //  Walk the deadlock monitoring list looking for a deadlock.
        //
        while ( pListEntry != &g_pRmDueTimeMonitoredListHead->leDueTimeEntry ) 
        {
            pDueTimeEntry = CONTAINING_RECORD( pListEntry,
                                               RM_DUE_TIME_ENTRY,
                                               leDueTimeEntry );
            pListEntry = pListEntry->Flink;
            if ( pDueTimeEntry->uliDueTime.QuadPart <= uliCurrentTime.QuadPart )
            {
                RmpDeclareDeadlock ( pDueTimeEntry, uliCurrentTime );
            }
        }  // while
 
        LeaveCriticalSection ( & g_RmDeadlockListLock );  
    } // while

    return ( ERROR_SUCCESS );
}// RmpDeadlockTimerThread

VOID
RmpDeclareDeadlock(
    IN PRM_DUE_TIME_ENTRY pDueTimeEntry,
    IN ULARGE_INTEGER uliCurrentTime
    )
/*++

Routine Description:

    Declare a deadlock and exit this process.

Arguments:

    pDueTimeEntry - The entry that contains information of possible deadlock causing resource dll.

    uliCurrentTime - Current time.

Returns:

    None.

--*/
{
    ClRtlLogPrint(LOG_CRITICAL, "[RM] RmpDeclareDeadlock: Declaring deadlock and exiting process\n");
   
    ClRtlLogPrint(LOG_CRITICAL,
                  "[RM] RmpDeclareDeadlock: Deadlock candidate info - DLL '%1!ws!', Type '%2!ws!', Resource '%3!ws!', Entry point '%4!ws!', Thread 0x%5!08lx!\n",
                  pDueTimeEntry->szResourceDllName,
                  pDueTimeEntry->szResourceTypeName,
                  pDueTimeEntry->szResourceName,
                  pDueTimeEntry->szEntryPointName,
                  pDueTimeEntry->dwThreadId);

    ClRtlLogPrint(LOG_CRITICAL,
                  "[RM] RmpDeclareDeadlock: Current time 0x%1!08lx!:%2!08lx!, due time 0x%3!08lx!:%4!08lx!\n",
                  uliCurrentTime.HighPart,
                  uliCurrentTime.LowPart,
                  pDueTimeEntry->uliDueTime.HighPart,
                  pDueTimeEntry->uliDueTime.LowPart);

    ClusterLogEvent4(LOG_CRITICAL,
                     LOG_CURRENT_MODULE,
                     __FILE__,
                     __LINE__,
                     RMON_DEADLOCK_DETECTED,
                     0,
                     NULL,
                     pDueTimeEntry->szResourceDllName,
                     pDueTimeEntry->szResourceTypeName,
                     pDueTimeEntry->szResourceName,
                     pDueTimeEntry->szEntryPointName);

    RmpSetMonitorState ( RmonDeadlocked, NULL );
    
    ExitProcess ( 0 );   
}// RmpDeclareDeadlock

DWORD
RmpUpdateDeadlockDetectionParams(
    IN DWORD dwDeadlockDetectionTimeout
    )

/*++

Routine Description:

    Update the parameters of the deadlock monitoring subsystem.

Arguments:

    dwDeadlockDetectionTimeout - The deadlock detection timeout.

Return Value:

    ERROR_SUCCESS on success, a Win32 error code otherwise.

--*/

{
    if ( !g_RmDeadlockMonitorInitialized ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL, "[RM] RmpUpdateDeadlockDetectionParams: Deadlock monitor not initialized yet\n");
        return ( ERROR_INVALID_STATE );
    }

    //
    //  Adjust timeouts so that it is at least equal to the minimum allowed.
    //
    dwDeadlockDetectionTimeout = ( dwDeadlockDetectionTimeout < CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_TIMEOUT_SECS ) ?
                                  CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_TIMEOUT_SECS : dwDeadlockDetectionTimeout;

    EnterCriticalSection ( &g_RmDeadlockListLock );
    g_pRmDueTimeMonitoredListHead->ullDeadLockTimeoutSecs = dwDeadlockDetectionTimeout;
    LeaveCriticalSection ( &g_RmDeadlockListLock );

    ClRtlLogPrint(LOG_NOISE, "[RM] RmpUpdateDeadlockDetectionParams: Updated monitor with a deadlock timeout of %1!u! secs\n",
                  dwDeadlockDetectionTimeout);

    return ( ERROR_SUCCESS );
} // RmpUpdateDeadlockDetectionParams
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\notify.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Interface for reporting resource notifications to cluster
    manager.

Author:

    John Vert (jvert) 12-Jan-1996

Revision History:

--*/
#include "resmonp.h"

#define RESMON_MODULE RESMON_MODULE_NOTIFY

//
// Define queue to post notifications to
//
CL_QUEUE RmpNotifyQueue;

//
// Define notification block structure
//
typedef struct _NOTIFY {
    LIST_ENTRY ListEntry;
    RM_NOTIFY_KEY Key;
    NOTIFY_REASON Reason;
    CLUSTER_RESOURCE_STATE State;
} NOTIFY, *PNOTIFY;


BOOL
s_RmNotifyChanges(
    IN handle_t IDL_handle,
    OUT RM_NOTIFY_KEY *lpNotifyKey,
    OUT DWORD *lpNotifyEvent,
    OUT DWORD *lpCurrentState     
    )

/*++

Routine Description:

    This is a blocking RPC call which is used to implement notification.
    The client calls this API and blocks until a notification event
    occurs. Any notification events wake up the blocked thread and
    it returns to the client with the notification information.

Arguments:

    IDL_handle - Supplies binding handle, currently unused

    lpNotifyKey - Returns the notification key of the resource

    lpCurrentState - Returns the current state of the resource

Return Value:

    TRUE - A notification event was successfully delivered

    FALSE - No notification events were delivered, the process is
            shutting down.

--*/

{
    PLIST_ENTRY ListEntry;
    PNOTIFY Notify;
    DWORD Status;
    BOOL Continue;

    //
    // Wait for something to be posted to the queue, pull it off, and
    // return it.
    //
    ListEntry = ClRtlRemoveHeadQueue(&RmpNotifyQueue);
    if ( ListEntry == NULL ) {
        // If we got nothing - assume we are shutting down!
        return(FALSE);
    }

    Notify = CONTAINING_RECORD(ListEntry,
                               NOTIFY,
                               ListEntry);
    if (Notify->Reason == NotifyShutdown) {
        //
        // System is shutting down.
        //
        RmpFree(Notify);
        ClRtlLogPrint( LOG_NOISE, "[RM] NotifyChanges shutting down.\n");
        return(FALSE);
    }

    //
    // Return to the client with the notification data
    //
    *lpNotifyKey = Notify->Key;
    *lpNotifyEvent = Notify->Reason;
    *lpCurrentState = Notify->State;
    RmpFree(Notify);

    return(TRUE);

} // RmNotifyChanges


VOID
RmpPostNotify(
    IN PRESOURCE Resource,
    IN NOTIFY_REASON Reason
    )

/*++

Routine Description:

    Posts a notification block to the notify queue.

Arguments:

    Resource - Supplies the resource to post the notification for

    Reason - Supplies the reason for the notification.

Return Value:

    None.

--*/

{
    PNOTIFY Notify;

    Notify = RmpAlloc(sizeof(NOTIFY));

    if (Notify != NULL) {
        Notify->Reason = Reason;
        switch ( Reason ) {

        case NotifyResourceStateChange:
            Notify->Key = Resource->NotifyKey;
            Notify->State = Resource->State;
            break;

        case NotifyResourceResuscitate:
            Notify->Key = Resource->NotifyKey;
            Notify->State = 0;
            break;

        case NotifyShutdown:
            Notify->Key = 0;
            Notify->State = 0;
            break;

        default:
            Notify->Key = 0;
            Notify->State = 0;

        }

        ClRtlInsertTailQueue(&RmpNotifyQueue, &Notify->ListEntry);

    } else {
        //
        // The notification will get dropped on the floor, but there's
        // not too much we can do about it anyway.
        //
        ClRtlLogPrint( LOG_ERROR, "[RM] RmpPostNotify dropped notification for %1!ws!, reason %2!u!\n",
            Resource->ResourceName,
            Reason);
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
    }
} // RmpPostNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\poller.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    poller.c

Abstract:

    This module polls the resource list

Author:

    John Vert (jvert) 5-Dec-1995

Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "resmonp.h"
#include "stdio.h"

#define RESMON_MODULE RESMON_MODULE_POLLER

//
// Global data defined by this module
//

BOOL                RmpShutdown = FALSE;

//
// The following critical section protects both insertion of new event lists
// onto the event listhead, as well as adding new events to a given event list.
// This could be broken into one critical section for each purpose. The latter
// critical section would be part of each event list. The former would use the
// following lock.
//

CRITICAL_SECTION    RmpEventListLock; // Lock for processing event lists


//
// Function prototypes local to this module
//
DWORD
RmpComputeNextTimeout(
    IN PPOLL_EVENT_LIST EventList
    );

DWORD
RmpPollList(
    IN PPOLL_EVENT_LIST EventList
    );

VOID
RmpPollBucket(
    IN PMONITOR_BUCKET Bucket
    );

DWORD
RmpPollerThread(
    IN LPVOID Context
    )

/*++

Routine Description:

    Thread startup routine for the polling thread. The way this works, is that
    other parts of the resource monitor add events to the list of events that
    is being processed by this thread.  When they are done, they signal this
    thread, which makes a copy of the new lists, and then waits for an event to
    happen or a timeout occurs.

Arguments:

    Context - A pointer to the POLL_EVENT_LIST for this thread.

Return Value:

    Win32 error code.

Note:

    This code assumes that the EventList pointed to by Context does NOT go
    away while this thread is running. Further it assumes that the ResourceList
    pointed to by the given EventList does not go away or change.

--*/

{
    DWORD Timeout;
    DWORD Status;
    PPOLL_EVENT_LIST    NewEventList = (PPOLL_EVENT_LIST)Context;
    POLL_EVENT_LIST     waitEventList; // Event list outstanding
    DWORD WaitFailed = 0;

    //
    // Zero the local copy event list structure.
    //

    ZeroMemory( &waitEventList, sizeof(POLL_EVENT_LIST) );

    //
    // Don't allow system failures to generate popups.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    //
    // Create notification event to indicate that this list
    // has changed.
    //

    NewEventList->ListNotify = CreateEvent(NULL,
                                           FALSE,
                                           FALSE,
                                           NULL);
    if (NewEventList->ListNotify == NULL) {
        CL_UNEXPECTED_ERROR(GetLastError());
    }

    RmpAddPollEvent(NewEventList, NewEventList->ListNotify, NULL);

    //
    // Create a shutdown event
    //
    NewEventList->hEventShutdown = CreateEvent( NULL,   // Security attributes
                                                FALSE,  // Auto reset event
                                                FALSE,  // Nonsignaled initial state
                                                NULL ); // Name

    if ( NewEventList->hEventShutdown == NULL ) 
    {
        CL_UNEXPECTED_ERROR(GetLastError());
    }

    //
    //  Add the shutdown event to the poll list
    //
    RmpAddPollEvent( NewEventList, NewEventList->hEventShutdown, NULL );

    //
    // Make a copy of the NewEventList first time through.
    //

    AcquireEventListLock( NewEventList );

    CopyMemory( &waitEventList,
                NewEventList,
                sizeof(POLL_EVENT_LIST)
               );

    ReleaseEventListLock( NewEventList );

try_again:
    //
    // Compute initial timeout.
    //
    Timeout = RmpComputeNextTimeout( NewEventList );

    //
    // There are four functions performed by this thread...
    //
    //  1. Handle timers for polling.
    //  2. Handle list notification changes and updates to the number of
    //     events handled by the WaitForMultipleObjects.
    //  3. Handle events set by resource DLL's to deliver asynchronous
    //     event (failure) notifications.
    //  4. Handle a shutdown request.
    //
    // N.B. Handles cannot go away while we are waiting... it is therefore
    //      best to set the event for the ListNotify event so we can redo the
    //      wait event list.
    //

    while (TRUE) {
        //
        // Wait for any of the events to be signaled.
        //
        CL_ASSERT(waitEventList.Handle[0] == NewEventList->ListNotify);
        Status = WaitForMultipleObjects(waitEventList.EventCount,
                                        &waitEventList.Handle[0],
                                        FALSE,
                                        Timeout);
        if (Status == WAIT_TIMEOUT) {
            //
            // Time period has elapsed, go poll everybody
            //
            Timeout = RmpPollList( NewEventList );
            WaitFailed = 0;
        } else {
            //
            // If the first event is signaled, which is the ListNotify event,
            // then the list changed or a new poll event was added.
            //
            if ( Status == WAIT_OBJECT_0 ) {
get_new_list:
                WaitFailed = 0;
                //
                // The list has changed or we have a new event to wait for,
                // recompute a new timeout and make a copy of the new event list
                //
                AcquireEventListLock( NewEventList );

                CopyMemory( &waitEventList,
                            NewEventList,
                            sizeof(POLL_EVENT_LIST)
                           );


                ReleaseEventListLock( NewEventList );

                Timeout = RmpComputeNextTimeout( NewEventList );

            } else if ( Status == WAIT_OBJECT_0 + 1 ) {
                //
                //  This thread has been asked to shutdown, so exit.
                //
                ClRtlLogPrint(LOG_NOISE, "[RM] RmpPollerThread: Asked to exit...\n");
                break;
            }
            else if ( Status == WAIT_FAILED ) {
                //
                // We've probably signaled an event, and closed the handle
                // already. Wait on the Notify Event for just a little bit.
                // If that event fires, then copy a new event list. But only
                // try this 100 times.
                //
                if ( ++WaitFailed < 100 ) {
                    Status = WaitForSingleObject( waitEventList.ListNotify,
                                                  100 );
                    if ( RmpShutdown ) {
                        break;
                    }
                    if ( Status == WAIT_TIMEOUT ) {
                        continue;
                    } else {
                        goto get_new_list;
                    }
                } else {
                    Status = GetLastError();
                    break;
                }
            } else {
                //
                // One of the resource events was signaled!
                //
                WaitFailed = 0;
                CL_ASSERT( WAIT_OBJECT_0 == 0 );
                RmpResourceEventSignaled( &waitEventList,
                                          Status );
                Timeout = RmpComputeNextTimeout( NewEventList );
            }
        }
    }

    ClRtlLogPrint( LOG_NOISE,
                   "[RM] PollerThread stopping. Shutdown = %1!u!, Status = %2!u!, "
                   "WaitFailed = %3!u!, NotifyEvent address = %4!u!.\n",
                   RmpShutdown,
                   Status,
                   WaitFailed,
                   waitEventList.ListNotify);

#if 1 // RodGa - this is for debug only!
    WaitFailed = 0;
    if ( Status == ERROR_INVALID_HANDLE ) {
        DWORD i;
        for ( i = 0; i < waitEventList.EventCount; i++ ) {
            ClRtlLogPrint( LOG_NOISE, "[RM] Event address %1!u!, index %2!u!.\n",
                       waitEventList.Handle[i], i);
            Status = WaitForSingleObject( waitEventList.Handle[i], 10 );
            if ( (Status == WAIT_FAILED) &&
                 (GetLastError() == ERROR_INVALID_HANDLE) )
            {
                ClRtlLogPrint( LOG_UNUSUAL, "[RM] Event address %1!u!, index %2!u! is bad. Removing...\n",
                           waitEventList.Handle[i], i);
                RmpRemovePollEvent( NewEventList, waitEventList.Handle[i] );

                //
                // Copy new list... and try again.
                //
                AcquireEventListLock( NewEventList );

                CopyMemory( &waitEventList,
                            NewEventList,
                            sizeof(POLL_EVENT_LIST)
                           );


                ReleaseEventListLock( NewEventList );

                goto try_again;
            }
        }
    }
#endif

    CL_ASSERT( NewEventList->ListNotify );
    CL_ASSERT( waitEventList.ListNotify == NewEventList->ListNotify );
    CloseHandle( NewEventList->ListNotify );
    NewEventList->ListNotify = NULL; 

    CL_ASSERT( NewEventList->hEventShutdown );
    CloseHandle( NewEventList->hEventShutdown );
    NewEventList->hEventShutdown = NULL; 

    return(0);
} // RmpPollerThread



DWORD
RmpComputeNextTimeout(
    IN PPOLL_EVENT_LIST EventList
    )

/*++

Routine Description:

    Searches the resource list to determine the number of milliseconds
    until the next poll event.

Arguments:

    None.

Return Value:

    0 - A poll interval has already elapsed.
    INFINITE - No resources to poll
    number of milliseconds until the next poll event.

--*/

{
    DWORD Timeout;
    PMONITOR_BUCKET Bucket;
    DWORDLONG NextDueTime;
    DWORDLONG CurrentTime;
    DWORDLONG WaitTime;

    AcquireEventListLock( EventList );
    if (!IsListEmpty(&EventList->BucketListHead)) {
        Bucket = CONTAINING_RECORD(EventList->BucketListHead.Flink,
                                   MONITOR_BUCKET,
                                   BucketList);
        NextDueTime = Bucket->DueTime;
        Bucket = CONTAINING_RECORD(Bucket->BucketList.Flink,
                                   MONITOR_BUCKET,
                                   BucketList);
        while (&Bucket->BucketList != &EventList->BucketListHead) {
            if (Bucket->DueTime < NextDueTime) {
                NextDueTime = Bucket->DueTime;
            }

            Bucket = CONTAINING_RECORD(Bucket->BucketList.Flink,
                                       MONITOR_BUCKET,
                                       BucketList);
        }

        //
        // Compute the number of milliseconds from the current time
        // until the next due time. This is our timeout value.
        //
        GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);
        if (NextDueTime > CurrentTime) {
            WaitTime = NextDueTime - CurrentTime;
            CL_ASSERT(WaitTime < (DWORDLONG)0xffffffff * 10000); // check for excessive value
            Timeout = (ULONG)(WaitTime / 10000);
        } else {
            //
            // The next poll time has already passed, timeout immediately
            // and go poll the list.
            //
            Timeout = 0;
        }

    } else {
        //
        // Nothing to poll, so wait on the ListNotify event forever.
        //
        Timeout = INFINITE;
    }
    ReleaseEventListLock( EventList );

    return(Timeout);

} // RmpComputeNextTimeout



DWORD
RmpPollList(
    IN PPOLL_EVENT_LIST EventList
    )

/*++

Routine Description:

    Polls all resources in the resource list whose timeouts have
    expired. Recomputes the next timeout interval for each polled
    resource.

Arguments:

    None.

Return Value:

    The number of milliseconds until the next poll event.

--*/

{
    ULONG i;
    DWORD Timeout = INFINITE;
    DWORDLONG NextDueTime;
    DWORDLONG CurrentTime;
    DWORDLONG WaitTime;
    PMONITOR_BUCKET Bucket;

    AcquireEventListLock( EventList );

    if (!IsListEmpty(&EventList->BucketListHead)) {
        Bucket = CONTAINING_RECORD(EventList->BucketListHead.Flink,
                                   MONITOR_BUCKET,
                                   BucketList);
        NextDueTime = Bucket->DueTime;
        while (&Bucket->BucketList != &EventList->BucketListHead) {
            GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);
            if (CurrentTime >= Bucket->DueTime) {
                //
                // This poll interval has expired. Compute the
                // next poll interval and poll this bucket now.
                //
                CL_ASSERT( Bucket->Period != 0 );
                Bucket->DueTime = CurrentTime + Bucket->Period;

                RmpPollBucket(Bucket);
            }
            //
            // If this bucket is the closest upcoming event,
            // update NextDueTime.
            //
            if (Bucket->DueTime < NextDueTime) {
                NextDueTime = Bucket->DueTime;
            }
            Bucket = CONTAINING_RECORD(Bucket->BucketList.Flink,
                                       MONITOR_BUCKET,
                                       BucketList);
        }

        //
        // Compute new timeout value in milliseconds
        //
        GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);
        if (CurrentTime > NextDueTime) {
            //
            // The next timeout has already expired
            //
            WaitTime = Timeout = 0;
        } else {
            WaitTime = NextDueTime - CurrentTime;
            CL_ASSERT(WaitTime < (DWORDLONG)0xffffffff * 10000);                // check for excessive value
            Timeout = (ULONG)(WaitTime / 10000);
        }
    }

    ReleaseEventListLock( EventList );
    return(Timeout);

} // RmpPollList



VOID
RmpPollBucket(
    IN PMONITOR_BUCKET Bucket
    )

/*++

Routine Description:

    Polls all the resources in a given bucket. Updates their state and notifies
    cluster manager as appropriate.

Arguments:

    Bucket - Supplies the bucket containing the list of resources to be polled.

Return Value:

    None.

--*/

{
    PLIST_ENTRY         CurrentEntry;
    PRESOURCE           Resource;
    BOOL                Success = TRUE;
    PRM_DUE_TIME_ENTRY  pDueTimeEntry;

    CurrentEntry = Bucket->ResourceList.Flink;
    while (CurrentEntry != &Bucket->ResourceList) {
        Resource = CONTAINING_RECORD(CurrentEntry,RESOURCE,ListEntry);
        //
        // The EventList Lock protects concurrent calls to individual
        // resources. The EventList Lock was taken out in RmpPollList.
        // If we increase the granularity of locking, and lock the resource
        // then we'd add a lock here.
        //
        if (Resource->State == ClusterResourceOnline) {

            //
            // A resource that is online alternates between LooksAlive
            // and IsAlive polling by doing an IsAlive poll instead of
            // a LooksAlive poll every IsAliveCount iterations.
            //
            Resource->IsAliveCount += 1;
            CL_ASSERT( Resource->IsAliveRollover != 0 );
            if (Resource->IsAliveCount == Resource->IsAliveRollover) {

                //
                // Poll the IsAlive entrypoint.
                //

                RmpSetMonitorState(RmonIsAlivePoll, Resource);
                pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                               Resource->ResourceType,
                                                               Resource->ResourceName,
                                                               L"Is alive" );
#ifdef COMRES
                Success = RESMON_ISALIVE (Resource) ;
#else
                Success = (Resource->IsAlive)(Resource->Id);
#endif
                RmpRemoveDeadlockMonitorList ( pDueTimeEntry );
                RmpSetMonitorState(RmonIdle, NULL);
                //
                // If this was successful, then we will perform the LooksAlive
                // test next time. Otherwise, we do the IsAlive check again.
                //
                if (Success) {
                    Resource->IsAliveCount = 0;
                } else {
                    --Resource->IsAliveCount;
                }

            } else {
                //
                // Poll the LooksAlive entrypoint.
                //
                if ( Resource->EventHandle == NULL ) {
                    RmpSetMonitorState(RmonLooksAlivePoll,Resource);
                    pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                                   Resource->ResourceType,
                                                                   Resource->ResourceName,
                                                                   L"Looks alive" );

#ifdef COMRES
                    Success = RESMON_LOOKSALIVE (Resource) ;
#else
                    Success = (Resource->LooksAlive)(Resource->Id);
#endif
                    RmpSetMonitorState(RmonIdle, NULL);
                    RmpRemoveDeadlockMonitorList ( pDueTimeEntry );
                }
                if ( !Success ) {
                    RmpSetMonitorState(RmonIsAlivePoll, Resource);
                    pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                                   Resource->ResourceType,
                                                                   Resource->ResourceName,
                                                                   L"Is alive (looksalive fail)" );
#ifdef COMRES
                    Success = RESMON_ISALIVE (Resource) ;
#else
                    Success = (Resource->IsAlive)(Resource->Id);
#endif
                    RmpSetMonitorState(RmonIdle, NULL);
                    RmpRemoveDeadlockMonitorList ( pDueTimeEntry );
                } 
            }
            if (!Success) {
                //
                // The resource has failed. Mark it as Failed and notify
                // the cluster manager.
                //
                Resource->State = ClusterResourceFailed;
                RmpPostNotify(Resource, NotifyResourceStateChange);
            }
        }
        CurrentEntry = CurrentEntry->Flink;
    }
} // RmpPollBucket



VOID
RmpSignalPoller(
    IN PPOLL_EVENT_LIST EventList
    )

/*++

Routine Description:

    Interface to notify the poller thread that the resource list has
    been changed or a new event has been added to the poll event list.
    The poller thread should get a new event list and recompute its timeouts.

Arguments:

    EventList - the event list that is to be notified.

Return Value:

    None.

--*/

{
    BOOL Success;

    if (EventList->ListNotify != NULL) {
        Success = SetEvent(EventList->ListNotify);
        CL_ASSERT(Success);
    }

} // RmpSignalPoller
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\property.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    property.c

Abstract:

    Implements the management of resource and resource type properties.

Author:

    Rod Gamache (rodga) 7-Jan-1996

Revision History:

--*/
#define UNICODE 1
#include "resmonp.h"
#include "clusudef.h"

#define RESMON_MODULE RESMON_MODULE_PROPERTY

#define MAX_DWORD ((DWORD)-1)

#define PARAMETERS_KEY CLUSREG_KEYNAME_PARAMETERS
#define RESOURCE_TYPES_KEY CLUSREG_KEYNAME_RESOURCE_TYPES

const WCHAR cszName[] = CLUSREG_NAME_RES_NAME;

typedef struct _COMMON_RES_PARAMS {
    LPWSTR          lpszResType;
    LPWSTR          lpszDescription;
    LPWSTR          lpszDebugPrefix;
    DWORD           dwSeparateMonitor;
    DWORD           dwPersistentState;
    DWORD           dwLooksAlive;
    DWORD           dwIsAlive;
    DWORD           dwRestartAction;
    DWORD           dwRestartThreshold;
    DWORD           dwRestartPeriod;
    DWORD           dwRetryPeriodOnFailure;
    DWORD           dwPendingTimeout;
    DWORD           dwLoadBalStartup;
    DWORD           dwLoadBalSample;
    DWORD           dwLoadBalAnalysis;
    DWORD           dwLoadBalProcessor;
    DWORD           dwLoadBalMemory;
} COMMON_RES_PARAMS, *PCOMMON_RES_PARAMS;

//
// Resource Common properties.
//

//
// Read-Write Resource Common Properties.
//
RESUTIL_PROPERTY_ITEM
RmpResourceCommonProperties[] = {
    { CLUSREG_NAME_RES_TYPE,              NULL, CLUSPROP_FORMAT_SZ,    0, 0, 0, 0, FIELD_OFFSET(COMMON_RES_PARAMS, lpszResType) },
    { CLUSREG_NAME_RES_DESC,              NULL, CLUSPROP_FORMAT_SZ,    0, 0, 0, 0, FIELD_OFFSET(COMMON_RES_PARAMS, lpszDescription) },
    { CLUSREG_NAME_RES_DEBUG_PREFIX,      NULL, CLUSPROP_FORMAT_SZ,    0, 0, 0, 0, FIELD_OFFSET(COMMON_RES_PARAMS, lpszDebugPrefix) },
    { CLUSREG_NAME_RES_SEPARATE_MONITOR,  NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwSeparateMonitor) },
    { CLUSREG_NAME_RES_PERSISTENT_STATE,  NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE,  CLUSTER_RESOURCE_MINIMUM_PERSISTENT_STATE,  CLUSTER_RESOURCE_MAXIMUM_PERSISTENT_STATE, RESUTIL_PROPITEM_SIGNED, FIELD_OFFSET(COMMON_RES_PARAMS, dwPersistentState) },
    { CLUSREG_NAME_RES_LOOKS_ALIVE,       NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE,       CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,       CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLooksAlive) },
    { CLUSREG_NAME_RES_IS_ALIVE,          NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_IS_ALIVE,          CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,          CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwIsAlive) },
    { CLUSREG_NAME_RES_RESTART_ACTION,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION,    0,                                          CLUSTER_RESOURCE_MAXIMUM_RESTART_ACTION, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwRestartAction) },
    { CLUSREG_NAME_RES_RESTART_THRESHOLD, NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD, CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD, CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwRestartThreshold) },
    { CLUSREG_NAME_RES_RESTART_PERIOD,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD,    CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,    CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwRestartPeriod) },
    { CLUSREG_NAME_RES_RETRY_PERIOD_ON_FAILURE,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE, 0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwRetryPeriodOnFailure) },
    { CLUSREG_NAME_RES_PENDING_TIMEOUT,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT,   CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,   CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwPendingTimeout) },
    { CLUSREG_NAME_RES_LOADBAL_STARTUP,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOADBAL_STARTUP,   0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalStartup) },
    { CLUSREG_NAME_RES_LOADBAL_SAMPLE,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOADBAL_SAMPLE,    0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalSample) },
    { CLUSREG_NAME_RES_LOADBAL_ANALYSIS,  NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOADBAL_ANALYSIS,  0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalAnalysis) },
    { CLUSREG_NAME_RES_LOADBAL_PROCESSOR, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalProcessor) },
    { CLUSREG_NAME_RES_LOADBAL_MEMORY,    NULL, CLUSPROP_FORMAT_DWORD, 0, 0, MAX_DWORD, 0, FIELD_OFFSET(COMMON_RES_PARAMS, dwLoadBalMemory) },
    { 0 }
};

//
// Read-Only Resource Common Properties.
//
RESUTIL_PROPERTY_ITEM
RmpResourceROCommonProperties[] = {
    { CLUSREG_NAME_RES_NAME, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
//    { CLUSREG_NAME_RES_DEPENDS_ON, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
//    { CLUSREG_NAME_RES_POSSIBLE_OWNERS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
    { 0 }
};


//
// Resource Type Common properties
//

//
// Read-Write Resource Type Common Properties.
//
RESUTIL_PROPERTY_ITEM
RmpResourceTypeCommonProperties[] = {
    { CLUSREG_NAME_RESTYPE_NAME,           NULL, CLUSPROP_FORMAT_SZ,       0, 0, 0, 0 },
    { CLUSREG_NAME_RESTYPE_DESC,           NULL, CLUSPROP_FORMAT_SZ,       0, 0, 0, 0 },
    { CLUSREG_NAME_RESTYPE_DEBUG_PREFIX,   NULL, CLUSPROP_FORMAT_SZ,       0, 0, 0, 0 },
    { CLUSREG_NAME_RESTYPE_DEBUG_CTRLFUNC, NULL, CLUSPROP_FORMAT_DWORD,    0, 0, 1, 0 },
    { CLUSREG_NAME_ADMIN_EXT,              NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, 0 },
    { CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,    NULL, CLUSPROP_FORMAT_DWORD,    CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE, CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE, CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE, 0 },
    { CLUSREG_NAME_RESTYPE_IS_ALIVE,       NULL, CLUSPROP_FORMAT_DWORD,    CLUSTER_RESOURCE_DEFAULT_IS_ALIVE,    CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,    CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE, 0 },
    { 0 }
};

//
// Read-Only Resource Type Common Properties.
//
RESUTIL_PROPERTY_ITEM
RmpResourceTypeROCommonProperties[] = {
    { CLUSREG_NAME_RESTYPE_DLL_NAME,     NULL, CLUSPROP_FORMAT_SZ,       0, 0, 0, 0 },
    { 0 }
};

//
// Local functions
//
DWORD
RmpCheckCommonProperties(
    IN PRESOURCE pResource,
    IN PCOMMON_RES_PARAMS pCommonParams
    );


DWORD
RmpResourceEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given resource.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Enumerate the common properties.
    //
    status = ResUtilEnumProperties( RmpResourceCommonProperties,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned,
                                    Required );

    return(status);

} // RmpResourceEnumCommonProperties



DWORD
RmpResourceGetCommonProperties(
    IN PRESOURCE Resource,
    IN BOOL     ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    ReadOnly - TRUE to get the Read-Only Common Properties. FALSE otherwise.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resKey;
    PRESUTIL_PROPERTY_ITEM propertyTable;

    //
    // Clear the output buffer.  Since this is an internal interface, we trust that
    // OutBuffer and OutBufferSize are valid.
    //
    if ( OutBufferSize != 0 ) {
        ZeroMemory( OutBuffer, OutBufferSize );
    }

    if ( ReadOnly ) {
        propertyTable = RmpResourceROCommonProperties;
    } else {
        propertyTable = RmpResourceCommonProperties;
    }

    //
    // Open the cluster resource key
    //
    status = ClusterRegOpenKey( RmpResourcesKey,
                                Resource->ResourceId,
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        *BytesReturned = 0;
        *Required = 0;
        return(status);
    }

    //
    // Get the common properties.
    //
    status = ResUtilGetProperties( resKey,
                                   propertyTable,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required );

    ClusterRegCloseKey( resKey );

    return(status);

} // RmpResourceGetCommonProperties



DWORD
RmpResourceValidateCommonProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;
    COMMON_RES_PARAMS CommonProps;

    ZeroMemory( &CommonProps, sizeof ( COMMON_RES_PARAMS ) );

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPropertyTable( RmpResourceCommonProperties,
                                         NULL,     // Reserved
                                         FALSE,    // Don't allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         ( LPBYTE ) &CommonProps );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpResourceValidateCommonProperties, Error %1!d! in verify routine for resource %2!ws!\n",
                      status,
                      Resource->ResourceName);
    } else {
        //  
        //  Chittur Subbaraman (chitturs) - 5/7/99
        //
        //  Validate the values of the common properties supplied
        //
        status = RmpCheckCommonProperties( Resource, &CommonProps );
        
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpResourceValidateCommonProperties, Error %1!d! in "
                          "checking routine for resource %2!ws!\n",
                          status,
                          Resource->ResourceName);
        }
    }

    ResUtilFreeParameterBlock(( LPBYTE ) &CommonProps,
                               NULL,
                               RmpResourceCommonProperties
                             );

    return(status);
} // RmpResourceValidateCommonProperties



DWORD
RmpResourceSetCommonProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    HKEY                    resKey = NULL;
    DWORD                   oldSeparateMonitor;
    DWORD                   newSeparateMonitor;
    COMMON_RES_PARAMS       CommonProps;

    ZeroMemory( &CommonProps, sizeof ( COMMON_RES_PARAMS ) );
    
    //
    // Validate the property list.
    //
    status = ResUtilVerifyPropertyTable( RmpResourceCommonProperties,
                                         NULL,     // Reserved
                                         FALSE,    // Don't allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         ( LPBYTE ) &CommonProps );

    if ( status == ERROR_SUCCESS ) {
        //  
        //  Chittur Subbaraman (chitturs) - 5/7/99
        //
        //  Validate the values of the common properties supplied
        //
        status = RmpCheckCommonProperties( Resource, &CommonProps );
        
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpResourceSetCommonProperties, Error %1!d! in "
                          "checking routine for resource %2!ws!\n",
                          status,
                          Resource->ResourceName);
            goto FnExit;
        }
    
        //
        // Open the cluster resource key
        //
        status = ClusterRegOpenKey( RmpResourcesKey,
                                    Resource->ResourceId,
                                    KEY_READ,
                                    &resKey );

        if ( status != ERROR_SUCCESS ) {
            goto FnExit;
        }

        //
        // Get the current SeparateMonitor value.
        //
        status = ResUtilGetDwordValue( resKey,
                                       CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                       &oldSeparateMonitor,
                                       0 );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpResourceSetCommonProperties, error %1!d! in getting "
                          "'SeparateMonitor' value for resource %2!ws!.\n",
                          status,
                          Resource->ResourceName);
            goto FnExit;
        }

        status = ResUtilSetPropertyTable( resKey,
                                          RmpResourceCommonProperties,
                                          NULL,     // Reserved
                                          FALSE,    // Don't allow unknowns
                                          InBuffer,
                                          InBufferSize,
                                          NULL );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpResourceSetCommonProperties, Error %1!d! in set routine for resource %2!ws!.\n",
                          status,
                          Resource->ResourceName);
        } else {
            //
            // Get the new SeparateMonitor value.  If it changed, return a
            // different error code.
            //
            status = ResUtilGetDwordValue( resKey,
                                           CLUSREG_NAME_RES_SEPARATE_MONITOR,
                                           &newSeparateMonitor,
                                           0 );

            if ( status == ERROR_SUCCESS ) {
                if ( oldSeparateMonitor != newSeparateMonitor ) {
                    status = ERROR_RESOURCE_PROPERTIES_STORED;
                }
            }
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpResourceSetCommonProperties, error %1!d! in verify routine for resource %2!ws!.\n",
                      status,
                      Resource->ResourceName);
    }

FnExit:
    ResUtilFreeParameterBlock(( LPBYTE ) &CommonProps,
                               NULL,
                               RmpResourceCommonProperties
                             );
    if ( resKey != NULL ) {
        ClusterRegCloseKey( resKey );
    }

    return( status );
} // RmpResourceSetCommonProperties



DWORD
RmpResourceEnumPrivateProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given resource.

Arguments:

    Resource - Supplies the resource.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resKey;
    WCHAR       PrivateProperties[] = L"12345678-1234-1234-1234-123456789012\\Parameters";

    *BytesReturned = 0;
    *Required = 0;

    //
    // Copy the ResourceId for opening the private properties.
    //
    CL_ASSERT( lstrlenW( Resource->ResourceId ) == (32+4) );

    MoveMemory( PrivateProperties,
                Resource->ResourceId,
                lstrlenW( Resource->ResourceId ) * sizeof(WCHAR) );

    //
    // Open the cluster resource key
    //
    status = ClusterRegOpenKey( RmpResourcesKey,
                                PrivateProperties,
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Enumerate the private properties.
    //
    status = ResUtilEnumPrivateProperties( resKey,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required );
    ClusterRegCloseKey( resKey );

    return(status);

} // RmpResourceEnumPrivateProperties



DWORD
RmpResourceGetPrivateProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resKey;
    WCHAR       PrivateProperties[] = L"12345678-1234-1234-1234-123456789012\\Parameters";

    *BytesReturned = 0;
    *Required = 0;

    //
    // Copy the ResourceId for opening the private properties.
    //
    CL_ASSERT( lstrlenW( Resource->ResourceId ) == (32+4) );

    MoveMemory( PrivateProperties,
                Resource->ResourceId,
                lstrlenW( Resource->ResourceId ) * sizeof(WCHAR) );

    //
    // Open the cluster resource key
    //
    status = ClusterRegOpenKey( RmpResourcesKey,
                                PrivateProperties,
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            if ( OutBufferSize < sizeof( DWORD ) ) {
                *Required = 4;
            } else {
                *((LPDWORD) OutBuffer) = 0;
                *BytesReturned = sizeof( DWORD );
            }
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Get private properties for the resource.
    //
    status = ResUtilGetPrivateProperties( resKey,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned,
                                          Required );

    ClusterRegCloseKey( resKey );

    return(status);

} // RmpResourceGetPrivateProperties



DWORD
RmpResourceValidatePrivateProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPrivatePropertyList( InBuffer,
                                               InBufferSize );

    return(status);

} // RmpResourceValidatePrivateProperties



DWORD
RmpResourceSetPrivateProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given resource.

Arguments:

    Resource - Supplies the resource.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resKey;
    WCHAR       PrivateProperties[] = L"12345678-1234-1234-1234-123456789012\\Parameters";

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPrivatePropertyList( InBuffer,
                                               InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Copy the ResourceId for opening the private properties.
        //
        CL_ASSERT( lstrlenW( Resource->ResourceId ) == (32+4) );

        MoveMemory( PrivateProperties,
                    Resource->ResourceId,
                    lstrlenW(Resource->ResourceId) * sizeof(WCHAR) );

        //
        // Open the cluster resource key
        //
        status = ClusterRegOpenKey( RmpResourcesKey,
                                    PrivateProperties,
                                    KEY_READ,
                                    &resKey );
        if ( status != ERROR_SUCCESS ) {
            return(status);
        }

        status = ResUtilSetPrivatePropertyList( resKey,
                                                InBuffer,
                                                InBufferSize );
        ClusterRegCloseKey( resKey );
    }

    return(status);

} // RmpResourceSetPrivateProperties



DWORD
RmpResourceGetFlags(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given resource.

Arguments:

    Resource - Supplies the resource.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        HKEY        resKey;
        DWORD       valueType;

        //
        // Open the cluster resource key
        //
        status = ClusterRegOpenKey( RmpResourcesKey,
                                    Resource->ResourceId,
                                    KEY_READ,
                                    &resKey );
        if ( status == ERROR_SUCCESS ) {
            //
            // Read the Flags value for the resource.
            //
            *BytesReturned = OutBufferSize;
            status = ClusterRegQueryValue( resKey,
                                           CLUSREG_NAME_FLAGS,
                                           &valueType,
                                           OutBuffer,
                                           BytesReturned );
            ClusterRegCloseKey( resKey );
            if ( status == ERROR_FILE_NOT_FOUND ) {
                *BytesReturned = sizeof(DWORD);
                *(LPDWORD)OutBuffer = 0;
                status = ERROR_SUCCESS;
            }
        }
    }

    return(status);

} // RmpResourceGetFlags



DWORD
RmpResourceTypeEnumCommonProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type's name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Enumerate the common properties.
    //
    status = ResUtilEnumProperties( RmpResourceTypeCommonProperties,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned,
                                    Required );

    return(status);

} // RmpResourceTypeEnumCommonProperties



DWORD
RmpResourceTypeGetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN BOOL    ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resourceTypesKey;
    HKEY        resTypeKey;
    PRESUTIL_PROPERTY_ITEM propertyTable;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    if ( ReadOnly ) {
        propertyTable = RmpResourceTypeROCommonProperties;
    } else {
        propertyTable = RmpResourceTypeCommonProperties;
    }
        
    //
    // Open the specific cluster ResourceType key
    //
    status = ClusterRegOpenKey( RmpResTypesKey,
                                ResourceTypeName,
                                KEY_READ,
                                &resTypeKey );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Get the common properties.
    //
    status = ResUtilGetProperties( resTypeKey,
                                   propertyTable,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned,
                                   Required );

    ClusterRegCloseKey( resTypeKey );

    return(status);

} // RmpResourceTypeGetCommonProperties



DWORD
RmpResourceTypeValidateCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPropertyTable( RmpResourceTypeCommonProperties,
                                         NULL,     // Reserved
                                         FALSE,    // Don't allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         NULL );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpResourceTypeValidateCommonProperties, error in verify routine.\n");
    }

    return(status);

} // RmpResourceTypeValidateCommonProperties



DWORD
RmpResourceTypeSetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;
    HKEY    resourceTypesKey;
    HKEY    resTypeKey;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPropertyTable( RmpResourceTypeCommonProperties,
                                         NULL,     // Reserved
                                         FALSE,    // Don't allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         NULL );

    if ( status == ERROR_SUCCESS ) {
        //
        // Open the specific cluster resource type key
        //
        status = ClusterRegOpenKey( RmpResTypesKey,
                                    ResourceTypeName,
                                    KEY_READ,
                                    &resTypeKey );
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] Failed to open ResourceTypes\\%1 cluster registry key, error %2!u!.\n",
                          ResourceTypeName,
                          status);
            return(status);
        }

        status = ResUtilSetPropertyTable( resTypeKey,
                                          RmpResourceTypeCommonProperties,
                                          NULL,     // Reserved
                                          FALSE,    // Don't allow unknowns
                                          InBuffer,
                                          InBufferSize,
                                          NULL );
        ClusterRegCloseKey( resTypeKey );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_UNUSUAL, "[RM] RmpResourceTypeSetCommonProperties, error in set routine.\n");
        }
    } else {
        ClRtlLogPrint( LOG_UNUSUAL, "[RM] RmpResourceTypeSetCommonProperties, error in verify routine.\n");
    }

    return(status);

} // RmpResourceTypeSetCommonProperties



DWORD
RmpResourceTypeEnumPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type's name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resTypeKey;
    DWORD       nameLength;
    LPWSTR      name;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Create name to open
    //
    nameLength = lstrlenW( ResourceTypeName ) + sizeof( PARAMETERS_KEY ) + 1;
    name = RmpAlloc( nameLength * sizeof(WCHAR) );
    if ( name == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wsprintfW( name, L"%ws\\%ws", ResourceTypeName, PARAMETERS_KEY );

    //
    // Open the specific cluster ResourceType key
    //
    status = ClusterRegOpenKey( RmpResTypesKey,
                                name,
                                KEY_READ,
                                &resTypeKey );
    RmpFree( name );
    if ( status != ERROR_SUCCESS ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }


    //
    // Enumerate the private properties.
    //
    status = ResUtilEnumPrivateProperties( resTypeKey,
                                           OutBuffer,
                                           OutBufferSize,
                                           BytesReturned,
                                           Required );
    ClusterRegCloseKey( resTypeKey );

    return(status);

} // RmpResourceTypeEnumPrivateProperties



DWORD
RmpResourceTypeGetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given resource.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resTypeKey;
    DWORD       nameLength;
    LPWSTR      name;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Create name to open
    //
    nameLength = lstrlenW( ResourceTypeName ) + sizeof( PARAMETERS_KEY ) + 1;
    name = RmpAlloc( nameLength * sizeof(WCHAR) );
    if ( name == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    wsprintfW( name, L"%ws\\%ws", ResourceTypeName, PARAMETERS_KEY );

    //
    // Open the specific cluster ResourceType key
    //
    status = ClusterRegOpenKey( RmpResTypesKey,
                                name,
                                KEY_READ,
                                &resTypeKey );
    RmpFree( name );
    if ( status != ERROR_SUCCESS ) {
        if ( status == ERROR_FILE_NOT_FOUND ) {
            if ( OutBufferSize < sizeof( DWORD ) ) {
                *Required = 4;
            } else {
                *((LPDWORD) OutBuffer) = 0;
                *BytesReturned = sizeof( DWORD );
            }
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Get private properties for the resource type.
    //
    status = ResUtilGetPrivateProperties( resTypeKey,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned,
                                          Required );

    ClusterRegCloseKey( resTypeKey );

    return(status);

} // RmpResourceTypeGetPrivateProperties



DWORD
RmpResourceTypeValidatePrivateProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given resource.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPrivatePropertyList( InBuffer,
                                               InBufferSize );

    return(status);


} // RmpResourceTypeValidatePrivateProperties



DWORD
RmpResourceTypeSetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given resource.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HKEY        resourceTypesKey;
    HKEY        resTypeKey;
    LPWSTR      name;
    DWORD       length;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ResUtilVerifyPrivatePropertyList( InBuffer,
                                               InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Create name to open
        //
        length = lstrlenW( ResourceTypeName ) + 1;
        name = RmpAlloc( length * sizeof(WCHAR) );
        if ( name == NULL ) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        lstrcpyW( name, ResourceTypeName );

        //
        // Open the specific cluster ResourceType key
        //
        status = ClusterRegOpenKey( RmpResTypesKey,
                                    name,
                                    KEY_READ,
                                    &resourceTypesKey );
        RmpFree( name );
        if ( status != ERROR_SUCCESS ) {
            if ( status == ERROR_FILE_NOT_FOUND ) {
                status = ERROR_SUCCESS;
            }
            return(status);
        }

        //
        // Open the parameters key
        //
        status = ClusterRegOpenKey( resourceTypesKey,
                                    PARAMETERS_KEY,
                                    KEY_READ,
                                    &resTypeKey );
        if ( status != ERROR_SUCCESS ) {
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                status = ClusterRegCreateKey( resourceTypesKey,
                                              PARAMETERS_KEY,
                                              0,
                                              KEY_READ | KEY_WRITE,
                                              NULL,
                                              &resTypeKey,
                                              &disposition );
                if ( status != ERROR_SUCCESS ) {
                    ClusterRegCloseKey( resourceTypesKey );
                    return(status);
                }
            }
        }

        if ( status == ERROR_SUCCESS ) {

            status = ResUtilSetPrivatePropertyList( resTypeKey,
                                                    InBuffer,
                                                    InBufferSize );
            ClusterRegCloseKey( resTypeKey );
        }

        ClusterRegCloseKey( resourceTypesKey );
    }

    return(status);


} // RmpResourceTypeSetPrivateProperties



DWORD
RmpResourceTypeGetFlags(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        HKEY        resourceTypesKey;
        HKEY        resTypeKey;
        DWORD       valueType;

        //
        // Open the specific cluster ResourceType key
        //
        status = ClusterRegOpenKey( RmpResTypesKey,
                                    ResourceTypeName,
                                    KEY_READ,
                                    &resTypeKey );
        if ( status == ERROR_SUCCESS ) {
            //
            // Read the Flags value for the resource type.
            //
            *BytesReturned = OutBufferSize;
            status = ClusterRegQueryValue( resTypeKey,
                                           CLUSREG_NAME_FLAGS,
                                           &valueType,
                                           OutBuffer,
                                           BytesReturned );
            ClusterRegCloseKey( resTypeKey );
            if ( status == ERROR_FILE_NOT_FOUND ) {
                *(LPDWORD)OutBuffer = 0;
                *BytesReturned = sizeof(DWORD);
                status = ERROR_SUCCESS;
            }
        }
    }

    return(status);

} // RmpResourceTypeGetFlags

DWORD
RmpCheckCommonProperties(
    IN PRESOURCE pResource,
    IN PCOMMON_RES_PARAMS pCommonParams
    )

/*++

Routine Description:

    Checks and validates the supplied values of common properties.

Arguments:

    pResource - Pointer to the resource.

    pCommonParams - The parameter block supplied by the user.
    
Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       dwStatus;
    COMMON_RES_PARAMS 
                currentCommonParams;
    LPBYTE      pBuffer = NULL;
    DWORD       dwBytesReturned = 0;
    DWORD       dwBytesRequired = 0;

    //  
    //  Chittur Subbaraman (chitturs) - 5/7/99
    //
    //  This function verifies whether the common property values
    //  that are supplied by the user are valid.
    //
    ZeroMemory( &currentCommonParams, sizeof ( COMMON_RES_PARAMS ) );

    //
    //  First check whether the user has supplied two conflicting
    //  parameter values.
    //
    if ( ( pCommonParams->dwRetryPeriodOnFailure != 0 ) &&
         ( pCommonParams->dwRestartPeriod != 0 ) &&
         ( pCommonParams->dwRetryPeriodOnFailure <
              pCommonParams->dwRestartPeriod ) )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties, Invalid parameters supplied: "
                      "RetryPeriod=%1!d! < RestartPeriod=%2!d! for resource %3!ws!\n",
                      pCommonParams->dwRetryPeriodOnFailure, 
                      pCommonParams->dwRestartPeriod,
                      pResource->ResourceName);
        goto FnExit;
    }

    //
    //  Get the buffer size for common properties list.
    //
    dwStatus = RmpResourceGetCommonProperties( pResource,
                                               FALSE,
                                               NULL,
                                               0,
                                               &dwBytesReturned,
                                               &dwBytesRequired
                                               );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties: Error %1!d! in getting props for resource %2!ws! (1st time)\n",
                      dwStatus,
                      pResource->ResourceName);
        goto FnExit;
    }

    pBuffer = LocalAlloc( LMEM_FIXED, dwBytesRequired + 10 );

    if ( pBuffer == NULL )
    {
        ClRtlLogPrint(LOG_UNUSUAL, 
                      "[RM] RmpCheckCommonProperties: Error %1!d! in mem alloc for resource %2!ws!\n",
                      dwStatus,
                      pResource->ResourceName);
        goto FnExit;
    }

    //
    //  Get all the common properties from the cluster database
    //
    dwStatus = RmpResourceGetCommonProperties( pResource,
                                               FALSE,
                                               pBuffer,
                                               dwBytesRequired + 10,
                                               &dwBytesReturned,
                                               &dwBytesReturned
                                               );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties: Error %1!d! in getting props for resource %2!ws! (2nd time)\n",
                      dwStatus,
                      pResource->ResourceName);
        goto FnExit;
    }

    //
    //  Get the parameter block from the common properties list
    //
    dwStatus = ResUtilVerifyPropertyTable( RmpResourceCommonProperties,
                                           NULL,     // Reserved
                                           FALSE,    // Don't allow unknowns
                                           pBuffer,
                                           dwBytesRequired + 10,
                                           ( LPBYTE ) &currentCommonParams );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties: Error %1!d! in verifying props for resource %2!ws!\n",
                      dwStatus,
                      pResource->ResourceName);
        goto FnExit;
    }

    //
    //  Check whether the RetryPeriodOnFailure is >= RestartPeriod
    //
    if ( ( ( pCommonParams->dwRetryPeriodOnFailure != 0 ) &&
             ( pCommonParams->dwRetryPeriodOnFailure <
                   currentCommonParams.dwRestartPeriod ) ) ||
         ( ( pCommonParams->dwRestartPeriod != 0 ) && 
            ( currentCommonParams.dwRetryPeriodOnFailure <
                   pCommonParams->dwRestartPeriod ) ) )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpCheckCommonProperties, Invalid IN params for resource %5!ws!: "
                      "Supplied Retry Period=%1!d!\n"
                      "[RM] Restart Period (DB)=%2!d!, RetryPeriod (DB)=%3!d!, Supplied Restart Period=%4!d! \n",
                      pCommonParams->dwRetryPeriodOnFailure,
                      currentCommonParams.dwRestartPeriod,
                      currentCommonParams.dwRetryPeriodOnFailure,
                      pCommonParams->dwRestartPeriod,
                      pResource->ResourceName);
        goto FnExit;
    }

FnExit:  
    LocalFree( pBuffer );

    ResUtilFreeParameterBlock(( LPBYTE ) &currentCommonParams,
                               NULL,
                               RmpResourceCommonProperties
                             );

    return( dwStatus );
} // RmpCheckCommonProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\evntlist.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    evntlist.c

Abstract:

    This module contains routines to process the Poll Event List.

Author:

    Rod Gamache (rodga) 9-April-1996

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "resmonp.h"
#include "stdio.h"

#define RESMON_MODULE RESMON_MODULE_EVNTLIST

//
// Global data defined by this module
//
LIST_ENTRY  RmpEventListHead;           // Event list (under construction)

//
// Function prototypes local to this module
//



DWORD
RmpAddPollEvent(
    IN PPOLL_EVENT_LIST EventList,
    IN HANDLE EventHandle,
    IN PRESOURCE Resource OPTIONAL
    )

/*++

Routine Description:

    Add a new EventHandle to the list of events in the Poll EventList.

Arguments:

    EventList - The event list associated with this event handle and resource.

    EventHandle - The new event handle to be added.

    Resource - The resource associated with the event handle.

Return Value:

    ERROR_SUCCESS - if the request is successful.
    ERROR_DUPLICATE_SERVICE_NAME - if the event handle is already in the list
    Win32 error code on other failures.

Note:

    Since the resource is optional, we cannot get the event list from the
    resource.

--*/

{
    DWORD               i;
    PLIST_ENTRY         pListEntry;
    PPOLL_EVENT_LIST    pTempEventList;

    CL_ASSERT( EventHandle != NULL );

    if ( ARGUMENT_PRESENT( Resource ) ) {
        CL_ASSERT( Resource->EventHandle == NULL );
    }

    //
    //  Acquire the global lock to walk all event list heads.  
    //
    AcquireListLock();

    //
    //  Since the global lock is acquired above, there is no danger of eventlist lock ordering being reversed
    //  even as multiple eventlist lock acquisitions are made below.
    //
    AcquireEventListLock( EventList );

    for ( pListEntry = RmpEventListHead.Flink;
          pListEntry != &RmpEventListHead;
          pListEntry = pListEntry->Flink ) 
    {
        pTempEventList = CONTAINING_RECORD( pListEntry, POLL_EVENT_LIST, Next );

        AcquireEventListLock( pTempEventList );

        //
        // First, make sure this handle isn't already present in ANY list.
        //
        for ( i = 0; i < pTempEventList->EventCount; i++ ) 
        {
            if ( pTempEventList->Handle[i] == EventHandle ) 
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                       "[RM] RmpAddPollEvent: Event handle 0x%1!08lx! is a duplicate of that of resource %2!ws!...\n",
                       EventHandle,
                       pTempEventList->Resource[i]->ResourceName);
                ReleaseEventListLock( pTempEventList );
                ReleaseEventListLock( EventList );
                ReleaseListLock();
                return( ERROR_DUPLICATE_SERVICE_NAME );
            }
        }

        ReleaseEventListLock( pTempEventList );
    }// for

    //
    //  Release the global lock. Note that since we acquire the eventlist lock of the list we are
    //  going to change, say lock L, a second thread cannot sneak in and insert a duplicate event after the first
    //  thread has ensured that there are no duplicate events.  This is because the second thread won't
    //  be able to acquire the eventlist lock L acquired by the first thread.
    //
    ReleaseListLock();

    //
    // Now make sure that we don't have too many events in this list!
    //

    CL_ASSERT ( EventList->EventCount < MAX_HANDLES_PER_THREAD );

    //
    // Now add our event to our list.
    //

    EventList->Handle[EventList->EventCount] = EventHandle;
    EventList->Resource[EventList->EventCount] = Resource;

    if ( ARGUMENT_PRESENT( Resource ) ) {
        Resource->EventHandle = EventHandle;
    }

    ++EventList->EventCount;
    ReleaseEventListLock( EventList );

    //
    // Now wake up our poller thread to get the new list.
    // Currently, the Online routine will pulse the poller thread - so
    // no need to do it here.

    //SignalPoller( EventList );

    return(ERROR_SUCCESS);

} // RmpAddPollEvent



DWORD
RmpRemovePollEvent(
    PPOLL_EVENT_LIST pEventList,
    IN HANDLE EventHandle
    )

/*++

Routine Description:

    Remove an EventHandle from the list of events in the Poll EventList.

Arguments:

    pEventList - The event list from which a handle is to be removed.
    
    EventHandle - The event handle to be removed.

Return Value:

    ERROR_SUCCESS - if the request is successful.
    ERROR_RESOURCE_NOT_FOUND - if the EventHandle is not in the list.

Note:

    We can only add to the event lists listhead - we can never remove a
    POLL_EVENT_LIST structure from the list!

--*/

{
    DWORD i;
    DWORD j;
    PRESOURCE resource;
    PLIST_ENTRY listEntry;

    CL_ASSERT( ARGUMENT_PRESENT( EventHandle ) );

    AcquireEventListLock( pEventList );

    //
    // Find the entry in the event list.
    //
    for ( i = 0; i < pEventList->EventCount; i++ ) {
        if ( pEventList->Handle[i] == EventHandle ) {
            break;
        }
    }

    //
    // If we hit the end of the list without finding our event, return error.
    //
    if ( i >= pEventList->EventCount ) {
        ReleaseEventListLock( pEventList );
        ClRtlLogPrint(LOG_UNUSUAL,
                       "[RM] RmpRemovePollEvent: Event handle 0x%1!08lx! not found in the eventlist...\n",
                       EventHandle);
        return( ERROR_RESOURCE_NOT_FOUND );
    }

    //
    // Otherwise, collapse lists, but first save pointer to the resource.
    //
    resource = pEventList->Resource[i];
    CL_ASSERT( resource != NULL );

    for ( j = i; j < (pEventList->EventCount-1); j++ ) {
        pEventList->Handle[j] = pEventList->Handle[j+1];
        pEventList->Resource[j] = pEventList->Resource[j+1];
    }

    --pEventList->EventCount;
    pEventList->Handle[pEventList->EventCount] = NULL;
    pEventList->Resource[pEventList->EventCount] = NULL;

    //
    // Event handle is of no use anymore until Online returns a new one.
    // N.B. We do not close the event handle, since the resource DLL is
    // responsible for taking care of this.
    //
    CL_ASSERT( EventHandle == resource->EventHandle );
    resource->EventHandle = NULL;

    ReleaseEventListLock( pEventList );

    //
    // Now wake up the poll thread to get the new list.
    //
    RmpSignalPoller( pEventList );

    return(ERROR_SUCCESS);

} // RmpRemovePollEvent


PVOID
RmpCreateEventList(
    VOID
    )

/*++

Routine Description:

    Allocates, initializes and inserts a new event list.

Arguments:

    None.

Returns:

    NULL - we failed.
    non-NULL - a pointer to the new event list.

    If NULL, it does a SetLastError() to indicate the failure.

Notes:

    This routine assumes that the EventListLock is held during this call.
    This routine will start a new event processing thread that will handle
    the list.

    There is one ListNotify event and one BucketListHead per event list!

--*/

{
    PPOLL_EVENT_LIST newEventList=NULL;
    DWORD   threadId;
    DWORD   dwError = ERROR_SUCCESS;

    AcquireListLock();

    if ( RmpShutdown || (RmpNumberOfThreads >= MAX_THREADS) ) {
        dwError = ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED;
        goto FnExit;
    }

    newEventList = LocalAlloc(LMEM_ZEROINIT,
                              sizeof( POLL_EVENT_LIST ));

    if ( newEventList == NULL ) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    //
    // Initialize the newEventList.
    //

    InitializeListHead( &newEventList->BucketListHead );
    InitializeCriticalSection( &newEventList->ListLock );

    //
    // Now create a thread and pass this Event List to it.
    //

    newEventList->ThreadHandle = CreateThread(NULL,
                                              0,
                                              RmpPollerThread,
                                              newEventList,
                                              0,
                                              &threadId);
    if ( newEventList->ThreadHandle == NULL ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Tally one more event list, and insert onto list of event lists.
    //

    RmpWaitArray[RmpNumberOfThreads] = newEventList->ThreadHandle;
    ++RmpNumberOfThreads;
    InsertTailList( &RmpEventListHead, &newEventList->Next );

    //
    // Signal the main thread to rewait and watch the new thread.
    //

    SetEvent( RmpRewaitEvent );


FnExit:
    ReleaseListLock();
    if (dwError != ERROR_SUCCESS)
    {
        //we failed, release any resource we might have allocated
        if (newEventList) 
        {
            RmpFree( newEventList );
        }
        SetLastError(dwError);
    }
    return(newEventList);

} // RmpCreateEventList



DWORD
RmpResourceEventSignaled(
    IN PPOLL_EVENT_LIST EventList,
    IN DWORD EventIndex
    )

/*++

Routine Description:

    A resource event has been signaled. This indicates that the specified
    resource has failed.

Arguments:

    EventList - the waiting event list.
    EventIndex - index of the event that was signaled.

Return Value:

    ERROR_SUCCESS - if the request is successful.

--*/

{
    PRESOURCE resource;

    //
    //  Don't post any events if resmon is shutting down. This causes cluster service policies
    //  to be triggered while resmon is shutting down and that causes bogus RPC failures in
    //  cluster service.
    //
    if ( RmpShutdown ) return ( ERROR_SUCCESS );

    CL_ASSERT( EventIndex <= MAX_HANDLES_PER_THREAD );

    //
    // Get our resource.
    //

    resource = EventList->Resource[EventIndex];

    if ( resource == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Remove the failed resource from the event notification list.
    // N.B. we do not need to acquire the eventlist lock because there is
    // only one thread that can ever touch the waiting event list!
    //

    if ( resource->EventHandle ) {
        RmpRemovePollEvent( resource->EventList, resource->EventHandle );
    }

    //
    // Post the failure of the resource, if the resource is not being taken
    // offline.
    //
    if ( resource->State != ClusterResourceOffline ) {
        CL_ASSERT( resource->State != ClusterResourceFailed );
        resource->State = ClusterResourceFailed;
        RmpPostNotify(resource, NotifyResourceStateChange);
    }

    return(ERROR_SUCCESS);

} // RmpResourceEventSignaled
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\excprpt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    excprt.c
    
Abstract:

    This module uses imagehlp.dll to dump the stack when an exception occurs.

Author:

    Sunita Shrivastava(sunitas) 11/5/1997

Revision History:

--*/
#define UNICODE 1
#define _UNICODE 1

#include "resmonp.h"
#include "dbghelp.h"


// Make typedefs for some dbghelp.DLL functions so that we can use them
// with GetProcAddress
typedef BOOL (__stdcall * SYMINITIALIZEPROC)( HANDLE, LPSTR, BOOL );
typedef BOOL (__stdcall *SYMCLEANUPPROC)( HANDLE );

typedef BOOL (__stdcall * STACKWALKPROC)
           ( DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
            PREAD_PROCESS_MEMORY_ROUTINE,
            PFUNCTION_TABLE_ACCESS_ROUTINE,
            PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE );

typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)( HANDLE, ULONG_PTR );

typedef ULONG_PTR (__stdcall *SYMGETMODULEBASEPROC)( HANDLE, ULONG_PTR );

typedef BOOL (__stdcall *SYMGETSYMFROMADDRPROC)
                            ( HANDLE, ULONG_PTR, PULONG_PTR, PIMAGEHLP_SYMBOL );

typedef BOOL (__stdcall *SYMFROMADDRPROC)
                            ( HANDLE, DWORD64, PDWORD64, PSYMBOL_INFO );

typedef BOOL (__stdcall *MINIDUMPWRITEDUMP)
                            ( HANDLE, DWORD, HANDLE, MINIDUMP_TYPE, 
                              PMINIDUMP_EXCEPTION_INFORMATION,
                              PMINIDUMP_USER_STREAM_INFORMATION,
                              PMINIDUMP_CALLBACK_INFORMATION );


SYMINITIALIZEPROC _SymInitialize = 0;
SYMCLEANUPPROC _SymCleanup = 0;
STACKWALKPROC _StackWalk = 0;
SYMFUNCTIONTABLEACCESSPROC _SymFunctionTableAccess = 0;
SYMGETMODULEBASEPROC _SymGetModuleBase = 0;
SYMGETSYMFROMADDRPROC _SymGetSymFromAddr = 0;
SYMFROMADDRPROC _SymFromAddr = 0;
MINIDUMPWRITEDUMP _MiniDumpWriteDump = NULL;

//local prototypes for forward use
BOOL InitImagehlpFunctions();
void ImagehlpStackWalk( IN PCONTEXT pContext );
BOOL GetLogicalAddress(
        IN PVOID    addr, 
        OUT LPWSTR  szModule, 
        IN  DWORD   len, 
        OUT LPDWORD section, 
        OUT PULONG_PTR offset );

VOID
GenerateMemoryDump(
    IN PEXCEPTION_POINTERS pExceptionInfo
    );

VOID
DumpCriticalSection(
    IN PCRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

Inputs:

Outputs:

--*/

{
    DWORD status;

    ClRtlLogPrint(LOG_CRITICAL, "[RM] Dumping Critical Section at %1!08LX!\n",
                CriticalSection );

    try {
        if ( CriticalSection->LockCount == -1 ) {
            ClRtlLogPrint(LOG_CRITICAL, "     LockCount       NOT LOCKED\n" );
        } else {
            ClRtlLogPrint(LOG_CRITICAL, "     LockCount       %1!u!\n",
                        CriticalSection->LockCount );
        }
        ClRtlLogPrint(LOG_CRITICAL, "     RecursionCount  %1!x!\n",
                    CriticalSection->RecursionCount );
        ClRtlLogPrint(LOG_CRITICAL, "     OwningThread    %1!x!\n",
                    CriticalSection->OwningThread );
        ClRtlLogPrint(LOG_CRITICAL, "     EntryCount      %1!x!\n",
                    CriticalSection->DebugInfo->EntryCount );
        ClRtlLogPrint(LOG_CRITICAL, "     ContentionCount %1!x!\n\n",
                    CriticalSection->DebugInfo->ContentionCount );
    
    } except ( EXCEPTION_EXECUTE_HANDLER )  {
        status = GetExceptionCode();
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Exception %1!lx! occurred while dumping critsec\n\n",
            status );
    }

    
} // DumpCriticalSection

VOID
GenerateMemoryDump(
    IN PEXCEPTION_POINTERS pExceptionInfo
    )
/*++

Routine Description:

    Generates a memory dump for the resource monitor process.

Arguments:

    pExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    DWORD                           dwStatus = ERROR_SUCCESS;
    WCHAR                           szFileName[ MAX_PATH + RTL_NUMBER_OF ( RM_DMP_FILE_NAME ) + 1 ];
    HANDLE                          hDumpFile = INVALID_HANDLE_VALUE;
    MINIDUMP_EXCEPTION_INFORMATION  mdumpExceptionInfo;

    if ( !_MiniDumpWriteDump ) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_CRITICAL, "[RM] GenerateMemoryDump: _MiniDumpWriteDump fn ptr is invalid, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }

    dwStatus = ClRtlGetClusterDirectory( szFileName, RTL_NUMBER_OF ( szFileName ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] GenerateMemoryDump: Could not get cluster dir, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }

    wcsncat( szFileName, 
             RM_DMP_FILE_NAME, 
             RTL_NUMBER_OF ( szFileName ) - 
                 ( wcslen ( szFileName ) + 1 ) );

    szFileName [ RTL_NUMBER_OF ( szFileName ) - 1 ] = UNICODE_NULL;

    hDumpFile = CreateFile( szFileName,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_ALWAYS,
                            0,
                            NULL );

    if ( hDumpFile == INVALID_HANDLE_VALUE )
    {
        dwStatus = GetLastError ();
        ClRtlLogPrint(LOG_CRITICAL, "[RM] GenerateMemoryDump: Could not create file %1!ws!, Status=%2!u!\n",
                      szFileName,
                      dwStatus);                              
        goto FnExit;
    }
    
    mdumpExceptionInfo.ThreadId = GetCurrentThreadId ();
    mdumpExceptionInfo.ExceptionPointers = pExceptionInfo;
    mdumpExceptionInfo.ClientPointers = TRUE;

    ClRtlLogPrint(LOG_NOISE, "[RM] GenerateMemoryDump: Start memory dump to file %1!ws!\n",
                  szFileName);                              

    if( !_MiniDumpWriteDump( GetCurrentProcess(), 
                             GetCurrentProcessId(), 
                             hDumpFile, 
                             MiniDumpNormal | MiniDumpWithHandleData,
                             &mdumpExceptionInfo,
                             NULL,
                             NULL ) )
    {
        dwStatus = GetLastError ();
        ClRtlLogPrint(LOG_CRITICAL, "[CS] GenerateMemoryDump: Could not write dump, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }
    
FnExit:
    if ( hDumpFile != INVALID_HANDLE_VALUE ) CloseHandle ( hDumpFile );

    ClRtlLogPrint(LOG_NOISE, "[RM] GenerateMemoryDump: Memory dump status %1!u!\n",
                  dwStatus);                              

    return;
}// GenerateMemoryDump

void GenerateExceptionReport(
    IN PEXCEPTION_POINTERS pExceptionInfo)
/*++

Routine Description:

    Top level exception handler for the cluster service process.
    Currently this just exits immediately and assumes that the
    cluster proxy will notice and restart us as appropriate.

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{    
    PCONTEXT pCtxt = pExceptionInfo->ContextRecord;

    if ( !InitImagehlpFunctions() )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Dbghelp.dll or its exported procs not found\r\n");

#if 0 
        #ifdef _M_IX86  // Intel Only!
        // Walk the stack using x86 specific code
        IntelStackWalk( pCtx );
        #endif
#endif        

        return;
    }

    GenerateMemoryDump ( pExceptionInfo );

    ImagehlpStackWalk( pCtxt );

    _SymCleanup( GetCurrentProcess() );

}


BOOL InitImagehlpFunctions()
/*++

Routine Description:

    Initializes the imagehlp functions/data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HMODULE hModImagehlp = LoadLibraryW( L"DBGHELP.DLL" );

    
    if ( !hModImagehlp )
        return FALSE;

    _SymInitialize = (SYMINITIALIZEPROC)GetProcAddress( hModImagehlp,
                                                        "SymInitialize" );
    if ( !_SymInitialize )
        return FALSE;

    _SymCleanup = (SYMCLEANUPPROC)GetProcAddress( hModImagehlp, "SymCleanup" );
    if ( !_SymCleanup )
        return FALSE;

    _StackWalk = (STACKWALKPROC)GetProcAddress( hModImagehlp, "StackWalk" );
    if ( !_StackWalk )
        return FALSE;

    _SymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC)
                        GetProcAddress( hModImagehlp, "SymFunctionTableAccess" );

    if ( !_SymFunctionTableAccess )
        return FALSE;

    _SymGetModuleBase=(SYMGETMODULEBASEPROC)GetProcAddress( hModImagehlp,
                                                            "SymGetModuleBase");
                                                            
    if ( !_SymGetModuleBase )
        return FALSE;

    _SymGetSymFromAddr=(SYMGETSYMFROMADDRPROC)GetProcAddress( hModImagehlp,
                                                "SymGetSymFromAddr" );
    if ( !_SymGetSymFromAddr )
        return FALSE;

    _SymFromAddr=(SYMFROMADDRPROC)GetProcAddress( hModImagehlp,
                                                "SymFromAddr" );
    if ( !_SymFromAddr )
        return FALSE;

    _MiniDumpWriteDump = (MINIDUMPWRITEDUMP)GetProcAddress( hModImagehlp,
                                                        "MiniDumpWriteDump" );
    if ( !_MiniDumpWriteDump )
        return FALSE;

    // Set the current directory so that the symbol handler functions will pick up any PDBs that happen to be in
    // the cluster dir.  
    // No need to save and restore the previous current dir since we will be dying after this.
    {
        WCHAR currentDir[ MAX_PATH + 1 ];
        UINT  windirLen = GetWindowsDirectory( currentDir, MAX_PATH );
        if ( windirLen != 0 && windirLen <= MAX_PATH - wcslen( L"\\Cluster" ) )
        {
            wcscat( currentDir, L"\\Cluster" );
            if ( !SetCurrentDirectory( currentDir ))
            {
                ClRtlLogPrint( LOG_CRITICAL, "Failed to set current directory to %1!ws!, error %2!d!\n", currentDir, GetLastError() );
            }
        }
    }

    if ( !_SymInitialize( GetCurrentProcess(), NULL, TRUE ) )
        return FALSE;

    return TRUE;        
} // InitImagehlpFunctions


void ImagehlpStackWalk(
    IN PCONTEXT pContext )
/*++

Routine Description:

    Walks the stack, and writes the results to the report file 

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    STACKFRAME      sf;
    BYTE            symbolBuffer[ sizeof(IMAGEHLP_SYMBOL) + 512 ];
    PSYMBOL_INFO    pSymbol = (PSYMBOL_INFO)symbolBuffer;
    DWORD64         symDisplacement = 0;      // Displacement of the input address,
                                        // relative to the start of the symbol
    DWORD       dwMachineType;                                        
    UCHAR       printBuffer[512];
    DWORD       nextPrtBufChar;

    ClRtlLogPrint(LOG_CRITICAL, 
                    "[RM] CallStack:\n");

    ClRtlLogPrint(LOG_CRITICAL, 
                    "[RM] Frame     Address\n");

    // Could use SymSetOptions here to add the SYMOPT_DEFERRED_LOADS flag

    memset( &sf, 0, sizeof(sf) );

#if defined (_M_IX86)
    dwMachineType          = IMAGE_FILE_MACHINE_I386;
    sf.AddrPC.Offset       = pContext->Eip;
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = pContext->Esp;
    sf.AddrStack.Mode      = AddrModeFlat;
    sf.AddrFrame.Offset    = pContext->Ebp;
    sf.AddrFrame.Mode      = AddrModeFlat;

#elif defined(_M_AMD64)
    dwMachineType          = IMAGE_FILE_MACHINE_AMD64;
    sf.AddrPC.Offset       = pContext->Rip;
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = pContext->Rsp;
    sf.AddrStack.Mode      = AddrModeFlat;

#elif defined(_M_IA64)
    dwMachineType          = IMAGE_FILE_MACHINE_IA64;
    sf.AddrPC.Offset       = pContext->StIIP;
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = pContext->IntSp;
    sf.AddrStack.Mode      = AddrModeFlat;

#else
#error "No Target Architecture"
#endif // defined(_M_IX86)

while ( 1 )
    {
        if ( ! _StackWalk(  dwMachineType,
                            GetCurrentProcess(),
                            GetCurrentThread(),
                            &sf,
                            pContext,
                            0,
                            _SymFunctionTableAccess,
                            _SymGetModuleBase,
                            0 ) )
               break;
                            
        if ( 0 == sf.AddrFrame.Offset ) // Basic sanity check to make sure
            break;                      // the frame is OK.  Bail if not.

        nextPrtBufChar = _snprintf(printBuffer,
                                   sizeof(printBuffer),
                                   "     %p  %p  ",
                                   sf.AddrFrame.Offset, sf.AddrPC.Offset );

        // IMAGEHLP is wacky, and requires you to pass in a pointer to an
        // IMAGEHLP_SYMBOL structure.  The problem is that this structure is
        // variable length.  That is, you determine how big the structure is
        // at runtime.  This means that you can't use sizeof(struct).
        // So...make a buffer that's big enough, and make a pointer
        // to the buffer.  We also need to initialize not one, but TWO
        // members of the structure before it can be used.

        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
        pSymbol->MaxNameLen = 512;

        
        if ( _SymFromAddr(GetCurrentProcess(), sf.AddrPC.Offset,
                                &symDisplacement, pSymbol) )
        {
            sprintf(printBuffer+nextPrtBufChar,
                      "%hs+%p\n", 
                      pSymbol->Name, symDisplacement);
            
        }
        else    // No symbol found.  Print out the logical address instead.
        {
            WCHAR szModule[MAX_PATH] = L"";
            DWORD section = 0;
            ULONG_PTR offset = 0;

            GetLogicalAddress(  (PVOID)sf.AddrPC.Offset,
                                szModule, sizeof(szModule)/sizeof(WCHAR), 
                                &section, &offset );

            sprintf(printBuffer+nextPrtBufChar,
                      "%04X:%08p %S\n",
                      section, offset, szModule );
        }

        
        ClRtlLogPrint(LOG_CRITICAL, "%1!hs!", printBuffer);
    }
}


BOOL GetLogicalAddress(
        IN PVOID addr, 
        OUT LPWSTR szModule, 
        IN DWORD len, 
        OUT LPDWORD section, 
        OUT PULONG_PTR offset )
/*++

Routine Description:

    Given a linear address, locates the module, section, and offset containing  
    that address.                                                               
    Note: the szModule paramater buffer is an output buffer of length specified 
    by the len parameter (in characters!)                                       

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    MEMORY_BASIC_INFORMATION mbi;
    ULONG_PTR hMod;
    // Point to the DOS header in memory
    PIMAGE_DOS_HEADER pDosHdr;
    // From the DOS header, find the NT (PE) header
    PIMAGE_NT_HEADERS pNtHdr;
    PIMAGE_SECTION_HEADER pSection;
    ULONG_PTR rva ;
    int   i;
    
    if ( !VirtualQuery( addr, &mbi, sizeof(mbi) ) )
        return FALSE;

    hMod = (ULONG_PTR)mbi.AllocationBase;

    if ( !GetModuleFileName( (HMODULE)hMod, szModule, len ) )
        return FALSE;

    rva = (ULONG_PTR)addr - hMod; // RVA is offset from module load address

    pDosHdr =  (PIMAGE_DOS_HEADER)hMod;
    pNtHdr = (PIMAGE_NT_HEADERS)(hMod + pDosHdr->e_lfanew);
    pSection = IMAGE_FIRST_SECTION( pNtHdr );
    
    // Iterate through the section table, looking for the one that encompasses
    // the linear address.
    for ( i = 0; i < pNtHdr->FileHeader.NumberOfSections;
            i++, pSection++ )
    {
        ULONG_PTR sectionStart = pSection->VirtualAddress;
        ULONG_PTR sectionEnd = sectionStart
                    + max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);


        // Is the address in this section???
        if ( (rva >= sectionStart) && (rva <= sectionEnd) )
        {
            // Yes, address is in the section.  Calculate section and offset,
            // and store in the "section" & "offset" params, which were
            // passed by reference.
            *section = i+1;
            *offset = rva - sectionStart;
            return TRUE;
        }
    }

    return FALSE;   // Should never get here!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\reslist.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    reslist.c

Abstract:

    Implements the management of the resource list. This includes
    adding resources to the list and deleting them from the list.

Author:

    John Vert (jvert) 1-Dec-1995

Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support
--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "resmonp.h"
#include "stdio.h"      //RNGBUG - remove all of these in all .c files

#define RESMON_MODULE RESMON_MODULE_RESLIST

DWORD   RmpLogLevel = LOG_ERROR;

//
// Function prototypes local to this module
//
BOOL
RmpChkdskNotRunning(
    IN PRESOURCE Resource
    );



DWORD
RmpSetResourceStatus(
    IN RESOURCE_HANDLE ResourceHandle,
    IN PRESOURCE_STATUS ResourceStatus
    )
/*++

Routine Description:

    Update the status of a resource.

Arguments:

    ResourceHandle - Handle (pointer to) the resource to update.

    ResourceStatus - Pointer to a resource status structure for update.

Returns:

    ResourceExitStateContinue - if the thread does not have to terminate.
    ResourceExitStateTerminate - if the thread must terminat now.

--*/

{
    BOOL                bSuccess;
    DWORD               status;
    PRESOURCE           resource = (PRESOURCE)ResourceHandle;
    DWORD               retryCount;
    PPOLL_EVENT_LIST    eventList;
    HANDLE              OnlineEvent;
    BOOL                fAddPollEvent = FALSE;       

    if ( ResourceHandle == NULL || ResourceStatus == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }
    
    retryCount = ( resource->PendingTimeout/100 >= 600 ) ? 
        ( resource->PendingTimeout/100 - 400 ):200;
    //
    // Check if we're only updating the checkpoint value. If so, then
    // don't use any locks.
    //
    if ( ResourceStatus->ResourceState >= ClusterResourcePending ) {
        resource->CheckPoint = ResourceStatus->CheckPoint;
        return ResourceExitStateContinue;
    }

    //
    // Acquire the lock first to prevent race conditions if the resource
    // DLL manages to set resource status from a different thread before
    // returning PENDING from its online/offline entrypoint.
    //
    eventList = (PPOLL_EVENT_LIST) resource->EventList;

    status = TryEnterCriticalSection( &eventList->ListLock );
    while ( !status &&
            retryCount-- ) {
        //
        //  Chittur Subbaraman (chitturs) - 10/18/99
        //  
        //  Comment out this unprotected check. The same check is done
        //  protected further downstream. Unprotected checking could
        //  cause a resource to attempt to enter here even before
        //  the timer event has been created by s_RmOnlineResource or
        //  s_RmOfflineResource and in such a case the resource will
        //  not be able to set the resource status. This will cause
        //  the resmon to wrongly time out the resource.
        //
#if 0
        //
        // Check if the resource is shutting down as we're waiting.
        //
        if ( resource->TimerEvent == NULL ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] Resource (%1!ws!) TimerEvent became NULL, state (%2!d!)!\n",
                          resource->ResourceName,
                          resource->State);

            if ( resource->OnlineEvent ) {
                CloseHandle( resource->OnlineEvent );
                resource->OnlineEvent = NULL;
            }

            return ResourceExitStateTerminate;
        }
#endif
        //
        //  Chittur Subbaraman (chitturs) - 12/8/99
        //
        //  Check if the "Terminate" or "Close" entry point has been
        //  called for this resource. If so, then no need to set the
        //  resource status. Moreover, those entry points could be
        //  blocked waiting for the pending thread to terminate and
        //  if the pending thread is stuck looping here waiting for 
        //  the lock held by the former thread, we are in a deadlock-like 
        //  situation. [Note that the fact that you are at this point 
        //  means that it is not the "Terminate"/"Close" itself calling 
        //  this function since the eventlist lock can be obtained since 
        //  it was obtained by resmon prior to calling the resdll entry.]
        //
        if( ( resource->dwEntryPoint ) & 
            ( RESDLL_ENTRY_TERMINATE | RESDLL_ENTRY_CLOSE ) )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] RmpSetResourceStatus: Resource <%1!ws!> not setting status since "
                          "%2!ws! is called, lock owner=0x%3!x!, resource=%4!ws!, state=%5!u!...\n",
                          resource->ResourceName,
                          (resource->dwEntryPoint == RESDLL_ENTRY_TERMINATE) ? 
                          L"Terminate":L"Close",
                          eventList->ListLock.OwningThread,
                          (eventList->LockOwnerResource != NULL) ? eventList->LockOwnerResource->ResourceName:L"Unknown resource",
                          eventList->MonitorState);                      
            if ( resource->OnlineEvent ) {
                CloseHandle( resource->OnlineEvent );
                resource->OnlineEvent = NULL;
            }
            return ResourceExitStateTerminate;       
        }
        
        Sleep(100);     // Delay a little
        status = TryEnterCriticalSection( &eventList->ListLock );
    }

    //
    // If we couldn't proceed, we're stuck. Just return now.
    //
    if ( !status ) {
        //
        // We're unsynchronized, but clean up a bit.
        //
        if ( resource->OnlineEvent ) {
            CloseHandle( resource->OnlineEvent );
            resource->OnlineEvent = NULL;
        }
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] Resource (%1!ws!) Failed TryEnterCriticalSection after too many "
                      "tries, state=%2!d!, lock owner=%3!x!, resource=%4!ws!, state=%5!u!\n",
                      resource->ResourceName,
                      resource->State,
                      eventList->ListLock.OwningThread,
                      (eventList->LockOwnerResource != NULL) ? eventList->LockOwnerResource->ResourceName:L"Unknown resource",
                      eventList->MonitorState);                      
        //
        // SS: Why do we let the resource continue ?
        //
        return ResourceExitStateContinue;
    }

    //
    // SS: If the timer thread has timed us out, there is no
    // point in continuing.
    //
    // First check if the resource is shutting down.
    //
    if ( resource->TimerEvent == NULL ) {
        //
        // Just return asking the resource dll to terminate, but clean 
        // up a bit.
        //
        if ( resource->OnlineEvent ) {
            CloseHandle( resource->OnlineEvent );
            resource->OnlineEvent = NULL;
        }
        ReleaseEventListLock( eventList );
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] Timer Event is NULL when resource (%1!ws!) tries to set state=%2!d! !\n",
                      resource->ResourceName,
                      resource->State);
        return ResourceExitStateTerminate;
    }

    //
    // Synchronize with the online thread.
    //
    if ( resource->OnlineEvent != NULL ) {
        OnlineEvent = resource->OnlineEvent;
        resource->OnlineEvent = NULL;
        ReleaseEventListLock( eventList );
        WaitForSingleObject( OnlineEvent, INFINITE );
        AcquireEventListLock( eventList );
        CloseHandle( OnlineEvent );
    }

    //
    // If the state of the resource is not pending, then return immediately
    //

    if ( resource->State < ClusterResourcePending ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] Resource (%1!ws!) attempted to set status while state was not pending (%2!d!)!\n",
                      resource->ResourceName,
                      resource->State);
        CL_LOGFAILURE(ERROR_INVALID_SERVER_STATE);
        ReleaseEventListLock( eventList );
        return ResourceExitStateContinue;
    }

    resource->State = ResourceStatus->ResourceState;
    // resource->WaitHint = ResourceStatus->WaitHint;
    resource->CheckPoint = ResourceStatus->CheckPoint;

    //
    // If the state has stabilized, stop the timer thread.
    //

    if ( resource->State < ClusterResourcePending ) {
        //
        // Add any events to our eventlist if the resource is reporting its state as online.
        //
        if ( ResourceStatus->EventHandle ) {
            if ( resource->State == ClusterResourceOnline ) {
                if ( (ULONG_PTR)ResourceStatus->EventHandle > 0x2000 ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                                  "[RM] SetResourceStatus: Resource <%1!ws!> attempted to set a bogus event %2!lx!.\n",
                                  resource->ResourceName,
                                  ResourceStatus->EventHandle );
                } else {
                    //
                    //  Mark that you need to add a poll event
                    //
                    fAddPollEvent = TRUE;
                }
            } else {
                ClRtlLogPrint(LOG_ERROR,
                              "[RM] RmpSetResourceStatus: Resource '%1!ws!' supplies event handle 0x%2!08lx! while reporting state %3!u!...\n",
                              resource->ResourceName,
                              ResourceStatus->EventHandle,
                              resource->State );
            }
        }
        
        //
        // The event may have been closed by the timer thread
        // if this is happening too late, ignore the error.
        //
        if( resource->TimerEvent != NULL )
        {
            bSuccess = SetEvent( resource->TimerEvent );
            if ( !bSuccess )
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[RM] RmpSetResourceStatus, Error %1!u! calling SetEvent to wake timer thread\n",
                              GetLastError());
        }
        //
        // Chittur Subbaraman (chitturs) - 1/12/99
        //
        // Post a notification to the cluster service regarding a state
        // change AFTER sending a signal to a timer. This will reduce
        // the probability of the cluster service sending in another
        // request before the timer thread had a chance to close out
        // the event handle.
        //
        ClRtlLogPrint(LOG_NOISE,
                      "[RM] RmpSetResourceStatus, Posting state %2!u! notification for resource <%1!ws!>\n",
                      resource->ResourceName,
                      resource->State);

        if ( fAddPollEvent == FALSE ) RmpPostNotify( resource, NotifyResourceStateChange );
    }

    ReleaseEventListLock( eventList );

    if ( fAddPollEvent )
    {
        ClRtlLogPrint(LOG_NOISE, "[RM] RmpSetResourceStatus: Adding event handle 0x%1!08lx! for resource %2!ws!\n",
                      ResourceStatus->EventHandle,
                      resource->ResourceName);

        status = RmpAddPollEvent( eventList,
                                  ResourceStatus->EventHandle,
                                  resource );

        if ( status != ERROR_SUCCESS ) {
            resource->State = ClusterResourceFailed;
            ClRtlLogPrint(LOG_CRITICAL, "[RM] RmpSetResourceStatus: Failed to add event to list, Status=%1!u!\n",
                         status);
        }
        //
        // Signal poller that event list changed.
        //
        if ( status == ERROR_SUCCESS ) {
            RmpSignalPoller( eventList );
        }

        RmpPostNotify( resource, NotifyResourceStateChange );        
    } // if

    return ResourceExitStateContinue;
} // RmpSetResourceStatus



VOID
RmpLogEvent(
    IN RESOURCE_HANDLE ResourceHandle,
    IN LOG_LEVEL LogLevel,
    IN LPCWSTR FormatString,
    ...
    )
/*++

Routine Description:

    Log an event for the given resource.

Arguments:

    ResourceHandle - Handle (pointer to) the resource to update.

    LogLevel - Supplies the level of this log event.

    FormatString - Supplies a format string for this log message.

Returns:

    None.

--*/

{
    LPWSTR headerBuffer;
    LPWSTR messageBuffer;
    DWORD bufferLength;
    PRESOURCE resource = (PRESOURCE)ResourceHandle;
    PVOID argArray[2];
    HKEY resKey;
    DWORD status;
    DWORD valueType;
#ifdef SLOW_RMP_LOG_EVENT
    WCHAR resourceName[128];
#endif
    va_list argList;
    ULONG rtlLogLevel;

    if ( FormatString == NULL ) {
        ClRtlLogPrint(LOG_UNUSUAL, "[RM] %1!hs! Invalid parameter.\n", __FUNCTION__ );
        return;
    }

    //
    // map resmon log levels to those used by ClRtlLogPrint
    //
    switch ( LogLevel ) {
    case LOG_INFORMATION:
        rtlLogLevel = LOG_NOISE;
        break;

    case LOG_WARNING:
        rtlLogLevel = LOG_UNUSUAL;
        break;

    case LOG_ERROR:
    case LOG_SEVERE:    
    default:
        rtlLogLevel = LOG_CRITICAL;
    }

    if ( (resource == NULL) ||
         (resource->Signature != RESOURCE_SIGNATURE) ) {

        LPWSTR resourcePrefix = (LPWSTR)ResourceHandle;
        //
        // Some resource DLLs have threads that do some
        // work on behalf of this resource DLL, but has no
        // relation to a particular resource. Thus they cannot
        // provide a resource handle, necessary to log an event.
        //
        // The following hack allows them to supply a string
        // to be printed before the message.
        //
        // This string should start with unicode 'r' and 't'
        // characters. "rt" is interpreted as a signature and is not printed.
        //
        if (resourcePrefix &&
            resourcePrefix[0] == L'r' && 
            resourcePrefix[1] == L't') 
        {
            resourcePrefix += 2; // skip the signature
        } else {
            resourcePrefix = L"<Unknown Resource>";
            //CL_LOGFAILURE((DWORD)resource);
        }

        va_start( argList, FormatString );

        //
        // Print out the actual message
        //
        if ( bufferLength = FormatMessageW(FORMAT_MESSAGE_FROM_STRING |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                           FormatString,
                                           0,
                                           0,
                                           (LPWSTR)&messageBuffer,
                                           0,
                                           &argList) )
        {
            ClRtlLogPrint( rtlLogLevel, "%1!ws!: %2!ws!", resourcePrefix, messageBuffer);
            LocalFree(messageBuffer);
        }
        va_end( argList );

        return;
    }
    //CL_ASSERT(resource->Signature == RESOURCE_SIGNATURE);

#ifdef SLOW_RMP_LOG_EVENT
    status = ClusterRegOpenKey( RmpResourcesKey,
                                resource->ResourceId,
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        return;
    }

    bufferLength = 128;
    status = ClusterRegQueryValue( resKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &valueType,
                                   (LPBYTE)&resourceName,
                                   &bufferLength );

    ClusterRegCloseKey( resKey );

    if ( status != ERROR_SUCCESS ) {
        return;
    }
#endif

    //
    // Print out the prefix string
    //
    argArray[0] = resource->ResourceType;
#ifdef SLOW_RMP_LOG_EVENT
    argArray[1] = resourceName;
#else
    argArray[1] = resource->ResourceName;
#endif

    if ( bufferLength = FormatMessageW(FORMAT_MESSAGE_FROM_STRING |
                                       FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                       FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       L"%1!ws! <%2!ws!>: ",
                                       0,
                                       0,
                                       (LPWSTR)&headerBuffer,
                                       0,
                                       (va_list*)&argArray) ) {
    } else {
        return;
    }

    va_start( argList, FormatString );

    //
    // Print out the actual message
    //
    if ( bufferLength = FormatMessageW(FORMAT_MESSAGE_FROM_STRING |
                                       FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                       FormatString,
                                       0,
                                       0,
                                       (LPWSTR)&messageBuffer,
                                       0,
                                       &argList) )
    {
        ClRtlLogPrint( rtlLogLevel, "%1!ws!%2!ws!", headerBuffer, messageBuffer);
        LocalFree(messageBuffer);
    }
    LocalFree(headerBuffer);
    va_end( argList );

} // RmpLogEvent



VOID
RmpLostQuorumResource(
    IN RESOURCE_HANDLE ResourceHandle
    )
/*++

Routine Description:

    Stop the cluster service... since we lost our quorum resource.

Arguments:

    ResourceHandle - Handle (pointer to) the resource to update.

Returns:

    None.

--*/

{
    PRESOURCE resource = (PRESOURCE)ResourceHandle;

    //
    // Kill the cluster service alone. Take no action for this process since the main
    // thread in resmon.c would detect the termination of the cluster service process
    // and cleanly shut down hosted resources and the process itself.
    //
    TerminateProcess( RmpClusterProcess, 1 );

    ClRtlLogPrint( LOG_CRITICAL, "[RM] LostQuorumResource, cluster service terminated...\n");

    return;

} // RmpLostQuorumResource


BOOL
RmpChkdskNotRunning(
    IN PRESOURCE Resource
    )

/*++

Routine Description:

    If this is a storage class resource, make sure CHKDSK is not running.

Arguments:

    Resource - A pointer to the resource to check.

Returns:

    TRUE - if this is not a STORAGE resource or CHKDSK is not running.
    FALSE - if this is a STORAGE resource AND CHKDSK is running.

--*/

{
    PSYSTEM_PROCESS_INFORMATION processInfo;
    NTSTATUS        ntStatus;
    DWORD           status;
    DWORD           size = 4096;
    ANSI_STRING     pname;
    PCHAR           commonBuffer = NULL;
    PCHAR           ptr;
    DWORD           totalOffset = 0;
    CLUS_RESOURCE_CLASS_INFO resClassInfo;
    DWORD           bytesReturned;

#if 1
    //
    // Get the class of resource... if not a STORAGE class then fail now.
    //
    if ( Resource->dwType == RESMON_TYPE_DLL ) {
        status = (Resource->pResourceTypeControl)( Resource->Id,
                                    CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                                    NULL,
                                    0,
                                    &resClassInfo,
                                    sizeof(resClassInfo),
                                    &bytesReturned );
    } else {
        HRESULT hr ;
        VARIANT vtIn, vtOut ;
        SAFEARRAY sfIn = {1, 0, 1, 0, NULL, {0, 0} } ;
        SAFEARRAY sfOut  = {1,  FADF_FIXEDSIZE, 1, 0, &resClassInfo, {sizeof(resClassInfo), 0} } ;
        SAFEARRAY *psfOut = &sfOut ;

        vtIn.vt = VT_ARRAY | VT_UI1 ;
        vtOut.vt = VT_ARRAY | VT_UI1 | VT_BYREF ;

        vtIn.parray = &sfIn ;
        vtOut.pparray = &psfOut ;

        hr = IClusterResControl_ResourceControl (
                Resource->pClusterResControl,
                (OLERESID)Resource->Id,
                (long)CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                &vtIn,
                &vtOut,
                (long *)&bytesReturned,
                &status);

        if (FAILED(hr)) {
            CL_LOGFAILURE(hr); // Use the default processing
            status = ERROR_INVALID_FUNCTION;
        }
    }

    if ( (status != ERROR_SUCCESS) ||
         (resClassInfo.rc != CLUS_RESCLASS_STORAGE) ) {
        return TRUE;            // fail now
    }
#endif

retry:

    RmpFree( commonBuffer );

    commonBuffer = RmpAlloc( size );
    if ( !commonBuffer ) {
        return TRUE;           // fail now
    }

    ntStatus = NtQuerySystemInformation(
                    SystemProcessInformation,
                    commonBuffer,
                    size,
                    NULL );

    if ( ntStatus == STATUS_INFO_LENGTH_MISMATCH ) {
        size += 4096;
        goto retry;
    }

    if ( !NT_SUCCESS(ntStatus) ) {
        return TRUE;           // fail now
    }

    processInfo = (PSYSTEM_PROCESS_INFORMATION)commonBuffer;
    while ( TRUE ) {
        if ( processInfo->ImageName.Buffer ) {
            if ( ( ntStatus = RtlUnicodeStringToAnsiString( &pname,
                                               &processInfo->ImageName,
                                               TRUE ) ) != STATUS_SUCCESS ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[RM] ChkdskNotRunning: Unable to convert Unicode string to Ansi, status = 0x%lx...\n",
                              ntStatus);
                break;
            }
            
            ptr = strrchr( pname.Buffer, '\\' );
            if ( ptr ) {
                ptr++;
            } else {
                ptr = pname.Buffer;
            }
            if ( lstrcmpiA( ptr, "CHKDSK.EXE" ) == 0 ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[RM] ChkdskNotRunning: Found process %1!ws!.\n",
                              processInfo->ImageName.Buffer );
                RmpFree( pname.Buffer );
                RmpFree( commonBuffer );
                return FALSE;    // chkdsk is running
            }
            RmpFree( pname.Buffer );
        }

        if ( processInfo->NextEntryOffset == 0 ) break;
        totalOffset += processInfo->NextEntryOffset;
        processInfo = (PSYSTEM_PROCESS_INFORMATION)&commonBuffer[totalOffset];
    }

    RmpFree( commonBuffer );
    return TRUE;            // CHKDSK is not running

} // RmpChkdskNotRunning



DWORD
RmpTimerThread(
    IN LPVOID Context
    )
/*++

Routine Description:

    Thread to wait on transition of a resource from pending to a stable state.

Arguments:

    Context - A pointer to the resource being timed.

Returns:

    Win32 error code.

--*/

{
    PRESOURCE resource = (PRESOURCE)Context;
    DWORD   status;
    HANDLE  timerEvent;
    DWORD   prevCheckPoint;

    CL_ASSERT( resource != NULL );

    timerEvent = resource->TimerEvent;
    if ( !timerEvent ) {
        return(ERROR_SUCCESS);
    }

    //
    // Loop waiting for resource to complete pending operation or to
    // shutdown processing.
    //
    while ( timerEvent ) {
        prevCheckPoint = resource->CheckPoint;

        status = WaitForSingleObject( timerEvent,
                                      resource->PendingTimeout );

        //
        // If we were asked to stop, then exit quietly.
        //
        if ( status != WAIT_TIMEOUT ) {
            //
            // The thread that cleans the timer event must close the handle.
            //
            CloseHandle(timerEvent);
            resource->TimerEvent = NULL;
            return(ERROR_SUCCESS);
        }

        //
        // Check if the resource has not made forward progress... if not,
        // then let break out now.
        //
        // Also if this is a storage class resource make sure that
        // CHKDSK is not running.
        //
        if ( (prevCheckPoint == resource->CheckPoint) &&
              RmpChkdskNotRunning( resource ) ) {
            break;
        }

        ClRtlLogPrint(LOG_NOISE,
                      "[RM] RmpTimerThread: Giving a reprieve for resource %1!ws!...\n",
                      resource->ResourceName);
    }

    //
    // Indicate that this resource failed!
    //
    AcquireEventListLock( (PPOLL_EVENT_LIST)resource->EventList );
    if ( resource->TimerEvent != NULL ) {

        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpTimerThread: Resource %1!ws! pending timed out, CP %2!u! "
                      "- setting state to failed.\n",
                      resource->ResourceName,
                      resource->CheckPoint);

        CloseHandle(resource->TimerEvent);
        resource->TimerEvent = NULL;
        resource->State = ClusterResourceFailed;
        //
        // Log an event
        //
        status = ERROR_TIMEOUT;
        ClusterLogEvent1(LOG_CRITICAL,
                         LOG_CURRENT_MODULE,
                         __FILE__,
                         __LINE__,
                         RMON_RESOURCE_TIMEOUT,
                         sizeof(status),
                         &status,
                         resource->ResourceName);
        //
        //  Chittur Subbaraman (chitturs) - 4/5/99
        //
        //  Since the resource has failed, there is no point in having
        //  the OnlineEvent hanging around. If the OnlineEvent is not
        //  closed out, then you cannot call s_RmOnlineResource or
        //  s_RmOfflineResource.
        //
        if ( resource->OnlineEvent != NULL ) {
            CloseHandle( resource->OnlineEvent );
            resource->OnlineEvent = NULL;
        }    
        RmpPostNotify( resource, NotifyResourceStateChange );
    }
    ReleaseEventListLock( (PPOLL_EVENT_LIST)resource->EventList );


    return(ERROR_SUCCESS);

} // RmpTimerThread



DWORD
RmpOfflineResource(
    IN RESID ResourceId,
    IN BOOL Shutdown,
    OUT DWORD *pdwState
    )

/*++

Routine Description:

    Brings the specified resource into the offline state.

Arguments:

    ResourceId - Supplies the resource to be brought online.

    Shutdown - Specifies whether the resource is to be shutdown gracefully
        TRUE - resource will be shutdown gracefully
        FALSE - resource will be immediately taken offline

    pdwState - the new resource state is returned in here.

Return Value:

    The new state of the resource.

Notes:

    The resource's eventlist lock must NOT be held.

--*/

{
    DWORD                   status=ERROR_SUCCESS;
    BOOL                    success;
    PRESOURCE               Resource;
    HANDLE                  timerThread;
    DWORD                   threadId;
    DWORD                   loopCount;
    BOOL                    fLockAcquired;
    PRM_DUE_TIME_ENTRY      pDueTimeEntry = NULL;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);
    *pdwState = Resource->State;

    //if this is a graceful close,create the online/offline
    //event such that if a resource calls rmpsetresourcestatus
    //soon after online for that resource is called and before
    //the timer thread/event  is even created then we wont have
    //an event leak and an abadoned thread
    if (Shutdown)
    {
        //
        // We should not be in a Pending state.
        //
        if ( Resource->State > ClusterResourcePending )
        {
            return(ERROR_INVALID_STATE);
        }

        //
        // Create an event to allow the SetResourceStatus callback to synchronize
        // execution with this thread.
        //
        if ( Resource->OnlineEvent )
        {
            return(ERROR_NOT_READY);
        }

        Resource->OnlineEvent = CreateEvent( NULL,
                                             FALSE,
                                             FALSE,
                                             NULL );
        if ( Resource->OnlineEvent == NULL )
        {
            return(GetLastError());
        }
    }

    //
    // Lock the EventList Lock, insert the
    // resource into the list, and take the resource offline.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );


    //
    // Stop any previous timer threads. Should this be done before the lock
    // is held?
    //

    if ( Resource->TimerEvent != NULL ) {
        success = SetEvent( Resource->TimerEvent );
    }

    //
    // Update shared state to indicate we are taking a resource offline
    //
    RmpSetMonitorState(RmonOfflineResource, Resource);

    //
    // If we have an error signal event, then remove it from our lists.
    //
    if ( Resource->EventHandle ) {
        RmpRemovePollEvent( Resource->EventList, Resource->EventHandle );
    }

    //
    // Call Offline entrypoint.
    //
    if ( Shutdown )
    {

        CL_ASSERT( (Resource->State < ClusterResourcePending) );

        //
        //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
        //  you remove the entry after you finish the entry point call, else you will kill
        //  this process on a FALSE deadlock positive.
        //
        pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                       Resource->ResourceType,
                                                       Resource->ResourceName,
                                                       L"Offline" );

        try {
#ifdef COMRES
            status = RESMON_OFFLINE (Resource) ;
#else
            status = (Resource->Offline)(Resource->Id);
#endif
        } except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
        }

        RmpRemoveDeadlockMonitorList( pDueTimeEntry );
        
        //
        // If the Resource DLL returns pending, then start a timer.
        //
        if (status == ERROR_SUCCESS) {
            //close the event
            SetEvent( Resource->OnlineEvent );
            CloseHandle( Resource->OnlineEvent );
            Resource->OnlineEvent = NULL;
            Resource->State = ClusterResourceOffline;

        }
        else if ( status == ERROR_IO_PENDING ) {
            CL_ASSERT(Resource->TimerEvent == NULL );
            Resource->TimerEvent = CreateEvent( NULL,
                                                FALSE,
                                                FALSE,
                                                NULL );
            if ( Resource->TimerEvent == NULL ) {
                CL_UNEXPECTED_ERROR(status = GetLastError());
            } else {
                timerThread = CreateThread( NULL,
                                            0,
                                            RmpTimerThread,
                                            Resource,
                                            0,
                                            &threadId );
                if ( timerThread == NULL ) {
                    CL_UNEXPECTED_ERROR(status = GetLastError());
                } else {
                    Resource->State = ClusterResourceOfflinePending;
                    //Resource->WaitHint = PENDING_TIMEOUT;
                    //Resource->CheckPoint = 0;
                    //
                    // Chittur Subbaraman (chitturs) - 1/12/99
                    //
                    // Raise the timer thread priority to highest. This
                    // is necessary to avoid certain cases in which the
                    // timer thread is sluggish to close out the timer event
                    // handle before a second offline. Note that there are
                    // no major performance implications by doing this since
                    // the timer thread is in a wait state most of the time.
                    //
                    if ( !SetThreadPriority( timerThread, THREAD_PRIORITY_HIGHEST ) )
                    {
                        ClRtlLogPrint(LOG_UNUSUAL,
                                      "[RM] RmpOfflineResource:Error setting priority of timer "
                                      "thread for resource %1!ws!\n",
                                      Resource->ResourceName);
                        CL_LOGFAILURE( GetLastError() );
                    }

                    CloseHandle( timerThread );
                }
            }
            Resource->State = ClusterResourceOfflinePending;
            SetEvent(Resource->OnlineEvent);
        }
        else {
            CloseHandle( Resource->OnlineEvent );
            Resource->OnlineEvent = NULL;
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[RM] OfflinelineResource failed, resource %1!ws!, status =  %2!u!.\n",
                          Resource->ResourceName,
                          status);

            ClusterLogEvent1(LOG_CRITICAL,
                             LOG_CURRENT_MODULE,
                             __FILE__,
                             __LINE__,
                             RMON_OFFLINE_FAILED,
                             sizeof(status),
                             &status,
                             Resource->ResourceName);
            Resource->State = ClusterResourceFailed;
        }
    } else {
        Resource->dwEntryPoint = RESDLL_ENTRY_TERMINATE;
        RmpSetMonitorState(RmonTerminateResource, Resource);
        //
        //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
        //  you remove the entry after you finish the entry point call, else you will kill
        //  this process on a FALSE deadlock positive.
        //
        pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                       Resource->ResourceType,
                                                       Resource->ResourceName,
                                                       L"Terminate" );
        try {
#ifdef COMRES
            RESMON_TERMINATE (Resource) ;
#else
            (Resource->Terminate)(Resource->Id);
#endif
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
        RmpSetMonitorState(RmonIdle, Resource);
        RmpRemoveDeadlockMonitorList ( pDueTimeEntry );
        Resource->dwEntryPoint = 0;
        Resource->State = ClusterResourceOffline;
    }

    *pdwState = Resource->State;

    RmpSetMonitorState(RmonIdle, NULL);
    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );

    return(status);

} // RmpOfflineResource



VOID
RmpRemoveResourceList(
    IN PRESOURCE Resource
    )

/*++

Routine Description:

    Removes a resource into the monitoring list.

Arguments:

    Resource - Supplies the resource to be removed from the list.

Return Value:

    None.

--*/

{
    PPOLL_EVENT_LIST EventList = (PPOLL_EVENT_LIST)Resource->EventList;

    AcquireEventListLock( EventList );

    //
    // Make sure it is really in the list.
    //
    CL_ASSERT(Resource->Flags & RESOURCE_INSERTED);
    CL_ASSERT(Resource->ListEntry.Flink->Blink == &Resource->ListEntry);
    CL_ASSERT(Resource->ListEntry.Blink->Flink == &Resource->ListEntry);
    CL_ASSERT(EventList->NumberOfResources);

    RemoveEntryList(&Resource->ListEntry);
    Resource->Flags &= ~RESOURCE_INSERTED;
    --EventList->NumberOfResources;

    ReleaseEventListLock( EventList );

} // RmpRemoveResourceList



DWORD
RmpInsertResourceList(
    IN PRESOURCE Resource,
    IN OPTIONAL PPOLL_EVENT_LIST pPollEventList
    )

/*++

Routine Description:

    Inserts a resource into the monitoring list.

    Each resource is placed in a list along with other resources with the
    same poll interval. The IsAlive and LooksAlive timeouts are adjusted
    so that the IsAlive interval is an even multiple of the LooksAlive interval.
    Thus, the IsAlive poll can simply be done every Nth poll instead of the normal
    LooksAlive poll.

Arguments:

    Resource - Supplies the resource to be added to the list.

    pPollEventList - Supplies the eventlist in which the resource is to
                     be added. Optional.

Return Value:

    None.

--*/

{
    DWORD Temp1, Temp2;
    ULONG i;
    PMONITOR_BUCKET NewBucket;
    PMONITOR_BUCKET Bucket;
    DWORDLONG PollInterval;
    PPOLL_EVENT_LIST EventList;
    PPOLL_EVENT_LIST MinEventList;
    PLIST_ENTRY ListEntry;
    DWORD   dwError = ERROR_SUCCESS;

    CL_ASSERT((Resource->Flags & RESOURCE_INSERTED) == 0);

    //
    // If we have no LooksAlivePollInterval, then poll the IsAlive on every
    // poll interval. Otherwise, poll IsAlive every N LooksAlive poll
    // intervals.
    //
    if ( Resource->LooksAlivePollInterval == 0 ) {
        //
        // Round IsAlivePollInterval up to the system granularity
        //
        Temp1 = Resource->IsAlivePollInterval;
        Temp1 = Temp1 + POLL_GRANULARITY - 1;
        //if this has rolled over
        if (Temp1 < Resource->IsAlivePollInterval)
            Temp1 = 0xFFFFFFFF;
        Temp1 = Temp1 / POLL_GRANULARITY;
        Temp1 = Temp1 * POLL_GRANULARITY;
        Resource->IsAlivePollInterval = Temp1;

        Resource->IsAliveRollover = 1;
        //
        // Convert poll interval from ms to 100ns units
        //
        PollInterval = Resource->IsAlivePollInterval * 10 * 1000;
    } else {
        //
        // First round LooksAlivePollInterval up to the system granularity
        //
        Temp1 = Resource->LooksAlivePollInterval;
        Temp1 = (Temp1 + POLL_GRANULARITY - 1) ;
        //check for rollover
        if (Temp1 < Resource->LooksAlivePollInterval)
            Temp1 = 0xFFFFFFFF;
        Temp1 = Temp1/POLL_GRANULARITY;
        Temp1 = Temp1 * POLL_GRANULARITY;
        Resource->LooksAlivePollInterval = Temp1;

        //
        // Now round IsAlivePollInterval to a multiple of LooksAlivePollInterval
        //
        Temp2 = Resource->IsAlivePollInterval;
        Temp2 = (Temp2 + Temp1 - 1) / Temp1;
        Temp2 = Temp2 * Temp1;
        Resource->IsAlivePollInterval = Temp2;

        Resource->IsAliveRollover = (ULONG)(Temp2 / Temp1);
        CL_ASSERT((Temp2 / Temp1) * Temp1 == Temp2);
        //
        // Convert poll interval from ms to 100ns units
        //
        PollInterval = Resource->LooksAlivePollInterval * 10 * 1000;
    }

    if ( PollInterval > 0xFFFFFFFF ) {
        PollInterval = 0xFFFFFFFF;
    }

    Resource->IsAliveCount = 0;

    //
    // Chittur Subbaraman (chitturs) - 1/30/2000
    //
    // If an eventlist is supplied as parameter, do not attempt to
    // find a new eventlist.
    //
    if( ARGUMENT_PRESENT( pPollEventList ) ) {
        MinEventList = pPollEventList;
        goto skip_eventlist_find;
    }
    //
    // First find the EventList with the fewest number of entries.
    //

    AcquireListLock();

    ListEntry = RmpEventListHead.Flink;
    MinEventList = CONTAINING_RECORD(ListEntry,
                                     POLL_EVENT_LIST,
                                     Next );

    CL_ASSERT( ListEntry != &RmpEventListHead );
    for ( ListEntry = RmpEventListHead.Flink;
          ListEntry != &RmpEventListHead;
          ListEntry = ListEntry->Flink ) {
        EventList = CONTAINING_RECORD( ListEntry, POLL_EVENT_LIST, Next );
        if ( EventList->NumberOfResources < MinEventList->NumberOfResources ) {
            MinEventList = EventList;
        }
    }

    ReleaseListLock();

    if ( MinEventList->NumberOfResources >= MAX_RESOURCES_PER_THREAD ) {
        MinEventList = RmpCreateEventList();
    }
    
skip_eventlist_find:
    if ( MinEventList == NULL ) {
        dwError = GetLastError();
        goto FnExit;
    }

    EventList = MinEventList;

    AcquireEventListLock( EventList );

    Resource->EventList = (PVOID)EventList;

    //
    // Search the list for a bucket with the same period as this resource.
    //
    Bucket = CONTAINING_RECORD(EventList->BucketListHead.Flink,
                               MONITOR_BUCKET,
                               BucketList);

    while (&Bucket->BucketList != &EventList->BucketListHead) {

        if (Bucket->Period == PollInterval) {
            break;
        }
        Bucket = CONTAINING_RECORD(Bucket->BucketList.Flink,
                                   MONITOR_BUCKET,
                                   BucketList);
    }
    if (&Bucket->BucketList == &EventList->BucketListHead) {
        //
        // Need to add a new bucket with this period.
        //
        Bucket = RmpAlloc(sizeof(MONITOR_BUCKET));
        if (Bucket == NULL) {
            CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        }
        InsertTailList(&EventList->BucketListHead, &Bucket->BucketList);
        InitializeListHead(&Bucket->ResourceList);
        GetSystemTimeAsFileTime((LPFILETIME)&Bucket->DueTime);
        Bucket->Period = PollInterval;
        if ( PollInterval == 0 ) {
            // The following constant should be over 136 years
            Bucket->DueTime += (DWORDLONG)((DWORDLONG)1000 * (DWORD) -1);
        } else {
            Bucket->DueTime += Bucket->Period;
        }
        EventList->NumberOfBuckets++;
    }
    InsertHeadList(&Bucket->ResourceList, &Resource->ListEntry);
    Resource->Flags |= RESOURCE_INSERTED;
    ++EventList->NumberOfResources;

    ReleaseEventListLock( EventList );

FnExit:
    return (dwError);

} // RmpInsertResourceList


VOID
RmpRundownResources(
    VOID
    )

/*++

Routine Description:

    Runs down the list of active resources and terminates/closes
    each one.

Arguments:

    None

Return Value:

    None.

--*/

{
    PLIST_ENTRY             ListEntry;
    PMONITOR_BUCKET         Bucket;
    PRESOURCE               Resource;
    PPOLL_EVENT_LIST        EventList;
    DWORD                   i;
    BOOL                    fLockAcquired;
    PRM_DUE_TIME_ENTRY      pDueTimeEntry = NULL;

    AcquireListLock();
    while (!IsListEmpty(&RmpEventListHead)) {
        ListEntry = RemoveHeadList(&RmpEventListHead);
        EventList = CONTAINING_RECORD(ListEntry,
                                      POLL_EVENT_LIST,
                                      Next);

        AcquireEventListLock( EventList );

        //
        // Find all resources on the bucket list and close them.
        //

        while (!IsListEmpty(&EventList->BucketListHead)) {
            ListEntry = RemoveHeadList(&EventList->BucketListHead);
            Bucket = CONTAINING_RECORD(ListEntry,
                                       MONITOR_BUCKET,
                                       BucketList);
            while (!IsListEmpty(&Bucket->ResourceList)) {
                ListEntry = RemoveHeadList(&Bucket->ResourceList);
                Resource = CONTAINING_RECORD(ListEntry,
                                             RESOURCE,
                                             ListEntry);

                //
                // Acquire spin lock for synchronizing with arbitrate.
                // Moved it below the state change ioctl above.
                //
                fLockAcquired = RmpAcquireSpinLock( Resource, TRUE );
                
                //
                // If the resource is in online, failed or in pending state, terminate it. Note that
                // we need to terminate pending resources as well, otherwise our close call
                // down below would cause those threads to AV.
                //
                if ((Resource->State == ClusterResourceOnline) ||
                    (Resource->State == ClusterResourceFailed) ||
                    (Resource->State > ClusterResourcePending)) {
                    Resource->dwEntryPoint = RESDLL_ENTRY_TERMINATE;
                    
                    ClRtlLogPrint( LOG_NOISE,
                        "[RM] RundownResources, terminate resource <%1!ws!>.\n",
                        Resource->ResourceName );
                    RmpSetMonitorState(RmonTerminateResource, Resource);
                    pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                                   Resource->ResourceType,
                                                                   Resource->ResourceName,
                                                                   L"Terminate (on rundown)" );

#ifdef COMRES
                    RESMON_TERMINATE (Resource) ;
#else
                    (Resource->Terminate)(Resource->Id);
#endif
                    RmpSetMonitorState(RmonIdle, Resource);
                    RmpRemoveDeadlockMonitorList( pDueTimeEntry );
                    Resource->dwEntryPoint = 0;
                }

                //
                // If the resource has been arbitrated for, release it.
                //
                if (Resource->IsArbitrated) {
                    RmpSetMonitorState(RmonReleaseResource, Resource);
                    //
                    //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
                    //  you remove the entry after you finish the entry point call, else you will kill
                    //  this process on a FALSE deadlock positive.
                    //
                    pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                                   Resource->ResourceType,
                                                                   Resource->ResourceName,
                                                                   L"Release (on rundown)" );

#ifdef COMRES
                    RESMON_RELEASE (Resource) ;
#else
                    (Resource->Release)(Resource->Id);
#endif
                    RmpRemoveDeadlockMonitorList( pDueTimeEntry );
                    RmpSetMonitorState(RmonIdle, Resource);
                }

                //
                // Close the resource.
                //
                Resource->dwEntryPoint = RESDLL_ENTRY_CLOSE;
                RmpSetMonitorState(RmonDeletingResource, Resource);
                //
                //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
                //  you remove the entry after you finish the entry point call, else you will kill
                //  this process on a FALSE deadlock positive.
                //
                pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                               Resource->ResourceType,
                                                               Resource->ResourceName,
                                                               L"Close (on rundown)" );

#ifdef COMRES
                RESMON_CLOSE (Resource) ;
#else
                (Resource->Close)(Resource->Id);
#endif
                RmpSetMonitorState(RmonIdle, Resource);
                RmpRemoveDeadlockMonitorList( pDueTimeEntry );
                Resource->dwEntryPoint = 0;

                //
                // Zero the resource links so that RmCloseResource can tell
                // that this resource is already terminated and closed.
                //
                Resource->ListEntry.Flink = Resource->ListEntry.Blink = NULL;

                if ( fLockAcquired ) RmpReleaseSpinLock ( Resource );
            }
        }

        CL_ASSERT(EventList->ThreadHandle != NULL);

        ReleaseEventListLock( EventList );

        //
        // Wait for the thread to finish up before freeing the memory it is
        // referencing.
        //

        ReleaseListLock(); // Release the list lock while waiting...

        // 
        //  Stop the thread processing this event list. Wait for 60 seconds for the 
        //  thread to finish up.
        //
        if ( EventList->hEventShutdown )
        {
            SetEvent( EventList->hEventShutdown );
            WaitForSingleObject( EventList->ThreadHandle, 60000 );
        }

        AcquireListLock();
        CloseHandle(EventList->ThreadHandle);
        EventList->ThreadHandle = NULL;

        //
        // We will assume that all of the event handles were closed as a
        // result of calling the Close entrypoint.
        //
        DeleteCriticalSection(&EventList->ListLock);
        RmpFree( EventList );
    }

    ReleaseListLock();

    return;

} // RmpRundownResources

VOID
RmpSetEventListLockOwner(
    IN PRESOURCE pResource,
    IN DWORD     dwMonitorState
    )

/*++

Routine Description:

    Saves the resource and the resource DLL entry point into the eventlist structure just
    before the resource DLL entry point is called.

Arguments:

    pResource - Pointer to the resource structure.

    dwMonitorState - The state of the resource monitor, what resource DLL entry point it has called.

Return Value:

    None.

--*/
{
    PPOLL_EVENT_LIST pEventList;

    if ( pResource == NULL ) return;
    
    pEventList = (PPOLL_EVENT_LIST) pResource->EventList;

    if ( pEventList != NULL )
    {
        pEventList->LockOwnerResource = pResource;
        pEventList->MonitorState = dwMonitorState;
    }
}

BOOL
RmpAcquireSpinLock(
    IN PRESOURCE pResource,
    IN BOOL fSpin
    )

/*++

Routine Description:

    Acquire a spin lock.

Arguments:

    pResource - Pointer to the resource structure.

    fSpin - TRUE if we must spin if the lock is unavailable. FALSE we shouldn't spin but return
    a failure.

Return Value:

    TRUE - Lock is acquired.

    FALSE - Lock is not acquired.

--*/
{
    DWORD       dwRetryCount = 0;

    //
    //  This resource is not one that supports arbitrate. Return failure. Note that resources
    //  other than the quorum resource support this entry point. We use this instead of the
    //  pResource->IsArbitrate since that variable is set only after the first arbitrate is called
    //  and we need to use this function before the arbitrate entry point is called.
    //
    if ( pResource->pArbitrate == NULL ) return FALSE;

    //
    //  Initial check for lock availability.
    //
    if ( InterlockedCompareExchange( &pResource->fArbLock, 1, 0 ) == 0 ) return TRUE;

    //
    //  Did not get the lock. Check if we must spin.
    //
    if ( fSpin == FALSE ) 
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] RmpAcquireSpinLock: Could not get spinlock for resource %1!ws! after no wait...\n",
                      pResource->ResourceName);
        return FALSE;
    }
    
    //
    //  We must spin. Spin until timeout.
    //
    while ( ( dwRetryCount < RESMON_MAX_SLOCK_RETRIES ) &&
            ( InterlockedCompareExchange( &pResource->fArbLock, 1, 0 ) ) )
    {
        Sleep ( 500 );
        dwRetryCount ++;
    }

    if ( dwRetryCount == RESMON_MAX_SLOCK_RETRIES ) 
    {
        ClRtlLogPrint(LOG_ERROR,
                      "[RM] RmpAcquireSpinLock: Could not get spinlock for resource %1!ws! after spinning...\n",
                      pResource->ResourceName);
        return FALSE;
    }

    return TRUE;
} // RmpAcquireSpinLock

VOID
RmpReleaseSpinLock(
    IN PRESOURCE pResource
    )

/*++

Routine Description:

    Release a spin lock.

Arguments:

    pResource - Pointer to the resource structure.

Return Value:

    None.

--*/
{
    DWORD       dwRetryCount = 0;

    //
    //  This resource is not one that supports arbitrate. Return failure.
    //
    if ( pResource->pArbitrate == NULL ) return;

    InterlockedExchange( &pResource->fArbLock, 0 );
} // RmpReleaseSpinLock

VOID
RmpNotifyResourceStateChangeReason(
    IN PRESOURCE pResource,
    IN CLUSTER_RESOURCE_STATE_CHANGE_REASON eReason
    )

/*++

Routine Description:

    Notify a resource the reason for the state change.

Arguments:

    pResource - Pointer to the resource structure.

    eReason - The state change reason.

Return Value:

    None.

--*/
{
    DWORD                                           dwStatus;
    DWORD                                           dwCharacteristics;
    DWORD                                           dwBytesReturned;
    CLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT     ClusterResourceStateChangeReason;

    //
    //  First of, check if the resource needs this state change notification.
    // 
#ifdef COMRES   
    dwStatus = RESMON_RESOURCECONTROL( pResource,
                                       CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                                       NULL,
                                       0,
                                       ( PUCHAR ) &dwCharacteristics,
                                       sizeof( DWORD ),
                                       &dwBytesReturned );
#else
    dwStatus = (pResource->ResourceControl)( pResource->Id,
                                              CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                                              NULL,
                                              0,
                                              ( PUCHAR ) &dwCharacteristics,
                                              sizeof( DWORD ),
                                              &dwBytesReturned );
#endif

    if ( ( dwStatus != ERROR_SUCCESS ) ||
         !( dwCharacteristics & CLUS_CHAR_REQUIRES_STATE_CHANGE_REASON ) ) 
    {
        goto FnExit;
    }

    ClRtlLogPrint(LOG_NOISE,
                  "[RM] RmpNotifyResourceStateChangeReason: Notifying resource %1!ws! of state change reason %2!u!...\n",
                  pResource->ResourceName,
                  eReason);

    //
    //  This resource needs the state change reason. Drop it down to this resource.
    //
    ClusterResourceStateChangeReason.dwSize = sizeof ( CLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT );
    ClusterResourceStateChangeReason.dwVersion = CLUSCTL_RESOURCE_STATE_CHANGE_REASON_VERSION_1;
    ClusterResourceStateChangeReason.eReason = eReason;

#ifdef COMRES
    RESMON_RESOURCECONTROL( pResource,
                            CLUSCTL_RESOURCE_STATE_CHANGE_REASON,
                            ( PUCHAR ) &ClusterResourceStateChangeReason,
                            ClusterResourceStateChangeReason.dwSize,
                            NULL,
                            0,
                            NULL );
#else
    (pResource->ResourceControl)( pResource->Id,
                                   CLUSCTL_RESOURCE_STATE_CHANGE_REASON,
                                   ( PUCHAR ) &ClusterResourceStateChangeReason,
                                   ClusterResourceStateChangeReason.dwSize,
                                   NULL,
                                   0,
                                   NULL );
#endif

FnExit:
    return;
}

VOID
RmpNotifyResourcesRundown(
    VOID
    )

/*++

Routine Description:

    Notify interested resources that resmon is running down resources due to a clussvc crash.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    PPOLL_EVENT_LIST        pEventList;
    PLIST_ENTRY             pEventListEntry, pBucketListEntry, pResourceListEntry;
    PRESOURCE               pResource;
    PMONITOR_BUCKET         pBucket;

    if ( !g_fRmpClusterProcessCrashed ) return;
    
    AcquireListLock();

    for ( pEventListEntry = RmpEventListHead.Flink;
          pEventListEntry != &RmpEventListHead;
          pEventListEntry = pEventListEntry->Flink )
    {       
        pEventList = CONTAINING_RECORD( pEventListEntry, POLL_EVENT_LIST, Next );

        AcquireEventListLock ( pEventList );
        
        for ( pBucketListEntry = pEventList->BucketListHead.Flink;
              pBucketListEntry != &pEventList->BucketListHead;
              pBucketListEntry = pBucketListEntry->Flink )
        {  
            pBucket = CONTAINING_RECORD ( pBucketListEntry, MONITOR_BUCKET, BucketList );

            for ( pResourceListEntry = pBucket->ResourceList.Flink;
                  pResourceListEntry != &pBucket->ResourceList;
                  pResourceListEntry = pResourceListEntry->Flink )
            {  
                pResource = CONTAINING_RECORD ( pResourceListEntry, RESOURCE, ListEntry );
                RmpNotifyResourceStateChangeReason ( pResource, eResourceStateChangeReasonRundown );                    
            } // for           
        } // for
        
        ReleaseEventListLock ( pEventList );
    } // for

    ReleaseListLock ();
} // RmpNotifyResourcesRundown
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\resmon.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    resmon.c

Abstract:

    Startup and initialization portion of the Cluster Resource Monitor

Author:

    John Vert (jvert) 30-Nov-1995


Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "resmonp.h"
#include "stdio.h"
#include "stdlib.h"
#include "clusverp.h"

#ifdef COMRES
#include "comres_i.c"
#endif

#define RESMON_MODULE RESMON_MODULE_RESMON

//
// Global data
//
CRITICAL_SECTION RmpListLock;
LOCK_INFO RmpListPPrevPrevLock;
LOCK_INFO RmpListPrevPrevLock;
LOCK_INFO RmpListPrevLock;
LOCK_INFO RmpListLastLock;
LOCK_INFO RmpListLastUnlock;
LOCK_INFO RmpListPrevUnlock;
LOCK_INFO RmpListPrevPrevUnlock;
LOCK_INFO RmpListPPrevPrevUnlock;
CRITICAL_SECTION RmpMonitorStateLock;
PMONITOR_STATE RmpSharedState = NULL;
HANDLE RmpInitEvent = NULL;
HANDLE RmpFileMapping = NULL;
HANDLE RmpClusterProcess = NULL;
HKEY RmpResourcesKey = NULL;
HKEY RmpResTypesKey = NULL;
HCLUSTER RmpHCluster = NULL;
HANDLE RmpWaitArray[MAX_THREADS];
HANDLE RmpRewaitEvent = NULL;
DWORD  RmpNumberOfThreads = 0;
BOOL   RmpDebugger = FALSE;
BOOL   RmpCrashed = FALSE;
LPTOP_LEVEL_EXCEPTION_FILTER lpfnOriginalExceptionFilter = NULL;
BOOL    g_fRmpClusterProcessCrashed = FALSE;
DWORD   g_dwDebugLogLevel = 0;  // Controls spew to debugger

PWCHAR RmonStates[] = {
    L"",       // Initializing
    L"",       // Idle
    L"Starting",
    L"Initializing",
    L"Online",
    L"Offline",
    L"Shutdown",
    L"Deleteing",
    L"IsAlivePoll",
    L"LooksAlivePoll",
    L"Arbitrate",
    L"Release"
    L"ResourceControl",
    L"ResourceTypeControl",
    0 };


//
// Prototypes local to this module
//

DWORD
RmpInitialize(
    VOID
    );

VOID
RmpCleanup(
    VOID
    );

VOID
RmpParseArgs(
    int argc,
    wchar_t *argv[],
    OUT LPDWORD pClussvcProcessId, 
    OUT HANDLE* pClussvcFileMapping, 
    OUT HANDLE* pClussvcInitEvent,
    OUT LPWSTR* pDebuggerCommand
    );

RPC_STATUS
ResmonRpcConnectCallback(
    IN RPC_IF_ID * Interface,
    IN void * Context
    );



LONG
RmpExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionInfo
    )
/*++

Routine Description:

    Top level exception handler for the resource monitor process.
    Currently this just exits immediately and assumes that the
    cluster service will notice and clean up the mess.

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/

{
    DWORD  code = 0;

    if ( !RmpCrashed ) {
        RmpCrashed = TRUE;
        code = ExceptionInfo->ExceptionRecord->ExceptionCode;
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Exception. Code = 0x%1!lx!, Address = 0x%2!p!\n",
               ExceptionInfo->ExceptionRecord->ExceptionCode,
               ExceptionInfo->ExceptionRecord->ExceptionAddress);
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Exception parameters: %1!lx!, %2!lx!, %3!lx!, %4!lx!\n",
                ExceptionInfo->ExceptionRecord->ExceptionInformation[0],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[1],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[2],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[3]);
        CL_LOGFAILURE(ExceptionInfo->ExceptionRecord->ExceptionCode);

        if (lpfnOriginalExceptionFilter)
            lpfnOriginalExceptionFilter(ExceptionInfo);

    }

    //
    // Dump an exception report
    //
    GenerateExceptionReport(ExceptionInfo);

    //
    // Try to dump the resource and the resource state
    //
    try {
        PRESOURCE resource;
        DWORD     state = 0;

        resource = (PRESOURCE)RmpSharedState->ActiveResource;

        if ( state <= RmonResourceTypeControl ) {
            state =RmpSharedState->State;
        }

        ClRtlLogPrint( LOG_CRITICAL, "[RM] Active Resource = %1!08LX!\n",
                   resource );
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Resource State is %1!u!,  \"%2!ws!\"\n",
                   RmpSharedState->State,
                   RmonStates[RmpSharedState->State] ); 

        if ( resource ) {
            ClRtlLogPrint( LOG_CRITICAL, "[RM] Resource name is %1!ws!\n",
                        resource->ResourceName );
            ClRtlLogPrint( LOG_CRITICAL, "[RM] Resource type is %1!ws!\n",
                        resource->ResourceType );
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Exception %1!08LX! while dumping state for resource!\n",
            GetExceptionCode());
    }

    if ( code == 0xC0000194 ) {
        DumpCriticalSection( (PVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[0] );
    }

    if ( IsDebuggerPresent()) {
        return(EXCEPTION_CONTINUE_SEARCH);
    } else {
#if !CLUSTER_BETA
        // terminate only when product ships

        TerminateProcess( GetCurrentProcess(),
                          ExceptionInfo->ExceptionRecord->ExceptionCode );
#endif

        return(EXCEPTION_CONTINUE_SEARCH);
    }
}



int _cdecl
wmain (argc, argv)
    int     argc;
    wchar_t *argv[];
{
    PVOID EventList;
    DWORD Status;
    HANDLE ResourceId;
    CLUSTER_RESOURCE_STATE ResourceState;
    WCHAR rpcEndpoint[80];
    HKEY ClusterKey;
    BOOL Inited = FALSE;
    BOOL comInited = FALSE;
    BOOL   bSuccess;
    HANDLE ClussvcFileMapping, ClussvcInitEvent;
    DWORD ClussvcProcessId;
    LPWSTR debuggerCommand = NULL;
    LPWSTR lpszDebugLogLevel;
    LPWSTR pResmonRpcEndpointName = NULL;

    //
    // Initialize the Cluster Rtl routines.
    //
    lpszDebugLogLevel = _wgetenv(L"ClusterLogLevel");

    if (lpszDebugLogLevel != NULL) {
        // Added test to keep prefast happy.
        if ( swscanf(lpszDebugLogLevel, L"%u", &g_dwDebugLogLevel ) == 0 ) {
            g_dwDebugLogLevel = 0;
        }
    }

    if ( (Status = ClRtlInitialize( FALSE, &g_dwDebugLogLevel )) != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[RM] Failed to initialize Cluster RTL, error %1!u!.\n",
                      Status);
        goto init_failure;
    }
    ClRtlInitWmi(NULL);

    Inited = TRUE;

    //
    // Set our unhandled exception filter so that if anything horrible
    // goes wrong, we can exit immediately.
    //
    lpfnOriginalExceptionFilter = SetUnhandledExceptionFilter(RmpExceptionFilter);

    //
    // Parse the input arguments.
    //

    RmpParseArgs(argc, argv, 
                 &ClussvcProcessId, 
                 &ClussvcFileMapping, 
                 &ClussvcInitEvent,
                 &debuggerCommand);

    if ((ClussvcInitEvent == NULL) ||
        (ClussvcFileMapping == NULL) ||
        (ClussvcProcessId == 0)) {
        //
        // All of these arguments are required.
        //
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to parse required parameter.\n");
        Status = ERROR_INVALID_PARAMETER;

        goto init_failure;
    }

    //
    // We do not want to create resmon process with InheritHandles flag.
    // So resmon parameters got changed. We no longer pass handles valid in
    // the context of resmon.
    //

    //
    // First, convert ProcessId into ProcessHandle
    //
    RmpClusterProcess = OpenProcess(PROCESS_ALL_ACCESS, 
                                    FALSE, // Don't inherit
                                    ClussvcProcessId);
        
    if (RmpClusterProcess == NULL) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] OpenProcess for %1!x! process failed, error %2!u!.\n",
                    RmpClusterProcess, Status);
        goto init_failure;
    }

    //
    // Now Dup the handles from ClusSvc to Resmon
    //

    bSuccess = DuplicateHandle(
                    RmpClusterProcess,  // Source Process
                    ClussvcInitEvent,   // Source Handle
                    GetCurrentProcess(),// Target Process
                    &RmpInitEvent,      // Target Handle
                    0,                  // DUPLICATE_SAME_ACCESS
                    FALSE,              // Don't inherit 
                    DUPLICATE_SAME_ACCESS);

    if (!bSuccess) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Dup InitEvent handle %1!x! failed, error %2!u!.\n",
                    ClussvcInitEvent, Status);
        goto init_failure;
    }

    bSuccess = DuplicateHandle(
                    RmpClusterProcess,  // Source Process
                    ClussvcFileMapping, // Source Handle
                    GetCurrentProcess(),// Target Process
                    &RmpFileMapping,    // Target Handle
                    0,                  // DUPLICATE_SAME_ACCESS
                    FALSE,              // Don't inherit 
                    DUPLICATE_SAME_ACCESS);

    if (!bSuccess) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Dup FileMapping handle %1!x! failed, error %2!u!.\n",
                    ClussvcFileMapping, Status);
        goto init_failure;
    }

    if ( debuggerCommand ) {
        //
        // if -d was specified, then check if the optional command arg was
        // specified. If not, wait for a debugger to be attached
        // external. Otherwise, append the PID to the passed command and call
        // CreateProcess on it.
        //
        if ( *debuggerCommand == UNICODE_NULL ) {
            while ( !IsDebuggerPresent()) {
                Sleep( 1000 );
            }
        } else {
            // Largest possible 64 bit number is 20 spaces (in decimal), + 4 for " -p ".
            #define MAX_PID_CCH_LEN 24

            STARTUPINFOW startupInfo;
            PROCESS_INFORMATION processInfo;
            DWORD cmdLength;
            PWCHAR dbgCmdLine;

            cmdLength = wcslen( debuggerCommand );
            cmdLength += MAX_PID_CCH_LEN;

            dbgCmdLine = LocalAlloc( LMEM_FIXED, cmdLength * sizeof( WCHAR ));

            if ( dbgCmdLine != NULL ) {
                dbgCmdLine [ cmdLength - 1 ] = UNICODE_NULL;
                _snwprintf( dbgCmdLine,
                            cmdLength - 1, // Include space for NULL
                            L"%ws -p %d",
                            debuggerCommand,
                            GetCurrentProcessId() );
                ClRtlLogPrint(LOG_NOISE, "[RM] Starting debugger process: %1!ws!\n", dbgCmdLine );

                //
                // Attempt to attach debugger to us
                //
                ZeroMemory(&startupInfo, sizeof(startupInfo));
                startupInfo.cb = sizeof(startupInfo);

                bSuccess = CreateProcessW(NULL,
                                          dbgCmdLine,
                                          NULL,
                                          NULL,
                                          FALSE,                 // Inherit handles
                                          DETACHED_PROCESS,      // so ctrl-c won't kill it
                                          NULL,
                                          NULL,
                                          &startupInfo,
                                          &processInfo);
                if (!bSuccess) {
                    Status = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                                  "[RM] Failed to create debugger process, error %1!u!.\n",
                                  Status);
                }

                CloseHandle(processInfo.hThread);           // don't need these
                CloseHandle(processInfo.hProcess);
                LocalFree( dbgCmdLine );
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[RM] Failed to alloc memory for debugger command line, error %1!u!.\n",
                              GetLastError());
            }
        }
    }

    //
    // init COM for netname
    //
    Status = CoInitializeEx( NULL, COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
    if ( !SUCCEEDED( Status )) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Couldn't init COM %1!08X!\n", Status );
        goto init_failure;
    }
    comInited = TRUE;

    ClRtlLogPrint( LOG_NOISE, "[RM] Main: Initializing.\r\n");

    //
    // Initialize the resource monitor.
    //
    Status = RmpInitialize();

    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to initialize, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    RmpSharedState = MapViewOfFile(RmpFileMapping,
                                   FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0);
    if (RmpSharedState == NULL) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to init shared state, error %1!u!.\n",
            Status = GetLastError());
        goto init_failure;
    }
    CloseHandle(RmpFileMapping);
    RmpFileMapping =  NULL;

    GetSystemTimeAsFileTime((PFILETIME)&RmpSharedState->LastUpdate);
    RmpSharedState->State = RmonInitializing;
    RmpSharedState->ActiveResource = NULL;
    if ( RmpSharedState->ResmonStop ) {
        // If ResmonStop is set to TRUE, then a debugger should be attached
        RmpDebugger = TRUE;
    }


    //
    // Connect to local cluster and open Resources key.
    //
    RmpHCluster = OpenCluster(NULL);
    if (RmpHCluster == NULL) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Error opening cluster, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    ClusterKey = GetClusterKey(RmpHCluster, KEY_READ);
    if (ClusterKey == NULL) {
        Status = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to open the cluster key, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    Status = ClusterRegOpenKey(ClusterKey,
                               CLUSREG_KEYNAME_RESOURCES,
                               KEY_READ,
                               &RmpResourcesKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to open Resources cluster registry key, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    Status = ClusterRegOpenKey(ClusterKey,
                               CLUSREG_KEYNAME_RESOURCE_TYPES,
                               KEY_READ,
                               &RmpResTypesKey);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to open ResourceTypes cluster registry key, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    //
    // The Wait Count identifies the number of events the main thread will
    // wait for. This is the notification event, the Cluster Service Process
    // plus each event list thread. We start at 2 because the first two entries
    // are fixed - for the notification event and the Cluster Service process.
    //

    RmpNumberOfThreads = 2;

    //
    // Create an event to be signaled whenever we add a new thread.
    //

    RmpRewaitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( RmpRewaitEvent == NULL ) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to create rewait event, error %1!u!.\n",
            Status = GetLastError());
        goto init_failure;
    }

    //
    // Create the first event list, and start a polling thread.
    //
    EventList = RmpCreateEventList();

    if (EventList == NULL) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to create event list, error %1!u!.\n",
            Status = GetLastError());
        goto init_failure;
    }

    //
    //  Register the protocol
    //
    Status = RpcServerUseProtseqW(L"ncalrpc",
                                  RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                  NULL);

    if (Status != RPC_S_OK) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to initialize RPC interface, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    //
    //  Get the dynamic endpoint name.
    //
    Status = RmpGetDynamicEndpointName( &pResmonRpcEndpointName );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[RM] Unable to obtain dynamic EP name, status %1!u!.\n",
            Status);
        goto init_failure;
    }

    //
    //  Save the dynamic endpoint name to the registry
    //
    Status = RmpSaveDynamicEndpointName ( pResmonRpcEndpointName );

    RpcStringFreeW ( &pResmonRpcEndpointName );
    
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[RM] Unable to save dynamic EP name, status %1!u!.\n",
            Status);
        goto init_failure;
    }

    //
    // Use NTLM as RPC authentication package.
    //
    Status = RpcServerRegisterAuthInfo(NULL,
                                       RPC_C_AUTHN_WINNT,
                                       NULL,
                                       NULL);
    if (Status != RPC_S_OK) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to register RPC auth info, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    //
    // Register the interface
    //	
    Status = RpcServerRegisterIfEx(s_resmon_v2_0_s_ifspec,
                        NULL,
                        NULL,
                        0, // No need to set RPC_IF_ALLOW_SECURE_ONLY if security callback
                        // is specified. If security callback is specified, RPC
                        // will reject unauthenticated requests without invoking
                        // callback. This is the info obtained from RpcDev. See
                        // Windows Bug 572035.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                        ResmonRpcConnectCallback );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to register RPC interface, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    Status = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
    if (Status != RPC_S_OK) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to set RPC server listening, error %1!u!.\n",
            Status);
        goto init_failure;
    }

    //
    // Set our unhandled exception filter so that if anything horrible
    // goes wrong, we can exit immediately.
    //
    lpfnOriginalExceptionFilter = SetUnhandledExceptionFilter(RmpExceptionFilter);

    //
    // Set the event to indicate that our initialization is complete.
    // This event is passed on the command line.
    //
    if (!SetEvent(RmpInitEvent)) {
        ClRtlLogPrint( LOG_CRITICAL, "[RM] Failed to signal cluster service event, error %1!u!.\n",
            Status = GetLastError());
        goto init_failure;
    }
    CloseHandle(RmpInitEvent);

    //
    // ResmonStop is initialized to TRUE by ClusSvc, we will wait for
    // ClusSvc to signal when it is done attaching a debugger by waiting
    // until ResmonStop is set to FALSE.
    //
    while ( RmpSharedState->ResmonStop ) {
        Sleep(100);
    }

    //
    // Boost our priority. Non-fatal if this fails.
    //
    if ( !SetPriorityClass( GetCurrentProcess(),
                            HIGH_PRIORITY_CLASS ) ) {
        ClRtlLogPrint( LOG_UNUSUAL, "[RM] Failed to set priority class, error %1!u!.\n",
                   GetLastError() );
    }

    //
    // Wait for shutdown. Either the cluster service terminating or
    // the poller thread terminating will initiate a shutdown.
    //
    RmpWaitArray[0] = RmpRewaitEvent;
    RmpWaitArray[1] = RmpClusterProcess;

    //
    // If we are notified a new thread is added, then just re-wait.
    // N.B. RmpNumberOfThreads is really the number of threads, plus the
    // two fixed wait events (the change notification and the Cluster Service).
    //

    do {
        Status = WaitForMultipleObjects(RmpNumberOfThreads,
                                        RmpWaitArray,
                                        FALSE,
                                        INFINITE);

    } while ( (Status == WAIT_OBJECT_0) && (RmpShutdown == FALSE) );

    ClRtlLogPrint( LOG_UNUSUAL, "[RM] Going away, Status = %1!u!, Shutdown = %2!u!.\n",
                  Status, RmpShutdown);

    //
    //  Mark a flag if the cluster service process crashed.
    //
    if ( Status == ( WAIT_OBJECT_0 + 1 ) ) g_fRmpClusterProcessCrashed = TRUE;
    
    RmpShutdown = TRUE;
    CloseHandle( RmpRewaitEvent );

    //
    // Initiate RM shutdown.
    //
    s_RmShutdownProcess(NULL);

    //
    // Post shutdown of notification thread.
    //
    ClRtlLogPrint(LOG_NOISE, "[RM] Posting shutdown notification.\n");

    RmpPostNotify( NULL, NotifyShutdown );

    //
    //  Notify resources of a rundown if necessary. This must be done prior to flushing RPC
    //  calls since some resources (such as MNS) depend on this control code to get out of an
    //  entry point such as arbitrate which is invoked as an RPC by the cluster service.
    //
    RmpNotifyResourcesRundown();

    //
    // Shutdown RPC Server
    //
    Status = RpcMgmtStopServerListening ( NULL );
    
    if ( Status == RPC_S_OK )
    {
        //
        //  Unregister the interface
        //
        Status = RpcServerUnregisterIf ( NULL, NULL, TRUE );

        //
        // Wait for all outstanding RPCs to complete
        //
        if ( Status == RPC_S_OK ) 
        {
            Status = RpcMgmtWaitServerListen ();

            if ( Status != RPC_S_OK )
            {
                ClRtlLogPrint(LOG_UNUSUAL, "[RM] RpcMgmtWaitServerListen returns %1!u!\n", Status);
            }
        } else
        {
            ClRtlLogPrint(LOG_UNUSUAL, "[RM] RpcServerUnregisterIf returns %1!u!\n", Status);
        }
    } else 
    {
        ClRtlLogPrint(LOG_UNUSUAL, "[RM] RpcMgmtStopServerListening returns %1!u!\n", Status);
    }
    

    //
    // Clean up any resources left lying around by the cluster service. This must be done only after all outstanding RPCs have
    // completed.
    //
    RmpRundownResources();

    //
    //  Unitialize COM runtime only after all resources have been cleaned up, else they could AV if they are trying to use
    //  COM.
    //
    CoUninitialize () ;

    return(0);

init_failure:
    if ( RmpInitEvent != NULL ) {
        CloseHandle( RmpInitEvent );
    }
    if ( RmpFileMapping != NULL ) {
        CloseHandle( RmpFileMapping );
    }
    if ( RmpClusterProcess != NULL ) {
        CloseHandle( RmpClusterProcess );
    }
    if ( RmpResTypesKey != NULL ) {
        ClusterRegCloseKey( RmpResTypesKey );
    }
    if ( RmpResourcesKey != NULL ) {
        ClusterRegCloseKey( RmpResourcesKey );
    }
    if ( RmpHCluster != NULL ) {
        CloseCluster( RmpHCluster );
    }
    if ( RmpRewaitEvent != NULL ) {
        CloseHandle( RmpRewaitEvent );
    }

    if ( comInited )
        CoUninitialize();

    if ( Inited )
        CL_LOGFAILURE(Status);

    return(Status);

} // main



VOID
RmpParseArgs(
    int argc,
    wchar_t *argv[],
    OUT LPDWORD pClussvcProcessId, 
    OUT HANDLE* pClussvcFileMapping, 
    OUT HANDLE* pClussvcInitEvent,
    OUT LPWSTR* pDebuggerCommand
    )

/*++

Routine Description:

    Parses the command line passed to the resource monitor

    Required options:
        -e EVENT  supplies Event handle to be signalled when
                  initialization is complete
        -m FILEMAPPING  supplies file mapping handle to be
                  used for shared monitor state.
        -p PROCESSID supplies process id of the cluster
                  service so resmon can detect failure of the
                  cluster service and shutdown cleanly.

        -d [DEBUGGERCMD] - wait for or attach a debugger during startup

    Additional options:
        none

Arguments:

    argc - supplies number of arguments

    argv - supplies actual arguments

Return Value:

    None.

--*/

{
    int i;
    wchar_t *p;

    for (i=1; i<argc; i++) {
        p=argv[i];
        if ((*p == '-') ||
            (*p == '/')) {

            ++p;

            switch (toupper(*p)) {
                case 'E':
                    if (i+1 < argc) {
                        *pClussvcInitEvent = LongToHandle(_wtoi(argv[++i]));
                    } else {
                        goto BadCommandLine;
                    }
                    break;

                case 'M':
                    if (i+1 < argc) {
                        *pClussvcFileMapping = LongToHandle(_wtoi(argv[++i]));
                    } else {
                        goto BadCommandLine;
                    }
                    break;

                case 'P':
                    if (i+1 < argc) {
                        *pClussvcProcessId = (DWORD)_wtoi(argv[++i]);
                    } else {
                        goto BadCommandLine;
                    }
                    break;

                case 'D':
                    //
                    // use the empty (but not NULL) string to indicate that
                    // resmon should wait for a debugger to be attached.
                    //
                    if (i+1 < argc) {
                        if ( *argv[i+1] != UNICODE_NULL && *argv[i+1] != L'-' ) {
                            *pDebuggerCommand = argv[++i];
                        } else {
                            *pDebuggerCommand = L"";
                        }
                    } else {
                        *pDebuggerCommand = L"";
                    }
                    break;

                default:
                    goto BadCommandLine;

            }
        }
    }

    return;

BadCommandLine:

    ClusterLogEvent0(LOG_CRITICAL,
                     LOG_CURRENT_MODULE,
                     __FILE__,
                     __LINE__,
                     RMON_INVALID_COMMAND_LINE,
                     0,
                     NULL);
    ExitProcess(0);

} // RmpParseArgs



DWORD
RmpInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize all resources needed by the resource monitor.

Arguments:

    None.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    //
    // Initialize global data
    //
    InitializeCriticalSection(&RmpListLock);
    InitializeCriticalSection(&RmpMonitorStateLock);
    InitializeListHead(&RmpEventListHead);
    ClRtlInitializeQueue(&RmpNotifyQueue);

    return(ERROR_SUCCESS);

} // RmpInitialize


DWORD RmpLoadResType(
    IN      LPCWSTR                 lpszResourceTypeName,
    IN      LPCWSTR                 lpszDllName,
    OUT     PRESDLL_FNINFO          pResDllFnInfo,
#ifdef COMRES
    OUT     PRESDLL_INTERFACES      pResDllInterfaces,
#endif
    OUT     LPDWORD                 pdwCharacteristics
)
{
    DWORD                   retry;
    DWORD                   dwStatus = ERROR_SUCCESS;
    HINSTANCE               hDll = NULL;
    PSTARTUP_ROUTINE        pfnStartup;
    PCLRES_FUNCTION_TABLE   pFnTable = NULL;
    LPWSTR                  pszDllName = (LPWSTR) lpszDllName;
    PRM_DUE_TIME_ENTRY      pDueTimeEntry = NULL;

    pResDllFnInfo->hDll = NULL;
    pResDllFnInfo->pResFnTable = NULL;

#ifdef COMRES
    pResDllInterfaces->pClusterResource = NULL;
    pResDllInterfaces->pClusterQuorumResource = NULL;
    pResDllInterfaces->pClusterResControl = NULL;

#endif

    // Expand any environment variables included in the DLL path name.
    if ( wcschr( lpszDllName, L'%' ) != NULL ) {
        pszDllName = ClRtlExpandEnvironmentStrings( lpszDllName );
        if ( pszDllName == NULL ) {
            dwStatus = GetLastError();
            ClRtlLogPrint( LOG_UNUSUAL, "[RM] ResTypeControl: Error expanding environment strings in '%1!ls!, error %2!u!.\n",
                       lpszDllName,
                       dwStatus);
            goto FnExit;
        }
    }

    // Load the dll... we can't assume we have the DLL loaded!
    hDll = LoadLibraryW(pszDllName);

    if ( hDll == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, "[RM] ResTypeControl: Error loading resource DLL '%1!ls!', error %2!u!.\n",
                   pszDllName,
                   dwStatus);
    #ifdef COMRES
        dwStatus = RmpLoadComResType(lpszDllName, pResDllInterfaces,
                        pdwCharacteristics);

        //
        //  Map COM errors to a specific Win32 error code that the cluster service relies on
        //  for figuring out whether this node supports this restype.
        //
        if ( dwStatus != S_OK ) 
        {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] ResTypeControl: Error loading resource DLL '%1!ls!', COM error 0x%2!08lx!...\n",
                          pszDllName,
                          dwStatus);
            dwStatus = ERROR_MOD_NOT_FOUND;
        }
    #endif
        goto FnExit;
    }

    //
    // Invoke debugger if one is specified.
    //
    if ( RmpDebugger ) {
        //
        // Wait for debugger to come online.
        //
        retry = 100;
        while ( retry-- &&
                !IsDebuggerPresent() ) {
            Sleep(100);
        }
        OutputDebugStringA("[RM] ResourceTypeControl: Just loaded resource DLL ");
        OutputDebugStringW(lpszDllName);
        OutputDebugStringA("\n");
        DebugBreak();
    }

    // Get the startup routine
    pfnStartup = (PSTARTUP_ROUTINE)GetProcAddress( hDll,
                                                STARTUP_ROUTINE );
    if ( pfnStartup == NULL ) {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[RM] ResTypeControl: Error getting startup routine of %1!ws!, status %2!u!.\n",
                      lpszDllName,
                      dwStatus);
        goto FnExit;
    }

    // Get the function table
    RmpSetMonitorState(RmonStartingResource, NULL);

    //
    //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
    //  you remove the entry after you finish the entry point call, else you will kill
    //  this process on a FALSE deadlock positive.
    //
    pDueTimeEntry = RmpInsertDeadlockMonitorList ( lpszDllName,
                                                   lpszResourceTypeName,
                                                   NULL,
                                                   L"Startup" );

    try {
        dwStatus = (pfnStartup)( lpszResourceTypeName,
                            CLRES_VERSION_V1_00,
                            CLRES_VERSION_V1_00,
                            RmpSetResourceStatus,
                            RmpLogEvent,
                            &pFnTable );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = GetExceptionCode();
    }

    RmpRemoveDeadlockMonitorList( pDueTimeEntry );
    
    RmpSetMonitorState(RmonIdle, NULL);

    if ( dwStatus != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] ResTypeControl: Startup call for %1!ws! failed, error %2!u!.\n",
                      lpszDllName,
                      dwStatus);
        goto FnExit;
    }

    if ( pFnTable == NULL ) {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] ResTypeControl: Startup function table is NULL for %1!ws!\n", lpszDllName);
        dwStatus = ERROR_INVALID_DATA;
        goto FnExit;
    }

    if ( pFnTable->Version != CLRES_VERSION_V1_00 ) {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] ResTypeControl: Incorrect function table version for %1!ws!\n", lpszDllName);
        dwStatus = ERROR_INVALID_DATA;
        goto FnExit;
    }

    if ( pFnTable->TableSize != CLRES_V1_FUNCTION_SIZE ) {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] ResTypeControl: Incorrect function table size for %1!ws!\n", lpszDllName);
        dwStatus = ERROR_INVALID_DATA;
        goto FnExit;
    }

    if ( (pFnTable->V1Functions.Arbitrate != NULL) &&
         (pFnTable->V1Functions.Release != NULL) && pdwCharacteristics) {
        *pdwCharacteristics = CLUS_CHAR_QUORUM;
    }

FnExit:
    if (dwStatus != ERROR_SUCCESS)
    {
        if (hDll) FreeLibrary(hDll);
        if (pFnTable) LocalFree(pFnTable);
    }
    else
    {
        pResDllFnInfo->hDll = hDll;
        pResDllFnInfo->pResFnTable = pFnTable;
    }

    if ( pszDllName != lpszDllName )
    {
        LocalFree( pszDllName );
    }
    return(dwStatus);

} //*** RmpLoadResType()


#ifdef COMRES
DWORD RmpLoadComResType(
    IN  LPCWSTR                 lpszDllName,
    OUT PRESDLL_INTERFACES      pResDllInterfaces,
    OUT LPDWORD                 pdwCharacteristics)
{
    IClusterResource          *pClusterResource = NULL ;
    IClusterQuorumResource    *pClusterQuorumResource = NULL;
    IClusterResControl        *pClusterResControl = NULL;
    HRESULT                 hr ;
    CLSID                   clsid ;
    DWORD                   Error ;

    pResDllInterfaces->pClusterResource = NULL;
    pResDllInterfaces->pClusterQuorumResource = NULL;
    pResDllInterfaces->pClusterResControl = NULL;


    hr = CLSIDFromProgID(lpszDllName, &clsid) ;
    if (FAILED (hr))
    {
        ClRtlLogPrint( LOG_UNUSUAL, "[RM] Error converting CLSIDFromProgID Prog ID %1!ws!, error %2!u!.\n",
            lpszDllName, hr);
        goto FnExit ;
    }

    if ((hr = CoCreateInstance (&clsid, NULL, CLSCTX_ALL, &IID_IClusterResource, (LPVOID *) &pClusterResource)) != S_OK)
        goto FnExit ;

    //not a mandatory interface
    hr = IClusterResource_QueryInterface (pClusterResource, &IID_IClusterQuorumResource, (LPVOID *) &pClusterQuorumResource) ;

    if (SUCCEEDED(hr))
    {
        if (pdwCharacteristics)
            *pdwCharacteristics = CLUS_CHAR_QUORUM;
        IClusterQuorumResource_Release (pClusterQuorumResource) ;
    }

    //not a mandatory interface
    hr = IClusterResource_QueryInterface (
             pClusterResource,
             &IID_IClusterResControl,
             (LPVOID *) &pClusterResControl
             ) ;

    if (SUCCEEDED(hr))
    {
        *pdwCharacteristics = CLUS_CHAR_QUORUM;
        IClusterQuorumResource_Release (pClusterResControl) ;
    }

    hr = S_OK;

FnExit:
    if (hr != S_OK)
    {
        if (pClusterResource)
            IClusterResource_Release (pClusterResource) ;
        if (pClusterQuorumResource)
            IClusterQuorumResource_Release (pClusterQuorumResource) ;
        if (pClusterResControl)
            IClusterResControl_Release (pClusterResControl) ;

    }
    else
    {
        pResDllInterfaces->pClusterResource = pClusterResource;
        pResDllInterfaces->pClusterQuorumResource = pClusterQuorumResource;
        pResDllInterfaces->pClusterResControl = pClusterResControl;
    }
    return(hr);

}

#endif  //end of #ifdef COMRES


RPC_STATUS
RmpGetDynamicEndpointName(
    OUT LPWSTR *ppResmonRpcDynamicEndpointName
    )

/*++

Routine Description:

    Get the name of the dynamic endpoint the resource monitor registered.

Arguments:

    ppResmonRpcDynamicEndpointName - The dynamic endpoint name string.    

Returns:

    RPC_S_OK on success. An RPC error code otherwise

--*/

{
    RPC_STATUS          rpcStatus;
    RPC_BINDING_VECTOR  *pServerBindingVector = NULL;
    DWORD               i;
    WCHAR               *pszProtSeq = NULL, *pServerStringBinding = NULL;

    //
    //  Get the server binding vector. This includes all the protocols and EP's registered
    //  so far.
    //
    rpcStatus = RpcServerInqBindings( &pServerBindingVector );
    
    if ( rpcStatus != RPC_S_OK )
    {
        ClRtlLogPrint(LOG_CRITICAL, 
                      "[RM] RmpGetDynamicEndpointName: Unable to inquire server bindings, status %1!u!.\n",
                      rpcStatus);
        goto FnExit;
    }

    //
    //  Grovel the binding vector looking for the LRPC protocol information.
    //
    for( i = 0; i < pServerBindingVector->Count; i++ )
    {
        rpcStatus = RpcBindingToStringBindingW( pServerBindingVector->BindingH[i],
                                               &pServerStringBinding );

        if ( rpcStatus != RPC_S_OK )
        {
            ClRtlLogPrint(LOG_CRITICAL, 
                          "[RM] RmpGetDynamicEndpointName: Unable to convert binding to string, status %1!u!.\n",
                          rpcStatus);
            goto FnExit;
        }

        rpcStatus = RpcStringBindingParseW( pServerStringBinding, 
                                           NULL,
                                           &pszProtSeq,
                                           NULL, 
                                           ppResmonRpcDynamicEndpointName, 
                                           NULL );

        if ( rpcStatus != RPC_S_OK )
        {
            ClRtlLogPrint(LOG_CRITICAL, 
                          "[RM] RmpGetDynamicEndpointName: Unable to parse server string binding, status %1!u!.\n",
                          rpcStatus);
            goto FnExit;
        }

        //
        //  If you found the LRPC protocol info, then you must have the endpoint info. Return
        //  with success.
        //
        if ( lstrcmpW ( pszProtSeq, L"ncalrpc" ) == 0 )
        {
            ClRtlLogPrint(LOG_NOISE, 
                         "[RM] RmpGetDynamicEndpointName: Successfully got LRPC endpoint info, EP name is %1!ws!\n",
                         *ppResmonRpcDynamicEndpointName);
            goto FnExit;
        }

        RpcStringFreeW ( &pszProtSeq );
        pszProtSeq = NULL;
        RpcStringFreeW ( ppResmonRpcDynamicEndpointName );
        *ppResmonRpcDynamicEndpointName = NULL;
        RpcStringFreeW ( &pServerStringBinding );
        pServerStringBinding = NULL;
    } // for

    //
    //  If you didn't find the LRPC information, return an error.
    //
    if ( i == pServerBindingVector->Count )
    {
        rpcStatus = RPC_S_NO_BINDINGS;
        ClRtlLogPrint(LOG_CRITICAL, 
                      "[INIT] RmpGetDynamicEndpointName: Unable to get info on the LRPC binding, status %1!u!.\n",
                      rpcStatus);
        goto FnExit;
    }

FnExit:
    //
    //  Free the strings and the binding vector if they haven't already been freed
    //
    if ( pszProtSeq != NULL ) RpcStringFreeW ( &pszProtSeq );
    if ( pServerStringBinding != NULL ) RpcStringFreeW ( &pServerStringBinding );
    if ( pServerBindingVector != NULL ) RpcBindingVectorFree ( &pServerBindingVector );

    return ( rpcStatus );
} // RmpCleanup

DWORD
RmpSaveDynamicEndpointName(
    IN LPWSTR pResmonRpcDynamicEndpointName
    )

/*++

Routine Description:

    Save the name of the dynamic endpoint the resource monitor registered to the cluster service parameters key.

Arguments:

    pResmonRpcDynamicEndpointName - The dynamic endpoint name string.    

Returns:

    ERROR_SUCCESS on success. A Win32 error code otherwise.

Comments:

    This function saves the registered resource monitor dynamic EP text string to the registry and the cluster service reads the
    registry to know the EP value.  This is similar to what SCM does with its services.  By using the registry as opposed to
    using the shared memory mapped section between cluster service and the resource monitor, we are not limited by
    any string sizes for the EP value and so this approach is safer compared to the shared memory way.

--*/

{
    HKEY    hParamsKey = NULL;
    DWORD   dwStatus;
    
    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                            &hParamsKey );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Error in opening cluster service params key, status %1!u!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Set the dynamic endpoint name
    //
    dwStatus = RegSetValueExW( hParamsKey,
                               CLUSREG_NAME_SVC_PARAM_RESMON_EP,
                               0, // reserved
                               REG_SZ,
                               ( LPBYTE ) pResmonRpcDynamicEndpointName,
                               ( lstrlenW ( pResmonRpcDynamicEndpointName ) + 1 ) * 
                                    sizeof ( WCHAR ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Error in setting endpoint name, status %1!u!\n",
                      dwStatus);
        goto FnExit;
    }

FnExit:
    if ( hParamsKey ) RegCloseKey ( hParamsKey );
    return ( dwStatus );
}// RmpSaveDynamicEndpointName


DWORD IsUserAdmin(
    BOOL *  pbIsAdmin )

/*++

Routine Description:

    Determines whether the current user session has administrative privileges.  Must
    impersonate the client before calling this function.

Arguments:

    pbIsAdmin -- set to TRUE if the current user has admin privileges.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    SID_IDENTIFIER_AUTHORITY sidNtAuth = SECURITY_NT_AUTHORITY;
    PSID psidAdminGroup; 
    DWORD dwStatus = ERROR_SUCCESS;
    
    if ( !AllocateAndInitializeSid(
        &sidNtAuth ,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &psidAdminGroup))
    {
        dwStatus = GetLastError();
    }
    else
    {
        *pbIsAdmin = FALSE;
        if (!CheckTokenMembership( NULL, psidAdminGroup, pbIsAdmin )) 
        {
             dwStatus = GetLastError();
        } 
        FreeSid(psidAdminGroup); 
    }

    return dwStatus;
}


RPC_STATUS
ResmonRpcConnectCallback(
    IN RPC_IF_ID * Interface,
    IN void * Context
    )

/*++

Routine Description:

    RPC callback for authenticating connecting clients of resmon.

Arguments:

    Interface (unused) - Supplies the UUID and version of the interface.

    Context - Supplies a server binding handle representing the client

Return Value:

    RPC_S_OK if the user is granted permission.
    RPC_S_ACCESS_DENIED if the user is denied permission.

    Win32 error code otherwise.

--*/

{
    RPC_STATUS RpcStatus = RPC_S_OK;
    DWORD dwStatus;
    RPC_AUTHZ_HANDLE hPrivs;
    DWORD dwAuthnLevel;
    BOOL bIsAdmin = FALSE;

    //
    // Verify the authentication level of the client.
    //
    RpcStatus = RpcBindingInqAuthClient( Context,
                    &hPrivs,
                    NULL,
                    &dwAuthnLevel,
                    NULL,
                    NULL );

    if ( RpcStatus != RPC_S_OK )
    {
        goto FnExit;
    }

    if ( dwAuthnLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
    {
        RpcStatus = RPC_S_ACCESS_DENIED;
        goto FnExit;
    }
    
    // Impersonate the client so we can call IsUserAdmin.
    if ( ( RpcStatus = RpcImpersonateClient( Context ) ) != RPC_S_OK )
    {
        dwStatus = I_RpcMapWin32Status(RpcStatus);
        goto FnExit;
    }


    // Check that the caller's account is local system account
    dwStatus = IsUserAdmin( &bIsAdmin );
    
    RpcRevertToSelf();
    
    if (dwStatus != ERROR_SUCCESS )
    {
        RpcStatus = RPC_E_ACCESS_DENIED;        
        goto FnExit;
    }

    if ( !bIsAdmin )
    {
        RpcStatus = RPC_E_ACCESS_DENIED;        
        goto FnExit;        
    }

FnExit: 

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\rmapi.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Implements the management of the resource list. This includes
    adding resources to the list and deleting them from the list.

Author:

    John Vert (jvert) 1-Dec-1995

Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support

--*/
#include "resmonp.h"
#include "stdio.h"

#define RESMON_MODULE RESMON_MODULE_RMAPI

//
// Local data
//

//
// Function prototypes local to this module
//
LPWSTR
GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    );



//
// Local functions
//
DWORD   s_RmLoadResourceTypeDll(
    IN  handle_t IDL_handle,
    IN  LPCWSTR lpszResourceType,
    IN  LPCWSTR lpszDllName
)
{

    RESDLL_FNINFO       ResDllFnInfo;
#ifdef COMRES
    RESDLL_INTERFACES   ResDllInterfaces;
#endif

    DWORD   dwStatus;

    dwStatus = RmpLoadResType(
                    lpszResourceType,
                    lpszDllName,
                    &ResDllFnInfo,
#ifdef COMRES
                    &ResDllInterfaces,
#endif
                    NULL);

    if (ResDllFnInfo.hDll)
        FreeLibrary(ResDllFnInfo.hDll);
#ifdef COMRES

    if (ResDllInterfaces.pClusterResource)
        IClusterResource_Release (ResDllInterfaces.pClusterResource) ;
    if (ResDllInterfaces.pClusterQuorumResource)
        IClusterQuorumResource_Release (ResDllInterfaces.pClusterQuorumResource) ;
    if (ResDllInterfaces.pClusterResControl)
        IClusterResControl_Release (
            ResDllInterfaces.pClusterResControl
            ) ;
#endif //COMRES

    return(dwStatus);

}


RESID
s_RmCreateResource(
    IN handle_t IDL_handle,
    IN LPCWSTR DllName,
    IN LPCWSTR ResourceType,
    IN LPCWSTR ResourceId,
    IN DWORD LooksAlivePoll,
    IN DWORD IsAlivePoll,
    IN RM_NOTIFY_KEY NotifyKey,
    IN DWORD PendingTimeout,
    OUT LPDWORD Status
    )
/*++

Routine Description:

    Creates a resource to be monitored by the resource monitor.
    This involves allocating necessary structures, and loading its DLL.
    This does *NOT* insert the resource into the monitoring list or
    attempt to bring the resource on-line.

Arguments:

    IDL_handle - Supplies RPC binding handle, currently unused

    DllName - Supplies the name of the resource DLL

    ResourceType - Supplies the type of resource

    ResourceId - Supplies the Id of this specific resource

    LooksAlivePoll - Supplies the LooksAlive poll interval

    IsAlivePoll - Supplies the IsAlive poll interval

    PendingTimeout - Supplies the Pending Timeout value for this resource

    NotifyKey - Supplies a key to be passed to the notification
                callback if this resource's state changes.

Return Value:

    ResourceId - Returns a unique identifer to be used to identify
                 this resource for later operations.

--*/

{
    PRESOURCE               Resource=NULL;
    DWORD                   Error;
    HKEY                    ResKey;
    PSTARTUP_ROUTINE        Startup;
    PCLRES_FUNCTION_TABLE   FunctionTable;
    DWORD                   quorumCapable;
    DWORD                   valueType;
    DWORD                   valueData;
    DWORD                   valueSize;
    DWORD                   retry;
    DWORD                   Reason;
    LPWSTR                  pszDllName = (LPWSTR) DllName;
    PRM_DUE_TIME_ENTRY      pDueTimeEntry = NULL;

    CL_ASSERT(IsAlivePoll != 0);

    Resource = RmpAlloc(sizeof(RESOURCE));
    if (Resource == NULL) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }
    ZeroMemory( Resource, sizeof(RESOURCE) );
    //Resource->Dll = NULL;
    //Resource->Flags = 0;
    //Resource->DllName = NULL;
    //Resource->ResourceType = NULL;
    //Resource->ResourceId = NULL;
    //Resource->ResourceName = NULL;
    //Resource->TimerEvent = NULL;
    //Resource->OnlineEvent = NULL;
    //Resource->IsArbitrated = FALSE;
    Resource->Signature = RESOURCE_SIGNATURE;
    Resource->NotifyKey = NotifyKey;
    Resource->LooksAlivePollInterval = LooksAlivePoll;
    Resource->IsAlivePollInterval = IsAlivePoll;
    Resource->State = ClusterResourceOffline;

    if ( PendingTimeout <= 10 ) {
        Resource->PendingTimeout = PENDING_TIMEOUT;
    } else {
        Resource->PendingTimeout = PendingTimeout;
    }

    Resource->DllName = RmpAlloc((lstrlenW(DllName) + 1)*sizeof(WCHAR));
    if (Resource->DllName == NULL) {
        Error =  ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }
    lstrcpyW(Resource->DllName, DllName);

    Resource->ResourceType = RmpAlloc((lstrlenW(ResourceType) + 1)*sizeof(WCHAR));
    if (Resource->ResourceType == NULL) {
        Error =  ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }
    lstrcpyW(Resource->ResourceType, ResourceType);

    Resource->ResourceId = RmpAlloc((lstrlenW(ResourceId) + 1)*sizeof(WCHAR));
    if (Resource->ResourceId == NULL) {
        Error =  ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }
    lstrcpyW(Resource->ResourceId, ResourceId);

    // Expand any environment variables included in the DLL path name.
    if ( wcschr( DllName, L'%' ) != NULL ) {
        pszDllName = ClRtlExpandEnvironmentStrings( DllName );
        if ( pszDllName == NULL ) {
            Error = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, "[RM] Error expanding environment strings in '%1!ls!, error %2!u!.\n",
                       DllName,
                       Error);
            goto ErrorExit;
        }
    }

    //
    // Load the specified DLL and find the required entrypoints.
    //
    Resource->Dll = LoadLibraryW(pszDllName);
    if (Resource->Dll == NULL) {
#ifdef COMRES
        HRESULT hr ;
        CLSID clsid ;
        Error = GetLastError(); // Save the previous error. Return it instead of COM error on failure
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Error loading resource dll %1!ws!, error %2!u!.\n",
            pszDllName, Error);

        hr = CLSIDFromProgID(DllName, &clsid) ;

        if (FAILED (hr))
        {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] CLSIDFromProgID %1!ws!, hr = %2!u!.\n",
                DllName, hr);

            hr = CLSIDFromString( (LPWSTR) DllName, //Pointer to the string representation of the CLSID
                                  &clsid//Pointer to the CLSID
                                 );

            if (FAILED (hr))
            {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] CLSIDFromString Also failed %1!ws!, hr = %2!u!.\n",
                    DllName, hr);

                goto ComError ;
            }
        }

        if ((hr = CoCreateInstance (&clsid, NULL, CLSCTX_ALL, &IID_IClusterResource, (LPVOID *) &Resource->pClusterResource)) != S_OK)
        {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] Error CoCreateInstance Prog ID %1!ws!, error %2!u!.\n", DllName, hr);
            goto ComError ;
        }

        Resource->dwType = RESMON_TYPE_COM ;

        hr = IClusterResource_QueryInterface (Resource->pClusterResource, &IID_IClusterQuorumResource,
                    &Resource->pClusterQuorumResource) ;
        if (FAILED(hr))
            Resource->pClusterQuorumResource = NULL ;

        quorumCapable = (Resource->pClusterQuorumResource)?1:0 ;

        hr = IClusterResource_QueryInterface (
                 Resource->pClusterResource,
                 &IID_IClusterResControl,
                 &Resource->pClusterResControl
                 ) ;
        if (FAILED(hr))
            Resource->pClusterResControl = NULL ;
        goto comOpened ;
ComError:
#else
        Error = GetLastError();
#endif
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Error loading resource dll %1!ws!, error %2!u!.\n",
            DllName, Error);
        CL_LOGFAILURE(Error);
        ClusterLogEvent2(LOG_CRITICAL,
                         LOG_CURRENT_MODULE,
                         __FILE__,
                         __LINE__,
                         RMON_CANT_LOAD_RESTYPE,
                         sizeof(Error),
                         &Error,
                         DllName,
                         ResourceType);
        goto ErrorExit;
    }
#ifdef COMRES
    else {
        Resource->dwType = RESMON_TYPE_DLL ;
    }
comOpened:
#endif

    //
    // Invoke debugger if one is specified.
    //
    if ( RmpDebugger ) {
        //
        // Wait for debugger to come online.
        //
        retry = 100;
        while ( retry-- &&
                !IsDebuggerPresent() ) {
            Sleep(100);
        }
        OutputDebugStringA("[RM] Just loaded resource DLL ");
        OutputDebugStringW(DllName);
        OutputDebugStringA("\n");
        DebugBreak();
    }

#ifdef COMRES
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
#endif
        //
        // We must have a startup routine to find all the other functions.
        //
        Startup = (PSTARTUP_ROUTINE)GetProcAddress(Resource->Dll,
                                                   STARTUP_ROUTINE);
        if ( Startup != NULL ) {
            FunctionTable = NULL;
            RmpSetMonitorState(RmonStartingResource, Resource);
            //
            //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
            //  you remove the entry after you finish the entry point call, else you will kill
            //  this process on a FALSE deadlock positive.
            //
            pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                           Resource->ResourceType,
                                                           Resource->ResourceName,
                                                           L"Startup (on create)" );
            try {
                Error = (Startup)( ResourceType,
                                   CLRES_VERSION_V1_00,
                                   CLRES_VERSION_V1_00,
                                   RmpSetResourceStatus,
                                   RmpLogEvent,
                                   &FunctionTable );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                Error = GetExceptionCode();
            }
            RmpSetMonitorState(RmonIdle, NULL);
            RmpRemoveDeadlockMonitorList( pDueTimeEntry );

            if ( Error != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Error on Startup call to %1!ws!, error %2!u!.\n",
                    DllName, Error );
                ClusterLogEvent2(LOG_CRITICAL,
                                 LOG_CURRENT_MODULE,
                                 __FILE__,
                                 __LINE__,
                                 RMON_CANT_INIT_RESTYPE,
                                 sizeof(Error),
                                 &Error,
                                 DllName,
                                 ResourceType);
                goto ErrorExit;
            }
            Error = ERROR_INVALID_DATA;
            if ( FunctionTable == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Error on Startup return, FunctionTable is NULL!\n");
                Reason = 0;
                ClusterLogEvent2(LOG_CRITICAL,
                                 LOG_CURRENT_MODULE,
                                 __FILE__,
                                 __LINE__,
                                 RMON_RESTYPE_BAD_TABLE,
                                 sizeof(Reason),
                                 &Reason,
                                 DllName,
                                 ResourceType);
                goto ErrorExit;
            }
            if ( FunctionTable->Version != CLRES_VERSION_V1_00 ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Error on Startup return, Invalid Version Number!\n");
                Reason = 1;
                ClusterLogEvent2(LOG_CRITICAL,
                                 LOG_CURRENT_MODULE,
                                 __FILE__,
                                 __LINE__,
                                 RMON_RESTYPE_BAD_TABLE,
                                 sizeof(Reason),
                                 &Reason,
                                 DllName,
                                 ResourceType);
                goto ErrorExit;
            }
            if ( FunctionTable->TableSize != CLRES_V1_FUNCTION_SIZE ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Error on Startup return, Invalid function table size!\n");
                Reason = 2;
                ClusterLogEvent2(LOG_CRITICAL,
                                 LOG_CURRENT_MODULE,
                                 __FILE__,
                                 __LINE__,
                                 RMON_RESTYPE_BAD_TABLE,
                                 sizeof(Reason),
                                 &Reason,
                                 DllName,
                                 ResourceType);
                goto ErrorExit;
            }
#ifdef COMRES
            Resource->pOpen = FunctionTable->V1Functions.Open;
            Resource->pClose = FunctionTable->V1Functions.Close;
            Resource->pOnline = FunctionTable->V1Functions.Online;
            Resource->pOffline = FunctionTable->V1Functions.Offline;
            Resource->pTerminate = FunctionTable->V1Functions.Terminate;
            Resource->pLooksAlive = FunctionTable->V1Functions.LooksAlive;
            Resource->pIsAlive = FunctionTable->V1Functions.IsAlive;

            Resource->pArbitrate = FunctionTable->V1Functions.Arbitrate;
            Resource->pRelease = FunctionTable->V1Functions.Release;
            Resource->pResourceControl = FunctionTable->V1Functions.ResourceControl;
            Resource->pResourceTypeControl = FunctionTable->V1Functions.ResourceTypeControl;

            Error = ERROR_INVALID_DATA;
            if ( Resource->pOpen == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Open routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pClose == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Close routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pOnline == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Online routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pOffline == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Offline routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pTerminate == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Terminate routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pLooksAlive == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null LooksAlive routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }

            if ( Resource->pIsAlive == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null IsAlive routine for resource dll %1!ws!\n",
                    DllName);
                goto ErrorExit;
            }
        } else {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] Could not find startup routine in resource DLL %1!ws!.\n",
                DllName);
            Error = ERROR_INVALID_DATA;
            goto ErrorExit;
        }

        if ( (Resource->pArbitrate) &&
             (Resource->pRelease) ) {
            quorumCapable = 1;
        } else {
            quorumCapable = 0;
        }
    }
#else // COMRES
            Resource->Open = FunctionTable->V1Functions.Open;
            Resource->Close = FunctionTable->V1Functions.Close;
            Resource->Online = FunctionTable->V1Functions.Online;
            Resource->Offline = FunctionTable->V1Functions.Offline;
            Resource->Terminate = FunctionTable->V1Functions.Terminate;
            Resource->LooksAlive = FunctionTable->V1Functions.LooksAlive;
            Resource->IsAlive = FunctionTable->V1Functions.IsAlive;

            Resource->Arbitrate = FunctionTable->V1Functions.Arbitrate;
            Resource->Release = FunctionTable->V1Functions.Release;
            Resource->ResourceControl = FunctionTable->V1Functions.ResourceControl;
            Resource->ResourceTypeControl = FunctionTable->V1Functions.ResourceTypeControl;

            Error = ERROR_INVALID_DATA;
            if ( Resource->Open == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Open routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->Close == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Close routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->Online == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Online routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->Offline == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Offline routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->Terminate == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null Terminate routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->LooksAlive == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null LooksAlive routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

            if ( Resource->IsAlive == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[RM] Startup returned null IsAlive routine for resource dll %1!ws!\n",
                    pszDllName);
                goto ErrorExit;
            }

        } else {
            ClRtlLogPrint(LOG_CRITICAL, "[RM] Could not find startup routine in resource DLL %1!ws!.\n",
                pszDllName);
            Error = ERROR_INVALID_DATA;
            goto ErrorExit;
        }

        if ( (Resource->Arbitrate) &&
             (Resource->Release) ) {
            quorumCapable = 1;
        } else {
            quorumCapable = 0;
        }
#endif // COMRES

    Resource->State = ClusterResourceOffline;

    //
    // Open the resource's cluster registry key so that it can
    // be easily accessed from the Create entrypoint.
    //
    Error = ClusterRegOpenKey(RmpResourcesKey,
                              ResourceId,
                              KEY_READ,
                              &ResKey);
    if (Error != ERROR_SUCCESS) {
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }

    //
    // Get the resource name.
    //
    Resource->ResourceName = GetParameter( ResKey, CLUSREG_NAME_RES_NAME );
    if ( Resource->ResourceName == NULL ) {
        Error = GetLastError();
        ClusterRegCloseKey(ResKey);
        ClRtlLogPrint(LOG_UNUSUAL, "[RM] Error reading resource name for %1!ws!, error %2!u!.\n",
            Resource->ResourceId, Error);
        CL_LOGFAILURE(Error);
        goto ErrorExit;
    }

    //
    // Call Open entrypoint.
    // This is done with the lock held to serialize calls to the
    // resource DLL and serialize access to the shared memory region.
    //

    AcquireListLock();

    RmpSetMonitorState(RmonInitializingResource, Resource);

    //
    //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
    //  you remove the entry after you finish the entry point call, else you will kill
    //  this process on a FALSE deadlock positive.
    //
    pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                   Resource->ResourceType,
                                                   Resource->ResourceName,
                                                   L"Open" );

    //
    // N.B. This is the only call that we make without locking the
    // eventlist lock! We can't, because we don't know that the event
    // list is yet.
    //
    try {
#ifdef COMRES
        Resource->Id = RESMON_OPEN (Resource, ResKey) ;
#else
        Resource->Id = (Resource->Open)(Resource->ResourceName,
                                        ResKey,
                                        Resource );
#endif
    } except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        Resource->Id = 0;
    }

    RmpRemoveDeadlockMonitorList( pDueTimeEntry );
    
    if (Resource->Id == 0) {
        Error = GetLastError();
    } else {
        Error = RmpInsertResourceList(Resource, NULL);
    }

    //set the monitor state and close the key
    RmpSetMonitorState(RmonIdle, NULL);
    ClusterRegCloseKey(ResKey);

    if (Error != ERROR_SUCCESS)
    {
        //CL_LOGFAILURE(Error);
        ClRtlLogPrint(LOG_UNUSUAL, "[RM] RmpInsertResourceList failed, returned %1!u!\n",
            Error);
        ReleaseListLock();
        goto ErrorExit;


    }

    ReleaseListLock();

    if (Resource->Id == 0) {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] Open of resource %1!ws! returned null!\n",
            Resource->ResourceName);
        if ( Error == ERROR_SUCCESS ) {
            Error = ERROR_RESOURCE_NOT_FOUND;
        }
        //CL_LOGFAILURE(Error);
        goto ErrorExit;
    }

    *Status = ERROR_SUCCESS;

    if ( pszDllName != DllName ) {
        LocalFree( pszDllName );
    }

    //
    // Resource object has been successfully loaded into memory and
    // its entrypoints determined. We now have a valid RESID that
    // can be used in subsequent calls.
    //
    return((RESID)Resource);

ErrorExit:

    if (Resource != NULL) {
        if (Resource->Dll != NULL) {
            FreeLibrary(Resource->Dll);
        }
#ifdef COMRES
        if (Resource->pClusterResource)
            IClusterResource_Release (Resource->pClusterResource) ;
        if (Resource->pClusterQuorumResource)
            IClusterQuorumResource_Release (Resource->pClusterQuorumResource) ;
        if (Resource->pClusterResControl)
            IClusterResControl_Release (
                Resource->pClusterResControl
                ) ;
#endif
        RmpFree(Resource->DllName);
        RmpFree(Resource->ResourceType);
        RmpFree(Resource->ResourceName);
        RmpFree(Resource->ResourceId);
        RmpFree(Resource);
    }
    if ( pszDllName != DllName ) {
        LocalFree( pszDllName );
    }
    ClRtlLogPrint(LOG_CRITICAL, "[RM] Failed creating resource %1!ws!, error %2!u!.\n",
        ResourceId, Error);
    *Status = Error;
    return(0);

} // RmCreateResource


VOID
s_RmCloseResource(
    IN OUT RESID *ResourceId
    )

/*++

Routine Description:

    Closes the specified resource. This includes removing it from the poll list,
    freeing any associated memory, and unloading its DLL.

Arguments:

    ResourceId - Supplies a pointer to the resource ID. This will be set to
                 NULL after cleanup is complete to indicate to RPC that the
                 client side context can be destroyed.

Return Value:

    None.

--*/

{
    PRESOURCE           Resource;
    BOOL                Closed;
    PRM_DUE_TIME_ENTRY  pDueTimeEntry = NULL;

    Resource = (PRESOURCE)*ResourceId;

    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);
    CL_ASSERT(Resource->Flags & RESOURCE_INSERTED);

    AcquireListLock();
    if (Resource->ListEntry.Flink != NULL) {
        RmpRemoveResourceList(Resource);
        Closed = FALSE;
    } else {
        Closed = TRUE;
    }

    ReleaseListLock();

    if (!Closed) {
        //
        // Call the DLL to close the resource.
        //
        AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
        //
        // If the Online Thread is still pending, wait a little bit for it.
        //
        if ( Resource->TimerEvent ) {
            SetEvent( Resource->TimerEvent );
            Resource->TimerEvent = NULL;
        }
        
        Resource->dwEntryPoint = RESDLL_ENTRY_CLOSE;
        RmpSetMonitorState(RmonDeletingResource, Resource);

        //
        //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
        //  you remove the entry after you finish the entry point call, else you will kill
        //  this process on a FALSE deadlock positive.
        //
        pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                       Resource->ResourceType,
                                                       Resource->ResourceName,
                                                       L"Close" );
    
        try {
#ifdef COMRES
            RESMON_CLOSE (Resource) ;
#else          
            (Resource->Close)(Resource->Id);
#endif
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
        Resource->dwEntryPoint = 0;
        RmpSetMonitorState(RmonIdle, Resource);
        RmpRemoveDeadlockMonitorList ( pDueTimeEntry );
        ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
    }
    Resource->Signature = 0;

    if ( Resource->OnlineEvent ) {
        SetEvent( Resource->OnlineEvent );
        CloseHandle( Resource->OnlineEvent );
        Resource->OnlineEvent = NULL;
    }

    //
    // Free the resource dll.
    //

#ifdef COMRES
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        FreeLibrary(Resource->Dll);
    }
    else
    {
        IClusterResource_Release (Resource->pClusterResource) ;
        if (Resource->pClusterQuorumResource)
            IClusterQuorumResource_Release (Resource->pClusterQuorumResource) ;
        if (Resource->pClusterResControl)
            IClusterResControl_Release (
                Resource->pClusterResControl
                ) ;
    }
#else
    FreeLibrary(Resource->Dll);
#endif
    RmpFree(Resource->DllName);
    RmpFree(Resource->ResourceType);
    RmpFree(Resource->ResourceName);
    RmpFree(Resource->ResourceId);

    RmpFree(Resource);

    *ResourceId = NULL;

} // RmCloseResource


VOID
RPC_RESID_rundown(
    IN RESID Resource
    )

/*++

Routine Description:

    RPC rundown procedure for a RESID. Just closes the handle.

Arguments:

    Resource - supplies the RESID that is to be rundown.

Return Value:

    None.

--*/

{
    //
    //  Chittur Subbaraman (chitturs) - 5/10/2001
    //
    //  Don't do anything on RPC rundown. If clussvc dies, then resmon main thread detects it and
    //  runs down (close, terminate) resources. Merely, closing the resource here may cause
    //  it to be delivered when resource dlls don't expect it.
    //
#if 0
    s_RmCloseResource(&Resource);
#endif
} // RESID_rundown


error_status_t
s_RmChangeResourceParams(
    IN RESID ResourceId,
    IN DWORD LooksAlivePoll,
    IN DWORD IsAlivePoll,
    IN DWORD PendingTimeout
    )

/*++

Routine Description:

    Changes the poll intervals defined for a resource.

Arguments:

    ResourceId - Supplies the resource ID.

    LooksAlivePoll - Supplies the new LooksAlive poll in ms units

    IsAlivePoll - Supplies the new IsAlive poll in ms units

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise

--*/

{
    PRESOURCE Resource;
    BOOL Inserted;

    //
    //  If the resmon is shutting down, just return since you can't trust any resource structures
    //  accessed below.
    //
    if ( RmpShutdown ) return ( ERROR_SUCCESS );
    
    Resource = (PRESOURCE)ResourceId;

    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);

    AcquireListLock();

    Inserted = (Resource->Flags & RESOURCE_INSERTED);
    if (Inserted) {
        //
        // Remove the resource from the list, update its properties,
        // and reinsert it. The reinsertion will put it back in the
        // right spot to reflect the new poll intervals.
        //

        RmpRemoveResourceList(Resource);
    }
    Resource->LooksAlivePollInterval = LooksAlivePoll;
    Resource->IsAlivePollInterval = IsAlivePoll;
    Resource->PendingTimeout = PendingTimeout;
    if (Inserted) {
        RmpInsertResourceList( Resource, 
                               (PPOLL_EVENT_LIST) Resource->EventList);
    }
    ReleaseListLock();

    return(ERROR_SUCCESS);

} // RmChangeResourcePoll


error_status_t
s_RmArbitrateResource(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Arbitrate for the resource.

Arguments:

    ResourceId - Supplies the resource to be arbitrated.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PRESOURCE           Resource;
    DWORD               status;
    PRM_DUE_TIME_ENTRY  pDueTimeEntry = NULL;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);

#ifdef COMRES
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        if ( (Resource->pArbitrate == NULL) ||
             (Resource->pRelease == NULL) ) {
            return(ERROR_NOT_QUORUM_CAPABLE);
        }
    }
    else
    {
        if (!Resource->pClusterQuorumResource)
            return(ERROR_NOT_QUORUM_CAPABLE);
    }
#else
    if ( (Resource->Arbitrate == NULL) ||
         (Resource->Release == NULL) ) {
        return(ERROR_NOT_QUORUM_CAPABLE);
    }
#endif

    // 
    //  Chittur Subbaraman (chitturs) - 10/15/99
    //
    //  Commenting out lock acquisition - This is done so that the
    //  arbitration request can proceed into the disk resource without
    //  any blockage. There have been cases where either some resource
    //  gets blocked in its "IsAlive" with this lock held or the resmon
    //  itself calling into clussvc to set a property (for instance) and
    //  this call gets blocked there. This results in an arbitration stall
    //  and the clussvc on this node dies. Note that arbitrate only needs to 
    //  be serialized with release and the disk resource is supposed 
    //  to take care of that.
    //
    
#if 0
    //
    // Lock the resource list and attempt to bring the resource on-line.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
#else
    //
    // Try to acquire spin lock for synchronizing with resource rundown.
    // Return failure if you cannot get the lock.
    //
    if ( !RmpAcquireSpinLock( Resource, FALSE ) ) return ( ERROR_BUSY );
#endif

    //
    // Update shared state to indicate we are arbitrating a resource
    //
    RmpSetMonitorState(RmonArbitrateResource, Resource);

    //
    //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
    //  you remove the entry after you finish the entry point call, else you will kill
    //  this process on a FALSE deadlock positive.
    //
    pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                   Resource->ResourceType,
                                                   Resource->ResourceName,
                                                   L"Arbitrate" );

#ifdef COMRES
    status = RESMON_ARBITRATE (Resource, RmpLostQuorumResource) ;
#else
    status = (Resource->Arbitrate)(Resource->Id,
                                   RmpLostQuorumResource);
#endif
    if (status == ERROR_SUCCESS) {
        Resource->IsArbitrated = TRUE;
    }

    RmpRemoveDeadlockMonitorList( pDueTimeEntry );
    RmpSetMonitorState(RmonIdle, NULL);

#if 0
    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
#else
    RmpReleaseSpinLock( Resource );
#endif

    return(status);

} // s_RmArbitrateResource(


error_status_t
s_RmReleaseResource(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Release the resource.

Arguments:

    ResourceId - Supplies the resource to be released.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    PRESOURCE           Resource;
    DWORD               status;
    PRM_DUE_TIME_ENTRY  pDueTimeEntry = NULL;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);

#ifdef COMRES
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        if (Resource->pRelease == NULL) {
            return(ERROR_NOT_QUORUM_CAPABLE);
        }
    }
    else
    {
        if (!Resource->pClusterQuorumResource)
            return(ERROR_NOT_QUORUM_CAPABLE);
    }
#else
    if ( Resource->Release == NULL ) {
        return(ERROR_NOT_QUORUM_CAPABLE);
    }
#endif
    //
    // Lock the resource list and attempt to bring the resource on-line.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
#if 0   // Not needed right now
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
#endif

    //
    // Update shared state to indicate we ar arbitrating a resource
    //
    RmpSetMonitorState(RmonReleaseResource, Resource);

    //
    //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
    //  you remove the entry after you finish the entry point call, else you will kill
    //  this process on a FALSE deadlock positive.
    //
    pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                   Resource->ResourceType,
                                                   Resource->ResourceName,
                                                   L"Release" );

#ifdef COMRES
    status = RESMON_RELEASE (Resource) ;
#else
    status = (Resource->Release)(Resource->Id);
#endif
    Resource->IsArbitrated = FALSE;

    RmpSetMonitorState(RmonIdle, NULL);
    RmpRemoveDeadlockMonitorList( pDueTimeEntry );
    
#if 0   // Not needed right now
    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );
#endif

    return(status);

} // s_RmReleaseResource(


error_status_t
s_RmOnlineResource(
    IN RESID    ResourceId,
    OUT LPDWORD pdwState
    )

/*++

Routine Description:

    Brings the specified resource into the online state.

Arguments:

    ResourceId - Supplies the resource to be brought online.

    pdwState - The new state of the resource is returned.

Return Value:


--*/

{
    PRESOURCE               Resource;
    DWORD                   status;
    HANDLE                  timerThread;
    HANDLE                  eventHandle = NULL;
    DWORD                   threadId;
    BOOL                    fAddPollEvent = FALSE;
    PRM_DUE_TIME_ENTRY      pDueTimeEntry = NULL;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);
    CL_ASSERT(Resource->EventHandle == NULL );

    *pdwState = ClusterResourceFailed;

    if ( Resource->State > ClusterResourcePending ) {
        return(ERROR_INVALID_STATE);
    }

    //
    // Create an event to allow the SetResourceStatus callback to synchronize
    // execution with this thread.
    //
    if ( Resource->OnlineEvent ) {
        return(ERROR_NOT_READY);
    }

    Resource->OnlineEvent = CreateEvent( NULL,
                                         FALSE,
                                         FALSE,
                                         NULL );
    if ( Resource->OnlineEvent == NULL ) {
        return(GetLastError());
    }

    //
    // Lock the resource list and attempt to bring the resource on-line.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );

    //
    // Update shared state to indicate we are bringing a resource online
    //
    RmpSetMonitorState(RmonOnlineResource, Resource);

    //
    //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
    //  you remove the entry after you finish the entry point call, else you will kill
    //  this process on a FALSE deadlock positive.
    //
    pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                   Resource->ResourceType,
                                                   Resource->ResourceName,
                                                   L"Online" );

    //
    // Call Online entrypoint. Regardless of whether this succeeds or
    // not, the resource has been successfully added to the list. If the
    // online call fails, the resource immediately enters the failed state.
    //
    Resource->CheckPoint = 0;
    try {
#ifdef COMRES
        status = RESMON_ONLINE (Resource, &eventHandle) ;
#else
        status = (Resource->Online)(Resource->Id, &eventHandle);
#endif
    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    RmpRemoveDeadlockMonitorList( pDueTimeEntry );

    if (status == ERROR_SUCCESS) {
        SetEvent( Resource->OnlineEvent );
        CloseHandle( Resource->OnlineEvent );
        Resource->OnlineEvent = NULL;
        Resource->State = ClusterResourceOnline;

        if ( eventHandle ) {
            fAddPollEvent = TRUE;
        } 
    } else if ( status == ERROR_IO_PENDING ) {
        status = ERROR_SUCCESS;
        //
        // If the Resource DLL returns pending, then start a timer.
        //
        CL_ASSERT(Resource->TimerEvent == NULL );
        Resource->TimerEvent = CreateEvent( NULL,
                                            FALSE,
                                            FALSE,
                                            NULL );
        if ( Resource->TimerEvent == NULL ) {
            CL_UNEXPECTED_ERROR(status = GetLastError());
        } else {
            timerThread = CreateThread( NULL,
                                        0,
                                        RmpTimerThread,
                                        Resource,
                                        0,
                                        &threadId );
            if ( timerThread == NULL ) {
                CL_UNEXPECTED_ERROR(status = GetLastError());
            } else {
                //
                // Chittur Subbaraman (chitturs) - 1/12/99
                //
                // Raise the timer thread priority to highest. This
                // is necessary to avoid certain cases in which the
                // timer thread is sluggish to close out the timer event
                // handle before a second online. Note that there are
                // no major performance implications by doing this since
                // the timer thread is in a wait state most of the time.
                //
                if ( !SetThreadPriority( timerThread, THREAD_PRIORITY_HIGHEST ) )
                {
                    ClRtlLogPrint(LOG_UNUSUAL,
                                  "[RM] s_RmOnlineResource: Error setting priority of timer "
                                  "thread for resource %1!ws!\n",
                                  Resource->ResourceName);
                    CL_LOGFAILURE( GetLastError() );
                }
                CloseHandle( timerThread );
                Resource->State = ClusterResourceOnlinePending;
                //
                // If we have an event handle, then add it to our list.
                //
                if ( eventHandle ) {
                    fAddPollEvent = TRUE;
                }
            }
        }
        SetEvent( Resource->OnlineEvent );
    } else {
        CloseHandle( Resource->OnlineEvent );
        Resource->OnlineEvent = NULL;
        ClRtlLogPrint(LOG_CRITICAL, "[RM] OnlineResource failed, resource %1!ws!, status =  %2!u!.\n",
            Resource->ResourceName,
            status);

        ClusterLogEvent1(LOG_CRITICAL,
                         LOG_CURRENT_MODULE,
                         __FILE__,
                         __LINE__,
                         RMON_ONLINE_FAILED,
                         sizeof(status),
                         &status,
                         Resource->ResourceName);
        Resource->State = ClusterResourceFailed;
    }

    *pdwState = Resource->State;

    RmpSetMonitorState(RmonIdle, NULL);
    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );

    //
    // Notify poller thread that the list has changed
    //
    if ( fAddPollEvent )
    {
        ClRtlLogPrint(LOG_NOISE,
                      "[RM] s_RmOnlineResource: Adding event 0x%1!08lx! for resource %2!ws!\n",
                      eventHandle,
                      Resource->ResourceName);

        status = RmpAddPollEvent( (PPOLL_EVENT_LIST)Resource->EventList,
                                  eventHandle,
                                  Resource );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[RM] s_RmOnlineResource: Failed to add event 0x%1!08lx! for resource %2!ws!, error %3!u!.\n",
                          eventHandle,
                          Resource->ResourceName,
                          status );
            CL_LOGFAILURE(status);
            Resource->State = ClusterResourceFailed;
        }       
    }

    RmpSignalPoller((PPOLL_EVENT_LIST)Resource->EventList);

    return(status);

} // RmOnlineResource



VOID
s_RmTerminateResource(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Brings the specified resource into the offline state immediately.

Arguments:

    ResourceId - Supplies the resource to be brought online.

Return Value:

    The new state of the resource.

--*/

{
    DWORD State;

    RmpOfflineResource(ResourceId, FALSE, &State);

    return;

} // RmTerminateResource



error_status_t
s_RmOfflineResource(
    IN RESID ResourceId,
    OUT LPDWORD pdwState
    )

/*++

Routine Description:

    Brings the specified resource into the offline state by shutting it
    down gracefully.

Arguments:

    ResourceId - Supplies the resource to be brought online.
    pdwState - Returns the new state of the resource.

Return Value:

    ERROR_SUCCESS if successful, else returns code.

--*/

{
    return(RmpOfflineResource(ResourceId, TRUE, pdwState));

} // RmOfflineResource



error_status_t
s_RmFailResource(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Fail the given resource.

Arguments:

    ResourceId - Supplies the resource ID.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise

--*/

{
    PRESOURCE Resource;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);

    if ( Resource->State == ClusterResourceOnline ) {
        Resource->State = ClusterResourceFailed;
        RmpPostNotify(Resource, NotifyResourceStateChange);
        return(ERROR_SUCCESS);
    } else {
        return(ERROR_RESMON_INVALID_STATE);
    }

} // RmChangeResourcePoll



error_status_t
s_RmShutdownProcess(
    IN handle_t IDL_handle
    )

/*++

Routine Description:

    Set the shutdown flag and trigger a poller thread to exit.
    The termination of any poller thread will notify the main
    thread to clean up and shutdown.

Arguments:

    IDL_handle - Supplies RPC binding handle, currently unused

Return Value:

    ERROR_SUCCESS

--*/

{
    //
    // Check if we've already been called here before. This can happen
    // as a result of the Failover Manager calling us to perform a clean
    // shutdown. The main thread also will call here, in case it is shutting
    // down because of a failure of one of the threads.
    //

    if ( !RmpShutdown ) {
        RmpShutdown = TRUE;
        //
        // Wake up the main thread so that it can cleanup.
        //
        SetEvent( RmpRewaitEvent );
    }
    return(ERROR_SUCCESS);

} // RmShutdownProcess



error_status_t
s_RmResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Process a resource control request.

Arguments:

    ResourceId - the resource that is being controlled.

    ControlCode - the control request, reduced to just the function code.

    InBuffer - the input buffer for this control request.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBufferSize - the size of the output buffer.

    BytesReturned - the number of bytes returned.

    Required - the number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    A Win32 error code on failure

--*/

{
    PRESOURCE               Resource;
    DWORD                   status = ERROR_INVALID_FUNCTION;
    PRM_DUE_TIME_ENTRY      pDueTimeEntry = NULL;

    Resource = (PRESOURCE)ResourceId;
    CL_ASSERT(Resource->Signature == RESOURCE_SIGNATURE);

    // Inbuffer is [unique].
    if ( InBuffer == NULL )
        InBufferSize = 0;
    else if ( InBufferSize == 0 )
        InBuffer = NULL;

    //
    // Lock the resource list and send down the control request.
    // The lock is required to synchronize access to the resource list and
    // to serialize any calls to resource DLLs. Only one thread may be
    // calling a resource DLL at any time. This prevents resource DLLs
    // from having to worry about being thread-safe.
    //
    AcquireEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );

    //
    //  If the control code is a notification for resource name change, modify the resource 
    //  name field in the resource structure to reflect that.
    //
    if ( ControlCode == CLUSCTL_RESOURCE_SET_NAME )
    {
        LPWSTR  lpszNewBuffer, lpszOldBuffer;

        lpszNewBuffer = LocalAlloc ( LPTR, InBufferSize );

        if ( lpszNewBuffer != NULL )
        {
            lstrcpyW ( lpszNewBuffer, ( LPWSTR ) InBuffer );
            lpszOldBuffer = InterlockedExchangePointer ( &Resource->ResourceName, lpszNewBuffer );
            LocalFree ( lpszOldBuffer );
        }
    }

    //
    //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
    //  you remove the entry after you finish the entry point call, else you will kill
    //  this process on a FALSE deadlock positive.
    //
    pDueTimeEntry = RmpInsertDeadlockMonitorList ( Resource->DllName,
                                                   Resource->ResourceType,
                                                   Resource->ResourceName,
                                                   L"Resource control" );
    
#ifdef COMRES
    if (Resource->pResourceControl || Resource->pClusterResControl) {
        RmpSetMonitorState(RmonResourceControl, Resource);
        status = RESMON_RESOURCECONTROL( Resource,
                                              ControlCode,
                                              InBuffer,
                                              InBufferSize,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned );
        RmpSetMonitorState(RmonIdle, NULL);
    }
#else
    if ( Resource->ResourceControl ) {
        RmpSetMonitorState(RmonResourceControl, Resource);
        status = (Resource->ResourceControl)( Resource->Id,
                                              ControlCode,
                                              InBuffer,
                                              InBufferSize,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned );
        RmpSetMonitorState(RmonIdle, NULL);
    }
#endif
    RmpRemoveDeadlockMonitorList( pDueTimeEntry );

    if ( status == ERROR_INVALID_FUNCTION ) {

        DWORD characteristics = CLUS_CHAR_UNKNOWN;

        switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_GET_COMMON_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( RmpResourceCommonProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                Required );
            break;

        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                *BytesReturned = 0;
                *Required = sizeof(CLUS_RESOURCE_CLASS_INFO);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_UNKNOWN;
                ptrResClassInfo->SubClass = 0;
                *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
#ifdef COMRES
            if (Resource->dwType == RESMON_TYPE_DLL)
            {
                if ( (Resource->pArbitrate != NULL) &&
                     (Resource->pRelease != NULL) ) {
                    characteristics = CLUS_CHAR_QUORUM;
                }
            }
            else
            {
                if (!Resource->pClusterQuorumResource)
                    characteristics = CLUS_CHAR_QUORUM;
            }
#else
            if ( (Resource->Arbitrate != NULL) &&
                 (Resource->Release != NULL) ) {
                characteristics = CLUS_CHAR_QUORUM;
            }
#endif
            if ( OutBufferSize < sizeof(DWORD) ) {
                *BytesReturned = 0;
                *Required = sizeof(DWORD);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                *BytesReturned = sizeof(DWORD);
                *(LPDWORD)OutBuffer = characteristics;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_GET_FLAGS:
            status = RmpResourceGetFlags( Resource,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned,
                                          Required );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_ENUM_COMMON_PROPERTIES:
            status = RmpResourceEnumCommonProperties( OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned,
                                                      Required );
            break;

        case CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES:
            status = RmpResourceGetCommonProperties( Resource,
                                                     TRUE,
                                                     OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned,
                                                     Required );
            break;

        case CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES:
            status = RmpResourceGetCommonProperties( Resource,
                                                     FALSE,
                                                     OutBuffer,
                                                     OutBufferSize,
                                                     BytesReturned,
                                                     Required );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_COMMON_PROPERTIES:
            status = RmpResourceValidateCommonProperties( Resource,
                                                          InBuffer,
                                                          InBufferSize );
            break;

        case CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES:
            status = RmpResourceSetCommonProperties( Resource,
                                                     InBuffer,
                                                     InBufferSize );
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = RmpResourceEnumPrivateProperties( Resource,
                                                       OutBuffer,
                                                       OutBufferSize,
                                                       BytesReturned,
                                                       Required );
            break;

        case CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES:
            if ( OutBufferSize < sizeof(DWORD) ) {
                *BytesReturned = 0;
                *Required = sizeof(DWORD);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                LPDWORD ptrDword = (LPDWORD) OutBuffer;
                *ptrDword = 0;
                *BytesReturned = sizeof(DWORD);
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = RmpResourceGetPrivateProperties( Resource,
                                                      OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned,
                                                      Required );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = RmpResourceValidatePrivateProperties( Resource,
                                                           InBuffer,
                                                           InBufferSize );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = RmpResourceSetPrivateProperties( Resource,
                                                      InBuffer,
                                                      InBufferSize );
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            //
            //  Chittur Subbaraman (chitturs) - 6/28/99
            //
            //  The setting of the name in the cluster registry is done
            //  in NT5 by clussvc. So, resmon does not have to do any work
            //  except return a success code in case a resource DLL returns
            //  ERROR_INVALID_FUNCTION.
            //
            status = ERROR_SUCCESS;
            break;

        default:
            break;
        }
    } else {
        // If the function is returning a buffer size without
        // copying data, move this info around to satisfy RPC.
        if ( *BytesReturned > OutBufferSize ) {
            *Required = *BytesReturned;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        }
    }

    if ( ( status != ERROR_SUCCESS ) && 
         ( status != ERROR_MORE_DATA ) &&
         ( status != ERROR_INVALID_FUNCTION ) )
    {
    	ClRtlLogPrint(LOG_UNUSUAL,
                      "[RM] s_RmResourceControl: Resource <%1!ws!> control operation "
                      "0x%2!08lx! gives status=%3!u!...\n",
                      Resource->ResourceName,
                      ControlCode,
                      status);
    }

    ReleaseEventListLock( (PPOLL_EVENT_LIST)Resource->EventList );

    return(status);

} // RmResourceControl



error_status_t
s_RmResourceTypeControl(
    IN handle_t IDL_handle,
    IN LPCWSTR ResourceTypeName,
    IN LPCWSTR DllName,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Process a resource type control request.

Arguments:

    IDL_handle - not used.

    ResourceTypeName - the resource type name that is being controlled.

    DllName - the name of the dll.

    ControlCode - the control request, reduced to just the function code.

    InBuffer - the input buffer for this control request.

    InBufferSize - the size of the input buffer.

    OutBuffer - the output buffer.

    OutBufferSize - the size of the output buffer.

    BytesReturned - the number of bytes returned.

    Required - the number of bytes required if OutBuffer is not big enough.

Return Value:

    ERROR_SUCCESS if successful

    A Win32 error code on failure

--*/

{

    RESDLL_FNINFO           ResDllFnInfo;
#ifdef COMRES
    RESDLL_INTERFACES       ResDllInterfaces;
#endif
    DWORD                   status = ERROR_INVALID_FUNCTION;
    DWORD                   characteristics = CLUS_CHAR_UNKNOWN;
    PRM_DUE_TIME_ENTRY      pDueTimeEntry = NULL;

    // InBuffer is [unique].
    if ( InBuffer == NULL )
        InBufferSize = 0;
    else if ( InBufferSize == 0 )
        InBuffer = NULL;

    status = RmpLoadResType(ResourceTypeName, DllName, &ResDllFnInfo,
    #ifdef COMRES
        &ResDllInterfaces,
    #endif
        &characteristics);

    if (status != ERROR_SUCCESS)
    {
        return(status);
    }

    status = ERROR_INVALID_FUNCTION;

    if (ResDllFnInfo.hDll && ResDllFnInfo.pResFnTable)
    {

        PRESOURCE_TYPE_CONTROL_ROUTINE resourceTypeControl = NULL ;

        resourceTypeControl = ResDllFnInfo.pResFnTable->V1Functions.ResourceTypeControl;

        if (resourceTypeControl)
        {
            RmpSetMonitorState(RmonResourceTypeControl, NULL);

            //
            //  Insert the DLL & entry point info into the deadlock monitoring list. Make sure 
            //  you remove the entry after you finish the entry point call, else you will kill
            //  this process on a FALSE deadlock positive.
            //
            pDueTimeEntry = RmpInsertDeadlockMonitorList ( DllName,
                                                           ResourceTypeName,
                                                           NULL,
                                                           L"Resource type control" );
            status = (resourceTypeControl)( ResourceTypeName,
                                        ControlCode,
                                        InBuffer,
                                        InBufferSize,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned );
            RmpSetMonitorState(RmonIdle, NULL);
            RmpRemoveDeadlockMonitorList( pDueTimeEntry );
        }
    }
#ifdef COMRES
    else if (ResDllInterfaces.pClusterResControl)
    {
        HRESULT hr ;
        VARIANT vtIn, vtOut ;
        SAFEARRAY sfIn = {1, 0, 1, 0, InBuffer, {InBufferSize, 0} } ;
        SAFEARRAY sfOut  = {1,  FADF_FIXEDSIZE, 1, 0, OutBuffer, {OutBufferSize, 0} } ;
        SAFEARRAY *psfOut = &sfOut ;
        BSTR pbResourceTypeName ;

        vtIn.vt = VT_ARRAY | VT_UI1 ;
        vtOut.vt = VT_ARRAY | VT_UI1 | VT_BYREF ;

        vtIn.parray = &sfIn ;
        vtOut.pparray = &psfOut ;

        pbResourceTypeName = SysAllocString (ResourceTypeName) ;

        if (pbResourceTypeName == NULL)
        {
            CL_LOGFAILURE( ERROR_NOT_ENOUGH_MEMORY) ;
            goto FnExit ; // Use the default processing
        }
        RmpSetMonitorState(RmonResourceTypeControl, NULL);
        pDueTimeEntry = RmpInsertDeadlockMonitorList ( DllName,
                                                       ResourceTypeName,
                                                       NULL,
                                                       L"Resource Type Control" );
        hr = IClusterResControl_ResourceTypeControl (
                ResDllInterfaces.pClusterResControl,
                pbResourceTypeName,
                ControlCode,
                &vtIn,
                &vtOut,
                BytesReturned,
                &status);

        RmpSetMonitorState(RmonIdle, NULL);
        RmpRemoveDeadlockMonitorList( pDueTimeEntry );
        SysFreeString (pbResourceTypeName) ;

        if (FAILED(hr))
        {
            CL_LOGFAILURE(hr); // Use the default processing
            status = ERROR_INVALID_FUNCTION;
        }
    }
#endif

    if ( status == ERROR_INVALID_FUNCTION ) {

        switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_GET_COMMON_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( RmpResourceTypeCommonProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                *BytesReturned = 0;
                *Required = sizeof(CLUS_RESOURCE_CLASS_INFO);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_UNKNOWN;
                ptrResClassInfo->SubClass = 0;
                *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
            if ( OutBufferSize < sizeof(DWORD) ) {
                *BytesReturned = 0;
                *Required = sizeof(DWORD);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                *BytesReturned = sizeof(DWORD);
                *(LPDWORD)OutBuffer = characteristics;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_FLAGS:
            status = RmpResourceTypeGetFlags( ResourceTypeName,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REGISTRY_CHECKPOINTS:
            *BytesReturned = 0;
            *Required = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_COMMON_PROPERTIES:
            status = RmpResourceTypeEnumCommonProperties( ResourceTypeName,
                                                          OutBuffer,
                                                          OutBufferSize,
                                                          BytesReturned,
                                                          Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES:
            status = RmpResourceTypeGetCommonProperties( ResourceTypeName,
                                                         TRUE,
                                                         OutBuffer,
                                                         OutBufferSize,
                                                         BytesReturned,
                                                         Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES:
            status = RmpResourceTypeGetCommonProperties( ResourceTypeName,
                                                         FALSE,
                                                         OutBuffer,
                                                         OutBufferSize,
                                                         BytesReturned,
                                                         Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_VALIDATE_COMMON_PROPERTIES:
            status = RmpResourceTypeValidateCommonProperties( ResourceTypeName,
                                                              InBuffer,
                                                              InBufferSize );
            break;

        case CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES:
            status = RmpResourceTypeSetCommonProperties( ResourceTypeName,
                                                         InBuffer,
                                                         InBufferSize );
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = RmpResourceTypeEnumPrivateProperties( ResourceTypeName,
                                                           OutBuffer,
                                                           OutBufferSize,
                                                           BytesReturned,
                                                           Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES:
            if ( OutBufferSize < sizeof(DWORD) ) {
                *BytesReturned = 0;
                *Required = sizeof(DWORD);
                if ( OutBuffer == NULL ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = ERROR_MORE_DATA;
                }
            } else {
                LPDWORD ptrDword = (LPDWORD) OutBuffer;
                *ptrDword = 0;
                *BytesReturned = sizeof(DWORD);
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES:
            status = RmpResourceTypeGetPrivateProperties( ResourceTypeName,
                                                          OutBuffer,
                                                          OutBufferSize,
                                                          BytesReturned,
                                                          Required );
            break;

        case CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES:
            status = RmpResourceTypeValidatePrivateProperties( ResourceTypeName,
                                                               InBuffer,
                                                               InBufferSize );
            break;

        case CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES:
            status = RmpResourceTypeSetPrivateProperties( ResourceTypeName,
                                                          InBuffer,
                                                          InBufferSize );
            break;

        default:
            break;

        }
    } else {
        // If the function is returning a buffer size without
        // copying data, move this info around to satisfy RPC.
        if ( *BytesReturned > OutBufferSize ) {
            *Required = *BytesReturned;
            *BytesReturned = 0;
        }
        if ( (status == ERROR_MORE_DATA) &&
             (OutBuffer == NULL) ) {
            status = ERROR_SUCCESS;
        }
    }


FnExit:

    if (ResDllFnInfo.hDll)
        FreeLibrary(ResDllFnInfo.hDll);
#ifdef COMRES
    if (ResDllInterfaces.pClusterResource)
        IClusterResource_Release (ResDllInterfaces.pClusterResource) ;
    if (ResDllInterfaces.pClusterQuorumResource)
        IClusterQuorumResource_Release (ResDllInterfaces.pClusterQuorumResource) ;
    if (ResDllInterfaces.pClusterResControl)
        IClusterResControl_Release (
            ResDllInterfaces.pClusterResControl
            ) ;
#endif


    return(status);

} // RmResourceTypeControl






LPWSTR
GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )

/*++

Routine Description:

    Reads a REG_SZ parameter from the cluster regitry, and allocates the
    necessary storage for it.

Arguments:

    ClusterKey - supplies the cluster key where the parameter is stored.

    ValueName - supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter value on success.

    NULL on failure.

--*/

{
    LPWSTR  value;
    DWORD   valueLength;
    DWORD   valueType;
    DWORD   status;

    valueLength = 0;
    status = ClusterRegQueryValue( ClusterKey,
                                   ValueName,
                                   &valueType,
                                   NULL,
                                   &valueLength );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_MORE_DATA) ) {
        SetLastError(status);
        return(NULL);
    }
    if ( valueType == REG_SZ ) {
        valueLength += sizeof(UNICODE_NULL);
    }
    value = LocalAlloc(LMEM_FIXED, valueLength);
    if ( value == NULL ) {
        return(NULL);
    }
    status = ClusterRegQueryValue(ClusterKey,
                                  ValueName,
                                  &valueType,
                                  (LPBYTE)value,
                                  &valueLength);
    if ( status != ERROR_SUCCESS) {
        LocalFree(value);
        SetLastError(status);
        value = NULL;
    }

    return(value);

} // GetParameter

error_status_t
s_RmUpdateDeadlockDetectionParams(
    IN handle_t IDL_handle,
    IN DWORD dwDeadlockDetectionTimeout
    )

/*++

Routine Description:

    Changes the poll intervals defined for a resource.

Arguments:

    IDL_handle - Unused.

    dwDeadlockDetectionTimeout - Deadlock detection timeout.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise

--*/

{
    DWORD   dwStatus = ERROR_SUCCESS;

    //
    //  Use the default for deadlock timeout if 0 is passed in.
    //
    dwDeadlockDetectionTimeout = 
        ( dwDeadlockDetectionTimeout == 0 ) ? 
            CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_TIMEOUT_SECS :
            dwDeadlockDetectionTimeout;
        
    //
    // Initialize the deadlock monitoring subsystem if it is not already initialized.
    //
    dwStatus = RmpDeadlockMonitorInitialize ( dwDeadlockDetectionTimeout );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] s_RmUpdateDeadlockDetectionParams: Unable to initialize the deadlock monitor, error %1!u!.\n",
                      dwStatus);
        goto FnExit;
    }

    dwStatus = RmpUpdateDeadlockDetectionParams ( dwDeadlockDetectionTimeout );

    if ( dwStatus != ERROR_SUCCESS ) 
    {
        ClRtlLogPrint(LOG_CRITICAL, "[RM] s_RmUpdateDeadlockDetectionParams: Unable to update the parameters for deadlock monitor, error %1!u!.\n",
                      dwStatus);
        goto FnExit;
    }

FnExit:
    return ( dwStatus );
} // s_RmUpdateDeadlockDetectionParams

#ifdef COMRES
RESID
Resmon_Open (
    IN PRESOURCE Resource,
    IN HKEY ResourceKey
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pOpen) (Resource->ResourceName, ResourceKey, Resource) ;
    }
    else
    {
        HRESULT hr ;
        OLERESID ResId = 0 ;

        BSTR pbResourceName = SysAllocString (Resource->ResourceName) ;

        if (pbResourceName == NULL)
        {
            SetLastError ( ERROR_NOT_ENOUGH_MEMORY) ;
            CL_LOGFAILURE( ERROR_NOT_ENOUGH_MEMORY) ;
            goto ErrorExit ;
        }

        hr = IClusterResource_Open(Resource->pClusterResource, pbResourceName, (OLEHKEY)ResourceKey,
                        (OLERESOURCE_HANDLE)Resource, &ResId);

        SysFreeString (pbResourceName) ;

        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
        }
ErrorExit:
        return (RESID) ResId ;
    }
}

VOID
Resmon_Close (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        (Resource->pClose) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;

        hr = IClusterResource_Close (Resource->pClusterResource, (OLERESID)Resource->Id);
        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
        }
    }
}

DWORD
Resmon_Online (
    IN PRESOURCE Resource,
    IN OUT LPHANDLE EventHandle
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pOnline) (Resource->Id, EventHandle) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterResource_Online(Resource->pClusterResource, (OLERESID)Resource->Id, (LPOLEHANDLE)EventHandle, &lRet);

        if (FAILED(hr))
        {
            SetLastError (lRet = hr) ;  // Return a error
            CL_LOGFAILURE(hr);
        }
        return lRet ;
    }
}

DWORD
Resmon_Offline (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pOffline) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterResource_Offline(Resource->pClusterResource, (OLERESID)Resource->Id, &lRet);

        if (FAILED(hr))
        {
            SetLastError (lRet = hr) ;  // Return a error
            CL_LOGFAILURE(hr);
        }
        return lRet ;
    }
}

VOID
Resmon_Terminate (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        (Resource->pTerminate) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;

        hr = IClusterResource_Terminate (Resource->pClusterResource, (OLERESID)Resource->Id);
        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
        }
    }
}

BOOL
Resmon_LooksAlive (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pLooksAlive) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterResource_LooksAlive (Resource->pClusterResource, (OLERESID)Resource->Id, &lRet);

        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
            lRet = 0 ; // Incase of failure return 0 to indicate LooksAlive is failed.
        }
        return lRet ;
    }
}

BOOL
Resmon_IsAlive (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pIsAlive) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterResource_IsAlive (Resource->pClusterResource, (OLERESID)Resource->Id, &lRet);

        if (FAILED(hr))
        {
            SetLastError (hr) ;
            CL_LOGFAILURE(hr);
            lRet = 0 ; // Incase of failure return 0 to indicate IsAlive is failed.
        }
        return lRet ;
    }
}

DWORD
Resmon_Arbitrate (
    IN PRESOURCE Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pArbitrate) (Resource->Id, LostQuorumResource) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterQuorumResource_QuorumArbitrate(Resource->pClusterQuorumResource, (OLERESID)Resource->Id, (POLEQUORUM_RESOURCE_LOST)LostQuorumResource, &lRet);

        if (FAILED(hr))
        {
            SetLastError (lRet = hr) ;
            CL_LOGFAILURE(hr);
        }
        return lRet ;
    }
}

DWORD
Resmon_Release (
    IN PRESOURCE Resource
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pRelease) (Resource->Id) ;
    }
    else
    {
        HRESULT hr ;
        long lRet ;

        hr = IClusterQuorumResource_QuorumRelease(Resource->pClusterQuorumResource, (OLERESID)Resource->Id, &lRet);

        if (FAILED(hr))
        {
            SetLastError (lRet = hr) ;
            CL_LOGFAILURE(hr);
        }
        return lRet ;
    }
}

DWORD
Resmon_ResourceControl (
    IN PRESOURCE Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    if (Resource->dwType == RESMON_TYPE_DLL)
    {
        return (Resource->pResourceControl)( Resource->Id,
                                              ControlCode,
                                              InBuffer,
                                              InBufferSize,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned );
    }
    else
    {
        long status ;
        HRESULT hr ;
        VARIANT vtIn, vtOut ;
        SAFEARRAY sfIn = {1, 0, 1, 0, InBuffer, {InBufferSize, 0} } ;
        SAFEARRAY sfOut  = {1,  FADF_FIXEDSIZE, 1, 0, OutBuffer, {OutBufferSize, 0} } ;
        SAFEARRAY *psfOut = &sfOut ;

        vtIn.vt = VT_ARRAY | VT_UI1 ;
        vtOut.vt = VT_ARRAY | VT_UI1 | VT_BYREF ;

        vtIn.parray = &sfIn ;
        vtOut.pparray = &psfOut ;

        hr = IClusterResControl_ResourceControl (
                Resource->pClusterResControl,
                (OLERESID)Resource->Id,
                (long)ControlCode,
                &vtIn,
                &vtOut,
                (long *)BytesReturned,
                &status);

        if (FAILED(hr))
        {
            CL_LOGFAILURE(hr); // Use the default processing
            status = ERROR_INVALID_FUNCTION;
        }

        return (DWORD)status ;
    }
}

#endif  // COMRES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\apip.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    apip.h

Abstract:

    Private data structures and procedure prototypes for
    the Cluster API subcomponent of the NT Cluster
    Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/
#include "service.h"
#include "clusapi.h"
#include "api_rpc.h"

#define LOG_CURRENT_MODULE LOG_MODULE_API


//
// Event processing routine
//
DWORD
WINAPI
ApipEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

//
// Data definitions global to the API module.
//
typedef enum _API_INIT_STATE {
    ApiStateUninitialized,
    ApiStateOffline,
    ApiStateReadOnly,
    ApiStateOnline
} API_INIT_STATE;

extern API_INIT_STATE ApiState;
extern LIST_ENTRY NotifyListHead;
extern CRITICAL_SECTION NotifyListLock;

#define API_CHECK_INIT() \
            if (ApiState != ApiStateOnline) return(ERROR_SHARING_PAUSED)

#define API_ASSERT_INIT() CL_ASSERT(ApiState == ApiStateOnline)

//
// Notification port
//
typedef struct _NOTIFY_PORT {
    LIST_ENTRY ListEntry;
    CRITICAL_SECTION Lock;
    CL_QUEUE Queue;
    DWORD Filter;
    LIST_ENTRY InterestList;
    LIST_ENTRY RegistryList;
} NOTIFY_PORT, *PNOTIFY_PORT;


//
// Common API handle structure. Every RPC context handle points to one of these.
// This allows us to do our own type checking since RPC does not do this for us.
//
#define API_NOTIFY_HANDLE       1
#define API_NODE_HANDLE         2
#define API_GROUP_HANDLE        3
#define API_RESOURCE_HANDLE     4
#define API_KEY_HANDLE          5
#define API_CLUSTER_HANDLE      6
#define API_NETWORK_HANDLE      7
#define API_NETINTERFACE_HANDLE 8

#define HANDLE_DELETED          1

typedef struct _API_HANDLE {
    USHORT Type;
    USHORT Flags;
    LIST_ENTRY NotifyList;
    union {
        PNOTIFY_PORT Notify;
        PNM_NODE     Node;
        PFM_GROUP    Group;
        PFM_RESOURCE Resource;
        HDMKEY       Key;
        PVOID        Cluster;
        PNM_NETWORK  Network;
        PNM_INTERFACE NetInterface;
    };
} API_HANDLE, *PAPI_HANDLE;

#define DELETE_HANDLE(_handle_) (((PAPI_HANDLE)(_handle_))->Flags |= HANDLE_DELETED)
#define IS_HANDLE_DELETED(_handle_) (((PAPI_HANDLE)(_handle_))->Flags & HANDLE_DELETED)

#define VALIDATE_NOTIFY(_notify_, _handle_)                             \
    if (((_handle_) == NULL) ||                                         \
        (((PAPI_HANDLE)(_handle_))->Type != API_NOTIFY_HANDLE) ||       \
        IS_HANDLE_DELETED(_handle_)) {                                  \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_notify_) = ((PAPI_HANDLE)(_handle_))->Notify;                 \
    }

#define VALIDATE_NODE(_node_, _handle_)                                 \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NODE_HANDLE)) {         \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_node_) = ((PAPI_HANDLE)(_handle_))->Node;                     \
    }

#define VALIDATE_NODE_EXISTS(_node_, _handle_)                          \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NODE_HANDLE)) {         \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_node_) = ((PAPI_HANDLE)(_handle_))->Node;                     \
        if (!OmObjectInserted((_node_))) {                              \
            return(ERROR_NODE_NOT_AVAILABLE);                           \
        }                                                               \
    }

#define VALIDATE_GROUP(_group_, _handle_)                               \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_GROUP_HANDLE)) {        \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_group_) = ((PAPI_HANDLE)(_handle_))->Group;                   \
    }

#define VALIDATE_GROUP_EXISTS(_group_, _handle_)                        \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_GROUP_HANDLE)) {        \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_group_) = ((PAPI_HANDLE)(_handle_))->Group;                   \
        if (!OmObjectInserted((_group_))) {                             \
            return(ERROR_GROUP_NOT_AVAILABLE);                          \
        }                                                               \
    }

#define VALIDATE_RESOURCE(_resource_, _handle_)                         \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_RESOURCE_HANDLE)) {     \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_resource_) = ((PAPI_HANDLE)(_handle_))->Resource;             \
    }

#define VALIDATE_RESOURCE_EXISTS(_resource_, _handle_)                  \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_RESOURCE_HANDLE)) {     \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_resource_) = ((PAPI_HANDLE)(_handle_))->Resource;             \
        if (!OmObjectInserted((_resource_))) {                          \
            return(ERROR_RESOURCE_NOT_AVAILABLE);                       \
        }                                                               \
    }

#define VALIDATE_KEY(_key_, _handle_)                                   \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_KEY_HANDLE)) {          \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_key_) = ((PAPI_HANDLE)(_handle_))->Key;                       \
    }

#define VALIDATE_NETWORK(_network_, _handle_)                           \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NETWORK_HANDLE)) {      \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_network_) = ((PAPI_HANDLE)(_handle_))->Network;               \
    }

#define VALIDATE_NETWORK_EXISTS(_network_, _handle_)                    \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NETWORK_HANDLE)) {      \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_network_) = ((PAPI_HANDLE)(_handle_))->Network;               \
        if (!OmObjectInserted((_network_))) {                           \
            return(ERROR_NETWORK_NOT_AVAILABLE);                        \
        }                                                               \
    }

#define VALIDATE_NETINTERFACE(_netinterface_, _handle_)                 \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NETINTERFACE_HANDLE)) { \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_netinterface_) = ((PAPI_HANDLE)(_handle_))->NetInterface;     \
    }

#define VALIDATE_NETINTERFACE_EXISTS(_netinterface_, _handle_)          \
    if ((_handle_ == NULL) ||                                           \
        (((PAPI_HANDLE)(_handle_))->Type != API_NETINTERFACE_HANDLE)) { \
        return(ERROR_INVALID_HANDLE);                                   \
    } else {                                                            \
        (_netinterface_) = ((PAPI_HANDLE)(_handle_))->NetInterface;     \
        if (!OmObjectInserted((_netinterface_))) {                      \
            return(ERROR_NETWORK_NOT_AVAILABLE);                        \
        }                                                               \
    }

//
// Common routines
//

#define INITIAL_ENUM_LIST_ALLOCATION    8

#define ENUM_SIZE(Entries) ((Entries-1) * sizeof(ENUM_ENTRY) + sizeof(ENUM_LIST))

VOID
ApipAddToEnum(
    IN PENUM_LIST *pEnum,
    IN DWORD *pAllocated,
    IN LPCWSTR Name,
    IN DWORD Type
    );

LPWSTR
ApipGetObjectName(
    IN PVOID Object
    );

VOID
ApipRundownNotify(
    IN PAPI_HANDLE Handle
    );

RPC_STATUS
ApipConnectCallback(
    IN RPC_IF_ID * Interface,
    IN void * Context
    );

DWORD
ApipUnblockGetNotifyCall(
    PNOTIFY_PORT pPort
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resmon\resmonp.h ===
#ifndef _RESMONP_H
#define _RESMONP_H


/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    resmonp.h

Abstract:

    Private header file for the Resource Monitor component

Author:

    John Vert (jvert) 30-Nov-1995

Revision History:
    Sivaprasad Padisetty (sivapad) 06-18-1997  Added the COM support

--*/
#include "windows.h"
#include "cluster.h"
#include "rm_rpc.h"
#include "monmsg.h"

#ifdef COMRES
#define COBJMACROS
#include "comres.h"
#endif

#define LOG_CURRENT_MODULE LOG_MODULE_RESMON

//
// internal module identifiers. Not used with ClRtl logging code. Used to
// track lock acquisitions.
//
#define RESMON_MODULE_EVNTLIST 1
#define RESMON_MODULE_NOTIFY   2
#define RESMON_MODULE_POLLER   3
#define RESMON_MODULE_PROPERTY 4
#define RESMON_MODULE_RESLIST  5
#define RESMON_MODULE_RESMON   6
#define RESMON_MODULE_RMAPI    7
#define RESMON_MODULE_DLOCK    8


//
// Define the maximum number of resources handled per thread.
// (This value must be smaller than MAXIMUM_WAIT_OBJECTS-2!)
//
#define MAX_RESOURCES_PER_THREAD 27

//
// 2 additional handles that are watched -- ListNotify and hEventShutdown
//
#define MAX_HANDLES_PER_THREAD (MAX_RESOURCES_PER_THREAD+2)

//
// Define the maximum number of threads.
// (This value can be up to MAXIMUM_WAIT_OBJECTS, however the first two
//  entries are taken by events, so in fact we have 2 less threads available).
//
#define MAX_THREADS (MAXIMUM_WAIT_OBJECTS)

//
// Define structure and flags used for each resource entry
//
#define RESOURCE_SIGNATURE 'crsR'

extern RESUTIL_PROPERTY_ITEM RmpResourceCommonProperties[];

extern RESUTIL_PROPERTY_ITEM RmpResourceTypeCommonProperties[];

typedef struct _POLL_EVENT_LIST;
typedef struct _POLL_EVENT_LIST *PPOLL_EVENT_LIST;


//
// Lock Info for debugging lock acquires/releases
//
typedef struct _LOCK_INFO {
    DWORD   Module: 6;
    DWORD   ThreadId: 11;
    DWORD   LineNumber: 15;
} LOCK_INFO, *PLOCK_INFO;

// 
// Entry points
//
#define RESDLL_ENTRY_CLOSE      0x00000001
#define RESDLL_ENTRY_TERMINATE  0x00000002

//
// Flags
//
#define RESOURCE_INSERTED 1

typedef struct _RESOURCE {
    ULONG Signature;                // 'Rsrc'
    ULONG Flags;
    LIST_ENTRY ListEntry;           // for linking onto monitoring list
    LPWSTR DllName;
    LPWSTR ResourceType;
    LPWSTR ResourceId;
    LPWSTR ResourceName;
    DWORD LooksAlivePollInterval;
    DWORD IsAlivePollInterval;
    HINSTANCE Dll;                  // handle to resource's DLL
    RESID Id;
    HANDLE  EventHandle;            // async error notification handle
    HANDLE  OnlineEvent;

#ifdef COMRES
#define RESMON_TYPE_DLL    1
#define RESMON_TYPE_COM    2

    // TODO define this as a union
    IClusterResource          *pClusterResource ;
    IClusterResControl        *pClusterResControl ;
    IClusterQuorumResource    *pClusterQuorumResource ;

    DWORD dwType ; // Type of resource whether it is DLL or a COMResources

    POPEN_ROUTINE pOpen;
    PCLOSE_ROUTINE pClose;
    PONLINE_ROUTINE pOnline;
    POFFLINE_ROUTINE pOffline;
    PTERMINATE_ROUTINE pTerminate;
    PIS_ALIVE_ROUTINE pIsAlive;
    PLOOKS_ALIVE_ROUTINE pLooksAlive;
    PARBITRATE_ROUTINE pArbitrate;
    PRELEASE_ROUTINE pRelease;
    PRESOURCE_CONTROL_ROUTINE pResourceControl;
    PRESOURCE_TYPE_CONTROL_ROUTINE pResourceTypeControl;
#else
    POPEN_ROUTINE Open;
    PCLOSE_ROUTINE Close;
    PONLINE_ROUTINE Online;
    POFFLINE_ROUTINE Offline;
    PTERMINATE_ROUTINE Terminate;
    PIS_ALIVE_ROUTINE IsAlive;
    PLOOKS_ALIVE_ROUTINE LooksAlive;
    PARBITRATE_ROUTINE Arbitrate;
    PRELEASE_ROUTINE Release;
    PRESOURCE_CONTROL_ROUTINE ResourceControl;
    PRESOURCE_TYPE_CONTROL_ROUTINE ResourceTypeControl;
#endif
    CLUSTER_RESOURCE_STATE State;
    ULONG IsAliveCount;
    ULONG IsAliveRollover;
    RM_NOTIFY_KEY NotifyKey;
    PPOLL_EVENT_LIST EventList;
    HANDLE TimerEvent;              // Timer event for offline completion.
    DWORD  PendingTimeout;
    DWORD  CheckPoint;              // Online pending checkpoint
    BOOL   IsArbitrated;
    DWORD  dwEntryPoint;            // Number indicating which resdll entry point is called.
    BOOL   fArbLock;                // Variable used for synchronizing arbitrate with close and rundown
} RESOURCE, *PRESOURCE;
#ifdef COMRES

extern DWORD tidActiveXWorker ;    // ThreadID for the COM worker thread

#define WM_RES_CREATE WM_USER+1
#define WM_RES_OPEN WM_USER+2
#define WM_RES_CLOSE WM_USER+3
#define WM_RES_ONLINE WM_USER+4
#define WM_RES_OFFLINE WM_USER+5
#define WM_RES_TERMINATE WM_USER+6
#define WM_RES_ISALIVE WM_USER+7
#define WM_RES_LOOKSALIVE WM_USER+8

#define WM_RES_ARBITRATE WM_USER+9
#define WM_RES_RELEASE WM_USER+10

#define WM_RES_EXITTHREAD WM_USER+11

#define WM_RES_FREE WM_USER+12

#define WM_RES_RESOURCECONTROL WM_USER+11
#define WM_RES_RESOURCETYPECONTROL WM_USER+12

DWORD WINAPI ActiveXWorkerThread (LPVOID pThreadInfo) ;

typedef struct {
    PRESOURCE Resource ;
    LPVOID Data1 ; // For ResourceKey in Open & EvenHandle in Online
    DWORD status ; // This is the Com Status indicating if the function is actually called.
    LONG Ret ;  // Actual Return Value of the functions like IsAlive, LooksAlive etc.
} COMWORKERTHREADPARAM, *PCOMWORKERTHREADPARAM  ;

DWORD PostWorkerMessage (DWORD tid, UINT msg, PCOMWORKERTHREADPARAM pData) ;

RESID
Resmon_Open (
    IN PRESOURCE Resource,
    IN HKEY ResourceKey
    );

VOID
Resmon_Close (
    IN PRESOURCE Resource
    );

DWORD
Resmon_Online (
    IN PRESOURCE Resource,
    IN OUT LPHANDLE EventHandle
    );

DWORD
Resmon_Offline (
    IN PRESOURCE Resource
    );

VOID
Resmon_Terminate (
    IN PRESOURCE Resource
    );

BOOL
Resmon_LooksAlive (
    IN PRESOURCE Resource
    );

BOOL
Resmon_IsAlive (
    IN PRESOURCE Resource
    );

DWORD
Resmon_Arbitrate (
    IN PRESOURCE Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    ) ;

DWORD
Resmon_Release (
    IN PRESOURCE Resource
    ) ;

DWORD
Resmon_ResourceControl (
    IN PRESOURCE Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    ) ;

#define RESMON_OPEN(Resource, ResKey) Resmon_Open(Resource, ResKey)

#define RESMON_CLOSE(Resource) Resmon_Close(Resource)

#define RESMON_ONLINE(Resource, EventHandle) Resmon_Online(Resource, EventHandle)

#define RESMON_OFFLINE(Resource) Resmon_Offline(Resource)

#define RESMON_TERMINATE(Resource) Resmon_Terminate(Resource)

#define RESMON_ISALIVE(Resource) Resmon_IsAlive(Resource)

#define RESMON_LOOKSALIVE(Resource) Resmon_LooksAlive(Resource)

#define RESMON_ARBITRATE(Resource, RmpLostQuorumResource) \
            Resmon_Arbitrate (Resource, RmpLostQuorumResource)

#define RESMON_RELEASE(Resource) \
            Resmon_Release (Resource)

#define RESMON_RESOURCECONTROL(Resource, ControlCode, InBuffer, InBufferSize, OutBuffer, OutBufferSize, BytesReturned) \
            Resmon_ResourceControl (Resource, ControlCode, InBuffer, InBufferSize, OutBuffer, OutBufferSize, BytesReturned)

#endif // COMRES

typedef struct _RESDLL_FNINFO{
    HINSTANCE               hDll;
    PCLRES_FUNCTION_TABLE   pResFnTable;
}RESDLL_FNINFO, *PRESDLL_FNINFO;

#ifdef COMRES
typedef struct _RESDLL_INTERFACES{
    IClusterResource          *pClusterResource ;
    IClusterResControl        *pClusterResControl ;
    IClusterQuorumResource    *pClusterQuorumResource ;
}RESDLL_INTERFACES, *PRESDLL_INTERFACES;
#endif

typedef struct _MONITOR_BUCKET {
    LIST_ENTRY BucketList;          // For chaining buckets together.
    LIST_ENTRY ResourceList;        // List of resources in this bucket
    DWORDLONG DueTime;              // Next time that these resources should be polled
    DWORDLONG Period;               // Periodic interval of this bucket.
} MONITOR_BUCKET, *PMONITOR_BUCKET;


//
// The Poll Event List structure.
//

typedef struct _POLL_EVENT_LIST {
    LIST_ENTRY Next;                // Next event list
    LIST_ENTRY BucketListHead;      // Bucket Listhead for this list/thread
    DWORD   NumberOfBuckets;        // Number of entries on this bucket list
    DWORD   NumberOfResources;      // Number of resources on this event list
    CRITICAL_SECTION ListLock;      // Critical section to add/remove events
    LOCK_INFO PPrevPrevListLock;
    LOCK_INFO PrevPrevListLock;
    LOCK_INFO PrevListLock;
    LOCK_INFO LastListLock;
    LOCK_INFO LastListUnlock;
    LOCK_INFO PrevListUnlock;
    LOCK_INFO PrevPrevListUnlock;
    LOCK_INFO PPrevPrevListUnlock;
    HANDLE  ListNotify;             // List change notification
    HANDLE  ThreadHandle;           // Handle of thread processing this list
    DWORD   EventCount;             // Number of events/resources in lists
    HANDLE  Handle[MAX_HANDLES_PER_THREAD]; // Array of handles to wait for
    PRESOURCE Resource[MAX_HANDLES_PER_THREAD]; // Resources that match handles
    PRESOURCE LockOwnerResource;    // Resource that owns the eventlist lock
    DWORD     MonitorState;         // Resdll entry point called. 
    HANDLE    hEventShutdown;       // Shutdown notification
} POLL_EVENT_LIST, *PPOLL_EVENT_LIST;


#define POLL_GRANULARITY (10)       // 10ms

#define PENDING_TIMEOUT  (3*1000*60) // 3 minutes for pending requests to finish

#define  RM_DMP_FILE_NAME   L"\\resrcmon.dmp"

//
//  Used in RmpAcquireSpinLock
//
#define RESMON_MAX_SLOCK_RETRIES    400

//
//  Used in deadlock monitoring
//
#define RESMON_MAX_NAME_LEN                     80

//
//  There could at most MAX_THREADS blocked inside resource dll entry points making resource
//  calls. Let us add a few more for resource type controls.
//
#define RESMON_MAX_DEADLOCK_MONITOR_ENTRIES     MAX_THREADS * 2

//
//  Interval at which the deadlock timer thread kicks in
//
#define RESMON_DEADLOCK_TIMER_INTERVAL          5 * 1000        // 5 secs

#define RM_DUE_TIME_MONITORED_ENTRY_SIGNATURE       'mLDD'
#define RM_DUE_TIME_FREE_ENTRY_SIGNATURE            'fLDD'
#define RM_DUE_TIME_FREE_LIST_HEAD_SIGNATURE        'hLDD'
#define RM_DUE_TIME_MONITORED_LIST_HEAD_SIGNATURE   'tLDD'

//
//  Structures used for deadlock monitoring
//
typedef struct _RM_DUE_TIME_MONITORED_LIST_HEAD
{
    DWORD                       dwSignature;            // Signature of this list head
    ULONGLONG                   ullDeadLockTimeoutSecs; // Deadlock timeout in seconds                       
    LIST_ENTRY                  leDueTimeEntry;         // Link to the first (& last) entry
} RM_DUE_TIME_MONITORED_LIST_HEAD, *PRM_DUE_TIME_MONITORED_LIST_HEAD;

typedef struct _RM_DUE_TIME_FREE_LIST_HEAD
{
    DWORD                       dwSignature;        // Signature of this list head
    LIST_ENTRY                  leDueTimeEntry;     // Link to the first (& last) entry
} RM_DUE_TIME_FREE_LIST_HEAD, *PRM_DUE_TIME_FREE_LIST_HEAD;

typedef struct _RM_DUE_TIME_ENTRY
{
    DWORD                       dwSignature;        // Signature of this entry
    LIST_ENTRY                  leDueTimeEntry;     // Link to the next (& previous) entry
    RESOURCE_MONITOR_STATE      EntryPointCalled;   // Resource DLL entry point name
    ULARGE_INTEGER              uliDueTime;         // Time at which a deadlock will be flagged
    DWORD                       dwThreadId;         // Thread ID tha insert this entry
    WCHAR                       szResourceDllName[ RESMON_MAX_NAME_LEN ];
                                                    // Name of the resource dll whose entry point
                                                    // has been called
    WCHAR                       szResourceTypeName [ RESMON_MAX_NAME_LEN ];
                                                    // Name of the resource type
    WCHAR                       szResourceName [ RESMON_MAX_NAME_LEN ];
                                                    // Name of the resource if this is a 
                                                    // resource entry point
    WCHAR                       szEntryPointName [ 30 ]; 
                                                    // Name of the entry point called
} RM_DUE_TIME_ENTRY, *PRM_DUE_TIME_ENTRY;

//
// Private helper macros and functions
//
VOID
RmpSetEventListLockOwner(
    IN PRESOURCE pResource,
    IN DWORD     dwMonitorState
    );

#define RmpAlloc(size) LocalAlloc(LMEM_FIXED, (size))
#define RmpFree(size)  LocalFree((size))

#define RmpSetMonitorState(state, resource)                                \
    EnterCriticalSection(&RmpMonitorStateLock);                            \
    GetSystemTimeAsFileTime((PFILETIME)&RmpSharedState->LastUpdate);       \
    RmpSharedState->State = (state);                                       \
    RmpSharedState->ActiveResource = (HANDLE)(resource);                   \
    LeaveCriticalSection(&RmpMonitorStateLock);                            \
    RmpSetEventListLockOwner( resource, state )

#define AcquireListLock() \
    EnterCriticalSection( &RmpListLock ); \
    RmpListPPrevPrevLock = RmpListPrevPrevLock; \
    RmpListPrevPrevLock = RmpListPrevLock; \
    RmpListPrevLock = RmpListLastLock; \
    RmpListLastLock.Module = RESMON_MODULE; \
    RmpListLastLock.ThreadId = GetCurrentThreadId(); \
    RmpListLastLock.LineNumber = __LINE__

#define ReleaseListLock() \
    RmpListPPrevPrevUnlock = RmpListPrevPrevUnlock; \
    RmpListPrevPrevUnlock = RmpListPrevUnlock; \
    RmpListPrevUnlock = RmpListLastUnlock; \
    RmpListLastUnlock.Module = RESMON_MODULE; \
    RmpListLastUnlock.ThreadId = GetCurrentThreadId(); \
    RmpListLastUnlock.LineNumber =  __LINE__; \
    LeaveCriticalSection( &RmpListLock )

#define AcquireEventListLock( EventList ) \
    EnterCriticalSection( &(EventList)->ListLock ); \
    (EventList)->PPrevPrevListLock = (EventList)->PrevPrevListLock; \
    (EventList)->PrevPrevListLock = (EventList)->PrevListLock; \
    (EventList)->PrevListLock = (EventList)->LastListLock; \
    (EventList)->LastListLock.Module = RESMON_MODULE; \
    (EventList)->LastListLock.ThreadId = GetCurrentThreadId(); \
    (EventList)->LastListLock.LineNumber = __LINE__

#define ReleaseEventListLock( EventList ) \
    (EventList)->PPrevPrevListUnlock = (EventList)->PrevPrevListUnlock; \
    (EventList)->PrevPrevListUnlock = (EventList)->PrevListUnlock; \
    (EventList)->PrevListUnlock = (EventList)->LastListUnlock; \
    (EventList)->LastListUnlock.Module = RESMON_MODULE; \
    (EventList)->LastListUnlock.ThreadId = GetCurrentThreadId(); \
    (EventList)->LastListUnlock.LineNumber = __LINE__; \
    (EventList)->LockOwnerResource = NULL; \
    (EventList)->MonitorState = RmonIdle; \
    LeaveCriticalSection( &(EventList)->ListLock )

//
// Data global to Resource Monitor
//
extern CRITICAL_SECTION RmpListLock;
extern LOCK_INFO RmpListPPrevPrevLock;
extern LOCK_INFO RmpListPrevPrevLock;
extern LOCK_INFO RmpListPrevLock;
extern LOCK_INFO RmpListLastLock;
extern LOCK_INFO RmpListLastUnlock;
extern LOCK_INFO RmpListPrevUnlock;
extern LOCK_INFO RmpListPrevPrevUnlock;
extern LOCK_INFO RmpListPPrevPrevUnlock;

extern CRITICAL_SECTION RmpMonitorStateLock;
extern PMONITOR_STATE RmpSharedState;
extern CL_QUEUE RmpNotifyQueue;
extern HKEY RmpResourcesKey;
extern HKEY RmpResTypesKey;
extern HCLUSTER RmpHCluster;
extern BOOL RmpShutdown;
extern LIST_ENTRY RmpEventListHead;
extern HANDLE RmpWaitArray[];
extern HANDLE RmpRewaitEvent;
extern HANDLE RmpClusterProcess;
extern DWORD RmpNumberOfThreads;
extern BOOL  RmpDebugger;
extern BOOL  g_fRmpClusterProcessCrashed;

//
// Interfaces for manipulating the resource lists
//
VOID
RmpRundownResources(
    VOID
    );

DWORD
RmpInsertResourceList(
    IN PRESOURCE Resource,
    IN OPTIONAL PPOLL_EVENT_LIST pPollEventList
    );

VOID
RmpRemoveResourceList(
    IN PRESOURCE Resource
    );


DWORD
RmpOfflineResource(
    IN RESID ResourceId,
    IN BOOL  Shutdown,
    OUT DWORD *pdwState
    );

DWORD
RmpSetResourceStatus(
    IN RESOURCE_HANDLE  ResourceHandle,
    IN PRESOURCE_STATUS ResourceStatus
    );

VOID
RmpLogEvent(
    IN RESOURCE_HANDLE  ResourceHandle,
    IN LOG_LEVEL        LogLevel,
    IN LPCWSTR          FormatString,
    ...
    );

VOID
RmpLostQuorumResource(
    IN RESOURCE_HANDLE ResourceHandle
    );

//
// Interfaces for interfacing with the poller thread
//
DWORD
RmpPollerThread(
    IN LPVOID lpParameter
    );

VOID
RmpSignalPoller(
    IN PPOLL_EVENT_LIST EventList
    );

PVOID
RmpCreateEventList(
    VOID
    );

DWORD
RmpAddPollEvent(
    IN PPOLL_EVENT_LIST EventList,
    IN HANDLE EventHandle,
    IN PRESOURCE Resource
    );

DWORD
RmpRemovePollEvent(
    PPOLL_EVENT_LIST pEventList,
    IN HANDLE EventHandle
    );

DWORD
RmpResourceEventSignaled(
    IN PPOLL_EVENT_LIST EventList,
    IN DWORD EventIndex
    );

//
// Notification interfaces
//
typedef enum _NOTIFY_REASON {
    NotifyResourceStateChange,
    NotifyResourceResuscitate,
    NotifyShutdown
} NOTIFY_REASON;

VOID
RmpPostNotify(
    IN PRESOURCE Resource,
    IN NOTIFY_REASON Reason
    );

DWORD
RmpTimerThread(
    IN LPVOID Context
    );

DWORD
RmpResourceEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceGetCommonProperties(
    IN PRESOURCE Resource,
    IN BOOL     ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceValidateCommonProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceSetCommonProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceEnumPrivateProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceGetPrivateProperties(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceValidatePrivateProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceSetPrivateProperties(
    IN PRESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceGetFlags(
    IN PRESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeEnumCommonProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeGetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN BOOL   ReadOnly,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeValidateCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeSetCommonProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeEnumPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeGetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
RmpResourceTypeValidatePrivateProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeSetPrivateProperties(
    IN LPCWSTR ResourceTypeName,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
RmpResourceTypeGetFlags(
    IN LPCWSTR ResourceTypeName,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

#ifdef COMRES
DWORD RmpLoadResType(
    IN  LPCWSTR                 lpszResourceTypeName,
    IN  LPCWSTR                 lpszDllName,
    OUT PRESDLL_FNINFO          pResDllFnInfo,
    OUT PRESDLL_INTERFACES      pResDllInterfaces,
    OUT LPDWORD                 pdwCharacteristics
);

DWORD RmpLoadComResType(
    IN  LPCWSTR                 lpszDllName,
    OUT PRESDLL_INTERFACES      pResDllInterfaces,
    OUT LPDWORD                 pdwCharacteristics
    );

#else

DWORD RmpLoadResType(
    IN  LPCWSTR                 lpszResourceTypeName,
    IN  LPCWSTR                 lpszDllName,
    OUT PRESDLL_FNINFO          pResDllFnInfo,
    OUT LPDWORD                 pdwCharacteristics
);

#endif

VOID
GenerateExceptionReport(
    IN PEXCEPTION_POINTERS pExceptionInfo
    );

VOID
DumpCriticalSection(
    IN PCRITICAL_SECTION CriticalSection
    );

BOOL
RmpAcquireSpinLock(
    IN PRESOURCE pResource,
    IN BOOL fSpin
    );

VOID
RmpReleaseSpinLock(
    IN PRESOURCE pResource
    );

VOID
RmpNotifyResourceStateChangeReason(
    IN PRESOURCE pResource,
    IN CLUSTER_RESOURCE_STATE_CHANGE_REASON eReason
    );

RPC_STATUS
RmpGetDynamicEndpointName(
    OUT LPWSTR *ppResmonRpcDynamicEndpointName
    );

DWORD
RmpSaveDynamicEndpointName(
    IN LPWSTR pResmonRpcDynamicEndpointName
    );

PRM_DUE_TIME_ENTRY
RmpInsertDeadlockMonitorList(
    IN LPCWSTR  lpszResourceDllName,
    IN LPCWSTR  lpszResourceTypeName,
    IN LPCWSTR  lpszResourceName,       OPTIONAL
    IN LPCWSTR  lpszEntryPointName
    );

VOID
RmpRemoveDeadlockMonitorList(
    IN PRM_DUE_TIME_ENTRY   pDueTimeEntry
    );

DWORD
RmpDeadlockMonitorInitialize(
    IN DWORD dwDeadlockDetectionTimeout
    );

DWORD
RmpDeadlockTimerThread(
    IN LPVOID pContext
    );

VOID
RmpDeclareDeadlock(
    IN PRM_DUE_TIME_ENTRY pDueTimeEntry,
    IN ULARGE_INTEGER uliCurrentTime
    );

DWORD
RmpUpdateDeadlockDetectionParams(
    IN DWORD dwDeadlockDetectionTimeout
    );

VOID
RmpNotifyResourcesRundown(
    VOID
    );

#endif //_RESMONP_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\cluster.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    cluster.c

Abstract:

    Server side support for Cluster APIs dealing with the whole
    cluster.

Author:

    John Vert (jvert) 9-Feb-1996

Revision History:

--*/
#include "apip.h"
#include "clusverp.h"
#include "clusudef.h"
#include <ntlsa.h>
#include <ntmsv1_0.h>



HCLUSTER_RPC
s_ApiOpenCluster(
    IN handle_t IDL_handle,
    OUT error_status_t *Status
    )
/*++

Routine Description:

    Opens a handle to the cluster. This context handle is
    currently used only to handle cluster notify additions
    and deletions correctly.

    Added call to ApipConnectCallback which checks that connecting
    users have rights to open cluster.

    Rod Sharper 03/27/97

Arguments:

    IDL_handle - RPC binding handle, not used.

    Status - Returns any error that may occur.

Return Value:

    A context handle to a cluster object if successful

    NULL otherwise.

History:
    RodSh   27-Mar-1997     Modified to support secured user connections.

--*/

{
    PAPI_HANDLE Handle;

    Handle = LocalAlloc(LMEM_FIXED, sizeof(API_HANDLE));

    if (Handle == NULL) {
        *Status = ERROR_NOT_ENOUGH_MEMORY;
        return(NULL);
    }

    *Status = ERROR_SUCCESS;
    Handle->Type = API_CLUSTER_HANDLE;
    Handle->Flags = 0;
    Handle->Cluster = NULL;
    InitializeListHead(&Handle->NotifyList);

    return(Handle);
}


error_status_t
s_ApiCloseCluster(
    IN OUT HCLUSTER_RPC *phCluster
    )

/*++

Routine Description:

    Closes an open cluster context handle.

Arguments:

    phCluster - Supplies a pointer to the HCLUSTER_RPC to be closed.
               Returns NULL

Return Value:

    None.

--*/

{
    PAPI_HANDLE Handle;

    Handle = (PAPI_HANDLE)*phCluster;
    if ((Handle == NULL) || (Handle->Type != API_CLUSTER_HANDLE)) {
        return(ERROR_INVALID_HANDLE);
    }
    ApipRundownNotify(Handle);

    LocalFree(*phCluster);
    *phCluster = NULL;

    return(ERROR_SUCCESS);
}


VOID
HCLUSTER_RPC_rundown(
    IN HCLUSTER_RPC Cluster
    )

/*++

Routine Description:

    RPC rundown procedure for a HCLUSTER_RPC. Just closes the handle.

Arguments:

    Cluster - Supplies the HCLUSTER_RPC that is to be rundown.

Return Value:

    None.

--*/

{

    s_ApiCloseCluster(&Cluster);
}


error_status_t
s_ApiSetClusterName(
    IN handle_t IDL_handle,
    IN LPCWSTR NewClusterName
    )

/*++

Routine Description:

    Changes the current cluster's name.

Arguments:

    IDL_handle - RPC binding handle, not used

    NewClusterName - Supplies the new name of the cluster.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwSize;
    LPWSTR  pszClusterName = NULL;

    API_CHECK_INIT();

    //
    // Get the cluster name, which is kept in the root of the
    // cluster registry under the "ClusterName" value, call the
    // FM only if the new name is different
    //

    dwSize = (MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR);
retry:
    pszClusterName = (LPWSTR)LocalAlloc(LMEM_FIXED, dwSize);
    if (pszClusterName == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    Status = DmQueryValue(DmClusterParametersKey,
                          CLUSREG_NAME_CLUS_NAME,
                          NULL,
                          (LPBYTE)pszClusterName,
                          &dwSize);

    if (Status == ERROR_MORE_DATA) {
        //
        // Try again with a bigger buffer.
        //
        LocalFree(pszClusterName);
        goto retry;
    }

    if ( Status == ERROR_SUCCESS ) {
        LPWSTR pszNewNameUpperCase = NULL;

        pszNewNameUpperCase = (LPWSTR) LocalAlloc(
                                            LMEM_FIXED,
                                            (lstrlenW(NewClusterName) + 1) *
                                                sizeof(*NewClusterName)
                                            );

        if (pszNewNameUpperCase != NULL) {
            lstrcpyW( pszNewNameUpperCase, NewClusterName );
            _wcsupr( pszNewNameUpperCase );
            
            Status = FmChangeClusterName(pszNewNameUpperCase, pszClusterName);

            LocalFree( pszNewNameUpperCase );
        }
        else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

FnExit:
    if ( pszClusterName ) LocalFree( pszClusterName );
    return(Status);

}


error_status_t
s_ApiGetClusterName(
    IN handle_t IDL_handle,
    OUT LPWSTR *ClusterName,
    OUT LPWSTR *NodeName
    )

/*++

Routine Description:

    Returns the current cluster name and the name of the
    node this RPC connection is to.

Arguments:

    IDL_handle - RPC binding handle, not used

    ClusterName - Returns a pointer to the cluster name.
        This memory must be freed by the client side.

    NodeName - Returns a pointer to the node name.
        This memory must be freed by the client side.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD           Size;
    DWORD           Status=ERROR_SUCCESS;

    //
    // Get the current node name
    //
    *ClusterName = NULL;
    Size = MAX_COMPUTERNAME_LENGTH+1;
    *NodeName = MIDL_user_allocate(Size*sizeof(WCHAR));
    if (*NodeName == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    GetComputerNameW(*NodeName, &Size);


    //
    // Get the cluster name, which is kept in the root of the
    // cluster registry under the "ClusterName" value.
    //

    Status = ERROR_SUCCESS;
    Size = (MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR);
retry:
    *ClusterName = MIDL_user_allocate(Size);
    if (*ClusterName == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }

    Status = DmQueryValue(DmClusterParametersKey,
                          CLUSREG_NAME_CLUS_NAME,
                          NULL,
                          (LPBYTE)*ClusterName,
                          &Size);
    if (Status == ERROR_MORE_DATA) {
        //
        // Try again with a bigger buffer.
        //
        MIDL_user_free(*ClusterName);
        goto retry;
    }


FnExit:
    if (Status == ERROR_SUCCESS) {
        return(ERROR_SUCCESS);
    }

    if (*NodeName) MIDL_user_free(*NodeName);
    if (*ClusterName) MIDL_user_free(*ClusterName);
    *NodeName = NULL;
    *ClusterName = NULL;
    return(Status);
}


error_status_t
s_ApiGetClusterVersion(
    IN handle_t IDL_handle,
    OUT LPWORD lpwMajorVersion,
    OUT LPWORD lpwMinorVersion,
    OUT LPWORD lpwBuildNumber,
    OUT LPWSTR *lpszVendorId,
    OUT LPWSTR *lpszCSDVersion
    )
/*++

Routine Description:

    Returns the current cluster version information.

Arguments:

    IDL_handle - RPC binding handle, not used

    lpdwMajorVersion - Returns the major version number of the cluster software

    lpdwMinorVersion - Returns the minor version number of the cluster software

    lpszVendorId - Returns a pointer to the vendor name. This memory must be
        freed by the client side.

    lpszCSDVersion - Returns a pointer to the current CSD description. This memory
        must be freed by the client side.
            N.B. The CSD Version of a cluster is currently the same as the CSD
                 Version of the base operating system.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    LPWSTR VendorString = NULL;
    LPWSTR CsdString = NULL;
    DWORD Length;
    OSVERSIONINFO OsVersionInfo;
    DWORD   dwStatus = ERROR_SUCCESS; 

    Length = lstrlenA(VER_CLUSTER_PRODUCTNAME_STR)+1;
    VendorString = MIDL_user_allocate(Length*sizeof(WCHAR));
    if (VendorString == NULL) 
    {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    mbstowcs(VendorString, VER_CLUSTER_PRODUCTNAME_STR, Length);

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionExW(&OsVersionInfo);
    Length = lstrlenW(OsVersionInfo.szCSDVersion)+1;
    CsdString = MIDL_user_allocate(Length*sizeof(WCHAR));
    if (CsdString == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    lstrcpyW(CsdString, OsVersionInfo.szCSDVersion);

    *lpszCSDVersion = CsdString;
    *lpszVendorId = VendorString;
    *lpwMajorVersion = VER_PRODUCTVERSION_W >> 8;
    *lpwMinorVersion = VER_PRODUCTVERSION_W & 0xff;
    *lpwBuildNumber = (WORD)(CLUSTER_GET_MINOR_VERSION(CsMyHighestVersion));


FnExit:
    if (dwStatus != ERROR_SUCCESS)
    {
        if (VendorString)
            MIDL_user_free(VendorString);
        if (CsdString)
            MIDL_user_free(CsdString);
        
    }
    return(dwStatus);
}


error_status_t
s_ApiGetClusterVersion2(
    IN handle_t IDL_handle,
    OUT LPWORD lpwMajorVersion,
    OUT LPWORD lpwMinorVersion,
    OUT LPWORD lpwBuildNumber,
    OUT LPWSTR *lpszVendorId,
    OUT LPWSTR *lpszCSDVersion,
    OUT PCLUSTER_OPERATIONAL_VERSION_INFO *ppClusterOpVerInfo
    )
/*++

Routine Description:

    Returns the current cluster version information.

Arguments:

    IDL_handle - RPC binding handle, not used

    lpdwMajorVersion - Returns the major version number of the cluster software

    lpdwMinorVersion - Returns the minor version number of the cluster software

    lpszVendorId - Returns a pointer to the vendor name. This memory must be
        freed by the client side.

    lpszCSDVersion - Returns a pointer to the current CSD description. This memory
        must be freed by the client side.
            N.B. The CSD Version of a cluster is currently the same as the CSD
                 Version of the base operating system.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    LPWSTR          VendorString = NULL;
    LPWSTR          CsdString = NULL;
    DWORD           Length;
    OSVERSIONINFO   OsVersionInfo;
    DWORD           dwStatus;
    PCLUSTER_OPERATIONAL_VERSION_INFO    pClusterOpVerInfo=NULL;


    *lpszVendorId = NULL;
    *lpszCSDVersion = NULL;
    *ppClusterOpVerInfo = NULL;

    Length = lstrlenA(VER_CLUSTER_PRODUCTNAME_STR)+1;
    VendorString = MIDL_user_allocate(Length*sizeof(WCHAR));
    if (VendorString == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    mbstowcs(VendorString, VER_CLUSTER_PRODUCTNAME_STR, Length);

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionExW(&OsVersionInfo);
    Length = lstrlenW(OsVersionInfo.szCSDVersion)+1;
    CsdString = MIDL_user_allocate(Length*sizeof(WCHAR));
    if (CsdString == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    lstrcpyW(CsdString, OsVersionInfo.szCSDVersion);


    pClusterOpVerInfo = MIDL_user_allocate(sizeof(CLUSTER_OPERATIONAL_VERSION_INFO));
    if (pClusterOpVerInfo == NULL) {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    pClusterOpVerInfo->dwSize = sizeof(CLUSTER_OPERATIONAL_VERSION_INFO);
    pClusterOpVerInfo->dwReserved = 0;

    dwStatus = NmGetClusterOperationalVersion(&(pClusterOpVerInfo->dwClusterHighestVersion),
                &(pClusterOpVerInfo->dwClusterLowestVersion),
                &(pClusterOpVerInfo->dwFlags));

    *lpszCSDVersion = CsdString;
    *lpszVendorId = VendorString;
    *ppClusterOpVerInfo = pClusterOpVerInfo;
    *lpwMajorVersion = VER_PRODUCTVERSION_W >> 8;
    *lpwMinorVersion = VER_PRODUCTVERSION_W & 0xff;
    *lpwBuildNumber = (WORD)CLUSTER_GET_MINOR_VERSION(CsMyHighestVersion);

FnExit:
    if (dwStatus != ERROR_SUCCESS)
    {
        // free the strings
        if (VendorString) MIDL_user_free(VendorString);
        if (CsdString) MIDL_user_free(CsdString);
        if (pClusterOpVerInfo) MIDL_user_free(pClusterOpVerInfo);
    }

    return(ERROR_SUCCESS);

}



error_status_t
s_ApiGetQuorumResource(
    IN handle_t IDL_handle,
    OUT LPWSTR  *ppszResourceName,
    OUT LPWSTR  *ppszClusFileRootPath,
    OUT DWORD   *pdwMaxQuorumLogSize
    )
/*++

Routine Description:

    Gets the current cluster quorum resource.

Arguments:

    IDL_handle - RPC binding handle, not used.

    *ppszResourceName - Returns a pointer to the current quorum resource name. This
        memory must be freed by the client side.

    *ppszClusFileRootPath - Returns the root path where the permanent cluster files are
        stored.

    *pdwMaxQuorumLogSize - Returns the size at which the quorum log path is set.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD           Status;
    LPWSTR          quorumId = NULL;
    DWORD           idMaxSize = 0;
    DWORD           idSize = 0;
    PFM_RESOURCE    pResource=NULL;
    LPWSTR          pszResourceName=NULL;
    LPWSTR          pszClusFileRootPath=NULL;
    LPWSTR          pszLogPath=NULL;

    API_CHECK_INIT();
    //
    // Get the quorum resource value.
    //
    Status = DmQuerySz( DmQuorumKey,
                        CLUSREG_NAME_QUORUM_RESOURCE,
                        (LPWSTR*)&quorumId,
                        &idMaxSize,
                        &idSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_ERROR,
                      "[API] s_ApiGetQuorumResource Failed to get quorum resource, error %1!u!.\n",
                      Status);
        goto FnExit;
    }

    //
    // Reference the specified resource ID.
    //
    pResource = OmReferenceObjectById( ObjectTypeResource, quorumId );
    if (pResource == NULL) {
        Status =  ERROR_RESOURCE_NOT_FOUND;
        ClRtlLogPrint(LOG_ERROR,
                      "[API] s_ApiGetQuorumResource Failed to find quorum resource object, error %1!u!\n",
                      Status);
        goto FnExit;
    }

    //
    // Allocate buffer for returning the resource name.
    //
    pszResourceName = MIDL_user_allocate((lstrlenW(OmObjectName(pResource))+1)*sizeof(WCHAR));
    if (pszResourceName == NULL) {

        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    lstrcpyW(pszResourceName, OmObjectName(pResource));

    //
    // Get the root path for cluster temporary files
    //
    idMaxSize = 0;
    idSize = 0;

    Status = DmQuerySz( DmQuorumKey,
                        cszPath,
                        (LPWSTR*)&pszLogPath,
                        &idMaxSize,
                        &idSize);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_ERROR,
                      "[API] s_ApiGetQuorumResource Failed to get the log path, error %1!u!.\n",
                      Status);
        goto FnExit;
    }

    //
    // Allocate buffer for returning the resource name.
    //
    pszClusFileRootPath = MIDL_user_allocate((lstrlenW(pszLogPath)+1)*sizeof(WCHAR));
    if (pszClusFileRootPath == NULL) {

        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    lstrcpyW(pszClusFileRootPath, pszLogPath);

    *ppszResourceName = pszResourceName;
    *ppszClusFileRootPath = pszClusFileRootPath;

    DmGetQuorumLogMaxSize(pdwMaxQuorumLogSize);

FnExit:
    if (pResource)    OmDereferenceObject(pResource);
    if (pszLogPath) LocalFree(pszLogPath);
    if (quorumId) LocalFree(quorumId);
    if (Status != ERROR_SUCCESS)
    {
        if (pszResourceName) MIDL_user_free(pszResourceName);
        if (pszClusFileRootPath) MIDL_user_free(pszClusFileRootPath);
    }
    return(Status);
}


error_status_t
s_ApiSetQuorumResource(
    IN HRES_RPC hResource,
    IN LPCWSTR  lpszClusFileRootPath,
    IN DWORD    dwMaxQuorumLogSize
    )
/*++

Routine Description:

    Sets the current cluster quorum resource.

Arguments:

    hResource - Supplies a handle to the resource that should be the cluster
        quorum resource.

    lpszClusFileRootPath - The root path for storing
        permananent cluster maintenace files.

    dwMaxQuorumLogSize - The maximum size of the quorum logs before they are
        reset by checkpointing.  If 0, the default is used.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    PFM_RESOURCE Resource;
    LPCWSTR lpszPathName = NULL;

    API_CHECK_INIT();
    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    //  Chittur Subbaraman (chitturs) - 1/6/99
    //
    //  Check whether the user is passing in a pointer to a NULL character
    //  as the second parameter. If not, pass the parameter passed by the
    //  user
    //
    if ( ( ARGUMENT_PRESENT( lpszClusFileRootPath ) ) &&
         ( *lpszClusFileRootPath != L'\0' ) )
    {
        lpszPathName = lpszClusFileRootPath;
    }

    //
    // Let FM decide if this operation can be completed.
    //
    Status = FmSetQuorumResource(Resource, lpszPathName, dwMaxQuorumLogSize );
    if ( Status != ERROR_SUCCESS ) {
        return(Status);
    }

    //Update the path
    return(Status);
}



error_status_t
s_ApiSetNetworkPriorityOrder(
    IN handle_t IDL_handle,
    IN DWORD NetworkCount,
    IN LPWSTR *NetworkIdList
    )
/*++

Routine Description:

    Sets the priority order for internal (intracluster) networks.

Arguments:

    IDL_handle - RPC binding handle, not used

    NetworkCount - The count of networks in the NetworkList

    NetworkList - An array of pointers to network IDs.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/
{
    API_CHECK_INIT();

    return(
        NmSetNetworkPriorityOrder(
               NetworkCount,
               NetworkIdList
               )
        );

}

error_status_t
s_ApiBackupClusterDatabase(
    IN handle_t IDL_handle,
    IN LPCWSTR  lpszPathName
    )
/*++

Routine Description:

    Requests for backup of the quorum log file and the checkpoint file.

Argument:

    IDL_handle - RPC binding handle, not used

    lpszPathName - The directory path name where the files have to be
                   backed up. This path must be visible to the node
                   on which the quorum resource is online.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    API_CHECK_INIT();

    //
    // Let FM decide if this operation can be completed.
    //
    return( FmBackupClusterDatabase( lpszPathName ) );
}



// #define SetServiceAccountPasswordDebug 1

error_status_t
s_ApiSetServiceAccountPassword(
    IN handle_t IDL_handle,
    IN LPWSTR lpszNewPassword,
    IN DWORD dwFlags,
    OUT IDL_CLUSTER_SET_PASSWORD_STATUS *ReturnStatusBufferPtr,
    IN DWORD ReturnStatusBufferSize,
    OUT DWORD *SizeReturned,
    OUT DWORD *ExpectedBufferSize
    )
/*++

Routine Description:

    Change cluster service account password on Service Control Manager
    Database and LSA password cache on every node of cluster.
    Return execution status on each node.

Argument:

      IDL_handle - Input parameter, RPC binding handle.
      lpszNewPassword - Input parameter, new password for cluster service account.
      
      dwFlags -  Describing how the password update should be made to
                 the cluster. The dwFlags parameter is optional. If set, the 
                 following value is valid: 
             
                 CLUSTER_SET_PASSWORD_IGNORE_DOWN_NODES
                     Apply the update even if some nodes are not
                     actively participating in the cluster (i.e. not
                     ClusterNodeStateUp or ClusterNodeStatePaused).
                     By default, the update is only applied if all 
                     nodes are up.
                     
      ReturnStatusBufferPtr - Output parameter, pointer to return status buffer.
      ReturnStatusBufferSize - Input paramter, the length of return status 
                               buffer, in number of elements.
      SizeReturned - Output parameter, the number of elements written to return 
                     status buffer.
      ExpectedBufferSize - Output parameter, expected return status buffer size 
                           (in number of entries) when ReturnStatusBuffer is 
                           too small.
    
Return Value:

    ERROR_SUCCESS if successful
    Win32 error code otherwise.

--*/

{
    DWORD Status=ERROR_SUCCESS;
    RPC_AUTHZ_HANDLE AuthzHandle = NULL;
    unsigned long AuthnLevel = 0;
    HANDLE TokenHandle = NULL;
    TOKEN_STATISTICS TokenSta;
    DWORD ReturnSize = 0;
    PSECURITY_LOGON_SESSION_DATA SecLogSesData = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;

#ifdef SetServiceAccountPasswordDebug
    // test
    WCHAR ComputerName[100];
    DWORD ComputerNameSize=100;
    static int once=0;
    // test
#endif
    
    API_CHECK_INIT();

    ClRtlLogPrint(LOG_NOISE,
                  "s_ApiSetServiceAccountPassword(): Changing account password.\n"
                  );
    
#ifdef SetServiceAccountPasswordDebug
    ClRtlLogPrint(LOG_NOISE, 
        "s_ApiSetServiceAccountPassword(): NewPassword = %1!ws!.\n",
        lpszNewPassword
        ); 
    ClRtlLogPrint(LOG_NOISE, 
        "s_ApiSetServiceAccountPassword(): ReturnStatusBufferSize = %1!u!.\n",
        ReturnStatusBufferSize
        ); 
    // test
#endif

    // check privilege attributes of the authenticated client that made the remote procedure call.
    Status = RpcBindingInqAuthClient(IDL_handle,  // The client binding handle of the client that made 
                                                  // the remote procedure call.
                            &AuthzHandle,  // Returns a pointer to a handle to the privileged information 
                                           // for the client application that made the remote procedure 
                                           // call 
                            NULL,
                            &AuthnLevel, // Returns a pointer to the level of authentication requested 
                                         // by the client application that made the remote procedure call 
                            NULL,
                            NULL
                            );

    
    if (Status == RPC_S_OK)
    {
#ifdef SetServiceAccountPasswordDebug
        ClRtlLogPrint(LOG_NOISE, 
                      "s_ApiSetServiceAccountPassword()/RpcBindingInqAuthClient() succeeded. AuthnLevel = %1!u!.\n",
                      AuthnLevel
                      ); 
#endif
        if (AuthnLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
                ClRtlLogPrint(LOG_CRITICAL, 
                      "s_ApiSetServiceAccountPassword()/RpcBindingInqAuthClient(): AuthnLevel (%1!u!) < RPC_C_AUTHN_LEVEL_PKT_PRIVACY.\n",
                      AuthnLevel
                      ); 
                Status = ERROR_ACCESS_DENIED;
                goto ErrorExit;
        }
        else
        {
#ifdef SetServiceAccountPasswordDebug
            ClRtlLogPrint(LOG_NOISE, 
                      "s_ApiSetServiceAccountPassword()/RpcBindingInqAuthClient(): AuthnLevel (%1!u!) fine.\n",
                      AuthnLevel
                      ); 
#endif
        }
    }
    else
    {
        ClRtlLogPrint(LOG_CRITICAL, 
                      "s_ApiSetServiceAccountPassword()/RpcBindingInqAuthClient() failed. Error code = %1!u!.\n",
                      Status
                      ); 
        goto ErrorExit;
    }


    // Get domain name and account name
    if (!OpenProcessToken(GetCurrentProcess(),  // Handle to the process whose access token is opened. 
                          TOKEN_QUERY,  // Access mask 
                          &TokenHandle  // Pointer to a handle identifying the newly-opened access token 
                                        // when the function returns. 
                          ))
    {
        Status=GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "s_ApiSetServiceAccountPassword()/OpenProcessToken() failed. Error code = %1!u!.\n", 
            Status);
        goto ErrorExit;
    }

    Status = GetTokenInformation(TokenHandle, // Handle to an access token from which information is retrieved.
                                 TokenStatistics, 
                                 &TokenSta,  // The buffer receives a TOKEN_STATISTICS structure containing 
                                             // various token statistics. 
                                 sizeof(TokenSta), 
                                 &ReturnSize
                                 );
    if ( (Status==0) || (ReturnSize > sizeof(TokenSta)) )
    {
        Status=GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "s_ApiSetServiceAccountPassword()/GetTokenInformation() failed. Error code = %1!u!.\n", 
            Status);
        goto ErrorExit;
    }

    NtStatus = LsaGetLogonSessionData(&(TokenSta.AuthenticationId), // Specifies a pointer to a LUID that 
                                                                    // identifies the logon session whose 
                                                                    // information will be retrieved.
                                      &SecLogSesData  // Address of a pointer to a SECURITY_LOGON_SESSION_DATA 
                                                      // structure containing information on the logon session 
                                      );
    if (NtStatus != STATUS_SUCCESS)
    {
        ClRtlLogPrint(LOG_CRITICAL, 
            "s_ApiSetServiceAccountPassword()/LsaGetLogonSessionData() failed. Error code = %1!u!.\n", 
            LsaNtStatusToWinError(NtStatus));
        Status=LsaNtStatusToWinError(NtStatus);
        goto ErrorExit;
    }

#ifdef SetServiceAccountPasswordDebug
    // test
    ClRtlLogPrint(LOG_NOISE, 
            "s_ApiSetServiceAccountPassword()/DomainName = %1!ws!\n", 
            SecLogSesData->LogonDomain.Buffer);
    ClRtlLogPrint(LOG_NOISE, 
            "s_ApiSetServiceAccountPassword()/AccountName = %1!ws!\n", 
            SecLogSesData->UserName.Buffer);
    ClRtlLogPrint(LOG_NOISE, 
            "s_ApiSetServiceAccountPassword()/AuthenticationPackage = %1!ws!\n", 
            SecLogSesData->AuthenticationPackage.Buffer);
    ClRtlLogPrint(LOG_NOISE, 
            "s_ApiSetServiceAccountPassword()/LogonType = %1!u!\n", 
            SecLogSesData->LogonType);

    // test
#endif


    ////////////////////////////////////////////////////////////////////////////////////////
    // Call NmSetServiceAccountPassword()

    Status = NmSetServiceAccountPassword(
                  SecLogSesData->LogonDomain.Buffer, 
                  SecLogSesData->UserName.Buffer, 
                  lpszNewPassword,
                  dwFlags,
                  (PCLUSTER_SET_PASSWORD_STATUS) ReturnStatusBufferPtr,
                  ReturnStatusBufferSize,
                  SizeReturned,
                  ExpectedBufferSize
                 );

    RtlSecureZeroMemory(lpszNewPassword, (wcslen(lpszNewPassword)+1)*sizeof(WCHAR));
 
ErrorExit:
    if (TokenHandle!=NULL)
    {
        if (!CloseHandle(TokenHandle))
                ClRtlLogPrint(LOG_ERROR, 
                          "s_ApiSetServiceAccountPassword(): CloseHandle() FAILED. Error code=%1!u!\n",
                          GetLastError()
                          );
    }

    if (SecLogSesData!=NULL)
    {
        NtStatus = LsaFreeReturnBuffer(SecLogSesData);
        if (NtStatus!=STATUS_SUCCESS)
            ClRtlLogPrint(LOG_ERROR, 
                          "s_ApiSetServiceAccountPassword(): LsaFreeReturnBuffer() FAILED. Error code=%1!u!\n",
                          LsaNtStatusToWinError(NtStatus)
                          );
    }

    // Return status can not be ERROR_INVALID_HANDLE, since this will trigger the
    // re-try logic at the RPC client. So ERROR_INVALID_HANDLE is converted to some
    // value, which no Win32 function will ever set its return status to, before
    // it is sent back to RPC client.

    // Error codes are 32-bit values (bit 31 is the most significant bit). Bit 29 
    // is reserved for application-defined error codes; no system error code has 
    // this bit set. If you are defining an error code for your application, set this 
    // bit to one. That indicates that the error code has been defined by an application, 
    // and ensures that your error code does not conflict with any error codes defined 
    // by the system. 
    if ( Status == ERROR_INVALID_HANDLE ) {
        Status |= 0x20000000;   // Bit 29 set.
    }

    return (Status);

} // s_ApiSetServiceAccountPassword()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\apiinit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    apiinit.c

Abstract:

    Initialization for Cluster API component (CLUSAPI) of the
    NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/
#include "apip.h"
#include "aclapi.h"
#include "stdio.h"
#include <psapi.h>


extern LPWSTR               g_pszServicesPath;
extern DWORD                g_dwServicesPid;

PSECURITY_DESCRIPTOR        g_SD = NULL;
CRITICAL_SECTION            g_SDCritSect;

API_INIT_STATE ApiState=ApiStateUninitialized;

const DWORD NO_USER_SID         = 0;
const DWORD USER_SID_GRANTED    = 1;
const DWORD USER_SID_DENIED     = 2;

//forward declarations
DWORD
ApipGetLocalCallerInfo(
    IN  handle_t                hIDL,
    IN  OUT OPTIONAL LPDWORD    pdwCheckPid,
    IN  OPTIONAL LPCWSTR        pszModuleName,
    OUT BOOL                    *pbLocal,
    OUT OPTIONAL BOOL           *pbMatchedPid,
    OUT OPTIONAL BOOL           *pbMatchedModule,
    OUT OPTIONAL BOOL           *pbLocalSystemAccount
);


RPC_STATUS
ApipConnectCallback(
    IN RPC_IF_ID * Interface,
    IN void * Context
    )
/*++

Routine Description:

    RPC callback for authenticating connecting clients of CLUSAPI

Arguments:

    Interface - Supplies the UUID and version of the interface.

    Context - Supplies a server binding handle representing the client

Return Value:

    RPC_S_OK if the user is granted permission.
    RPC_S_ACCESS_DENIED if the user is denied permission.

    Win32 error code otherwise

--*/

{
    PSECURITY_DESCRIPTOR pdefaultSD = NULL;
    DWORD Status;
    HANDLE ClientToken = NULL;
    PRIVILEGE_SET psPrivileges;
    DWORD PrivSize = sizeof(psPrivileges);
    DWORD GrantedAccess;
    DWORD AccessStatus;
    DWORD dwMask = CLUSAPI_ALL_ACCESS;
    GENERIC_MAPPING gmMap;
    DWORD dwStatus = 0;
    BOOL bReturn = FALSE;
    BOOL bACRtn = FALSE;
    DWORD dwUserPermStatus;
    RPC_STATUS RpcStatus;
    BOOL bRevertToSelfRequired = FALSE;
    BOOL bLocal, bMatchedPid, bMatchedModule, bLocalSystemAccount;
    DWORD dwRetries = 0;
    BOOL bGotCritSect = FALSE;

    //check if services is calling the cluster service for
    //services calls the interface only for eventlog propagation
    //if so, avoid the security checks
    // Get the process id
    Status = ApipGetLocalCallerInfo(Context,
                &g_dwServicesPid, 
                g_dwServicesPid ? NULL : g_pszServicesPath, //perform the module name match the first time
                &bLocal, 
                &bMatchedPid,
                &bMatchedModule,
                g_dwServicesPid ? &bLocalSystemAccount : NULL);//perform the local system account check if it is the first time
    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE, "[API] ApipGetLocalCallerInfo failed with %1!u!.\n",
            Status);
        Status = RPC_S_ACCESS_DENIED;
        goto FnExit;
    }
    if (Status == ERROR_SUCCESS)
    {
        //if the caller is local and if it matches the pid or if it matches
        //the module and is in local system account, allow access
        if ((bLocal) && 
                (bMatchedPid || (bMatchedModule && bLocalSystemAccount)))
        {
            Status = RPC_S_OK;
            goto FnExit;
        }
    }
    

    //
    // The authentication we do here is to retrieve the Security value
    // from the cluster registry, impersonate the client, and call
    // AccessCheck.
    //

    RpcStatus = RpcImpersonateClient(Context);
    if (RpcStatus != RPC_S_OK) {
        Status = RpcStatus;
        ClRtlLogPrint(LOG_NOISE, "[API] RpcImpersonateClient() failed.  Status = 0x%1!.8x!\n", Status);
        goto FnExit;
    }

    bRevertToSelfRequired = TRUE;

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &ClientToken)) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_NOISE, "[API] OpenThreadToken() failed.  Status = 0x%1!.8x!\n", Status);
        goto FnExit;
    }

    gmMap.GenericRead    = CLUSAPI_READ_ACCESS;
    gmMap.GenericWrite   = CLUSAPI_CHANGE_ACCESS;
    gmMap.GenericExecute = CLUSAPI_READ_ACCESS | CLUSAPI_CHANGE_ACCESS;
    gmMap.GenericAll     = CLUSAPI_ALL_ACCESS;

    MapGenericMask(&dwMask, &gmMap);

    // RAID 519037: We no longer read the security descriptor from the cluster database, as this
    // can cause an RPC timeout.  The SD is now read during initialization and upon notification
    // of registry changes.
    // Synchronize access to SD without blocking for more than 15 seconds.
    // 15 seconds was chosen because it is half of the timeout for an RPC call.
    while (( dwRetries++ < 15 ) &&  !( bGotCritSect = TryEnterCriticalSection( &g_SDCritSect))) {
        Sleep( 1000 );
    }

    if ( !bGotCritSect ) {
        ClRtlLogPrint( LOG_UNUSUAL, "[API] Timed out waiting for SD critsect.\n" );
        Status = WAIT_FAILED;
        goto FnExit;
    }
    
    bACRtn = ( g_SD != NULL )
        && AccessCheck(g_SD, ClientToken, dwMask, &gmMap, &psPrivileges, &PrivSize, &dwStatus, &bReturn);
    if (bACRtn && bReturn) {
        Status = RPC_S_OK;
    } else {

        DWORD   dwSDLen;

        if ( g_SD != NULL ) {
            ClRtlLogPrint(LOG_NOISE,
                          "[API] User denied access.  GetLastError() = 0x%1!.8x!; dwStatus = 0x%2!.8x!.  Trying the default SD...\n",
                          GetLastError(),
                          dwStatus);
        }
        Status = RPC_S_ACCESS_DENIED;

        ClRtlLogPrint(LOG_NOISE, "[API] Dump access mask.\n");
        ClRtlExamineMask(dwMask, "[API]");

#if CLUSTER_BETA
        if ( g_SD != NULL ) {
            //
            // SDs can be big and this could add hundreds of lines of text to the log
            //
            ClRtlLogPrint(LOG_NOISE, "[API] Dump the SD that failed...\n" );
            ClRtlExamineSD(g_SD, "[API]");
        }
#endif

        ClRtlLogPrint(LOG_NOISE, "[API] Dump the ClientToken that failed...\n" );
        ClRtlExamineClientToken(ClientToken, "[API]");

        Status = ClRtlBuildDefaultClusterSD(NULL, &pdefaultSD, &dwSDLen);
        if (SUCCEEDED(Status)) {
            ClRtlLogPrint(LOG_NOISE, "[API] Successfully built default cluster SD.\n");
            bACRtn = AccessCheck(pdefaultSD, ClientToken, dwMask, &gmMap, &psPrivileges, &PrivSize, &dwStatus, &bReturn);
            if (bACRtn && bReturn) {
                ClRtlLogPrint(LOG_NOISE, "[API] User granted access using default cluster SD.\n");
                Status = RPC_S_OK;
            } else {
                ClRtlLogPrint(LOG_NOISE,
                              "[API] User denied access using default cluster SD.  GetLastError() = 0x%1!.8x!; dwStatus = 0x%2!.8x!.\n",
                              GetLastError(),
                              dwStatus);
                Status = RPC_S_ACCESS_DENIED;
            }
            // InitializeClusterSD may have been temporarily unable to set g_SD due to low memory; if at this
            // point we have successfully built a default SD, assign it to g_SD.
            if ( g_SD == NULL ) {
                g_SD = pdefaultSD;
                pdefaultSD = NULL;
            }
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[API] Did not successfully build default cluster SD.  Error = 0x%1!.8x!\n",
                          Status);
            Status = RPC_S_ACCESS_DENIED;
        }
    }

FnExit:
    if ( bGotCritSect ) {
        LeaveCriticalSection( &g_SDCritSect );
    }

    if (bRevertToSelfRequired) {
        RpcRevertToSelf();
    }

    if (ClientToken) {
        CloseHandle(ClientToken);
    }

    if (pdefaultSD) {
        LocalFree(pdefaultSD);
    }

    return(Status);
}


DWORD
ApiInitialize(
    VOID
    )
/*++

Routine Description:

    Performs one-time initialization of the API data structures.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    ClRtlLogPrint(LOG_NOISE, "[API] Initializing\n");

    CL_ASSERT(ApiState == ApiStateUninitialized);

    //
    // Initialize global data.
    //
    InitializeListHead(&NotifyListHead);
    InitializeCriticalSection(&NotifyListLock);
    InitializeCriticalSection( &g_SDCritSect );

    ApiState = ApiStateOffline;

    return(ERROR_SUCCESS);
}


DWORD
InitializeClusterSD(
    VOID
    )
/*++
--*/
{
    DWORD BufferSize=0;
    DWORD Size=0;
    DWORD Status = ERROR_SUCCESS;

    EnterCriticalSection( &g_SDCritSect );

    if ( g_SD ) {
        LocalFree( g_SD );
        g_SD = NULL;
    }
    
    Status = DmQueryString(DmClusterParametersKey,
                           CLUSREG_NAME_CLUS_SD,
                           REG_BINARY,
                           (LPWSTR *) &g_SD,
                           &BufferSize,
                           &Size);

    if (Status == ERROR_SUCCESS) {
        if (!IsValidSecurityDescriptor(g_SD)) {
            ClRtlLogPrint(LOG_CRITICAL, "[API] ApiReadSDFromReg - SD is not valid!\n");
            // Set Status, but do not bail yet.  Further down we will create a default SD.
            Status = RPC_S_ACCESS_DENIED;
        }
    }
    else {
        PSECURITY_DESCRIPTOR psd4;

        ClRtlLogPrint(LOG_NOISE, "[API] InitializeClusterSD - Did not find Security Descriptor key in the cluster DB.\n");
        Status = DmQueryString(DmClusterParametersKey,
                               CLUSREG_NAME_CLUS_SECURITY,
                               REG_BINARY,
                               (LPWSTR *) &psd4,
                               &BufferSize,
                               &Size);

        if (Status == ERROR_SUCCESS) {
            g_SD = ClRtlConvertClusterSDToNT5Format(psd4);
            if ( g_SD == NULL ) {
                ClRtlLogPrint(LOG_CRITICAL, "[API] InitializeClusterSD - Unable to convert SD to NT5 format." );
                Status = ERROR_INVALID_PARAMETER;
            }
            LocalFree(psd4);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, "[API] InitializeClusterSD - Did not find Security key in the cluster DB.\n");
        } // Else failed to read CLUS_SECURITY
    } // Else failed to read CLUS_SD

    // If we still haven't got a valid SD at this point, create a default one.
    if ( Status != ERROR_SUCCESS ) {
        DWORD   dwSDLen;

        Status = ClRtlBuildDefaultClusterSD(NULL, &g_SD, &dwSDLen);
        if (SUCCEEDED(Status)) {
            ClRtlLogPrint(LOG_NOISE, "[API] InitializeClusterSD - Successfully built default cluster SD.\n");
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[API] InitializeClusterSD - Did not successfully build default cluster SD.  Error = 0x%1!.8x!\n",
                          Status);
            Status = RPC_S_ACCESS_DENIED;
        }
    }

    if (( Status != ERROR_SUCCESS ) && ( g_SD != NULL )) {
        LocalFree( g_SD );
        g_SD = NULL;
    }

    if ( Status == ERROR_SUCCESS ) {
        CL_ASSERT( g_SD != NULL );
    }
    
    LeaveCriticalSection( &g_SDCritSect );

    return Status;
}


DWORD
ApiOnlineReadOnly(
    VOID
    )
/*++

Routine Description:

    Brings up a limited set of APIs - currently OpenResource/read-only
    registry APIs. Only LPC connections are enabled.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status = ERROR_SUCCESS;


    if (ApiState == ApiStateOffline) {
        ClRtlLogPrint(LOG_NOISE, "[API] Online read only\n");

        // No need to log anything here -- the routine does its own logging,
        if (( Status = InitializeClusterSD()) != ERROR_SUCCESS ) {
            goto FnExit;
        }
    
        //
        // Register the clusapi RPC server interface so resources can use
        // the API when they are created by the FM. Note that we won't receive
        // any calls from remote clients yet because we haven't registered
        // the dynamic UDP endpoint. That will happnen in ApiOnline().
        //
        Status = RpcServerRegisterIfEx(s_clusapi_v2_0_s_ifspec,
                                       NULL,
                                       NULL,
                                       0,  // No need to set RPC_IF_ALLOW_SECURE_ONLY if security callback
                                           // is specified. If security callback is specified, RPC
                                           // will reject unauthenticated requests without invoking
                                           // callback. This is the info obtained from RpcDev. See
                                           // Windows Bug 572035.
                                       RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                       ApipConnectCallback
                                       );

        if (Status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                          "[API] Failed to register clusapi RPC interface, status %1!u!.\n",
                          Status
                          );
            goto FnExit;
        }

        if ( Status == ERROR_SUCCESS ) {
            ApiState = ApiStateReadOnly;
        }
    }
    else {
        //CL_ASSERT(ApiState == ApiStateOffline);
    }

FnExit:
    return Status;
}


DWORD
ApiOnline(
    VOID
    )
/*++

Routine Description:

    Enables the rest of the API set and starts listening for remote
    connections.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD Status = ERROR_SUCCESS;


    ClRtlLogPrint(LOG_NOISE, "[API] Online\n");

    if (ApiState == ApiStateReadOnly) {
        // No need to log anything here -- the routine does its own logging,
        if (( Status = InitializeClusterSD()) != ERROR_SUCCESS ) {
            goto FnExit;
        }

        //
        // Register for all events
        //
        Status = EpRegisterEventHandler(CLUSTER_EVENT_ALL,ApipEventHandler);
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }

        //
        // Register the dynamic UDP endpoint for the clusapi interface.
        // This will enable remote clients to begin calling us. We do this
        // here to minimize the chances that we will service an external
        // call before we are ready. If we ever have to rollback after
        // this point, we will still be listening externally. Nothing we can
        // do about that.
        //
        CL_ASSERT(CsRpcBindingVector != NULL);

        Status = RpcEpRegister(s_clusapi_v2_0_s_ifspec,
                               CsRpcBindingVector,
                               NULL,
                               L"Microsoft Cluster Server API");

        if (Status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                          "[API] Failed to register endpoint for clusapi RPC interface, status %1!u!.\n",
                          Status
                          );
            NmDumpRpcExtErrorInfo(Status);
            goto FnExit;
        }

        if ( Status == ERROR_SUCCESS ) {
            ApiState = ApiStateOnline;
        }
    }
    else {
        CL_ASSERT(ApiState == ApiStateReadOnly);
    }

FnExit:
    return Status;

}

VOID
ApiOffline(
    VOID
    )

/*++

Routine Description:

    Takes the Cluster Api offline.

Arguments:

    None.

Returns:

    None.

--*/

{
    DWORD Status;


    if (ApiState == ApiStateOnline) {

        ClRtlLogPrint(LOG_NOISE, "[API] Offline\n");

        //
        // Deregister the Clusapi RPC endpoint
        //
        CL_ASSERT(CsRpcBindingVector != NULL);

        Status = RpcEpUnregister(
                     s_clusapi_v2_0_s_ifspec,
                     CsRpcBindingVector,
                     NULL
                     );

        if ((Status != RPC_S_OK) && (Status != EPT_S_NOT_REGISTERED)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[API] Failed to deregister endpoint for clusapi RPC interface, status %1!u!.\n",
                Status
                );
        }

        ApiState = ApiStateReadOnly;
    }

//
// KB - We can't deregister the interface because we can't wait for
//      pending calls to complete - pending notifies never complete.
//      If we deregistered the interface after a failed join without
//      a complete shutdown, the subsequent form would fail. As a
//      result, the API won't go offline until service shutdown.
//
#if 0

    if (ApiState == ApiStateReadOnly) {

        //
        // Deregister the Clusapi RPC interface
        //

        Status = RpcServerUnregisterIf(
                     s_clusapi_v2_0_s_ifspec,
                     NULL,
                     1      // Wait for outstanding calls to complete
                     );

        if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] Unable to deregister the clusapi RPC interface, Status %1!u!.\n",
                Status
                );
        }

        ApiState = ApiStateOffline;
    }

#endif

    return;
}


VOID
ApiShutdown(
    VOID
    )

/*++

Routine Description:

    Shuts down the Cluster Api

Arguments:

    None.

Returns:

    None.

--*/

{
    DWORD  Status;


    if (ApiState > ApiStateOffline) {
        ApiOffline();

        //
        // KB - We do this here because shutdown of the Clusapi RPC
        //          interface is broken due to pending notifies.
        //
        Status = RpcServerUnregisterIf(
                     s_clusapi_v2_0_s_ifspec,
                     NULL,
                     0      // Don't wait for calls to complete
                     );

        if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] Unable to deregister the clusapi RPC interface, Status %1!u!.\n",
                Status
                );
        }

        ApiState = ApiStateOffline;
    }

    if (ApiState == ApiStateOffline) {

        ClRtlLogPrint(LOG_NOISE, "[API] Shutdown\n");

        //
        // KB
        //
        // Because we cannot shutdown the RPC server and cannot
        // unregister our event handler, it is not safe to delete
        // the critical section.
        //
        // DeleteCriticalSection(&NotifyListLock);
        // ApiState = ApiStateUninitialized;

        //
        // TODO?
        //
        // SS: free notify list head
        // SS: how do we deregister with the event handler
        //
    }

    return;
}

DWORD
ApipGetLocalCallerInfo(
    IN  handle_t                hIDL,
    IN  OUT OPTIONAL LPDWORD    pdwCheckPid,
    IN  OPTIONAL LPCWSTR        pszModuleName,
    OUT BOOL                    *pbLocal,
    OUT OPTIONAL BOOL           *pbMatchedPid,
    OUT OPTIONAL BOOL           *pbMatchedModule,
    OUT OPTIONAL BOOL           *pbLocalSystemAccount
)
/*++

Routine Description:

    This function checks whether the caller's account is the local system
    account.

Arguments:

    hIDL - The handle to the binding context
    
    pdwCheckPid - if the value passed in is NULL, the pid of the calling process is returned.  If
        is returned.

    pszModuleName - If non null, the call performs the check to compare
        the module name of the caller against pszModuleName.  If they
        match, *pbMatchedPid is set to TRUE.

    pbLocal - TRUE is returned if the caller initiated this call using 
        lrpc.  If this is FALSE, all other output values will be FALSE.

    pbMatchedModule - TRUE is returned, if the caller matches the module
        name specified by lpszModuleName. This pointer can be NULL.

    pbMatchedPid - if *pdwCheckPid is non NULL, and it matched the pid of the 
        caller, then this is set to TRUE.   Else, this is set to FALSE.

    pbLocalSystemAccount - If this is NON NULL, the call performs a check
        to see if the the caller is running in LocalSystemAccount.  If it is
        then TRUE is returned, else FALSE is returned.
        
Return Value:

    ERROR_SUCCESS on success.

    Win32 error code on failure.

Remarks:


--*/
{
    DWORD           Pid;
    HANDLE          hProcess = NULL;
    DWORD           dwNumChar;
    DWORD           dwLen;
    WCHAR           wCallerPath[MAX_PATH + 1];
    RPC_STATUS      RpcStatus;
    DWORD           dwStatus = ERROR_SUCCESS;
    BOOLEAN         bWasEnabled;

    if (pbMatchedModule)
        *pbMatchedModule = FALSE;
    if (pbMatchedPid)
        *pbMatchedPid = FALSE;
    if (pbLocalSystemAccount)
        *pbLocalSystemAccount = FALSE;


    //assume the caller is local
    *pbLocal = TRUE;
    
    RpcStatus = I_RpcBindingInqLocalClientPID(NULL, &Pid );
    if (RpcStatus == RPC_S_INVALID_BINDING)
    {
        *pbLocal = FALSE;
        RpcStatus = RPC_S_OK;
        goto FnExit;
    }            
    
    dwStatus = I_RpcMapWin32Status(RpcStatus);

    if (dwStatus != ERROR_SUCCESS)
    {
        ClRtlLogPrint( LOG_CRITICAL, 
                "[API] ApipGetLocalCallerInfo: Error %1!u! calling RpcBindingInqLocalClientPID.\n",
                dwStatus 
                );
        goto FnExit;
    }

    dwStatus = ClRtlEnableThreadPrivilege(SE_DEBUG_PRIVILEGE, &bWasEnabled);
    if ( dwStatus != ERROR_SUCCESS )
    {
        if (dwStatus == STATUS_PRIVILEGE_NOT_HELD) 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[API] ApipGetLocalCallerInfo: Debug privilege not held by cluster service\n");
        } 
        else 
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[API] ApipGetLocalCallerInfo: Attempt to enable debug privilege failed %1!lx!\n",
                dwStatus);
        }
        goto FnExit;
    }


    // Get the process
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, Pid);

    //restore the thread privilege, now that we have a process handle with the right access
    ClRtlRestoreThreadPrivilege(SE_DEBUG_PRIVILEGE,
        bWasEnabled);
    
    if(hProcess == NULL)
    {
        dwStatus = GetLastError();
        ClRtlLogPrint( LOG_CRITICAL, 
                "[API] ApipGetLocalCallerInfo: Error %1!u! calling OpenProcess %2!u!.\n",
                dwStatus,
                Pid                
                );
                        
        goto FnExit;
    }        


    //if a process id has been specified, see if it matches that one
    if (pdwCheckPid)
    {
        if ((*pdwCheckPid) && (*pdwCheckPid == Pid))
        {
            *pbMatchedPid = TRUE;            
        }
    }
    
    if (pszModuleName && pbMatchedModule)
    {
        // Get the module name of whoever is calling us.
        
        dwNumChar = GetModuleFileNameExW(hProcess, NULL, wCallerPath, MAX_PATH);
        if(dwNumChar == 0)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint( LOG_CRITICAL, 
                "[API] ApipGetLocalCallerInfo: Error %1!u! calling GetModuleFileNameExW.\n",
                dwStatus 
                );
            goto FnExit;
        }        

        if(!lstrcmpiW(wCallerPath, pszModuleName))
        {
            *pbMatchedModule = TRUE;
        }
    }

    //check if it is the local system account, if requested
    if (pbLocalSystemAccount && hIDL)
    {
        // Impersonate the client.
        if ( ( RpcStatus = RpcImpersonateClient( hIDL ) ) != RPC_S_OK )
        {
            dwStatus = I_RpcMapWin32Status(RpcStatus);
            ClRtlLogPrint( LOG_CRITICAL, 
                    "[API] ApipGetLocalCallerInfo: Error %1!u! trying to impersonate caller...\n",
                    dwStatus 
                    );
            goto FnExit;
        }


        // Check that the caller's account is local system account
        dwStatus = ClRtlIsCallerAccountLocalSystemAccount(pbLocalSystemAccount );
        
        RpcRevertToSelf();
        
        if (dwStatus != ERROR_SUCCESS )
        {
            ClRtlLogPrint( LOG_CRITICAL, 
                        "[API] ApipGetLocalCallerInfo : Error %1!u! trying to check caller's account...\n",
                        dwStatus);   
            goto FnExit;
        }
    
    }

    //return the pid if the pid passed in is NULL and the pid passes
    //the criteria  - matches pszModuleName if specified and is in 
    //local system account
    if (pdwCheckPid && !(*pdwCheckPid))
    {
        //if we need to check for local system, the process must be in local system account
        //if the module name needs to be checked 
        if (((pbLocalSystemAccount && *pbLocalSystemAccount) || (!pbLocalSystemAccount))
            && ((pszModuleName && pbMatchedModule && *pbMatchedModule)  || (!pbMatchedModule)))
        {            
            ClRtlLogPrint( LOG_NOISE, 
                        "[API] ApipGetLocalCallerInfo : Returning Pid %1!u!\n",
                        Pid);   
            *pdwCheckPid = Pid;
        }            
    }

FnExit:
    if (hProcess)
        CloseHandle(hProcess);
    return(dwStatus);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\fixup.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    FixUp.cpp

Abstract:

    Fix up Routines for Rolling Upgrades

Author:

    Sunita Shrivastava(sunitas) 18-Mar-1998
    Galen Barbee    (galenb)    31-Mar-1998


Revision History:

--*/

#include "apip.h"

//extern "C"
//{
//extern ULONG CsLogLevel;
//extern ULONG CsLogModule;
//}

//static WCHAR  wszPropertyName [] =  { CLUSREG_NAME_CLUS_SD };

//typedef struct stSecurityDescriptorProp
//{
//  DWORD                   dwPropCount;
//  CLUSPROP_PROPERTY_NAME  pnPropName;
//  WCHAR                   wszPropName [( sizeof( wszPropertyName ) / sizeof( WCHAR ) )];
//  CLUSPROP_BINARY         biValueHeader;
//  BYTE                    rgbValueData[1];
//} SECURITYPROPERTY;

DWORD
ApipAddNetServiceSidToSD(
    PSECURITY_DESCRIPTOR    CurrentSD,
    PSECURITY_DESCRIPTOR *  UpdatedSD
    )

/*++

Routine Description:

    If necessary, add the Network Service SID to the cluster security
    descriptor.

    REMOVE AFTER 1st MAJOR RELEASE AFTER WINDOWS XP/SERVER 2003 HAS SHIPPED,
    I.E. DURING THE DEV CYCLE OF WHISTLER + 2

Arguments:

    CurrentSD - current NT5 based security descriptor

    UpdatedSD - address of pointer that receives SD with service SID added. If
                the SID is already present, the pointer is set to NULL.

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/
{
    DWORD   status = ERROR_SUCCESS;
    PSID    pNetServiceSid = NULL;
    PACL    dacl = NULL;
    BOOL    daclPresent;
    BOOL    defaultDacl;
    BOOL    success;
    DWORD   aceIndex = 0;

    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

    //
    // make sure the passed in SD is valid
    //
    if ( !IsValidSecurityDescriptor( CurrentSD )) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[API] Cluster Security Descriptor is not valid! Unable to add Network Service account.\n");

        status = ERROR_INVALID_SECURITY_DESCR;
        goto cleanup;
    }

    //
    // allocate and init the Network Service sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    1,
                                    SECURITY_NETWORK_SERVICE_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pNetServiceSid ) )
    {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[API] Can't get SID for Network Service account (status %1!u!)! "
                      "Unable to add Network Service account to cluster security descriptor.\n",
                      status);

        goto cleanup;
    }

    //
    // see if it is already in there; get a pointer to the DACL and run down
    // the ACES, comparing their SIDs to the Network Service SID
    //
    success = GetSecurityDescriptorDacl( CurrentSD, &daclPresent, &dacl, &defaultDacl );
    if ( !success ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                      "[API] Failed to get DACL in cluster security descriptor - status %1!u!\n",
                      status);
        goto cleanup;
    }

    if ( !daclPresent ) {
        //
        // no DACL present. Normally, the SD is present but downlevel (W2K)
        // nodes can delete the security properties.
        //
        ClRtlLogPrint(LOG_CRITICAL,
                      "[API] DACL not present in cluster security descriptor.\n" );
        status = ERROR_INVALID_SECURITY_DESCR;
        goto cleanup;
    }

    for ( aceIndex = 0; aceIndex < dacl->AceCount; ++aceIndex ) {
        PACE_HEADER aceHeader;
        PSID    aceSid = NULL;

        success = GetAce( dacl, aceIndex, (LPVOID *)&aceHeader );
        if ( !success ) {
            status = GetLastError();
            break;
        }

        //
        // we currently only support access allowed and denied ACEs, i.e., no
        // other ACE type should be present in the DACL.
        //
        if ( aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE ) {
            aceSid = &((ACCESS_ALLOWED_ACE *)aceHeader)->SidStart;
        }
        else if ( aceHeader->AceType == ACCESS_DENIED_ACE_TYPE ) {
            aceSid = &((ACCESS_DENIED_ACE *)aceHeader)->SidStart;
        }

        if ( aceSid != NULL ) {
            if ( EqualSid( pNetServiceSid, aceSid )) {
#if DBG
                ClRtlLogPrint(LOG_NOISE,
                              "[API] Network Service SID is already present in cluster security descriptor.\n" );
#endif
                break;
            }
        }
    }

    if ( status == ERROR_SUCCESS && aceIndex == dacl->AceCount ) {
        //
        // didn't find it; add the Network Service SID
        //
        status = ClRtlAddAceToSd( CurrentSD, pNetServiceSid, CLUSAPI_ALL_ACCESS, UpdatedSD );
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[API] Unable to add Network Service account to cluster security "
                          "descriptor, (status %1!u!).\n",
                          status);

            goto cleanup;
        }
    } else if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
                      "[API] Failed to get ACE #%1!u! in cluster security descriptor - status %2!u!.\n",
                      aceIndex,
                      status);
    }

cleanup:
    if ( pNetServiceSid != NULL ) {
        FreeSid( pNetServiceSid );
    }

    return status;

} // ApipAddNetServiceSidToSD

/****
@func       DWORD | ApiFixNotifyCb | If a cluster component wants to make
            a fixup to the cluster registry as a part of form/join it
            must register with the NM via this API.

@parm       IN PVOID| pContext | A pointer to the context information passed
            to NmRegisterFixupCb().

@parm       IN PVOID *ppPropertyList |

@parm       IN PVOID pdwProperyListSize | A pointer to DWORD where the size
            of the property list structure is returned.


@comm       For Whister/Windows Server 2003, the Network Service SID is added to the cluster
            security descriptor as well as the standard things for NT5. For
            NT 5.0, the api layer performs the fixup for the security
            descriptor. If the new security descriptor entry for the cluster is
            not present in the registry, convert the old format to the new one
            and write it to the cluster registry.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmJoinFixup> <f NmFormFixup>
*****/
extern "C" DWORD
ApiFixupNotifyCb(
    IN DWORD    dwFixupType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR  *pszKeyName
    )
{

    PSECURITY_DESCRIPTOR    psd             = NULL;
    PSECURITY_DESCRIPTOR    psd5            = NULL;
    PSECURITY_DESCRIPTOR    updatedSD       = NULL;
    DWORD                   dwBufferSize    = 0;
    DWORD                   dwSize          = 0;
    DWORD                   dwStatus        = E_FAIL;

#if DBG
    CL_ASSERT( ppPropertyList != NULL );
    CL_ASSERT( pdwPropertyListSize != NULL );
    ClRtlLogPrint( LOG_NOISE,  "[API] ApiFixupNotifyCb: entering.\n" );
#endif

    if ( pdwPropertyListSize && ppPropertyList )
    {
        *ppPropertyList = NULL;
        *pdwPropertyListSize = 0;

        //
        // try to get the W2K SD
        //
        dwStatus = DmQueryString( DmClusterParametersKey,
                                  CLUSREG_NAME_CLUS_SD,
                                  REG_BINARY,
                                  (LPWSTR *) &psd5,
                                  &dwBufferSize,
                                  &dwSize );

        if ( dwStatus != ERROR_SUCCESS )
        {
            //
            // not there or can't get it; try to get the NT4 SD
            //
            dwStatus = DmQueryString( DmClusterParametersKey,
                                      CLUSREG_NAME_CLUS_SECURITY,
                                      REG_BINARY,
                                      (LPWSTR *) &psd,
                                      &dwBufferSize,
                                      &dwSize );

            if ( dwStatus == ERROR_SUCCESS )
            {
                //
                // convert to W2K descriptor format and add in the Network
                // Service SID if necessary. updatedSD will be non-NULL if the
                // SID was added. The convert routine can fail and set psd5 to
                // NULL. 
                //
                // The Service SID routine can be removed after the next major
                // release after Whistler/Windows Server 2003 is shipped.
                //
                psd5 = ClRtlConvertClusterSDToNT5Format( psd );

                dwStatus = ApipAddNetServiceSidToSD( psd5, &updatedSD );
                if ( dwStatus == ERROR_SUCCESS ) {
                    if ( updatedSD != NULL ) {
                        //
                        // we've got a new SD so free the old one and point to
                        // the new one
                        //
                        LocalFree( psd5 );
                        psd5 = updatedSD;
                    }
                } else {
                    ClRtlLogPrint(LOG_CRITICAL,
                                  "[API] ApiFixupNotifyCb: Unable to add Network Service "
                                  "account to Cluster security descriptor. Error = %1!u!.\n",
                                  dwStatus );

                    //
                    // we did some work (hopefully). If the conversion failed,
                    // psd5 will be null but that will be caught below.
                    //
                    dwStatus = ERROR_SUCCESS;
                }
            }
        }
        else
        {
            //
            // we have an W2K based SD; now see if the Network Service SID
            // needs to be added
            //
            dwStatus = ApipAddNetServiceSidToSD( psd5, &updatedSD );
            if ( dwStatus == ERROR_SUCCESS )
            {
                if ( updatedSD != NULL )
                {
                    //
                    // we've got a new SD so free the old one and point to
                    // the new one
                    //
                    LocalFree( psd5 );
                    psd5 = updatedSD;
                }
            }
            else {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[API] ApiFixupNotifyCb: Unable to add Network Service "
                              "account to Cluster security descriptor. Error = %1!u!.\n",
                              dwStatus );

                dwStatus = ERROR_SUCCESS;
            }
        }

        if ( dwStatus == ERROR_SUCCESS && psd5 != NULL )
        {
            //
            // build a property list describing the W2K security descriptor
            //
            *pdwPropertyListSize =  sizeof( DWORD )
                + sizeof( CLUSPROP_PROPERTY_NAME )
                + ( ALIGN_CLUSPROP( ( lstrlenW( CLUSREG_NAME_CLUS_SD )  + 1 ) * sizeof( WCHAR ) ) )
                + sizeof( CLUSPROP_BINARY )
                + ALIGN_CLUSPROP( GetSecurityDescriptorLength( psd5 ) )
                + sizeof( CLUSPROP_SYNTAX );

            *ppPropertyList = LocalAlloc( LMEM_ZEROINIT, *pdwPropertyListSize );
            if ( *ppPropertyList != NULL )
            {
                CLUSPROP_BUFFER_HELPER  props;

                props.pb = (BYTE *) *ppPropertyList;

                //
                // set the number of properties
                //
                props.pList->nPropertyCount = 1;
                props.pb += sizeof( props.pList->nPropertyCount );      // DWORD

                //
                // set the property name
                //
                props.pName->Syntax.dw = CLUSPROP_SYNTAX_NAME;
                props.pName->cbLength = ( lstrlenW( CLUSREG_NAME_CLUS_SD )  + 1 ) * sizeof( WCHAR );
                lstrcpyW( props.pName->sz, CLUSREG_NAME_CLUS_SD );
                props.pb += ( sizeof( CLUSPROP_PROPERTY_NAME )
                              + ( ALIGN_CLUSPROP( ( lstrlenW( CLUSREG_NAME_CLUS_SD )  + 1 ) * sizeof( WCHAR ) ) ) );

                //
                // set the binary part of the property the SD...
                //
                props.pBinaryValue->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_BINARY;
                props.pBinaryValue->cbLength = GetSecurityDescriptorLength( psd5 );
                CopyMemory( props.pBinaryValue->rgb, psd5, GetSecurityDescriptorLength( psd5 ) );
                props.pb += sizeof(*props.pBinaryValue) + ALIGN_CLUSPROP( GetSecurityDescriptorLength( psd5 ) );

                //
                // Set an endmark.
                //
                props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

                //
                // specify the registry key
                //
                *pszKeyName=(LPWSTR)LocalAlloc(LMEM_FIXED, (lstrlenW(L"Cluster") + 1) *sizeof(WCHAR));

                if( *pszKeyName == NULL ) {
                    LocalFree( *ppPropertyList );
                    *ppPropertyList = NULL;
                    *pdwPropertyListSize = 0;

                    dwStatus =GetLastError();
                }
                else
                {
                    lstrcpyW(*pszKeyName,L"Cluster");
                }
            }
            else
            {
                dwStatus = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                              "[API] ApiFixupNotifyCb: Unable to build property list "
                              "for security descriptor update. status %1!u!\n",
                              dwStatus);
            }
        }
    }
    else
    {
#if DBG
        ClRtlLogPrint( LOG_CRITICAL,  "[API] ApiFixupNotifyCb: Invalid parameters.\n" );
#endif
    }

    LocalFree( psd5 );
    LocalFree( psd );

    return dwStatus;

} // ApiFixupNotifyCb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\api\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Implements server side of the resource and resource type
    IOCTL interfaces in the CLUSAPI.

Author:

    John Vert (jvert) 10/16/1996

Revision History:

--*/
#include "apip.h"


error_status_t
s_ApiNodeResourceControl(
    IN HRES_RPC hResource,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    hResource - Supplies a handle to the resource to be controlled.

    hNode - Supplies a handle to the node on which the resource
        control should be delivered. If this is NULL, the node where
        the resource is online is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;
    PNM_NODE     Node;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);
    VALIDATE_NODE(Node, hNode);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(FmResourceControl( Resource,
                              Node,
                              dwControlCode,
                              lpInBuffer,
                              dwInBufferSize,
                              lpOutBuffer,
                              nOutBufferSize,
                              lpBytesReturned,
                              lpcbRequired ));
}


error_status_t
s_ApiResourceControl(
    IN HRES_RPC hResource,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    hResource - Supplies a handle to the resource to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_RESOURCE Resource;

    API_CHECK_INIT();

    VALIDATE_RESOURCE_EXISTS(Resource, hResource);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) 
    {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(FmResourceControl( Resource,
                              NULL,
                              dwControlCode,
                              lpInBuffer,
                              dwInBufferSize,
                              lpOutBuffer,
                              nOutBufferSize,
                              lpBytesReturned,
                              lpcbRequired ));
}


error_status_t
s_ApiNodeResourceTypeControl(
    IN HCLUSTER_RPC hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    hCluster - Supplies a handle to the cluster to be controlled. Not used.

    lpszResourceTypename - Supplies the name of the resource type to be
        controlled.

    hNode - Supplies a handle to the node on which the resource
        control should be delivered. If this is NULL, the node where
        the resource is online is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource type control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PNM_NODE     Node;

    API_CHECK_INIT();

    VALIDATE_NODE(Node, hNode);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) {
        return (ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }

    return(FmResourceTypeControl( lpszResourceTypeName,
                                  Node,
                                  dwControlCode,
                                  lpInBuffer,
                                  dwInBufferSize,
                                  lpOutBuffer,
                                  nOutBufferSize,
                                  lpBytesReturned,
                                  lpcbRequired ));

}


error_status_t
s_ApiResourceTypeControl(
    IN HCLUSTER_RPC hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    hCluster - Supplies a handle to the cluster to be controlled. Not used.

    lpszResourceTypename - Supplies the name of the resource type to be
        controlled.

    hNode - Supplies a handle to the node on which the resource
        control should be delivered. If this is NULL, the node where
        the resource is online is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource type control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..


    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    API_CHECK_INIT();

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) {
        return (ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(FmResourceTypeControl( lpszResourceTypeName,
                                  NULL,
                                  dwControlCode,
                                  lpInBuffer,
                                  dwInBufferSize,
                                  lpOutBuffer,
                                  nOutBufferSize,
                                  lpBytesReturned,
                                  lpcbRequired ));

}


error_status_t
s_ApiNodeGroupControl(
    IN HGROUP_RPC hGroup,
    IN HNODE_RPC hNode,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    hGroup - Supplies a handle to the group to be controlled.

    hNode - Supplies a handle to the node on which the group
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the group control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the group.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the group.

    lpcbRequired - Returns the number of bytes required if OutBuffer
        is not large enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PFM_GROUP    Group;
    PNM_NODE     Node;

    API_CHECK_INIT();

    VALIDATE_GROUP_EXISTS(Group, hGroup);
    VALIDATE_NODE(Node, hNode);

    //
    // Check if this is an internal, private control code.
    //
    if ( dwControlCode & CLCTL_INTERNAL_MASK ) {
        return(ERROR_PRIVILEGE_NOT_HELD);
    }

    //
    //  Since lpInBuffer is declared as [unique] in the IDL file, it can be NULL while dwBufferSize
    //  is non-zero and vice-versa. To avoid confusion in the following code, we make them consistent
    //  right here.
    //
    if ( lpInBuffer == NULL )
    {
        dwInBufferSize = 0;
    }
    else if ( dwInBufferSize == 0 )
    {
        lpInBuffer = NULL;
    }
    
    return(FmGroupControl( Group,
                           Node,
                           dwControlCode,
                           lpInBuffer,
                           dwInBufferSize,
                           lpOutBuffer,
                           nOutBufferSize,
                           lpBytesReturned,
                           lpcbRequired ));
}


error_status_t
s_ApiGroupControl(
    IN HGROUP_RPC hGroup,
    IN DWORD dwControlCode,
    IN UCHAR *lpInBuffer,
    IN DWORD dwInBufferSize,
    OUT UCHAR *lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT DWORD *lpBytesReturned,
    OUT DWORD *lpcbRequired
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    hGroup - Supplies a handle to the group to be controlled.

    dwControlCode- Supplies the control code that defines the
        structure and action of the group control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
      