BReadOnly());

    try
    {
        PciCluster()->SetNetworkPriority(LpciNetworkPriority());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CPropertyPage::OnApply();

}  //*** CClusterNetPriorityPage::OnApply

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnSelChangeList
//
//  Routine Description:
//      Handler for the LBN_SELCHANGE message on the list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnSelChangeList(void)
{
    BOOL    bEnableUp;
    BOOL    bEnableDown;
    BOOL    bEnableProperties;
    int     isel;
    int     cItems;

    isel = m_lbList.GetCurSel();
    cItems = m_lbList.GetCount();

    // Enable buttons only if there is a selection and there
    // is more than one item in the list.
    if (BReadOnly() || (isel == LB_ERR) || (cItems <= 1))
    {
        bEnableUp = FALSE;
        bEnableDown = FALSE;
    }  // if:  no selection or only 0 or 1 items in the list
    else
    {
        bEnableUp = (isel > 0);
        bEnableDown = (isel < cItems - 1);
    }  // else:  buttons allowed to be enabled

    bEnableProperties = (isel != LB_ERR);

    m_pbUp.EnableWindow(bEnableUp);
    m_pbDown.EnableWindow(bEnableDown);
    m_pbProperties.EnableWindow(bEnableProperties);

}  //*** CClusterNetPriorityPage::OnSelChangeList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnUp
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Up push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnUp(void)
{
    int         isel;
    CNetwork *  pciNet;

    isel = m_lbList.GetCurSel();
    ASSERT(isel != LB_ERR);

    pciNet = (CNetwork *) m_lbList.GetItemDataPtr(isel);
    ASSERT_VALID(pciNet);

    VERIFY(m_lbList.DeleteString(isel) != LB_ERR);
    isel = m_lbList.InsertString(isel - 1, pciNet->StrName());
    ASSERT(isel != LB_ERR);
    VERIFY(m_lbList.SetItemDataPtr(isel, pciNet) != LB_ERR);
    VERIFY(m_lbList.SetCurSel(isel) != LB_ERR);

    OnSelChangeList();
    m_lbList.SetFocus();

    SetModified(TRUE);

}  //*** CClusterNetPriorityPage::OnUp

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnDown
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Down push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnDown(void)
{
    int         isel;
    CNetwork *  pciNet;

    isel = m_lbList.GetCurSel();
    ASSERT(isel != LB_ERR);

    pciNet = (CNetwork *) m_lbList.GetItemDataPtr(isel);
    ASSERT_VALID(pciNet);

    VERIFY(m_lbList.DeleteString(isel) != LB_ERR);
    isel = m_lbList.InsertString(isel + 1, pciNet->StrName());
    ASSERT(isel != LB_ERR);
    VERIFY(m_lbList.SetItemDataPtr(isel, pciNet) != LB_ERR);
    VERIFY(m_lbList.SetCurSel(isel) != LB_ERR);

    OnSelChangeList();
    m_lbList.SetFocus();

    SetModified(TRUE);

}  //*** CClusterNetPriorityPage::OnDown

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnProperties(void)
{
    DisplayProperties();

}  //*** CClusterNetPriorityPage::OnProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::FillList
//
//  Routine Description:
//      Fill the network list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::FillList(void)
{
    int         nIndex;
    POSITION    pos;
    CNetwork *  pciNet;
    CWaitCursor wc;

    ClearNetworkList();
    PciCluster()->CollectNetworkPriority(NULL);

    pos = LpciNetworkPriority().GetHeadPosition();
    while (pos != NULL)
    {
        pciNet = (CNetwork *) LpciNetworkPriority().GetNext(pos);
        ASSERT_VALID(pciNet);

        try
        {
            nIndex = m_lbList.AddString(pciNet->StrName());
            ASSERT(nIndex != LB_ERR);
            m_lbList.SetItemDataPtr(nIndex, pciNet);
            pciNet->AddRef();
        }  // try
        catch (...)
        {
            // Ignore all errors because there is really nothing we can do.
            // Displaying a message isn't really very useful.
        }  // catch:  Anything
    }  // while:  more items in the list

}  // CClusterNetPriorityPage::FillList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::ClearNetworkList
//
//  Routine Description:
//      Clear the network list and release references to pointers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::ClearNetworkList(void)
{
    int         cItems;
    int         iItem;
    CNetwork *  pciNet;

    cItems = m_lbList.GetCount();
    for (iItem = 0 ; iItem < cItems ; iItem++)
    {
        pciNet = (CNetwork *) m_lbList.GetItemDataPtr(iItem);
        ASSERT_VALID(pciNet);
        ASSERT_KINDOF(CNetwork, pciNet);
        pciNet->Release();
    }  // for:  each item in the list

    m_lbList.ResetContent();

}  //*** CClusterNetPriorityPage::ClearNetworkList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::DisplayProperties
//
//  Routine Description:
//      Display properties of the item with the focus.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::DisplayProperties( void )
{
    int         isel;
    CNetwork *  pciNet;

    isel = m_lbList.GetCurSel();
    ASSERT(isel != LB_ERR);

    if (isel != LB_ERR)
    {
        // Get the network pointer.
        pciNet = (CNetwork *) m_lbList.GetItemDataPtr(isel);
        ASSERT_VALID(pciNet);

        // Set properties of that item.
        if (pciNet->BDisplayProperties())
        {
            // Remove the item.  If it is still used for internal cluster
            // communications, add it back in.
            VERIFY(m_lbList.DeleteString(isel) != LB_ERR);
            if (pciNet->Cnr() & ClusterNetworkRoleInternalUse)
            {
                isel = m_lbList.InsertString(isel, pciNet->StrName());
                ASSERT(isel != LB_ERR);
                VERIFY(m_lbList.SetItemDataPtr(isel, pciNet) != LB_ERR);
                VERIFY(m_lbList.SetCurSel(isel) != LB_ERR);
            }  // if:  still used for internal cluster communications
            else
            {
                pciNet->Release();
            }

            // Make sure only appropriate buttons are enabled.
            OnSelChangeList();
        }  // if:  properties changed
        m_lbList.SetFocus();
    }  // if:  found an item with focus

}  //*** CClusterNetPriorityPage::DisplayProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnContextMenu( CWnd * pWnd, CPoint point )
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListBox *      pListBox    = (CListBox *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list box, don't handle the message.
    if ( pWnd == &m_lbList )
    {
        // Create the menu to display.
        try
        {
            pmenu = new CMenu;
            if ( pmenu == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating memory
            if ( pmenu->CreatePopupMenu() )
            {
                UINT    nFlags  = MF_STRING;

                // If there are no items in the list, disable the menu item.
                if ( pListBox->GetCount() == 0 )
                {
                    nFlags |= MF_GRAYED;
                } // if: no items in the list

                // Add the Properties item to the menu.
                strMenuName.LoadString( IDS_MENU_PROPERTIES );
                if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
                {
                    bHandled = TRUE;
                }  // if:  successfully added menu item
            }  // if:  menu created successfully
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // if:  focus is on the list control

    if ( bHandled )
    {
        // Display the menu.
        if ( ! pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        this
                        ) )
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display
    else
    {
        CBasePropertyPage::OnContextMenu( pWnd, point );
    } // else: no menu to display

    delete pmenu;

}  //*** CClusterNetPriorityPage::OnContextMenu

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnDblClkList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnDblClkList( void )
{
    DisplayProperties();

}  //*** CClusterNetPriorityPage::OnDblClkList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\cmdline.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		CmdLine.cpp
//
//	Abstract:
//		Implementation of the CCluAdminCommandLineInfo class.
//
//	Author:
//		David Potter (davidp)	March 31, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CmdLine.h"
#include "TraceTag.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagCmdLine(_T("App"), _T("CmdLine"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CCluAdminCommandLineInfo
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCluAdminCommandLineInfo::CCluAdminCommandLineInfo
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluAdminCommandLineInfo::CCluAdminCommandLineInfo(void)
{
	m_nShellCommand = CCommandLineInfo::FileNothing;	// Don't want to do a FileNew.
	m_bReconnect = TRUE;

}  //*** CCluAdminCommandLineInfo::CCluAdminCommandLineInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCluAdminCommandLineInfo::ParseParam
//
//	Routine Description:
//		Parse a command line parameter.
//
//	Arguments:
//		pszParam		[IN] Parameter to parse.
//		bFlag			[IN] TRUE = parameter is a flag.
//		bLast			[IN] TRUE = parameter is the last parameter on the command line.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdminCommandLineInfo::ParseParam(
	const TCHAR *	pszParam,
	BOOL			bFlag,
	BOOL			bLast
	)
{
	if (bFlag)
	{
		CString	str1;
		CString	str2;

		str1.LoadString(IDS_CMDLINE_NORECONNECT);
		str2.LoadString(IDS_CMDLINE_NORECON);

		if (   (str1.CompareNoCase(pszParam) == 0)
			|| (str2.CompareNoCase(pszParam) == 0))
			m_bReconnect = FALSE;
	}  // if:  this is a flag parameter
	else
	{
		m_lstrClusters.AddTail(pszParam);
		m_nShellCommand = CCommandLineInfo::FileOpen;
		m_bReconnect = FALSE;
	}  // else:  this is not a flag parameter

}  //*** CCluAdminCommandLineInfo::ParseParam()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\cmdline.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		CmdLine.h
//
//	Abstract:
//		Definition of the CCluAdminCommandLineInfo class.
//
//	Implementation File:
//		CmdLine.cpp
//
//	Author:
//		David Potter (davidp)	March 31, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CMDLINE_H_
#define _CMDLINE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdminCommandLineInfo;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CCluAdminCommandLineInfo
/////////////////////////////////////////////////////////////////////////////

class CCluAdminCommandLineInfo : public CCommandLineInfo
{
public:
	CCluAdminCommandLineInfo(void);

// Attributes
public:
	CStringList		m_lstrClusters;
	BOOL			m_bReconnect;

	CStringList &	LstrClusters(void) { return m_lstrClusters; }

// Operations
public:

// Overrides
public:
	virtual void ParseParam(IN const TCHAR * pszParam, IN BOOL bFlag, IN BOOL bLast);

// Implementation
public:

protected:

};  //*** class CCluAdminCommandLineInfo

/////////////////////////////////////////////////////////////////////////////

#endif // _CMDLINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\cluster.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Cluster.cpp
//
//  Abstract:
//      Implementation of the CCluster class.
//
//  Author:
//      David Potter (davidp)   May 13, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Cluster.h"
#include "CASvc.h"
#include "ClusDoc.h"
#include "ClusProp.h"
#include "ExcOper.h"
#include "ClusItem.inl"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagCluster( _T("Document"), _T("CLUSTER"), 0 );
#endif

/////////////////////////////////////////////////////////////////////////////
// CCluster
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CCluster, CClusterItem )

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CCluster, CClusterItem )
    //{{AFX_MSG_MAP(CCluster)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::CCluster
//
//  Routine Description:
//      Default construtor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluster::CCluster( void ) : CClusterItem( NULL, IDS_ITEMTYPE_CLUSTER )
{
    m_idmPopupMenu = IDM_CLUSTER_POPUP;

    ZeroMemory( &m_cvi, sizeof( m_cvi ) );
    m_nMaxQuorumLogSize = 0;

    m_plpciNetworkPriority = NULL;

    // Set the object type and state images.
    m_iimgObjectType = GetClusterAdminApp()->Iimg( IMGLI_CLUSTER );
    m_iimgState = m_iimgObjectType;

    // Setup the property array.
    {
        m_rgProps[epropDefaultNetworkRole].Set(CLUSREG_NAME_CLUS_DEFAULT_NETWORK_ROLE, m_nDefaultNetworkRole, m_nDefaultNetworkRole);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_CLUS_DESC, m_strDescription, m_strDescription);
        m_rgProps[epropEnableEventLogReplication].Set(CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION, m_bEnableEventLogReplication, m_bEnableEventLogReplication);
        m_rgProps[epropQuorumArbitrationTimeMax].Set(CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT, m_nQuorumArbitrationTimeMax, m_nQuorumArbitrationTimeMax);
        m_rgProps[epropQuorumArbitrationTimeMin].Set(CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER, m_nQuorumArbitrationTimeMin, m_nQuorumArbitrationTimeMin);
    } // Setup the property array

}  //*** CCluster::CCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::~CCluster
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluster::~CCluster( void )
{
    Cleanup();

}  //*** CCluster::~CCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Cleanup( void )
{
    // Delete the NetworkPriority list.
    if ( m_plpciNetworkPriority != NULL )
    {
        m_plpciNetworkPriority->RemoveAll();
        delete m_plpciNetworkPriority;
        m_plpciNetworkPriority = NULL;
    }  // if:  NetworkPriority list exists

    m_hkey = NULL;

}  //*** CCluster::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc            [IN OUT] Document to which this item belongs.
//      lpszName        [IN] Name of the item.
//      hOpenedCluster  [IN] Handle to cluster to use that is already open.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenCluster(), GetClusterKey(), or
//                          CreateClusterNotifyPort().
//      Any exceptions thrown by CCluster::ReadClusterInfo().
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Init(
    IN OUT CClusterDoc *    pdoc,
    IN LPCTSTR              lpszName,
    IN HCLUSTER             hOpenedCluster // = NULL
    )
{
    CWaitCursor wc;
    TCHAR       szClusterName[ MAX_PATH ];
    DWORD       scLastError;

    ASSERT( Hkey() == NULL );
    ASSERT( _tcslen( lpszName ) < RTL_NUMBER_OF( szClusterName ) );

    try
    {
        // If connecting the local machine, get its name.
        if ( _tcscmp( lpszName, _T(".") ) == 0 )
        {
            DWORD   nSize = sizeof( szClusterName ) / sizeof( TCHAR );
            GetComputerName( szClusterName, &nSize );
        }  // if:  connecting to the local machine
        else
        {
            HRESULT hr = StringCchCopy( szClusterName, RTL_NUMBER_OF( szClusterName ), lpszName );
            ASSERT( SUCCEEDED( hr ) );
        }  // else:  not connecting to the local machine

        // Open the cluster.
        if ( hOpenedCluster == NULL )
        {
            pdoc->m_hcluster = HOpenCluster( lpszName );
            if ( pdoc->m_hcluster == NULL )
            {
                //
                // GPotts - 7/25/2001
                //
                // HOpenCluster could return NULL and last error = 0 if GetNodeClusterState
                // returned either ClusterStateNotInstalled or ClusterStateNotConfigured.
                //
                scLastError = GetLastError();
                ThrowStaticException( scLastError, IDS_OPEN_CLUSTER_ERROR, szClusterName );

            } // if: error opening the cluster
        }  // if:  no opened cluster passed in
        else
        {
            pdoc->m_hcluster = hOpenedCluster;
        } // if: cluster already opened

        // Get the cluster registry key.
        pdoc->m_hkeyCluster = GetClusterKey( pdoc->m_hcluster, MAXIMUM_ALLOWED );
        if ( pdoc->m_hkeyCluster == NULL )
        {
            ThrowStaticException( GetLastError(), IDS_GET_CLUSTER_KEY_ERROR, szClusterName );
        } // if: error opening the cluster key

        // Call the base class method.  We can use Hcluster() after calling this.
        CClusterItem::Init( pdoc, szClusterName );

        // Get the cluster registry key.
        m_hkey = pdoc->m_hkeyCluster;

        // Register this cluster with the notification port.
        {
            HCHANGE     hchange;

            // We want these notifications to go to the document, not us.
            ASSERT( Pcnk() != NULL );
            m_pcnk->m_cnkt = cnktDoc;
            m_pcnk->m_pdoc = pdoc;
            Trace( g_tagClusItemNotify, _T("CCluster::Init() - Registering for cluster notifications (%08.8x)"), Pcnk() );

            // Create the notification port.
            hchange = CreateClusterNotifyPort(
                            GetClusterAdminApp()->HchangeNotifyPort(),
                            Hcluster(),
                            (CLUSTER_CHANGE_NODE_ADDED
                                | CLUSTER_CHANGE_GROUP_ADDED
                                | CLUSTER_CHANGE_RESOURCE_ADDED
                                | CLUSTER_CHANGE_RESOURCE_TYPE_ADDED
                                | CLUSTER_CHANGE_RESOURCE_TYPE_DELETED
                                | CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY
                                | CLUSTER_CHANGE_NETWORK_ADDED
                                | CLUSTER_CHANGE_NETINTERFACE_ADDED
                                | CLUSTER_CHANGE_QUORUM_STATE
                                | CLUSTER_CHANGE_CLUSTER_STATE
                                | CLUSTER_CHANGE_CLUSTER_PROPERTY
                                | CLUSTER_CHANGE_REGISTRY_NAME
                                | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                | CLUSTER_CHANGE_REGISTRY_VALUE
                                | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                            (DWORD_PTR) Pcnk()
                            );
            if ( hchange == NULL )
            {
                ThrowStaticException( GetLastError(), IDS_CLUSTER_NOTIF_REG_ERROR, szClusterName );
            } // if: error creating the notify port
            ASSERT( hchange == GetClusterAdminApp()->HchangeNotifyPort() );
        }  // Register this cluster with the notification port

        // Get the name of the cluster as recorded by the cluster.
        ReadClusterInfo();

        // Allocate lists.
        m_plpciNetworkPriority = new CNetworkList;
        if ( m_plpciNetworkPriority == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the network list

        // Read the initial state.
        UpdateState();
    }  // try
    catch ( CException * )
    {
        if ( pdoc->m_hkeyCluster != NULL )
        {
            ClusterRegCloseKey( pdoc->m_hkeyCluster );
            pdoc->m_hkeyCluster = NULL;
            m_hkey = NULL;
        }  // if:  registry key opened
        if ( ( pdoc->m_hcluster != NULL ) && ( pdoc->m_hcluster != hOpenedCluster ) )
        {
            CloseCluster( pdoc->m_hcluster );
            pdoc->m_hcluster = NULL;
        }  // if:  group opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CCluster::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue() or
//                              CClusterItem::ReadItem().
//      Any exceptions thrown by CCluster::ReadExtensions().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadItem( void )
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT( Hcluster() != NULL );
    ASSERT( Hkey() != NULL );

    if ( Hcluster() != NULL )
    {
        m_rgProps[epropDefaultNetworkRole].m_value.pdw = &m_nDefaultNetworkRole;
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
        m_rgProps[epropEnableEventLogReplication].m_value.pb = &m_bEnableEventLogReplication;
        m_rgProps[epropQuorumArbitrationTimeMax].m_value.pdw = &m_nQuorumArbitrationTimeMax;
        m_rgProps[epropQuorumArbitrationTimeMin].m_value.pdw = &m_nQuorumArbitrationTimeMin;

        // Call the base class method.
        try
        {
            CClusterItem::ReadItem();
        }  // try
        catch ( CNTException * pnte )
        {
            dwRetStatus = pnte->Sc();
            pnte->Delete();
        }  // catch:  CNTException

        // Get the name of the cluster as recorded by the cluster.
        ReadClusterInfo();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            Trace( g_tagCluster, _T("(%x) - CCluster::ReadItem() - Getting common properties"), this );
            dwStatus = cpl.ScGetClusterProperties(
                                Hcluster(),
                                CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                Trace( g_tagCluster, _T("(%x) - CCluster::ReadItem() - Parsing common properties"), this );
                dwStatus = DwParseProperties(cpl);
            } // if: properties read successfully
            if (dwStatus != ERROR_SUCCESS)
            {
                Trace( g_tagError, _T("(%x) - CCluster::ReadItem() - Error 0x%08.8x getting or parsing common properties"), this, dwStatus );

                // PROCNUM_OUT_OF_RANGE occurs when the server side
                // (clussvc.exe) doesn't support the ClusterControl( )
                // API.  In this case, read the data using the cluster
                // registry APIs.
                if ( dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE )
                {
                    if ( Hkey() != NULL )
                    {
                        // Read the Description
                        dwStatus = DwReadValue( CLUSREG_NAME_CLUS_DESC, m_strDescription );
                        if ( ( dwStatus != ERROR_SUCCESS )
                          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
                        {
                            dwRetStatus = dwStatus;
                        } // if: error reading the value
                    } // if: key is available
                } // if: must be talking to an NT4 node
                else
                {
                    dwRetStatus = dwStatus;
                } // else: not talking to an NT4 node
            } // if: error reading or parsing properties
        } // Read and parse the common properties

        // Get quorum resource information.
        {
            LPWSTR      pwszQResName    = NULL;
            LPWSTR      pwszQuorumPath  = NULL;
            DWORD       cchQResName;
            DWORD       cchQuorumPath;

            // Get the size of the resource name.
            cchQResName = 0;
            cchQuorumPath = 0;
            dwStatus = GetClusterQuorumResource(
                                Hcluster(),
                                NULL,
                                &cchQResName,
                                NULL,
                                &cchQuorumPath,
                                &m_nMaxQuorumLogSize
                                );
            if ( ( dwStatus == ERROR_SUCCESS ) || ( dwStatus == ERROR_MORE_DATA ) )
            {
                // Allocate enough space for the data.
                cchQResName++;  // Don't forget the final null-terminator.
                pwszQResName = new WCHAR[ cchQResName ];
                cchQuorumPath++;
                pwszQuorumPath = new WCHAR[ cchQuorumPath ];
                ASSERT( pwszQResName != NULL && pwszQuorumPath != NULL );


                // Read the resource name.
                dwStatus = GetClusterQuorumResource(
                                    Hcluster(),
                                    pwszQResName,
                                    &cchQResName,
                                    pwszQuorumPath,
                                    &cchQuorumPath,
                                    &m_nMaxQuorumLogSize
                                    );
            }  // if:  got the size successfully
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error occurred
            else
            {
                m_strQuorumResource = pwszQResName;
                m_strQuorumPath = pwszQuorumPath;
                ASSERT( m_strQuorumPath[ m_strQuorumPath.GetLength() - 1 ] == _T('\\') );
            }  // else:  quorum resource info retrieved successfully

            delete [] pwszQResName;
            delete [] pwszQuorumPath;
        }  // Get the quorum resource name

    }  // if:  cluster is available

    // If any errors occurred, throw an exception.
    if ( dwRetStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwRetStatus, IDS_READ_CLUSTER_PROPS_ERROR, StrName() );
    } // if: error occurred

    // Read extension lists.
    ReadClusterExtensions();
    ReadNodeExtensions();
    ReadGroupExtensions();
    ReadResourceExtensions();
    ReadResTypeExtensions();
    ReadNetworkExtensions();
    ReadNetInterfaceExtensions();

    // Read the initial state.
    UpdateState();

    MarkAsChanged( FALSE );

}  //*** CCluster::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::PlstrExtensions
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CCluster::PlstrExtensions( void ) const
{
    return &LstrClusterExtensions();

}  //*** CCluster::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadClusterInfo
//
//  Routine Description:
//      Get the name of the cluster as recorded by the cluster and the
//      version of the cluster software.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadClusterInfo( void )
{
    CWaitCursor wc;
    GetClusterInformation( Hcluster(), m_strName, &m_cvi );
    Pdoc()->m_strName = m_strName;
}  //*** CCluster::ReadClusterInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadClusterExtensions
//
//  Routine Description:
//      Read the extension list for the cluster object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadClusterExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Cluster extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, m_lstrClusterExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrClusterExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadClusterExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadNodeExtensions
//
//  Routine Description:
//      Read the extension list for all nodes.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadNodeExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Nodes extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_NODES, m_lstrNodeExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrNodeExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadNodeExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadGroupExtensions
//
//  Routine Description:
//      Read the extension list for all groups.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadGroupExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Groups extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_GROUPS, m_lstrGroupExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrGroupExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadGroupExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadResourceExtensions
//
//  Routine Description:
//      Read the extension list for all resources.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadResourceExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Resources extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_RESOURCES, m_lstrResourceExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrResourceExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadResourceExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadResTypeExtensions
//
//  Routine Description:
//      Read the extension list for all resouce types.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadResTypeExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Resource Types extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_RESOURCE_TYPES, m_lstrResTypeExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if: key is available
    else
    {
        m_lstrResTypeExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadResTypeExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadNetworkExtensions
//
//  Routine Description:
//      Read the extension list for all networks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadNetworkExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Networks extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_NETWORKS, m_lstrNetworkExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrNetworkExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadNetworkExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadNetInterfaceExtensions
//
//  Routine Description:
//      Read the extension list for all network interfaces.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadNetInterfaceExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Network Intefaces extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_NETINTERFACES, m_lstrNetInterfaceExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrNetInterfaceExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadNetInterfaceExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::CollecNetworkPriority
//
//  Routine Description:
//      Construct the network priority list.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterOpenEnum() or ClusterEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::CollectNetworkPriority( IN OUT CNetworkList * plpci )
{
    DWORD           dwStatus;
    HCLUSENUM       hclusenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CNetwork *      pciNet;
    CWaitCursor     wc;

    ASSERT_VALID( Pdoc() );
    ASSERT( Hcluster() != NULL );

    if ( plpci == NULL )
    {
        plpci = m_plpciNetworkPriority;
    } // if: no list specified

    ASSERT( plpci != NULL );

    // Remove the previous contents of the list.
    plpci->RemoveAll();

    if ( Hcluster() != NULL )
    {
        // Open the enumeration.
        hclusenum = ClusterOpenEnum( Hcluster(), (DWORD) CLUSTER_ENUM_INTERNAL_NETWORK );
        if ( hclusenum == NULL )
        {
            ThrowStaticException( GetLastError(), IDS_ENUM_NETWORK_PRIORITY_ERROR, StrName() );
        } // if: error opening the enmeration

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[ cchmacName ];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            // Loop through the enumeration and add each network to the list.
            for ( ienum = 0 ; ; ienum++ )
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterEnum( hclusenum, ienum, &dwRetType, pwszName, &cchName );
                if ( dwStatus == ERROR_MORE_DATA )
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[ cchmacName ];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating the name buffer
                    dwStatus = ClusterEnum( hclusenum, ienum, &dwRetType, pwszName, &cchName );
                }  // if:  name buffer was too small
                if ( dwStatus == ERROR_NO_MORE_ITEMS )
                {
                    break;
                } // if: done with the enumeraiton
                else if ( dwStatus != ERROR_SUCCESS )
                {
                    ThrowStaticException( dwStatus, IDS_ENUM_NETWORK_PRIORITY_ERROR, StrName() );
                } // else if: error getting the next enumeration value

                ASSERT( dwRetType == CLUSTER_ENUM_INTERNAL_NETWORK );

                // Find the item in the list of networks on the document.
                pciNet = Pdoc()->LpciNetworks().PciNetworkFromName( pwszName );
                ASSERT_VALID( pciNet );

                // Add the network to the list.
                if ( pciNet != NULL )
                {
                    plpci->AddTail( pciNet );
                }  // if:  found network in list

            }  // for:  each item in the group

            ClusterCloseEnum( hclusenum );

        }  // try
        catch ( CException * )
        {
            delete [] pwszName;
            ClusterCloseEnum( hclusenum );
            throw;
        }  // catch:  any exception
    }  // if:  cluster is available

    delete [] pwszName;

}  //*** CCluster::CollecNetworkPriority()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::OnUpdateProperties( CCmdUI * pCmdUI )
{
    pCmdUI->Enable(TRUE);

}  //*** CCluster::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluster::BDisplayProperties( IN BOOL bReadOnly )
{
    BOOL                bChanged = FALSE;
    CClusterPropSheet   sht( AfxGetMainWnd() );

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if ( BChanged() )
    {
        ReadItem();
    } // if: object changed

    // Display the property sheet.
    try
    {
        sht.SetReadOnly( bReadOnly );
        if ( sht.BInit( this, IimgObjectType() ) )
        {
            bChanged = ( ( sht.DoModal() == IDOK ) && ! bReadOnly );
        } // if: initialized successfully
    }  // try
    catch ( CException * pe )
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CCluster::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::SetName
//
//  Routine Description:
//      Set the name of the cluster.
//
//  Arguments:
//      pszName         [IN] New name of the cluster.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::SetName( IN LPCTSTR pszName )
{
    Rename( pszName );

}  //*** CCluster::SetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::SetDescription
//
//  Routine Description:
//      Set the description in the cluster database.
//
//  Arguments:
//      pszDesc     [IN] Description to set.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::SetDescription( IN LPCTSTR pszDesc )
{
    ASSERT( Hkey() != NULL );

    if ( ( Hkey() != NULL ) && ( m_strDescription != pszDesc ) )
    {
        WriteValue( CLUSREG_NAME_CLUS_DESC, NULL, pszDesc );
        m_strDescription = pszDesc;
    }  // if:  a change occured

}  //*** CCluster::SetDescription()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::SetQuorumResource
//
//  Routine Description:
//      Set the quorum resource for the cluster.
//
//  Arguments:
//      pszResource     [IN] Name of resource to make the quorum resource.
//      pszQuorumPath   [IN] Path for storing cluster files.
//      nMaxLogSize     [IN] Maximum size of the quorum log.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_SET_QUORUM_RESOURCE_ERROR - errors from
//                          SetClusterQuorumResource().
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::SetQuorumResource(
    IN LPCTSTR  pszResource,
    IN LPCTSTR  pszQuorumPath,
    IN DWORD    nMaxLogSize
    )
{
    DWORD       dwStatus;
    CResource * pciRes;
    CString     strRes( pszResource );  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT( pszResource != NULL );

    if ( ( StrQuorumResource() != pszResource )
      || ( StrQuorumPath() != pszQuorumPath )
      || ( NMaxQuorumLogSize() != nMaxLogSize ) )
    {
        // Find the resource.
        pciRes = Pdoc()->LpciResources().PciResFromName( pszResource );
        ASSERT_VALID( pciRes );
        ASSERT( pciRes->Hresource() != NULL );

        if ( pciRes->Hresource() != NULL )
        {
            // Change the quorum resource.
            dwStatus = SetClusterQuorumResource( pciRes->Hresource(), pszQuorumPath, nMaxLogSize );
            if ( dwStatus != ERROR_SUCCESS )
            {
                ThrowStaticException( dwStatus, IDS_SET_QUORUM_RESOURCE_ERROR, pciRes->StrName() );
            } // if: error setting the quorum resource

            m_strQuorumResource = pszResource;
            m_strQuorumPath = pszQuorumPath;
            m_nMaxQuorumLogSize = nMaxLogSize;
        }  // if:  resource is available
    }  // if:  the quorum resource changed

}  //*** CCluster::SetQuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::SetNetworkPriority
//
//  Routine Description:
//      Set the network priority list.
//
//  Arguments:
//      rlpci       [IN] List of networks in priority order.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by HNETWORK::new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::SetNetworkPriority( IN const CNetworkList & rlpci )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hcluster() != NULL );

    if ( Hcluster() != NULL )
    {
        BOOL        bChanged    = TRUE;

        // Determine if the list has changed.
        if ( rlpci.GetCount() == LpciNetworkPriority().GetCount() )
        {
            POSITION    posOld;
            POSITION    posNew;
            CNetwork *  pciOldNet;
            CNetwork *  pciNewNet;

            bChanged = FALSE;

            posOld = LpciNetworkPriority().GetHeadPosition();
            posNew = rlpci.GetHeadPosition();
            while ( posOld != NULL )
            {
                pciOldNet = (CNetwork *) LpciNetworkPriority().GetNext( posOld );
                ASSERT_VALID( pciOldNet );

                ASSERT( posNew != NULL );
                pciNewNet = (CNetwork *) rlpci.GetNext( posNew );
                ASSERT_VALID( pciNewNet );

                if ( pciOldNet->StrName() != pciNewNet->StrName() )
                {
                    bChanged = TRUE;
                    break;
                }  // if:  name is not the same
            }  // while:  more items in the old list
        }  // if:  same number of items in the list

        if ( bChanged )
        {
            HNETWORK *  phnetwork   = NULL;

            try
            {
                DWORD       ipci;
                POSITION    posPci;
                CNetwork *  pciNet;

                // Allocate an array for all the node handles.
                phnetwork = new HNETWORK[ (DWORD) rlpci.GetCount() ];
                if ( phnetwork == NULL )
                {
                    ThrowStaticException( GetLastError() );
                } // if: error allocating network handle array

                // Copy the handle of all the networks in the networks list to the handle aray.
                posPci = rlpci.GetHeadPosition();
                for ( ipci = 0 ; posPci != NULL ; ipci++ )
                {
                    pciNet = (CNetwork *) rlpci.GetNext( posPci );
                    ASSERT_VALID( pciNet );
                    phnetwork[ ipci ] = pciNet->Hnetwork();
                }  // while:  more networks in the list

                // Set the property.
                dwStatus = SetClusterNetworkPriorityOrder( Hcluster(), (DWORD) rlpci.GetCount(), phnetwork );
                if ( dwStatus != ERROR_SUCCESS )
                {
                    ThrowStaticException( dwStatus, IDS_SET_NET_PRIORITY_ERROR, StrName() );
                } // if: error setting network priority

                // Update the PCI list.
                m_plpciNetworkPriority->RemoveAll();
                posPci = rlpci.GetHeadPosition();
                while ( posPci != NULL )
                {
                    pciNet = (CNetwork *) rlpci.GetNext( posPci );
                    m_plpciNetworkPriority->AddTail( pciNet );
                }  // while:  more items in the list
            } // try
            catch ( CException * )
            {
                delete [] phnetwork;
                throw;
            }  // catch:  CException

            delete [] phnetwork;

        }  // if:  list changed
    }  // if:  key is available

}  //*** CCluster::SetNetworkPriority(CNetworkList*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Rename
//
//  Routine Description:
//      Change the name of the cluster..
//
//  Arguments:
//      pszName         [IN] New name to give to the cluster.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors returned from SetClusterName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Rename( IN LPCTSTR pszName )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hcluster() != NULL );

    if ( StrName() != pszName )
    {
        // Set the name.
        dwStatus = SetClusterName( Hcluster(), pszName );
        if ( dwStatus != ERROR_SUCCESS )
        {
            if ( dwStatus == ERROR_RESOURCE_PROPERTIES_STORED )
            {
                AfxMessageBox( IDS_RESTART_CLUSTER_NAME, MB_OK | MB_ICONEXCLAMATION );
            } // if: properties stored but not in use yet
            else
            {
                ThrowStaticException( dwStatus, IDS_RENAME_CLUSTER_ERROR, StrName(), pszName );
            } // else: error occurred
        }  // if:  error occurred setting cluster name
        m_strName = pszName;
    }  // if:  the name changed

}  //*** CCluster::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::BIsLabelEditValueValid
//
//  Routine Description:
//      Validate the label edit value as a cluster name
//
//  Arguments:
//      pszName         [IN] New name to give to the cluster.
//
//  Return Value:
//      TRUE    name is valid
//      FALSE   name is invalid
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluster::BIsLabelEditValueValid( IN LPCTSTR pszName )
{
    BOOL    bSuccess = TRUE;

    if ( StrName() != pszName )
    {
        CLRTL_NAME_STATUS   cnStatus;
        UINT                idsError;

        // Validate the name.
        if ( ! ClRtlIsNetNameValid( pszName, &cnStatus, FALSE /*CheckIfExists*/ ) )
        {
            switch ( cnStatus )
            {
                case NetNameTooLong:
                    idsError = IDS_INVALID_CLUSTER_NAME_TOO_LONG;
                    break;
                case NetNameInvalidChars:
                    idsError = IDS_INVALID_CLUSTER_NAME_INVALID_CHARS;
                    break;
                case NetNameInUse:
                    idsError = IDS_INVALID_CLUSTER_NAME_IN_USE;
                    break;
                case NetNameDNSNonRFCChars:
                    idsError = IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS;
                    break;
                case NetNameSystemError:
                {
                    DWORD scError = GetLastError();
                    ThrowStaticException( scError, IDS_ERROR_VALIDATING_NETWORK_NAME, pszName );
                }
                default:
                    idsError = IDS_INVALID_CLUSTER_NAME;
                    break;
            } // switch:  cnStatus

            if ( idsError == IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS )
            {
                int id = AfxMessageBox(IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                if ( id == IDNO )
                {
                    bSuccess = FALSE;
                }
            }
            else
            {
                bSuccess = FALSE;
            }
        } // if:  error validating the name
    }  // if:  the name changed

    return bSuccess;
}  //*** CCluster::BIsLabelEditValueValid()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::OnBeginLabelEdit
//
//  Routine Description:
//      Prepare an edit control in a view for editing the cluster name.
//
//  Arguments:
//      pedit       [IN OUT] Edit control to prepare.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::OnBeginLabelEdit( IN OUT CEdit * pedit )
{
    ASSERT_VALID(pedit);

    pedit->SetLimitText( MAX_CLUSTERNAME_LENGTH );
    pedit->ModifyStyle( 0 /*dwRemove*/, ES_UPPERCASE | ES_OEMCONVERT /*dwAdd*/ );

}  //*** CCluster::OnBeginLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::UpdateState( void )
{
    // NOTENOTE: not referneced
    //CClusterAdminApp *    papp = GetClusterAdminApp();

    CString             strTitle;

    GetClusterAdminApp();

    Trace( g_tagCluster, _T("(%s) - Updating state"), StrName() );

    // Update the title of the document.
    ASSERT_VALID( Pdoc() );
    try
    {
        Pdoc()->UpdateTitle();
    }  // try
    catch ( CException * pe )
    {
        pe->Delete();
    }  // catch:  CException

    // Call the base class method.
    CClusterItem::UpdateState();

}  //*** CCluster::UpdateState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\constdef.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ConstDef.h
//
//	Abstract:
//		Definitions of constants used in the Cluster Administrator program.
//
//	Author:
//		David Potter (davidp)	December 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CONSTDEF_H_
#define _CONSTDEF_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

// Service Names

// Resource Names
#define RESNAME_NETWORK_NAME			_T("Network Name")

// Property Names
#define REGPARAM_CONNECTIONS			_T("Connections")
#define REGPARAM_COLUMNS				_T("Columns")
#define REGPARAM_SELECTION				_T("Selection")
#define REGPARAM_SETTINGS				_T("Settings")
#define REGPARAM_WINDOW_POS				_T("WindowPos")
#define REGPARAM_SPLITTER_BAR_POS		_T("SplitterBarPos")
#define REGPARAM_WINDOW_COUNT			_T("WindowCount")
#define REGPARAM_SHOW_TOOL_BAR			_T("ShowToolBar")
#define REGPARAM_SHOW_STATUS_BAR		_T("ShowStatusBar")
#define REGPARAM_EXPANDED				_T("Expanded")
#define REGPARAM_VIEW					_T("View")

#define REGPARAM_PARAMETERS				_T("Parameters")

#define REGPARAM_NAME					_T("Name")

/////////////////////////////////////////////////////////////////////////////
// User Window Messages
/////////////////////////////////////////////////////////////////////////////

#define WM_CAM_RESTORE_DESKTOP		(WM_USER + 1)
#define WM_CAM_CLUSTER_NOTIFY		(WM_USER + 2)
#define WM_CAM_UNLOAD_EXTENSION		(WM_USER + 3)

/////////////////////////////////////////////////////////////////////////////

#endif // _CONSTDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\colitem.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ColItem.cpp
//
//	Abstract:
//		Implementation of the CColumnItem class.
//
//	Author:
//		David Potter (davidp)	May 7, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ColItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColumnItem

IMPLEMENT_DYNCREATE(CColumnItem, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CColumnItem::CColumnItem
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem::CColumnItem(void)
{
	m_colid = 0;
	m_nDefaultWidth = COLI_WIDTH_DEFAULT;
	m_nWidth = COLI_WIDTH_DEFAULT;

}  //*** CColumnItem::CColumnItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CColumnItem::CColumnItem
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		rstrText		[IN] Text that appears on the column header.
//		colid			[IN] Column ID for identifying data relating to this column.
//		nDefaultWidth	[IN] Default width of the column.  Defaults to COLI_WIDTH_DEFAULT if -1.
//		nWidth			[IN] Initial width of the column.  Defaults to nDefaultWidth if -1.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem::CColumnItem(
	IN const CString &	rstrText,
	IN COLID			colid,
	IN int				nDefaultWidth,	// = -1
	IN int				nWidth			// = -1
	)
{
	ASSERT(colid != 0);
	ASSERT(nDefaultWidth > 0);
	ASSERT((nWidth > 0) || (nWidth == -1));

	if (nDefaultWidth == -1)
		nDefaultWidth = COLI_WIDTH_DEFAULT;
	if (nWidth == -1)
		nWidth = nDefaultWidth;

	m_strText = rstrText;
	m_colid = colid;
	m_nDefaultWidth = nDefaultWidth;
	m_nWidth = nWidth;

}  //*** CColumnItem::CColumnItem(pci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CColumnItem::~CColumnItem
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem::~CColumnItem(void)
{
}  //*** CColumnItem::~CColumnItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CColumnItem::PcoliClone
//
//	Routine Description:
//		Clone the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		pcoli		The newly created item that is a clone of this item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem * CColumnItem::PcoliClone(void)
{
	CColumnItem *	pcoli	= NULL;

	pcoli = new CColumnItem(StrText(), NDefaultWidth(), NWidth());
	return pcoli;

}  //*** CColumnItem::PcoliClone()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DeleteAllItemData
//
//	Routine Description:
//		Deletes all item data in a CList.
//
//	Arguments:
//		rlp		[IN OUT] Reference to the list whose data is to be deleted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData(IN OUT CColumnItemList & rlp)
{
	POSITION		pos;
	CColumnItem *	pcoli;

	// Delete all the items in the Contained list.
	pos = rlp.GetHeadPosition();
	while (pos != NULL)
	{
		pcoli = rlp.GetNext(pos);
		ASSERT_VALID(pcoli);
		delete pcoli;
	}  // while:  more items in the list

}  //*** DeleteAllItemData()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\clusprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusProp.cpp
//
//  Abstract:
//      Definition of the cluster property sheet and pages.
//
//  Author:
//      David Potter (davidp)   May 13, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSPROP_H_
#define _CLUSPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"   // for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"   // for CBasePropertySheet
#endif

#ifndef _NETWORK_H_
#include "Network.h"    // for CNetworkList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterGeneralPage;
class CClusterQuorumPage;
class CClusterNetPriorityPage;
class CClusterPropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluster;
class CResource;

/////////////////////////////////////////////////////////////////////////////
// CClusterGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CClusterGeneralPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CClusterGeneralPage)

// Construction
public:
    CClusterGeneralPage(void);
    ~CClusterGeneralPage(void);

    virtual BOOL        BInit(IN OUT CBaseSheet * psht);

// Dialog Data
    //{{AFX_DATA(CClusterGeneralPage)
    enum { IDD = IDD_PP_CLUSTER_GENERAL };
    CEdit   m_editName;
    CEdit   m_editDesc;
    CString m_strName;
    CString m_strDesc;
    CString m_strVendorID;
    CString m_strVersion;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CClusterGeneralPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
//  BOOL                m_bSecurityChanged;

    CClusterPropSheet * PshtCluster(void)               { return (CClusterPropSheet *) Psht(); }
    CCluster *          PciCluster(void)                { return (CCluster *) Pci(); }
//  BOOL                BSecurityChanged(void) const    { return m_bSecurityChanged; }

    // Generated message map functions
    //{{AFX_MSG(CClusterGeneralPage)
    virtual BOOL OnInitDialog();
//  afx_msg void OnBnClickedPermissions();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CClusterQuorumPage dialog
/////////////////////////////////////////////////////////////////////////////

class CClusterQuorumPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CClusterQuorumPage)

// Construction
public:
    CClusterQuorumPage(void);
    ~CClusterQuorumPage(void);

    virtual BOOL        BInit(IN OUT CBaseSheet * psht);

// Dialog Data
    //{{AFX_DATA(CClusterQuorumPage)
    enum { IDD = IDD_PP_CLUSTER_QUORUM };
    CEdit   m_editRootPath;
    CEdit   m_editMaxLogSize;
    CComboBox   m_cboxPartition;
    CComboBox   m_cboxQuorumResource;
    CString m_strQuorumResource;
    CString m_strPartition;
    DWORD   m_nMaxLogSize;
    CString m_strRootPath;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CClusterQuorumPage)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    //
    // This struct will be stored as the data item in the resource drop down.
    // We use the pciRes to get info about the resource and nIndex is the 
    // index of the last selected partition for that resource so that we can
    // remember what the user wanted (rather than default to the first entry
    // every time we select a new resource).
    //
    struct SResourceItemData
    {
        CResource *     pciRes;
        int             nIndex; 
    };

    BOOL                m_bControlsInitialized;
    PBYTE               m_pbDiskInfo;
    DWORD               m_cbDiskInfo;

    //
    // Last saved values to compare against to determine whether to apply chagnes or not.
    //
    CString             m_strSavedResource;
    CString             m_strSavedPartition;
    CString             m_strSavedRootPath;
    DWORD               m_nSavedLogSize;


    BOOL                BControlsInitialized(void) const    { return m_bControlsInitialized; }
    CClusterPropSheet * PshtCluster(void) const             { return (CClusterPropSheet *) Psht(); }
    CCluster *          PciCluster(void) const              { return (CCluster *) Pci(); }

    void                ClearResourceList(void);
    void                ClearPartitionList(void);
    void                FillResourceList(void);
    void                FillPartitionList(IN OUT CResource * pciRes);
    BOOL                BGetDiskInfo(IN OUT CResource & rpciRes);

    void 
    SplitRootPath(
        CResource * pciRes,
        LPTSTR      pszPartitionNameOut,
        DWORD       cchPartition,
        LPTSTR      pszRootPathOut,
        DWORD       cchRootPath
        );

    // Generated message map functions
    //{{AFX_MSG(CClusterQuorumPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnDblClkQuorumResource();
    afx_msg void OnChangeQuorumResource();
    afx_msg void OnChangePartition();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterQuorumPage

/////////////////////////////////////////////////////////////////////////////
// CClusterNetPriorityPage dialog
/////////////////////////////////////////////////////////////////////////////

class CClusterNetPriorityPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CClusterNetPriorityPage)

// Construction
public:
    CClusterNetPriorityPage(void);

// Dialog Data
    //{{AFX_DATA(CClusterNetPriorityPage)
    enum { IDD = IDD_PP_CLUSTER_NET_PRIORITY };
    CButton m_pbProperties;
    CButton m_pbDown;
    CButton m_pbUp;
    CListBox    m_lbList;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CClusterNetPriorityPage)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    BOOL                m_bControlsInitialized;
    CNetworkList        m_lpciNetworkPriority;

    BOOL                BControlsInitialized(void) const    { return m_bControlsInitialized; }
    CClusterPropSheet * PshtCluster(void) const             { return (CClusterPropSheet *) Psht(); }
    CCluster *          PciCluster(void) const              { return (CCluster *) Pci(); }
    CNetworkList &      LpciNetworkPriority(void)           { return m_lpciNetworkPriority; }

    void                FillList(void);
    void                ClearNetworkList(void);
    void                DisplayProperties(void);

    // Generated message map functions
    //{{AFX_MSG(CClusterNetPriorityPage)
    afx_msg void OnSelChangeList();
    virtual BOOL OnInitDialog();
    afx_msg void OnUp();
    afx_msg void OnDown();
    afx_msg void OnProperties();
    afx_msg void OnDestroy();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnDblClkList();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterNetPriorityPage

/////////////////////////////////////////////////////////////////////////////
// CClusterPropSheet
/////////////////////////////////////////////////////////////////////////////

class CClusterPropSheet : public CBasePropertySheet
{
    DECLARE_DYNAMIC(CClusterPropSheet)

// Construction
public:
    CClusterPropSheet(
        IN OUT CWnd *       pParentWnd = NULL,
        IN UINT             iSelectPage = 0
        );
    virtual BOOL                BInit(
                                    IN OUT CClusterItem *   pciCluster,
                                    IN IIMG                 iimgIcon
                                    );

// Attributes
protected:
    CBasePropertyPage *         m_rgpages[3];

    // Pages
    CClusterGeneralPage         m_pageGeneral;
    CClusterQuorumPage          m_pageQuorum;
    CClusterNetPriorityPage     m_pageNetPriority;

    CClusterGeneralPage &       PageGeneral(void)       { return m_pageGeneral; }
    CClusterQuorumPage &        PageQuorum(void)        { return m_pageQuorum; }
    CClusterNetPriorityPage &   PageNetPriority(void)   { return m_pageNetPriority; }

public:
    CCluster *                  PciCluster(void)        { return (CCluster *) Pci(); }

// Operations

// Overrides
protected:
    virtual CBasePropertyPage** Ppages(void);
    virtual int                 Cpages(void);

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterPropSheet)
    //}}AFX_VIRTUAL

// Implementation
public:

    // Generated message map functions
protected:
    //{{AFX_MSG(CClusterPropSheet)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterPropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\colitem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ColItem.h
//
//	Abstract:
//		Definition of the CColumnItem class.
//
//	Author:
//		David Potter (davidp)	May 7, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _COLITEM_H_
#define _COLITEM_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXTEMPL_H__
#include "afxtempl.h"	// for CList
#endif

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define COLI_WIDTH_DEFAULT		75
#define COLI_WIDTH_NAME			125
#define COLI_WIDTH_DISPLAY_NAME	190
#define COLI_WIDTH_TYPE			75
#define COLI_WIDTH_STATE		100
#define COLI_WIDTH_DESCRIPTION	125
#define COLI_WIDTH_OWNER		COLI_WIDTH_NAME
#define COLI_WIDTH_GROUP		COLI_WIDTH_NAME
#define COLI_WIDTH_RESTYPE		100
#define COLI_WIDTH_RESDLL		100
#define COLI_WIDTH_NET_ROLE		100
#define COLI_WIDTH_NET_PRIORITY	75
#define COLI_WIDTH_NODE			75
#define COLI_WIDTH_NETWORK		100
#define COLI_WIDTH_NET_ADAPTER	75
#define COLI_WIDTH_NET_ADDRESS	75
#define COLI_WIDTH_NET_MASK		75

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CColumnItem;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CColumnItem *, CColumnItem *>	CColumnItemList;

/////////////////////////////////////////////////////////////////////////////
// CColumnItem

class CColumnItem : public CObject
{
	DECLARE_DYNCREATE(CColumnItem)
	CColumnItem(void);			// protected constructor used by dynamic creation
	CColumnItem(
		IN const CString &	rstrText,
		IN COLID			colid,
		IN int				nDefaultWidth = -1,
		IN int				nWidth = -1
		);

// Attributes
protected:
	CString			m_strText;
	COLID			m_colid;
	int				m_nDefaultWidth;
	int				m_nWidth;

public:
	CString &		StrText(void)				{ return m_strText; }
	COLID			Colid(void) const			{ return m_colid; }
	int				NDefaultWidth(void) const	{ return m_nDefaultWidth; }
	int				NWidth(void) const			{ return m_nWidth; }

	void			SetWidth(IN int nWidth)		{ m_nWidth = nWidth; }

// Operations
public:
	CColumnItem *	PcoliClone(void);

// Implementation
public:
	virtual ~CColumnItem(void);

protected:

};  //*** class CColumnItem

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void DeleteAllItemData(IN OUT CColumnItemList & rlp);

/////////////////////////////////////////////////////////////////////////////

#endif // _COLITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\dlghelps.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelpS.cpp
//
//	Abstract:
//		Stub for implementation of dialog help classes.
//
//	Author:
//		David Potter (davidp)	February 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\cluster.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Cluster.h
//
//  Abstract:
//      Definition of the CCluster class.
//
//  Author:
//      David Potter (davidp)   May 13, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSTER_H_
#define _CLUSTER_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluster;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResource;
class CNetworkList;

/////////////////////////////////////////////////////////////////////////////
// CCluster command target
/////////////////////////////////////////////////////////////////////////////

class CCluster : public CClusterItem
{
    DECLARE_DYNCREATE(CCluster)

    CCluster(void);         // protected constructor used by dynamic creation
    void            Init(
                        IN OUT CClusterDoc *    pdoc,
                        IN LPCTSTR              lpszName,
                        IN HCLUSTER             hOpenedCluster = NULL
                        );

// Attributes
protected:
    CLUSTERVERSIONINFO      m_cvi;
    CString                 m_strQuorumResource;
    CString                 m_strQuorumPath;
    DWORD                   m_nMaxQuorumLogSize;
    DWORD                   m_nDefaultNetworkRole;
    DWORD                   m_nQuorumArbitrationTimeMax;
    DWORD                   m_nQuorumArbitrationTimeMin;
    BOOL                    m_bEnableEventLogReplication;
    CStringList             m_lstrClusterExtensions;
    CStringList             m_lstrNodeExtensions;
    CStringList             m_lstrGroupExtensions;
    CStringList             m_lstrResourceExtensions;
    CStringList             m_lstrResTypeExtensions;
    CStringList             m_lstrNetworkExtensions;
    CStringList             m_lstrNetInterfaceExtensions;

    CNetworkList *          m_plpciNetworkPriority;

    enum
    {
        epropDefaultNetworkRole = 0,
        epropDescription,
        epropEnableEventLogReplication,
        epropQuorumArbitrationTimeMax,
        epropQuorumArbitrationTimeMin,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(m_rgProps[0]); }

public:
    virtual const CStringList * PlstrExtensions(void) const;
    const CLUSTERVERSIONINFO &  Cvi(void) const                 { return m_cvi; }

    const CString &         StrQuorumResource(void) const       { return m_strQuorumResource; }
    const CString &         StrQuorumPath(void) const           { return m_strQuorumPath; }
    DWORD                   NMaxQuorumLogSize(void) const       { return m_nMaxQuorumLogSize; }

    const CStringList &     LstrClusterExtensions(void) const   { return m_lstrClusterExtensions; }
    const CStringList &     LstrNodeExtensions(void) const      { return m_lstrNodeExtensions; }
    const CStringList &     LstrGroupExtensions(void) const     { return m_lstrGroupExtensions; }
    const CStringList &     LstrResourceExtensions(void) const  { return m_lstrResourceExtensions; }
    const CStringList &     LstrResTypeExtensions(void) const   { return m_lstrResTypeExtensions; }
    const CStringList &     LstrNetworkExtensions(void) const   { return m_lstrNetworkExtensions; }
    const CStringList &     LstrNetInterfaceExtensions(void) const  { return m_lstrNetInterfaceExtensions; }

    const CNetworkList &    LpciNetworkPriority(void) const     { ASSERT(m_plpciNetworkPriority != NULL); return *m_plpciNetworkPriority; }

// Operations
public:
    void                SetName(IN LPCTSTR pszName);
    void                SetDescription(IN LPCTSTR pszDesc);
    void                SetQuorumResource(
                            IN LPCTSTR  pszResource,
                            IN LPCTSTR  pszQuorumPath,
                            IN DWORD    nMaxLogSize
                            );
    void                SetNetworkPriority(IN const CNetworkList & rlpci);

    void                CollectNetworkPriority(IN OUT CNetworkList * plpci);

    void                ReadClusterInfo(void);
    void                ReadClusterExtensions(void);
    void                ReadNodeExtensions(void);
    void                ReadGroupExtensions(void);
    void                ReadResourceExtensions(void);
    void                ReadResTypeExtensions(void);
    void                ReadNetworkExtensions(void);
    void                ReadNetInterfaceExtensions(void);

// Overrides
    virtual void        Cleanup(void);
    virtual void        ReadItem(void);
    virtual void        UpdateState(void);
    virtual void        Rename(IN LPCTSTR pszName);
    virtual BOOL        BCanBeEdited(void) const    { return TRUE; }
    virtual void        OnBeginLabelEdit(IN OUT CEdit * pedit);
    virtual BOOL        BDisplayProperties(IN BOOL bReadOnly = FALSE);
    virtual BOOL        BIsLabelEditValueValid(IN LPCTSTR pszName);

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCluster)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CCluster(void);

protected:
    // Generated message map functions
    //{{AFX_MSG(CCluster)
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

};  //*** class CCluster

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\dataobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DataObj.h
//
//	Abstract:
//		Definition of the CDataObject class, which is the IDataObject
//		class used to transfer data between CluAdmin and the extension DLL
//		handlers.
//
//	Author:
//		David Potter (davidp)	June 4, 1996
//
//	Implementation File:
//		DataObj.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include "CluAdmEx.h"
#endif

#ifndef __cluadmid_h__
#include "CluAdmID.h"
#endif

#ifndef _RESOURCE_H_
#include "resource.h"
#define _RESOURCE_H_
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Declarations
/////////////////////////////////////////////////////////////////////////////

typedef BOOL (*PFGETRESOURCENETWORKNAME)(
					OUT BSTR lpszNetName,
					IN OUT DWORD * pcchNetName,
					IN OUT PVOID pvContext
					);

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDataObject;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;

/////////////////////////////////////////////////////////////////////////////
//
//	class CDataObject
//
//	Purpose:
//		Encapsulates the IDataObject interface for exchanging data with
//		extension DLL handlers.
//
/////////////////////////////////////////////////////////////////////////////
class CDataObject :
	public CObject,
	public IGetClusterUIInfo,
	public IGetClusterDataInfo,
	public IGetClusterObjectInfo,
	public IGetClusterNodeInfo,
	public IGetClusterGroupInfo,
	public IGetClusterResourceInfo,
	public IGetClusterNetworkInfo,
	public IGetClusterNetInterfaceInfo,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CDataObject, &CLSID_CoCluAdminData>
{
	DECLARE_DYNAMIC(CDataObject)

public:
	// Constructors
	CDataObject(void);			// protected constructor used by dynamic creation
	virtual ~CDataObject(void);

	// Second-phase constructor.
	void				Init(
							IN OUT CClusterItem *	pci,
							IN LCID					lcid,
							IN HFONT				hfont,
							IN HICON				hicon
							);

BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IGetClusterUIInfo)
	COM_INTERFACE_ENTRY(IGetClusterDataInfo)
	COM_INTERFACE_ENTRY(IGetClusterObjectInfo)
	COM_INTERFACE_ENTRY(IGetClusterNodeInfo)
	COM_INTERFACE_ENTRY(IGetClusterGroupInfo)
	COM_INTERFACE_ENTRY(IGetClusterResourceInfo)
	COM_INTERFACE_ENTRY(IGetClusterNetworkInfo)
	COM_INTERFACE_ENTRY(IGetClusterNetInterfaceInfo)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CDataObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CDataObject, _T("CLUADMIN.Data"), _T("CLUADMIN.Data"), IDS_CLUADMIN_DESC, THREADFLAGS_BOTH)

// Attributes
protected:
	CClusterItem *		m_pci;			// Cluster item for which a prop sheet is being displayed.
	LCID				m_lcid;			// Locale ID of resources to be loaded by extension.
	HFONT				m_hfont;		// Font for all text.
	HICON				m_hicon;		// Icon for upper left corner.

	PFGETRESOURCENETWORKNAME	m_pfGetResNetName;	// Pointer to static function for getting net name for resource.
	PVOID				m_pvGetResNetNameContext;	// Context for m_pfGetResNetName;

	CClusterItem *		Pci(void)			{ return m_pci; }
	LCID				Lcid(void)			{ return m_lcid; }
	HFONT				Hfont(void)			{ return m_hfont; }
	HICON				Hicon(void)			{ return m_hicon; }

public:
	PFGETRESOURCENETWORKNAME	PfGetResNetName(void) const	{ return m_pfGetResNetName; }
	void				SetPfGetResNetName(PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext)
	{
		m_pfGetResNetName = pfGetResNetName;
		m_pvGetResNetNameContext = pvContext;
	}

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDataObject)
	//}}AFX_VIRTUAL

// ISupportsErrorInfo
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IGetClusterUIInfo
public:
	STDMETHOD_(LCID, GetLocale)(void);
	STDMETHOD_(HFONT, GetFont)(void);
	STDMETHOD_(HICON, GetIcon)(void);

// IGetClusterDataInfo
public:
	STDMETHOD(GetClusterName)(
		OUT BSTR				lpszName,
		IN OUT LONG *			plMaxLength
		);
	STDMETHOD_(HCLUSTER, GetClusterHandle)(void);
	STDMETHOD_(LONG, GetObjectCount)(void);

// IGetClusterObjectInfo
public:
	STDMETHOD(GetObjectName)(
		IN LONG					lObjIndex,
		OUT BSTR				lpszName,
		IN OUT LONG *			plMaxLength
		);
	STDMETHOD_(CLUADMEX_OBJECT_TYPE, GetObjectType)(
		IN LONG					lObjIndex
		);

// IGetClusterNodeInfo
public:
	STDMETHOD_(HNODE, GetNodeHandle)(
		IN LONG					lObjIndex
		);

// IGetClusterGroupInfo
public:
	STDMETHOD_(HGROUP, GetGroupHandle)(
		IN LONG					lObjIndex
		);

// IGetClusterResourceInfo
public:
	STDMETHOD_(HRESOURCE, GetResourceHandle)(
		IN LONG					lObjIndex
		);
	STDMETHOD(GetResourceTypeName)(
		IN LONG					lObjIndex,
		OUT BSTR				lpszResourceTypeName,
		IN OUT LONG *			pcchName
		);
	STDMETHOD_(BOOL, GetResourceNetworkName)(
		IN LONG					lobjIndex,
		OUT BSTR				lpszNetName,
		IN OUT ULONG *			pcchNetName
		);

// IGetClusterNetworkInfo
public:
	STDMETHOD_(HNETWORK, GetNetworkHandle)(
		IN LONG					lObjIndex
		);

// IGetClusterNetInterfaceInfo
public:
	STDMETHOD_(HNETINTERFACE, GetNetInterfaceHandle)(
		IN LONG					lObjIndex
		);

// Implementation
protected:
	AFX_MODULE_STATE *			m_pModuleState;			// Required for resetting our state during callbacks.

};  //*** class CDataObject

/////////////////////////////////////////////////////////////////////////////

#endif // _DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\delres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      DelRes.cpp
//
//  Abstract:
//      Implementation of the CDeleteResourcesDlg class.
//
//  Author:
//      David Potter (davidp)   August 7, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "DelRes.h"
#include "Res.h"
#include "HelpData.h"   // for g_rghelpmapDeleteResource

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteResourcesDlg class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CDeleteResourcesDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CDeleteResourcesDlg)
    ON_NOTIFY(NM_DBLCLK, IDC_DR_RESOURCES_LIST, OnDblClkResourcesList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_DR_RESOURCES_LIST, OnColumnClick)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_BN_CLICKED(IDYES, CBaseDialog::OnOK)
    ON_BN_CLICKED(IDNO, CBaseDialog::OnCancel)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::CDeleteResourcesDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pciRes      [IN] Resource being deleted.
//      plpci       [IN] List of resources which are dependent on pciRes.
//      pParent     [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDeleteResourcesDlg::CDeleteResourcesDlg(
    IN CResource *              pciRes,
    IN const CResourceList *    plpci,
    IN OUT CWnd *               pParent /*=NULL*/
    )
    : CBaseDialog(IDD, g_aHelpIDs_IDD_DELETE_RESOURCES, pParent)
{
    //{{AFX_DATA_INIT(CDeleteResourcesDlg)
    //}}AFX_DATA_INIT

    ASSERT_VALID(pciRes);
    ASSERT(plpci != NULL);

    m_pciRes = pciRes;
    m_plpci = plpci;

}  //*** CDeleteResourcesDlg::CDeleteResourcesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDeleteResourcesDlg::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDeleteResourcesDlg)
    DDX_Control(pDX, IDC_DR_RESOURCES_LIST, m_lcResources);
    //}}AFX_DATA_MAP

}  //*** CDeleteResourcesDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDeleteResourcesDlg::OnInitDialog(void)
{
    int     nitem;

    CBaseDialog::OnInitDialog();

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        dwExtendedStyle = (DWORD)m_lcResources.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcResources.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    // Set the image list for the list control to use.
    m_lcResources.SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_SMALL);

    // Add the columns.
    {
        CString         strColumn;
        try
        {
            strColumn.LoadString(IDS_COLTEXT_NAME);
            m_lcResources.InsertColumn(0, strColumn, LVCFMT_LEFT, COLI_WIDTH_NAME * 3 / 2);
            strColumn.LoadString(IDS_COLTEXT_RESTYPE);
            m_lcResources.InsertColumn(1, strColumn, LVCFMT_LEFT, COLI_WIDTH_RESTYPE * 3 / 2);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // Add the columns

    // Add the resource being deleted to the list.
    nitem = m_lcResources.InsertItem(0, PciRes()->StrName(), PciRes()->IimgObjectType());
    m_lcResources.SetItemText(nitem, 1, PciRes()->StrRealResourceTypeDisplayName());
    m_lcResources.SetItemData(nitem, (DWORD_PTR) PciRes());
    m_pciRes->AddRef();

    // Add the items.
    {
        POSITION        pos;
        int             iitem;
        CResource *     pciRes;

        pos = Plpci()->GetHeadPosition();
        for (iitem = 1 ; pos != NULL ; iitem++)
        {
            pciRes = (CResource *) Plpci()->GetNext(pos);
            ASSERT_VALID(pciRes);
            if (pciRes != PciRes())
            {
                nitem = m_lcResources.InsertItem(iitem, pciRes->StrName(), pciRes->IimgObjectType());
                m_lcResources.SetItemText(nitem, 1, pciRes->StrRealResourceTypeDisplayName());
                m_lcResources.SetItemData(nitem, (DWORD_PTR) pciRes);
                pciRes->AddRef();
            }  // if:  not resource being deleted
        }  // while:  more items in the list
    }  // Add the items

    // Sort the items.
    m_nSortColumn = 0;
    m_nSortDirection = 0;
    m_lcResources.SortItems(CompareItems, (LPARAM) this);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CDeleteResourcesDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDeleteResourcesDlg::OnDestroy(void)
{
    // Dereference all the cluster item pointers.
    if (m_lcResources.m_hWnd != NULL)
    {
        int             ili = -1;
        CClusterItem *  pci;

        while ((ili = m_lcResources.GetNextItem(ili, LVNI_ALL)) != -1)
        {
            pci = (CClusterItem *) m_lcResources.GetItemData(ili);
            ASSERT_VALID(pci);
            ASSERT_KINDOF(CClusterItem, pci);

            pci->Release();
        }  // while:  more items in the list control
    }  // if:  list control has been instantiated

    CBaseDialog::OnDestroy();

}  //*** CDeleteResourcesDlg::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::OnDblClkDependsList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDeleteResourcesDlg::OnDblClkResourcesList(NMHDR * pNMHDR, LRESULT * pResult)
{
    int             iitem;
    CResource *     pciRes;

    // Get the item with the focus.
    iitem = m_lcResources.GetNextItem(-1, LVNI_FOCUSED);
    ASSERT(iitem != -1);

    if (iitem != -1)
    {
        // Get the resource pointer.
        pciRes = (CResource *) m_lcResources.GetItemData(iitem);
        ASSERT_VALID(pciRes);

        // Get properties of that item.
        pciRes->BDisplayProperties(FALSE /*bReadOnly*/);
    }  // if:  found an item with focus

    *pResult = 0;

}  //*** CDeleteResourcesDlg::OnDblClkResourcesList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::OnColumnClick
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDeleteResourcesDlg::OnColumnClick(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    if (m_lcResources.GetItemCount() != 0)
    {
        // Save the current sort column and direction.
        if (pNMListView->iSubItem == m_nSortColumn)
            m_nSortDirection ^= -1;
        else
        {
            m_nSortColumn = pNMListView->iSubItem;
            m_nSortDirection = 0;
        }  // else:  different column

        // Sort the list.
        m_lcResources.SortItems(CompareItems, (LPARAM) this);
    }  // if:  there are items in the list

    *pResult = 0;

}  //*** CDeleteResourcesDlg::OnColumnClick()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CDeleteResourcesDlg::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CResource *         pciRes1 = (CResource *) lparam1;
    CResource *         pciRes2 = (CResource *) lparam2;
    CDeleteResourcesDlg *   pdlg    = (CDeleteResourcesDlg *) lparamSort;
    const CString *     pstr1;
    const CString *     pstr2;
    int                 nResult;

    ASSERT_VALID(pciRes1);
    ASSERT_VALID(pciRes2);
    ASSERT_VALID(pdlg);

    // Get the strings from the list items.
    if (pdlg->m_nSortColumn == 1)
    {
        pstr1 = &pciRes1->StrRealResourceTypeDisplayName();
        pstr2 = &pciRes2->StrRealResourceTypeDisplayName();
    }  //  if:  sorting on name column
    else
    {
        pstr1 = &pciRes1->StrName();
        pstr2 = &pciRes2->StrName();
    }  // else:  sorting on resource type column

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                *pstr1,
                pstr1->GetLength(),
                *pstr2,
                pstr2->GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (pdlg->m_nSortDirection != 0)
        nResult = -nResult;

    return nResult;

}  //*** CDeleteResourcesDlg::CompareItems()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\extdll.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ExtDll.cpp
//
//  Abstract:
//      Implementation of the extension DLL classes.
//
//  Author:
//      David Potter (davidp)   May 31, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <CluAdmEx.h>
#include "CluAdmID.h"
#include "ExtDll.h"
#include "CluAdmin.h"
#include "ExtMenu.h"
#include "TraceTag.h"
#include "ExcOper.h"
#include "ClusItem.h"
#include "BaseSht.h"
#include "BasePSht.h"
#include "BaseWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagExtDll(_T("UI"), _T("EXTENSION DLL"), 0);
CTraceTag   g_tagExtDllRef(_T("UI"), _T("EXTENSION DLL References"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CExtensions
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CExtensions, CObject);

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::CExtensions
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtensions::CExtensions(void)
{
    m_pci   = NULL;
    m_hfont = NULL;
    m_hicon = NULL;

    m_pdoData = NULL;
    m_plextdll = NULL;
    m_psht = NULL;
    m_pmenu = NULL;
    m_plMenuItems = NULL;

    m_nFirstCommandID = (ULONG) -1;
    m_nNextCommandID = (ULONG) -1;
    m_nFirstMenuID = (ULONG) -1;
    m_nNextMenuID = (ULONG) -1;

}  //*** CExtensions::CExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::~CExtensions
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtensions::~CExtensions(void)
{
    UnloadExtensions();

}  //*** CExtensions::~CExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::Init
//
//  Routine Description:
//      Common initialize for all interfaces.
//
//  Arguments:
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pci             [IN OUT] Cluster item to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::Init(
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterItem *   pci,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    CWaitCursor     wc;

    ASSERT( rlstrExtensions.GetCount() > 0 );

    UnloadExtensions();

    // Save parameters.
    m_plstrExtensions = &rlstrExtensions;
    m_pci = pci;
    m_hfont = hfont;
    m_hicon = hicon;

    // Allocate a new Data Object.
    m_pdoData = new CComObject< CDataObject >;
    if ( m_pdoData == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory
    m_pdoData->AddRef();

    // Construct the Data Object.
    Pdo()->Init( pci, GetClusterAdminApp()->Lcid(), hfont, hicon );

    // Allocate the extension list.
    m_plextdll = new CExtDllList;
    if ( m_plextdll == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory
    ASSERT( Plextdll() != NULL );

    // Loop through the extensions and load each one.
    {
        CComObject<CExtensionDll> * pextdll = NULL;
        POSITION                    posName;

        Trace( g_tagExtDll, _T("CExtensions::Init() - %d extensions"), rlstrExtensions.GetCount() );
        posName = rlstrExtensions.GetHeadPosition();
        while ( posName != NULL )
        {
            // Allocate an extension DLL object and add it to the list.
            pextdll = new CComObject< CExtensionDll >;
            if ( pextdll == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating memory
            pextdll->AddRef();
            Plextdll()->AddTail( pextdll );
            try
            {
                pextdll->Init( rlstrExtensions.GetNext( posName ), this );
            }  // try
            catch ( CException * pe )
            {
                POSITION    pos;

                pe->ReportError();
                pe->Delete();

                pos = Plextdll()->Find(pextdll);
                ASSERT( pos != NULL );
                Plextdll()->RemoveAt( pos );
                delete pextdll;
            }  // catch:  anything
        }  // while:  more items in the list
    }  // Loop through the extensions and load each one

}  //*** CExtensions::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::UnloadExtensions
//
//  Routine Description:
//      Unload the extension DLL.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::UnloadExtensions(void)
{
    // Delete all the extension DLL objects.
    if (Plextdll() != NULL)
    {
        POSITION                    pos;
        CComObject<CExtensionDll> * pextdll;

        pos = Plextdll()->GetHeadPosition();
        while (pos != NULL)
        {
            pextdll = Plextdll()->GetNext(pos);
            pextdll->AddRef(); // See comment below.
            pextdll->UnloadExtension();
            if (pextdll->m_dwRef != 2)
            {
                Trace(g_tagError, _T("CExtensions::UnloadExtensions() - Extension DLL has ref count = %d"), pextdll->m_dwRef);
            }

            // We added a reference above.  Combined with the reference that
            // was added when the object was created, we typically will need
            // to release two references.  However, due to bogus code
            // generated by earlier versions of the custom AppWizard where the
            // extension was releasing the interface but not zeroing out its
            // pointer in the error case, we may not need to release the
            // second reference.
            if (pextdll->Release() != 0)
            {
                pextdll->Release();
            } // if: more references to release
        }  // while:  more items in the list
        delete m_plextdll;
        m_plextdll = NULL;
    }  // if:  there is a list of extensions

    if (m_pdoData != NULL)
    {
        if (m_pdoData->m_dwRef != 1)
        {
            Trace(g_tagError, _T("CExtensions::UnloadExtensions() - Data Object has ref count = %d"), m_pdoData->m_dwRef);
        }
        m_pdoData->Release();
        m_pdoData = NULL;
    }  // if:  data object allocated

    m_pci = NULL;
    m_hfont = NULL;
    m_hicon = NULL;

    // Delete all menu items.
    if (PlMenuItems() != NULL)
    {
        POSITION        pos;
        CExtMenuItem *  pemi;

        pos = PlMenuItems()->GetHeadPosition();
        while (pos != NULL)
        {
            pemi = PlMenuItems()->GetNext(pos);
            delete pemi;
        }  // while:  more items in the list
        delete m_plMenuItems;
        m_plMenuItems = NULL;
    }  // if:  there is a list of menu items

}  //*** CExtensions::UnloadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::CreatePropertySheetPages
//
//  Routine Description:
//      Add pages to a property sheet.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pci             [IN OUT] Cluster item to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::CreatePropertySheetPages(
    IN OUT CBasePropertySheet * psht,
    IN const CStringList &      rlstrExtensions,
    IN OUT CClusterItem *       pci,
    IN HFONT                    hfont,
    IN HICON                    hicon
    )
{
    POSITION                    pos;
    CComObject<CExtensionDll> * pextdll;

    ASSERT_VALID(psht);

    m_psht = psht;

    // Initialize for all extensions.
    Init(rlstrExtensions, pci, hfont, hicon);
    ASSERT(Plextdll() != NULL);

    pos = Plextdll()->GetHeadPosition();
    while (pos != NULL)
    {
        pextdll = Plextdll()->GetNext(pos);
        ASSERT_VALID(pextdll);
        try
        {
            pextdll->CreatePropertySheetPages();
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CNTException
    }  // while:  more items in the list

}  //*** CExtensions::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::CreateWizardPages
//
//  Routine Description:
//      Add pages to a wizard.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pci             [IN OUT] Cluster item to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::CreateWizardPages(
    IN OUT CBaseWizard *    psht,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterItem *   pci,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    POSITION                    pos;
    CComObject<CExtensionDll> * pextdll;

    ASSERT_VALID(psht);

    m_psht = psht;

    // Initialize for all extensions.
    Init(rlstrExtensions, pci, hfont, hicon);
    ASSERT(Plextdll() != NULL);

    pos = Plextdll()->GetHeadPosition();
    while (pos != NULL)
    {
        pextdll = Plextdll()->GetNext(pos);
        ASSERT_VALID(pextdll);
        try
        {
            pextdll->CreateWizardPages();
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CNTException
    }  // while:  more items in the list

}  //*** CExtensions::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::AddContextMenuItems
//
//  Routine Description:
//      Query the extension DLL for new menu items to be added to the context
//      menu.
//
//  Arguments:
//      pmenu           [IN OUT] Menu to which items are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pci             [IN OUT] Cluster item to be administered.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::AddContextMenuItems() or
//          CExtMenuItemList::new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::AddContextMenuItems(
    IN OUT CMenu *          pmenu,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterItem *   pci
    )
{
    POSITION                        pos;
    CComObject< CExtensionDll > *   pextdll;

    ASSERT(m_pmenu == NULL);
    ASSERT_VALID(pmenu);

    // Initialize for all extensions.
    Init( rlstrExtensions, pci, NULL, NULL );
    ASSERT( Plextdll() != NULL );

    m_pmenu = pmenu;
    m_nFirstCommandID = CAEXT_MENU_FIRST_ID;
    m_nNextCommandID = m_nFirstCommandID;
    m_nFirstMenuID = 0;
    m_nNextMenuID = m_nFirstMenuID;

    // Create the list of menu items.
    ASSERT( m_plMenuItems == NULL );
    m_plMenuItems = new CExtMenuItemList;
    if ( m_plMenuItems == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory

    pos = Plextdll()->GetHeadPosition();
    while ( pos != NULL )
    {
        pextdll = Plextdll()->GetNext( pos );
        ASSERT_VALID( pextdll );
        try
        {
            pextdll->AddContextMenuItems();
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CNTException
    }  // while:  more items in the list

}  //*** CExtensions::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::BExecuteContextMenuItem
//
//  Routine Description:
//      Execute a command associated with a menu item added to a context menu
//      by the extension DLL.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item chosen by the user.
//
//  Return Value:
//      TRUE            Context menu item was executed.
//      FALSE           Context menu item was not executed.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExceptionDll::BExecuteContextMenuItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtensions::BExecuteContextMenuItem(IN ULONG nCommandID)
{
    BOOL            bHandled    = FALSE;
    HRESULT         hr;
    CExtMenuItem *  pemi;

    // Find the item in our list.
    pemi = PemiFromCommandID(nCommandID);
    if (pemi != NULL)
    {
        Pdo()->AddRef();
        pemi->PiCommand()->AddRef();
        hr = pemi->PiCommand()->InvokeCommand(pemi->NExtCommandID(), Pdo()->GetUnknown());
        if (hr == NOERROR)
        {
            bHandled = TRUE;
        } //if:
    }  // if:  found an item for the command ID

    return bHandled;

}  //*** CExtensions::BExecuteContextMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::BGetCommandString
//
//  Routine Description:
//      Get a command string from a menu ID.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item.
//      rstrMessage     [OUT] String in which to return the message.
//
//  Return Value:
//      TRUE            String is being returned.
//      FALSE           No string is being returned.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::BGetCommandString().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtensions::BGetCommandString(
    IN ULONG        nCommandID,
    OUT CString &   rstrMessage
    )
{
    BOOL            bHandled    = FALSE;
    CExtMenuItem *  pemi;

    // Find the item in our list.
    pemi = PemiFromCommandID(nCommandID);
    if (pemi != NULL)
    {
        rstrMessage = pemi->StrStatusBarText();
        bHandled = TRUE;
    }  // if:  found an item for the command ID

    return bHandled;

}  //*** CExtensions::BGetCommandString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::OnUpdateCommand
//
//  Routine Description:
//      Determines whether extension DLL menu items should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::BOnUpdateCommand().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::OnUpdateCommand(CCmdUI * pCmdUI)
{
    CExtMenuItem *  pemi;

    ASSERT(Plextdll() != NULL);

    // Find the item in our list.
    Trace(g_tagExtDll, _T("OnUpdateCommand() - ID = %d"), pCmdUI->m_nID);
    pemi = PemiFromCommandID(pCmdUI->m_nID);
    if (pemi != NULL)
    {
        Trace(g_tagExtDll, _T("OnUpdateCommand() - Found a match with '%s' ExtID = %d"), pemi->StrName(), pemi->NExtCommandID());

        pCmdUI->Enable( TRUE );

        if ( pCmdUI->m_pMenu != NULL && (pemi->UFlags() != 0) )
        {
            (pCmdUI->m_pMenu)->EnableMenuItem( pCmdUI->m_nID, pemi->UFlags() );
        } // if:

    }  // if:  found an item for the command ID

}  //*** CExtensions::OnUpdateCommand()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtensions::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    return BExecuteContextMenuItem(nID);

}  //*** CExtensions::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::PemiFromCommandID
//
//  Routine Description:
//      Find the menu item for the specified command ID.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item.
//
//  Return Value:
//      pemi            Menu item or NULL if not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem * CExtensions::PemiFromCommandID(IN ULONG nCommandID) const
{
    POSITION        pos;
    CExtMenuItem *  pemi;
    CExtMenuItem *  pemiReturn = NULL;

    if (PlMenuItems() != NULL)
    {
        pos = PlMenuItems()->GetHeadPosition();
        while (pos != NULL)
        {
            pemi = PlMenuItems()->GetNext(pos);
            ASSERT_VALID(pemi);
            if (pemi->NCommandID() == nCommandID)
            {
                pemiReturn = pemi;
                break;
            }  // if:  match was found
        }  // while:  more items in the list
    }  // if:  item list exists

    return pemiReturn;

}  //*** CExtensions::PemiFromCommandID()

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::PemiFromExtCommandID
//
//  Routine Description:
//      Find the menu item for the specified extension command ID.
//
//  Arguments:
//      nExtCommandID   [IN] Extension command ID for the menu item.
//
//  Return Value:
//      pemi            Menu item or NULL if not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem * CExtensions::PemiFromExtCommandID(IN ULONG nExtCommandID) const
{
    POSITION        pos;
    CExtMenuItem *  pemi;
    CExtMenuItem *  pemiReturn = NULL;

    if (PlMenuItems() != NULL)
    {
        pos = PlMenuItems()->GetHeadPosition();
        while (pos != NULL)
        {
            pemi = PlMenuItems()->GetNext(pos);
            ASSERT_VALID(pemi);
            if (pemi->NExtCommandID() == nExtCommandID)
            {
                pemiReturn = pemi;
                break;
            }  // if:  match was found
        }  // while:  more items in the list
    }  // if:  item list exists

    return pemiReturn;

}  //*** CExtensions::PemiFromExtCommandID()
#endif


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CComObject<CExtensionDll>
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CExtensionDll, CObject);

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CoCluAdmin, CExtensionDll)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::CExtensionDll
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtensionDll::CExtensionDll(void)
{
    m_piExtendPropSheet = NULL;
    m_piExtendWizard = NULL;
    m_piExtendContextMenu = NULL;
    m_piInvokeCommand = NULL;

    m_pext = NULL;

    m_pModuleState = AfxGetModuleState();
    ASSERT(m_pModuleState != NULL);

}  //*** CExtensionDll::CExtensionDll()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::~CExtensionDll
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtensionDll::~CExtensionDll(void)
{
    UnloadExtension();
    m_pModuleState = NULL;

}  //*** CExtensionDll::~CExtensionDll()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::Init
//
//  Routine Description:
//      Initialize this class in preparation for accessing the extension.
//
//  Arguments:
//      rstrCLSID       [IN] CLSID of the extension in string form.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    0 (error converting CLSID from string)
//      Any exceptions thrown by CString::operater=().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::Init(
    IN const CString &      rstrCLSID,
    IN OUT CExtensions *    pext
    )
{
    HRESULT     hr;
    CWaitCursor wc;

    ASSERT_VALID(pext);

    Trace(g_tagExtDll, _T("Init() - CLSID = %s"), rstrCLSID);

    // Save parameters.
    ASSERT(StrCLSID().IsEmpty() || (StrCLSID() == rstrCLSID));
    m_strCLSID = rstrCLSID;
    m_pext = pext;

    // Convert the CLSID string to a CLSID.
    hr = ::CLSIDFromString((LPWSTR) (LPCTSTR) rstrCLSID, &m_clsid);
    if (hr != S_OK)
        ThrowStaticException(hr, IDS_CLSIDFROMSTRING_ERROR, rstrCLSID);

}  //*** CExtensionDll::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::LoadInterface
//
//  Routine Description:
//      Load an extension DLL.
//
//  Arguments:
//      riid            [IN] Interface ID.
//
//  Return Value:
//      piUnk           IUnknown interface pointer for interface.
//
//  Exceptions Thrown:
//      CNTException    IDS_EXT_CREATE_INSTANCE_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
IUnknown * CExtensionDll::LoadInterface(IN const REFIID riid)
{
    HRESULT     hr;
    IUnknown *  piUnk;
    CWaitCursor wc;

    // Load the inproc server and get the IShellExtInit interface pointer.
    Trace(g_tagExtDllRef, _T("LoadInterface() - Getting interface pointer"));
    hr = ::CoCreateInstance(
                Rclsid(),
                NULL,
                CLSCTX_INPROC_SERVER,
                riid,
                (LPVOID *) &piUnk
                );
    if ((hr != S_OK)
            && (hr != REGDB_E_CLASSNOTREG)
            && (hr != E_NOINTERFACE)
            )
        ThrowStaticException(hr, IDS_EXT_CREATE_INSTANCE_ERROR, StrCLSID());

    return piUnk;

}  //*** CExtensionDll::LoadInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::UnloadExtension
//
//  Routine Description:
//      Unload the extension DLL.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::UnloadExtension(void)
{
    // Release the interface pointers in the opposite order in which they
    // were obtained.
    ReleaseInterface(&m_piExtendPropSheet);
    ReleaseInterface(&m_piExtendWizard);
    ReleaseInterface(&m_piExtendContextMenu);
    ReleaseInterface(&m_piInvokeCommand);

    m_strCLSID.Empty();

}  //*** CExtensionDll::UnloadExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::CreatePropertySheetPages
//
//  Routine Description:
//      Add pages to a property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::CreatePropertySheetPages(void)
{
    HRESULT     hr;

    ASSERT_VALID(Pext());
    ASSERT(m_piExtendPropSheet == NULL);

    // Load the interface.
    m_piExtendPropSheet = (interface IWEExtendPropertySheet *) LoadInterface(IID_IWEExtendPropertySheet);
    if (m_piExtendPropSheet == NULL)
        return;
    ASSERT(m_piExtendPropSheet != NULL);

    // Add pages from the extension.
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        hr = PiExtendPropSheet()->CreatePropertySheetPages(Pdo()->GetUnknown(), this);
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch

    if ((hr != NOERROR) && (hr != E_NOTIMPL))
        ThrowStaticException(hr, IDS_EXT_ADD_PAGES_ERROR, StrCLSID());

}  //*** CExtensionDll::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::CreateWizardPages
//
//  Routine Description:
//      Add pages to a wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::CreateWizardPages(void)
{
    HRESULT     hr;

    ASSERT_VALID(Pext());
    ASSERT(m_piExtendWizard == NULL);
    ASSERT_VALID(Psht());

    // Load the interface.
    m_piExtendWizard = (interface IWEExtendWizard *) LoadInterface(IID_IWEExtendWizard);
    if (m_piExtendWizard == NULL)
        return;
    ASSERT(m_piExtendWizard != NULL);

    // Add pages from the extension.
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        hr = PiExtendWizard()->CreateWizardPages(Pdo()->GetUnknown(), this);
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch

    if ((hr != NOERROR) && (hr != E_NOTIMPL))
        ThrowStaticException(hr, IDS_EXT_ADD_PAGES_ERROR, StrCLSID());

}  //*** CExtensionDll::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::AddContextMenuItems
//
//  Routine Description:
//      Ask the extension DLL to add items to the menu.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_EXT_QUERY_CONTEXT_MENU_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::AddContextMenuItems(void)
{
    HRESULT     hr;

    ASSERT_VALID(Pext());
    ASSERT_VALID(Pmenu());
    ASSERT(m_piExtendContextMenu == NULL);

    // Load the interface.
    m_piExtendContextMenu = (interface IWEExtendContextMenu *) LoadInterface(IID_IWEExtendContextMenu);
    if (m_piExtendContextMenu == NULL)
        return;
    ASSERT(m_piExtendContextMenu != NULL);

    hr = PiExtendContextMenu()->QueryInterface(IID_IWEInvokeCommand, (LPVOID *) &m_piInvokeCommand);
    if (hr != NOERROR)
    {
        PiExtendContextMenu()->Release();
        m_piExtendContextMenu = NULL;
        ThrowStaticException(hr, IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID());
    }  // if:  error getting the InvokeCommand interface

    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    Trace(g_tagExtDll, _T("CExtensionDll::AddContextMenuItem() - Adding context menu items from '%s'"), StrCLSID());
    try
    {
        hr = PiExtendContextMenu()->AddContextMenuItems(Pdo()->GetUnknown(), this);
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if (hr != NOERROR)
        ThrowStaticException(hr, IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID());

    // Add a separator after the extension's items.
    Trace(g_tagExtDll, _T("CExtensionDll::AddContextMenuItem() - Adding separator"));
    try
    {
        hr = AddExtensionMenuItem(NULL, NULL, (ULONG) -1, 0, MF_SEPARATOR);
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if (hr != NOERROR)
        ThrowStaticException(hr, IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID());

}  //*** CExtensionDll::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::InterfaceSupportsErrorInfo [ISupportsErrorInfo]
//
//  Routine Description:
//      Determines whether the interface supports error info (???).
//
//  Arguments:
//      riid        [IN] Reference to the interface ID.
//
//  Return Value:
//      S_OK        Interface supports error info.
//      S_FALSE     Interface does not support error info.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID * rgiid[] =
    {
        &IID_IWCPropertySheetCallback,
        &IID_IWCWizardCallback,
        &IID_IWCContextMenuCallback,
    };
    int     iiid;

    for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
    {
        if (InlineIsEqualGUID(*rgiid[iiid], riid))
            return S_OK;
    }
    return S_FALSE;

}  //*** CExtensionDll::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::AddPropertySheetPage [IWCPropertySheetCallback]
//
//  Routine Description:
//      Add a page to the property sheet.
//
//  Arguments:
//      hpage           [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CBasePropertySheet::HrAddPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::AddPropertySheetPage(
    IN LONG *   hpage
    )
{
    HRESULT     hr = NOERROR;

    AFX_MANAGE_STATE(m_pModuleState);

    ASSERT(hpage != NULL);
    ASSERT_VALID(Psht());

    // Do this for the release build.
    if ((hpage == NULL)
            || (Psht() == NULL))
        hr = E_INVALIDARG;
    else
        hr = Psht()->HrAddPage((HPROPSHEETPAGE) hpage);

    return hr;

}  //*** CExtensionDll::AddPropertySheetPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::AddWizardPage [IWCWizardCallback]
//
//  Routine Description:
//      Add a page to the wizard.
//
//  Arguments:
//      hpage           [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CBaseSheet::HrAddPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::AddWizardPage(
    IN LONG *   hpage
    )
{
    HRESULT     hr = NOERROR;

    AFX_MANAGE_STATE(m_pModuleState);

    ASSERT(hpage != NULL);
    ASSERT_VALID(Psht());

    // Do this for the release build.
    if ((hpage == NULL) || (Psht() == NULL))
        hr = E_INVALIDARG;
    else
        hr = Psht()->HrAddPage((HPROPSHEETPAGE) hpage);

    return hr;

}  //*** CExtensionDll::AddWizardPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::EnableNext [IWCWizardCallback]
//
//  Routine Description:
//      Enable or disable the NEXT button.  If it is the last page, the
//      FINISH button will be enabled or disabled.
//
//  Arguments:
//      hpage           [IN] Page for which the button is being enabled or
//                          disabled.
//      bEnable         [IN] TRUE = Enable the button, FALSE = disable.
//
//  Return Value:
//      NOERROR         Success.
//      E_INVALIDARG    Unknown hpage specified.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::EnableNext(
    IN LONG *   hpage,
    IN BOOL     bEnable
    )
{
    HRESULT         hr              = NOERROR;
    CBaseWizard *   pwiz;
    DWORD           dwWizButtons;

    AFX_MANAGE_STATE(m_pModuleState);

    ASSERT(hpage != NULL);
    ASSERT_VALID(Psht());
    ASSERT_KINDOF(CBaseWizard, Psht());

    pwiz = (CBaseWizard *) Psht();

    // If this is the last extension page, enable/disable the FINISH button.
    {
        POSITION    pos;
        BOOL        bMatch  = FALSE;

        pos = pwiz->Lhpage().GetHeadPosition();
        while (pos != NULL)
        {
            if (pwiz->Lhpage().GetNext(pos) == hpage)
            {
                bMatch = TRUE;
                break;
            }  // if:  found a match
        }  // while:  more items in the list
        if (!bMatch)
            return E_INVALIDARG;
        if (pos == NULL)
            dwWizButtons = PSWIZB_BACK | (bEnable ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH);
        else
            dwWizButtons = PSWIZB_BACK | (bEnable ? PSWIZB_NEXT : 0);
    }  // If this is the last extension page, set the FINISH button

    // Set wizard buttons.
    pwiz->SetWizardButtons(dwWizButtons);

    return hr;

}  //*** CExtensionDll::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::AddExtensionMenuItem [IWCContextMenuCallback]
//
//  Routine Description:
//      Add a page to the wizard.
//
//  Arguments:
//      lpszName            [IN] Name of item.
//      lpszStatusBarText   [IN] Text to appear on the status bar when the
//                              item is highlighted.
//      nCommandID          [IN] ID for the command when menu item is invoked.
//                              Must not be -1.
//      nSubmenuCommandID   [IN] ID for a submenu.
//      uFlags              [IN] Menu flags.  The following are not supportd:
//                              MF_OWNERDRAW, MF_POPUP
//
//  Return Value:
//      NOERROR             Item added successfully.
//      E_INVALIDARG        MF_OWNERDRAW or MF_POPUP were specified.
//      E_OUTOFMEMORY       Error allocating the item.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::AddExtensionMenuItem(
    IN BSTR     lpszName,
    IN BSTR     lpszStatusBarText,
    IN ULONG    nCommandID,
    IN ULONG    nSubmenuCommandID,
    IN ULONG    uFlags
    )
{
    HRESULT         hr      = NOERROR;
    CExtMenuItem *  pemi    = NULL;

    AFX_MANAGE_STATE( m_pModuleState );

    UNREFERENCED_PARAMETER( nSubmenuCommandID );

    ASSERT_VALID( Pext() );
    ASSERT( ! ( uFlags & (MF_OWNERDRAW | MF_POPUP) ) );
    ASSERT_VALID( Pmenu() );

    // Do this for the release build.
    if ( ( uFlags & (MF_OWNERDRAW | MF_POPUP) ) != 0 )
    {
        hr = E_INVALIDARG;
    } // if: trying to add invalid type of menu item
    else
    {
        ASSERT( Pext()->PemiFromExtCommandID( nCommandID ) == NULL );

        try
        {
            Trace( g_tagExtDll, _T("CExtensionDll::AddExtensionMenuItem() - Adding menu item '%s', ExtID = %d"), lpszName, nCommandID );

            // Allocate a new item.
            pemi = new CExtMenuItem(
                            OLE2CT( lpszName ),
                            OLE2CT( lpszStatusBarText ),
                            nCommandID,
                            NNextCommandID(),
                            NNextMenuID(),
                            uFlags,
                            FALSE, /*bMakeDefault*/
                            PiInvokeCommand()
                            );
            if ( pemi == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating memory

            // Insert the item in the menu.
            if ( ! Pmenu()->InsertMenu( NNextMenuID(), MF_BYPOSITION | uFlags, NNextCommandID(), pemi->StrName() ) )
            {
                ThrowStaticException( ::GetLastError(), IDS_INSERT_MENU_ERROR, pemi->StrName() );
            } // if: error inserting the menu item

            // Add the item to the tail of the list.
            Pext()->PlMenuItems()->AddTail( pemi );
            pemi = NULL;

            // Update the counters.
            Pext()->m_nNextCommandID++;
            Pext()->m_nNextMenuID++;
        }  // try
        catch ( CNTException * pnte )
        {
            hr = pnte->Sc();
            pnte->ReportError();
            pnte->Delete();
        }  // catch:  CException
        catch ( CException * pe )
        {
            hr = E_OUTOFMEMORY;
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // else:  we can add the item

    delete pemi;
    return hr;

}  //*** CExtensionDll::AddExtensionMenuItem()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\extmenu.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ExtMenu.cpp
//
//  Abstract:
//      Implementation of the CExtMenuItem class.
//
//  Author:
//      David Potter (davidp)   August 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExtMenu.h"

/////////////////////////////////////////////////////////////////////////////
// CExtMenuItem
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC( CExtMenuItem, CObject );

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::CExtMenuItem
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem::CExtMenuItem( void )
{
    CommonConstruct();

}  //*** CExtMenuItem::CExtMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::CExtMenuItem
//
//  Routine Description:
//      Constructor.  Caller must check range on ID and flags.
//
//  Arguments:
//      lpszName            [IN] Name of item.
//      lpszStatusBarText   [IN] Text to appear on the status bar when the
//                            item is highlighted.
//      nExtCommandID       [IN] Extension's ID for the command.
//      nCommandID          [IN] ID for the command when menu item is invoked.
//      nMenuItemID         [IN] Index in the menu of the item.
//      uFlags              [IN] Menu flags.
//      bMakeDefault        [IN] TRUE = Make this item the default item.
//      piCommand           [IN OUT] Command interface.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem::CExtMenuItem(
    IN LPCTSTR                  lpszName,
    IN LPCTSTR                  lpszStatusBarText,
    IN ULONG                    nExtCommandID,
    IN ULONG                    nCommandID,
    IN ULONG                    nMenuItemID,
    IN ULONG                    uFlags,
    IN BOOL                     bMakeDefault,
    IN OUT IWEInvokeCommand *   piCommand
    )
{
    CommonConstruct();

    ASSERT( piCommand != NULL );

    m_strName = lpszName;
    m_strStatusBarText = lpszStatusBarText;
    m_nExtCommandID = nExtCommandID;
    m_nCommandID = nCommandID;
    m_nMenuItemID = nMenuItemID;
    m_uFlags = uFlags;
    m_bDefault = bMakeDefault;
    m_piCommand = piCommand;

    // will throw its own exception if it fails
    if ( uFlags & MF_POPUP )
    {
        m_plSubMenuItems = new CExtMenuItemList;
        if ( m_plSubMenuItems == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating memory
    } // if: popup menu

    ASSERT_VALID( this );

}  //*** CExtMenuItem::CExtMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::~CExtMenuItem
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem::~CExtMenuItem( void )
{
    delete m_plSubMenuItems;

    // Nuke data so it can't be used again
    CommonConstruct();

}  //*** CExtMenuItem::~CExtMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::CommonConstruct
//
//  Routine Description:
//      Common object construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtMenuItem::CommonConstruct( void )
{
    m_strName.Empty();
    m_strStatusBarText.Empty();
    m_nExtCommandID = (ULONG) -1;
    m_nCommandID = (ULONG) -1;
    m_nMenuItemID = (ULONG) -1;
    m_uFlags = (ULONG) -1;
    m_bDefault = FALSE;
    m_piCommand = NULL;

    m_plSubMenuItems = NULL;
    m_hmenuPopup = NULL;

}  //*** CExtMenuItem::CommonConstruct()

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::AssertValid
//
//  Routine Description:
//      Assert that the object is valid.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtMenuItem::AssertValid( void )
{
    CObject::AssertValid();

    if ( ( m_nExtCommandID == -1 )
      || ( m_nCommandID == -1 )
      || ( m_nMenuItemID == -1 )
      || ( m_uFlags == -1 )
      || ( ( ( m_uFlags & MF_POPUP ) == 0 ) && ( m_plSubMenuItems != NULL ) )
      || ( ( ( m_uFlags & MF_POPUP ) != 0 ) && ( m_plSubMenuItems == NULL ) )
        )
    {
        ASSERT( FALSE );
    }

}  //*** CExtMenuItem::AssertValid()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\dataobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      DataObj.cpp
//
//  Abstract:
//      Implementation of the CDataObject class, which is the IDataObject
//      class used to transfer data between CluAdmin and the extension DLL
//      handlers.
//
//  Author:
//      David Potter (davidp)   June 4, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <CluAdmEx.h>
#include "DataObj.h"
#include "ClusItem.h"
#include "ClusItem.inl"
#include "Res.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

// Object type map.
static IDS  g_rgidsObjectType[] =
{
    NULL,
    IDS_ITEMTYPE_CLUSTER,
    IDS_ITEMTYPE_NODE,
    IDS_ITEMTYPE_GROUP,
    IDS_ITEMTYPE_RESOURCE,
    IDS_ITEMTYPE_RESTYPE,
    IDS_ITEMTYPE_NETWORK,
    IDS_ITEMTYPE_NETIFACE
};
#define RGIDS_OBJECT_TYPE_SIZE  sizeof(g_rgidsObjectType) / sizeof(IDS)

/////////////////////////////////////////////////////////////////////////////
// CDataObject
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CDataObject, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::CDataObject
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDataObject::CDataObject(void)
{
    m_pci = NULL;
    m_lcid = NULL;
    m_hfont = NULL;
    m_hicon = NULL;

    m_pfGetResNetName = NULL;

    m_pModuleState = AfxGetModuleState();
    ASSERT(m_pModuleState != NULL);

}  //*** CDataObject::CDataObject

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::~CDataObject
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDataObject::~CDataObject(void)
{
    m_pModuleState = NULL;

}  //*** CDataObject::~CDataObject

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::Init
//
//  Routine Description:
//      Second-phase constructor.
//
//  Arguments:
//      pci         [IN OUT] Cluster item for which a property sheet is being displayed.
//      lcid        [IN] Locale ID of resources to be loaded by extension.
//      hfont       [IN] Font to use for property page text.
//      hicon       [IN] Icon for upper left icon control.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDataObject::Init(
    IN OUT CClusterItem *   pci,
    IN LCID                 lcid,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    ASSERT_VALID(pci);

    // Save parameters.
    m_pci = pci;
    m_lcid = lcid;
    m_hfont = hfont;
    m_hicon = hicon;

}  //*** CDataObject::Init

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::InterfaceSupportsErrorInfo [ISupportsErrorInfo]
//
//  Routine Description:
//      Determines whether the interface supports error info (???).
//
//  Arguments:
//      riid        [IN] Reference to the interface ID.
//
//  Return Value:
//      S_OK        Interface supports error info.
//      S_FALSE     Interface does not support error info.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataObject::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID * rgiid[] = 
    {
        &IID_IGetClusterDataInfo,
        &IID_IGetClusterObjectInfo,
        &IID_IGetClusterNodeInfo,
        &IID_IGetClusterGroupInfo,
        &IID_IGetClusterResourceInfo,
    };
    int     iiid;
    HRESULT hr = S_FALSE;

    for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
    {
        if (InlineIsEqualGUID(*rgiid[iiid], riid))
        {
            hr = S_OK;
        }
    }

    return hr;

}  //*** CDataObject::InterfaceSupportsErrorInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetLocale [IGetClusterUIInfo]
//
//  Routine Description:
//      Get the locale ID for the extension to use.
//
//  Arguments:
//      None.
//
//  Return Value:
//      LCID
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(LCID) CDataObject::GetLocale(void)
{
    return Lcid();

}  //*** CDataObject::GetLocale

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetFont [IGetClusterUIInfo]
//
//  Routine Description:
//      Get the font to use for property pages and wizard pages.
//
//  Arguments:
//      None.
//
//  Return Value:
//      HFONT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HFONT) CDataObject::GetFont(void)
{
    return Hfont();

}  //*** CDataObject::GetFont

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetIcon [IGetClusterUIInfo]
//
//  Routine Description:
//      Get the icon to use in the upper left corner of property pages
//      and wizard pages.
//
//  Arguments:
//      None.
//
//  Return Value:
//      HICON
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HICON) CDataObject::GetIcon(void)
{
    return Hicon();

}  //*** CDataObject::GetIcon

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetClusterName [IGetClusterDataInfo]
//
//  Routine Description:
//      Get the name of the cluster in which this object exists.
//
//  Arguments:
//      lpszName        [OUT] String in which to return the name.
//      pcchName        [IN OUT] Maximum length of lpszName buffer on
//                          input.  Set to the total number of characters
//                          upon return, including terminating null character.
//                          If no lpszName buffer is not specified, the
//                          status returned will be NOERROR.  If an lpszName
//                          buffer is specified but it is too small, the
//                          number of characters will be returned in pcchName
//                          and an ERROR_MORE_DATA status will be returned.
//
//  Return Value:
//      NOERROR         Data (or size) copied successfully.
//      E_INVALIDARG    Invalid arguments specified.
//      ERROR_MORE_DATA Buffer is too small.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataObject::GetClusterName(
    OUT BSTR        lpszName,
    IN OUT LONG *   pcchName
    )
{
    LONG    cchName = 0;
    HRESULT hr = NOERROR;

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());
    ASSERT_VALID(Pci()->Pdoc());

    // Validate parameters.
    if (pcchName == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    try
    {
        // Save the length to copy.
        cchName = *pcchName;
        *pcchName = Pci()->Pdoc()->StrName().GetLength() + 1;
    } // try
    catch (...)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }  // catch:  anything

    // If only the length is being requested, return it now.
    if (lpszName == NULL)
    {
        hr = NOERROR;
        goto Cleanup;
    }

    // If a buffer is specified and it is too small, return an error.
    if (cchName < *pcchName)
    {
        hr = ERROR_MORE_DATA;
        goto Cleanup;
    }

    // Copy the data.
    hr = StringCchCopyNW( lpszName, cchName, Pci()->Pdoc()->StrName(), Pci()->Pdoc()->StrName().GetLength() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    return hr;

}  //*** CDataObject::GetClusterName

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetClusterHandle [IGetClusterDataInfo]
//
//  Routine Description:
//      Get the cluster handle for these objects.
//
//  Arguments:
//      None.
//
//  Return Value:
//      HCLUSTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HCLUSTER) CDataObject::GetClusterHandle(void)
{
    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());
    return Pci()->Hcluster();

}  //*** CDataObject::GetClusterHandle

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetObjectCount [IGetClusterDataInfo]
//
//  Routine Description:
//      Get the number of selected objects.
//
//  Arguments:
//      None.
//
//  Return Value:
//      cObj
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(LONG) CDataObject::GetObjectCount(void)
{
    // We only support one selected object at a time for now.
    return 1;

}  //*** CDataObject::GetObjectCount

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetObjectName [IGetClusterObjectInfo]
//
//  Routine Description:
//      Get the name of the specified object.
//
//  Arguments:
//      lObjIndex       [IN] Zero-based index of the object.
//      lpszName        [OUT] String in which to return the name.
//      pcchName        [IN OUT] Maximum length of lpszName buffer on
//                          input.  Set to the total number of characters
//                          upon return, including terminating null character.
//                          If no lpszName buffer is not specified, the
//                          status returned will be NOERROR.  If an lpszName
//                          buffer is specified but it is too small, the
//                          number of characters will be returned in pcchName
//                          and an ERROR_MORE_DATA status will be returned.
//
//  Return Value:
//      NOERROR         Data (or size) copied successfully.
//      E_INVALIDARG    Invalid arguments specified.
//      ERROR_MORE_DATA Buffer is too small.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataObject::GetObjectName(
    IN LONG         lObjIndex,
    OUT BSTR        lpszName,
    IN OUT LONG *   pcchName
    )
{
    LONG    cchName = 0;
    HRESULT hr = NOERROR;

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());

    // Validate parameters.
    // We only support one selected object at a time for now.
    if ((lObjIndex != 0) || (pcchName == NULL))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Save the length to copy.
    try
    {
        cchName = *pcchName;
        *pcchName = Pci()->StrName().GetLength() + 1;
    } // try
    catch (...)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }  // catch:  anything

    // If only the length is being requested, return it now.
    if (lpszName == NULL)
    {
        hr = NOERROR;
        goto Cleanup;
    }

    // If a buffer is specified and it is too small, return an error.
    if (cchName < *pcchName)
    {
        hr = ERROR_MORE_DATA;
        goto Cleanup;
    }

    // Copy the data.
    hr = StringCchCopyNW( lpszName, cchName, Pci()->StrName(), Pci()->StrName().GetLength() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    return hr;

}  //*** CDataObject::GetObjectName

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetObjectType [IGetClusterObjectInfo]
//
//  Routine Description:
//      Get the cluster database registry key for the specified object.
//
//  Arguments:
//      lObjIndex   [IN] Zero-based index of the object.
//
//  Return Value:
//      -1          Invalid argument.  Call GetLastError for more information.
//      CLUADMEX_OBJECT_TYPE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(CLUADMEX_OBJECT_TYPE) CDataObject::GetObjectType(
    IN LONG     lObjIndex
    )
{
    int                     iids;
    CLUADMEX_OBJECT_TYPE    cot = CLUADMEX_OT_NONE;

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());

    // Validate parameters.
    // We only support one selected object at a time for now.
    if (lObjIndex != 0)
    {
        SetLastError((DWORD) E_INVALIDARG);
        cot = (CLUADMEX_OBJECT_TYPE) -1;
        goto Cleanup;
    }  // if:  invalid argument

    // Get the object type.
    for (iids = 0 ; iids < RGIDS_OBJECT_TYPE_SIZE ; iids++)
    {
        if (g_rgidsObjectType[iids] == Pci()->IdsType())
        {
            cot = (CLUADMEX_OBJECT_TYPE) iids;
            break;
        }
    }  // for:  each entry in the table

Cleanup:

    return cot;

}  //*** CDataObject::GetObjectType

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetNodeHandle [IGetClusterNodeInfo]
//
//  Routine Description:
//      Get the handle for the specified node.
//
//  Arguments:
//      lObjIndex       [IN] Zero-based index of the object.
//
//  Return Value:
//      HNODE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HNODE) CDataObject::GetNodeHandle(
    IN LONG     lObjIndex
    )
{
    CClusterNode *  pciNode = (CClusterNode *) Pci();
    HNODE           hnode = NULL;

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());

    // Validate parameters.
    // We only support one selected object at a time for now.
    if (    (lObjIndex != 0)
        ||  (Pci()->IdsType() != IDS_ITEMTYPE_NODE))
    {
        SetLastError((DWORD) E_INVALIDARG);
        goto Cleanup;
    }  // if:  invalid argument

    ASSERT_KINDOF(CClusterNode, pciNode);

    hnode = pciNode->Hnode();

Cleanup:

    return hnode;

}  //*** CDataObject::GetNodeHandle

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetGroupHandle [IGetClusterGroupInfo]
//
//  Routine Description:
//      Get the handle for the specified group.
//
//  Arguments:
//      lObjIndex       [IN] Zero-based index of the object.
//
//  Return Value:
//      HGROUP
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HGROUP) CDataObject::GetGroupHandle(
    IN LONG     lObjIndex
    )
{
    CGroup *    pciGroup = (CGroup *) Pci();
    HGROUP      hgroup = NULL;

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());

    // Validate parameters.
    // We only support one selected object at a time for now.
    if (    (lObjIndex != 0)
        ||  (Pci()->IdsType() != IDS_ITEMTYPE_GROUP))
    {
        SetLastError((DWORD) E_INVALIDARG);
        goto Cleanup;
    }  // if:  invalid argument

    ASSERT_KINDOF(CGroup, pciGroup);

    hgroup = pciGroup->Hgroup();

Cleanup:

    return hgroup;

}  //*** CDataObject::GetGroupHandle

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetResourceHandle [IGetClusterResourceInfo]
//
//  Routine Description:
//      Get the handle for the specified resource.
//
//  Arguments:
//      lObjIndex       [IN] Zero-based index of the object.
//
//  Return Value:
//      HRESOURCE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HRESOURCE) CDataObject::GetResourceHandle(
    IN LONG     lObjIndex
    )
{
    CResource * pciRes = (CResource *) Pci();
    HRESOURCE   hres = NULL;

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());

    // Validate parameters.
    // We only support one selected object at a time for now.
    if (    (lObjIndex != 0)
        ||  (Pci()->IdsType() != IDS_ITEMTYPE_RESOURCE))
    {
        SetLastError((DWORD) E_INVALIDARG);
        goto Cleanup;
    }  // if:  invalid argument

    ASSERT_KINDOF(CResource, pciRes);

    hres = pciRes->Hresource();

Cleanup:

    return hres;

}  //*** CDataObject::GetResourceHandle

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetResourceTypeName [IGetClusterResourceInfo]
//
//  Routine Description:
//      Returns the name of the resource type of the specified resource.
//
//  Arguments:
//      lObjIndex       [IN] Zero-based index of the object.
//      lpszResTypeName [OUT] String in which to return the resource type name.
//      pcchResTypeName [IN OUT] Maximum length of lpszResTypeName buffer on
//                          input.  Set to the total number of characters
//                          upon return, including terminating null character.
//                          If no lpszResTypeName buffer is not specified, the
//                          status returned will be NOERROR.  If an lpszResTypeName
//                          buffer is specified but it is too small, the
//                          number of characters will be returned in pcchResTypeName
//                          and an ERROR_MORE_DATA status will be returned.
//
//  Return Value:
//      NOERROR         Data (or size) copied successfully.
//      E_INVALIDARG    Invalid arguments specified.
//      ERROR_MORE_DATA Buffer is too small.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataObject::GetResourceTypeName(
    IN LONG         lObjIndex,
    OUT BSTR        lpszResTypeName,
    IN OUT LONG *   pcchResTypeName
    )
{
    LONG            cchResTypeName = 0;
    CResource *     pciRes = (CResource *) Pci();
    CString const * pstrResourceTypeName;
    HRESULT         hr = NOERROR;

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());

    // Validate parameters.
    // We only support one selected object at a time for now.
    if ((lObjIndex != 0)
            || (pcchResTypeName == NULL)
            || (Pci()->IdsType() != IDS_ITEMTYPE_RESOURCE))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }  // if:  invalid argument

    ASSERT_KINDOF(CResource, pciRes);

    // Get a pointer to the name to copy.
    if (pciRes->PciResourceType() != NULL)
    {
        ASSERT_VALID(pciRes->PciResourceType());
        pstrResourceTypeName = &pciRes->PciResourceType()->StrName();
    }  // if:  valid resource type pointer
    else
        pstrResourceTypeName = &pciRes->StrResourceType();

    // Save the length to copy.
    try
    {
        cchResTypeName = *pcchResTypeName;
        *pcchResTypeName = pstrResourceTypeName->GetLength() + 1;
    } // try
    catch (...)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }  // catch:  anything

    // If only the length is being requested, return it now.
    if (lpszResTypeName == NULL)
    {
        hr = NOERROR;
        goto Cleanup;
    }

    // If a buffer is specified and it is too small, return an error.
    if (cchResTypeName < *pcchResTypeName)
    {
        hr = ERROR_MORE_DATA;
        goto Cleanup;
    }

    // Copy the data.
    hr = StringCchCopyNW(lpszResTypeName, cchResTypeName, *pstrResourceTypeName, pstrResourceTypeName->GetLength() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:

    return hr;

}  //*** CDataObject::GetResourceTypeName

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetResourceNetworkName [IGetClusterResourceInfo]
//
//  Routine Description:
//      Returns the name of the network name of the first Network Name
//      resource on which the specified resource depends.
//
//  Arguments:
//      lObjIndex       [IN] Zero-based index of the object.
//      lpszNetName     [OUT] String in which to return the network name.
//      pcchNetName     [IN OUT] Points to a variable that specifies the
//                          maximum size, in characters, of the buffer.  This
//                          value should be large enough to contain
//                          MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//                          return it contains the actual number of characters
//                          copied.
//
//  Return Value:
//      TRUE            Data (or size) copied successfully.
//      FALSE           Error getting information.  GetLastError() returns:
//                          E_INVALIDARG    Invalid arguments specified.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(BOOL) CDataObject::GetResourceNetworkName(
    IN LONG         lObjIndex,
    OUT BSTR        lpszNetName,
    IN OUT ULONG *  pcchNetName
    )
{
    BOOL            bSuccess = FALSE;
    CResource *     pciRes = (CResource *) Pci();

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());

    try
    {
        // Validate parameters.
        // We only support one selected object at a time for now.
        if ((lObjIndex != 0)
                || (pcchNetName == NULL)
                || (*pcchNetName < MAX_COMPUTERNAME_LENGTH)
                || (Pci()->IdsType() != IDS_ITEMTYPE_RESOURCE))
        {
            SetLastError((DWORD) E_INVALIDARG);
            goto Cleanup;
        }  // if:  invalid argument

        ASSERT_KINDOF(CResource, pciRes);

        // If there is a function for getting this information, call it.
        // Otherwise, handle it ourselves.
        if (PfGetResNetName() != NULL)
        {
            bSuccess = (*PfGetResNetName())(lpszNetName, pcchNetName, m_pvGetResNetNameContext);
        }
        else
        {
            bSuccess = pciRes->BGetNetworkName(lpszNetName, pcchNetName);
        }
    } // try
    catch (...)
    {
        bSuccess = FALSE;
        SetLastError((DWORD) E_INVALIDARG);
    }  // catch:  anything

Cleanup:

    return bSuccess;

}  //*** CDataObject::GetResourceNetworkName

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetNetworkHandle [IGetClusterNetworkInfo]
//
//  Routine Description:
//      Get the handle for the specified network.
//
//  Arguments:
//      lObjIndex       [IN] Zero-based index of the object.
//
//  Return Value:
//      HNETWORK
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HNETWORK) CDataObject::GetNetworkHandle(
    IN LONG     lObjIndex
    )
{
    CNetwork *  pciNetwork = (CNetwork *) Pci();
    HNETWORK    hnet = NULL;

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());

    // Validate parameters.
    // We only support one selected object at a time for now.
    if (    (lObjIndex != 0)
        ||  (Pci()->IdsType() != IDS_ITEMTYPE_NETWORK))
    {
        SetLastError((DWORD) E_INVALIDARG);
        goto Cleanup;
    }  // if:  invalid argument

    ASSERT_KINDOF(CNetwork, pciNetwork);

    hnet = pciNetwork->Hnetwork();

Cleanup:

    return hnet;

}  //*** CDataObject::GetNetworkHandle

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDataObject::GetNetInterfaceHandle [IGetClusterNetInterfaceInfo]
//
//  Routine Description:
//      Get the handle for the specified network interface.
//
//  Arguments:
//      lObjIndex       [IN] Zero-based index of the object.
//
//  Return Value:
//      HNETINTERFACE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HNETINTERFACE) CDataObject::GetNetInterfaceHandle(
    IN LONG     lObjIndex
    )
{
    CNetInterface * pciNetIFace = (CNetInterface *) Pci();
    HNETINTERFACE   hnetiface = NULL;

    AFX_MANAGE_STATE(m_pModuleState);
    ASSERT_VALID(Pci());

    // Validate parameters.
    // We only support one selected object at a time for now.
    if (    (lObjIndex != 0)
        ||  (Pci()->IdsType() != IDS_ITEMTYPE_NETIFACE))
    {
        SetLastError((DWORD) E_INVALIDARG);
        goto Cleanup;
    }  // if:  invalid argument

    ASSERT_KINDOF(CNetwork, pciNetIFace);

    hnetiface = pciNetIFace->Hnetiface();

Cleanup:

    return hnetiface;

}  //*** CDataObject::GetNetInterfaceHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\delres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DelRes.cpp
//
//	Abstract:
//		Definition of the CDeleteResourcesDlg dialog.
//
//	Implementation File:
//		DelRes.h
//
//	Author:
//		David Potter (davidp)	August 7, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DELRES_H_
#define _DELRES_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#include "resource.h"
#define _RESOURCE_H_
#endif

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDeleteResourcesDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResource;
class CResourceList;

/////////////////////////////////////////////////////////////////////////////
// CDeleteResourcesDlg class
/////////////////////////////////////////////////////////////////////////////

class CDeleteResourcesDlg : public CBaseDialog
{
// Construction
public:
	CDeleteResourcesDlg(
		IN CResource *				pciRes,
		IN const CResourceList *	plpci,
		IN OUT CWnd *				pParent = NULL
		);

// Dialog Data
	//{{AFX_DATA(CDeleteResourcesDlg)
	enum { IDD = IDD_DELETE_RESOURCES };
	CListCtrl	m_lcResources;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteResourcesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResource *				m_pciRes;
	const CResourceList *	m_plpci;
	int						m_nSortDirection;
	int						m_nSortColumn;

	const CResource *		PciRes(void) const		{ return m_pciRes; }
	const CResourceList *	Plpci(void) const		{ return m_plpci; }

	static int CALLBACK		CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);

	// Generated message map functions
	//{{AFX_MSG(CDeleteResourcesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblClkResourcesList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CDeleteResourcesDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _DELRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\extmenu.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExtMenu.h
//
//	Abstract:
//		Definition of the CExtMenuItem class.
//
//	Implementation File:
//		ExtMenu.cpp
//
//	Author:
//		David Potter (davidp)	August 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTMENU_H_
#define _EXTMENU_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtMenuItem;
class CExtMenuItemList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

interface IWEInvokeCommand;

/////////////////////////////////////////////////////////////////////////////
//
//	class CExtMenuItem
//
//	Purpose:
//		Represents one extension DLL's menu item.
//
/////////////////////////////////////////////////////////////////////////////
class CExtMenuItem : public CObject
{
	DECLARE_DYNAMIC(CExtMenuItem);

// Construction
public:
	CExtMenuItem(void);
	CExtMenuItem(
				IN LPCTSTR				lpszName,
				IN LPCTSTR				lpszStatusBarText,
				IN ULONG				nExtCommandID,
				IN ULONG				nCommandID,
				IN ULONG				nMenuItemID,
				IN ULONG				uFlags,
				IN BOOL					bMakeDefault,
				IN IWEInvokeCommand *	piCommand
				);
	virtual ~CExtMenuItem(void);

protected:
	void				CommonConstruct(void);

// Attributes
protected:
	CString				m_strName;
	CString				m_strStatusBarText;
	ULONG				m_nExtCommandID;
	ULONG				m_nCommandID;
	ULONG				m_nMenuItemID;
	ULONG				m_uFlags;
	BOOL				m_bDefault;
	IWEInvokeCommand *	m_piCommand;

public:
	const CString &		StrName(void) const				{ return m_strName; }
	const CString &		StrStatusBarText(void) const	{ return m_strStatusBarText; }
	ULONG				NExtCommandID(void) const		{ return m_nExtCommandID; }
	ULONG				NCommandID(void) const			{ return m_nCommandID; }
	ULONG				NMenuItemID(void) const			{ return m_nMenuItemID; }
	ULONG				UFlags(void) const				{ return m_uFlags; }
	BOOL				BDefault(void) const			{ return m_bDefault; }
	IWEInvokeCommand *	PiCommand(void)					{ return m_piCommand; }

// Operations
public:
	void				SetPopupMenuHandle(HMENU hmenu)	{ m_hmenuPopup = hmenu; }

#ifdef _DEBUG
	// Use MFC's standard object validity technique
	virtual void AssertValid(void);
#endif

// Implementation
protected:
	HMENU				m_hmenuPopup;
	CExtMenuItemList *	m_plSubMenuItems;

public:
	HMENU				HmenuPopup(void) const			{ return m_hmenuPopup; }
	CExtMenuItemList *	PlSubMenuItems(void) const		{ return m_plSubMenuItems; }

};  //*** class CExtMenuItem

/////////////////////////////////////////////////////////////////////////////
//
// class CExtMenuItemList
//
/////////////////////////////////////////////////////////////////////////////

class CExtMenuItemList : public CTypedPtrList<CObList, CExtMenuItem *>
{
};  //*** class CExtMenuItemList

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\extdll.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		ExtDll.h
//
//	Abstract:
//		Definition of the extension classes.
//
//	Implementation File:
//		ExtDll.cpp
//
//	Author:
//		David Potter (davidp)	May 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTDLL_H_
#define _EXTDLL_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for extension DLL definitions
#endif

#ifndef __cluadmid_h__
#include "CluAdmID.h"
#endif

#ifndef _DATAOBJ_H_
#include "DataObj.h"	// for CDataObject
#endif

#ifndef _TRACETAG_H_
#include "TraceTag.h"	// for CTraceTag, Trace
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtension;
class CExtensionDll;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CBaseSheet;
class CBasePropertySheet;
class CBaseWizard;
class CExtMenuItem;
class CExtMenuItemList;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define CAEXT_MENU_FIRST_ID		35000

typedef CList<CComObject<CExtensionDll> *, CComObject<CExtensionDll> *> CExtDllList;

/////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
extern CTraceTag g_tagExtDll;
extern CTraceTag g_tagExtDllRef;
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	class CExtensions
//
//	Purpose:
//		Encapsulates access to a list of extension DLLs.
//
/////////////////////////////////////////////////////////////////////////////
class CExtensions : public CObject
{
	friend class CExtensionDll;

	DECLARE_DYNAMIC(CExtensions);

// Attributes
private:
	const CStringList *	m_plstrExtensions;	// List of extensions.
	CClusterItem *		m_pci;				// Cluster item being administered.
	HFONT				m_hfont;			// Font for dialog text.
	HICON				m_hicon;			// Icon for upper left corner.

protected:
	const CStringList *	PlstrExtensions(void) const	{ return m_plstrExtensions; }
	CClusterItem *		Pci(void) const				{ return m_pci; }
	HFONT				Hfont(void) const			{ return m_hfont; }
	HICON				Hicon(void) const			{ return m_hicon; }

// Operations
public:
	CExtensions(void);
	virtual ~CExtensions(void);

	void				Init(
							IN const CStringList &	rlstrExtensions,
							IN OUT CClusterItem *	pci,
							IN HFONT				hfont,
							IN HICON				hicon
							);
	void				UnloadExtensions(void);

	// IWEExtendPropertySheet interface routines.
	void				CreatePropertySheetPages(
							IN OUT CBasePropertySheet *	psht,
							IN const CStringList &		rlstrExtensions,
							IN OUT CClusterItem *		pci,
							IN HFONT					hfont,
							IN HICON					hicon
							);

	// IWEExtendWizard interface routines.
	void				CreateWizardPages(
							IN OUT CBaseWizard *	psht,
							IN const CStringList &	rlstrExtensions,
							IN OUT CClusterItem *	pci,
							IN HFONT				hfont,
							IN HICON				hicon
							);

	// IWEExtendContextMenu interface routines.
	void				AddContextMenuItems(
							IN OUT CMenu *				pmenu,
							IN const CStringList &		rlstrExtensions,
							IN OUT CClusterItem *		pci
							);
	BOOL				BExecuteContextMenuItem(IN ULONG nCommandID);

	BOOL				BGetCommandString(IN ULONG nCommandID, OUT CString & rstrMessage);
	void				SetPfGetResNetName(PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext)
	{
		if (Pdo() != NULL)
			Pdo()->SetPfGetResNetName(pfGetResNetName, pvContext);
	}

// Implementation
private:
	CComObject<CDataObject> *	m_pdoData;			// Data object for exchanging data.
	CExtDllList *				m_plextdll;			// List of extension DLLs.
	CBaseSheet *				m_psht;				// Property sheet for IWEExtendPropertySheet.
	CMenu *						m_pmenu;			// Menu for IWEExtendContextMenu.
	CExtMenuItemList *			m_plMenuItems;

	ULONG						m_nFirstCommandID;
	ULONG						m_nNextCommandID;
	ULONG						m_nFirstMenuID;
	ULONG						m_nNextMenuID;

protected:
	CComObject<CDataObject> *	Pdo(void)						{ return m_pdoData; }
	CExtDllList *				Plextdll(void) const			{ return m_plextdll; }
	CBaseSheet *				Psht(void) const				{ return m_psht; }
	CMenu *						Pmenu(void) const				{ return m_pmenu; }
	CExtMenuItemList *			PlMenuItems(void) const			{ return m_plMenuItems; }
	CExtMenuItem *				PemiFromCommandID(ULONG nCommandID) const;
#ifdef _DEBUG
	CExtMenuItem *				PemiFromExtCommandID(ULONG nExtCommandID) const;
#endif
	ULONG						NFirstCommandID(void) const		{ return m_nFirstCommandID; }
	ULONG						NNextCommandID(void) const		{ return m_nNextCommandID; }
	ULONG						NFirstMenuID(void) const		{ return m_nFirstMenuID; }
	ULONG						NNextMenuID(void) const			{ return m_nNextMenuID; }

public:
	afx_msg void				OnUpdateCommand(CCmdUI * pCmdUI);
	BOOL						OnCmdMsg(UINT nID, int nCode, void * pExtra, AFX_CMDHANDLERINFO * pHandlerInfo);

};  //*** class CExtensions

/////////////////////////////////////////////////////////////////////////////
//
//	class CExtensionDll
//
//	Purpose:
//		Encapsulates access to an extension DLL.
//
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CExtensionDll :
	public CObject,
	public IWCPropertySheetCallback,
	public IWCWizardCallback,
	public IWCContextMenuCallback,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtensionDll, &CLSID_CoCluAdmin>
{
	friend class CExtensions;

	DECLARE_DYNAMIC(CExtensionDll);

// Attributes
private:
	CString						m_strCLSID;		// Name of extension DLL.

protected:
	const CString &				StrCLSID(void) const		{ return m_strCLSID; }
	CClusterItem *				Pci(void) const				{ return Pext()->Pci(); }

// Operations
public:
	CExtensionDll(void);
	virtual ~CExtensionDll(void);

BEGIN_COM_MAP(CExtensionDll)
	COM_INTERFACE_ENTRY(IWCPropertySheetCallback)
	COM_INTERFACE_ENTRY(IWCWizardCallback)
	COM_INTERFACE_ENTRY(IWCContextMenuCallback)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CExtensionDll) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtensionDll, _T("CLUADMIN.Extensions"), _T("CLUADMIN.Extensions"), IDS_CLUADMIN_DESC, THREADFLAGS_BOTH)

	void						Init(
									IN const CString &		rstrExtension,
									IN OUT CExtensions *	pext
									);
	IUnknown *					LoadInterface(IN const REFIID riid);
	void						UnloadExtension(void);

	// IWEExtendPropertySheet interface routines.
	void						CreatePropertySheetPages(void);

	// IWEExtendWizard interface routines.
	void						CreateWizardPages(void);

	// IWEExtendContextMenu interface routines.
	void						AddContextMenuItems(void);

// ISupportsErrorInfo
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWCPropertySheetCallback
public:
	STDMETHOD(AddPropertySheetPage)(
					IN LONG *		hpage	// really should be HPROPSHEETPAGE
					);

// IWCWizardCallback
public:
	STDMETHOD(AddWizardPage)(
					IN LONG *		hpage	// really should be HPROPSHEETPAGE
					);
	STDMETHOD(EnableNext)(
					IN LONG *		hpage,
					IN BOOL			bEnable
					);

// IWCContextMenuCallback
public:
	STDMETHOD(AddExtensionMenuItem)(
					IN BSTR		lpszName,
					IN BSTR		lpszStatusBarText,
					IN ULONG	nCommandID,
					IN ULONG	nSubmenuCommandID,
					IN ULONG	uFlags
					);

// Implementation
private:
	CExtensions *				m_pext;
	CLSID						m_clsid;
	IWEExtendPropertySheet *	m_piExtendPropSheet;	// Pointer to an IWEExtendPropertySheet interface.
	IWEExtendWizard *			m_piExtendWizard;		// Pointer to an IWEExtendWizard interface.
	IWEExtendContextMenu *		m_piExtendContextMenu;	// Pointer to an IWEExtendContextMenu interface.
	IWEInvokeCommand *			m_piInvokeCommand;		// Pointer to an IWEInvokeCommand interface.

	AFX_MODULE_STATE *			m_pModuleState;			// Required for resetting our state during callbacks.

protected:
	CExtensions *				Pext(void) const				{ ASSERT_VALID(m_pext); return m_pext; }
	const CLSID &				Rclsid(void) const				{ return m_clsid; }
	IWEExtendPropertySheet *	PiExtendPropSheet(void) const	{ return m_piExtendPropSheet; }
	IWEExtendWizard *			PiExtendWizard(void) const		{ return m_piExtendWizard; }
	IWEExtendContextMenu *		PiExtendContextMenu(void) const	{ return m_piExtendContextMenu; }
	IWEInvokeCommand *			PiInvokeCommand(void) const		{ return m_piInvokeCommand; }

	CComObject<CDataObject> *	Pdo(void) const					{ return Pext()->Pdo(); }
	CBaseSheet *				Psht(void) const				{ return Pext()->Psht(); }
	CMenu *						Pmenu(void) const				{ return Pext()->Pmenu(); }
	CExtMenuItemList *			PlMenuItems(void) const			{ return Pext()->PlMenuItems(); }
	ULONG						NFirstCommandID(void) const		{ return Pext()->NFirstCommandID(); }
	ULONG						NNextCommandID(void) const		{ return Pext()->NNextCommandID(); }
	ULONG						NFirstMenuID(void) const		{ return Pext()->NFirstMenuID(); }
	ULONG						NNextMenuID(void) const			{ return Pext()->NNextMenuID(); }

	void ReleaseInterface(
			IN OUT IUnknown ** ppi
#ifdef _DEBUG
			, IN LPCTSTR szClassName
#endif
			)
	{
		ASSERT(ppi != NULL);
		if (*ppi != NULL)
		{
#ifdef _DEBUG
			ULONG ulNewRefCount;

			Trace(g_tagExtDllRef, _T("Releasing %s"), szClassName);
			ulNewRefCount =
#endif
			(*ppi)->Release();
			*ppi = NULL;
#ifdef _DEBUG
			Trace(g_tagExtDllRef, _T("  Reference count = %d"), ulNewRefCount);
			Trace(g_tagExtDllRef, _T("ReleaseInterface() - %s = %08.8x"), szClassName, *ppi);
#endif
		}  // if:  interface specified
	}
	void ReleaseInterface(IN OUT IWEExtendPropertySheet ** ppi)
	{
		ReleaseInterface(
			(IUnknown **) ppi
#ifdef _DEBUG
			, _T("IWEExtendPropertySheet")
#endif
			);
	}
	void ReleaseInterface(IN OUT IWEExtendWizard ** ppi)
	{
		ReleaseInterface(
			(IUnknown **) ppi
#ifdef _DEBUG
			, _T("IWEExtendWizard")
#endif
			);
	}
	void ReleaseInterface(IN OUT IWEExtendContextMenu ** ppi)
	{
		ReleaseInterface(
			(IUnknown **) ppi
#ifdef _DEBUG
			, _T("IWEExtendContextMenu")
#endif
			);
	}
	void ReleaseInterface(IN OUT IWEInvokeCommand ** ppi)
	{
		ReleaseInterface(
			(IUnknown **) ppi
#ifdef _DEBUG
			, _T("IWEInvokeCommand")
#endif
			);
	}

};  //*** class CExtensionDll

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\group.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Group.cpp
//
//  Abstract:
//      Implementation of the CGroup class.
//
//  Author:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Group.h"
#include "ClusItem.inl"
#include "GrpProp.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "Cluster.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagGroup(_T("Document"), _T("GROUP"), 0);
CTraceTag   g_tagGroupRead(_T("Document"), _T("GROUP READ"), 0);
CTraceTag   g_tagGroupDrag(_T("Drag&Drop"), _T("GROUP DRAG"), 0);
CTraceTag   g_tagGroupMenu(_T("Menu"), _T("GROUP MENU"), 0);
CTraceTag   g_tagGroupNotify(_T("Notify"), _T("GROUP NOTIFY"), 0);
CTraceTag   g_tagGroupRegNotify(_T("Notify"), _T("GROUP REG NOTIFY"), 0);
#endif


/////////////////////////////////////////////////////////////////////////////
// CGroup
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGroup, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CGroup, CClusterItem)
    //{{AFX_MSG_MAP(CGroup)
    ON_UPDATE_COMMAND_UI(ID_FILE_BRING_ONLINE, OnUpdateBringOnline)
    ON_UPDATE_COMMAND_UI(ID_FILE_TAKE_OFFLINE, OnUpdateTakeOffline)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP, OnUpdateMoveGroup)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_1, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_DELETE, OnUpdateDelete)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_2, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_3, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_4, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_5, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_6, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_7, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_8, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_9, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_10, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_11, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_12, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_13, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_14, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_15, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_16, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_BRING_ONLINE, OnCmdBringOnline)
    ON_COMMAND(ID_FILE_TAKE_OFFLINE, OnCmdTakeOffline)
    ON_COMMAND(ID_FILE_MOVE_GROUP, OnCmdMoveGroup)
    ON_COMMAND(ID_FILE_DELETE, OnCmdDelete)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::CGroup
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroup::CGroup(void) : CClusterItem(NULL, IDS_ITEMTYPE_GROUP)
{
    CommonConstruct();

}  //*** CGroup::CGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::CGroup
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      bDocObj     [IN] TRUE = object is part of the document.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroup::CGroup(IN BOOL bDocObj) : CClusterItem(NULL, IDS_ITEMTYPE_GROUP)
{
    CommonConstruct();
    m_bDocObj = bDocObj;

}  //*** CGroup::CGroup(bDocObj)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::CommonConstruct(void)
{
    m_idmPopupMenu = IDM_GROUP_POPUP;
    m_hgroup = NULL;
    m_nFailoverThreshold = CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD;
    m_nFailoverPeriod = CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD;
    m_cgaftAutoFailbackType = CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE;
    m_nFailbackWindowStart = CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START;
    m_nFailbackWindowEnd = CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END;

    m_pciOwner = NULL;

    m_plpcires = NULL;
    m_plpcinodePreferredOwners = NULL;

    // Set the object type image.
    m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_GROUP);

    // Setup the property array.
    {
        m_rgProps[epropName].Set(CLUSREG_NAME_GRP_NAME, m_strName, m_strName);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_GRP_DESC, m_strDescription, m_strDescription);
        m_rgProps[epropFailoverThreshold].Set(CLUSREG_NAME_GRP_FAILOVER_THRESHOLD, m_nFailoverThreshold, m_nFailoverThreshold);
        m_rgProps[epropFailoverPeriod].Set(CLUSREG_NAME_GRP_FAILOVER_PERIOD, m_nFailoverPeriod, m_nFailoverPeriod);
        m_rgProps[epropAutoFailbackType].Set(CLUSREG_NAME_GRP_FAILBACK_TYPE, (DWORD &) m_cgaftAutoFailbackType, (DWORD &) m_cgaftAutoFailbackType);
        m_rgProps[epropFailbackWindowStart].Set(CLUSREG_NAME_GRP_FAILBACK_WIN_START, m_nFailbackWindowStart, m_nFailbackWindowStart);
        m_rgProps[epropFailbackWindowEnd].Set(CLUSREG_NAME_GRP_FAILBACK_WIN_END, m_nFailbackWindowEnd, m_nFailbackWindowEnd);
    }  // Setup the property array

#ifdef _CLUADMIN_USE_OLE_
    EnableAutomation();
#endif

    // To keep the application running as long as an OLE automation
    //  object is active, the constructor calls AfxOleLockApp.

//  AfxOleLockApp();

}  //*** CGroup::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::~CGroup
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroup::~CGroup(void)
{
    // Cleanup this object.
    Cleanup();

    delete m_plpcires;
    delete m_plpcinodePreferredOwners;

    // Close the group handle.
    if (Hgroup() != NULL)
    {
        CloseClusterGroup(Hgroup());
    }

    // To terminate the application when all objects created with
    //  with OLE automation, the destructor calls AfxOleUnlockApp.

//  AfxOleUnlockApp();

}  //*** CGroup::~CGroup

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Cleanup(void)
{
    // Delete the resource list.
    if (m_plpcires != NULL)
    {
        m_plpcires->RemoveAll();
    }

    // Delete the PreferredOwners list.
    if (m_plpcinodePreferredOwners != NULL)
    {
        m_plpcinodePreferredOwners->RemoveAll();
    }

    // If we are active on a node, remove ourselves from that active list.
    if (PciOwner() != NULL)
    {
        if (BDocObj())
        {
            PciOwner()->RemoveActiveGroup(this);
        }
        PciOwner()->Release();
        m_pciOwner = NULL;
    }  // if:  there is an owner

    // Remove the item from the group list.
    if (BDocObj())
    {
        POSITION    posPci;

        posPci = Pdoc()->LpciGroups().Find(this);
        if (posPci != NULL)
        {
            Pdoc()->LpciGroups().RemoveAt(posPci);
        }  // if:  found in the document's list
    }  // if:  this is a document object

}  //*** CGroup::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::Create
//
//  Routine Description:
//      Create a group.
//
//  Arguments:
//      pdoc                [IN OUT] Document to which this item belongs.
//      lpszName            [IN] Name of the group.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from CreateClusterResource.
//      Any exceptions thrown by CResource::Init(), CResourceList::new(),
//      or CNodeList::new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Create(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
    DWORD       dwStatus;
    HGROUP      hgroup;
    CString     strName(lpszName);  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(Hgroup() == NULL);
    ASSERT(Hkey() == NULL);
    ASSERT_VALID(pdoc);
    ASSERT(lpszName != NULL);

    // Create the group.
    hgroup = CreateClusterGroup(pdoc->Hcluster(), strName);
    if (hgroup == NULL)
    {
        dwStatus = GetLastError();
        ThrowStaticException(dwStatus, IDS_CREATE_GROUP_ERROR, lpszName);
    }  // if:  error creating the cluster group

    CloseClusterGroup(hgroup);

    // Open the group.
    Init(pdoc, lpszName);

}  //*** CGroup::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenClusterGroup() or GetClusterGroupKey().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LONG    lResult;
    CString strName(lpszName);  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(Hgroup() == NULL);
    ASSERT(Hkey() == NULL);

    // Call the base class method.
    CClusterItem::Init(pdoc, lpszName);

    try
    {
        // Open the group.
        m_hgroup = OpenClusterGroup(Hcluster(), strName);
        if (Hgroup() == NULL)
        {
            dwStatus = GetLastError();
            ThrowStaticException(dwStatus, IDS_OPEN_GROUP_ERROR, lpszName);
        }  // if:  error opening the cluster group

        // Get the group registry key.
        m_hkey = GetClusterGroupKey(Hgroup(), MAXIMUM_ALLOWED);
        if (Hkey() == NULL)
        {
            ThrowStaticException(GetLastError(), IDS_GET_GROUP_KEY_ERROR, lpszName);
        }

        if (BDocObj())
        {
            ASSERT(Pcnk() != NULL);
            Trace(g_tagClusItemNotify, _T("CGroup::Init() - Registering for group notifications (%08.8x) for '%s'"), Pcnk(), StrName());

            // Register for group notifications.
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (CLUSTER_CHANGE_GROUP_STATE
                                    | CLUSTER_CHANGE_GROUP_DELETED
                                    | CLUSTER_CHANGE_GROUP_PROPERTY),
                                Hgroup(),
                                (DWORD_PTR) Pcnk()
                                );
            if (lResult != ERROR_SUCCESS)
            {
                dwStatus = lResult;
                ThrowStaticException(dwStatus, IDS_GROUP_NOTIF_REG_ERROR, lpszName);
            }  // if:  error registering for group notifications

            // Register for registry notifications.
            if (Hkey() != NULL)
            {
                lResult = RegisterClusterNotify(
                                    GetClusterAdminApp()->HchangeNotifyPort(),
                                    (CLUSTER_CHANGE_REGISTRY_NAME
                                        | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                        | CLUSTER_CHANGE_REGISTRY_VALUE
                                        | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                    Hkey(),
                                    (DWORD_PTR) Pcnk()
                                    );
                if (lResult != ERROR_SUCCESS)
                {
                    dwStatus = lResult;
                    ThrowStaticException(dwStatus, IDS_GROUP_NOTIF_REG_ERROR, lpszName);
                }  // if:  error registering for registry notifications
            }  // if:  there is a key
        }  // if:  document object

        // Allocate lists.
        m_plpcires = new CResourceList;
        if ( m_plpcires == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating resource list
        m_plpcinodePreferredOwners = new CNodeList;
        if ( m_plpcinodePreferredOwners == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating preferred owners list

        // Read the initial state.
        UpdateState();
    }  // try
    catch (CException *)
    {
        if (Hkey() != NULL)
        {
            ClusterRegCloseKey(Hkey());
            m_hkey = NULL;
        }  // if:  registry key opened
        if (Hgroup() != NULL)
        {
            CloseClusterGroup(Hgroup());
            m_hgroup = NULL;
        }  // if:  group opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CGroup::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue() or
//                              CGroup::ConstructList().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ReadItem(void)
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT_VALID(this);

    if (Hgroup() != NULL)
    {
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
        m_rgProps[epropFailoverThreshold].m_value.pdw = &m_nFailoverThreshold;
        m_rgProps[epropFailoverPeriod].m_value.pdw = &m_nFailoverPeriod;
        m_rgProps[epropAutoFailbackType].m_value.pdw = (DWORD *) &m_cgaftAutoFailbackType;
        m_rgProps[epropFailbackWindowStart].m_value.pdw = &m_nFailbackWindowStart;
        m_rgProps[epropFailbackWindowEnd].m_value.pdw = &m_nFailbackWindowEnd;

        // Call the base class method.
        CClusterItem::ReadItem();

        Trace(g_tagGroupRead, _T("ReadItem() - Name before reading properties: '%s'"), StrName());

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetGroupProperties(
                                Hgroup(),
                                CLUSCTL_GROUP_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                dwStatus = DwParseProperties(cpl);
            }
            if (dwStatus != ERROR_SUCCESS)
            {
                dwRetStatus = dwStatus;
            }
        }  // Read and parse the common properties

        // Read and parse the read-only common properties.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetGroupProperties(
                                Hgroup(),
                                CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                dwStatus = DwParseProperties(cpl);
            }
            if (dwStatus != ERROR_SUCCESS)
            {
                dwRetStatus = dwStatus;
            }
        }  // if:  no error yet

        Trace(g_tagGroupRead, _T("ReadItem() - Name after reading properties: '%s'"), StrName());

        // Read extension lists.
        ReadExtensions();

        if (dwRetStatus == ERROR_SUCCESS)
        {
            // Read the list of preferred owners.
            ASSERT(m_plpcinodePreferredOwners != NULL);
            ConstructList(*m_plpcinodePreferredOwners, CLUSTER_GROUP_ENUM_NODES);
        }  // if:  no error reading properties
    }  // if:  group is available

    // Read the initial state.
    UpdateState();

    // Construct the list of resources contained in the group.
//  ASSERT(m_plpcires != NULL);
//  ConstructList(*m_plpcires, CLUSTER_GROUP_ENUM_CONTAINS);

    // If any errors occurred, throw an exception.
    if (dwRetStatus != ERROR_SUCCESS)
    {
        m_bReadOnly = TRUE;
        if (   (dwRetStatus != ERROR_GROUP_NOT_AVAILABLE)
            && (dwRetStatus != ERROR_KEY_DELETED))
        {
            ThrowStaticException(dwRetStatus, IDS_READ_GROUP_PROPS_ERROR, StrName());
        }
    }  // if:  error reading properties

    MarkAsChanged(FALSE);

}  //*** CGroup::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::PlstrExtensions
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CGroup::PlstrExtensions(void) const
{
    return &Pdoc()->PciCluster()->LstrGroupExtensions();

}  //*** CGroup::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::ReadExtensions
//
//  Routine Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ReadExtensions(void)
{
}  //*** CGroup::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::ConstructList
//
//  Routine Description:
//      Construct a list of node items which are enumerable on the group.
//
//  Arguments:
//      rlpci           [OUT] List to fill.
//      dwType          [IN] Type of objects.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterGroupOpenEnum or ClusterGroupEnum.
//      Any exceptions thrown by new or CList::AddTail.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ConstructList(
    OUT CNodeList & rlpci,
    IN DWORD        dwType
    )
{
    DWORD           dwStatus;
    HGROUPENUM      hgrpenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CClusterNode *  pciNode;
    CWaitCursor     wc;

    ASSERT_VALID(Pdoc());
    ASSERT(Hgroup() != NULL);

    Trace(g_tagGroup, _T("(%s) (%s (%x)) - Constructing node list"), Pdoc()->StrNode(), StrName(), this);

    // Remove the previous contents of the list.
    rlpci.RemoveAll();

    if (Hgroup() != NULL)
    {
        // Open the enumeration.
        hgrpenum = ClusterGroupOpenEnum(Hgroup(), dwType);
        if (hgrpenum == NULL)
        {
            ThrowStaticException(GetLastError(), IDS_ENUM_PREFERRED_OWNERS_ERROR, StrName());
        }

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating name buffer

            // Loop through the enumeration and add each node to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterGroupEnum(hgrpenum, ienum, &dwRetType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating name buffer
                    dwStatus = ClusterGroupEnum(hgrpenum, ienum, &dwRetType, pwszName, &cchName);
                }  // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                {
                    break;
                }
                else if (dwStatus != ERROR_SUCCESS)
                {
                    ThrowStaticException(dwStatus, IDS_ENUM_PREFERRED_OWNERS_ERROR, StrName());
                }

                ASSERT(dwRetType == dwType);

                // Find the item in the list of nodes on the document.
                pciNode = Pdoc()->LpciNodes().PciNodeFromName(pwszName);
                ASSERT_VALID(pciNode);

                // Add the node to the list.
                if (pciNode != NULL)
                {
                    rlpci.AddTail(pciNode);
                }  // if:  found node in list

            }  // for:  each item in the group

            delete [] pwszName;
            ClusterGroupCloseEnum(hgrpenum);

        }  // try
        catch (CException *)
        {
            delete [] pwszName;
            ClusterGroupCloseEnum(hgrpenum);
            throw;
        }  // catch:  any exception
    }  // if:  resource is available

}  //*** CGroup::ConstructList(CNodeList&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::ConstructList
//
//  Routine Description:
//      Construct a list of resource items which are enumerable on the group.
//
//  Arguments:
//      rlpci           [OUT] List to fill.
//      dwType          [IN] Type of objects.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterGroupOpenEnum or ClusterGroupEnum.
//      Any exceptions thrown by new or CList::AddTail.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ConstructList(
    OUT CResourceList & rlpci,
    IN DWORD            dwType
    )
{
    DWORD           dwStatus;
    HGROUPENUM      hgrpenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CResource *     pciRes;
    CWaitCursor     wc;

    ASSERT_VALID(Pdoc());
    ASSERT(Hgroup() != NULL);

    Trace(g_tagGroup, _T("(%s) (%s (%x)) - Constructing resource list"), Pdoc()->StrNode(), StrName(), this);

    // Remove the previous contents of the list.
    rlpci.RemoveAll();

    if (Hgroup() != NULL)
    {
        // Open the enumeration.
        hgrpenum = ClusterGroupOpenEnum(Hgroup(), dwType);
        if (hgrpenum == NULL)
        {
            ThrowStaticException(GetLastError(), IDS_ENUM_CONTAINS_ERROR, StrName());
        }

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating name buffer

            // Loop through the enumeration and add each resource to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterGroupEnum(hgrpenum, ienum, &dwRetType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating name buffer
                    dwStatus = ClusterGroupEnum(hgrpenum, ienum, &dwRetType, pwszName, &cchName);
                }  // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                {
                    break;
                }
                else if (dwStatus != ERROR_SUCCESS)
                {
                    ThrowStaticException(dwStatus, IDS_ENUM_CONTAINS_ERROR, StrName());
                }

                ASSERT(dwRetType == dwType);

                // Find the item in the list of resources on the document.
                pciRes = Pdoc()->LpciResources().PciResFromName(pwszName);
                ASSERT_VALID(pciRes);

                // Add the resource to the list.
                if (pciRes != NULL)
                {
                    rlpci.AddTail(pciRes);
                }  // if:  found resource in list

            }  // for:  each item in the group

            delete [] pwszName;
            ClusterGroupCloseEnum(hgrpenum);

        }  // try
        catch (CException *)
        {
            delete [] pwszName;
            ClusterGroupCloseEnum(hgrpenum);
            throw;
        }  // catch:  any exception
    }  // if:  resource is available

}  //*** CGroup::ConstructList(CResourceList&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::ConstructPossibleOwnersList
//
//  Routine Description:
//      Construct the list of nodes on which this group can run.
//
//  Arguments:
//      rlpciNodes  [OUT] List of nodes on which group can run.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ConstructPossibleOwnersList(OUT CNodeList & rlpciNodes)
{
    POSITION        posNode;
    POSITION        posRes;
    POSITION        posResNode;
    POSITION        posCurResNode   = NULL;
    CClusterNode *  pciNode;
    CClusterNode *  pciResNode;
    CResource *     pciRes;
    CWaitCursor wc;

    ASSERT_VALID(Pdoc());

    // Remove the previous contents of the list.
    rlpciNodes.RemoveAll();

    posNode = Pdoc()->LpciNodes().GetHeadPosition();
    while (posNode != NULL)
    {
        pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext(posNode);
        ASSERT_VALID(pciNode);

        if (Lpcires().GetCount() != 0)
        {
            posRes = Lpcires().GetHeadPosition();
            while (posRes != NULL)
            {
                pciRes = (CResource *) Lpcires().GetNext(posRes);
                ASSERT_VALID(pciRes);

                posResNode = pciRes->LpcinodePossibleOwners().GetHeadPosition();
                while (posResNode != NULL)
                {
                    posCurResNode = posResNode;
                    pciResNode = (CClusterNode *) pciRes->LpcinodePossibleOwners().GetNext(posResNode);
                    ASSERT_VALID(pciResNode);
                    if (pciNode->StrName() == pciResNode->StrName())
                    {
                        break;
                    }
                    posCurResNode = NULL;
                }  // while:  more possible owners in the list

                // If the node wasn't found, the group can't run here.
                if (posCurResNode == NULL)
                {
                    break;
                }
            }  // while:  more resources in the list
        }  // if:  group has resources

        // If the node was found on a resource, the group can run here.
        if (posCurResNode != NULL)
        {
            rlpciNodes.AddTail(pciNode);
        }  // if:  node found on a resource
    }  // while:  more nodes in the document

}  //*** CGroup::ConstructPossibleOwnersList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::DeleteGroup
//
//  Routine Description:
//      Delete the group.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Any errors from DeleteClusterGroup.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::DeleteGroup(void)
{
    CWaitCursor wc;

    if (Hgroup() != NULL)
    {
        DWORD       dwStatus;
        CWaitCursor wc;

        // Delete the group itself.
        dwStatus = DeleteClusterGroup(Hgroup());
        if (dwStatus != ERROR_SUCCESS)
        {
            ThrowStaticException(dwStatus, IDS_DELETE_GROUP_ERROR, StrName());
        }

        UpdateState();
    }  // if:  group has been opened/created

}  //*** CGroup::DeleteGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::AddResource
//
//  Routine Description:
//      Add a resource to the list of resources contained in this group.
//
//  Arguments:
//      pciRes      [IN OUT] New resource.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::AddResource(IN OUT CResource * pciRes)
{
    POSITION    posPci;

    ASSERT_VALID(pciRes);
    Trace(g_tagGroup, _T("(%s) (%s (%x)) - Adding resource '%s'"), Pdoc()->StrNode(), StrName(), this, pciRes->StrName());

    // Make sure the resource is not already in the list.
    VERIFY((posPci = Lpcires().Find(pciRes)) == NULL);

    if (posPci == NULL)
    {
        POSITION    posPtiGroup;
        CTreeItem * ptiGroup;

        // Loop through each tree item to update the group's list of resources.
        posPtiGroup = LptiBackPointers().GetHeadPosition();
        while (posPtiGroup != NULL)
        {
            ptiGroup = LptiBackPointers().GetNext(posPtiGroup);
            ASSERT_VALID(ptiGroup);

            // Add the new resource.
            VERIFY(ptiGroup->PliAddChild(pciRes) != NULL);
        }  // while:  more tree items for this group

        m_plpcires->AddTail(pciRes);

    }  // if:  resource not in the list yet

}  //*** CGroup::AddResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::RemoveResource
//
//  Routine Description:
//      Remove a resource from the list of resources contained in this group.
//
//  Arguments:
//      pciRes      [IN OUT] Resource that no is no longer contained in this group.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::RemoveResource(IN OUT CResource * pciRes)
{
    POSITION    posPci;

    ASSERT_VALID(pciRes);
    Trace(g_tagGroup, _T("(%s) (%s (%x)) - Removing resource '%s'"), Pdoc()->StrNode(), StrName(), this, pciRes->StrName());

    // Make sure the resource is in the list.
    posPci = Lpcires().Find(pciRes);

    if (posPci != NULL)
    {
        POSITION    posPtiGroup;
        CTreeItem * ptiGroup;

        // Loop through each tree item to update the group's list of resources.
        posPtiGroup = LptiBackPointers().GetHeadPosition();
        while (posPtiGroup != NULL)
        {
            ptiGroup = LptiBackPointers().GetNext(posPtiGroup);
            ASSERT_VALID(ptiGroup);

            // Remove the resource.
            ptiGroup->RemoveChild(pciRes);
        }  // while:  more tree items for this group

        m_plpcires->RemoveAt(posPci);

    }  // if:  resource in the list

}  //*** CGroup::RemoveResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::SetName
//
//  Routine Description:
//      Set the name of this group.
//
//  Arguments:
//      pszName     [IN] New name of the group.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_RENAME_GROUP_ERROR - errors from
//                          SetClusterGroupName().
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::SetName(IN LPCTSTR pszName)
{
    Rename(pszName);

}  //*** CGroup::SetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::SetPreferredOwners
//
//  Routine Description:
//      Set the list of preferred owners of this group in the cluster database.
//
//  Arguments:
//      rlpci       [IN] List of preferred owners (nodes).
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CStringList::AddTail() or
//      CNodeList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::SetPreferredOwners(IN const CNodeList & rlpci)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hgroup() != NULL);

    if (Hgroup() != NULL)
    {
        BOOL        bChanged    = TRUE;

        // Determine if the list has changed.
        if (rlpci.GetCount() == LpcinodePreferredOwners().GetCount())
        {
            POSITION        posOld;
            POSITION        posNew;
            CClusterNode *  pciOldNode;
            CClusterNode *  pciNewNode;

            bChanged = FALSE;

            posOld = LpcinodePreferredOwners().GetHeadPosition();
            posNew = rlpci.GetHeadPosition();
            while (posOld != NULL)
            {
                pciOldNode = (CClusterNode *) LpcinodePreferredOwners().GetNext(posOld);
                ASSERT_VALID(pciOldNode);

                ASSERT(posNew != NULL);
                pciNewNode = (CClusterNode *) rlpci.GetNext(posNew);
                ASSERT_VALID(pciNewNode);

                if (pciOldNode->StrName() != pciNewNode->StrName())
                {
                    bChanged = TRUE;
                    break;
                }  // if:  name is not the same
            }  // while:  more items in the old list
        }  // if:  same number of items in the list

        if (bChanged)
        {
            HNODE *     phnode  = NULL;

            try
            {
                DWORD           ipci;
                POSITION        posPci;
                CClusterNode *  pciNode;

                // Allocate an array for all the node handles.
                phnode = new HNODE[(DWORD)rlpci.GetCount()];
                if (phnode == NULL)
                {
                    ThrowStaticException(GetLastError());
                } // if: error allocating the node handle array

                // Copy the handle of all the nodes in the node list to the handle aray.
                posPci = rlpci.GetHeadPosition();
                for (ipci = 0 ; posPci != NULL ; ipci++)
                {
                    pciNode = (CClusterNode *) rlpci.GetNext(posPci);
                    ASSERT_VALID(pciNode);
                    phnode[ipci] = pciNode->Hnode();
                }  // while:  more nodes in the list

                // Set the property.
                dwStatus = SetClusterGroupNodeList(Hgroup(), (DWORD)rlpci.GetCount(), phnode);
                if (dwStatus != ERROR_SUCCESS)
                {
                    ThrowStaticException(dwStatus, IDS_SET_GROUP_NODE_LIST_ERROR, StrName());
                }

                // Update the PCI list.
                m_plpcinodePreferredOwners->RemoveAll();
                posPci = rlpci.GetHeadPosition();
                while (posPci != NULL)
                {
                    pciNode = (CClusterNode *) rlpci.GetNext(posPci);
                    m_plpcinodePreferredOwners->AddTail(pciNode);
                }  // while:  more items in the list
            } // try
            catch (CException *)
            {
                delete [] phnode;
                throw;
            }  // catch:  CException

            delete [] phnode;

        }  // if:  list changed
    }  // if:  key is available

}  //*** CGroup::SetPreferredOwners(CNodeList*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::SetCommonProperties
//
//  Routine Description:
//      Set the common properties for this resource in the cluster database.
//
//  Arguments:
//      rstrDesc        [IN] Description string.
//      nThreshold      [IN] Failover threshold.
//      nPeriod         [IN] Failover period.
//      cgaft           [IN] Auto Failback Type.
//      nStart          [IN] Start of failback window.
//      nEnd            [IN] End of failback window.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusterItem::SetCommonProperties().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::SetCommonProperties(
    IN const CString &  rstrDesc,
    IN DWORD            nThreshold,
    IN DWORD            nPeriod,
    IN CGAFT            cgaft,
    IN DWORD            nStart,
    IN DWORD            nEnd,
    IN BOOL             bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;
    m_rgProps[epropFailoverThreshold].m_value.pdw = &nThreshold;
    m_rgProps[epropFailoverPeriod].m_value.pdw = &nPeriod;
    m_rgProps[epropAutoFailbackType].m_value.pdw = (DWORD *) &cgaft;
    m_rgProps[epropFailbackWindowStart].m_value.pdw = &nStart;
    m_rgProps[epropFailbackWindowEnd].m_value.pdw = &nEnd;

    try
    {
        CClusterItem::SetCommonProperties(bValidateOnly);
    }  // try
    catch (CNTException * pnte)
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    }  // catch:  CNTException

    m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
    m_rgProps[epropFailoverThreshold].m_value.pdw = &m_nFailoverThreshold;
    m_rgProps[epropFailoverPeriod].m_value.pdw = &m_nFailoverPeriod;
    m_rgProps[epropAutoFailbackType].m_value.pdw = (DWORD *) &m_cgaftAutoFailbackType;
    m_rgProps[epropFailbackWindowStart].m_value.pdw = &m_nFailbackWindowStart;
    m_rgProps[epropFailbackWindowEnd].m_value.pdw = &m_nFailbackWindowEnd;

    if (nte.Sc() != ERROR_SUCCESS)
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );

}  //*** CGroup::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::DwSetCommonProperties
//
//  Routine Description:
//      Set the common properties for this group in the cluster database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      Any status returned by ClusterGroupControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGroup::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;


    ASSERT(Hgroup());

    if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if (bValidateOnly)
        {
            dwControl = CLUSCTL_GROUP_VALIDATE_COMMON_PROPERTIES;
        }
        else
        {
            dwControl = CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
        }

        // Set private properties.
        dwStatus = ClusterGroupControl(
                        Hgroup(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        static_cast< DWORD >( rcpl.CbPropList() ),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
    {
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;

}  //*** CGroup::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::UpdateState(void)
{
    CClusterAdminApp *  papp        = GetClusterAdminApp();
    WCHAR *             pwszOwner   = NULL;

    // This should probably be limited by MAX_COMPUTERNAME_LENGTH (31) for now, but
    // if/when we go to DNS names we'll need at most 255 bytes for the name.
    WCHAR               rgwszOwner[256];
    DWORD               cchOwner    = sizeof(rgwszOwner) / sizeof(WCHAR);

    Trace(g_tagGroup, _T("(%s) (%s (%x)) - Updating state"), Pdoc()->StrNode(), StrName(), this);

    // Get the current state of the group.
    if (Hgroup() == NULL)
    {
        m_cgs = ClusterGroupStateUnknown;
    }
    else
    {
        CWaitCursor wc;

        m_cgs = GetClusterGroupState(Hgroup(), rgwszOwner, &cchOwner);
        pwszOwner = rgwszOwner;
    }  // else:  group is available

    // Save the current state image index.
    switch (Cgs())
    {
        case ClusterGroupStateUnknown:
            m_iimgState = papp->Iimg(IMGLI_GROUP_UNKNOWN);
            pwszOwner = NULL;
            break;
        case ClusterGroupOnline:
            m_iimgState = papp->Iimg(IMGLI_GROUP);
            break;
        case ClusterGroupPartialOnline:
            m_iimgState = papp->Iimg(IMGLI_GROUP_PARTIALLY_ONLINE);
            break;
        case ClusterGroupPending:
            m_iimgState = papp->Iimg(IMGLI_GROUP_PENDING);
            break;
        case ClusterGroupOffline:
            m_iimgState = papp->Iimg(IMGLI_GROUP_OFFLINE);
            break;
        case ClusterGroupFailed:
            m_iimgState = papp->Iimg(IMGLI_GROUP_FAILED);
            break;
        default:
            Trace(g_tagGroup, _T("(%s) (%s (%x)) - UpdateState: Unknown state '%d' for group '%s'"), Pdoc()->StrNode(), StrName(), this, Cgs(), StrName());
            m_iimgState = (UINT) -1;
            break;
    }  // switch:  Cgs()

    SetOwnerState(pwszOwner);

    // Update the state of all resources owned by this group.
    if (m_plpcires != NULL)
    {
        POSITION    posRes;
        CResource * pciRes;

        posRes = Lpcires().GetHeadPosition();
        while (posRes != NULL)
        {
            pciRes = (CResource *) Lpcires().GetNext(posRes);
            ASSERT_VALID(pciRes);
            pciRes->UpdateState();
        }  // while:  more items in the list
    }  // if:  resource list exists

    // Call the base class method.
    CClusterItem::UpdateState();

}  //*** CGroup::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::SetOwnerState
//
//  Routine Description:
//      Set a new owner for this group.
//
//  Arguments:
//      pszNewOwner     [IN] Name of the new owner.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::SetOwnerState(IN LPCTSTR pszNewOwner)
{
    CClusterNode *  pciOldOwner = PciOwner();
    CClusterNode *  pciNewOwner;

    Trace(g_tagGroup, _T("(%s) (%s (%x)) - Setting owner to '%s'"), Pdoc()->StrNode(), StrName(), this, pszNewOwner);

    if (pszNewOwner == NULL)
    {
        pciNewOwner = NULL;
    }
    else
    {
        pciNewOwner = Pdoc()->LpciNodes().PciNodeFromName(pszNewOwner);
    }
    if (pciNewOwner != pciOldOwner)
    {
#ifdef _DEBUG
        if (g_tagGroup.BAny())
        {
            CString     strMsg;
            CString     strMsg2;

            strMsg.Format(_T("(%s) (%s (%x)) - Changing owner from "), Pdoc()->StrNode(), StrName(), this);
            if (pciOldOwner == NULL)
            {
                strMsg += _T("nothing ");
            }
            else
            {
                strMsg2.Format(_T("'%s' "), pciOldOwner->StrName());
                strMsg += strMsg2;
            }  // else:  previous owner
            if (pciNewOwner == NULL)
            {
                strMsg += _T("to nothing");
            }
            else
            {
                strMsg2.Format(_T("to '%s'"), pciNewOwner->StrName());
                strMsg += strMsg2;
            }  // else:  new owner
            Trace(g_tagGroup, strMsg);
        }  // if:  trace tag turned on
#endif
        m_strOwner = pszNewOwner;
        m_pciOwner = pciNewOwner;

        // Update reference counts.
        if (pciOldOwner != NULL)
        {
            pciOldOwner->Release();
        }
        if (pciNewOwner != NULL)
        {
            pciNewOwner->AddRef();
        }

        if (BDocObj())
        {
            if (pciOldOwner != NULL)
            {
                pciOldOwner->RemoveActiveGroup(this);
            }
            if (pciNewOwner != NULL)
            {
                pciNewOwner->AddActiveGroup(this);
            }
        }  // if:  this is a document object
    }  // if:  owner changed
    else if ((pszNewOwner != NULL) && (StrOwner() != pszNewOwner))
    {
        m_strOwner = pszNewOwner;
    }

}  //*** CGroup::SetOwnerState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnFinalRelease
//
//  Routine Description:
//      Called when the last OLE reference to or from the object is released.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnFinalRelease(void)
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CClusterItem::OnFinalRelease();

}  //*** CGroup::OnFinalRelease()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
    BOOL    bSuccess;

    switch (colid)
    {
        case IDS_COLTEXT_OWNER:
            rstrText = StrOwner();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_STATE:
            GetStateName(rstrText);
            bSuccess = TRUE;
            break;
        default:
            bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CGroup::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::GetTreeName
//
//  Routine Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CGroup::GetTreeName(OUT CString & rstrName) const
{
    CString     strState;

    GetStateName(strState);
    rstrName.Format(_T("%s (%s)"), StrName(), strState);

}  //*** CGroup::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::GetStateName
//
//  Routine Description:
//      Returns a string with the name of the current state.
//
//  Arguments:
//      rstrState   [OUT] String in which to return the name of the current state.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::GetStateName(OUT CString & rstrState) const
{
    switch (Cgs())
    {
        case ClusterGroupStateUnknown:
            rstrState.LoadString(IDS_UNKNOWN);
            break;
        case ClusterGroupOnline:
            rstrState.LoadString(IDS_ONLINE);
            break;
        case ClusterGroupPartialOnline:
            rstrState.LoadString(IDS_PARTIAL_ONLINE);
            break;
        case ClusterGroupPending:
            rstrState.LoadString(IDS_PENDING);
            break;
        case ClusterGroupOffline:
            rstrState.LoadString(IDS_OFFLINE);
            break;
        case ClusterGroupFailed:
            rstrState.LoadString(IDS_FAILED);
            break;
        default:
            rstrState.Empty();
            break;
    }  // switch:  Cgs()

}  //*** CGroup::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::BCanBeEdited
//
//  Routine Description:
//      Determines if the resource can be renamed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource can be renamed.
//      FALSE       Resource cannot be renamed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::BCanBeEdited(void) const
{
    BOOL    bCanBeEdited;

    if (   (Cgs() == ClusterGroupStateUnknown)
        || BReadOnly())
    {
        bCanBeEdited  = FALSE;
    }
    else
    {
        bCanBeEdited = TRUE;
    }

    return bCanBeEdited;

}  //*** CGroup::BCanBeEdited()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::Rename
//
//  Routine Description:
//      Rename the group.
//
//  Arguments:
//      pszName         [IN] New name to give to the group.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors returned from SetClusterGroupName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Rename(IN LPCTSTR pszName)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hgroup() != NULL);

    if (StrName() != pszName)
    {
        dwStatus = SetClusterGroupName(Hgroup(), pszName);
        if (dwStatus != ERROR_SUCCESS)
        {
            ThrowStaticException(dwStatus, IDS_RENAME_GROUP_ERROR, StrName(), pszName);
        }
        m_strName = pszName;
    }  // if:  the name changed

}  //*** CGroup::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::Move
//
//  Routine Description:
//      Move the group to another node.
//
//  Arguments:
//      pciNode         [IN] Node to move the group to.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Move(IN const CClusterNode * pciNode)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT_VALID(pciNode);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    if (pciNode->StrName() == StrOwner())
    {
        CString strMsg;
        strMsg.FormatMessage(IDS_CANT_MOVE_GROUP_TO_SAME_NODE, StrName(), StrOwner());
        AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
    }  // if:  trying to move to the same node
    else
    {
        // Move the group.
        dwStatus = MoveClusterGroup(Hgroup(), pciNode->Hnode());
        if (    (dwStatus != ERROR_SUCCESS)
            &&  (dwStatus != ERROR_IO_PENDING))
        {
            CNTException    nte(dwStatus, IDS_MOVE_GROUP_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
            nte.ReportError();
        }  // if:  error moving the group
    }  // else:  trying to move to a different node

    Release();

}  //*** CGroup::Move()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::BCanBeDropTarget
//
//  Routine Description:
//      Determine if the specified item can be dropped on this item.
//
//  Arguments:
//      pci         [IN OUT] Item to be dropped on this item.
//
//  Return Value:
//      TRUE        Can be drop target.
//      FALSE       Can NOT be drop target.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::BCanBeDropTarget(IN const CClusterItem * pci) const
{
    BOOL    bCan;

    // This group can be a drop target only if the specified item
    // is a resource and it is not already a member of this group.

    if (pci->IdsType() == IDS_ITEMTYPE_RESOURCE)
    {
        CResource * pciRes = (CResource *) pci;
        ASSERT_KINDOF(CResource, pciRes);
        if (pciRes->StrGroup() != StrName())
        {
            bCan = TRUE;
        }
        else
        {
            bCan = FALSE;
        }
        Trace(g_tagGroupDrag, _T("(%s) BCanBeDropTarget() - Dragging resource '%s' (%x) (group = '%s' (%x)) over group '%s' (%x)"), Pdoc()->StrNode(), pciRes->StrName(), pciRes, pciRes->StrGroup(), pciRes->PciGroup(), StrName(), this);
    }  // if:  resource item
    else
    {
        bCan = FALSE;
    }

    return bCan;

}  //*** CGroup::BCanBeDropTarget()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::DropItem
//
//  Routine Description:
//      Process an item being dropped on this item.
//
//  Arguments:
//      pci         [IN OUT] Item dropped on this item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::DropItem(IN OUT CClusterItem * pci)
{
    if (BCanBeDropTarget(pci))
    {
        POSITION    pos;
        UINT        imenu;
        UINT        idMenu;
        CGroup *    pciGroup;
        CResource * pciRes;

        // Calculate the ID of this group.
        pos = Pdoc()->LpciGroups().GetHeadPosition();
        for (imenu = 0, idMenu = ID_FILE_MOVE_RESOURCE_1
                ; pos != NULL
                ; idMenu++)
        {
            pciGroup = (CGroup *) Pdoc()->LpciGroups().GetNext(pos);
            ASSERT_VALID(pciGroup);
            if (pciGroup == this)
            {
                break;
            }
        }  // for:  each group
        ASSERT(imenu < (UINT) Pdoc()->LpciGroups().GetCount());

        // Change the group of the specified resource.
        pciRes = (CResource *) pci;
        ASSERT_KINDOF(CResource, pci);
        ASSERT_VALID(pciRes);
        pciRes->OnCmdMoveResource(idMenu);
    }  // if:  item can be dropped on this item
    else if (pci->IdsType() == IDS_ITEMTYPE_RESOURCE)
    {
        CString     strMsg;

#ifdef _DEBUG
        CResource * pciRes = (CResource *) pci;

        ASSERT_KINDOF(CResource, pci);
        ASSERT_VALID(pciRes);
        ASSERT(pciRes->StrGroup() == StrName());
#endif // _DEBUG

        strMsg.FormatMessage(
                    IDS_CANT_MOVE_RES_TO_GROUP,
                    pci->StrName(),
                    StrName()
                    );

        AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
    }  // else if:  dropped item is a resource
    else
    {
        CClusterItem::DropItem(pci);
    }

}  //*** CGroup::DropItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL        bHandled    = FALSE;

    // If this is a MOVE_GROUP command, process it here.
    if ((ID_FILE_MOVE_GROUP_1 <= nID) && (nID <= ID_FILE_MOVE_GROUP_16))
    {
        Trace(g_tagGroup, _T("(%s) OnCmdMsg() %s (%x) - ID = %d, code = %d"), Pdoc()->StrNode(), StrName(), this, nID, nCode);
        if (nCode == 0)
        {
            OnCmdMoveGroup(nID);
            bHandled = TRUE;
        }  // if:  code = 0
    }  // if:  move resource

    if (!bHandled)
    {
        bHandled = CClusterItem::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    }

    return bHandled;

}  //*** CGroup::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnUpdateBringOnline
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_BRING_ONLINE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateBringOnline(CCmdUI * pCmdUI)
{
    if (   (Cgs() != ClusterGroupOnline)
        && (Cgs() != ClusterGroupPending)
        && (Cgs() != ClusterGroupStateUnknown))
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

}  //*** CGroup::OnUpdateBringOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnUpdateTakeOffline
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_TAKE_OFFLINE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateTakeOffline(CCmdUI * pCmdUI)
{
    if (   (Cgs() == ClusterGroupOnline)
        || (Cgs() == ClusterGroupPartialOnline))
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

}  //*** CGroup::OnUpdateTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnUpdateMoveGroup
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_MOVE_GROUP
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateMoveGroup(CCmdUI * pCmdUI)
{
    if (   (pCmdUI->m_pSubMenu == NULL)
        && (pCmdUI->m_pParentMenu == NULL))
    {
        if (   (Cgs() == ClusterGroupStateUnknown)
            || (Cgs() == ClusterGroupPending)
            || (Pdoc()->LpciNodes().GetCount() < 2))
        {
            pCmdUI->Enable(FALSE);
        }
        else
        {
            pCmdUI->Enable(TRUE);
        }
    }  // if:  nested menu is being displayed
    else
    {
        BOOL    bEnabled;
        CString strMenuName;

        if (pCmdUI->m_pMenu != NULL)
        {
            pCmdUI->m_pMenu->GetMenuString(0, strMenuName, MF_BYPOSITION);
            Trace(g_tagGroupMenu, _T("(%s) pMenu(0) = '%s'"), Pdoc()->StrNode(), strMenuName);
            pCmdUI->m_pMenu->GetMenuString(pCmdUI->m_nIndex, strMenuName, MF_BYPOSITION);
            Trace(g_tagGroupMenu, _T("(%s) pMenu(%d) = '%s'"), Pdoc()->StrNode(), pCmdUI->m_nIndex, strMenuName);
        }  // if:  main menu

        if (pCmdUI->m_pSubMenu != NULL)
        {
            pCmdUI->m_pSubMenu->GetMenuString(0, strMenuName, MF_BYPOSITION);
            Trace(g_tagGroupMenu, _T("(%s) pSubMenu(0) = '%s'"), Pdoc()->StrNode(), strMenuName);
            pCmdUI->m_pSubMenu->GetMenuString(pCmdUI->m_nIndex, strMenuName, MF_BYPOSITION);
            Trace(g_tagGroupMenu, _T("(%s) pSubMenu(%d) = '%s'"), Pdoc()->StrNode(), pCmdUI->m_nIndex, strMenuName);
        }  // if:  submenu

        // Handle the menu item based on whether it is on the main menu
        // or on the submenu.

        if (pCmdUI->m_pSubMenu == NULL)
        {
            bEnabled = OnUpdateMoveGroupItem(pCmdUI);
            pCmdUI->Enable(bEnabled);
        }  // if:  on the main menu
        else
        {
            bEnabled = OnUpdateMoveGroupSubMenu(pCmdUI);
        }  // else:  on the submenu

        // Enable or disable the Move menu.
        pCmdUI->m_pMenu->EnableMenuItem(
                            pCmdUI->m_nIndex,
                            MF_BYPOSITION
                            | (bEnabled ? MF_ENABLED : MF_GRAYED)
                            );
    }  // else:  top-level menu is being displayed

}  //*** CGroup::OnUpdateMoveGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnUpdateMoveGroupItem
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_MOVE_GROUP
//      that are not popups should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      TRUE        Item should be enabled.
//      FALSE       Item should be disabled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::OnUpdateMoveGroupItem(CCmdUI * pCmdUI)
{
    BOOL    bEnabled;

    // If there are more than two nodes, make the menu item a submenu.
    if (   (Cgs() == ClusterGroupStateUnknown)
        || (Cgs() == ClusterGroupPending)
        || (Pdoc()->LpciNodes().GetCount() < 2))
    {
        bEnabled = FALSE;
    }
    else if (Pdoc()->LpciNodes().GetCount() == 2)
    {
        bEnabled = TRUE;
    }
    else
    {
        UINT            idMenu;
        POSITION        pos;
        CClusterNode *  pciNode;
        CString         strMenuName;
        CMenu           menuMove;
        CMenu *         pmenu   = pCmdUI->m_pMenu;

        // Load the Move submenu.
        VERIFY(menuMove.LoadMenu(IDM_MOVE_GROUP) != 0);
        ASSERT(menuMove.GetMenuItemCount() == 2);

        // Add all the nodes in the cluster to the end of the menu.
        pos = Pdoc()->LpciNodes().GetHeadPosition();
        for (idMenu = ID_FILE_MOVE_GROUP_1
                ; pos != NULL
                ; idMenu++)
        {
            pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext(pos);
            ASSERT_VALID(pciNode);
            VERIFY(menuMove.AppendMenu(
                                MF_BYPOSITION | MF_STRING,
                                idMenu,
                                pciNode->StrName()
                                ));
        }  // for:  each node

        // Get the name of the menu.
        pmenu->GetMenuString(pCmdUI->m_nIndex, strMenuName, MF_BYPOSITION);

        Trace(g_tagGroupMenu, _T("(%s) Making item '%s' a submenu"), Pdoc()->StrNode(), strMenuName);

        // Modify this menu item.
        VERIFY(pmenu->ModifyMenu(
                            pCmdUI->m_nIndex,
                            MF_BYPOSITION | MF_STRING | MF_POPUP,
                            (UINT_PTR) menuMove.m_hMenu,
                            strMenuName
                            ));

        // Detach the menu from the class since we don't own it anymore.
        menuMove.Detach();

        bEnabled = TRUE;
    }  // else:  more than two nodes in the cluster

    return bEnabled;

}  //*** CGroup::OnUpdateMoveGroupItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnUpdateMoveGroupSubMenu
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_MOVE_GROUP
//      that are on popups should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      TRUE        Item should be enabled.
//      FALSE       Item should be disabled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::OnUpdateMoveGroupSubMenu(CCmdUI * pCmdUI)
{
    BOOL    bEnabled;

    // If there are not more than two nodes, make the menu item a normal item.
    if (Pdoc()->LpciNodes().GetCount() > 2)
    {
        bEnabled = TRUE;
    }
    else
    {
        CString         strMenuName;
        CMenu *         pmenu   = pCmdUI->m_pMenu;

        // Get the name of the menu.
        pmenu->GetMenuString(pCmdUI->m_nIndex, strMenuName, MF_BYPOSITION);

        Trace(g_tagGroupMenu, _T("(%s) Making item '%s' a non-submenu"), Pdoc()->StrNode(), strMenuName);

        // Modify this menu item.
        // We should be able to just modify the menu, but for some reason
        // this doesn't work.  So, instead, we will remove the previous item
        // and add a new item.
#ifdef NEVER
        VERIFY(pmenu->ModifyMenu(
                            pCmdUI->m_nIndex,
                            MF_BYPOSITION | MF_STRING,
                            ID_FILE_MOVE_GROUP,
                            strMenuName
                            ));
#else
        VERIFY(pmenu->DeleteMenu(pCmdUI->m_nIndex, MF_BYPOSITION));
        VERIFY(pmenu->InsertMenu(
                            pCmdUI->m_nIndex,
                            MF_BYPOSITION | MF_STRING,
                            ID_FILE_MOVE_GROUP,
                            strMenuName
                            ));
#endif

        if (   (Cgs() == ClusterGroupStateUnknown)
            || (Cgs() == ClusterGroupPending)
            || (Pdoc()->LpciNodes().GetCount() < 2))
        {
            bEnabled = FALSE;
        }
        else
        {
            bEnabled = TRUE;
        }

        AfxGetMainWnd()->DrawMenuBar();
    }  // else:  not more than two nodes in the cluster

    return bEnabled;

}  //*** CGroup::OnUpdateMoveGroupSubMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnUpdateMoveGroupRest
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_MOVE_GROUP_1
//      through ID_FILE_MOVE_GROUP_16 should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateMoveGroupRest(CCmdUI * pCmdUI)
{
    if (   (Cgs() == ClusterGroupStateUnknown)
        || (Cgs() == ClusterGroupPending))
    {
        pCmdUI->Enable(FALSE);
    }
    else
    {
        pCmdUI->Enable(TRUE);
    }

}  //*** CGroup::OnUpdateMoveGroupRest()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnUpdateDelete
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_DELETE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateDelete(CCmdUI * pCmdUI)
{
    if (   (Cgs() != ClusterGroupStateUnknown)
        && (Cgs() != ClusterGroupPending)
        && Lpcires().IsEmpty())
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

}  //*** CGroup::OnUpdateDelete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnCmdBringOnline
//
//  Routine Description:
//      Processes the ID_FILE_BRING_ONLINE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdBringOnline(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hgroup() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    dwStatus = OnlineClusterGroup(Hgroup(), NULL);
    if (    (dwStatus != ERROR_SUCCESS)
        &&  (dwStatus != ERROR_IO_PENDING))
    {
        CNTException    nte(dwStatus, IDS_BRING_GROUP_ONLINE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
        nte.ReportError();
    }  // if:  error bringing the group online

    UpdateState();

    Release();

}  //*** CGroup::OnCmdBringOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnCmdTakeOffline
//
//  Routine Description:
//      Processes the ID_FILE_TAKE_OFFLINE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdTakeOffline(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hgroup() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    dwStatus = OfflineClusterGroup(Hgroup());
    if (    (dwStatus != ERROR_SUCCESS)
        &&  (dwStatus != ERROR_IO_PENDING))
    {
        CNTException    nte(dwStatus, IDS_TAKE_GROUP_OFFLINE_ERROR, StrName(), NULL, FALSE /*bAUtoDelete*/);
        nte.ReportError();
    }  // if:  error taking the group offline

    UpdateState();

    Release();

}  //*** CGroup::OnCmdTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnCmdMoveGroup
//
//  Routine Description:
//      Processes the ID_FILE_MOVE_GROUP menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdMoveGroup(void)
{
    OnCmdMoveGroup((UINT) -1);

}  //*** CGroup::OnCmdMoveGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnCmdMoveGroup
//
//  Routine Description:
//      Processes the ID_FILE_MOVE_GROUP_1 through ID_FILE_MOVE_GROUP_16 menu
//      commands.
//
//  Arguments:
//      nID             [IN] Command ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdMoveGroup(IN UINT nID)
{
    DWORD           dwStatus;
    HNODE           hnode;
    CClusterNode *  pciNode;
    CWaitCursor     wc;

    ASSERT(Hgroup() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // Get the handle of the node to move the group to.
    if ((int) nID >= 0)
    {
        int         ipci;

        ipci = (int) (nID - ID_FILE_MOVE_GROUP_1);
        ASSERT(ipci < Pdoc()->LpciNodes().GetCount());
        if (ipci < Pdoc()->LpciNodes().GetCount())
        {
            POSITION        pos;

            // Get the node.
            pos = Pdoc()->LpciNodes().FindIndex(ipci);
            ASSERT(pos);
            pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetAt(pos);
            ASSERT_VALID(pciNode);

            hnode = pciNode->Hnode();
        }  // if:  valid node index
        else
        {
            goto Cleanup;
        }
    }  // if:  non-default ID specified
    else
    {
        hnode = NULL;
        pciNode = NULL;
    }  // else:  default ID specified

    // Move the group.
    dwStatus = MoveClusterGroup(Hgroup(), hnode);
    if (    (dwStatus != ERROR_SUCCESS)
        &&  (dwStatus != ERROR_IO_PENDING))
    {
        CNTException    nte(dwStatus, IDS_MOVE_GROUP_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
        nte.ReportError();
    }  // if:  error moving the group

    UpdateState();

Cleanup:

    Release();

}  //*** CGroup::OnCmdMoveGroup(nID)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnCmdDelete
//
//  Routine Description:
//      Processes the ID_FILE_DELETE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdDelete(void)
{
    ASSERT(Hgroup() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // Verify that the user really wants to delete this resource.
    {
        CString     strMsg;

        strMsg.FormatMessage(IDS_VERIFY_DELETE_GROUP, StrName());
        if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
        {
            goto Cleanup;
        }
    }  // Verify that the user really wants to delete this resource

    try
    {
        DeleteGroup();
    }  // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() != ERROR_GROUP_NOT_AVAILABLE)
            pnte->ReportError();
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

Cleanup:

    Release();

}  //*** CGroup::OnCmdDelete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateProperties(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(TRUE);

}  //*** CGroup::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::BDisplayProperties(IN BOOL bReadOnly)
{
    BOOL            bChanged = FALSE;
    CGroupPropSheet sht(AfxGetMainWnd());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if (BChanged())
    {
        ReadItem();
    }

    // Display the property sheet.
    try
    {
        sht.SetReadOnly(bReadOnly);
        if (sht.BInit(this, IimgObjectType()))
        {
            bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
        }
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CGroup::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroup::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
    ASSERT(pnotify != NULL);
    ASSERT_VALID(this);

    try
    {
        switch (pnotify->m_dwFilterType)
        {
            case CLUSTER_CHANGE_GROUP_STATE:
                Trace(g_tagGroupNotify, _T("(%s) - Group '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                UpdateState();
                break;

            case CLUSTER_CHANGE_GROUP_DELETED:
                Trace(g_tagGroupNotify, _T("(%s) - Group '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    Delete();
                break;

            case CLUSTER_CHANGE_GROUP_PROPERTY:
                Trace(g_tagGroupNotify, _T("(%s) - Group '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    ReadItem();
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace(g_tagGroupRegNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace(g_tagGroupRegNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName());
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace(g_tagGroupRegNotify, _T("(%s) - Registry value at '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            default:
                Trace(g_tagGroupNotify, _T("(%s) - Unknown group notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
        }  // switch:  dwFilterType
    }  // try
    catch (CException * pe)
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    delete pnotify;
    return 0;

}  //*** CGroup::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CGroupList & rlp)
{
    POSITION    pos;
    CGroup *    pci;

    // Delete all the items in the list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        pci = rlp.GetNext(pos);
        ASSERT_VALID(pci);
//      Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlpcigrp) - Deleting group cluster item '%s' (%x)"), pci->StrName(), pci);
        pci->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\grpprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      GrpProp.cpp
//
//  Abstract:
//      Implementation of the group property sheet and pages.
//
//  Author:
//      David Potter (davidp)   May 14, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GrpProp.h"
#include "Group.h"
#include "ModNodes.h"
#include "DDxDDv.h"
#include "ClusDoc.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupPropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CGroupPropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CGroupPropSheet, CBasePropertySheet)
    //{{AFX_MSG_MAP(CGroupPropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupPropSheet::CGroupPropSheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroupPropSheet::CGroupPropSheet(
    IN OUT CWnd *   pParentWnd,
    IN UINT         iSelectPage
    )
    : CBasePropertySheet(pParentWnd, iSelectPage)
{
    m_rgpages[0] = &PageGeneral();
    m_rgpages[1] = &PageFailover();
    m_rgpages[2] = &PageFailback();

}  //*** CGroupPropSheet::CGroupPropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupPropSheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupPropSheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    // Call the base class method.
    if (!CBasePropertySheet::BInit(pci, iimgIcon))
    {
        return FALSE;
    }

    // Set the read-only flag.
    m_bReadOnly = PciGroup()->BReadOnly()
                    || (PciGroup()->Cgs() == ClusterGroupStateUnknown);

    return TRUE;

}  //*** CGroupPropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupPropSheet::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CGroupPropSheet::Ppages(void)
{
    return m_rgpages;

}  //*** CGroupPropSheet::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupPropSheet::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CGroupPropSheet::Cpages(void)
{
    return RTL_NUMBER_OF( m_rgpages );

}  //*** CGroupPropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CGroupGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGroupGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CGroupGeneralPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CGroupGeneralPage)
    ON_BN_CLICKED(IDC_PP_GROUP_PREF_OWNERS_MODIFY, OnModifyPreferredOwners)
    ON_LBN_DBLCLK(IDC_PP_GROUP_PREF_OWNERS, OnDblClkPreferredOwners)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_GROUP_NAME, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_GROUP_DESC, CBasePropertyPage::OnChangeCtrl)
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::CGroupGeneralPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroupGeneralPage::CGroupGeneralPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_GROUP_GENERAL)
{
    //{{AFX_DATA_INIT(CGroupGeneralPage)
    m_strName = _T("");
    m_strDesc = _T("");
    m_strState = _T("");
    m_strNode = _T("");
    //}}AFX_DATA_INIT

}  //*** CGroupGeneralPage::CGroupGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    bSuccess;

    ASSERT_KINDOF(CGroupPropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);
    if (bSuccess)
    {
        try
        {
            m_strName = PciGroup()->StrName();
            m_strDesc = PciGroup()->StrDescription();
            m_strNode = PciGroup()->StrOwner();

            // Duplicate the preferred owners list.
            {
                POSITION        pos;
                CClusterNode *  pciNode;

                pos = PciGroup()->LpcinodePreferredOwners().GetHeadPosition();
                while (pos != NULL)
                {
                    pciNode = (CClusterNode *) PciGroup()->LpcinodePreferredOwners().GetNext(pos);
                    ASSERT_VALID(pciNode);
                    m_lpciPreferredOwners.AddTail(pciNode);
                }  // while:  more nodes in the list
            }  // Duplicate the possible owners list

            PciGroup()->GetStateName(m_strState);
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  // if:  base class method was successful

    return bSuccess;

}  //*** CGroupGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGroupGeneralPage)
    DDX_Control(pDX, IDC_PP_GROUP_PREF_OWNERS_MODIFY, m_pbPrefOwnersModify);
    DDX_Control(pDX, IDC_PP_GROUP_PREF_OWNERS, m_lbPrefOwners);
    DDX_Control(pDX, IDC_PP_GROUP_DESC, m_editDesc);
    DDX_Control(pDX, IDC_PP_GROUP_NAME, m_editName);
    DDX_Text(pDX, IDC_PP_GROUP_NAME, m_strName);
    DDX_Text(pDX, IDC_PP_GROUP_DESC, m_strDesc);
    DDX_Text(pDX, IDC_PP_GROUP_CURRENT_STATE, m_strState);
    DDX_Text(pDX, IDC_PP_GROUP_CURRENT_NODE, m_strNode);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BReadOnly())
        {
            DDV_RequiredText(pDX, IDC_PP_GROUP_NAME, IDC_PP_GROUP_NAME_LABEL, m_strName);

            try
            {
                PciGroup()->ValidateCommonProperties(
                                m_strDesc,
                                PciGroup()->NFailoverThreshold(),
                                PciGroup()->NFailoverPeriod(),
                                PciGroup()->CgaftAutoFailbackType(),
                                PciGroup()->NFailbackWindowStart(),
                                PciGroup()->NFailbackWindowEnd()
                                );
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                pDX->Fail();
            }  // catch:  CException
        }  // if:  not read only
    }  // if:  saving data from dialog
    else
    {
        FillPrefOwners();
    }  // else:  setting data to dialog

}  //*** CGroupGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::FillPrefOwners
//
//  Routine Description:
//      Fill the Preferred Owners list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::FillPrefOwners(void)
{
    POSITION        posPci;
    CClusterNode *  pciNode;
    int             iitem;

    m_lbPrefOwners.ResetContent();

    posPci = LpciPreferredOwners().GetHeadPosition();
    while (posPci != NULL)
    {
        pciNode = (CClusterNode *) LpciPreferredOwners().GetNext(posPci);
        iitem = m_lbPrefOwners.AddString(pciNode->StrName());
        if (iitem >= 0)
        {
            m_lbPrefOwners.SetItemDataPtr(iitem, pciNode);
        }
    }  // for:  each string in the list

}  //*** CGroupGeneralPage::FillPrefOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_editName.SetReadOnly(TRUE);
        m_editDesc.SetReadOnly(TRUE);
        m_pbPrefOwnersModify.EnableWindow(FALSE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGroupGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::OnApply
//
//  Routine Description:
//      Handler for when the Apply button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciGroup()->SetName(m_strName);
        PciGroup()->SetCommonProperties(
                        m_strDesc,
                        PciGroup()->NFailoverThreshold(),
                        PciGroup()->NFailoverPeriod(),
                        PciGroup()->CgaftAutoFailbackType(),
                        PciGroup()->NFailbackWindowStart(),
                        PciGroup()->NFailbackWindowEnd()
                        );
        PciGroup()->SetPreferredOwners(m_lpciPreferredOwners);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CGroupGeneralPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::OnProperties(void)
{
    int             iitem;
    CClusterNode *  pciNode;

    // Get the item with the focus.
    iitem = m_lbPrefOwners.GetCurSel();
    ASSERT(iitem >= 0);

    if (iitem >= 0)
    {
        // Get the node pointer.
        pciNode = (CClusterNode *) m_lbPrefOwners.GetItemDataPtr(iitem);
        ASSERT_VALID(pciNode);

        // Set properties of that item.
        if (pciNode->BDisplayProperties())
        {
        }  // if:  properties changed
    }  // if:  found an item with focus

}  //*** CGroupGeneralPage::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::OnContextMenu( CWnd * pWnd, CPoint point )
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListBox *      pListBox    = (CListBox *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list control, don't handle the message.
    if ( pWnd == &m_lbPrefOwners )
    {
        // Create the menu to display.
        try
        {
            pmenu = new CMenu;
            if ( pmenu == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the menu

            if ( pmenu->CreatePopupMenu() )
            {
                UINT    nFlags  = MF_STRING;

                // If there are no items in the list, disable the menu item.
                if ( pListBox->GetCount() == 0 )
                {
                    nFlags |= MF_GRAYED;
                } // if: no items in the list

                // Add the Properties item to the menu.
                strMenuName.LoadString( IDS_MENU_PROPERTIES );
                if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
                {
                    bHandled = TRUE;
                    if ( pListBox->GetCurSel() == -1 )
                    {
                        pListBox->SetCurSel( 0 );
                    } // if: no item selected
                }  // if:  successfully added menu item
            }  // if:  menu created successfully
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // if:  focus is on the list control

    if ( bHandled )
    {
        // Display the menu.
        if ( ! pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        this
                        ) )
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display
    else
    {
        CBasePropertyPage::OnContextMenu( pWnd, point );
    } // else: no menu to display

    delete pmenu;

}  //*** CGroupGeneralPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::OnModifyPreferredOwners
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Modify Preferred Owners button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::OnModifyPreferredOwners(void)
{
    CModifyNodesDlg dlg(
                        IDD_MODIFY_PREFERRED_OWNERS,
                        g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS,
                        m_lpciPreferredOwners,
                        PciGroup()->Pdoc()->LpciNodes(),
                        LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY | LCPS_CAN_BE_ORDERED | LCPS_ORDERED
                        );

    if (dlg.DoModal() == IDOK)
    {
        SetModified(TRUE);
        FillPrefOwners();
    }  // if:  OK button pressed

}  //*** CGroupGeneralPage::OnModifyPreferredOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::OnDblClkPreferredOwners
//
//  Routine Description:
//      Handler for the LBN_DBLCLK message on the Preferred Owners listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::OnDblClkPreferredOwners(void)
{
    OnProperties();

}  //*** CGroupGeneralPage::OnDblClkPreferredOwners()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CGroupFailoverPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGroupFailoverPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CGroupFailoverPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CGroupFailoverPage)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_GROUP_FAILOVER_THRESH, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_GROUP_FAILOVER_PERIOD, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::CGroupFailoverPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroupFailoverPage::CGroupFailoverPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_GROUP_FAILOVER)
{
    //{{AFX_DATA_INIT(CGroupFailoverPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

}  //*** CGroupFailoverPage::CGroupFailoverPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    fSuccess;

    ASSERT_KINDOF(CGroupPropSheet, psht);

    fSuccess = CBasePropertyPage::BInit(psht);

    m_nThreshold= PciGroup()->NFailoverThreshold();
    m_nPeriod= PciGroup()->NFailoverPeriod();

    return fSuccess;

}  //*** CBasePropertyPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailoverPage::DoDataExchange(CDataExchange* pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGroupFailoverPage)
    DDX_Control(pDX, IDC_PP_GROUP_FAILOVER_THRESH, m_editThreshold);
    DDX_Control(pDX, IDC_PP_GROUP_FAILOVER_PERIOD, m_editPeriod);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BReadOnly())
        {
            DDX_Number(
                pDX,
                IDC_PP_GROUP_FAILOVER_THRESH,
                m_nThreshold,
                CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD,
                CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD
                );
            DDX_Number(
                pDX,
                IDC_PP_GROUP_FAILOVER_PERIOD,
                m_nPeriod,
                CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD,
                CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD
                );

            try
            {
                PciGroup()->ValidateCommonProperties(
                                PciGroup()->StrDescription(),
                                m_nThreshold,
                                m_nPeriod,
                                PciGroup()->CgaftAutoFailbackType(),
                                PciGroup()->NFailbackWindowStart(),
                                PciGroup()->NFailbackWindowEnd()
                                );
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                pDX->Fail();
            }  // catch:  CException
        }  // if:  not read only
    }  // if:  saving data from dialog
    else
    {
        DDX_Number(
            pDX,
            IDC_PP_GROUP_FAILOVER_THRESH,
            m_nThreshold,
            CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD,
            CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD
            );
        DDX_Number(
            pDX,
            IDC_PP_GROUP_FAILOVER_PERIOD,
            m_nPeriod,
            CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD,
            CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD
            );
    }  // else:  setting data to dialog

}  //*** CGroupFailoverPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_editPeriod.SetReadOnly(TRUE);
        m_editThreshold.SetReadOnly(TRUE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGroupFailoverPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::OnApply
//
//  Routine Description:
//      Handler for when the Apply button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciGroup()->SetCommonProperties(
                        PciGroup()->StrDescription(),
                        m_nThreshold,
                        m_nPeriod,
                        PciGroup()->CgaftAutoFailbackType(),
                        PciGroup()->NFailbackWindowStart(),
                        PciGroup()->NFailbackWindowEnd()
                        );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CGroupFailoverPage::OnApply()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CGroupFailbackPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGroupFailbackPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CGroupFailbackPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CGroupFailbackPage)
    ON_BN_CLICKED(IDC_PP_GROUP_AUTOFB_PREVENT, OnClickedPreventFailback)
    ON_BN_CLICKED(IDC_PP_GROUP_AUTOFB_ALLOW, OnClickedAllowFailback)
    ON_BN_CLICKED(IDC_PP_GROUP_FB_IMMED, OnClickedFailbackImmediate)
    ON_BN_CLICKED(IDC_PP_GROUP_FB_WINDOW, OnClickedFailbackInWindow)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_GROUP_FBWIN_START, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_GROUP_FBWIN_END, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::CGroupFailbackPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroupFailbackPage::CGroupFailbackPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_GROUP_FAILBACK)
{
    //{{AFX_DATA_INIT(CGroupFailbackPage)
    //}}AFX_DATA_INIT

    m_nStart = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
    m_nEnd = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;

}  //*** CGroupFailbackPage::CGroupFailbackPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    bSuccess;

    ASSERT_KINDOF(CGroupPropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);

    m_cgaft = PciGroup()->CgaftAutoFailbackType();
    m_nStart = PciGroup()->NFailbackWindowStart();
    m_nEnd = PciGroup()->NFailbackWindowEnd();
    m_bNoFailbackWindow = ((m_cgaft == ClusterGroupPreventFailback)
                                || (m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
                                || (m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE));

    return bSuccess;

}  //*** CGroupFailbackPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGroupFailbackPage)
    DDX_Control(pDX, IDC_PP_GROUP_AUTOFB_PREVENT, m_rbPreventFailback);
    DDX_Control(pDX, IDC_PP_GROUP_AUTOFB_ALLOW, m_rbAllowFailback);
    DDX_Control(pDX, IDC_PP_GROUP_FB_IMMED, m_rbFBImmed);
    DDX_Control(pDX, IDC_PP_GROUP_FB_WINDOW, m_rbFBWindow);
    DDX_Control(pDX, IDC_PP_GROUP_FB_WINDOW_LABEL1, m_staticFBWindow1);
    DDX_Control(pDX, IDC_PP_GROUP_FB_WINDOW_LABEL2, m_staticFBWindow2);
    DDX_Control(pDX, IDC_PP_GROUP_FBWIN_START, m_editStart);
    DDX_Control(pDX, IDC_PP_GROUP_FBWIN_START_SPIN, m_spinStart);
    DDX_Control(pDX, IDC_PP_GROUP_FBWIN_END, m_editEnd);
    DDX_Control(pDX, IDC_PP_GROUP_FBWIN_END_SPIN, m_spinEnd);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BReadOnly())
        {
            if ((m_cgaft == ClusterGroupAllowFailback) && !m_bNoFailbackWindow)
            {
                DDX_Number(pDX, IDC_PP_GROUP_FBWIN_START, m_nStart, 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START);
                DDX_Number(pDX, IDC_PP_GROUP_FBWIN_END, m_nEnd, 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END);
                if (m_nStart == m_nEnd)
                {
                    AfxMessageBox(IDS_SAME_START_AND_END, MB_OK | MB_ICONEXCLAMATION);
                    pDX->Fail();
                }  // if:  values are the same
            }  // if:  failback is allowed and failback window desired

            try
            {
                PciGroup()->ValidateCommonProperties(
                                PciGroup()->StrDescription(),
                                PciGroup()->NFailoverThreshold(),
                                PciGroup()->NFailoverPeriod(),
                                m_cgaft,
                                m_nStart,
                                m_nEnd
                                );
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                pDX->Fail();
            }  // catch:  CException
        }  // if:  not read only
    }  // if:  saving data
    else
    {
        if (m_cgaft == ClusterGroupPreventFailback)
        {
            m_rbPreventFailback.SetCheck(BST_CHECKED);
            m_rbAllowFailback.SetCheck(BST_UNCHECKED);
            OnClickedPreventFailback();
        }  // if:  failbacks are not allowed
        else
        {
            m_rbPreventFailback.SetCheck(BST_UNCHECKED);
            m_rbAllowFailback.SetCheck(BST_CHECKED);
            OnClickedAllowFailback();
        }  // else:  failbacks are allowed
        m_rbFBImmed.SetCheck(m_bNoFailbackWindow ? BST_CHECKED : BST_UNCHECKED);
        m_rbFBWindow.SetCheck(m_bNoFailbackWindow ? BST_UNCHECKED : BST_CHECKED);

        // Set up the Start and End window controls.
        DDX_Number(pDX, IDC_PP_GROUP_FBWIN_START, m_nStart, 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START);
        DDX_Number(pDX, IDC_PP_GROUP_FBWIN_END, m_nEnd, 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END);
        m_spinStart.SetRange(0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START);
        m_spinEnd.SetRange(0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END);
        if (m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
        {
            m_editStart.SetWindowText(TEXT(""));
        }
        if (m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
        {
            m_editEnd.SetWindowText(TEXT(""));
        }
    }  // else:  not saving data

}  //*** CGroupFailbackPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_rbPreventFailback.EnableWindow(FALSE);
        m_rbAllowFailback.EnableWindow(FALSE);
        m_rbFBImmed.EnableWindow(FALSE);
        m_rbFBWindow.EnableWindow(FALSE);
        m_staticFBWindow1.EnableWindow(FALSE);
        m_staticFBWindow2.EnableWindow(FALSE);
        m_spinStart.EnableWindow(FALSE);
        m_spinEnd.EnableWindow(FALSE);
        m_editStart.SetReadOnly(TRUE);
        m_editEnd.SetReadOnly(TRUE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGroupFailbackPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnApply
//
//  Routine Description:
//      Handler for when the Apply button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        if (m_bNoFailbackWindow)
        {
            m_nStart = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
            m_nEnd = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
        }  // if:  no failback window
        PciGroup()->SetCommonProperties(
                        PciGroup()->StrDescription(),
                        PciGroup()->NFailoverThreshold(),
                        PciGroup()->NFailoverPeriod(),
                        m_cgaft,
                        m_nStart,
                        m_nEnd
                        );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CGroupFailbackPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnClickedPreventFailback
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Prevent Failback radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::OnClickedPreventFailback(void)
{
    // Disable the Failback Window controls.
    m_rbFBImmed.EnableWindow(FALSE);
    m_rbFBWindow.EnableWindow(FALSE);
    m_staticFBWindow1.EnableWindow(FALSE);
    m_staticFBWindow2.EnableWindow(FALSE);

    OnClickedFailbackImmediate();

    // Call the base class method if the state changed.
    if (m_cgaft != ClusterGroupPreventFailback)
    {
        CBasePropertyPage::OnChangeCtrl();
        m_cgaft = ClusterGroupPreventFailback;
    }  // if:  state changed

}  //*** CGroupFailbackPage::OnClickedPreventFailback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnClickedAllowFailback
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Allow Failback radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::OnClickedAllowFailback(void)
{
    // Enable the Failback Window controls.
    m_rbFBImmed.EnableWindow(TRUE);
    m_rbFBWindow.EnableWindow(TRUE);
    m_staticFBWindow1.EnableWindow(TRUE);
    m_staticFBWindow2.EnableWindow(TRUE);

    if (m_bNoFailbackWindow)
    {
        OnClickedFailbackImmediate();
    }
    else
    {
        OnClickedFailbackInWindow();
    }

    // Call the base class method if the state changed.
    if (m_cgaft != ClusterGroupAllowFailback)
    {
        CBasePropertyPage::OnChangeCtrl();
        m_cgaft = ClusterGroupAllowFailback;
    }  // if:  state changed

}  //*** CGroupFailbackPage::OnClickedAllowFailback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnClickedFailbackImmediate
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Failback Immediately radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::OnClickedFailbackImmediate(void)
{
    // Disable the Failback Window controls.
    m_editStart.EnableWindow(FALSE);
    m_spinStart.EnableWindow(FALSE);
    m_editEnd.EnableWindow(FALSE);
    m_spinEnd.EnableWindow(FALSE);

    // Call the base class method if the state changed.
    if (!m_bNoFailbackWindow)
    {
        CBasePropertyPage::OnChangeCtrl();
    }

    m_bNoFailbackWindow = TRUE;

}  //*** CGroupFailbackPage::OnClickedFailbackImmediate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnClickedFailbackInWindow
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Failback In Window radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::OnClickedFailbackInWindow(void)
{
    // Enable the Failback Window controls.
    m_editStart.EnableWindow(TRUE);
    m_spinStart.EnableWindow(TRUE);
    m_editEnd.EnableWindow(TRUE);
    m_spinEnd.EnableWindow(TRUE);

    if (m_bNoFailbackWindow)
    {
        // Set the values of the edit controls.
        if (m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
        {
            SetDlgItemInt(IDC_PP_GROUP_FBWIN_START, 0, FALSE);
        }
        if (m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
        {
            SetDlgItemInt(IDC_PP_GROUP_FBWIN_END, 0, FALSE);
        }

        // Call the base class method.
        CBasePropertyPage::OnChangeCtrl();
    }  // if:  state changed

    m_bNoFailbackWindow = FALSE;

}  //*** CGroupFailbackPage::OnClickedFailbackInWindow()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _HELPDATA_H_
#define _HELPDATA_H_

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // _HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\grpprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		GrpProp.cpp
//
//	Abstract:
//		Definition of the group property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GRPPROP_H_
#define _GRPPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _GROUP_H_
#include "Group.h"		// for CGroup
#endif

#ifndef _NODE_H_
#include "Node.h"		// for CNodeList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroupGeneralPage;
class CGroupFailoverPage;
class CGroupFailbackPage;
class CGroupPropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CGroupGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGroupGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGroupGeneralPage)

// Construction
public:
	CGroupGeneralPage(void);
	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CGroupGeneralPage)
	enum { IDD = IDD_PP_GROUP_GENERAL };
	CEdit	m_editDesc;
	CButton	m_pbPrefOwnersModify;
	CListBox	m_lbPrefOwners;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strState;
	CString	m_strNode;
	//}}AFX_DATA

	CNodeList				m_lpciPreferredOwners;

	const CNodeList &		LpciPreferredOwners(void) const	{ return m_lpciPreferredOwners; }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CGroupPropSheet *		PshtGroup(void)	{ return (CGroupPropSheet *) Psht(); }
	CGroup *				PciGroup(void)	{ return (CGroup *) Pci(); }

	void					FillPrefOwners(void);

	// Generated message map functions
	//{{AFX_MSG(CGroupGeneralPage)
	afx_msg void OnModifyPreferredOwners();
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDblClkPreferredOwners();
	//}}AFX_MSG
	afx_msg void OnProperties();
	DECLARE_MESSAGE_MAP()

};  //*** class CGroupGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CGroupFailoverPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGroupFailoverPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGroupFailoverPage)

// Construction
public:
	CGroupFailoverPage(void);
	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CGroupFailoverPage)
	enum { IDD = IDD_PP_GROUP_FAILOVER };
	CEdit	m_editThreshold;
	CEdit	m_editPeriod;
	//}}AFX_DATA
	DWORD	m_nThreshold;
	DWORD	m_nPeriod;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupFailoverPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CGroupPropSheet *		PshtGroup(void)	{ return (CGroupPropSheet *) Psht(); }
	CGroup *				PciGroup(void)	{ return (CGroup *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CGroupFailoverPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGroupFailoverPage

/////////////////////////////////////////////////////////////////////////////
// CGroupFailbackPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGroupFailbackPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGroupFailbackPage)

// Construction
public:
	CGroupFailbackPage(void);
	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CGroupFailbackPage)
	enum { IDD = IDD_PP_GROUP_FAILBACK };
	CButton	m_rbPreventFailback;
	CButton	m_rbAllowFailback;
	CButton	m_rbFBImmed;
	CButton	m_rbFBWindow;
	CStatic	m_staticFBWindow1;
	CStatic	m_staticFBWindow2;
	CEdit	m_editStart;
	CSpinButtonCtrl	m_spinStart;
	CEdit	m_editEnd;
	CSpinButtonCtrl	m_spinEnd;
	//}}AFX_DATA
	CGAFT	m_cgaft;
	BOOL	m_bNoFailbackWindow;
	DWORD	m_nStart;
	DWORD	m_nEnd;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupFailbackPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CGroupPropSheet *		PshtGroup(void)	{ return (CGroupPropSheet *) Psht(); }
	CGroup *				PciGroup(void)	{ return (CGroup *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CGroupFailbackPage)
	afx_msg void OnClickedPreventFailback(void);
	afx_msg void OnClickedAllowFailback(void);
	afx_msg void OnClickedFailbackImmediate(void);
	afx_msg void OnClickedFailbackInWindow(void);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGroupFailbackPage

/////////////////////////////////////////////////////////////////////////////
// CGroupPropSheet
/////////////////////////////////////////////////////////////////////////////

class CGroupPropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CGroupPropSheet)

// Construction
public:
	CGroupPropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[3];

	// Pages
	CGroupGeneralPage				m_pageGeneral;
	CGroupFailoverPage				m_pageFailover;
	CGroupFailbackPage				m_pageFailback;

	CGroupGeneralPage &				PageGeneral(void)		{ return m_pageGeneral; }
	CGroupFailoverPage &			PageFailover(void)		{ return m_pageFailover; }
	CGroupFailbackPage &			PageFailback(void)		{ return m_pageFailback; }

public:
	CGroup *						PciGroup(void) const	{ return (CGroup *) Pci(); }

	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGroupPropSheet)
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGroupPropSheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGroupPropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _GRPPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\grpwiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      GrpWiz.cpp
//
//  Abstract:
//      Implementation of the CCreateGroupWizard class and all pages
//      specific to a group wizard.
//
//  Author:
//      David Potter (davidp)   July 22, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "GrpWiz.h"
#include "ClusDoc.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmapGroupWizName

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateGroupWizard
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CCreateGroupWizard, CBaseWizard)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CCreateGroupWizard, CBaseWizard)
    //{{AFX_MSG_MAP(CCreateGroupWizard)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::CCreateGroupWizard
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pdoc        [IN OUT] Document in which group is to be created.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCreateGroupWizard::CCreateGroupWizard(
    IN OUT CClusterDoc *    pdoc,
    IN OUT CWnd *           pParentWnd
    )
    : CBaseWizard(IDS_NEW_GROUP_TITLE, pParentWnd)

{
    ASSERT_VALID(pdoc);
    m_pdoc = pdoc;

    m_pciGroup = NULL;
    m_bCreated = FALSE;

    m_rgpages[0].m_pwpage = &m_pageName;
    m_rgpages[0].m_dwWizButtons = PSWIZB_NEXT;
    m_rgpages[1].m_pwpage = &m_pageOwners;
    m_rgpages[1].m_dwWizButtons = PSWIZB_BACK | PSWIZB_FINISH;

}  //*** CCreateGroupWizard::CCreateGroupWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::~CCreateGroupWizard
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCreateGroupWizard::~CCreateGroupWizard(void)
{
    if (m_pciGroup != NULL)
        m_pciGroup->Release();

}  //*** CCreateGroupWizard::~CCreateGroupWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Wizard initialized successfully.
//      FALSE   Wizard not initialized successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCreateGroupWizard::BInit(void)
{
    // Call the base class method.
    CClusterAdminApp *  papp = GetClusterAdminApp();
    if (!CBaseWizard::BInit(papp->Iimg(IMGLI_GROUP)))
        return FALSE;

    return TRUE;

}  //*** CCreateGroupWizard::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::OnCancel
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Cancel button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCreateGroupWizard::OnCancel(void)
{
    if (BCreated())
    {
        ASSERT_VALID(PciGroup());
        try
        {
            PciGroup()->DeleteGroup();
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
        catch (...)
        {
        }  // catch:  anything
        m_bCreated = FALSE;
    }  // if:  we created the object

}  //*** CCreateGroupWizard::OnCancel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizPage * CCreateGroupWizard::Ppages(void)
{
    return m_rgpages;

}  //*** CCreateGroupWizard::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CCreateGroupWizard::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CWizPage);

}  //*** CCreateGroupWizard::Cpages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::BSetName
//
//  Routine Description:
//      Set the name of the group, creating it if necessary.
//
//  Arguments:
//      rstrName        [IN] Name of the group.
//
//  Return Value:
//      TRUE            Name set successfully.
//      FALSE           Error setting the name.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCreateGroupWizard::BSetName( IN const CString & rstrName )
{
    BOOL        bSuccess = TRUE;
    CWaitCursor wc;

    try
    {
        if ( ! BCreated() )
        {
            // Allocate an item and create the group.
            if ( PciGroup() == NULL )
            {
                m_pciGroup = new CGroup( FALSE );
                if ( m_pciGroup == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating memory
                m_pciGroup->AddRef();
            }  // if:  no group yet
            PciGroup()->Create( Pdoc(), rstrName );
            PciGroup()->ReadItem();
            m_strName = rstrName;
            m_bCreated = TRUE;
        }  // if:  object not created yet
        else
        {
            ASSERT_VALID( PciGroup() );
            PciGroup()->SetName( rstrName );
            m_strName = rstrName;
        }  // else:  object already exists
    }  // try
    catch ( CException * pe )
    {
        pe->ReportError();
        pe->Delete();
        try
        {
            PciGroup()->DeleteGroup();
        }  // try
        catch (...)
        {
        }  // catch:  Anything
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CCreateGroupWizard::BSetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::BSetDescription
//
//  Routine Description:
//      Set the description of the group.
//
//  Arguments:
//      rstrDesc        [IN] Description of the group.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CCreateGroupWizard::BSetDescription(IN const CString & rstrDesc)
{
    BOOL        bSuccess = TRUE;
    CWaitCursor wc;

    try
    {
        ASSERT(BCreated());
        ASSERT_VALID(PciGroup());
        PciGroup()->SetCommonProperties(
                        rstrDesc,
                        PciGroup()->NFailoverThreshold(),
                        PciGroup()->NFailoverPeriod(),
                        PciGroup()->CgaftAutoFailbackType(),
                        PciGroup()->NFailbackWindowStart(),
                        PciGroup()->NFailbackWindowEnd()
                        );
        m_strDescription = rstrDesc;
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CCreateGroupWizard::BSetDescription()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewGroupNamePage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewGroupNamePage, CBaseWizardPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNewGroupNamePage, CBaseWizardPage)
    //{{AFX_MSG_MAP(CNewGroupNamePage)
    ON_EN_CHANGE(IDC_WIZ_GROUP_NAME, OnChangeGroupName)
    ON_EN_KILLFOCUS(IDC_WIZ_GROUP_NAME, OnKillFocusGroupName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::CNewGroupNamePage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewGroupNamePage::CNewGroupNamePage(void)
    : CBaseWizardPage(IDD, g_aHelpIDs_IDD_WIZ_GROUP_NAME)
{
    //{{AFX_DATA_INIT(CNewGroupNamePage)
    m_strName = _T("");
    m_strDesc = _T("");
    //}}AFX_DATA_INIT

}  //*** CNewGroupNamePage::CNewGroupNamePage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewGroupNamePage::DoDataExchange(CDataExchange * pDX)
{
    CBaseWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewGroupNamePage)
    DDX_Control(pDX, IDC_WIZ_GROUP_DESC, m_editDesc);
    DDX_Control(pDX, IDC_WIZ_GROUP_NAME, m_editName);
    DDX_Text(pDX, IDC_WIZ_GROUP_NAME, m_strName);
    DDX_Text(pDX, IDC_WIZ_GROUP_DESC, m_strDesc);
    //}}AFX_DATA_MAP

    DDV_RequiredText(pDX, IDC_WIZ_GROUP_NAME, IDC_WIZ_GROUP_NAME_LABEL, m_strName);

}  //*** CNewGroupNamePage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::BApplyChanges
//
//  Routine Description:
//      Apply changes from this page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Changes applied successfully.
//      FALSE       Error applying changes.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupNamePage::BApplyChanges(void)
{
    CWaitCursor wc;

    ASSERT(Pwiz() != NULL);

    // Get the data from the dialog.
    if (!UpdateData(TRUE /*bSaveAndValidate*/))
        return FALSE;

    // Save the data in the sheet.
    if (!PwizGroup()->BSetName(m_strName)
            || !PwizGroup()->BSetDescription(m_strDesc))
        return FALSE;

    return TRUE;

}  //*** CNewGroupNamePage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupNamePage::OnSetActive(void)
{
    BOOL    bSuccess;

    bSuccess = CBaseWizardPage::OnSetActive();
    if (bSuccess)
    {
        if (m_strName.IsEmpty())
            EnableNext(FALSE);
    }  // if:  successful thus far

    return bSuccess;

}  //*** CNewGroupNamePage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::OnChangeGroupName
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Group Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewGroupNamePage::OnChangeGroupName(void)
{
    if (m_editName.GetWindowTextLength() == 0)
        EnableNext(FALSE);
    else
        EnableNext(TRUE);

}  //*** CNewGroupNamePage::OnChangeGroupName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::OnKillFocusGroupName
//
//  Routine Description:
//      Handler for the WM_KILLFOCUS message on the Group Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewGroupNamePage::OnKillFocusGroupName(void)
{
    CString     strName;

    m_editName.GetWindowText(strName);
    SetObjectTitle(strName);

}  //*** CNewGroupNamePage::OnKillFocusGroupName()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewGroupOwnersPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewGroupOwnersPage, CListCtrlPairWizPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CNewGroupOwnersPage, CListCtrlPairWizPage)
    //{{AFX_MSG_MAP(CNewGroupOwnersPage)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::CNewGroupOwnersPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewGroupOwnersPage::CNewGroupOwnersPage(void)
    : CListCtrlPairWizPage(
            IDD,
            g_aHelpIDs_IDD_WIZ_PREFERRED_OWNERS,
            LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY | LCPS_CAN_BE_ORDERED | LCPS_ORDERED,
            GetColumn,
            BDisplayProperties
            )
{
    //{{AFX_DATA_INIT(CNewGroupOwnersPage)
    //}}AFX_DATA_INIT

}  //*** CNewGroupOwnersPage::CNewGroupOwnersPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewGroupOwnersPage::DoDataExchange(CDataExchange * pDX)
{
    // Initialize the lists before the list pair control is updated.
    if (!pDX->m_bSaveAndValidate)
    {
        if (!BInitLists())
            pDX->Fail();
    }  // if:  setting data to the dialog

    CListCtrlPairWizPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewGroupOwnersPage)
    DDX_Control(pDX, IDC_LCP_NOTE, m_staticNote);
    //}}AFX_DATA_MAP

}  //*** CNewGroupOwnersPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::BInitLists
//
//  Routine Description:
//      Initialize the lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupOwnersPage::BInitLists(void)
{
    BOOL        bSuccess = TRUE;

    ASSERT_VALID(PciGroup());

    try
    {
        SetLists(&PciGroup()->LpcinodePreferredOwners(), &PciGroup()->Pdoc()->LpciNodes());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CNewGroupOwnersPage::BInitLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupOwnersPage::OnInitDialog(void)
{
    // Add columns.
    try
    {
        NAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    // Call the base class method.
    CListCtrlPairWizPage::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNewGroupOwnersPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupOwnersPage::BApplyChanges(void)
{
    BOOL        bSuccess;
    CWaitCursor wc;

    // Set the data from the page in the cluster item.
    try
    {
        PciGroup()->SetPreferredOwners((CNodeList &) Plcp()->LpobjRight());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    bSuccess = CListCtrlPairWizPage::BApplyChanges();
    if (bSuccess)
    {
        POSITION        pos;
        CClusterNode *  pciNode;;

        // If the group is not owned by the first node in the preferred
        // owners list, move the group to the first node.
        pos = Plcp()->LpobjRight().GetHeadPosition();
        if (pos != NULL)
        {
            pciNode = (CClusterNode *) Plcp()->LpobjRight().GetNext(pos);
            if (pciNode->StrName() != PciGroup()->StrOwner())
            {
                try
                {
                    PciGroup()->Move(pciNode);
                }  // try
                catch (CException * pe)
                {
                    pe->ReportError();
                    pe->Delete();
                }  // catch:  CException
            }  // if:  not on first preferred owner node
        }  // if:  there is a preferred owner
    }  // if:  changes applied successfully

    return bSuccess;

}  //*** CNewGroupOwnersPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::GetColumn [static]
//
//  Routine Description:
//      Returns a column for an item.
//
//  Arguments:
//      pobj        [IN OUT] Object for which the column is to be displayed.
//      iItem       [IN] Index of the item in the list.
//      icol        [IN] Column number whose text is to be retrieved.
//      pdlg        [IN OUT] Dialog to which object belongs.
//      rstr        [OUT] String in which to return column text.
//      piimg       [OUT] Image index for the object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CNewGroupOwnersPage::GetColumn(
    IN OUT CObject *    pobj,
    IN int              iItem,
    IN int              icol,
    IN OUT CDialog *    pdlg,
    OUT CString &       rstr,
    OUT int *           piimg
    )
{
    CClusterNode *  pciNode = (CClusterNode *) pobj;
    int             colid;

    ASSERT_VALID(pciNode);
    ASSERT((0 <= icol) && (icol <= 1));

    switch (icol)
    {
        // Sorting by resource name.
        case 0:
            colid = IDS_COLTEXT_NAME;
            break;

        default:
            ASSERT(0);
            colid = IDS_COLTEXT_NAME;
            break;
    }  // switch:  pdlg->NSortColumn()

    pciNode->BGetColumnData(colid, rstr);
    if (piimg != NULL)
        *piimg = pciNode->IimgObjectType();

}  //*** CNewGroupOwnersPage::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::BDisplayProperties [static]
//
//  Routine Description:
//      Display the properties of the specified object.
//
//  Arguments:
//      pobj    [IN OUT] Cluster item whose properties are to be displayed.
//
//  Return Value:
//      TRUE    Properties where accepted.
//      FALSE   Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CNewGroupOwnersPage::BDisplayProperties(IN OUT CObject * pobj)
{
    CClusterItem *  pci = (CClusterItem *) pobj;

    ASSERT_KINDOF(CClusterItem, pobj);

    return pci->BDisplayProperties();

}  //*** CNewGroupOwnersPage::BDisplayProperties();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\guids.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		Guids.cpp
//
//	Abstract:
//		Implements GUIDS for the application.
//
//	Author:
//		David Potter (davidp)	June 4, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#define INC_OLE2

#include "stdafx.h"
#include <initguid.h>
#include "DataObj.h"
#include "CluAdmID.h"

#define IID_DEFINED
#include "CluAdmID_i.c"

CComModule _Module;

#pragma warning( push )
#pragma warning( disable : 4701 ) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\group.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Group.h
//
//	Abstract:
//		Definition of the CGroup class.
//
//	Implementation File:
//		Group.cpp
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GROUP_H_
#define _GROUP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroup;
class CGroupList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterNode;
class CNodeList;
class CResourceList;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_
#include "ClusItem.h"	// for CClusterItem
#endif

#ifndef _RES_H_
#include "Res.h"		// for CResourceList
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroup command target
/////////////////////////////////////////////////////////////////////////////

class CGroup : public CClusterItem
{
	DECLARE_DYNCREATE(CGroup)

// Construction
public:
	CGroup(void);			// protected constructor used by dynamic creation
	CGroup(IN BOOL bDocObj);
	void					Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);
	void					Create(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

protected:
	void					CommonConstruct(void);

// Attributes
protected:
	HGROUP					m_hgroup;
    CLUSTER_GROUP_STATE		m_cgs;
	CString					m_strOwner;
	CClusterNode *			m_pciOwner;
	CResourceList *			m_plpcires;

	DWORD					m_nFailoverThreshold;
	DWORD					m_nFailoverPeriod;
	CGAFT					m_cgaftAutoFailbackType;
	DWORD					m_nFailbackWindowStart;
	DWORD					m_nFailbackWindowEnd;

	CNodeList *				m_plpcinodePreferredOwners;

	enum
	{
		epropName = 0,
		epropDescription,
		epropFailoverThreshold,
		epropFailoverPeriod,
		epropAutoFailbackType,
		epropFailbackWindowStart,
		epropFailbackWindowEnd,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

public:
	HGROUP					Hgroup(void) const				{ return m_hgroup; }
	CLUSTER_GROUP_STATE		Cgs(void) const					{ return m_cgs; }
	const CString &			StrOwner(void) const			{ return m_strOwner; }
	CClusterNode *			PciOwner(void) const			{ return m_pciOwner; }
	const CResourceList &	Lpcires(void) const				{ ASSERT(m_plpcires != NULL); return *m_plpcires; }

	DWORD					NFailoverThreshold(void) const		{ return m_nFailoverThreshold; }
	DWORD					NFailoverPeriod(void) const			{ return m_nFailoverPeriod; }
	CGAFT					CgaftAutoFailbackType(void) const	{ return m_cgaftAutoFailbackType; }
	DWORD					NFailbackWindowStart(void) const	{ return m_nFailbackWindowStart; }
	DWORD					NFailbackWindowEnd(void) const		{ return m_nFailbackWindowEnd; }

	const CNodeList &		LpcinodePreferredOwners(void) const	{ ASSERT(m_plpcinodePreferredOwners != NULL); return *m_plpcinodePreferredOwners; }

	void					GetStateName(OUT CString & rstrState) const;

// Operations
public:
	void					Move(IN const CClusterNode * pciNode);
	void					DeleteGroup(void);
	void					ReadExtensions(void);
	void					SetOwnerState(IN LPCTSTR pszNewOwner);

	void					AddResource(IN OUT CResource * pciResource);
	void					RemoveResource(IN OUT CResource * pciResource);

	void					SetName(IN LPCTSTR pszName);
	void					SetPreferredOwners(IN const CNodeList & rlpci);
	void					SetCommonProperties(
								IN const CString &	rstrDesc,
								IN DWORD			nThreshold,
								IN DWORD			nPeriod,
								IN CGAFT			cgaft,
								IN DWORD			nStart,
								IN DWORD			nEnd,
								IN BOOL				bValidateOnly
								);
	void					SetCommonProperties(
								IN const CString &	rstrDesc,
								IN DWORD			nThreshold,
								IN DWORD			nPeriod,
								IN CGAFT			cgaft,
								IN DWORD			nStart,
								IN DWORD			nEnd
								)
	{
		SetCommonProperties(rstrDesc, nThreshold, nPeriod, cgaft, nStart, nEnd, FALSE /*bValidateOnly*/);
	}
	void					ValidateCommonProperties(
								IN const CString &	rstrDesc,
								IN DWORD			nThreshold,
								IN DWORD			nPeriod,
								IN CGAFT			cgaft,
								IN DWORD			nStart,
								IN DWORD			nEnd
								)
	{
		SetCommonProperties(rstrDesc, nThreshold, nPeriod, cgaft, nStart, nEnd, TRUE /*bValidateOnly*/);
	}

	void					ConstructList(OUT CNodeList & rlpci, IN DWORD dwType);
	void					ConstructList(OUT CResourceList & rlpci, IN DWORD dwType);
	void					ConstructPossibleOwnersList(OUT CNodeList & rlpciNodes);

// Overrides
public:
	virtual void			Cleanup(void);
	virtual	void			ReadItem(void);
	virtual	void			UpdateState(void);
	virtual void			Rename(IN LPCTSTR pszName);
	virtual	BOOL			BGetColumnData(IN COLID colid, OUT CString & rstrText);
	virtual BOOL			BCanBeEdited(void) const;
	virtual BOOL			BDisplayProperties(IN BOOL bReadOnly = FALSE);

	// Drag & Drop
	virtual BOOL			BCanBeDragged(void) const	{ return TRUE; }
	virtual BOOL			BCanBeDropTarget(IN const CClusterItem * pci) const;
	virtual void			DropItem(IN OUT CClusterItem * pci);

	virtual const CStringList *	PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
	virtual void			GetTreeName(OUT CString & rstrName) const;
#endif

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGroup)
	public:
	virtual void OnFinalRelease();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

	virtual LRESULT			OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }
	virtual DWORD					DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
public:
	virtual ~CGroup(void);

public:
	// Generated message map functions
	//{{AFX_MSG(CGroup)
	afx_msg void OnUpdateBringOnline(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTakeOffline(CCmdUI* pCmdUI);
	afx_msg void OnUpdateMoveGroup(CCmdUI* pCmdUI);
	afx_msg void OnUpdateMoveGroupRest(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDelete(CCmdUI* pCmdUI);
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	afx_msg void OnCmdBringOnline();
	afx_msg void OnCmdTakeOffline();
	afx_msg void OnCmdMoveGroup();
	afx_msg void OnCmdDelete();
	//}}AFX_MSG
	afx_msg BOOL OnUpdateMoveGroupItem(CCmdUI* pCmdUI);
	afx_msg BOOL OnUpdateMoveGroupSubMenu(CCmdUI* pCmdUI);
	afx_msg void OnCmdMoveGroup(IN UINT nID);

	DECLARE_MESSAGE_MAP()
#ifdef _CLUADMIN_USE_OLE_
	DECLARE_OLECREATE(CGroup)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CGroup)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
#endif // _CLUADMIN_USE_OLE_

};  //*** class CGroup

/////////////////////////////////////////////////////////////////////////////
// CGroupList
/////////////////////////////////////////////////////////////////////////////

class CGroupList : public CClusterItemList
{
public:
	CGroup *		PciGroupFromName(
						IN LPCTSTR		pszName,
						OUT POSITION *	ppos = NULL
						)
	{
		return (CGroup *) PciFromName(pszName, ppos);
	}

};  //*** class CGroupList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CGroupList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagGroup;
extern CTraceTag g_tagGroupNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _GROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\helparr.h ===
#define IDH_DISABLEHELP ((DWORD)-1)

#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_ABOUTBOX[]=
{
	IDC_ABOUT_ICON, IDH_DISABLEHELP,
	IDC_ABOUT_PRODUCT_TITLE,IDH_ABOUT_PRODUCT_TITLE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_BROWSE_CLUSTERS[]=
{
	IDC_BC_CLUSTER_LABEL, IDH_BC_CLUSTER,
	IDC_BC_CLUSTER,IDH_BC_CLUSTER,
	IDC_BC_LIST,IDH_BC_LIST,
	IDOK, IDH_DISABLEHELP,
	IDCANCEL, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DELETE_RESOURCES[]=
{
	IDC_DR_LABEL_1, IDH_DR_RESOURCES_LIST,
	IDC_DR_RESOURCES_LIST,IDH_DR_RESOURCES_LIST,
	IDC_DR_LABEL_2, IDH_DISABLEHELP,
	IDYES,IDH_YES_DEL_RES,
	IDNO,IDH_NO_DEL_RES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_DEPENDENCIES[]=
{
	IDC_LCP_LEFT_LABEL, IDH_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_LCP_ADD,
	IDC_LCP_REMOVE,IDH_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_LCP_RIGHT_LIST,
	IDOK, IDH_DISABLEHELP,
	IDCANCEL, IDH_DISABLEHELP,
	IDC_LCP_PROPERTIES,IDH_LCP_PROPERTIES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS[]=
{
	IDC_LCP_LEFT_LABEL, IDH_POSSIBLE_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_POSSIBLE_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_POSSIBLE_LCP_ADD,
	IDC_LCP_REMOVE,IDH_POSIBLE_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_POSSIBLE_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_POSSIBLE_LCP_RIGHT_LIST,
	IDOK, IDH_DISABLEHELP,
	IDCANCEL, IDH_DISABLEHELP,
	IDC_LCP_PROPERTIES,IDH_POSSIBLE_LCP_PROPERTIES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS[]=
{
	IDC_LCP_LEFT_LABEL, IDH_PREF_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_PREF_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_POSSIBLE_LCP_ADD,
	IDC_LCP_REMOVE, IDH_POSIBLE_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_PREF_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_PREF_LCP_RIGHT_LIST,
	IDC_LCP_MOVE_UP,IDH_LCP_MOVE_UP,
	IDC_LCP_MOVE_DOWN,IDH_LCP_MOVE_DOWN,
	IDOK, IDH_DISABLEHELP,
	IDCANCEL, IDH_DISABLEHELP,
	IDC_LCP_PROPERTIES,IDH_LCP_PROPERTIES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MOVE_RESOURCES[]=
{
	IDC_MR_LABEL_1, IDH_MR_RESOURCES_LIST,
	IDC_MR_RESOURCES_LIST,IDH_MR_RESOURCES_LIST,
	IDC_MR_LABEL_2, IDH_DISABLEHELP,
	IDYES,IDH_YES_MOVE_RES,
	IDNO,IDH_NO_MOVE_RES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_OPEN_CLUSTER[]=
{
    IDC_OCD_ACTION_LABEL,   IDH_OCD_ACTION,
    IDC_OCD_ACTION,         IDH_OCD_ACTION,
	IDC_OCD_NAME_LABEL,     IDH_OCD_NAME,
	IDC_OCD_NAME,           IDH_OCD_NAME,
	IDC_OCD_BROWSE,         IDH_OCD_BROWSE,
	IDOK,                   IDH_DISABLEHELP,
	IDCANCEL,               IDH_DISABLEHELP,
	0,                      0
};

const DWORD g_aHelpIDs_IDD_PP_CLUSTER_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_CLUS_NAME_LABEL, IDH_PP_CLUS_NAME,
	IDC_PP_CLUS_NAME,IDH_PP_CLUS_NAME,
	IDC_PP_CLUS_DESC_LABEL, IDH_PP_CLUS_DESC,
	IDC_PP_CLUS_DESC,IDH_PP_CLUS_DESC,
	IDC_PP_CLUS_INFO_LINE, IDH_DISABLEHELP,
	IDC_PP_CLUS_VENDOR_ID,IDH_PP_CLUS_VENDOR_ID,
	IDC_PP_CLUS_VERSION,IDH_PP_CLUS_VERSION,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_CLUSTER_NET_PRIORITY[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_CLUS_PRIORITY_LIST_LABEL, IDH_PP_CLUS_PRIORITY_LIST,
	IDC_PP_CLUS_PRIORITY_LIST,IDH_PP_CLUS_PRIORITY_LIST,
	IDC_PP_CLUS_PRIORITY_UP,IDH_PP_CLUS_PRIORITY_UP,
	IDC_PP_CLUS_PRIORITY_DOWN,IDH_PP_CLUS_PRIORITY_DOWN,
	IDC_PP_CLUS_PRIORITY_PROPERTIES,IDH_PP_CLUS_PRIORITY_PROPERTIES,
	IDC_PP_CLUS_PRIORITY_NOTE, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_CLUSTER_QUORUM[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_CLUS_QUORUM_RESOURCE_LABEL, IDH_PP_CLUS_QUORUM_RESOURCE,
	IDC_PP_CLUS_QUORUM_RESOURCE,IDH_PP_CLUS_QUORUM_RESOURCE,
	IDC_PP_CLUS_QUORUM_LOGGING_GROUP,IDH_PP_CLUS_QUORUM_LOGGING_GROUP,
	IDC_PP_CLUS_QUORUM_PARTITION_LABEL, IDH_PP_CLUS_QUORUM_PARTITION,
	IDC_PP_CLUS_QUORUM_PARTITION,IDH_PP_CLUS_QUORUM_PARTITION,
	IDC_PP_CLUS_QUORUM_ROOT_PATH_LABEL, IDH_PP_CLUS_QUORUM_ROOT_PATH,
	IDC_PP_CLUS_QUORUM_ROOT_PATH,IDH_PP_CLUS_QUORUM_ROOT_PATH,
	IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE_LABEL, IDH_PP_CLUS_QUORUM_MAX_LOG_SIZE,
	IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE,IDH_PP_CLUS_QUORUM_MAX_LOG_SIZE,
	IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE_LABEL2, IDH_PP_CLUS_QUORUM_MAX_LOG_SIZE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GROUP_FAILBACK[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_GROUP_AUTOFB_PREVENT,IDH_PP_GROUP_AUTOFB_PREVENT,
	IDC_PP_GROUP_AUTOFB_ALLOW,IDH_PP_GROUP_AUTOFB_ALLOW,
	IDC_PP_GROUP_FB_IMMED,IDH_PP_GROUP_FB_IMMED,
	IDC_PP_GROUP_FB_WINDOW,IDH_PP_GROUP_FB_WINDOW,
	IDC_PP_GROUP_FBWIN_START,IDH_PP_GROUP_FBWIN_START,
	IDC_PP_GROUP_FB_WINDOW_LABEL1, IDH_DISABLEHELP,
	IDC_PP_GROUP_FBWIN_END,IDH_PP_GROUP_FBWIN_END,
	IDC_PP_GROUP_FB_WINDOW_LABEL2, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GROUP_FAILOVER[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_GROUP_FAILOVER_THRESH_LABEL, IDH_PP_GROUP_FAILOVER_THRESH,
	IDC_PP_GROUP_FAILOVER_THRESH,IDH_PP_GROUP_FAILOVER_THRESH,
	IDC_PP_GROUP_FAILOVER_PERIOD_LABEL, IDH_PP_GROUP_FAILOVER_PERIOD,
	IDC_PP_GROUP_FAILOVER_PERIOD,IDH_PP_GROUP_FAILOVER_PERIOD,
	IDC_PP_GROUP_FAILOVER_PERIOD_LABEL2, IDH_PP_GROUP_FAILOVER_PERIOD,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GROUP_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_GROUP_NAME_LABEL, IDH_PP_GROUP_NAME,
	IDC_PP_GROUP_NAME,IDH_PP_GROUP_NAME,
	IDC_PP_GROUP_DESC_LABEL, IDH_PP_GROUP_DESC,
	IDC_PP_GROUP_DESC,IDH_PP_GROUP_DESC,
	IDC_PP_GROUP_PREF_OWNERS_LABEL, IDH_PP_GROUP_PREF_OWNERS,
	IDC_PP_GROUP_PREF_OWNERS,IDH_PP_GROUP_PREF_OWNERS,
	IDC_PP_GROUP_PREF_OWNERS_MODIFY,IDH_PP_GROUP_PREF_OWNERS_MODIFY,
	IDC_PP_GROUP_INFO_LINE, IDH_DISABLEHELP,
	IDC_PP_GROUP_CURRENT_STATE_LABEL, IDH_PP_GROUP_CURRENT_STATE,
	IDC_PP_GROUP_CURRENT_STATE,IDH_PP_GROUP_CURRENT_STATE,
	IDC_PP_GROUP_CURRENT_NODE_LABEL, IDH_PP_GROUP_CURRENT_NODE,
	IDC_PP_GROUP_CURRENT_NODE,IDH_PP_GROUP_CURRENT_NODE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_NET_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_NET_NAME_LABEL, IDH_PP_NET_NAME,
	IDC_PP_NET_NAME,IDH_PP_NET_NAME,
	IDC_PP_NET_DESC_LABEL, IDH_PP_NET_DESC,
	IDC_PP_NET_DESC,IDH_PP_NET_DESC, 
	IDC_PP_NET_ROLE_ENABLE_NETWORK,IDH_PP_NET_ROLE_ENABLE_NETWORK,
	IDC_PP_NET_ROLE_ALL_COMM,IDH_PP_NET_ROLE_ALL_COMM,
	IDC_PP_NET_ROLE_INTERNAL_ONLY,IDH_PP_NET_ROLE_INTERNAL_ONLY,
	IDC_PP_NET_ROLE_CLIENT_ONLY,IDH_PP_NET_ROLE_CLIENT_ONLY,
	IDC_PP_NET_CURRENT_STATE_LABEL, IDH_PP_NET_CURRENT_STATE,
	IDC_PP_NET_CURRENT_STATE,IDH_PP_NET_CURRENT_STATE,
	IDC_PP_NET_ADDRESS_MASK_LABEL, IDH_PP_NET_ADDRESS_MASK,
	IDC_PP_NET_ADDRESS_MASK,IDH_PP_NET_ADDRESS_MASK,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_NETIFACE_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_NETIFACE_NODE_LABEL, IDH_PP_NETIFACE_NODE,
	IDC_PP_NETIFACE_NODE,IDH_PP_NETIFACE_NODE,
	IDC_PP_NETIFACE_NETWORK_LABEL, IDH_PP_NETIFACE_NETWORK,
	IDC_PP_NETIFACE_NETWORK,IDH_PP_NETIFACE_NETWORK,
	IDC_PP_NETIFACE_DESC_LABEL, IDH_PP_NETIFACE_DESC,
	IDC_PP_NETIFACE_DESC,IDH_PP_NETIFACE_DESC,
	IDC_PP_NETIFACE_NAME_LABEL, IDH_PP_NETIFACE_NAME,
	IDC_PP_NETIFACE_NAME,IDH_PP_NETIFACE_NAME,
	IDC_PP_NETIFACE_CURRENT_STATE_LABEL, IDH_PP_NETIFACE_CURRENT_STATE,
	IDC_PP_NETIFACE_CURRENT_STATE,IDH_PP_NETIFACE_CURRENT_STATE,
	IDC_PP_NETIFACE_ADAPTER_LABEL, IDH_PP_NETIFACE_ADAPTER,
	IDC_PP_NETIFACE_ADAPTER,IDH_PP_NETIFACE_ADAPTER,
	IDC_PP_NETIFACE_ADDRESS_LABEL, IDH_PP_NETIFACE_ADDRESS,
	IDC_PP_NETIFACE_ADDRESS,IDH_PP_NETIFACE_ADDRESS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_NODE_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_NODE_NAME_LABEL, IDH_PP_NODE_NAME,
	IDC_PP_NODE_NAME,IDH_PP_NODE_NAME,
	IDC_PP_NODE_DESC_LABEL, IDH_PP_NODE_DESC,
	IDC_PP_NODE_DESC,IDH_PP_NODE_DESC,
	IDC_PP_NODE_CURRENT_STATE_LABEL, IDH_PP_NODE_CURRENT_STATE,
	IDC_PP_NODE_CURRENT_STATE,IDH_PP_NODE_CURRENT_STATE,
	IDC_PP_NODE_CSD_VERSION,IDH_PP_NODE_CSD_VERSION,
	IDC_PP_NODE_VERSION,IDH_PP_NODE_VERSION,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_RES_ADVANCED[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_RES_DONT_RESTART,IDH_PP_RES_DONT_RESTART,
	IDC_PP_RES_RESTART_GROUP, IDH_PP_RES_RESTART,
	IDC_PP_RES_RESTART,IDH_PP_RES_RESTART,
	IDC_PP_RES_AFFECT_THE_GROUP,IDH_PP_RES_AFFECT_THE_GROUP,
	IDC_PP_RES_RESTART_THRESH_LABEL, IDH_PP_RES_RESTART_THRESHOLD,
	IDC_PP_RES_RESTART_THRESHOLD,IDH_PP_RES_RESTART_THRESHOLD,
	IDC_PP_RES_RESTART_PERIOD_LABEL, IDH_PP_RES_RESTART_PERIOD,
	IDC_PP_RES_RESTART_PERIOD,IDH_PP_RES_RESTART_PERIOD,
	IDC_PP_RES_RESTART_PERIOD_LABEL2, IDH_PP_RES_RESTART_PERIOD,
	IDC_PP_RES_LOOKS_ALIVE_GROUP,IDH_PP_RES_LOOKS_ALIVE_GROUP,
	IDC_PP_RES_DEFAULT_LOOKS_ALIVE,IDH_PP_RES_DEFAULT_LOOKS_ALIVE,
	IDC_PP_RES_SPECIFY_LOOKS_ALIVE,IDH_PP_RES_SPECIFY_LOOKS_ALIVE,
	IDC_PP_RES_LOOKS_ALIVE,IDH_PP_RES_LOOKS_ALIVE,
	IDC_PP_RES_SPECIFY_LOOKS_ALIVE_LABEL, IDH_PP_RES_LOOKS_ALIVE,
	IDC_PP_RES_IS_ALIVE_GROUP,IDH_PP_RES_IS_ALIVE_GROUP,
	IDC_PP_RES_DEFAULT_IS_ALIVE,IDH_PP_RES_DEFAULT_IS_ALIVE,	
	IDC_PP_RES_SPECIFY_IS_ALIVE,IDH_PP_RES_SPECIFY_IS_ALIVE,
	IDC_PP_RES_IS_ALIVE,IDH_PP_RES_IS_ALIVE,
	IDC_PP_RES_IS_ALIVE_LABEL, IDH_PP_RES_IS_ALIVE,
	IDC_PP_RES_PENDING_TIMEOUT_LABEL, IDH_PP_RES_PENDING_TIMEOUT,
	IDC_PP_RES_PENDING_TIMEOUT,IDH_PP_RES_PENDING_TIMEOUT,
	IDC_PP_RES_PENDING_TIMEOUT_LABEL2, IDH_PP_RES_PENDING_TIMEOUT,
	0, 0
};


const DWORD g_aHelpIDs_IDD_PP_RES_DEPENDS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_RES_NOTE, IDH_DISABLEHELP,
	IDC_PP_RES_DEPENDS_LIST_LABEL, IDH_PP_RES_DEPENDS_LIST,
	IDC_PP_RES_DEPENDS_LIST,IDH_PP_RES_DEPENDS_LIST,
	IDC_PP_RES_MODIFY,IDH_PP_RES_MODIFY,
	IDC_PP_RES_PROPERTIES,IDH_PP_RES_PROPERTIES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_RES_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_RES_NAME_LABEL, IDH_PP_RES_NAME,
	IDC_PP_RES_NAME,IDH_PP_RES_NAME,
	IDC_PP_RES_DESC_LABEL, IDH_PP_RES_DESC,
	IDC_PP_RES_DESC,IDH_PP_RES_DESC,
	IDC_PP_RES_POSSIBLE_OWNERS_LABEL, IDH_PP_RES_POSSIBLE_OWNERS,
	IDC_PP_RES_POSSIBLE_OWNERS,IDH_PP_RES_POSSIBLE_OWNERS,
	IDC_PP_RES_POSSIBLE_OWNERS_MODIFY,IDH_PP_RES_POSSIBLE_OWNERS_MODIFY,
	IDC_PP_RES_SEPARATE_MONITOR,IDH_PP_RES_SEPARATE_MONITOR,
	IDC_PP_RES_INFO_LINE, IDH_DISABLEHELP,
	IDC_PP_RES_RESOURCE_TYPE_LABEL, IDH_PP_RES_RESOURCE_TYPE,
	IDC_PP_RES_RESOURCE_TYPE,IDH_PP_RES_RESOURCE_TYPE,
	IDC_PP_RES_GROUP_LABEL, IDH_PP_RES_GROUP,
	IDC_PP_RES_GROUP,IDH_PP_RES_GROUP,
	IDC_PP_RES_CURRENT_STATE_LABEL, IDH_PP_RES_CURRENT_STATE,
	IDC_PP_RES_CURRENT_STATE,IDH_PP_RES_CURRENT_STATE,
	IDC_PP_RES_CURRENT_NODE_LABEL, IDH_PP_RES_CURRENT_NODE,
	IDC_PP_RES_CURRENT_NODE,IDH_PP_RES_CURRENT_NODE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_RESTYPE_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_RESTYPE_DISPLAY_NAME_LABEL, IDH_PP_RESTYPE_DISPLAY_NAME,
	IDC_PP_RESTYPE_DISPLAY_NAME,IDH_PP_RESTYPE_DISPLAY_NAME,
	IDC_PP_RESTYPE_DESC_LABEL, IDH_PP_RESTYPE_DESC, 
	IDC_PP_RESTYPE_DESC,IDH_PP_RESTYPE_DESC,
	IDC_PP_RESTYPE_POSSIBLE_OWNERS_LABEL, IDH_PP_RESTYPE_POSSIBLE_OWNERS,
	IDC_PP_RESTYPE_POSSIBLE_OWNERS,IDH_PP_RESTYPE_POSSIBLE_OWNERS,
	IDC_PP_RESTYPE_POLLINT_GROUP,IDH_PP_RESTYPE_POLLINT_GROUP,
	IDC_PP_RESTYPE_LOOKS_ALIVE_LABEL, IDH_PP_RESTYPE_LOOKS_ALIVE,
	IDC_PP_RESTYPE_LOOKS_ALIVE,IDH_PP_RESTYPE_LOOKS_ALIVE,
	IDC_PP_RESTYPE_LOOKS_ALIVE_LABEL2, IDH_PP_RESTYPE_LOOKS_ALIVE,
	IDC_PP_RESTYPE_IS_ALIVE_LABEL, IDH_PP_RESTYPE_IS_ALIVE, 
	IDC_PP_RESTYPE_IS_ALIVE,IDH_PP_RESTYPE_IS_ALIVE,
	IDC_PP_RESTYPE_IS_ALIVE_LABEL2, IDH_PP_RESTYPE_IS_ALIVE,
	IDC_PP_RESTYPE_NAME_LABEL, IDH_PP_RESTYPE_NAME,
	IDC_PP_RESTYPE_NAME,IDH_PP_RESTYPE_NAME,
	IDC_PP_RESTYPE_RESDLL_LABEL, IDH_PP_RESTYPE_RESDLL,
	IDC_PP_RESTYPE_RESDLL,IDH_PP_RESTYPE_RESDLL,
	IDC_PP_RESTYPE_QUORUM_CAPABLE_LABEL, IDH_PP_RESTYPE_QUORUM_CAPABLE,
	IDC_PP_RESTYPE_QUORUM_CAPABLE,IDH_PP_RESTYPE_QUORUM_CAPABLE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_DEPENDENCIES[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_LCP_NOTE, IDH_DISABLEHELP,
	IDC_LCP_LEFT_LABEL, IDH_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_LCP_ADD,
	IDC_LCP_REMOVE,IDH_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_LCP_RIGHT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_GROUP_NAME[]=
{
	IDC_WIZ_GRAPHIC, IDH_DISABLEHELP,
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_WIZ_GROUP_WIZ_DESC, IDH_DISABLEHELP,
	IDC_WIZ_GROUP_NAME_LABEL, IDH_WIZ_GROUP_NAME,
	IDC_WIZ_GROUP_NAME,IDH_WIZ_GROUP_NAME,
	IDC_WIZ_GROUP_DESC_LABEL, IDH_WIZ_GROUP_DESC,
	IDC_WIZ_GROUP_DESC,IDH_WIZ_GROUP_DESC,
	IDC_WIZ_GROUP_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_POSSIBLE_OWNERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_LCP_NOTE, IDH_DISABLEHELP,
	IDC_LCP_LEFT_LABEL, IDH_POSSIBLE_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_POSSIBLE_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_POSSIBLE_LCP_ADD,
	IDC_LCP_REMOVE,IDH_POSIBLE_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_POSSIBLE_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_POSSIBLE_LCP_RIGHT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_PREFERRED_OWNERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_LCP_NOTE, IDH_DISABLEHELP,
	IDC_LCP_LEFT_LABEL, IDH_PREF_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_PREF_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_POSSIBLE_LCP_ADD,
	IDC_LCP_REMOVE, IDH_POSIBLE_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_WIZ_PRE_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_WIZ_PRE_LCP_RIGHT_LIST,
	IDC_LCP_MOVE_UP,IDH_LCP_MOVE_UP,
	IDC_LCP_MOVE_DOWN,IDH_LCP_MOVE_DOWN,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_RESOURCE_NAME[]=
{
	IDC_WIZ_GRAPHIC, IDH_DISABLEHELP,
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_TITLE, IDH_DISABLEHELP,
	IDC_WIZ_RES_NAME_LABEL, IDH_WIZ_RES_NAME,
	IDC_WIZ_RES_NAME,IDH_WIZ_RES_NAME,
	IDC_WIZ_RES_DESC_LABEL, IDH_WIZ_RES_DESC,
	IDC_WIZ_RES_DESC,IDH_WIZ_RES_DESC,
	IDC_WIZ_RES_RESTYPE_LABEL, IDH_WIZ_RES_RESTYPE,
	IDC_WIZ_RES_RESTYPE,IDH_WIZ_RES_RESTYPE,
	IDC_WIZ_RES_GROUP_LABEL, IDH_WIZ_RES_GROUP,
	IDC_WIZ_RES_GROUP,IDH_WIZ_RES_GROUP,
	IDC_WIZ_RES_SEPARATE_MONITOR,IDH_WIZ_RES_SEPARATE_MONITOR,
	IDC_WIZ_RES_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_YESTOALL[]=
{
	IDC_YTA_MESSAGE, IDH_YTA_MESSAGE,
	IDC_YTA_QUESTION, IDH_YTA_MESSAGE,
	IDYES,IDH_YES_YTA,
	IDC_YTA_YESTOALL,IDH_YTA_YESTOALL,
	IDNO,IDH_NO_YTA,
	0, 0
};


#else

extern const DWORD g_aHelpIDs_IDD_ABOUTBOX[];
extern const DWORD g_aHelpIDs_IDD_OPEN_CLUSTER[];
extern const DWORD g_aHelpIDs_IDD_DELETE_RESOURCES[];
extern const DWORD g_aHelpIDs_IDD_MOVE_RESOURCES[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_DEPENDENCIES[];
extern const DWORD g_aHelpIDs_IDD_YESTOALL[];
extern const DWORD g_aHelpIDs_IDD_BROWSE_CLUSTERS[];
extern const DWORD g_aHelpIDs_IDD_PP_CLUSTER_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_CLUSTER_QUORUM[];
extern const DWORD g_aHelpIDs_IDD_PP_CLUSTER_NET_PRIORITY[];
extern const DWORD g_aHelpIDs_IDD_PP_NODE_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_GROUP_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_GROUP_FAILOVER[];
extern const DWORD g_aHelpIDs_IDD_PP_GROUP_FAILBACK[];
extern const DWORD g_aHelpIDs_IDD_PP_RES_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_RES_DEPENDS[];
extern const DWORD g_aHelpIDs_IDD_PP_RES_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_PP_RESTYPE_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_NETIFACE_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_WIZ_GROUP_NAME[];
extern const DWORD g_aHelpIDs_IDD_WIZ_PREFERRED_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_RESOURCE_NAME[];
extern const DWORD g_aHelpIDs_IDD_WIZ_POSSIBLE_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_DEPENDENCIES[];
extern const DWORD g_aHelpIDs_IDD_PP_NET_GENERAL[];

#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\grpwiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		GrpWiz.h
//
//	Abstract:
//		Definition of the CCreateGroupWizard class and all pages specific
//		to a group wizard.
//
//	Implementation File:
//		GrpWiz.cpp
//
//	Author:
//		David Potter (davidp)	July 22, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GRPWIZ_H_
#define _GRPWIZ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEWIZ_H_
#include "BaseWiz.h"	// for CBaseWizard
#endif

#ifndef _BASEWPAG_H_
#include "BaseWPag.h"	// for CBaseWizardPage
#endif

#ifndef _LCPRPAGE_H_
#include "LCPrWPag.h"	// for CListCtrlPairWizPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNewGroupNamePage;
class CCreateGroupWizard;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroup;
class CClusterDoc;

/////////////////////////////////////////////////////////////////////////////
// CNewGroupNamePage property page
/////////////////////////////////////////////////////////////////////////////

class CNewGroupNamePage : public CBaseWizardPage
{
	DECLARE_DYNCREATE(CNewGroupNamePage)

// Construction
public:
	CNewGroupNamePage(void);

// Dialog Data
	//{{AFX_DATA(CNewGroupNamePage)
	enum { IDD = IDD_WIZ_GROUP_NAME };
	CEdit	m_editDesc;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewGroupNamePage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateGroupWizard *	PwizGroup(void) const	{ return (CCreateGroupWizard *) Pwiz(); }

	// Generated message map functions
	//{{AFX_MSG(CNewGroupNamePage)
	afx_msg void OnChangeGroupName();
	afx_msg void OnKillFocusGroupName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewGroupNamePage

/////////////////////////////////////////////////////////////////////////////
// CNewGroupOwnersPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNewGroupOwnersPage : public CListCtrlPairWizPage
{
	DECLARE_DYNCREATE(CNewGroupOwnersPage)

// Construction
public:
	CNewGroupOwnersPage(void);

// Dialog Data
	//{{AFX_DATA(CNewGroupOwnersPage)
	enum { IDD = IDD_WIZ_PREFERRED_OWNERS };
	CStatic	m_staticNote;
	//}}AFX_DATA

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewGroupOwnersPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateGroupWizard *	PwizGroup(void) const	{ return (CCreateGroupWizard *) Pwiz(); }
	CGroup *				PciGroup(void) const;

	BOOL					BInitLists(void);

	// Generated message map functions
	//{{AFX_MSG(CNewGroupOwnersPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewGroupOwnersPage

/////////////////////////////////////////////////////////////////////////////
// CCreateGroupWizard
/////////////////////////////////////////////////////////////////////////////

class CCreateGroupWizard : public CBaseWizard
{
	friend class CNewGroupNamePage;
	friend class CNewGroupOwnersPage;

	DECLARE_DYNAMIC(CCreateGroupWizard)

// Construction
public:
	CCreateGroupWizard(IN OUT CClusterDoc * pdoc, IN OUT CWnd * pParentWnd);
	BOOL				BInit(void);

// Attributes
protected:
	CWizPage			m_rgpages[2];

	CClusterDoc *		m_pdoc;
	CString				m_strName;
	CString				m_strDescription;
	CStringList			m_lstrPreferredOwners;

public:
	CClusterDoc *		Pdoc(void) const				{ return m_pdoc; }
	const CString &		StrName(void) const				{ return m_strName; }
	const CString &		StrDescription(void) const		{ return m_strDescription; }
	const CStringList &	LstrPreferredOwners(void) const	{ return m_lstrPreferredOwners; }

// Operations
public:
	BOOL				BSetName(IN const CString & rstrName);
	BOOL				BSetDescription(IN const CString & rstrDescription);

// Overrides
protected:
	virtual void		OnCancel(void);
	virtual CWizPage *	Ppages(void);
	virtual int			Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateGroupWizard)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCreateGroupWizard(void);

protected:
	CNewGroupNamePage	m_pageName;
	CNewGroupOwnersPage	m_pageOwners;
	CStringList			m_lstrAllNodes;
	CGroup *			m_pciGroup;
	BOOL				m_bCreated;

	const CStringList &	LstrAllNodes(void) const		{ return m_lstrAllNodes; }
	CGroup *			PciGroup(void) const			{ return m_pciGroup; }
	BOOL				BCreated(void) const			{ return m_bCreated; }


	// Generated message map functions
protected:
	//{{AFX_MSG(CCreateGroupWizard)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CCreateGroupWizard

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline CGroup * CNewGroupOwnersPage::PciGroup(void) const
{
	ASSERT_VALID(PwizGroup());
	return PwizGroup()->PciGroup();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _GRPWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\lcprdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      LCPrDlg.cpp
//
//  Abstract:
//      Implementation of the CListCtrlPairDlg dialog template class.
//
//  Author:
//      David Potter (davidp)   August 12, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LCPrDlg.h"
#include "OLCPair.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairDlg
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CListCtrlPairDlg, CBaseDialog)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListCtrlPairDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CListCtrlPairDlg)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::CListCtrlPairDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairDlg::CListCtrlPairDlg(void)
{
    CommonConstruct();

}  //*** CListCtrlPairDlg::CListCtrlPairDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::CListCtrlPairDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      idd             [IN] Resource ID for the dialog template.
//      pdwHelpMap      [IN] Control-to-Help ID mapping array.
//      plpciRight      [IN OUT] List for the right list control.
//      plpciLeft       [IN] List for the left list control.
//      dwStyle         [IN] Style:
//                          LCPS_SHOW_IMAGES    Show images to left of items.
//                          LCPS_ALLOW_EMPTY    Allow right list to be empty.
//                          LCPS_ORDERED        Ordered right list.
//                          LCPS_CAN_BE_ORDERED List can be ordered (hides
//                              Up/Down buttons if LCPS_ORDERED not specified).
//      pfnGetColumn    [IN] Function pointer for getting column data.
//      pfnDisplayProps [IN] Function pointer for displaying properties.
//      pParent         [IN OUT] Parent window.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairDlg::CListCtrlPairDlg(
    IN UINT                     idd,
    IN const DWORD *            pdwHelpMap,
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft,
    IN DWORD                    dwStyle,
    IN PFNLCPGETCOLUMN          pfnGetColumn,
    IN PFNLCPDISPPROPS          pfnDisplayProps,
    IN OUT CWnd *               pParent         //=NULL
    )
    : CBaseDialog(idd, pdwHelpMap, pParent)
{
    ASSERT(pfnGetColumn != NULL);
    ASSERT(pfnDisplayProps != NULL);

    CommonConstruct();

    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;

    m_dwStyle = dwStyle;
    m_pfnGetColumn = pfnGetColumn;
    m_pfnDisplayProps = pfnDisplayProps;

    if (dwStyle & LCPS_ORDERED)
        ASSERT(m_dwStyle & LCPS_CAN_BE_ORDERED);

}  //*** CListCtrlPairDlg::CListCtrlPairDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::CommonConstruct(void)
{
    m_plpobjRight = NULL;
    m_plpobjLeft = NULL;
    m_dwStyle = 0;
    m_pfnGetColumn = NULL;

    m_plcp = NULL;

}  //*** CListCtrlPairDlg::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::~CListCtrlPairDlg
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairDlg::~CListCtrlPairDlg(void)
{
    delete m_plcp;

}  //*** CListCtrlPairDlg::~CListCtrlPairDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NAddColumn
//
//  Routine Description:
//      Add a column to the list of columns displayed in each list control.
//
//  Arguments:
//      idsText     [IN] String resource ID for text to display on column.
//      nWidth      [IN] Initial width of the column.
//
//  Return Value:
//      icol        Index of the column.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CArray::Add.
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPairDlg::NAddColumn(IN IDS idsText, IN int nWidth)
{
    CListCtrlPair::CColumn  col;

    ASSERT(idsText != 0);
    ASSERT(nWidth > 0);
    ASSERT(Plcp() == NULL);

    col.m_idsText = idsText;
    col.m_nWidth = nWidth;

    return (int)m_aColumns.Add(col);

}  //*** CListCtrlPair::NAddColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    Plcp()->DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CListCtrlPairDlg)
    //}}AFX_DATA_MAP

}  //*** CListCtrlPairDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairDlg::OnInitDialog( void )
{
    // Initialize the ListCtrlPair control.
    if ( BCanBeOrdered() )
    {
        m_plcp = new COrderedListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // if: list can be ordered
    else
    {
        m_plcp = new CListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // else: list cannot be ordered
    if ( m_plcp == NULL )
    {
        AfxThrowMemoryException();
    } // if: Error allocating memory

    // Add columns if there are any.
    {
        int     icol;

        for ( icol = 0 ; icol <= m_aColumns.GetUpperBound() ; icol++ )
        {
            Plcp()->NAddColumn( m_aColumns[ icol ].m_idsText, m_aColumns[ icol ].m_nWidth );
        } // for: each column
    }  // Add columns if there are any

    CBaseDialog::OnInitDialog();
    Plcp()->OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CListCtrlPairDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::OnOK
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::OnOK(void)
{
    if (Plcp()->BSaveChanges())
        CBaseDialog::OnOK();

}  //*** CListCtrlPairDlg::OnOK()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairDlg::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL    bHandled;

    ASSERT(Plcp() != NULL);

    bHandled = Plcp()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    if (!bHandled)
        bHandled = CBaseDialog::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    return bHandled;

}  //*** CListCtrlPairDlg::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::OnContextMenu(CWnd * pWnd, CPoint point)
{
    ASSERT(Plcp() != NULL);

    if (!Plcp()->OnContextMenu(pWnd, point))
        CBaseDialog::OnContextMenu(pWnd, point);

}  //*** CListCtrlPairDlg::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair.
//
//  Arguments:
//      plpobjRight     [IN OUT] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::SetLists(
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairDlg::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair where the right list should
//      not be modified.
//
//  Arguments:
//      plpobjRight     [IN] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::SetLists(
    IN const CClusterItemList * plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = (CClusterItemList *) plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    m_dwStyle |= LCPS_DONT_OUTPUT_RIGHT_LIST;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairDlg::SetLists()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\lcpair.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      LCPair.cpp
//
//  Abstract:
//      Implementation of the CListCtrlPair class.
//
//  Author:
//      David Potter (davidp)   August 8, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "LCPair.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPair
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CListCtrlPair, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListCtrlPair, CCmdTarget)
    //{{AFX_MSG_MAP(CListCtrlPair)
    //}}AFX_MSG_MAP
    ON_BN_CLICKED(IDC_LCP_ADD, OnAdd)
    ON_BN_CLICKED(IDC_LCP_REMOVE, OnRemove)
    ON_BN_CLICKED(IDC_LCP_PROPERTIES, OnProperties)
    ON_NOTIFY(NM_DBLCLK, IDC_LCP_LEFT_LIST, OnDblClkLeftList)
    ON_NOTIFY(NM_DBLCLK, IDC_LCP_RIGHT_LIST, OnDblClkRightList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LCP_LEFT_LIST, OnItemChangedLeftList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LCP_RIGHT_LIST, OnItemChangedRightList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_LCP_LEFT_LIST, OnColumnClickLeftList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_LCP_RIGHT_LIST, OnColumnClickRightList)
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CListCtrlPair
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPair::CListCtrlPair(void)
{
    CommonConstruct();

}  //*** CListCtrlPair::CListCtrlPair()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CListCtrlPair
//
//  Routine Description:
//      Cconstructor.
//
//  Arguments:
//      pdlg            [IN OUT] Dialog to which controls belong.
//      plpobjRight     [IN OUT] List for the right list control.
//      plpobjLeft      [IN] List for the left list control.
//      dwStyle         [IN] Style:
//                          LCPS_SHOW_IMAGES    Show images to left of items.
//                          LCPS_ALLOW_EMPTY    Allow right list to be empty.
//      pfnGetColumn    [IN] Function pointer for retrieving columns.
//      pfnDisplayProps [IN] Function pointer for displaying properties.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPair::CListCtrlPair(
    IN OUT CDialog *            pdlg,
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft,
    IN DWORD                    dwStyle,
    IN PFNLCPGETCOLUMN          pfnGetColumn,
    IN PFNLCPDISPPROPS          pfnDisplayProps
    )
{
    ASSERT(pfnGetColumn != NULL);
    ASSERT(pfnDisplayProps != NULL);

    CommonConstruct();

    m_pdlg = pdlg;

    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;

    m_dwStyle = dwStyle;

    m_pfnGetColumn = pfnGetColumn;
    m_pfnDisplayProps = pfnDisplayProps;

}  //*** CListCtrlPair::CListCtrlPair()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::CommonConstruct(void)
{
    m_pdlg = NULL;
    m_plpobjLeft = NULL;
    m_plpobjRight = NULL;
    m_dwStyle = LCPS_ALLOW_EMPTY;
    m_pfnGetColumn = NULL;
    m_plcFocusList = NULL;

    // Set the sort info.
    SiLeft().m_nDirection = -1;
    SiLeft().m_nColumn = -1;
    SiRight().m_nDirection = -1;
    SiRight().m_nColumn = -1;

}  //*** CListCtrlPair::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NAddColumn
//
//  Routine Description:
//      Add a column to the list of columns displayed in each list control.
//
//  Arguments:
//      idsText     [IN] String resource ID for text to display on column.
//      nWidth      [IN] Initial width of the column.
//
//  Return Value:
//      icol        Index of the column.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CArray::Add.
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPair::NAddColumn(IN IDS idsText, IN int nWidth)
{
    CColumn     col;

    ASSERT(idsText != 0);
    ASSERT(nWidth > 0);
    ASSERT(LpobjRight().GetCount() == 0);

    col.m_idsText = idsText;
    col.m_nWidth = nWidth;

    return (int)m_aColumns.Add(col);

}  //*** CListCtrlPair::NAddColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::DoDataExchange(CDataExchange * pDX)
{
    DDX_Control(pDX, IDC_LCP_RIGHT_LIST, m_lcRight);
    DDX_Control(pDX, IDC_LCP_LEFT_LIST, m_lcLeft);
    DDX_Control(pDX, IDC_LCP_ADD, m_pbAdd);
    DDX_Control(pDX, IDC_LCP_REMOVE, m_pbRemove);
    if (BPropertiesButton())
        DDX_Control(pDX, IDC_LCP_PROPERTIES, m_pbProperties);

    if (pDX->m_bSaveAndValidate)
    {
        // Verify that the list is not empty.
        if (!BAllowEmpty() && (m_lcRight.GetItemCount() == 0))
        {
            CString     strMsg;
            CString     strLabel;
            TCHAR *     pszLabel;
            TCHAR       szStrippedLabel[1024];
            int         iSrc;
            int         iDst;
            TCHAR       ch;

            DDX_Text(pDX, IDC_LCP_RIGHT_LABEL, strLabel);

            // Remove ampersands (&) and colons (:).
            pszLabel = strLabel.GetBuffer(1);
            for (iSrc = 0, iDst = 0 ; pszLabel[iSrc] != _T('\0') ; iSrc++)
            {
                ch = pszLabel[iSrc];
                if ((ch != _T('&')) && (ch != _T(':')))
                    szStrippedLabel[iDst++] = ch;
            }  // for:  each character in the label
            szStrippedLabel[iDst] = _T('\0');

            strMsg.FormatMessage(IDS_EMPTY_RIGHT_LIST, szStrippedLabel);
            ::AfxMessageBox(strMsg, MB_OK | MB_ICONWARNING);

            strMsg.Empty();
            pDX->Fail();
        }  // if:  list is empty and isn't allowed to be
    }  // if:  saving data from the dialog
    else
    {
        // Fill the lists.
        if (m_plpobjRight != NULL)
            FillList(m_lcRight, LpobjRight());
        if (m_plpobjLeft != NULL)
            FillList(m_lcLeft, LpobjLeft());
    }  // else:  setting data to the dialog

}  //*** CListCtrlPair::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPair::OnInitDialog(void)
{
    ASSERT_VALID(Pdlg());
    ASSERT(PlpobjRight() != NULL);
    ASSERT(PlpobjLeft() != NULL);

    Pdlg()->UpdateData(FALSE /*bSaveAndValidate*/);

    if (BShowImages())
    {
        CClusterAdminApp *  papp    = GetClusterAdminApp();

        m_lcLeft.SetImageList(papp->PilSmallImages(), LVSIL_SMALL);
        m_lcRight.SetImageList(papp->PilSmallImages(), LVSIL_SMALL);
    }  // if:  showing images
    
    // Disable buttons by default.
    m_pbAdd.EnableWindow(FALSE);
    m_pbRemove.EnableWindow(FALSE);
    if (BPropertiesButton())
        m_pbProperties.EnableWindow(FALSE);

    // Set the right list to sort.  Set both to show selection always.
    m_lcRight.ModifyStyle(0, LVS_SHOWSELALWAYS | LVS_SORTASCENDING, 0);
    m_lcLeft.ModifyStyle(0, LVS_SHOWSELALWAYS, 0);

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        // Left control.
        dwExtendedStyle = (DWORD)m_lcLeft.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcLeft.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );

        // Right control.
        dwExtendedStyle = (DWORD)m_lcRight.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcRight.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    try
    {
        // Duplicate lists.
        DuplicateLists();

        // Insert all the columns.
        {
            int         icol;
            int         ncol;
            int         nUpperBound = (int)m_aColumns.GetUpperBound();
            CString     strColText;

            ASSERT(nUpperBound >= 0);

            for (icol = 0 ; icol <= nUpperBound ; icol++)
            {
                strColText.LoadString(m_aColumns[icol].m_idsText);
                ncol = m_lcLeft.InsertColumn(icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0);
                ASSERT(ncol == icol);
                ncol = m_lcRight.InsertColumn(icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0);
                ASSERT(ncol == icol);
            }  // for:  each column
        }  // Insert all the columns
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

    Pdlg()->UpdateData(FALSE /*bSaveAndValidate*/);

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_lcRight.EnableWindow(FALSE);
        m_lcLeft.EnableWindow(FALSE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CListCtrlPair::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPair::OnSetActive(void)
{
    UINT    nSelCount;

    // Set the focus to the left list.
    m_lcLeft.SetFocus();
    m_plcFocusList = &m_lcLeft;

    // Enable/disable the Properties button.
    nSelCount = m_lcLeft.GetSelectedCount();
    if (BPropertiesButton())
        m_pbProperties.EnableWindow(nSelCount == 1);

    // Enable or disable the other buttons.
    if (!BReadOnly())
    {
        m_pbAdd.EnableWindow(nSelCount > 0);
        nSelCount = m_lcRight.GetSelectedCount();
        m_pbRemove.EnableWindow(nSelCount > 0);
    }  // if:  not read-only page

    return TRUE;

}  //*** CListCtrlPair::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::BSaveChanges
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Changes saved successfully.
//      FALSE       Error saving changes.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPair::BSaveChanges(void)
{
    POSITION        pos;
    CClusterItem *  pci;

    ASSERT(!BIsStyleSet(LCPS_DONT_OUTPUT_RIGHT_LIST));
    ASSERT(!BReadOnly());

    // Update the data first.
    if (!Pdlg()->UpdateData(TRUE /*bSaveAndValidate*/))
        return FALSE;

    // Copy the Nodes list.
    PlpobjRight()->RemoveAll();
    pos = LpobjRight().GetHeadPosition();
    while (pos != NULL)
    {
        pci = LpobjRight().GetNext(pos);
        ASSERT_VALID(pci);
        VERIFY(PlpobjRight()->AddTail(pci) != NULL);
    }  // while:  more items in the list

    return TRUE;

}  //*** CListCtrlPair::BSaveChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnAdd
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Add button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnAdd(void)
{
    ASSERT(!BReadOnly());

    // Move selected items from the left list to the right list.
    MoveItems(m_lcRight, LpobjRight(), m_lcLeft, LpobjLeft());

}  //*** CListCtrlPair::OnAdd()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnRemove
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Remove button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnRemove(void)
{
    ASSERT(!BReadOnly());

    // Move selected items from the right list to the left list.
    MoveItems(m_lcLeft, LpobjLeft(), m_lcRight, LpobjRight());

}  //*** CListCtrlPair::OnRemove()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnProperties(void)
{
    int         iitem;
    CObject *   pobj;

    ASSERT(m_plcFocusList != NULL);
    ASSERT(m_pfnDisplayProps != NULL);

    // Get the index of the item with the focus.
    iitem = m_plcFocusList->GetNextItem(-1, LVNI_FOCUSED);
    ASSERT(iitem != -1);

    // Get a pointer to the selected item.
    pobj = (CObject *) m_plcFocusList->GetItemData(iitem);
    ASSERT_VALID(pobj);

    if ((*m_pfnDisplayProps)(pobj))
    {
        // Update this item.
        {
            CString     strText;
            int         iimg;
            int         icol;

            ASSERT(m_pfnGetColumn != NULL);
            ASSERT(Pdlg() != NULL);
            (*m_pfnGetColumn)(pobj, iitem, 0, Pdlg(), strText, &iimg);
            m_plcFocusList->SetItem(iitem, 0, LVIF_TEXT | LVIF_IMAGE, strText, iimg, 0, 0, 0);

            for (icol = 1 ; icol <= m_aColumns.GetUpperBound() ; icol++)
            {
                (*m_pfnGetColumn)(pobj, iitem, icol, Pdlg(), strText, NULL);
                m_plcFocusList->SetItemText(iitem, icol, strText);
            }  // for:  each column
        }  // Update this item
    }  // if:  properties changed

}  //*** CListCtrlPair::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPair::OnContextMenu(CWnd * pWnd, CPoint point)
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListCtrl *     pListCtrl   = (CListCtrl *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list control, don't handle the message.
    if ( ( pWnd != &m_lcRight ) && ( pWnd != &m_lcLeft ) )
    {
        return FALSE;
    } // if: focus not in list control

    // Create the menu to display.
    try
    {
        pmenu = new CMenu;
        if ( pmenu == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the memory

        if ( pmenu->CreatePopupMenu() )
        {
            UINT    nFlags  = MF_STRING;

            // If there are no items in the list, disable the menu item.
            if ( pListCtrl->GetItemCount() == 0 )
            {
                nFlags |= MF_GRAYED;
            } // if: no items in the list

            // Add the Properties item to the menu.
            strMenuName.LoadString( IDS_MENU_PROPERTIES );
            if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
            {
                m_plcFocusList = pListCtrl;
                bHandled = TRUE;
            }  // if:  successfully added menu item
        }  // if:  menu created successfully
    }  // try
    catch ( CException * pe )
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    if ( bHandled )
    {
        // Display the menu.
        if ( ! pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        Pdlg()
                        ) )
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display

    delete pmenu;
    return bHandled;

}  //*** CListCtrlPair::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnDblClkLeftList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message for the left list.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnDblClkLeftList(NMHDR * pNMHDR, LRESULT * pResult)
{
    ASSERT(!BReadOnly());

    m_plcFocusList = &m_lcLeft;
    OnAdd();
    *pResult = 0;

}  //*** CListCtrlPair::OnDblClkLeftList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnDblClkRightList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message for the right list.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnDblClkRightList(NMHDR * pNMHDR, LRESULT * pResult)
{
    ASSERT(!BReadOnly());

    m_plcFocusList = &m_lcRight;
    OnRemove();
    *pResult = 0;

}  //*** CListCtrlPair::OnDblClkRightList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnItemChangedLeftList
//
//  Routine Description:
//      Handler method for the LVN_ITEMCHANGED message in the left list.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnItemChangedLeftList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    m_plcFocusList = &m_lcLeft;

    // If the selection changed, enable/disable the Add button.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                    || (pNMListView->uNewState & LVIS_SELECTED))
            && !BReadOnly())
    {
        UINT    cSelected = m_plcFocusList->GetSelectedCount();

        // If there is a selection, enable the Add button.  Otherwise disable it.
        m_pbAdd.EnableWindow((cSelected == 0) ? FALSE : TRUE);
        if (BPropertiesButton())
            m_pbProperties.EnableWindow((cSelected == 1) ? TRUE : FALSE);
    }  // if:  selection changed

    *pResult = 0;

}  //*** CListCtrlPair::OnItemChangedLeftList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnItemChangedRightList
//
//  Routine Description:
//      Handler method for the LVN_ITEMCHANGED message in the right list.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnItemChangedRightList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;

    m_plcFocusList = &m_lcRight;

    // If the selection changed, enable/disable the Remove button.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                    || (pNMListView->uNewState & LVIS_SELECTED))
            && !BReadOnly())
    {
        UINT    cSelected = m_plcFocusList->GetSelectedCount();

        // If there is a selection, enable the Remove button.  Otherwise disable it.
        m_pbRemove.EnableWindow((cSelected == 0) ? FALSE : TRUE);
        if (BPropertiesButton())
            m_pbProperties.EnableWindow((cSelected == 1) ? TRUE : FALSE);
    }  // if:  selection changed

    *pResult = 0;

}  //*** CListCtrlPair::OnItemChangedRightList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnColumnClickLeftList
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message on the left list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnColumnClickLeftList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;

    ASSERT(m_pfnGetColumn != NULL);

    m_plcFocusList = &m_lcLeft;

    // Save the current sort column and direction.
    if (pNMListView->iSubItem == SiLeft().m_nColumn)
        SiLeft().m_nDirection ^= -1;
    else
    {
        SiLeft().m_nColumn = pNMListView->iSubItem;
        SiLeft().m_nDirection = 0;
    }  // else:  different column

    // Sort the list.
    m_psiCur = &SiLeft();
    VERIFY(m_lcLeft.SortItems(CompareItems, (LPARAM) this));

    *pResult = 0;

}  //*** CListCtrlPair::OnColumnClickLeftList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnColumnClickRightList
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message on the right list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnColumnClickRightList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;

    ASSERT(m_pfnGetColumn != NULL);

    m_plcFocusList = &m_lcRight;

    // Save the current sort column and direction.
    if (pNMListView->iSubItem == SiRight().m_nColumn)
        SiRight().m_nDirection ^= -1;
    else
    {
        SiRight().m_nColumn = pNMListView->iSubItem;
        SiRight().m_nDirection = 0;
    }  // else:  different column

    // Sort the list.
    m_psiCur = &SiRight();
    VERIFY(m_lcRight.SortItems(CompareItems, (LPARAM) this));

    *pResult = 0;

}  //*** CListCtrlPair::OnColumnClickRightList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CListCtrlPair::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CObject *           pobj1   = (CObject *) lparam1;
    CObject *           pobj2   = (CObject *) lparam2;
    CListCtrlPair *     plcp    = (CListCtrlPair *) lparamSort;
    int                 icol    = plcp->PsiCur()->m_nColumn;
    int                 nResult;
    CString             str1;
    CString             str2;

    ASSERT_VALID(pobj1);
    ASSERT_VALID(pobj2);
    ASSERT(plcp != NULL);
    ASSERT(plcp->PsiCur()->m_nColumn >= 0);
    ASSERT(icol >= 0);

    (*plcp->m_pfnGetColumn)(pobj1, 0, icol, plcp->Pdlg(), str1, NULL);
    (*plcp->m_pfnGetColumn)(pobj2, 0, icol, plcp->Pdlg(), str2, NULL);

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                str1,
                str1.GetLength(),
                str2,
                str2.GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (plcp->PsiCur()->m_nDirection != 0)
        nResult = -nResult;

    return nResult;

}  //*** CListCtrlPair::CompareItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair.
//
//  Arguments:
//      plpobjRight     [IN OUT] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::SetLists(
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;

    DuplicateLists();

}  //*** CListCtrlPair::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair where the right list should
//      not be modified.
//
//  Arguments:
//      plpobjRight     [IN] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::SetLists(
    IN const CClusterItemList * plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    m_dwStyle |= LCPS_DONT_OUTPUT_RIGHT_LIST;
    SetLists((CClusterItemList *) plpobjRight, plpobjLeft);

}  //*** CListCtrlPair::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::DuplicateLists
//
//  Routine Description:
//      Duplicate the lists so that we have local copies.
//
//  Arguments:
//      rlc         [IN OUT] List control to fill.
//      rlpobj      [IN] List to use to fill the control.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::DuplicateLists(void)
{
    LpobjRight().RemoveAll();
    LpobjLeft().RemoveAll();

    if ((PlpobjRight() == NULL) || (PlpobjLeft() == NULL))
        return;

    // Duplicate the right list.
    {
        POSITION        pos;
        CClusterItem *  pci;

        pos = PlpobjRight()->GetHeadPosition();
        while (pos != NULL)
        {
            // Get the item pointer.
            pci = PlpobjRight()->GetNext(pos);
            ASSERT_VALID(pci);

            // Add it to our list.
            LpobjRight().AddTail(pci);
        }  // while:  more items in the list
    }  // Duplicate the right list

    // Duplicate the left list.
    {
        POSITION        pos;
        CClusterItem *  pci;

        pos = PlpobjLeft()->GetHeadPosition();
        while (pos != NULL)
        {
            // Get the item pointer.
            pci = PlpobjLeft()->GetNext(pos);
            ASSERT_VALID(pci);

            // If the item is not already in the other list,
            // add it to the left list.
            if (LpobjRight().Find(pci) == NULL)
                LpobjLeft().AddTail(pci);
        }  // while:  more items in the list
    }  // Duplicate the left list

}  //*** CListCtrlPair::DuplicateLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::FillList
//
//  Routine Description:
//      Fill a list control.
//
//  Arguments:
//      rlc         [IN OUT] List control to fill.
//      rlpobj      [IN] List to use to fill the control.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::FillList(
    IN OUT CListCtrl &          rlc,
    IN const CClusterItemList & rlpobj
    )
{
    POSITION    pos;
    CObject *   pobj;
    int         iItem;

    // Initialize the control.
    VERIFY(rlc.DeleteAllItems());

    rlc.SetItemCount((int)rlpobj.GetCount());

    // Add the items to the list.
    pos = rlpobj.GetHeadPosition();
    for (iItem = 0 ; pos != NULL ; iItem++)
    {
        pobj = rlpobj.GetNext(pos);
        ASSERT_VALID(pobj);
        NInsertItemInListCtrl(iItem, pobj, rlc);
    }  // for:  each string in the list

    // If there are any items, set the focus on the first one.
    if (rlc.GetItemCount() != 0)
        rlc.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);

}  //*** CListCtrlPair::FillList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NInsertItemInListCtrl
//
//  Routine Description:
//      Insert an item in a list control.
//
//  Arguments:
//      iitem       [IN] Index of the item in the list.
//      pobj        [IN OUT] Item to add.
//      rlc         [IN OUT] List control in which to insert the item.
//
//  Return Value:
//      iRetItem    Index of the new item in the list control.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPair::NInsertItemInListCtrl(
    IN int              iitem,
    IN OUT CObject *    pobj,
    IN OUT CListCtrl &  rlc
    )
{
    int         iRetItem;
    CString     strText;
    int         iimg;
    int         icol;

    ASSERT(m_pfnGetColumn != NULL);
    ASSERT(Pdlg() != NULL);

    // Insert the first column.
    (*m_pfnGetColumn)(pobj, iitem, 0, Pdlg(), strText, &iimg);
    iRetItem = rlc.InsertItem(
                    LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM,    // nMask
                    iitem,                                  // nItem
                    strText,                                // lpszItem
                    0,                                      // nState
                    0,                                      // nStateMask
                    iimg,                                   // nImage
                    (LPARAM) pobj                           // lParam
                    );
    ASSERT(iRetItem != -1);

    for (icol = 1 ; icol <= m_aColumns.GetUpperBound() ; icol++)
    {
        (*m_pfnGetColumn)(pobj, iRetItem, icol, Pdlg(), strText, NULL);
        rlc.SetItemText(iRetItem, icol, strText);
    }  // for:  each column

    return iRetItem;

}  //*** CListCtrlPair::NInsertItemInListCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::MoveItems
//
//  Routine Description:
//      Move an item from one list to the other.
//
//  Arguments:
//      rlcDst      [IN OUT] Destination list control.
//      rlpobjDst   [IN OUT] Destination list.
//      rlcSrc      [IN OUT] Source list control.
//      rlpobjSrc   [IN OUT] Source list.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::MoveItems(
    IN OUT CListCtrl &          rlcDst,
    IN OUT CClusterItemList &   rlpobjDst,
    IN OUT CListCtrl &          rlcSrc,
    IN OUT CClusterItemList &   rlpobjSrc
    )
{
    int             iSrcItem;
    int             iDstItem;
    int             nItem   = -1;
    CClusterItem *  pci;
    POSITION        pos;

    ASSERT(!BReadOnly());

    iDstItem = rlcDst.GetItemCount();
    while ((iSrcItem = rlcSrc.GetNextItem(-1, LVNI_SELECTED)) != -1)
    {
        // Get the item pointer.
        pci = (CClusterItem *) rlcSrc.GetItemData(iSrcItem);
        ASSERT_VALID(pci);

        // Remove the item from the source list.
        pos = rlpobjSrc.Find(pci);
        ASSERT(pos != NULL);
        rlpobjSrc.RemoveAt(pos);

        // Add the item to the destination list.
        rlpobjDst.AddTail(pci);

        // Remove the item from the source list control and
        // add it to the destination list control.
        VERIFY(rlcSrc.DeleteItem(iSrcItem));
        nItem = NInsertItemInListCtrl(iDstItem++, pci, rlcDst);
        rlcDst.SetItemState(
            nItem,
            LVIS_SELECTED | LVIS_FOCUSED,
            LVIS_SELECTED | LVIS_FOCUSED
            );
    }  // while:  more items

    ASSERT(nItem != -1);

    rlcDst.EnsureVisible(nItem, FALSE /*bPartialOK*/);
    rlcDst.SetFocus();

    // Indicate that the data has changed.
    Pdlg()->GetParent()->SendMessage(PSM_CHANGED, (WPARAM)Pdlg()->m_hWnd);

}  //*** CListCtrlPair::MoveItems()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\lcpair.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		LCPair.h
//
//	Abstract:
//		Definition of the CListCtrlPair dialog.
//
//	Implementation File:
//		LCPair.cpp
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPAIR_H_
#define _LCPAIR_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItemList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPair;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef void (*PFNLCPGETCOLUMN)(
				IN OUT CObject *	pobj,
				IN int				iItem,
				IN int				icol,
				IN OUT CDialog *	pdlg,
				OUT CString &		rstr,
				OUT int *			piimg
				);
typedef int (*PFNLCPDISPPROPS)(
				IN OUT CObject *	pobj
				);

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPair command target
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPair : public CCmdTarget
{
	DECLARE_DYNAMIC(CListCtrlPair)
	friend class CListCtrlPairDlg;
	friend class CListCtrlPairPage;
	friend class CListCtrlPairWizPage;

// Construction
public:
	CListCtrlPair(void);		// protected constructor used by dynamic creation
	CListCtrlPair(
		IN OUT CDialog *			pdlg,
		IN OUT CClusterItemList *	rlpobjRight,
		IN const CClusterItemList *	rlpobjLeft,
		IN DWORD					dwStyle,
		IN PFNLCPGETCOLUMN			pfnGetColumn,
		IN PFNLCPDISPPROPS			pfnDisplayProps
		);

	void CommonConstruct(void);

// Attributes
protected:
	CDialog *					m_pdlg;
	CClusterItemList *			m_plpobjRight;
	const CClusterItemList *	m_plpobjLeft;
	IDS							m_idsRightLabel;
	IDS							m_idsLeftLabel;
	DWORD						m_dwStyle;

#define LCPS_SHOW_IMAGES			0x1
#define LCPS_ALLOW_EMPTY			0x2
#define LCPS_CAN_BE_ORDERED			0x4
#define LCPS_ORDERED				0x8
#define LCPS_DONT_OUTPUT_RIGHT_LIST	0x10
#define LCPS_READ_ONLY				0x20
#define LCPS_PROPERTIES_BUTTON		0x40
#define LCPS_MAX					0x40

	PFNLCPGETCOLUMN	m_pfnGetColumn;
	PFNLCPDISPPROPS	m_pfnDisplayProps;

	BOOL			BIsStyleSet(IN DWORD dwStyle) const	{ return (m_dwStyle & dwStyle) == dwStyle; }
	void			ModifyStyle(IN DWORD dwRemove, IN DWORD dwAdd)
	{
		ASSERT((dwRemove & dwAdd) == 0);
		if (dwRemove != 0)
			m_dwStyle &= ~dwRemove;
		if (dwAdd != 0)
			m_dwStyle |= dwAdd;
	}

public:
	CDialog *		Pdlg(void) const				{ return m_pdlg; }
	CClusterItemList *			PlpobjRight(void) const			{ return m_plpobjRight; }
	const CClusterItemList *	PlpobjLeft(void) const			{ return m_plpobjLeft; }
	IDS				IdsRightLabel(void) const		{ return m_idsRightLabel; }
	IDS				IdsLeftLabel(void) const		{ return m_idsLeftLabel; }
	DWORD			DwStyle(void) const				{ return m_dwStyle; }
	BOOL			BShowImages(void) const			{ return BIsStyleSet(LCPS_SHOW_IMAGES); }
	BOOL			BAllowEmpty(void) const			{ return BIsStyleSet(LCPS_ALLOW_EMPTY); }
	BOOL			BCanBeOrdered(void) const		{ return BIsStyleSet(LCPS_CAN_BE_ORDERED); }
	BOOL			BOrdered(void) const			{ return BIsStyleSet(LCPS_ORDERED); }
	BOOL			BReadOnly(void) const			{ return BIsStyleSet(LCPS_READ_ONLY); }
	BOOL			BPropertiesButton(void) const	{ return BIsStyleSet(LCPS_PROPERTIES_BUTTON); }

	void			SetDlg(CDialog * pdlg)		{ ASSERT_VALID(pdlg); m_pdlg = pdlg; }

	void			SetLists(IN OUT CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);
	void			SetLists(IN const CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);

// Operations
public:
	int				NAddColumn(IN IDS idsText, IN int nWidth);
	int				NInsertItemInListCtrl(
								IN int				iitem,
								IN OUT CObject *	pobj,
								IN OUT CListCtrl &	rlc
								);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCtrlPair)
	//}}AFX_VIRTUAL
	virtual BOOL	OnSetActive(void);
	virtual void	DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	CClusterItemList	m_lpobjRight;
	CClusterItemList	m_lpobjLeft;
	CListCtrl			m_lcRight;
	CListCtrl			m_lcLeft;
	CListCtrl *			m_plcFocusList;
	CButton				m_pbAdd;
	CButton				m_pbRemove;
	CButton				m_pbProperties;

public:
	CClusterItemList &	LpobjRight(void)		{ return m_lpobjRight; }
	CClusterItemList &	LpobjLeft(void)			{ return m_lpobjLeft; }

protected:
	void			DuplicateLists(void);
	void			FillList(IN OUT CListCtrl & rlc, IN const CClusterItemList & rlpobj);
	void			MoveItems(
						IN OUT CListCtrl &			rlcDst,
						IN OUT CClusterItemList &	rlpobjDst,
						IN OUT CListCtrl &			rlcSrc,
						IN OUT CClusterItemList &	rlpobjSrc
						);

	// Column structure and collection.
	struct CColumn
	{
		IDS			m_idsText;
		int			m_nWidth;
	};
	typedef CArray<CColumn, CColumn&> CColumnArray;
	CColumnArray	m_aColumns;

	// Sort information.
	struct SortInfo
	{
		int		m_nDirection;
		int		m_nColumn;
	};
	
	static int CALLBACK		CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);

	SortInfo				m_siLeft;
	SortInfo				m_siRight;
	SortInfo *				m_psiCur;

	SortInfo &				SiLeft(void)		{ return m_siLeft; }
	SortInfo &				SiRight(void)		{ return m_siRight; }
	SortInfo *				PsiCur(void) const	{ return m_psiCur; }

	// Generated message map functions
	//{{AFX_MSG(CListCtrlPair)
	//}}AFX_MSG
public:
	virtual BOOL OnInitDialog(void);
	virtual BOOL BSaveChanges(void);
protected:
	afx_msg BOOL OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnAdd(void);
	afx_msg void OnRemove(void);
	afx_msg void OnProperties(void);
	afx_msg void OnDblClkLeftList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblClkRightList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemChangedLeftList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemChangedRightList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickLeftList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickRightList(NMHDR* pNMHDR, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()

};  //*** class CListCtrlPair

/////////////////////////////////////////////////////////////////////////////

#endif // _LCPAIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\lcprdlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		LCPrDlg.h
//
//	Abstract:
//		Definition of the CListCtrlPairDlg dialog class.
//
//	Implementation File:
//		LCPrDlg.cpp
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPRDLG_H_
#define _LCPRDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

#ifndef _LCPAIR_H_
#include "LCPair.h"		// for PFNLCPGETCOLUMN, CListCtrlPair
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairDlg;

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairDlg : public CBaseDialog
{
	DECLARE_DYNCREATE(CListCtrlPairDlg)

// Construction
public:
	CListCtrlPairDlg(void);
	CListCtrlPairDlg(
		IN UINT						idd,
		IN const DWORD *			pdwHelpMap,
		IN OUT CClusterItemList *	plpobjRight,
		IN const CClusterItemList *	plpobjLeft,
		IN DWORD					dwStyle,
		IN PFNLCPGETCOLUMN			pfnGetColumn,
		IN PFNLCPDISPPROPS			pfnDisplayProps,
		IN OUT CWnd *				pParent			= NULL
		);
	~CListCtrlPairDlg(void);

	void CommonConstruct(void);

// Attributes
protected:
	CClusterItemList *			m_plpobjRight;
	const CClusterItemList *	m_plpobjLeft;
	DWORD						m_dwStyle;
	PFNLCPGETCOLUMN				m_pfnGetColumn;
	PFNLCPDISPPROPS				m_pfnDisplayProps;

	BOOL						BIsStyleSet(IN DWORD dwStyle) const	{ return (m_dwStyle & dwStyle) == dwStyle; }

	CListCtrlPair::CColumnArray	m_aColumns;

public:
	BOOL				BOrdered(void) const		{ return BIsStyleSet(LCPS_ORDERED); }
	BOOL				BCanBeOrdered(void) const	{ return BIsStyleSet(LCPS_CAN_BE_ORDERED); }
	int					NAddColumn(IN IDS idsText, IN int nWidth);

	void				SetLists(IN OUT CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);
	void				SetLists(IN const CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);

// Dialog Data
	//{{AFX_DATA(CListCtrlPairDlg)
	enum { IDD = 0 };
	//}}AFX_DATA

protected:
	CListCtrlPair *		m_plcp;

public:
	CListCtrlPair *		Plcp(void) const		{ return m_plcp; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCtrlPairDlg)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL				m_bInitDone;

	BOOL				BInitDone(void) const	{ return m_bInitDone; }

	// Generated message map functions
	//{{AFX_MSG(CListCtrlPairDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CListCtrlPairDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _LCPRDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\helpids.h ===
#define	IDH_ABOUT_PRODUCT_TITLE	700001000
#define	IDH_BC_CLUSTER	700001025
#define	IDH_BC_LIST	700001026
#define	IDH_DR_RESOURCES_LIST	700001050
#define	IDH_LCP_ADD	700001076
#define	IDH_LCP_LEFT_LIST	700001075
#define	IDH_LCP_MOVE_DOWN	700001130
#define	IDH_LCP_MOVE_UP	700001129
#define	IDH_LCP_PROPERTIES	700001079
#define	IDH_LCP_REMOVE	700001077
#define	IDH_LCP_RIGHT_LIST	700001078
#define	IDH_MR_RESOURCES_LIST	700001150
#define	IDH_NO_DEL_RES	700001052
#define	IDH_NO_MOVE_RES	700001152
#define	IDH_NO_YTA	700001653
#define	IDH_OCD_BROWSE	700001176
#define	IDH_OCD_NAME	700001175
#define IDH_OCD_ACTION  700002002
#define	IDH_POSIBLE_LCP_REMOVE	700001102
#define	IDH_POSSIBLE_LCP_ADD	700001101
#define	IDH_POSSIBLE_LCP_LEFT_LIST	700001100
#define	IDH_POSSIBLE_LCP_PROPERTIES	700001104
#define	IDH_POSSIBLE_LCP_RIGHT_LIST	700001103
#define	IDH_PP_CLUS_DESC	700001201
#define	IDH_PP_CLUS_NAME	700001200
#define	IDH_PP_CLUS_PRIORITY_DOWN	700001227
#define	IDH_PP_CLUS_PRIORITY_LIST	700001225
#define	IDH_PP_CLUS_PRIORITY_PROPERTIES	700001228
#define	IDH_PP_CLUS_PRIORITY_UP	700001226
#define	IDH_PP_CLUS_QUORUM_LOGGING_GROUP	700001251
#define	IDH_PP_CLUS_QUORUM_MAX_LOG_SIZE	700001254
#define	IDH_PP_CLUS_QUORUM_PARTITION	700001252
#define	IDH_PP_CLUS_QUORUM_RESOURCE	700001250
#define	IDH_PP_CLUS_QUORUM_ROOT_PATH	700001253
#define	IDH_PP_CLUS_VENDOR_ID	700001202
#define	IDH_PP_CLUS_VERSION	700001203
#define	IDH_PP_GROUP_AUTOFB_ALLOW	700001276
#define	IDH_PP_GROUP_AUTOFB_PREVENT	700001275
#define	IDH_PP_GROUP_CURRENT_NODE	700001330
#define	IDH_PP_GROUP_CURRENT_STATE	700001329
#define	IDH_PP_GROUP_DESC	700001326
#define	IDH_PP_GROUP_FAILOVER_PERIOD	700001301
#define	IDH_PP_GROUP_FAILOVER_THRESH	700001300
#define	IDH_PP_GROUP_FB_IMMED	700001277
#define	IDH_PP_GROUP_FB_WINDOW	700001278
#define	IDH_PP_GROUP_FBWIN_END	700001280
#define	IDH_PP_GROUP_FBWIN_START	700001279
#define	IDH_PP_GROUP_NAME	700001325
#define	IDH_PP_GROUP_PREF_OWNERS	700001327
#define	IDH_PP_GROUP_PREF_OWNERS_MODIFY	700001328
#define	IDH_PP_NET_ADDRESS_MASK	700001357
#define	IDH_PP_NET_CURRENT_STATE	700001356
#define	IDH_PP_NET_DESC	700001351
#define	IDH_PP_NET_NAME	700001350
#define	IDH_PP_NET_ROLE_ALL_COMM	700001353
#define	IDH_PP_NET_ROLE_CLIENT_ONLY	700001355
#define	IDH_PP_NET_ROLE_ENABLE_NETWORK	700001352
#define	IDH_PP_NET_ROLE_INTERNAL_ONLY	700001354
#define	IDH_PP_NETIFACE_ADAPTER	700001380
#define	IDH_PP_NETIFACE_ADDRESS	700001381
#define	IDH_PP_NETIFACE_CURRENT_STATE	700001379
#define	IDH_PP_NETIFACE_DESC	700001377
#define	IDH_PP_NETIFACE_NAME	700001378
#define	IDH_PP_NETIFACE_NETWORK	700001376
#define	IDH_PP_NETIFACE_NODE	700001375
#define	IDH_PP_NODE_CSD_VERSION	700001404
#define	IDH_PP_NODE_CURRENT_STATE	700001402
#define	IDH_PP_NODE_DESC	700001401
#define	IDH_PP_NODE_NAME	700001400
#define	IDH_PP_NODE_VERSION	700001403
#define	IDH_PP_RES_AFFECT_THE_GROUP	700001437
#define	IDH_PP_RES_CURRENT_NODE	700001483
#define	IDH_PP_RES_CURRENT_STATE	700001482
#define	IDH_PP_RES_DEFAULT_IS_ALIVE	700001431
#define	IDH_PP_RES_DEFAULT_LOOKS_ALIVE	700001427
#define	IDH_PP_RES_DEPENDS_LIST	700001450
#define	IDH_PP_RES_DESC	700001476
#define	IDH_PP_RES_DONT_RESTART	700001435
#define	IDH_PP_RES_GROUP	700001481
#define	IDH_PP_RES_IS_ALIVE	700001433
#define	IDH_PP_RES_IS_ALIVE_GROUP	700001430
#define	IDH_PP_RES_LOOKS_ALIVE	700001429
#define	IDH_PP_RES_LOOKS_ALIVE_GROUP	700001426
#define	IDH_PP_RES_MODIFY	700001451
#define	IDH_PP_RES_NAME	700001475
#define	IDH_PP_RES_PENDING_TIMEOUT	700001434
#define	IDH_PP_RES_POSSIBLE_OWNERS	700001477
#define	IDH_PP_RES_POSSIBLE_OWNERS_MODIFY	700001478
#define	IDH_PP_RES_PROPERTIES	700001452
#define	IDH_PP_RES_RESOURCE_TYPE	700001480
#define	IDH_PP_RES_RESTART	700001436
#define	IDH_PP_RES_RESTART_PERIOD	700001425
#define	IDH_PP_RES_RESTART_THRESHOLD	700001438
#define	IDH_PP_RES_SEPARATE_MONITOR	700001479
#define	IDH_PP_RES_SPECIFY_IS_ALIVE	700001432
#define	IDH_PP_RES_SPECIFY_LOOKS_ALIVE	700001428
#define	IDH_PP_RESTYPE_DESC	700001501
#define	IDH_PP_RESTYPE_DISPLAY_NAME	700001500
#define	IDH_PP_RESTYPE_IS_ALIVE	700001505
#define	IDH_PP_RESTYPE_LOOKS_ALIVE	700001504
#define	IDH_PP_RESTYPE_NAME	700001506
#define	IDH_PP_RESTYPE_POLLINT_GROUP	700001503
#define	IDH_PP_RESTYPE_POSSIBLE_OWNERS	700001502
#define	IDH_PP_RESTYPE_QUORUM_CAPABLE	700001508
#define	IDH_PP_RESTYPE_RESDLL	700001507
#define	IDH_PREF_LCP_LEFT_LIST	700001125
#define	IDH_PREF_LCP_RIGHT_LIST	700001128
#define	IDH_WIZ_GROUP_DESC	700001551
#define	IDH_WIZ_GROUP_NAME	700001550
#define	IDH_WIZ_PRE_LCP_RIGHT_LIST	700001605
#define	IDH_WIZ_RES_DESC	700001626
#define	IDH_WIZ_RES_GROUP	700001628
#define	IDH_WIZ_RES_NAME	700001625
#define	IDH_WIZ_RES_RESTYPE	700001627
#define	IDH_WIZ_RES_SEPARATE_MONITOR	700001629
#define	IDH_YES_DEL_RES	700001051
#define	IDH_YES_MOVE_RES	700001151
#define	IDH_YES_YTA	700001651
#define	IDH_YTA_MESSAGE	700001650
#define	IDH_YTA_YESTOALL	700001652
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\lcprpage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      LCPrPage.cpp
//
//  Abstract:
//      Implementation of the CListCtrlPairPage dialog template class.
//
//  Author:
//      David Potter (davidp)   August 12, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LCPrPage.h"
#include "OLCPair.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairPage
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CListCtrlPairPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListCtrlPairPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CListCtrlPairPage)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::CListCtrlPairPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairPage::CListCtrlPairPage(void)
{
    CommonConstruct();

}  //*** CListCtrlPairPage::CListCtrlPairPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::CListCtrlPairPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      idd             [IN] Resource ID for the dialog template.
//      pdwHelpMap      [IN] Control-to-Help ID mapping array.
//      dwStyle         [IN] Style:
//                          LCPS_SHOW_IMAGES    Show images to left of items.
//                          LCPS_ALLOW_EMPTY    Allow right list to be empty.
//                          LCPS_ORDERED        Ordered right list.
//                          LCPS_CAN_BE_ORDERED List can be ordered (hides
//                              Up/Down puttons if LCPS_ORDERED not specified).
//      pfnGetColumn    [IN] Function pointer for getting column data.
//      pfnDisplayProps [IN] Function pointer for displaying properties.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairPage::CListCtrlPairPage(
    IN UINT             idd,
    IN const DWORD *    pdwHelpMap,
    IN DWORD            dwStyle,
    IN PFNLCPGETCOLUMN  pfnGetColumn,
    IN PFNLCPDISPPROPS  pfnDisplayProps
    )
    : CBasePropertyPage(idd, pdwHelpMap)
{
    ASSERT(pfnGetColumn != NULL);
    ASSERT(pfnDisplayProps != NULL);

    CommonConstruct();

    m_dwStyle = dwStyle;
    m_pfnGetColumn = pfnGetColumn;
    m_pfnDisplayProps = pfnDisplayProps;

}  //*** CListCtrlPairPage::CListCtrlPairPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::CommonConstruct(void)
{
    m_plpobjRight = NULL;
    m_plpobjLeft = NULL;
    m_dwStyle = 0;
    m_pfnGetColumn = NULL;

    m_plcp = NULL;

}  //*** CListCtrlPairPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::~CListCtrlPairPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairPage::~CListCtrlPairPage(void)
{
    delete m_plcp;

}  //*** CListCtrlPairPage::~CListCtrlPairPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NAddColumn
//
//  Routine Description:
//      Add a column to the list of columns displayed in each list control.
//
//  Arguments:
//      idsText     [IN] String resource ID for text to display on column.
//      nWidth      [IN] Initial width of the column.
//
//  Return Value:
//      icol        Index of the column.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CArray::Add.
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPairPage::NAddColumn(IN IDS idsText, IN int nWidth)
{
    CListCtrlPair::CColumn  col;

    ASSERT(idsText != 0);
    ASSERT(nWidth > 0);
    ASSERT(Plcp() == NULL);

    col.m_idsText = idsText;
    col.m_nWidth = nWidth;

    return (int)m_aColumns.Add(col);

}  //*** CListCtrlPair::NAddColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    Plcp()->DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CListCtrlPairDlg)
    //}}AFX_DATA_MAP

}  //*** CListCtrlPairPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairPage::OnInitDialog( void )
{
    if ( BReadOnly() )
    {
        m_dwStyle |= LCPS_READ_ONLY;
    } // if: page is read only

    // Initialize the ListCtrlPair control.
    if ( BCanBeOrdered() )
    {
        m_plcp = new COrderedListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // if: list can be ordered
    else
    {
        m_plcp = new CListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // else: list cannot be ordered
    if ( m_plcp == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory

    // Add columns if there are any.
    {
        int     icol;

        for ( icol = 0 ; icol <= m_aColumns.GetUpperBound() ; icol++ )
        {
            Plcp()->NAddColumn( m_aColumns[ icol ].m_idsText, m_aColumns[ icol ].m_nWidth );
        } // for: each column
    }  // Add columns if there are any

    CBasePropertyPage::OnInitDialog();
    Plcp()->OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CListCtrlPairPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairPage::OnSetActive(void)
{
    BOOL    bSuccess;

    bSuccess = CBasePropertyPage::OnSetActive();
    if (bSuccess)
        bSuccess = Plcp()->OnSetActive();

    return bSuccess;

}  //*** CListCtrlPairPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairPage::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL    bHandled;

    ASSERT(Plcp() != NULL);

    bHandled = Plcp()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    if (!bHandled)
        bHandled = CBasePropertyPage::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    return bHandled;

}  //*** CListCtrlPairPage::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    ASSERT(Plcp() != NULL);

    if (!Plcp()->OnContextMenu(pWnd, point))
        CBasePropertyPage::OnContextMenu(pWnd, point);

}  //*** CListCtrlPairPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair.
//
//  Arguments:
//      plpobjRight     [IN OUT] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::SetLists(
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairPage::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair where the right list should
//      not be modified.
//
//  Arguments:
//      plpobjRight     [IN] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::SetLists(
    IN const CClusterItemList * plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = (CClusterItemList *) plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    m_dwStyle |= LCPS_DONT_OUTPUT_RIGHT_LIST;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairPage::SetLists()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\lcprpage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		LCPrPage.h
//
//	Abstract:
//		Definition of the CListCtrlPairPage dialog class.
//
//	Implementation File:
//		LCPrPage.cpp
//
//	Author:
//		David Potter (davidp)	August 12, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPRPAGE_H_
#define _LCPRPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _LCPAIR_H_
#include "LCPair.h"		// for PFNLCPGETCOLUMN, CListCtrlPair
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairPage;

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairPage dialog
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CListCtrlPairPage)

// Construction
public:
	CListCtrlPairPage(void);
	CListCtrlPairPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN DWORD			dwStyle,
		IN PFNLCPGETCOLUMN	pfnGetColumn,
		IN PFNLCPDISPPROPS	pfnDisplayProps
		);
	~CListCtrlPairPage(void);

	void CommonConstruct();

// Attributes
protected:
	CClusterItemList *			m_plpobjRight;
	const CClusterItemList *	m_plpobjLeft;
	DWORD						m_dwStyle;
	PFNLCPGETCOLUMN				m_pfnGetColumn;
	PFNLCPDISPPROPS				m_pfnDisplayProps;

	BOOL						BIsStyleSet(IN DWORD dwStyle) const	{ return (m_dwStyle & dwStyle) == dwStyle; }

	CListCtrlPair::CColumnArray	m_aColumns;

public:
	BOOL				BOrdered(void) const		{ return BIsStyleSet(LCPS_ORDERED); }
	BOOL				BCanBeOrdered(void) const	{ return BIsStyleSet(LCPS_CAN_BE_ORDERED); }
	int					NAddColumn(IN IDS idsText, IN int nWidth);

	void				SetLists(IN OUT CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);
	void				SetLists(IN const CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);

// Dialog Data
	//{{AFX_DATA(CListCtrlPairPage)
	enum { IDD = 0 };
	//}}AFX_DATA

protected:
	CListCtrlPair *		m_plcp;

public:
	CListCtrlPair *		Plcp(void) const		{ return m_plcp; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCtrlPairPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CListCtrlPairPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CListCtrlPairPage

/////////////////////////////////////////////////////////////////////////////

#endif // _LCPRPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\lcprwpag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      LCPrWPag.cpp
//
//  Abstract:
//      Implementation of the CListCtrlPairWizPage dialog template class.
//
//  Author:
//      David Potter (davidp)   August 31, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LCPrWPag.h"
#include "OLCPair.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairWizPage
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CListCtrlPairWizPage, CBaseWizardPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListCtrlPairWizPage, CBaseWizardPage)
    //{{AFX_MSG_MAP(CListCtrlPairWizPage)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::CListCtrlPairWizPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairWizPage::CListCtrlPairWizPage(void)
{
    m_plpobjRight = NULL;
    m_plpobjLeft = NULL;
    m_dwStyle = 0;
    m_pfnGetColumn = NULL;

    m_plcp = NULL;

}  //*** CListCtrlPairWizPage::CListCtrlPairWizPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::CListCtrlPairWizPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      idd             [IN] Resource ID for the dialog template.
//      pdwHelpMap      [IN] Control-to-Help ID mapping array.
//      dwStyle         [IN] Style:
//                          LCPS_SHOW_IMAGES    Show images to left of items.
//                          LCPS_ALLOW_EMPTY    Allow right list to be empty.
//                          LCPS_ORDERED        Ordered right list.
//                          LCPS_CAN_BE_ORDERED List can be ordered (hides
//                              Up/Down puttons if LCPS_ORDERED not specified).
//      pfnGetColumn    [IN] Function pointer for getting column data.
//      pfnDisplayProps [IN] Function pointer for displaying properties.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairWizPage::CListCtrlPairWizPage(
    IN UINT             idd,
    IN const DWORD *    pdwHelpMap,
    IN DWORD            dwStyle,
    IN PFNLCPGETCOLUMN  pfnGetColumn,
    IN PFNLCPDISPPROPS  pfnDisplayProps
    )
    : CBaseWizardPage(idd, pdwHelpMap)
{
    ASSERT(pfnGetColumn != NULL);
    ASSERT(pfnDisplayProps != NULL);

    m_plpobjRight = NULL;
    m_plpobjLeft = NULL;
    m_dwStyle = dwStyle;
    m_pfnGetColumn = pfnGetColumn;
    m_pfnDisplayProps = pfnDisplayProps;

    m_plcp = NULL;

    if (dwStyle & LCPS_ORDERED)
        ASSERT(m_dwStyle & LCPS_CAN_BE_ORDERED);

}  //*** CListCtrlPairWizPage::CListCtrlPairWizPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::~CListCtrlPairWizPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairWizPage::~CListCtrlPairWizPage(void)
{
    delete m_plcp;

}  //*** CListCtrlPairWizPage::~CListCtrlPairWizPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NAddColumn
//
//  Routine Description:
//      Add a column to the list of columns displayed in each list control.
//
//  Arguments:
//      idsText     [IN] String resource ID for text to display on column.
//      nWidth      [IN] Initial width of the column.
//
//  Return Value:
//      icol        Index of the column.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CArray::Add.
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPairWizPage::NAddColumn(IN IDS idsText, IN int nWidth)
{
    CListCtrlPair::CColumn  col;

    ASSERT(idsText != 0);
    ASSERT(nWidth > 0);
    ASSERT(Plcp() == NULL);

    col.m_idsText = idsText;
    col.m_nWidth = nWidth;

    return (int)m_aColumns.Add(col);

}  //*** CListCtrlPair::NAddColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairWizPage::DoDataExchange(CDataExchange * pDX)
{
    CBaseWizardPage::DoDataExchange(pDX);
    Plcp()->DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CListCtrlPairDlg)
    //}}AFX_DATA_MAP

}  //*** CListCtrlPairWizPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairWizPage::OnInitDialog( void )
{
    if ( BReadOnly() )
    {
        m_dwStyle |= LCPS_READ_ONLY;
    } // if: page is read only

    // Initialize the ListCtrlPair control.
    if ( BCanBeOrdered() )
    {
        m_plcp = new COrderedListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // if: list can be ordered
    else
    {
        m_plcp = new CListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // else: list cannot be ordered
    if ( m_plcp == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory

    // Add columns if there are any.
    {
        int     icol;

        for ( icol = 0 ; icol <= m_aColumns.GetUpperBound() ; icol++ )
        {
            Plcp()->NAddColumn( m_aColumns[ icol ].m_idsText, m_aColumns[ icol ].m_nWidth );
        } // for: each column
    }  // Add columns if there are any

    CBaseWizardPage::OnInitDialog();
    Plcp()->OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CListCtrlPairWizPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairWizPage::OnSetActive(void)
{
    BOOL    bSuccess;

    bSuccess = CBaseWizardPage::OnSetActive();
    if (bSuccess)
        bSuccess = Plcp()->OnSetActive();

    return bSuccess;

}  //*** CListCtrlPairWizPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairWizPage::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL    bHandled;

    ASSERT(Plcp() != NULL);

    bHandled = Plcp()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    if (!bHandled)
        bHandled = CBaseWizardPage::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    return bHandled;

}  //*** CListCtrlPairWizPage::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairWizPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    ASSERT(Plcp() != NULL);

    if (!Plcp()->OnContextMenu(pWnd, point))
        CBaseWizardPage::OnContextMenu(pWnd, point);

}  //*** CListCtrlPairWizPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair.
//
//  Arguments:
//      plpobjRight     [IN OUT] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairWizPage::SetLists(
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairWizPage::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair where the right list should
//      not be modified.
//
//  Arguments:
//      plpobjRight     [IN] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairWizPage::SetLists(
    IN const CClusterItemList * plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = (CClusterItemList *) plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    m_dwStyle |= LCPS_DONT_OUTPUT_RIGHT_LIST;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairWizPage::SetLists()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\listitem.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ListItem.inl
//
//	Abstract:
//		Inline function implementations for the CListItem class.
//
//	Author:
//		David Potter (davidp)	May 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LISTITEM_INL_
#define _LISTITEM_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _LISTITEM_H_
#include "ListItem.h"	// for CListItem
#endif

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItem
#endif

#ifndef _TREEITEM_H_
#include "TreeItem.h"
#endif

#ifndef _LISTVIEW_H_
#include "ListView.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline CMenu * CListItem::PmenuPopup(void)
{
	ASSERT(Pci() != NULL);
	return Pci()->PmenuPopup();

}  //*** CListItem::PmenuPopup()

inline const CColumnItemList & CListItem::Lpcoli(void) const
{
	ASSERT(PtiParent() != NULL);
	return PtiParent()->Lpcoli();

}  //*** CListItem::Lpcoli()

inline CListCtrl * CListItem::Plc(CClusterListView * pclv) const
{
	ASSERT(pclv != NULL);
	return &pclv->GetListCtrl();

}  //*** CListItem::Plc(pclv)

inline const CString & CListItem::StrName(void) const
{
	ASSERT(Pci() != NULL);
	return Pci()->StrName();

}  //*** CListItem::StrName()

/////////////////////////////////////////////////////////////////////////////

#endif // _LISTITEM_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\listview.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ListView.cpp
//
//  Abstract:
//      Implementation of the CListView class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ClusDoc.h"
#include "ClusItem.h"
#include "ListView.h"
#include "ListItem.h"
#include "ListItem.inl"
#include "SplitFrm.h"
#include "TreeItem.h"
#include "TreeView.h"
#include "ClusDoc.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagListView(_T("UI"), _T("LIST VIEW"), 0);
CTraceTag   g_tagListDrag(_T("Drag&Drop"), _T("LIST VIEW DRAG"), 0);
CTraceTag   g_tagListDragMouse(_T("Drag&Drop"), _T("LIST VIEW DRAG MOUSE"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterListView
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterListView, CListView)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterListView, CListView)
    //{{AFX_MSG_MAP(CClusterListView)
    ON_WM_DESTROY()
    ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemChanged)
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
    ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblClk)
    ON_COMMAND(ID_OPEN_ITEM, OpenItem)
    ON_NOTIFY_REFLECT(LVN_BEGINLABELEDIT, OnBeginLabelEdit)
    ON_NOTIFY_REFLECT(LVN_ENDLABELEDIT, OnEndLabelEdit)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_PROPERTIES, OnCmdProperties)
    ON_COMMAND(ID_FILE_RENAME, OnCmdRename)
    ON_NOTIFY_REFLECT(LVN_BEGINDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(LVN_BEGINRDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(LVN_KEYDOWN, OnKeyDown)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::CClusterListView
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterListView::CClusterListView(void)
{
    m_ptiParent = NULL;
    m_nColumns = 0;
    m_nSortDirection = -1;
    m_pcoliSort = NULL;

    m_pframe = NULL;

    // Initialize label editing.
    m_pliBeingEdited = NULL;
    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

    // Initialize drag & drop.
    m_iliDrag = -1;
    m_pliDrag = NULL;
    m_iliDrop = -1;

}  //*** CClusterListView::CClusterListView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::~CClusterListView
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterListView::~CClusterListView(void)
{
    if (m_ptiParent != NULL)
        m_ptiParent->Release();

}  //*** CClusterListView::~CClusterListView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::Create
//
//  Routine Description:
//      Create the window.
//
//  Arguments:
//      lpszClassName   [IN] Name of the window class to create.
//      lpszWindowName  [IN] Name of the window (used as the caption).
//      dwStyle         [IN] Window styles.
//      rect            [IN] Size and position of the window
//      pParentWnd      [IN OUT ] Parent window.
//      nID             [IN] ID of the window.
//      pContext        [IN OUT] Create context of the window.
//
//  Return Value:
//      0               Successful.
//      !0              Unsuccessful.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterListView::Create(
    LPCTSTR             lpszClassName,
    LPCTSTR             lpszWindowName,
    DWORD               dwStyle,
    const RECT &        rect,
    CWnd *              pParentWnd,
    UINT                nID,
    CCreateContext *    pContext
    )
{
    BOOL                bSuccess;

    // Set default style bits.
    dwStyle |=
        LVS_SHAREIMAGELISTS
        | LVS_EDITLABELS
        | LVS_SINGLESEL
        | LVS_SHOWSELALWAYS
        | LVS_ICON
        | LVS_REPORT
        ;

    bSuccess = CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
    if (bSuccess)
    {
        GetListCtrl().SetImageList(GetClusterAdminApp()->PilLargeImages(), LVSIL_NORMAL);
        GetListCtrl().SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_SMALL);
//      GetListCtrl().SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_STATE);

        // Change list view control extended styles.
        {
            DWORD   dwExtendedStyle;

            dwExtendedStyle = (DWORD)GetListCtrl().SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
            GetListCtrl().SendMessage(
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                dwExtendedStyle
                    | LVS_EX_FULLROWSELECT
                    | LVS_EX_HEADERDRAGDROP
                );
        }  // Change list view control extended styles

    }  // if:  window created successfully

    return bSuccess;

}  //*** CClusterListView::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnInitialUpdate
//
//  Routine Description:
//      Do one-time initialization.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnInitialUpdate()
{
    CListView::OnInitialUpdate();

    // Save the frame pointer.
//  ASSERT(m_pframe == NULL);
    m_pframe = (CSplitterFrame *) GetParentFrame();
    ASSERT_VALID(m_pframe);
    ASSERT_KINDOF(CSplitterFrame, m_pframe);

}  //*** CClusterListView::OnInitialUpdate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::Refresh
//
//  Routine Description:
//      Refresh the view by reloading all the data.
//
//  Arguments:
//      ptiSelected [IN OUT] Pointer to currently selected item in the tree control.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::Refresh(IN OUT CTreeItem * ptiSelected)
{
    // Save columns.
    if (PtiParent() != NULL)
        SaveColumns();

    // Clean up the control to start with.
    DeleteAllItems();

    // Cleanup the previous parent tree item.
    if (m_ptiParent != NULL)
        m_ptiParent->Release();
    m_ptiParent = ptiSelected;

    // Setup the new selection.
    if (m_ptiParent != NULL)
    {
        ASSERT_VALID(ptiSelected);

        CListCtrl &             rListCtrl   = GetListCtrl();
        const CListItemList &   rlpli       = ptiSelected->LpliChildren();

        m_ptiParent->AddRef();

        // Add columns to the list control.
        AddColumns();

        // Add items from the tree item's list to the list view.
        {
            POSITION        pos;
            CListItem *     pli;

            // Tell the list control how many items we will be adding.
            // This improves performance.
            rListCtrl.SetItemCount((int)rlpli.GetCount());

            // Add the items to the list control.
            pos = rlpli.GetHeadPosition();
            while (pos != NULL)
            {
                pli = rlpli.GetNext(pos);
                ASSERT_VALID(pli);
                pli->IliInsertInList(this);
            }  // while:  more items in the list
        }  // Add items from the tree item's list to the list view

        // Give the focus to the first item in the list.
        if (rListCtrl.GetItemCount() != 0)
            rListCtrl.SetItem(0, 0, LVIF_STATE, NULL, 0, LVIS_FOCUSED, LVIS_FOCUSED, NULL);
    }  // if:  non-null selection

    // Set the sort column and direction.
    m_nSortDirection = -1;
    m_pcoliSort = NULL;

}  //*** CClusterListView::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::DeleteAllItems
//
//  Routine Description:
//      Delete all the list and column items.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        All items deleted successfully.
//      FALSE       Not all items were deleted successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterListView::DeleteAllItems(void)
{
    BOOL    bDeletedAllItems;
    BOOL    bDeletedAllColumns  = TRUE;
    int     icol;

    // Remove all the items from our list.
    {
        CListItem * pli;
        int         ili;
        int         cli = GetListCtrl().GetItemCount();

        // Get the index of the first item.
        for (ili = 0 ; ili < cli; ili++)
        {
            pli = (CListItem *) GetListCtrl().GetItemData(ili);
            ASSERT_VALID(pli);
            pli->PreRemoveFromList(this);
        }  // for:  each item in the list

    }  // Remove all the items from the cluster item back pointer list

    // Delete the columns.
    {
        for (icol = m_nColumns - 1 ; icol >= 0 ; icol--)
        {
            // Delete the column from the view.
            if (!GetListCtrl().DeleteColumn(icol))
                bDeletedAllColumns = FALSE;
        }  // for:  each column
        m_nColumns = 0;
    }  // Delete the columns

    // Remove all the items from the list.
    bDeletedAllItems = GetListCtrl().DeleteAllItems();

    return (bDeletedAllItems && bDeletedAllColumns);

}  //*** CClusterListView::DeleteAllItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::SaveColumns
//
//  Routine Description:
//      Save the columns being displayed in the list view.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::SaveColumns(void)
{
    int         icol;
    DWORD *     prgnColumnInfo;
    CListCtrl & rplc = GetListCtrl();

    ASSERT_VALID(PtiParent());

    // We can only save column information if we are in report view.
    if (GetView() & LVS_REPORT)
    {
        try
        {
            // Get the column info array for this view.
            prgnColumnInfo = PtiParent()->PrgnColumnInfo(this);

            // Save the widths of the columns.
            for (icol = m_nColumns - 1 ; icol >= 0 ; icol--)
                prgnColumnInfo[icol + 1] = rplc.GetColumnWidth(icol);

            // Save the position information in the array.
            rplc.SendMessage(LVM_GETCOLUMNORDERARRAY, m_nColumns, (LPARAM) &prgnColumnInfo[m_nColumns + 1]);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // if:  we are in detail view

}  //*** CClusterListView::SaveColumns()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::AddColumns
//
//  Routine Description:
//      Add columns to the list view.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::AddColumns(void)
{
    POSITION        pos;
    int             cColumns;
    int             icoli = 0;
    CColumnItem *   pcoli;
    DWORD *         prgnColumnInfo;
    CListCtrl &     rplc = GetListCtrl();

    ASSERT_VALID(PtiParent());

    try
    {
        // Get the column info.
        cColumns = (int)PtiParent()->Lpcoli().GetCount();
        prgnColumnInfo = PtiParent()->PrgnColumnInfo(this);

        pos = PtiParent()->Lpcoli().GetHeadPosition();
        for (icoli = 0 ; pos != NULL ; icoli++)
        {
            // Get the next column item.
            pcoli = PtiParent()->Lpcoli().GetNext(pos);
            ASSERT(pcoli != NULL);

            // Insert the column item in the list.
            rplc.InsertColumn(
                    icoli,                      // nCol
                    pcoli->StrText(),           // lpszColumnHeading
                    LVCFMT_LEFT,                // nFormat
                    prgnColumnInfo[icoli + 1],  // nWidth
                    icoli                       // nSubItem
                    );
        }  // while:  more items in the list

        // Set column positions.
        rplc.SendMessage(LVM_SETCOLUMNORDERARRAY, cColumns, (LPARAM) &prgnColumnInfo[cColumns + 1]);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    m_nColumns = icoli;

}  //*** CClusterListView::AddColumns()

/////////////////////////////////////////////////////////////////////////////
// CClusterListView diagnostics
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
void CClusterListView::AssertValid(void) const
{
    CListView::AssertValid();

}  //*** CClusterListView::AssertValid()

void CClusterListView::Dump(CDumpContext& dc) const
{
    CListView::Dump(dc);

}  //*** CClusterListView::Dump()

CClusterDoc * CClusterListView::GetDocument(void) // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClusterDoc)));
    return (CClusterDoc *) m_pDocument;

}  //*** CClusterListView::GetDocument()
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::PliFocused
//
//  Routine Description:
//      Get the list item that has the focus.
//
//  Arguments:
//      None.
//
//  Return Value:
//      pliSelected     The item with the focus or NULL if no item has focus.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem * CClusterListView::PliFocused(void) const
{
    int         iliFocused;
    CListItem * pliFocused;

    iliFocused = IliFocused();
    if (iliFocused != -1)
    {
        pliFocused = (CListItem *) GetListCtrl().GetItemData(iliFocused);
        ASSERT_VALID(pliFocused);
    }  // if:  found an item with the focus
    else
        pliFocused = NULL;

    return pliFocused;

}  //*** CClusterListView::PliFocused()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterListView::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    int         ili;
    CListItem * pli;
    BOOL        bHandled    = FALSE;

    // If there is a current item selected, give it a chance
    // to handle the message.
    ili = GetListCtrl().GetNextItem(-1, LVNI_FOCUSED);
    if (ili != -1)
    {
        pli = (CListItem *) GetListCtrl().GetItemData(ili);
        ASSERT_VALID(pli);
        bHandled = pli->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    }  // if:  an item is selected

    if (!bHandled)
        bHandled = CListView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

    return bHandled;

}  //*** CClusterListView::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::PmenuPopup
//
//  Routine Description:
//      Returns a popup menu.
//
//  Arguments:
//      rpointScreen    [IN OUT] Position of the cursor, in screen coordinates.
//      rpci            [OUT] Pointer in which to return associated cluster item.
//
//  Return Value:
//      pmenu       A popup menu for the item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMenu * CClusterListView::PmenuPopup(
    IN OUT CPoint &     rpointScreen,
    OUT CClusterItem *& rpci
    )
{
    CListItem * pli     = NULL;
    CMenu *     pmenu   = NULL;

    rpci = NULL;

    // If there are no coordinates (-1,-1), display a menu for the selected item.
    if ((rpointScreen.x == -1) && (rpointScreen.y == -1))
    {
        CListItem * pliFocused  = PliFocused();
        CRect       rect;

        if ((pliFocused != NULL)
                && GetListCtrl().GetItemRect(IliFocused(), &rect, LVIR_BOUNDS))
        {
            pli = pliFocused;
        }  // if:  item with focus and it is visible
        else
            GetWindowRect(&rect);
        rpointScreen.x = (rect.right - rect.left) / 2;
        rpointScreen.y = (rect.bottom - rect.top) / 2;
        ClientToScreen(&rpointScreen);
    }  // if:  no coordinates
    else
    {
        CPoint      pointClient;
        int         ili;
        UINT        uiFlags;

        // Get the coordinates of the point where the user clicked the right mouse
        // button.  We need in both screen and client coordinates.
        pointClient = rpointScreen;
        ScreenToClient(&pointClient);

        // Get the item under the cursor and get its popup menu.
        ili = GetListCtrl().HitTest(pointClient, &uiFlags);
        if ((ili != -1) && ((uiFlags | LVHT_ONITEM) != 0))
        {
            // Get the list item for the item under the cursor.
            pli = (CListItem *) GetListCtrl().GetItemData(ili);
            ASSERT_VALID(pli);
        }  // if:  on an item
    }  // else:  coordinates specified

    if (pli != NULL)
    {
        // Get a menu from the item.
        pmenu = pli->PmenuPopup();
        rpci = pli->Pci();
    }  // if:  item found

    return pmenu;

}  //*** CClusterListView::PmenuPopup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnUpdateProperties(CCmdUI * pCmdUI)
{
    CListItem * pliFocused = PliFocused();

    // If there is an item with the focus, pass this message on to it.
    if (pliFocused != NULL)
    {
        ASSERT_VALID(pliFocused->Pci());
        pliFocused->Pci()->OnUpdateProperties(pCmdUI);
    }  // if:  there is an item with the focus

}  //*** CClusterListView::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnCmdProperties
//
//  Routine Description:
//      Processes the ID_FILE_PROPERTIES menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnCmdProperties(void)
{
    CListItem * pliFocused = PliFocused();

    // If there is an item with the focus, pass this message on to it.
    if (pliFocused != NULL)
    {
        ASSERT_VALID(pliFocused->Pci());
        pliFocused->Pci()->OnCmdProperties();
    }  // if:  there is an item with the focus

}  //*** CClusterListView::OnCmdProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnItemChanged
//
//  Routine Description:
//      Handler method for the LVN_ITEMCHANGED message.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;
    CWnd *          pwndFocus   = GetFocus();
    CListItem *     pli;

    if (m_pDocument != NULL)  // this happens on system shutdown
    {
        // If the item has just lost or received the focus, save it and set the menu.
        if ((pNMListView->uChanged & LVIF_STATE)
                && (pwndFocus == &GetListCtrl()))
        {
            ASSERT(pNMListView->iItem != -1);

            // Get the item whose state is changing.
            pli = (CListItem *) pNMListView->lParam;
            ASSERT_VALID(pli);

            if ((pNMListView->uOldState & LVIS_FOCUSED)
                    && !(pNMListView->uNewState & LVIS_FOCUSED))
            {
                Trace(g_tagListView, _T("OnItemChanged() - '%s' lost focus"), pli->Pci()->StrName());

                // Tell the document of the new selection.
                GetDocument()->OnSelChanged(NULL);
            }  // if:  old item losing focus
            else if (!(pNMListView->uOldState & LVIS_FOCUSED)
                        && (pNMListView->uNewState & LVIS_FOCUSED))
            {
                Trace(g_tagListView, _T("OnItemChanged() - '%s' received focus"), pli->Pci()->StrName());

                // Tell the document of the new selection.
                GetDocument()->OnSelChanged(pli->Pci());
            }  // else:  new item receiving focus
        }  // if:  item received the focus
    }  // if:  document is available

    *pResult = 0;

}  //*** CClusterListView::OnItemChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnActivateView
//
//  Routine Description:
//      Called when the view is activated.
//
//  Arguments:
//      bActivate       [IN] Indicates whether the view being activated or deactivated.
//      pActivateView   [IN OUT] Points to the view object that is being activated.
//      peactiveView    [IN OUT] Points to the view object that is being deactivated.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnActivateView(
    BOOL        bActivate,
    CView *     pActivateView,
    CView *     pDeactiveView
    )
{
    CListItem * pliFocused  = PliFocused();

    if (m_pDocument != NULL)  // this happens on system shutdown
    {
        if (bActivate && (pliFocused != NULL))
        {
            ASSERT_VALID(pliFocused->Pci());
            Trace(g_tagListView, _T("OnActivateView() - '%s' received focus"), pliFocused->Pci()->StrName());

            // Tell the document of the new selection.
            GetDocument()->OnSelChanged(pliFocused->Pci());
        }  // if:  we are being activated
    }  // if:  document is available

    CListView::OnActivateView(bActivate, pActivateView, pDeactiveView);

}  //*** CClusterListView::OnActivateView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnDestroy(void)
{
    // Save the columns.
    if (PtiParent() != NULL)
        SaveColumns();

    // Clean up the control.
    DeleteAllItems();

    CListView::OnDestroy();

}  //*** CClusterListView::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnColumnClick
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnColumnClick(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;
    int             ili;
    CListItem *     pli;
    POSITION        pos;
    CColumnItem *   pcoli;

    if (GetListCtrl().GetItemCount() != 0)
    {
        // Get the first item in the list.
        ili = GetListCtrl().GetNextItem(-1, LVNI_ALL);
        ASSERT(ili != -1);
        pli = (CListItem *) GetListCtrl().GetItemData(ili);
        ASSERT_VALID(pli);
        ASSERT_VALID(pli->PtiParent());

        // Get the column item to sort by.
        pos = pli->PtiParent()->Lpcoli().FindIndex(pNMListView->iSubItem);
        ASSERT(pos != NULL);
        pcoli = pli->PtiParent()->Lpcoli().GetAt(pos);
        ASSERT_VALID(pcoli);

        // Save the current sort column and direction.
        if (pcoli == PcoliSort())
            m_nSortDirection ^= -1;
        else
        {
            m_pcoliSort = pcoli;
            m_nSortDirection = 0;
        }  // else:  different column

        // Sort the list.
        GetListCtrl().SortItems(CompareItems, (LPARAM) this);
    }  // if:  there are items in the list

    *pResult = 0;

}  //*** CClusterListView::OnColumnClick()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CClusterListView::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CListItem *         pli1    = (CListItem *) lparam1;
    CListItem *         pli2    = (CListItem *) lparam2;
    CClusterListView *  pclv    = (CClusterListView *) lparamSort;
    CString             str1;
    CString             str2;
    int                 nResult;

    ASSERT_VALID(pli1);
    ASSERT_VALID(pli2);
    ASSERT_VALID(pli1->Pci());
    ASSERT_VALID(pli2->Pci());
    ASSERT_VALID(pclv);
    ASSERT_VALID(pclv->PcoliSort());

    // Get the strings from the list items.
    pli1->Pci()->BGetColumnData(pclv->PcoliSort()->Colid(), str1);
    pli2->Pci()->BGetColumnData(pclv->PcoliSort()->Colid(), str2);

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                str1,
                str1.GetLength(),
                str2,
                str2.GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (pclv->NSortDirection() != 0)
        nResult = -nResult;

    return nResult;

}  //*** CClusterListView::CompareItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnDblClk
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnDblClk(NMHDR * pNMHDR, LRESULT * pResult)
{
    OpenItem();
    *pResult = 0;

}  //*** CClusterListView::OnDblClk()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OpenItem
//
//  Routine Description:
//      Open the item with the focus.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OpenItem(void)
{
    CListItem * pliFocused = PliFocused();

    if (m_pliBeingEdited == NULL)
    {
        // If an item has focus, open it or show its properties.
        if (pliFocused != NULL)
        {
            CTreeItem *     pti;

            ASSERT_VALID(pliFocused->PtiParent());

            Trace(g_tagListView, _T("Opening item '%s'"), pliFocused->Pci()->StrName());

            // Find the item tree item for the list item.
            pti = pliFocused->PtiParent()->PtiChildFromPci(pliFocused->Pci());

            // If this item has a tree item, open it up.  Otherwise show its
            // properties.
            if (pti != NULL)
            {
                CSplitterFrame *    pframe;

                // Get the frame pointer so we can talk to the tree view.
                pframe = (CSplitterFrame *) GetParentFrame();
                ASSERT_KINDOF(CSplitterFrame, pframe);

                pliFocused->PtiParent()->OpenChild(pti, pframe);
            }  // if:  item is openable
            else
                OnCmdProperties();
        }  // if:  an item has focus
    }  // if:  label not being edited
    else
    {
        ASSERT_VALID(m_pliBeingEdited);
        Trace(g_tagListView, _T("Not opening item '%s'"), m_pliBeingEdited->Pci()->StrName());
    }  // else if:  label being edited
    
}  //*** CClusterListView::OpenItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnBeginLabelEdit
//
//  Routine Description:
//      Handler method for the LVN_BEGINLABELEDIT message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnBeginLabelEdit(NMHDR * pNMHDR, LRESULT * pResult)
{
    ASSERT(pNMHDR != NULL);

    LV_DISPINFO * pDispInfo = (LV_DISPINFO *) pNMHDR;
    CListItem * pli = (CListItem *) pDispInfo->item.lParam;

    ASSERT(m_pliBeingEdited == NULL);
    ASSERT_VALID(pli->Pci());

    if (pli->Pci()->BCanBeEdited())
    {
        pli->Pci()->OnBeginLabelEdit(GetListCtrl().GetEditControl());
        m_pliBeingEdited = pli;
        *pResult = FALSE;
    }  // if:  object can be renamed
    else
        *pResult = TRUE;

    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

}  //*** CClusterListView::OnBeginLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnEndLabelEdit
//
//  Routine Description:
//      Handler method for the LVN_ENDLABELEDIT message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnEndLabelEdit(NMHDR * pNMHDR, LRESULT * pResult)
{
    ASSERT(pNMHDR != NULL);

    LV_DISPINFO * pDispInfo = (LV_DISPINFO *) pNMHDR;
    CListItem * pli = (CListItem *) pDispInfo->item.lParam;

    ASSERT_VALID(pli);
    ASSERT(pli == m_pliBeingEdited);
    ASSERT_VALID(pli->Pci());

    // If the edit wasn't cancelled, rename it.
    if (pDispInfo->item.mask & LVIF_TEXT)
    {
        ASSERT(pli->Pci()->BCanBeEdited());
        ASSERT(pDispInfo->item.pszText != NULL);

        Trace(g_tagListView, _T("Ending edit of item '%s' (Saving as '%s')"), pli->Pci()->StrName(), pDispInfo->item.pszText);

        if ( pli->Pci()->BIsLabelEditValueValid( pDispInfo->item.pszText ) )
        {
            try
            {
                pli->Pci()->Rename(pDispInfo->item.pszText);
                *pResult = TRUE;
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                *pResult = FALSE;
            }  // catch:  CException
        } // if:  name is valid
        else
        {
            *pResult = FALSE;
        }
    }  // if:  the edit wasn't cancelled
    else
    {
        Trace(g_tagListView, _T("Ending edit of item '%s' (Not Saving)"), pli->Pci()->StrName());
        *pResult = TRUE;
    }  // else:  edit was cancelled

    m_pliBeingEdited = NULL;
    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

}  //*** CClusterListView::OnEndLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnBeginDrag
//
//  Routine Description:
//      Handler method for the LVN_BEGINDRAG and LVN_BEGINRDRAG messages.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnBeginDrag(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;
    CListCtrl &     rlc         = GetListCtrl();
    CPoint          ptAction;
    CClusterItem *  pci = NULL;
    CImageList *    pimagelist;

    ASSERT_VALID(Pframe());

    // Get the item being dragged.
    {
        int         ili;
        CListItem * pli;

        // Get the item being dragged.
        ili = pNMListView->iItem;
        pli = (CListItem *) rlc.GetItemData(ili);
        ASSERT_VALID(pli);
        ASSERT_KINDOF(CListItem, pli);
        ASSERT_VALID(pli->Pci());

        // If the item can not be dragged, abort the operation.
        if (!pli->Pci()->BCanBeDragged())
            return;

        // Deselect the item being dragged.
        rlc.SetItemState(ili, 0, LVIS_SELECTED);

        // Save info for later.
        m_iliDrag = ili;
        m_pliDrag = pli;
        m_iliDrop = -1;
        pci = pli->Pci();
    }  // Get the item being dragged

    // Create the image list and let the frame window initialize the drag operation.
    {
        CPoint  ptImage;
        CPoint  ptFrameItem;
        CPoint  ptHotSpot;

        pimagelist = rlc.CreateDragImage(m_iliDrag, &ptImage);
        ASSERT(pimagelist != NULL);
        ptFrameItem = pNMListView->ptAction;
        Pframe()->ScreenToClient(&ptFrameItem);

        // Calculate the hot spot point.
        {
            long lStyle = rlc.GetStyle() & LVS_TYPEMASK;
            switch (lStyle)
            {
                case LVS_REPORT:
                case LVS_LIST:
                case LVS_SMALLICON:
                    ptHotSpot.x = 0;
                    ptHotSpot.y = -16;
                    break;
                case LVS_ICON:
                    ptHotSpot.x = 8;
                    ptHotSpot.y = 8;
                    break;
            }  // switch:  lStyle
        }  // Calculate the hot spot point

        Trace(g_tagListDrag, _T("OnBeginDrag() - Dragging '%s' at (%d,%d)"), m_pliDrag->StrName(), ptFrameItem.x, ptFrameItem.y);
        Pframe()->BeginDrag(pimagelist, pci, ptFrameItem, ptHotSpot);
        pimagelist->SetDragCursorImage(0, CPoint(0, 0));  // define the hot spot for the new cursor image
    }  // Create the image list and let the frame window initialize the drag operation

    *pResult = 0;

}  //*** CClusterListView::OnBeginDrag(pNMHDR, pResult)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnMouseMoveForDrag
//
//  Routine Description:
//      Handler method for the WM_MOUSEMOVE message during a drag operation.
//      This function is only responsible for providing view-specific
//      functionality, such as selecting the drop target if it is valid.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor in frame
//                      coordinates.
//      pwndDrop    Specifies the window under the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnMouseMoveForDrag(
    IN UINT         nFlags,
    IN OUT CPoint   point,
    IN const CWnd * pwndDrop
    )
{
    ASSERT(BDragging());
    ASSERT_VALID(Pframe());

    // If we are dragging, select the drop target.
    if (BDragging())
    {
        int             ili;
        UINT            uFlags;
        CPoint          ptView;
        CListCtrl &     rlc     = GetListCtrl();

        // Convert the point to view coordinates.
        ptView = point;
        Pframe()->ClientToScreen(&ptView);
        rlc.ScreenToClient(&ptView);

        // If this window is the drop target, find the item under the cursor.
        if (pwndDrop == &rlc)
        {
            // If we are over a list item, highlight it.
            ili = rlc.HitTest(ptView, &uFlags);
            if (ili != -1)
            {
                CListItem * pli;

                // Get the item to be highlight.
                pli = (CListItem *) rlc.GetItemData(ili);
                ASSERT_VALID(pli);
                ASSERT_KINDOF(CListItem, pli);
                ASSERT_VALID(pli->Pci());

                // If this is not a drop target, change the cursor.
                if (pli->Pci()->BCanBeDropTarget(Pframe()->PciDrag()))
                    Pframe()->ChangeDragCursor(IDC_ARROW);
                else
                    Pframe()->ChangeDragCursor(IDC_NO);
            }  // if:  over a list item
        }  // if:  this window is the drop target
        else
            ili = -1;

        // If the drop target is or was in this view, update the view.
        if ((ili != -1) || (m_iliDrop != -1))
        {
            // Unlock window updates.
            VERIFY(Pimagelist()->DragShowNolock(FALSE /*bShow*/));

            // Turn off highlight for the previous drop target.
            if (m_iliDrop != -1)
            {
                VERIFY(rlc.SetItemState(m_iliDrop, 0, LVIS_DROPHILITED));
                VERIFY(rlc.RedrawItems(m_iliDrop, m_iliDrop));
            }  // if:  there was a previous drop target

            // Highlight the new drop target.
            if (ili != -1)
            {
                VERIFY(rlc.SetItemState(ili, LVIS_DROPHILITED, LVIS_DROPHILITED));
                VERIFY(rlc.RedrawItems(ili, ili));
            }  // if:  over an item
            m_iliDrop = ili;

            rlc.UpdateWindow();
            VERIFY(Pimagelist()->DragShowNolock(TRUE /*bShow*/));
        }  // if:  new or old drop target

    }  // if:  list item is being dragged

}  //*** CClusterListView::OnMouseMoveForDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnButtonUpForDrag
//
//  Routine Description:
//      Called to handle a button up event during drag and drop.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnButtonUpForDrag(IN UINT nFlags, IN CPoint point)
{
    ASSERT(BDragging());
    ASSERT_VALID(Pframe());
    ASSERT_VALID(Pframe()->PciDrag());

    // If we are dragging, process the drop.
    if (BDragging())
    {
        int             ili;
        UINT            flags;
        CPoint          ptView;
        CListCtrl &     rlc     = GetListCtrl();

        Trace(g_tagListDrag, _T("OnButtonUpForDrag()"));

        // Convert the point to view coordinates.
        ptView = point;
        Pframe()->ClientToScreen(&ptView);
        rlc.ScreenToClient(&ptView);

        // If we are over a tree item, drop the item being dragged.
        ili = rlc.HitTest(ptView, &flags);
        if (ili != -1)
        {
            CListItem * pliDropTarget;

            // Get the item to drop on.
            pliDropTarget = (CListItem *) rlc.GetItemData(ili);
            ASSERT_VALID(pliDropTarget);
            ASSERT_KINDOF(CListItem, pliDropTarget);
            ASSERT_VALID(pliDropTarget->Pci());

            if (pliDropTarget->Pci() != Pframe()->PciDrag())
                pliDropTarget->Pci()->DropItem(Pframe()->PciDrag());
        }  // if:  over a tree item
    }  // if:  tree item is being dragged

}  //*** CClusterListView::OnButtonUpForDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::BeginDrag
//
//  Routine Description:
//      Called by the frame to begin a drag operation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::BeginDrag(void)
{
    Trace(g_tagListDrag, _T("BeginDrag()"));

}  //*** CClusterListView::BeginDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::EndDrag
//
//  Routine Description:
//      Called by the frame to end a drag operation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::EndDrag(void)
{
    // Clear and reset highlights.  The second one can fail, since the item
    // could be removed from the list by this time.
    if (m_iliDrop != -1)
        VERIFY(GetListCtrl().SetItemState(m_iliDrop, 0, LVIS_DROPHILITED));
    if (m_iliDrag != -1)
        GetListCtrl().SetItemState(m_iliDrag, LVIS_SELECTED, LVIS_SELECTED);

    m_iliDrag = -1;
    m_pliDrag = NULL;
    m_iliDrop = -1;

    Trace(g_tagListDrag, _T("EndDrag()"));

}  //*** CClusterListView::EndDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::PreTranslateMessage
//
//  Routine Description:
//      Translate window messages before they are dispatched.
//      This is necessary for handling keystrokes properly while editing
//      the label on an item.
//
//  Arguments:
//      pMsg    Points to a MSG structure that contains the message to process.
//
//  Return Value:
//      TRUE    Message was handled.
//      FALSE   Message was not handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterListView::PreTranslateMessage(MSG * pMsg)
{
    BOOL    bForward    = FALSE;

    if (m_pliBeingEdited != NULL)
    {
        CEdit * pedit = GetListCtrl().GetEditControl();
        ASSERT(pedit != NULL);

        if (pMsg->message == WM_KEYDOWN)
        {
            if (pMsg->wParam == VK_SHIFT)
                m_bShiftPressed = TRUE;
            else if (pMsg->wParam == VK_CONTROL)
            {
                ::CopyMemory(&m_msgControl, pMsg, sizeof(m_msgControl));
                m_bControlPressed = TRUE;
            }  // else if:  control key pressed
            else if ((pMsg->wParam == VK_RETURN)
                        || (pMsg->wParam == VK_ESCAPE)
                        || (pMsg->wParam == VK_INSERT)
                        || (pMsg->wParam == VK_DELETE)
                        || (pMsg->wParam == VK_F1)
                        || (pMsg->wParam == VK_F5)
                        || (pMsg->wParam == VK_F6)
                    )
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Forwarding WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                bForward = TRUE;
                if (m_bControlPressed)
                {
                    if (pMsg->wParam == VK_RETURN)
                        pedit->SendMessage(WM_KEYUP, m_msgControl.wParam, m_msgControl.lParam);
                }  // if:  control key pressed
            }  // else if:  editing key pressed
            else if ((pMsg->wParam == VK_TAB)
                        || (m_bControlPressed
                                && (_T('A') <= pMsg->wParam) && (pMsg->wParam <= _T('Y'))
                                && (pMsg->wParam != _T('C'))
                                && (pMsg->wParam != _T('H'))
                                && (pMsg->wParam != _T('M'))
                                && (pMsg->wParam != _T('V'))
                                && (pMsg->wParam != _T('X'))
                            )
                        )
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Ignoring WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                MessageBeep(MB_ICONEXCLAMATION);
                return TRUE;
            }  // else if:  key pressed that should be ignored
#ifdef NEVER
            else
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Not forwarding WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
            }  // else:  not processing key
#endif
        }  // if:  key pressed while editing label
        else if (pMsg->message == WM_SYSKEYDOWN)
        {
            if (pMsg->wParam == VK_MENU)
                m_bAltPressed = TRUE;
            else if ((pMsg->wParam == VK_RETURN)
                    )
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Forwarding WM_SYSKEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                bForward = TRUE;
            }  // else if:  editing key pressed
#ifdef NEVER
            else
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Not forwarding WM_SYSKEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
            }  // else:  not processing key
#endif
        }  // else if:  system key pressed while editing label
        if (bForward)
        {
            pedit->SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
            return TRUE;
        }  // if:  forwarding the message
        else if (pMsg->message == WM_KEYUP)
        {
            if (pMsg->wParam == VK_SHIFT)
                m_bShiftPressed = FALSE;
            else if (pMsg->wParam == VK_CONTROL)
                m_bControlPressed = FALSE;
        }  // else if:  key up
        else if (pMsg->message == WM_SYSKEYUP)
        {
            if (pMsg->wParam == VK_MENU)
                m_bAltPressed = FALSE;
        }  // else if:  system key up
    }  // if:  editing a label

    return CListView::PreTranslateMessage(pMsg);

}  //*** CClusterListView::PreTranslateMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnCmdRename
//
//  Routine Description:
//      Processes the ID_FILE_RENAME menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnCmdRename(void)
{
    CListItem * pliFocused = PliFocused();

    // If an item has focus, begin label editing
    if (pliFocused != NULL)
    {
        ASSERT_VALID(pliFocused);
        pliFocused->EditLabel(this);
    }  // if:  an item has the focus

}  //*** CClusterListView::OnCmdRename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::SetView
//
//  Routine Description:
//      Set the current view of the list view control.
//
//  Arguments:
//      dwView      [IN] List view to set.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::SetView(IN DWORD dwView)
{
    // Get the current window style.
    DWORD dwStyle = GetWindowLong(GetListCtrl().m_hWnd, GWL_STYLE);

    // Only set the window style if the view bits have changed.
    if ((dwStyle & LVS_TYPEMASK) != dwView)
    {
        // Save the column information before switching out of report view.
        if ((dwStyle & LVS_REPORT) && (PtiParent() != NULL))
            SaveColumns();

        // Set the new view.
        SetWindowLong(GetListCtrl().m_hWnd, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK) | dwView);
    }  // if:  view has changed

}  //*** CClusterListView::SetView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnKeyDown
//
//  Routine Description:
//      Handler method for the LVN_KEYDOWN message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnKeyDown(NMHDR * pNMHDR, LRESULT * pResult)
{
    LV_KEYDOWN * pLVKeyDown = (LV_KEYDOWN *) pNMHDR;

    if (BDragging() && (pLVKeyDown->wVKey == VK_ESCAPE))
        Pframe()->AbortDrag();

    *pResult = 0;

}  //*** CClusterListView::OnKeyDown()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\listitem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ListItem.h
//
//	Abstract:
//		Definition of the CListItem class.
//
//	Author:
//		David Potter (davidp)	May 6, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LISTITEM_H_
#define _LISTITEM_H_

#ifndef __AFXTEMPL_H__
#include "afxtempl.h"	// for CList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListItem;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CListItem *, CListItem *> CListItemList;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _COLITEM_H_
#include "ColItem.h"	// for CColumnItemList;
#endif

#ifndef _LISTVIEW_H_
#include "ListView.h"	// for CClusterListViewList
#endif

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;

/////////////////////////////////////////////////////////////////////////////
// CListItem command target

class CListItem : public CCmdTarget
{
	friend class CClusterListView;

	DECLARE_DYNCREATE(CListItem)

	CListItem(void);		// protected constructor used by dynamic creation
	CListItem(IN OUT CClusterItem * pci, IN OUT CTreeItem * pti);

// Attributes
protected:
	CTreeItem *				m_ptiParent;
	CClusterItem *			m_pci;
	CClusterListViewList	m_lpclvViews;

	CClusterListViewList &	LpclvViews(void)		{ return m_lpclvViews; }
	const CColumnItemList &	Lpcoli(void) const;

public:
	CTreeItem *				PtiParent(void) const	{ return m_ptiParent; }
	CClusterItem *			Pci(void) const			{ return m_pci; }

	int						Ili(CClusterListView * pclv) const;
	CListCtrl *				Plc(CClusterListView * pclv) const;

	const CString &			StrName(void) const;

// Operations
public:
	int						IliInsertInList(IN OUT CClusterListView * pclv);
	void					RemoveFromAllLists(void);
	void					PreRemoveFromList(IN OUT CClusterListView * pclv);
	virtual void			UpdateState(void);
	void					UpdateUIState(void);

	CMenu *					PmenuPopup(void);
	void					EditLabel(IN OUT CClusterListView * pclv);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListItem)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListItem(void);

protected:
	// Generated message map functions
	//{{AFX_MSG(CListItem)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CListItem

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void DeleteAllItemData(IN OUT CListItemList & rlp);

/////////////////////////////////////////////////////////////////////////////

#endif // _LISTITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\lcprwpag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		LCPrWPag.h
//
//	Abstract:
//		Definition of the CListCtrlPairWizPage dialog class.
//
//	Implementation File:
//		LCPrWPag.cpp
//
//	Author:
//		David Potter (davidp)	August 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPRWPAG_H_
#define _LCPRWPAG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BaseWPag.h"	// for CBaseWizardPage
#endif

#ifndef _LCPAIR_H_
#include "LCPair.h"		// for PFNLCPGETCOLUMN, CListCtrlPair
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairWizPage;

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairWizPage dialog
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairWizPage : public CBaseWizardPage
{
	DECLARE_DYNCREATE(CListCtrlPairWizPage)

// Construction
public:
	CListCtrlPairWizPage(void);
	CListCtrlPairWizPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN DWORD			dwStyle,
		IN PFNLCPGETCOLUMN	pfnGetColumn,
		IN PFNLCPDISPPROPS	pfnDisplayProps
		);
	~CListCtrlPairWizPage(void);

// Attributes
protected:
	CClusterItemList *			m_plpobjRight;
	const CClusterItemList *	m_plpobjLeft;
	DWORD						m_dwStyle;
	PFNLCPGETCOLUMN				m_pfnGetColumn;
	PFNLCPDISPPROPS				m_pfnDisplayProps;

	BOOL						BIsStyleSet(IN DWORD dwStyle) const	{ return (m_dwStyle & dwStyle) == dwStyle; }

	CListCtrlPair::CColumnArray	m_aColumns;

public:
	BOOL				BOrdered(void) const		{ return BIsStyleSet(LCPS_ORDERED); }
	BOOL				BCanBeOrdered(void) const	{ return BIsStyleSet(LCPS_CAN_BE_ORDERED); }
	int					NAddColumn(IN IDS idsText, IN int nWidth);

	void				SetLists(IN OUT CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);
	void				SetLists(IN const CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);

// Dialog Data
	//{{AFX_DATA(CListCtrlPairWizPage)
	enum { IDD = 0 };
	//}}AFX_DATA

protected:
	CListCtrlPair *		m_plcp;

public:
	CListCtrlPair *		Plcp(void) const		{ return m_plcp; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCtrlPairWizPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CListCtrlPairWizPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CListCtrlPairWizPage

/////////////////////////////////////////////////////////////////////////////

#endif // _LCPRWPAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\listitem.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ListItem.cpp
//
//	Abstract:
//		Implementation of the CListItem class.
//
//	Author:
//		David Potter (davidp)	May 6, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ListItem.h"
#include "ClusItem.h"
#include "ListItem.inl"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag g_tagListItem(_T("Document"), _T("LIST ITEM"), 0);
CTraceTag g_tagListItemCreate(_T("Create"), _T("LIST ITEM CREATE"), 0);
CTraceTag g_tagListItemDelete(_T("Delete"), _T("LIST ITEM DELETE"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CListItem
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CListItem, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListItem, CCmdTarget)
	//{{AFX_MSG_MAP(CListItem)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::CListItem
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem::CListItem(void)
{
	m_ptiParent = NULL;
	m_pci = NULL;

}  //*** CListItem::CListItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::CListItem
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pci			[IN OUT] Cluster item represented by this item.
//		ptiParent	[IN OUT] Parent tree item to which this item belongs.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem::CListItem(IN OUT CClusterItem * pci, IN OUT CTreeItem * ptiParent)
{
	ASSERT_VALID(ptiParent);
	ASSERT_VALID(pci);

	m_ptiParent = ptiParent;
	m_pci = pci;

	Trace(g_tagListItemCreate, _T("CListItem() - Creating '%s', parent = '%s'"), pci->StrName(), (ptiParent ? ptiParent->Pci()->StrName() : _T("<None>")));

}  //*** CListItem::CListItem(pci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::~CListItem
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem::~CListItem(void)
{
	Trace(g_tagListItemDelete, _T("~CListItem() - Deleting list item '%s', parent = '%s'"), (Pci() != NULL ? Pci()->StrName() : _T("<Unknown>")), (PtiParent()->Pci() != NULL ? PtiParent()->Pci()->StrName() : _T("<Unknown>")));

	// Remove ourselves from all views.
	RemoveFromAllLists();

}  //*** CListItem::~CListItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::Ili
//
//	Routine Description:
//		Returns the index of the item in the specified list view.
//
//	Arguments:
//		pclv		[IN OUT] List view in which to search for the item.
//
//	Return Value:
//		ili			Index of the item, or -1 if it was not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CListItem::Ili(CClusterListView * pclv) const
{
	LV_FINDINFO		lvfi;
	int				ili;

	lvfi.flags = LVFI_PARAM;
	lvfi.lParam = (LPARAM) this;

	ili = pclv->GetListCtrl().FindItem(&lvfi);
	Trace(g_tagListItem, _T("Item index = %d"), ili);
	return ili;

}  //*** CListItem::Ili()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::IliInsertInList
//
//	Routine Description:
//		Insert the item in a list.
//
//	Arguments:
//		pclv		[IN OUT] Cluster list view item is being added to.
//
//	Return Value:
//		ili			Index of the new item in the list, or -1 if unsuccessful.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CListItem::IliInsertInList(IN OUT CClusterListView * pclv)
{
	POSITION		posColi;
	CColumnItem *	pcoli;
	CString			strColumnData;
	int				ili;
	int				iliReturn;

	ASSERT_VALID(Pci());
	ASSERT(Ili(pclv) == -1);	// Make sure we aren't in that list yet.

	// Determine the index of this item.
	ili = Plc(pclv)->GetItemCount();

	// Save a pointer to the list view to which we are being added.
	if (LpclvViews().Find(pclv) == NULL)
		LpclvViews().AddTail(pclv);

	// Get the first column's data.
	VERIFY((posColi = Lpcoli().GetHeadPosition()) != NULL);
	VERIFY((pcoli = Lpcoli().GetNext(posColi)) != NULL);
	Pci()->BGetColumnData(pcoli->Colid(), strColumnData);

	// Insert the item into the list and add the first column.
	// The rest of the columns get added by the call to UpdateState().
	VERIFY((iliReturn
				= Plc(pclv)->InsertItem(
						LVIF_TEXT | LVIF_PARAM,		// nMask
						ili,						// nItem
						strColumnData,				// lpszItem
						0,							// nState
						0,							// nStateMask
						0,							// nImage
						(LPARAM) this				// lParam
						)) != -1);

	// Add ourselves to the cluster item's list.
	Pci()->AddListItem(this);

	UpdateState();
	return iliReturn;

}  //*** CListItem::IliInsertInList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::RemoveFromAllLists
//
//	Routine Description:
//		Remove the item from all lists.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::RemoveFromAllLists(void)
{
	ASSERT_VALID(Pci());

	// Loop through each view and remove the item from the list.
	{
		int					ili;
		POSITION			posView;
		POSITION			posViewPrev;
		CClusterListView *	pclv;

		posView = LpclvViews().GetHeadPosition();
		while (posView != NULL)
		{
			// Get the next list view list entry.
			posViewPrev = posView;
			pclv = LpclvViews().GetNext(posView);
			ASSERT_VALID(pclv);

			ili = Ili(pclv);
			ASSERT(ili != -1);

			// Delete the item.
			VERIFY(pclv->GetListCtrl().DeleteItem(ili));
			LpclvViews().RemoveAt(posViewPrev);
		}  // while:  more lists
	}  // Loop through each view and remove the item from the list

	// Remove ourselves from the cluster item's list.
	Pci()->RemoveListItem(this);

	// Remove ourselves from the tree's list.
//	PtiParent()->RemoveChild(Pci());

}  //*** CListItem::RemoveFromAllLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::PreRemoveFromList
//
//	Routine Description:
//		Prepare to remove the item from a list.
//
//	Arguments:
//		pclv		[IN OUT] Cluster list view item is being removed from.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::PreRemoveFromList(IN OUT CClusterListView * pclv)
{
	POSITION	posView;

	ASSERT_VALID(pclv);
	ASSERT_VALID(Pci());

	// Find the view in our list.
	VERIFY((posView = LpclvViews().Find(pclv)) != NULL);

	// Remove ourselves from the cluster item's list if this is the last view.
//	if (LpclvViews().GetCount() == 1)
//	{
//		Pci()->RemoveListItem(this);
//	}  // if:  this is the last view

	// Remove the view from the list.
	LpclvViews().RemoveAt(posView);

}  //*** CListItem::PreRemoveFromList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::UpdateState
//
//	Routine Description:
//		Update the current state of the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::UpdateState(void)
{
	ASSERT_VALID(Pci());

	// Ask the item to update its state.
	Pci()->UpdateState();

}  //*** CListItem::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::UpdateUIState
//
//	Routine Description:
//		Update the current UI state of the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::UpdateUIState(void)
{
	BOOL				bSuccess;
	POSITION			posView;
	POSITION			posColi;
	CColumnItem *		pcoli;
	int					icoli;
	int					ili;
	CString				strColumnData;
	UINT				nImage;
	UINT				nMask;
	CClusterListView *	pclv;
	CListCtrl *			plc;

	ASSERT_VALID(Pci());
//	ASSERT(LpclvViews().GetCount() > 0);

	// Loop through the views and update the state on each one.
	posView = LpclvViews().GetHeadPosition();
	while (posView != NULL)
	{
		// Get the pointers to the view and the list control.
		VERIFY((pclv = LpclvViews().GetNext(posView)) != NULL);
		ASSERT_KINDOF(CClusterListView, pclv);
		plc = Plc(pclv);

		// Get the item index.
		VERIFY((ili = Ili(pclv)) != -1);

		// Set the column data.
		VERIFY((posColi = Lpcoli().GetHeadPosition()) != NULL);
		for (icoli = 0 ; posColi != NULL ; icoli++)
		{
			VERIFY((pcoli = Lpcoli().GetNext(posColi)) != NULL);
			ASSERT_KINDOF(CColumnItem, pcoli);

			bSuccess = Pci()->BGetColumnData(pcoli->Colid(), strColumnData);
			if (!bSuccess)
			{
				Trace(g_tagListItem, _T("IliInsertInList: Column #%d (ID %d) not available for %s '%s'"), icoli, pcoli->Colid(), Pci()->StrType(), Pci()->StrName());
			}  // if:  column data not available
			if (icoli == 0)
			{
				nMask = LVIF_TEXT | LVIF_IMAGE;
				nImage = Pci()->IimgState();
			}  // if:  first column
			else
			{
				nMask = LVIF_TEXT;
				nImage = (UINT) -1;
			}  // else:  not first column
			VERIFY(plc->SetItem(
							ili,			// nItem
							icoli,			// nSubItem
							nMask,			// nMask
							strColumnData,	// lpszItem
							nImage,			// nImage
							0,				// nState
							0,				// nStateMask
							0				// lParam
							));
		}  // for:  each column item in the list
	}  // while:  more views

}  //*** CListItem::UpdateUIState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::OnCmdMsg
//
//	Routine Description:
//		Processes command messages.  Attempts to pass them on to a selected
//		item first.
//
//	Arguments:
//		nID				[IN] Command ID.
//		nCode			[IN] Notification code.
//		pExtra			[IN OUT] Used according to the value of nCode.
//		pHandlerInfo	[OUT] ???
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListItem::OnCmdMsg(
	UINT					nID,
	int						nCode,
	void *					pExtra,
	AFX_CMDHANDLERINFO *	pHandlerInfo
	)
{
	ASSERT_VALID(Pci());

	// Give the cluster item a chance to handle the message.
	if (Pci()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	return CCmdTarget::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

}  //*** CListItem::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::EditLabel
//
//	Routine Description:
//		Processes the ID_FILE_RENAME menu command.
//
//	Arguments:
//		pclv		[IN OUT] Cluster list view item is being edited in.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::EditLabel(IN OUT CClusterListView * pclv)
{
	ASSERT_VALID(pclv);
	ASSERT_VALID(Pci());

	ASSERT(Pci()->BCanBeEdited());
	pclv->GetListCtrl().EditLabel(Ili(pclv));

}  //*** CListItem::EditLabel()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DeleteAllItemData
//
//	Routine Description:
//		Deletes all item data in a CList.
//
//	Arguments:
//		rlp		[IN OUT] List whose data is to be deleted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData(IN OUT CListItemList & rlp)
{
	POSITION	pos;
	CListItem *	pli;

	// Delete all the items in the list.
	pos = rlp.GetHeadPosition();
	while (pos != NULL)
	{
		pli = rlp.GetNext(pos);
		ASSERT_VALID(pli);
//		Trace(g_tagListItemDelete, _T("DeleteAllItemData(rlpli) - Deleting list item '%s'"), pli->Pci()->StrName());
		delete pli;
	}  // while:  more items in the list

}  //*** DeleteAllItemData()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\listview.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ListView.h
//
//	Abstract:
//		Definition of the CClusterListView class.
//
//	Implementation File:
//		ListView.cpp
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LISTVIEW_H_
#define _LISTVIEW_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterListView;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CColumnItem;
class CClusterDoc;
class CTreeItem;
class CSplitterFrame;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CClusterListView *, CClusterListView *> CClusterListViewList;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#include "TreeItem.h"	// for CTreeItem
#endif

#ifndef _SPLITFRM_H
#include "SplitFrm.h"	// for CSplitterFrame
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterListView view
/////////////////////////////////////////////////////////////////////////////

class CClusterListView : public CListView
{
	friend class CListItem;
	friend class CClusterDoc;
	friend class CSplitterFrame;

protected:
	CClusterListView(void);			// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CClusterListView)

// Attributes
protected:
	CTreeItem *			m_ptiParent;
	int					m_nColumns;
	CSplitterFrame *	m_pframe;

	BOOL				BDragging(void) const		{ ASSERT_VALID(Pframe()); return Pframe()->BDragging(); }
	CImageList *		Pimagelist(void) const		{ ASSERT_VALID(Pframe()); return Pframe()->Pimagelist(); }

public:
	CClusterDoc *		GetDocument(void);
	CSplitterFrame *	Pframe(void) const			{ return m_pframe; }
	CListItem *			PliFocused(void) const;
	int					IliFocused(void) const	{ return GetListCtrl().GetNextItem(-1, LVNI_FOCUSED); }
	CTreeItem *			PtiParent(void) const	{ return m_ptiParent; }

// Operations
public:
	void				Refresh(IN OUT CTreeItem * ptiSelected);
	BOOL				DeleteAllItems(void);
	void				SaveColumns(void);
	void				SetView(IN DWORD dwView);
	int					GetView(void) const		{ return (GetWindowLong(GetListCtrl().m_hWnd, GWL_STYLE) & LVS_TYPEMASK); }

	CMenu *				PmenuPopup(
							IN CPoint &			rpointScreen,
							OUT CClusterItem *&	rpci
							);

protected:
	void				AddColumns(void);

//	CMenu *				PmenuPopup(void);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClusterListView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnInitialUpdate();
	protected:
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CClusterListView(void);
#ifdef _DEBUG
	virtual void		AssertValid(void) const;
	virtual void		Dump(CDumpContext& dc) const;
#endif

	static int CALLBACK	CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);
	int					m_nSortDirection;
	CColumnItem *		m_pcoliSort;

	// Label editing.
	CListItem *			m_pliBeingEdited;
	BOOL				m_bShiftPressed;
	BOOL				m_bControlPressed;
	BOOL				m_bAltPressed;
	MSG					m_msgControl;

	// Drag & drop.
	int					m_iliDrag;
	CListItem *			m_pliDrag;
	int					m_iliDrop;
	CPoint				m_ptDragHotSpot;
	void				OnMouseMoveForDrag(IN UINT nFlags, IN CPoint point, IN const CWnd * pwndDrop);
	void				OnButtonUpForDrag(IN UINT nFlags, IN CPoint point);
	void				BeginDrag(void);
	void				EndDrag(void);

	int					NSortDirection(void) const	{ return m_nSortDirection; }
	CColumnItem *		PcoliSort(void) const		{ return m_pcoliSort; }

	// Generated message map functions
protected:
	//{{AFX_MSG(CClusterListView)
	afx_msg void OnDestroy();
	afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblClk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OpenItem();
	afx_msg void OnBeginLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	afx_msg void OnCmdProperties();
	afx_msg void OnCmdRename();
	afx_msg void OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CClusterListView

#ifndef _DEBUG  // debug version in TreeView.cpp
inline CClusterDoc * CClusterListView::GetDocument(void)
   { return (CClusterDoc *) m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _LISTVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\mainfrm.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      MainFrm.h
//
//  Abstract:
//      Definition of the CMainFrame class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _MAINFRM_H_
#define _MAINFRM_H_

/////////////////////////////////////////////////////////////////////////////
// Class CMainFrame
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CMDIFrameWnd
{
    DECLARE_DYNAMIC(CMainFrame)
public:
    CMainFrame(void);

// Attributes
public:

// Operations
public:

    // For customizing the default messages on the status bar
    virtual void    GetMessageString(UINT nID, CString& rMessage) const;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    //}}AFX_VIRTUAL

// Implementation
public:
#ifdef _DEBUG
    virtual void    AssertValid() const;
    virtual void    Dump(CDumpContext& dc) const;
#endif

protected:
    // control bar embedded members
    CStatusBar      m_wndStatusBar;
    CToolBar        m_wndToolBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnClose();
    afx_msg void OnHelp();
    //}}AFX_MSG
    afx_msg LRESULT OnRestoreDesktop(WPARAM wparam, LPARAM lparam);
    afx_msg LRESULT OnClusterNotify(WPARAM wparam, LPARAM lparam);
    DECLARE_MESSAGE_MAP()

};  //*** class CMainFrame

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

BOOL ReadWindowPlacement(OUT LPWINDOWPLACEMENT pwp, IN LPCTSTR pszSection, IN DWORD nValueNum);
void WriteWindowPlacement(IN const LPWINDOWPLACEMENT pwp, IN LPCTSTR pszSection, IN DWORD nValueNum);

/////////////////////////////////////////////////////////////////////////////

#endif // _MAINFRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\mainfrm.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      MainFrm.cpp
//
//  Abstract:
//      Implementation of the CMainFrame class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "MainFrm.h"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagMainFrame(TEXT("UI"), TEXT("MAIN FRAME"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
    // Global help commands
    ON_COMMAND(ID_HELP_FINDER, OnHelp)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnHelp)
    ON_MESSAGE(WM_CAM_RESTORE_DESKTOP, OnRestoreDesktop)
    ON_MESSAGE(WM_CAM_CLUSTER_NOTIFY, OnClusterNotify)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMainFrame::CMainFrame
//
//  Routine Description:
//      Default construtor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMainFrame::CMainFrame(void)
{
}  //*** CMainFrame::CMainFrame()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMainFrame::OnCreate
//
//  Routine Description:
//      Handler for the WM_CREATE message.  Create the contents of the frame,
//      including toolbars, status bars, etc.
//
//  Arguments:
//      lpCreateStruct  Pointer to a CREATESTRUCT.
//
//  Return Value:
//      -1      Failed to create.
//      0       Created successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    int     nCreateStatus = -1;

    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
    {
        goto Cleanup;
    }
    
    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        Trace(g_tagMainFrame, _T("Failed to create toolbar"));
        goto Cleanup;      // fail to create
    }

    if (!m_wndStatusBar.Create(this)
            || !m_wndStatusBar.SetIndicators(
                                indicators,
                                sizeof(indicators)/sizeof(UINT)
                                ))
    {
        Trace(g_tagMainFrame, _T("Failed to create status bar"));
        goto Cleanup;      // fail to create
    }

    // TODO: Remove this if you don't want tool tips or a resizeable toolbar
    m_wndToolBar.SetBarStyle(
                    m_wndToolBar.GetBarStyle()
                    | CBRS_TOOLTIPS
                    | CBRS_FLYBY
                    | CBRS_SIZE_DYNAMIC
                    );

    // TODO: Delete these three lines if you don't want the toolbar to
    //  be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    // Hide the toolbar and/or status bar is that is the current setting.
    {
        BOOL    bShowToolBar;
        BOOL    bShowStatusBar;

        // Read the settings from the user's profile.
        bShowToolBar = AfxGetApp()->GetProfileInt(
                                        REGPARAM_SETTINGS,
                                        REGPARAM_SHOW_TOOL_BAR,
                                        TRUE
                                        );
        bShowStatusBar = AfxGetApp()->GetProfileInt(
                                        REGPARAM_SETTINGS,
                                        REGPARAM_SHOW_STATUS_BAR,
                                        TRUE
                                        );

        // Show or hide the toolbar and status bar.
        m_wndToolBar.ShowWindow(bShowToolBar);
        m_wndStatusBar.ShowWindow(bShowStatusBar);
    }  // Hide the toolbar and/or status bar is that is the current setting

    nCreateStatus = 0;

Cleanup:

    return nCreateStatus;

}  //*** CMainFrame::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMainFrame::GetMessageString
//
//  Routine Description:
//      Get a string for a command ID.
//
//  Arguments:
//      nID         [IN] Command ID for which a string should be returned.
//      rMessage    [OUT] String in which to return the message.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMainFrame::GetMessageString(UINT nID, CString& rMessage) const
{
    CFrameWnd * pframe;

    // Pass off to the active MDI child frame window, if there is one.
    pframe = MDIGetActive();
    if (pframe == NULL)
    {
        CMDIFrameWnd::GetMessageString(nID, rMessage);
    }
    else
    {
        pframe->GetMessageString(nID, rMessage);
    }

}  //*** CMainFrame::GetMessageString()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
void CMainFrame::AssertValid(void) const
{
    CMDIFrameWnd::AssertValid();

}  //*** CMainFrame::AssertValid()

void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);

}  //*** CMainFrame::Dump()

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMainFrame::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnClose(void)
{
    // Save the current window position and size.
    {
        WINDOWPLACEMENT wp;
        wp.length = sizeof wp;
        if (GetWindowPlacement(&wp))
        {
            wp.flags = 0;
            if (IsZoomed())
            {
                wp.flags |= WPF_RESTORETOMAXIMIZED;
            }
            if (IsIconic())
            {
                wp.showCmd = SW_SHOWMINNOACTIVE;
            }

            // and write it to the .INI file
            WriteWindowPlacement(&wp, REGPARAM_SETTINGS, 0);
        }  // if:  window placement retrieved successfully
    }  // Save the current window position and size

    // Save the current connections.
    GetClusterAdminApp()->SaveConnections();

    // Save the current toolbar and status bar show state.
    AfxGetApp()->WriteProfileInt(
                    REGPARAM_SETTINGS,
                    REGPARAM_SHOW_TOOL_BAR,
                    ((m_wndToolBar.GetStyle() & WS_VISIBLE) ? TRUE : FALSE)
                    );
    AfxGetApp()->WriteProfileInt(
                    REGPARAM_SETTINGS,
                    REGPARAM_SHOW_STATUS_BAR,
                    ((m_wndStatusBar.GetStyle() & WS_VISIBLE) ? TRUE : FALSE)
                    );

    CMDIFrameWnd::OnClose();

}  //*** CMainFrame::OnClose()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMainFrame::OnRestoreDesktop
//
//  Routine Description:
//      Handler for the WM_CAM_RESTORE_DESKTOP message.
//      Restores the desktop from the saved parameters.
//
//  Arguments:
//      wparam      1st parameter.
//      lparam      2nd parameter.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnRestoreDesktop(WPARAM wparam, LPARAM lparam)
{
    // Call this method on the application.
    return GetClusterAdminApp()->OnRestoreDesktop(wparam, lparam);

}  //*** CMainFrame::OnRestoreDesktop()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMainFrame::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications.
//
//  Arguments:
//      wparam      1st parameter.
//      lparam      2nd parameter.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnClusterNotify(WPARAM wparam, LPARAM lparam)
{
    CClusterAdminApp *  papp    = GetClusterAdminApp();

    // Call this method on the application.
    return papp->OnClusterNotify(wparam, lparam);

}  //*** CMainFrame::OnClusterNotify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMainFrame::OnHelp
//
//  Routine Description:
//      Handler for the IDM_HELP_FINDER menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnHelp(void)
{
    HtmlHelpW( m_hWnd, _T("MSCSConcepts.chm"), HH_DISPLAY_TOPIC, 0L );

}  //*** CMainFrame::OnHelp()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Helpers for saving/restoring window state

static TCHAR g_szFormat[] = _T("%u,%u,%d,%d,%d,%d,%d,%d,%d,%d");

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ReadWindowPlacement
//
//  Routine Description:
//      Read window placement parameters.
//
//  Arguments:
//      pwp         [OUT] WINDOWPLACEMENT structure to fill.
//      pszSection  [IN] Section name under which to read data.
//      nValueNum   [IN] Number of the value to read.
//
//  Return Value:
//      TRUE        Parameters read.
//      FALSE       Parameters not read.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL ReadWindowPlacement(
    OUT LPWINDOWPLACEMENT   pwp,
    IN LPCTSTR              pszSection,
    IN DWORD                nValueNum
    )
{
    CString strBuffer;
    CString strValueName;
    BOOL    bParametersRead = FALSE;

    if (nValueNum <= 1)
    {
        strValueName = REGPARAM_WINDOW_POS;
    }
    else
    {
        strValueName.Format(REGPARAM_WINDOW_POS _T("-%d"), nValueNum);
    }

    strBuffer = AfxGetApp()->GetProfileString(pszSection, strValueName);
    if (strBuffer.IsEmpty())
    {
        goto Cleanup;
    }

    WINDOWPLACEMENT wp;
    int nRead = _stscanf(strBuffer, g_szFormat,
        &wp.flags, &wp.showCmd,
        &wp.ptMinPosition.x, &wp.ptMinPosition.y,
        &wp.ptMaxPosition.x, &wp.ptMaxPosition.y,
        &wp.rcNormalPosition.left, &wp.rcNormalPosition.top,
        &wp.rcNormalPosition.right, &wp.rcNormalPosition.bottom);

    if (nRead != 10)
    {
        goto Cleanup;
    }

    wp.length = sizeof wp;
    *pwp = wp;
    bParametersRead = TRUE;

Cleanup:

    return bParametersRead;

}  //*** ReadWindowPlacement()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  WriteWindowPlacement
//
//  Routine Description:
//      Write window placement parameters.
//
//  Arguments:
//      pwp         [IN] WINDOWPLACEMENT structure to save.
//      pszSection  [IN] Section name under which to write data.
//      nValueNum   [IN] Number of the value to write.
//
//  Return Value:
//      TRUE        Parameters read.
//      FALSE       Parameters not read.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WriteWindowPlacement(
    IN const LPWINDOWPLACEMENT  pwp,
    IN LPCTSTR                  pszSection,
    IN DWORD                    nValueNum
    )
{
    TCHAR szBuffer[sizeof("-32767")*8 + sizeof("65535")*2];
    CString strBuffer;
    CString strValueName;
    HRESULT hr;

    if (nValueNum <= 1)
        strValueName = REGPARAM_WINDOW_POS;
    else
        strValueName.Format(REGPARAM_WINDOW_POS _T("-%d"), nValueNum);

    hr = StringCchPrintf(szBuffer, RTL_NUMBER_OF( szBuffer ), g_szFormat,
        pwp->flags, pwp->showCmd,
        pwp->ptMinPosition.x, pwp->ptMinPosition.y,
        pwp->ptMaxPosition.x, pwp->ptMaxPosition.y,
        pwp->rcNormalPosition.left, pwp->rcNormalPosition.top,
        pwp->rcNormalPosition.right, pwp->rcNormalPosition.bottom);
    AfxGetApp()->WriteProfileString(pszSection, strValueName, szBuffer);

}  //*** WriteWindowPlacement()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\modnodes.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ModNodes.cpp
//
//	Abstract:
//		Implementation of the CModifyNodesDlg dialog.
//
//	Author:
//		David Potter (davidp)	July 16, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ModNodes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CModifyNodesDlg
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CModifyNodesDlg, CListCtrlPairDlg)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CModifyNodesDlg, CListCtrlPairDlg)
	//{{AFX_MSG_MAP(CModifyNodesDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::CModifyNodesDlg
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CModifyNodesDlg::CModifyNodesDlg(void)
{
}  //*** CModifyNodesDlg::CModifyNodesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::CModifyNodesDlg
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog ID.
//		pdwHelpMap		[IN] Control-to-Help ID mapping array.
//		rlpciRight		[IN OUT] List for the right list control.
//		rlpciLeft		[IN] List for the left list control.
//		dwStyle			[IN] Style:
//							LCPS_SHOW_IMAGES	Show images to left of items.
//							LCPS_ALLOW_EMPTY	Allow right list to be empty.
//							LCPS_ORDERED		Ordered right list.
//		pParent			[IN OUT] Parent window.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CModifyNodesDlg::CModifyNodesDlg(
	IN UINT					idd,
	IN const DWORD *		pdwHelpMap,
	IN OUT CNodeList &		rlpciRight,
	IN const CNodeList &	rlpciLeft,
	IN DWORD				dwStyle,
	IN OUT CWnd *			pParent /*=NULL*/
	) : CListCtrlPairDlg(
			idd,
			pdwHelpMap,
			&rlpciRight,
			&rlpciLeft,
			dwStyle | LCPS_PROPERTIES_BUTTON | (dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
			GetColumn,
			BDisplayProperties,
			pParent
			)
{
	//{{AFX_DATA_INIT(CModifyNodesDlg)
	//}}AFX_DATA_INIT

}  //*** CModifyNodesDlg::CModifyNodesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CModifyNodesDlg::OnInitDialog(void)
{
	// Add columns.
	try
	{
		NAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
	}  // catch:  CException

	// Call the base class method.
	CListCtrlPairDlg::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CModifyNodesDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::GetColumn [static]
//
//	Routine Description:
//		Returns a column for an item.
//
//	Arguments:
//		pobj		[IN OUT] Object for which the column is to be displayed.
//		iItem		[IN] Index of the item in the list.
//		icol		[IN] Column number whose text is to be retrieved.
//		pdlg		[IN OUT] Dialog to which object belongs.
//		rstr		[OUT] String in which to return column text.
//		piimg		[OUT] Image index for the object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CModifyNodesDlg::GetColumn(
	IN OUT CObject *	pobj,
	IN int				iItem,
	IN int				icol,
	IN OUT CDialog *	pdlg,
	OUT CString &		rstr,
	OUT int *			piimg
	)
{
	CClusterNode *	pciNode	= (CClusterNode *) pobj;

	ASSERT_VALID(pciNode);
	ASSERT(icol == 0);

	pciNode->BGetColumnData(IDS_COLTEXT_NAME, rstr);
	if (piimg != NULL)
		*piimg = pciNode->IimgObjectType();

}  //*** CModifyNodesDlg::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::BDisplayProperties [static]
//
//	Routine Description:
//		Display the properties of the specified object.
//
//	Arguments:
//		pobj	[IN OUT] Cluster item whose properties are to be displayed.
//
//	Return Value:
//		TRUE	Properties where accepted.
//		FALSE	Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CModifyNodesDlg::BDisplayProperties(IN OUT CObject * pobj)
{
	CClusterItem *	pci = (CClusterItem *) pobj;

	ASSERT_KINDOF(CClusterItem, pobj);

	return pci->BDisplayProperties();

}  //*** CModifyNodesDlg::BDisplayProperties();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\modnodes.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ModNodes.cpp
//
//	Abstract:
//		Definition of the CModifyNodesDlg dialog.
//
//	Implementation File:
//		ModNodes.h
//
//	Author:
//		David Potter (davidp)	July 16, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _MODNODES_H_
#define _MODNODES_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _NODE_H_
#include "Node.h"		// for CNodeList
#endif

#ifndef _LCPRDLG_H_
#include "LCPrDlg.h"	// for CListCtrlPairDlg
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CModifyNodesDlg;

/////////////////////////////////////////////////////////////////////////////
// CModifyNodesDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CModifyNodesDlg : public CListCtrlPairDlg
{
	DECLARE_DYNCREATE(CModifyNodesDlg)

// Construction
public:
	CModifyNodesDlg(void);
	CModifyNodesDlg::CModifyNodesDlg(
		IN UINT					idd,
		IN const DWORD *		pdwHelpMap,
		IN OUT CNodeList &		rlpciRight,
		IN const CNodeList &	rlpciLeft,
		IN DWORD				dwStyle,
		IN OUT CWnd *			pParent = NULL
		);

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Dialog Data
	//{{AFX_DATA(CModifyNodesDlg)
	enum { IDD = 0 };
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CModifyNodesDlg)
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CModifyNodesDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CModifyNodesDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _MODNODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\modres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ModRes.cpp
//
//	Abstract:
//		Implementation of the CModifyResourcesDlg dialog.
//
//	Author:
//		David Potter (davidp)	November 26, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ModRes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CModifyResourcesDlg
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CModifyResourcesDlg, CListCtrlPairDlg)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CModifyResourcesDlg, CListCtrlPairDlg)
	//{{AFX_MSG_MAP(CModifyResourcesDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::CModifyResourcesDlg
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CModifyResourcesDlg::CModifyResourcesDlg(void)
{
}  //*** CModifyResourcesDlg::CModifyResourcesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::CModifyResourcesDlg
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog ID.
//		pdwHelpMap		[IN] Control-to-Help ID mapping array.
//		rlpciRight		[IN OUT] List for the right list control.
//		rlpciLeft		[IN] List for the left list control.
//		dwStyle			[IN] Style:
//							LCPS_SHOW_IMAGES	Show images to left of items.
//							LCPS_ALLOW_EMPTY	Allow right list to be empty.
//							LCPS_ORDERED		Ordered right list.
//		pParent			[IN OUT] Parent window.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CModifyResourcesDlg::CModifyResourcesDlg(
	IN UINT						idd,
	IN const DWORD *			pdwHelpMap,
	IN OUT CResourceList &		rlpciRight,
	IN const CResourceList &	rlpciLeft,
	IN DWORD					dwStyle,
	IN OUT CWnd *				pParent //=NULL
	) : CListCtrlPairDlg(
			idd,
			pdwHelpMap,
			&rlpciRight,
			&rlpciLeft,
			dwStyle | LCPS_PROPERTIES_BUTTON | (dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
			GetColumn,
			BDisplayProperties,
			pParent
			)
{
	//{{AFX_DATA_INIT(CModifyResourcesDlg)
	//}}AFX_DATA_INIT

}  //*** CModifyResourcesDlg::CModifyResourcesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CModifyResourcesDlg::OnInitDialog(void)
{
	// Add columns.
	try
	{
		NAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
		NAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
	}  // catch:  CException

	// Call the base class method.
	CListCtrlPairDlg::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CModifyResourcesDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::GetColumn [static]
//
//	Routine Description:
//		Returns a column for an item.
//
//	Arguments:
//		pobj		[IN OUT] Object for which the column is to be displayed.
//		iItem		[IN] Index of the item in the list.
//		icol		[IN] Column number whose text is to be retrieved.
//		pdlg		[IN OUT] Dialog to which object belongs.
//		rstr		[OUT] String in which to return column text.
//		piimg		[OUT] Image index for the object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CModifyResourcesDlg::GetColumn(
	IN OUT CObject *	pobj,
	IN int				iItem,
	IN int				icol,
	IN OUT CDialog *	pdlg,
	OUT CString &		rstr,
	OUT int *			piimg
	)
{
	CResource *	pciRes	= (CResource *) pobj;
	int			colid;

	ASSERT_VALID(pciRes);
	ASSERT((0 <= icol) && (icol <= 1));

	switch (icol)
	{
		// Sorting by resource name.
		case 0:
			colid = IDS_COLTEXT_RESOURCE;
			break;

		// Sorting by resource type.
		case 1:
			colid = IDS_COLTEXT_RESTYPE;
			break;

		default:
			colid = IDS_COLTEXT_RESOURCE;
			break;
	}  // switch:  icol

	pciRes->BGetColumnData(colid, rstr);
	if (piimg != NULL)
		*piimg = pciRes->IimgObjectType();

}  //*** CModifyResourcesDlg::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::BDisplayProperties [static]
//
//	Routine Description:
//		Display the properties of the specified object.
//
//	Arguments:
//		pobj	[IN OUT] Cluster item whose properties are to be displayed.
//
//	Return Value:
//		TRUE	Properties where accepted.
//		FALSE	Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CModifyResourcesDlg::BDisplayProperties(IN OUT CObject * pobj)
{
	CClusterItem *	pci = (CClusterItem *) pobj;

	ASSERT_KINDOF(CClusterItem, pobj);

	return pci->BDisplayProperties();

}  //*** CModifyResourcesDlg::BDisplayProperties();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\modres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ModRes.cpp
//
//	Abstract:
//		Definition of the CModifyResourcesDlg dialog.
//
//	Implementation File:
//		ModNodes.h
//
//	Author:
//		David Potter (davidp)	November 26, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _MODRES_H_
#define _MODRES_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RES_H_
#include "Res.h"		// for CResourceList
#endif

#ifndef _LCPRDLG_H_
#include "LCPrDlg.h"	// for CListCtrlPairDlg
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CModifyResourcesDlg;

/////////////////////////////////////////////////////////////////////////////
// CModifyResourcesDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CModifyResourcesDlg : public CListCtrlPairDlg
{
	DECLARE_DYNCREATE(CModifyResourcesDlg)

// Construction
public:
	CModifyResourcesDlg(void);
	CModifyResourcesDlg::CModifyResourcesDlg(
		IN UINT						idd,
		IN const DWORD *			pdwHelpMap,
		IN OUT CResourceList &		rlpciRight,
		IN const CResourceList &	rlpciLeft,
		IN DWORD					dwStyle,
		IN OUT CWnd *				pParent = NULL
		);

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Dialog Data
	//{{AFX_DATA(CModifyResourcesDlg)
	enum { IDD = 0 };
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CModifyResourcesDlg)
	//}}AFX_VIRTUAL

// Implementation
protected:
	IDS						m_idsTitle;

	IDS						IdsTitle(void) const		{ return m_idsTitle; }

	// Generated message map functions
	//{{AFX_MSG(CModifyResourcesDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CModifyResourcesDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _MODRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\moveres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      MoveRes.cpp
//
//  Abstract:
//      Implementation of the CMoveResourcesDlg class.
//
//  Author:
//      David Potter (davidp)   April 1, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "MoveRes.h"
#include "Res.h"
#include "ResType.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMoveResourcesDlg class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CMoveResourcesDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CMoveResourcesDlg)
    ON_NOTIFY(NM_DBLCLK, IDC_MR_RESOURCES_LIST, OnDblClkResourcesList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_MR_RESOURCES_LIST, OnColumnClick)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_BN_CLICKED(IDYES, CBaseDialog::OnOK)
    ON_BN_CLICKED(IDNO, CBaseDialog::OnCancel)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::CMoveResourcesDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pciRes      [IN] Resource being moved.
//      plpci       [IN] List of resources which are dependent on pciRes.
//      pParent     [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMoveResourcesDlg::CMoveResourcesDlg(
    IN CResource *              pciRes,
    IN const CResourceList *    plpci,
    IN OUT CWnd *               pParent /*=NULL*/
    )
    : CBaseDialog(IDD, g_aHelpIDs_IDD_MOVE_RESOURCES, pParent)
{
    //{{AFX_DATA_INIT(CMoveResourcesDlg)
    //}}AFX_DATA_INIT

    ASSERT_VALID(pciRes);
    ASSERT(plpci != NULL);

    m_pciRes = pciRes;
    m_plpci = plpci;

}  //*** CMoveResourcesDlg::CMoveResourcesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMoveResourcesDlg::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMoveResourcesDlg)
    DDX_Control(pDX, IDC_MR_RESOURCES_LIST, m_lcResources);
    //}}AFX_DATA_MAP

}  //*** CMoveResourcesDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CMoveResourcesDlg::OnInitDialog(void)
{
    int     nitem;

    CBaseDialog::OnInitDialog();

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        dwExtendedStyle = (DWORD)m_lcResources.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcResources.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    // Set the image list for the list control to use.
    m_lcResources.SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_SMALL);

    // Add the columns.
    {
        CString         strColumn;
        try
        {
            strColumn.LoadString(IDS_COLTEXT_NAME);
            m_lcResources.InsertColumn(0, strColumn, LVCFMT_LEFT, COLI_WIDTH_NAME * 3 / 2);
            strColumn.LoadString(IDS_COLTEXT_RESTYPE);
            m_lcResources.InsertColumn(1, strColumn, LVCFMT_LEFT, COLI_WIDTH_RESTYPE * 3 / 2);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // Add the columns

    // Add the resource being moved to the list.
    nitem = m_lcResources.InsertItem(0, PciRes()->StrName(), PciRes()->IimgObjectType());
    m_lcResources.SetItemText(nitem, 1, PciRes()->StrRealResourceTypeDisplayName());
    m_lcResources.SetItemData(nitem, (DWORD_PTR) PciRes());
    m_pciRes->AddRef();

    // Add the items.
    {
        POSITION        pos;
        int             iitem;
        CResource *     pciRes;

        pos = Plpci()->GetHeadPosition();
        for (iitem = 1 ; pos != NULL ; iitem++)
        {
            pciRes = (CResource *) Plpci()->GetNext(pos);
            ASSERT_VALID(pciRes);
            if (pciRes != PciRes())
            {
                nitem = m_lcResources.InsertItem(iitem, pciRes->StrName(), pciRes->IimgObjectType());
                m_lcResources.SetItemText(nitem, 1, pciRes->StrRealResourceTypeDisplayName());
                m_lcResources.SetItemData(nitem, (DWORD_PTR) pciRes);
                pciRes->AddRef();
            }  // if:  not resource being moved
        }  // while:  more items in the list
    }  // Add the items

    // Sort the items.
    m_nSortColumn = 0;
    m_nSortDirection = 0;
    m_lcResources.SortItems(CompareItems, (LPARAM) this);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CMoveResourcesDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMoveResourcesDlg::OnDestroy(void)
{
    // Dereference all the cluster item pointers.
    if (m_lcResources.m_hWnd != NULL)
    {
        int             ili = -1;
        CClusterItem *  pci;

        while ((ili = m_lcResources.GetNextItem(ili, LVNI_ALL)) != -1)
        {
            pci = (CClusterItem *) m_lcResources.GetItemData(ili);
            ASSERT_VALID(pci);
            ASSERT_KINDOF(CClusterItem, pci);

            pci->Release();
        }  // while:  more items in the list control
    }  // if:  list control has been instantiated

    CBaseDialog::OnDestroy();

}  //*** CMoveResourcesDlg::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::OnDblClkDependsList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMoveResourcesDlg::OnDblClkResourcesList(NMHDR * pNMHDR, LRESULT * pResult)
{
    int             iitem;
    CResource *     pciRes;

    // Get the item with the focus.
    iitem = m_lcResources.GetNextItem(-1, LVNI_FOCUSED);
    ASSERT(iitem != -1);

    if (iitem != -1)
    {
        // Get the resource pointer.
        pciRes = (CResource *) m_lcResources.GetItemData(iitem);
        ASSERT_VALID(pciRes);

        // Get properties of that item.
        pciRes->BDisplayProperties(FALSE /*bReadOnly*/);
    }  // if:  found an item with focus

    *pResult = 0;

}  //*** CMoveResourcesDlg::OnDblClkResourcesList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::OnColumnClick
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMoveResourcesDlg::OnColumnClick(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    if (m_lcResources.GetItemCount() != 0)
    {
        // Save the current sort column and direction.
        if (pNMListView->iSubItem == m_nSortColumn)
            m_nSortDirection ^= -1;
        else
        {
            m_nSortColumn = pNMListView->iSubItem;
            m_nSortDirection = 0;
        }  // else:  different column

        // Sort the list.
        m_lcResources.SortItems(CompareItems, (LPARAM) this);
    }  // if:  there are items in the list

    *pResult = 0;

}  //*** CMoveResourcesDlg::OnColumnClick()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CMoveResourcesDlg::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CResource *         pciRes1 = (CResource *) lparam1;
    CResource *         pciRes2 = (CResource *) lparam2;
    CMoveResourcesDlg * pdlg    = (CMoveResourcesDlg *) lparamSort;
    const CString *     pstr1;
    const CString *     pstr2;
    int                 nResult;

    ASSERT_VALID(pciRes1);
    ASSERT_VALID(pciRes2);
    ASSERT_VALID(pdlg);

    // Get the strings from the list items.
    if (pdlg->m_nSortColumn == 1)
    {
        pstr1 = &pciRes1->StrRealResourceTypeDisplayName();
        pstr2 = &pciRes2->StrRealResourceTypeDisplayName();
    }  //  if:  sorting on name column
    else
    {
        pstr1 = &pciRes1->StrName();
        pstr2 = &pciRes2->StrName();
    }  // else:  sorting on resource type column

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                *pstr1,
                pstr1->GetLength(),
                *pstr2,
                pstr2->GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (pdlg->m_nSortDirection != 0)
        nResult = -nResult;

    return nResult;

}  //*** CMoveResourcesDlg::CompareItems()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\netiface.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      NetIFace.cpp
//
//  Abstract:
//      Implementation of the CNetInterface class.
//
//  Author:
//      David Potter (davidp)   May 28, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "NetIFace.h"
#include "ClusItem.inl"
#include "Cluster.h"
#include "NetIProp.h"
#include "ExcOper.h"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagNetIFace(_T("Document"), _T("NETWORK INTERFACE"), 0);
CTraceTag   g_tagNetIFaceNotify(_T("Notify"), _T("NETIFACE NOTIFY"), 0);
CTraceTag   g_tagNetIFaceRegNotify(_T("Notify"), _T("NETIFACE REG NOTIFY"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetInterface
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetInterface, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetInterface, CClusterItem)
    //{{AFX_MSG_MAP(CNetInterface)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::CNetInterface
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterface::CNetInterface(void)
    : CClusterItem(NULL, IDS_ITEMTYPE_NETIFACE)
{
    CommonConstruct();

}  //*** CResoruce::CNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::CommonConstruct(void)
{
    m_idmPopupMenu = IDM_NETIFACE_POPUP;
    m_hnetiface = NULL;

    m_dwCharacteristics = CLUS_CHAR_UNKNOWN;
    m_dwFlags = 0;

    m_pciNode = NULL;
    m_pciNetwork = NULL;

    // Set the object type image.
    m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_NETIFACE);

    // Setup the property array.
    {
        m_rgProps[epropName].Set(CLUSREG_NAME_NETIFACE_NAME, m_strName, m_strName);
        m_rgProps[epropNode].Set(CLUSREG_NAME_NETIFACE_NODE, m_strNode, m_strNode);
        m_rgProps[epropNetwork].Set(CLUSREG_NAME_NETIFACE_NETWORK, m_strNetwork, m_strNetwork);
        m_rgProps[epropAdapter].Set(CLUSREG_NAME_NETIFACE_ADAPTER_NAME, m_strAdapter, m_strAdapter);
        m_rgProps[epropAddress].Set(CLUSREG_NAME_NETIFACE_ADDRESS, m_strAddress, m_strAddress);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_NETIFACE_DESC, m_strDescription, m_strDescription);
    }  // Setup the property array

}  //*** CNetInterface::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::~CNetInterface
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterface::~CNetInterface(void)
{
    // Cleanup this object.
    Cleanup();

    // Close the network interface handle.
    if (Hnetiface() != NULL)
        CloseClusterNetInterface(Hnetiface());

}  //*** CNetInterface::~CNetInterface

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::Cleanup(void)
{
    // Remove ourselves from the node's list.
    if (PciNode() != NULL)
    {
        PciNode()->RemoveNetInterface(this);
        PciNode()->Release();
        m_pciNode = NULL;
    }  // if:  there is a node

    // Remove ourselves from the network's list.
    if (PciNetwork() != NULL)
    {
        PciNetwork()->RemoveNetInterface(this);
        PciNetwork()->Release();
        m_pciNetwork = NULL;
    }  // if:  there is a network

    // Remove the item from the network interface list.
    {
        POSITION    posPci;

        posPci = Pdoc()->LpciNetInterfaces().Find(this);
        if (posPci != NULL)
        {
            Pdoc()->LpciNetInterfaces().RemoveAt(posPci);
        }  // if:  found in the document's list
    }  // Remove the item from the network interface list

}  //*** CNetInterface::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenClusterNetInterface() or
//      GetClusterNetInterfaceKey().
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LONG        lResult;
    CString     strName(lpszName);  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(Hnetiface() == NULL);
    ASSERT(Hkey() == NULL);

    // Call the base class method.
    CClusterItem::Init(pdoc, lpszName);

    try
    {
        // Open the network interface.
        m_hnetiface = OpenClusterNetInterface(Hcluster(), strName);
        if (Hnetiface() == NULL)
        {
            dwStatus = GetLastError();
            ThrowStaticException(dwStatus, IDS_OPEN_NETIFACE_ERROR, lpszName);
        }  // if:  error opening the cluster network interface

        // Get the network interface registry key.
        m_hkey = GetClusterNetInterfaceKey(Hnetiface(), MAXIMUM_ALLOWED);
        if (Hkey() == NULL)
            ThrowStaticException(GetLastError(), IDS_GET_NETIFACE_KEY_ERROR, lpszName);

        ASSERT(Pcnk() != NULL);
        Trace(g_tagClusItemNotify, _T("CNetInterface::Init() - Registering for network interface notifications (%08.8x) for '%s'"), Pcnk(), StrName());

        // Register for network interface notifications.
        lResult = RegisterClusterNotify(
                            GetClusterAdminApp()->HchangeNotifyPort(),
                            (     CLUSTER_CHANGE_NETINTERFACE_STATE
                                | CLUSTER_CHANGE_NETINTERFACE_DELETED
                                | CLUSTER_CHANGE_NETINTERFACE_PROPERTY),
                            Hnetiface(),
                            (DWORD_PTR) Pcnk()
                            );
        if (lResult != ERROR_SUCCESS)
        {
            dwStatus = lResult;
            ThrowStaticException(dwStatus, IDS_NETIFACE_NOTIF_REG_ERROR, lpszName);
        }  // if:  error registering for network interface notifications

        // Register for registry notifications.
        if (Hkey() != NULL)
        {
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (CLUSTER_CHANGE_REGISTRY_NAME
                                    | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                    | CLUSTER_CHANGE_REGISTRY_VALUE
                                    | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                Hkey(),
                                (DWORD_PTR) Pcnk()
                                );
            if (lResult != ERROR_SUCCESS)
            {
                dwStatus = lResult;
                ThrowStaticException(dwStatus, IDS_NETIFACE_NOTIF_REG_ERROR, lpszName);
            }  // if:  error registering for registry notifications
        }  // if:  there is a key

        // Read the initial state.
        UpdateState();
    }  // try
    catch (CException *)
    {
        if (Hkey() != NULL)
        {
            ClusterRegCloseKey(Hkey());
            m_hkey = NULL;
        }  // if:  registry key opened
        if (Hnetiface() != NULL)
        {
            CloseClusterNetInterface(Hnetiface());
            m_hnetiface = NULL;
        }  // if:  network interface opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CNetInterface::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//      Any exceptions thrown by ConstructList or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::ReadItem(void)
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT_VALID(this);

    if (Hnetiface() != NULL)
    {
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;

        // Call the base class method.
        CClusterItem::ReadItem();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNetInterfaceProperties(
                                Hnetiface(),
                                CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
                dwStatus = DwParseProperties(cpl);
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
        }  // Read and parse the common properties

        // Read and parse the read-only common properties.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNetInterfaceProperties(
                                Hnetiface(),
                                CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
                dwStatus = DwParseProperties(cpl);
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
        }  // if:  no error yet

        // Find the node object.
        {
            CClusterNode *  pciNode;

            pciNode = Pdoc()->LpciNodes().PciNodeFromName(StrNode());
            if (pciNode != m_pciNode)
            {
                if (m_pciNode != NULL)
                {
                    m_pciNode->RemoveNetInterface(this);
                    m_pciNode->Release();
                }  // if:  old node
                m_pciNode = pciNode;
                if (m_pciNode != NULL)
                {
                    m_pciNode->AddRef();
                    m_pciNode->AddNetInterface(this);
                }  // if:  new node
            }  // if:  node changed (should never happen)
        }  // Find the node object

        // Find the network object.
        {
            CNetwork *  pciNetwork;

            pciNetwork = Pdoc()->LpciNetworks().PciNetworkFromName(StrNetwork());
            if (pciNetwork != m_pciNetwork)
            {
                if (m_pciNetwork != NULL)
                {
                    m_pciNetwork->RemoveNetInterface(this);
                    m_pciNetwork->Release();
                }  // if:  old network
                m_pciNetwork = pciNetwork;
                if (m_pciNetwork != NULL)
                {
                    m_pciNetwork->AddRef();
                    m_pciNetwork->AddNetInterface(this);
                }  // if:  new network
            }  // if:  netowrk changed (should never happen)
        }  // Find the network object

        // Read the characteristics flag.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterNetInterfaceControl(
                            Hnetiface(),
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_CHARACTERISTICS,
                            NULL,
                            NULL,
                            &m_dwCharacteristics,
                            sizeof(m_dwCharacteristics),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
            else
            {
                ASSERT(cbReturned == sizeof(m_dwCharacteristics));
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Read the flags.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterNetInterfaceControl(
                            Hnetiface(),
                            NULL,
                            CLUSCTL_NETINTERFACE_GET_FLAGS,
                            NULL,
                            NULL,
                            &m_dwFlags,
                            sizeof(m_dwFlags),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
            else
            {
                ASSERT(cbReturned == sizeof(m_dwFlags));
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Construct the list of extensions.
        ReadExtensions();

    }  // if:  network interface is available

    // Read the initial state.
    UpdateState();

    // If any errors occurred, throw an exception.
    if (dwRetStatus != ERROR_SUCCESS)
    {
        m_bReadOnly = TRUE;
//      if (dwRetStatus != ERROR_FILE_NOT_FOUND)
            ThrowStaticException(dwRetStatus, IDS_READ_NETIFACE_PROPS_ERROR, StrName());
    }  // if:  error reading properties

    MarkAsChanged(FALSE);

}  //*** CNetInterface::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::ReadExtensions
//
//  Routine Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::ReadExtensions(void)
{
}  //*** CNetInterface::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::PlstrExtension
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CNetInterface::PlstrExtensions(void) const
{
    return &Pdoc()->PciCluster()->LstrNetworkExtensions();

}  //*** CNetInterface::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::SetCommonProperties
//
//  Routine Description:
//      Set the common properties for this network interface in the cluster
//      database.
//
//  Arguments:
//      rstrDesc        [IN] Description string.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusterItem::SetCommonProperties().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::SetCommonProperties(
    IN const CString &  rstrDesc,
    IN BOOL             bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;

    try
    {
        CClusterItem::SetCommonProperties(bValidateOnly);
    }  // try
    catch (CNTException * pnte)
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    }  // catch:  CNTException

    m_rgProps[epropDescription].m_value.pstr = &m_strDescription;

    if (nte.Sc() != ERROR_SUCCESS)
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );

}  //*** CNetInterface::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::DwSetCommonProperties
//
//  Routine Description:
//      Set the common properties for this network interface in the cluster
//      database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      Any status returned by ClusterNetInterfaceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterface::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnetiface());

    if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if (bValidateOnly)
            dwControl = CLUSCTL_NETINTERFACE_VALIDATE_COMMON_PROPERTIES;
        else
            dwControl = CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES;

        // Set common properties.
        dwStatus = ClusterNetInterfaceControl(
                        Hnetiface(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        static_cast< DWORD >( rcpl.CbPropList() ),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
        dwStatus = ERROR_SUCCESS;

    return dwStatus;

}  //*** CNetInterface::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::UpdateState(void)
{
    CClusterAdminApp *  papp = GetClusterAdminApp();

    Trace(g_tagNetIFace, _T("(%s) (%s (%x)) - Updating state"), Pdoc()->StrNode(), StrName(), this);

    // Get the current state of the network interface.
    if (Hnetiface() == NULL)
        m_cnis = ClusterNetInterfaceStateUnknown;
    else
    {
        CWaitCursor wc;

        m_cnis = GetClusterNetInterfaceState(Hnetiface());
    }  // else:  network interface is available

    // Save the current state image index.
    switch (Cnis())
    {
        case ClusterNetInterfaceStateUnknown:
        case ClusterNetInterfaceUnavailable:
            m_iimgState = papp->Iimg(IMGLI_NETIFACE_UNKNOWN);
            break;
        case ClusterNetInterfaceUp:
            m_iimgState = papp->Iimg(IMGLI_NETIFACE);
            break;
        case ClusterNetInterfaceUnreachable:
            m_iimgState = papp->Iimg(IMGLI_NETIFACE_UNREACHABLE);
            break;
        case ClusterNetInterfaceFailed:
            m_iimgState = papp->Iimg(IMGLI_NETIFACE_FAILED);
            break;
        default:
            Trace(g_tagNetIFace, _T("(%s) (%s (%x)) - UpdateState: Unknown state '%d' for network interface '%s'"), Pdoc()->StrNode(), StrName(), this, Cnis(), StrName());
            m_iimgState = (UINT) -1;
            break;
    }  // switch:  Crs()

    // Call the base class method.
    CClusterItem::UpdateState();

}  //*** CNetInterface::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterface::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
    BOOL    bSuccess;

    switch (colid)
    {
        case IDS_COLTEXT_STATE:
            GetStateName(rstrText);
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_NODE:
            rstrText = StrNode();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_NETWORK:
            if (PciNetwork() == NULL)
                rstrText = StrNetwork();
            else
                rstrText = PciNetwork()->StrName();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_ADAPTER:
            rstrText = StrAdapter();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_ADDRESS:
            rstrText = StrAddress();
            bSuccess = TRUE;
            break;
        default:
            bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CNetInterface::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::GetTreeName
//
//  Routine Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CNetInterface::GetTreeName(OUT CString & rstrName) const
{
    CString     strState;

    GetStateName(strState);
    rstrName.Format(_T("%s (%s)"), StrName(), strState);

}  //*** CNetInterface::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::GetStateName
//
//  Routine Description:
//      Returns a string with the name of the current state.
//
//  Arguments:
//      rstrState   [OUT] String in which to return the name of the current state.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::GetStateName(OUT CString & rstrState) const
{
    switch (Cnis())
    {
        case ClusterNetInterfaceStateUnknown:
            rstrState.LoadString(IDS_UNKNOWN);
            break;
        case ClusterNetInterfaceUp:
            rstrState.LoadString(IDS_UP);
            break;
        case ClusterNetInterfaceUnreachable:
            rstrState.LoadString(IDS_UNREACHABLE);
            break;
        case ClusterNetInterfaceFailed:
            rstrState.LoadString(IDS_FAILED);
            break;
        case ClusterNetInterfaceUnavailable:
            rstrState.LoadString(IDS_UNAVAILABLE);
            break;
        default:
            rstrState.Empty();
            break;
    }  // switch:  Crs()

}  //*** CNetInterface::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::OnUpdateProperties(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(TRUE);

}  //*** CNetInterface::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterface::BDisplayProperties(IN BOOL bReadOnly)
{
    BOOL                    bChanged = FALSE;
    CNetInterfacePropSheet  sht(AfxGetMainWnd());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if (BChanged())
        ReadItem();

    // Display the property sheet.
    try
    {
        sht.SetReadOnly(bReadOnly);
        if (sht.BInit(this, IimgObjectType()))
            bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CNetInterface::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterface::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CNetInterface::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
    ASSERT(pnotify != NULL);
    ASSERT_VALID(this);

    try
    {
        switch (pnotify->m_dwFilterType)
        {
            case CLUSTER_CHANGE_NETINTERFACE_STATE:
                Trace(g_tagNetIFaceNotify, _T("(%s) - Network Interface '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                UpdateState();
                break;

            case CLUSTER_CHANGE_NETINTERFACE_DELETED:
                Trace(g_tagNetIFaceNotify, _T("(%s) - Network Interface '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    Delete();
                break;

            case CLUSTER_CHANGE_NETINTERFACE_PROPERTY:
                Trace(g_tagNetIFaceNotify, _T("(%s) - Network Interface '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    ReadItem();
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace(g_tagNetIFaceNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace(g_tagNetIFaceNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace(g_tagNetIFaceNotify, _T("(%s) - Registry value '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            default:
                Trace(g_tagNetIFaceNotify, _T("(%s) - Unknown network interface notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
        }  // switch:  dwFilterType
    }  // try
    catch (CException * pe)
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    delete pnotify;
    return 0;

}  //*** CNetInterface::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CNetInterfaceList & rlp)
{
    POSITION        pos;
    CNetInterface * pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        pci = rlp.GetNext(pos);
        ASSERT_VALID(pci);
//      Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlp) - Deleting network interface cluster item '%s' (%x)"), pci->StrName(), pci);
        pci->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\moveres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		MoveRes.cpp
//
//	Abstract:
//		Definition of the CMoveResourcesDlg dialog.
//
//	Implementation File:
//		MoveRes.h
//
//	Author:
//		David Potter (davidp)	April 1, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _MOVERES_H_
#define _MOVERES_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#include "resource.h"
#define _RESOURCE_H_
#endif

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CMoveResourcesDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResource;
class CResourceList;

/////////////////////////////////////////////////////////////////////////////
// CMoveResourcesDlg class
/////////////////////////////////////////////////////////////////////////////

class CMoveResourcesDlg : public CBaseDialog
{
// Construction
public:
	CMoveResourcesDlg(
		IN CResource *				pciRes,
		IN const CResourceList *	plpci,
		IN OUT CWnd *				pParent = NULL
		);

// Dialog Data
	//{{AFX_DATA(CMoveResourcesDlg)
	enum { IDD = IDD_MOVE_RESOURCES };
	CListCtrl	m_lcResources;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMoveResourcesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResource *				m_pciRes;
	const CResourceList *	m_plpci;
	int						m_nSortDirection;
	int						m_nSortColumn;

	const CResource *		PciRes(void) const		{ return m_pciRes; }
	const CResourceList *	Plpci(void) const		{ return m_plpci; }

	static int CALLBACK		CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);

	// Generated message map functions
	//{{AFX_MSG(CMoveResourcesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblClkResourcesList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CMoveResourcesDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _MOVERES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\netiface.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      NetIFace.h
//
//  Abstract:
//      Definition of the CNetInterface class.
//
//  Implementation File:
//      NetIFace.cpp
//
//  Author:
//      David Potter (davidp)   May 28, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETIFACE_H_
#define _NETIFACE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetInterface;
class CNetInterfaceList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNode;
class CNetwork;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetInterface command target
/////////////////////////////////////////////////////////////////////////////

class CNetInterface : public CClusterItem
{
    DECLARE_DYNCREATE(CNetInterface)

// Construction
public:
    CNetInterface(void);        // protected constructor used by dynamic creation
    void                    Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

protected:
    void                    CommonConstruct(void);

// Attributes
protected:
    HNETINTERFACE           m_hnetiface;
    CLUSTER_NETINTERFACE_STATE  m_cnis;

    CString                 m_strNode;
    CClusterNode *          m_pciNode;
    CString                 m_strNetwork;
    CNetwork *              m_pciNetwork;
    CString                 m_strAdapter;
    CString                 m_strAddress;
    DWORD                   m_dwCharacteristics;
    DWORD                   m_dwFlags;

    enum
    {
        epropName = 0,
        epropNode,
        epropNetwork,
        epropAdapter,
        epropAddress,
        epropDescription,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

public:
    HNETINTERFACE           Hnetiface(void) const               { return m_hnetiface; }
    CLUSTER_NETINTERFACE_STATE  Cnis(void) const                { return m_cnis; }

    const CString &         StrNode(void) const                 { return m_strNode; }
    CClusterNode *          PciNode(void) const                 { return m_pciNode; }
    const CString &         StrNetwork(void) const              { return m_strNetwork; }
    CNetwork *              PciNetwork(void) const              { return m_pciNetwork; }
    const CString &         StrAdapter(void) const              { return m_strAdapter; }
    const CString &         StrAddress(void) const              { return m_strAddress; }
    DWORD                   DwCharacteristics(void) const       { return m_dwCharacteristics; }
    DWORD                   DwFlags(void) const                 { return m_dwFlags; }

    void                    GetStateName(OUT CString & rstrState) const;

// Operations
public:
    void                    ReadExtensions(void);

    void                    SetCommonProperties(
                                IN const CString &  rstrDesc,
                                IN BOOL             bValidateOnly
                                );
    void                    SetCommonProperties(
                                IN const CString &  rstrDesc
                                )
    {
        SetCommonProperties(rstrDesc, FALSE /*bValidateOnly*/);
    }
    void                    ValidateCommonProperties(
                                IN const CString &  rstrDesc
                                )
    {
        SetCommonProperties(rstrDesc, TRUE /*bValidateOnly*/);
    }

// Overrides
public:
    virtual void            Cleanup(void);
    virtual void            ReadItem(void);
    virtual void            UpdateState(void);
    virtual BOOL            BGetColumnData(IN COLID colid, OUT CString & rstrText);
    virtual BOOL            BDisplayProperties(IN BOOL bReadOnly = FALSE);

    virtual const CStringList * PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
    virtual void            GetTreeName(OUT CString & rstrName) const;
#endif

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CNetInterface)
    //}}AFX_VIRTUAL

    virtual LRESULT         OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(m_rgProps[0]); }
    virtual DWORD                   DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
public:
    virtual ~CNetInterface(void);

public:
    // Generated message map functions
    //{{AFX_MSG(CNetInterface)
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

};  //*** class CNetInterface

/////////////////////////////////////////////////////////////////////////////
// CNetInterfaceList
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceList : public CClusterItemList
{
public:
    CNetInterface *     PciNetInterfaceFromName(
                        IN LPCTSTR      pszName,
                        OUT POSITION *  ppos = NULL
                        )
    {
        return (CNetInterface *) PciFromName(pszName, ppos);
    }

};  //*** class CNetInterfaceList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CNetInterfaceList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagNetIFace;
extern CTraceTag g_tagNetIFaceNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _NETIFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\netprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		NetProp.h
//
//	Abstract:
//		Definition of the network property sheet and pages.
//
//	Author:
//		David Potter (davidp)	June 9, 1997
//
//	Implementation File:
//		NetProp.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETPROP_H_
#define _NETPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _NETWORK_H_
#include "Network.h"	// for CNetwork
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetworkGeneralPage;
class CNetworkPropSheet;

/////////////////////////////////////////////////////////////////////////////
// CNetworkGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNetworkGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CNetworkGeneralPage)

// Construction
public:
	CNetworkGeneralPage(void);

	virtual	BOOL		BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CNetworkGeneralPage)
	enum { IDD = IDD_PP_NET_GENERAL };
	CEdit	m_editAddressMask;
	CEdit	m_editDesc;
	CEdit	m_editName;
	CButton	m_rbRoleClientOnly;
	CButton	m_rbRoleInternalOnly;
	CButton	m_rbRoleAllComm;
	CButton	m_ckbEnable;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strAddressMask;
	CString	m_strState;
	int		m_nRole;
	BOOL	m_bEnabled;
	//}}AFX_DATA
	CLUSTER_NETWORK_ROLE	m_cnr;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNetworkGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CNetworkPropSheet *	PshtNetwork(void) const	{ return (CNetworkPropSheet *) Psht(); }
	CNetwork *			PciNet(void) const		{ return (CNetwork *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CNetworkGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnEnableNetwork();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNetworkGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CNetworkPropSheet
/////////////////////////////////////////////////////////////////////////////

class CNetworkPropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CNetworkPropSheet)

// Construction
public:
	CNetworkPropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[1];

	// Pages
	CNetworkGeneralPage				m_pageGeneral;

	CNetworkGeneralPage &			PageGeneral(void)		{ return m_pageGeneral; }

public:
	CNetwork *						PciNet(void) const	{ return (CNetwork *) Pci(); }

// Operations

// Overrides
protected:
	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetworkPropSheet)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CNetworkPropSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNetworkPropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _NETPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\netiprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		NetIProp.cpp
//
//	Abstract:
//		Implementation of the network interface property sheet and pages.
//
//	Author:
//		David Potter (davidp)	June 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "NetIProp.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetworkPropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CNetInterfacePropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetInterfacePropSheet, CBasePropertySheet)
	//{{AFX_MSG_MAP(CNetInterfacePropSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfacePropSheet::CNetInterfacePropSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfacePropSheet::CNetInterfacePropSheet(
	IN OUT CWnd *		pParentWnd,
	IN UINT				iSelectPage
	)
	: CBasePropertySheet(pParentWnd, iSelectPage)
{
	m_rgpages[0] = &PageGeneral();

}  //*** CNetInterfacePropSheet::CNetInterfacePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfacePropSheet::BInit
//
//	Routine Description:
//		Initialize the property sheet.
//
//	Arguments:
//		pci			[IN OUT] Cluster item whose properties are to be displayed.
//		iimgIcon	[IN] Index in the large image list for the image to use
//					  as the icon on each page.
//
//	Return Value:
//		TRUE		Property sheet initialized successfully.
//		FALSE		Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterfacePropSheet::BInit(
	IN OUT CClusterItem *	pci,
	IN IIMG					iimgIcon
	)
{
	// Call the base class method.
	if (!CBasePropertySheet::BInit(pci, iimgIcon))
		return FALSE;

	// Set the read-only flag if the handles are invalid.
	m_bReadOnly = PciNetIFace()->BReadOnly()
					|| (PciNetIFace()->Cnis() == ClusterNetInterfaceStateUnknown);

	return TRUE;

}  //*** CNetInterfacePropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfacePropSheet::Ppages
//
//	Routine Description:
//		Returns the array of pages to add to the property sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CNetInterfacePropSheet::Ppages(void)
{
	return m_rgpages;

}  //*** CNetworkPropSheet::Pppges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfacePropSheet::Cpages
//
//	Routine Description:
//		Returns the count of pages in the array.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CNetInterfacePropSheet::Cpages(void)
{
	return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CNetInterfacePropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNetInterfaceGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetInterfaceGeneralPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetInterfaceGeneralPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CNetInterfaceGeneralPage)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_NETIFACE_DESC, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::CNetInterfaceGeneralPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaceGeneralPage::CNetInterfaceGeneralPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_NETIFACE_GENERAL)
{
	//{{AFX_DATA_INIT(CNetInterfaceGeneralPage)
	m_strNode = _T("");
	m_strNetwork = _T("");
	m_strDesc = _T("");
	m_strAdapter = _T("");
	m_strAddress = _T("");
	m_strName = _T("");
	m_strState = _T("");
	//}}AFX_DATA_INIT

}  //*** CNetInterfaceGeneralPage::CNetInterfaceGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterfaceGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
	BOOL	bSuccess;

	ASSERT_KINDOF(CNetInterfacePropSheet, psht);

	bSuccess = CBasePropertyPage::BInit(psht);
	if (bSuccess)
	{
		try
		{
			m_strNode = PciNetIFace()->StrNode();
			m_strNetwork = PciNetIFace()->StrNetwork();
			m_strDesc = PciNetIFace()->StrDescription();
			m_strAdapter = PciNetIFace()->StrAdapter();
			m_strAddress = PciNetIFace()->StrAddress();
			m_strName = PciNetIFace()->StrName();
			PciNetIFace()->GetStateName(m_strState);
		} // try
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
			bSuccess = FALSE;
		}  // catch:  CException
	}  //  if:  base class method was successful

	return bSuccess;

}  //*** CNetInterfaceGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterfaceGeneralPage::DoDataExchange(CDataExchange * pDX)
{
	CBasePropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNetInterfaceGeneralPage)
	DDX_Control(pDX, IDC_PP_NETIFACE_DESC, m_editDesc);
	DDX_Text(pDX, IDC_PP_NETIFACE_NODE, m_strNode);
	DDX_Text(pDX, IDC_PP_NETIFACE_NETWORK, m_strNetwork);
	DDX_Text(pDX, IDC_PP_NETIFACE_DESC, m_strDesc);
	DDX_Text(pDX, IDC_PP_NETIFACE_ADAPTER, m_strAdapter);
	DDX_Text(pDX, IDC_PP_NETIFACE_ADDRESS, m_strAddress);
	DDX_Text(pDX, IDC_PP_NETIFACE_NAME, m_strName);
	DDX_Text(pDX, IDC_PP_NETIFACE_CURRENT_STATE, m_strState);
	//}}AFX_DATA_MAP

}  //*** CNetInterfaceGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterfaceGeneralPage::OnInitDialog(void)
{
	CBasePropertyPage::OnInitDialog();

	// If read-only, set all controls to be either disabled or read-only.
	if (BReadOnly())
	{
		m_editDesc.SetReadOnly(TRUE);
	}  // if:  sheet is read-only

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNetInterfaceGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::OnApply
//
//	Routine Description:
//		Handler for when the Apply button is pressed.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterfaceGeneralPage::OnApply(void)
{
	// Set the data from the page in the cluster item.
	try
	{
		CWaitCursor	wc;

		PciNetIFace()->SetCommonProperties(m_strDesc);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		return FALSE;
	}  // catch:  CException

	return CBasePropertyPage::OnApply();

}  //*** CNetInterfaceGeneralPage::OnApply()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\netiprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		NetIProp.h
//
//	Abstract:
//		Definition of the network interface property sheet and pages.
//
//	Author:
//		David Potter (davidp)	June 9, 1997
//
//	Implementation File:
//		NetIProp.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETIPROP_H_
#define _NETIPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _NETWORK_H_
#include "NetIFace.h"	// for CNetInterface
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceGeneralPage;
class CNetInterfacePropSheet;

/////////////////////////////////////////////////////////////////////////////
// CNetInterfaceGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CNetInterfaceGeneralPage)

// Construction
public:
	CNetInterfaceGeneralPage();

	virtual	BOOL		BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CNetInterfaceGeneralPage)
	enum { IDD = IDD_PP_NETIFACE_GENERAL };
	CEdit	m_editDesc;
	CString	m_strNode;
	CString	m_strNetwork;
	CString	m_strDesc;
	CString	m_strAdapter;
	CString	m_strAddress;
	CString	m_strName;
	CString	m_strState;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNetInterfaceGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CNetInterfacePropSheet *	PshtNetIFace(void) const	{ return (CNetInterfacePropSheet *) Psht(); }
	CNetInterface *				PciNetIFace(void) const		{ return (CNetInterface *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CNetInterfaceGeneralPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNetInterfaceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CNetInterfacePropSheet
/////////////////////////////////////////////////////////////////////////////

class CNetInterfacePropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CNetInterfacePropSheet)

// Construction
public:
	CNetInterfacePropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[1];

	// Pages
	CNetInterfaceGeneralPage		m_pageGeneral;

	CNetInterfaceGeneralPage &		PageGeneral(void)		{ return m_pageGeneral; }

public:
	CNetInterface *					PciNetIFace(void) const	{ return (CNetInterface *) Pci(); }

// Operations

// Overrides
protected:
	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetInterfacePropSheet)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CNetInterfacePropSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNetInterfacePropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _NETIPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\network.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Network.cpp
//
//  Abstract:
//      Implementation of the CNetwork class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Network.h"
#include "ClusItem.inl"
#include "Cluster.h"
#include "NetProp.h"
#include "ExcOper.h"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagNetwork(_T("Document"), _T("NETWORK"), 0);
CTraceTag   g_tagNetNotify(_T("Notify"), _T("NET NOTIFY"), 0);
CTraceTag   g_tagNetRegNotify(_T("Notify"), _T("NET REG NOTIFY"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetwork
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetwork, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetwork, CClusterItem)
    //{{AFX_MSG_MAP(CNetwork)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::CNetwork
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetwork::CNetwork(void)
    : CClusterItem(NULL, IDS_ITEMTYPE_NETWORK)
{
    CommonConstruct();

}  //*** CResoruce::CNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::CommonConstruct(void)
{
    m_idmPopupMenu = IDM_NETWORK_POPUP;
    m_hnetwork = NULL;

    m_dwCharacteristics = CLUS_CHAR_UNKNOWN;
    m_dwFlags = 0;

    m_cnr = ClusterNetworkRoleNone;

    m_plpciNetInterfaces = NULL;

    // Set the object type image.
    m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_NETWORK);

    // Setup the property array.
    {
        m_rgProps[epropName].Set(CLUSREG_NAME_NET_NAME, m_strName, m_strName);
        m_rgProps[epropRole].Set(CLUSREG_NAME_NET_ROLE, (DWORD &) m_cnr, (DWORD &) m_cnr);
        m_rgProps[epropAddress].Set(CLUSREG_NAME_NET_ADDRESS, m_strAddress, m_strAddress);
        m_rgProps[epropAddressMask].Set(CLUSREG_NAME_NET_ADDRESS_MASK, m_strAddressMask, m_strAddressMask);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_NET_DESC, m_strDescription, m_strDescription);
    }  // Setup the property array

}  //*** CNetwork::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::~CNetwork
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetwork::~CNetwork(void)
{
    // Cleanup this object.
    Cleanup();

    delete m_plpciNetInterfaces;

    // Close the network handle.
    if (Hnetwork() != NULL)
        CloseClusterNetwork(Hnetwork());

}  //*** CNetwork::~CNetwork

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::Cleanup(void)
{
    // Delete the Network Interface list.
    if (m_plpciNetInterfaces != NULL)
        m_plpciNetInterfaces->RemoveAll();

    // Remove the item from the network list.
    {
        POSITION    posPci;

        posPci = Pdoc()->LpciNetworks().Find(this);
        if (posPci != NULL)
        {
            Pdoc()->LpciNetworks().RemoveAt(posPci);
        }  // if:  found in the document's list
    }  // Remove the item from the network list

}  //*** CNetwork::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenClusterNetwork or GetClusterNetworkKey.
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LONG        lResult;
    CString     strName(lpszName);  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(Hnetwork() == NULL);
    ASSERT(Hkey() == NULL);

    // Call the base class method.
    CClusterItem::Init(pdoc, lpszName);

    try
    {
        // Open the network.
        m_hnetwork = OpenClusterNetwork(Hcluster(), strName);
        if (Hnetwork() == NULL)
        {
            dwStatus = GetLastError();
            ThrowStaticException(dwStatus, IDS_OPEN_NETWORK_ERROR, lpszName);
        }  // if:  error opening the cluster network

        // Get the network registry key.
        m_hkey = GetClusterNetworkKey(Hnetwork(), MAXIMUM_ALLOWED);
//      if (Hkey() == NULL)
//          ThrowStaticException(GetLastError(), IDS_GET_NETWORK_KEY_ERROR, lpszName);

        if (BDocObj())
        {
            ASSERT(Pcnk() != NULL);
            Trace(g_tagClusItemNotify, _T("CNetwork::Init() - Registering for network notifications (%08.8x) for '%s'"), Pcnk(), StrName());

            // Register for network notifications.
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (     CLUSTER_CHANGE_NETWORK_STATE
                                    | CLUSTER_CHANGE_NETWORK_DELETED
                                    | CLUSTER_CHANGE_NETWORK_PROPERTY),
                                Hnetwork(),
                                (DWORD_PTR) Pcnk()
                                );
            if (lResult != ERROR_SUCCESS)
            {
                dwStatus = lResult;
                ThrowStaticException(dwStatus, IDS_RES_NOTIF_REG_ERROR, lpszName);
            }  // if:  error registering for network notifications

            // Register for registry notifications.
            if (m_hkey != NULL)
            {
                lResult = RegisterClusterNotify(
                                    GetClusterAdminApp()->HchangeNotifyPort(),
                                    (CLUSTER_CHANGE_REGISTRY_NAME
                                        | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                        | CLUSTER_CHANGE_REGISTRY_VALUE
                                        | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                    Hkey(),
                                    (DWORD_PTR) Pcnk()
                                    );
                if (lResult != ERROR_SUCCESS)
                {
                    dwStatus = lResult;
                    ThrowStaticException(dwStatus, IDS_RES_NOTIF_REG_ERROR, lpszName);
                }  // if:  error registering for registry notifications
            }  // if:  there is a key
        }  // if:  document object

        // Allocate lists.
        m_plpciNetInterfaces = new CNetInterfaceList;
        if ( m_plpciNetInterfaces == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the network interface list

        // Read the initial state.
        UpdateState();
    }  // try
    catch (CException *)
    {
        if (Hkey() != NULL)
        {
            ClusterRegCloseKey(Hkey());
            m_hkey = NULL;
        }  // if:  registry key opened
        if (Hnetwork() != NULL)
        {
            CloseClusterNetwork(Hnetwork());
            m_hnetwork = NULL;
        }  // if:  network opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CNetwork::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::ReadItem(void)
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CString     strOldName;
    CWaitCursor wc;

    ASSERT_VALID(this);

    if (Hnetwork() != NULL)
    {
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
        m_rgProps[epropRole].m_value.pdw = (DWORD *) &m_cnr;

        // Save the name so we can detect changes.
        strOldName = StrName();

        // Call the base class method.
        CClusterItem::ReadItem();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNetworkProperties(
                                Hnetwork(),
                                CLUSCTL_NETWORK_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
                dwStatus = DwParseProperties(cpl);
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
        }  // Read and parse the common properties

        // Read and parse the read-only common properties.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNetworkProperties(
                                Hnetwork(),
                                CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
                dwStatus = DwParseProperties(cpl);
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
        }  // if:  no error yet

        // Read the characteristics.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterNetworkControl(
                            Hnetwork(),
                            NULL,
                            CLUSCTL_NETWORK_GET_CHARACTERISTICS,
                            NULL,
                            NULL,
                            &m_dwCharacteristics,
                            sizeof(m_dwCharacteristics),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
            else
            {
                ASSERT(cbReturned == sizeof(m_dwCharacteristics));
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Read the flags.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterNetworkControl(
                            Hnetwork(),
                            NULL,
                            CLUSCTL_NETWORK_GET_FLAGS,
                            NULL,
                            NULL,
                            &m_dwFlags,
                            sizeof(m_dwFlags),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
            else
            {
                ASSERT(cbReturned == sizeof(m_dwFlags));
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Construct the list of extensions.
        ReadExtensions();

        // If the name changed, update all the network interfaces.
        if ( (m_plpciNetInterfaces != NULL) && (StrName() != strOldName) )
        {
            POSITION        posPciNetIFaces;
            CNetInterface * pciNetIFace;

            posPciNetIFaces = m_plpciNetInterfaces->GetHeadPosition();
            while ( posPciNetIFaces != NULL )
            {
                pciNetIFace = reinterpret_cast< CNetInterface * >( m_plpciNetInterfaces->GetNext(posPciNetIFaces) );
                ASSERT_VALID(pciNetIFace);
                ASSERT_KINDOF(CNetInterface, pciNetIFace);
                pciNetIFace->ReadItem();
            } // while:  more items in the list
        } // if:  list exists and name changed

    }  // if:  network is available

    // Read the initial state.
    UpdateState();

    // If any errors occurred, throw an exception.
    if (dwRetStatus != ERROR_SUCCESS)
    {
        m_bReadOnly = TRUE;
//      if (dwRetStatus != ERROR_FILE_NOT_FOUND)
            ThrowStaticException(dwRetStatus, IDS_READ_NETWORK_PROPS_ERROR, StrName());
    }  // if:  error reading properties

    MarkAsChanged(FALSE);

}  //*** CNetwork::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::ReadExtensions
//
//  Routine Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::ReadExtensions(void)
{
}  //*** CNetwork::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::PlstrExtension
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CNetwork::PlstrExtensions(void) const
{
    return &Pdoc()->PciCluster()->LstrNetworkExtensions();

}  //*** CNetwork::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::CollectInterfaces
//
//  Routine Description:
//      Construct a list of interfaces connected to this network.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterNetworkOpenEnum() or
//                        ClusterNetworkEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::CollectInterfaces(IN OUT CNetInterfaceList * plpci) const
{
    DWORD           dwStatus;
    HNETWORKENUM    hnetenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CNetInterface * pciNetIFace;
    CWaitCursor     wc;

    ASSERT_VALID(Pdoc());
    ASSERT(Hnetwork() != NULL);

    if (plpci == NULL)
        plpci = m_plpciNetInterfaces;

    ASSERT(plpci != NULL);

    // Remove the previous contents of the list.
    plpci->RemoveAll();

    if (Hnetwork() != NULL)
    {
        // Open the enumeration.
        hnetenum = ClusterNetworkOpenEnum(Hnetwork(), CLUSTER_NETWORK_ENUM_NETINTERFACES);
        if (hnetenum == NULL)
            ThrowStaticException(GetLastError(), IDS_ENUM_NETWORK_INTERFACES_ERROR, StrName());

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating name buffer

            // Loop through the enumeration and add each interface to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterNetworkEnum(hnetenum, ienum, &dwRetType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating name buffer
                    dwStatus = ClusterNetworkEnum(hnetenum, ienum, &dwRetType, pwszName, &cchName);
                }  // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                    break;
                else if (dwStatus != ERROR_SUCCESS)
                    ThrowStaticException(dwStatus, IDS_ENUM_NETWORK_INTERFACES_ERROR, StrName());

                ASSERT(dwRetType == CLUSTER_NETWORK_ENUM_NETINTERFACES);

                // Find the item in the list of networks on the document.
                pciNetIFace = Pdoc()->LpciNetInterfaces().PciNetInterfaceFromName(pwszName);
                ASSERT_VALID(pciNetIFace);

                // Add the interface to the list.
                if (pciNetIFace != NULL)
                {
                    plpci->AddTail(pciNetIFace);
                }  // if:  found node in list

            }  // for:  each network interface connected to this network

            delete [] pwszName;
            ClusterNetworkCloseEnum(hnetenum);

        }  // try
        catch (CException *)
        {
            delete [] pwszName;
            ClusterNetworkCloseEnum(hnetenum);
            throw;
        }  // catch:  any exception
    }  // if:  network is available

}  //*** CNetwork::CollecPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::AddNetInterface
//
//  Routine Description:
//      Add a network interface to the list of interaces connected to this
//      network.
//
//  Arguments:
//      pciNetIFace     [IN OUT] New network interface.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::AddNetInterface(IN OUT CNetInterface * pciNetIFace)
{
    POSITION    posPci;

    ASSERT_VALID(pciNetIFace);
    Trace(g_tagNetwork, _T("(%s) (%s (%x)) - Adding network interface '%s'"), Pdoc()->StrNode(), StrName(), this, pciNetIFace->StrName());

    // Make sure the network interface is not already in the list.
    VERIFY((posPci = LpciNetInterfaces().Find(pciNetIFace)) == NULL);

    if (posPci == NULL)
    {
        POSITION    posPtiNetwork;
        CTreeItem * ptiNetwork;

        // Loop through each tree item to update the Network list.
        posPtiNetwork = LptiBackPointers().GetHeadPosition();
        while (posPtiNetwork != NULL)
        {
            ptiNetwork = LptiBackPointers().GetNext(posPtiNetwork);
            ASSERT_VALID(ptiNetwork);

            // Add the new network interface.
            VERIFY(ptiNetwork->PliAddChild(pciNetIFace) != NULL);
        }  // while:  more tree items for this network

        m_plpciNetInterfaces->AddTail(pciNetIFace);

    }  // if:  network interface not in the list yet

}  //*** CNetwork::AddNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::RemoveNetInterface
//
//  Routine Description:
//      Remove a network interface from the list of interfaces connected to
//      this network
//
//  Arguments:
//      pciNetIFace     [IN OUT] Network interface that is no longer
//                          connected to this network.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::RemoveNetInterface(IN OUT CNetInterface * pciNetIFace)
{
    POSITION    posPci;

    ASSERT_VALID(pciNetIFace);
    Trace(g_tagNetwork, _T("(%s) (%s (%x)) - Removing network interface '%s'"), Pdoc()->StrNode(), StrName(), this, pciNetIFace->StrName());

    // Make sure the network interface is in the list.
    VERIFY((posPci = LpciNetInterfaces().Find(pciNetIFace)) != NULL);

    if (posPci != NULL)
    {
        POSITION    posPtiNetwork;
        CTreeItem * ptiNetwork;

        // Loop through each tree item to update the Network list.
        posPtiNetwork = LptiBackPointers().GetHeadPosition();
        while (posPtiNetwork != NULL)
        {
            ptiNetwork = LptiBackPointers().GetNext(posPtiNetwork);
            ASSERT_VALID(ptiNetwork);

            // Remove the network interface.
            ptiNetwork->RemoveChild(pciNetIFace);
        }  // while:  more tree items for this network

        m_plpciNetInterfaces->RemoveAt(posPci);

    }  // if:  network interface in the list

}  //*** CNetwork::RemoveNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::SetName
//
//  Routine Description:
//      Set the name of this network.
//
//  Arguments:
//      pszName         [IN] New name of the network.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by Rename().
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::SetName(IN LPCTSTR pszName)
{
    Rename(pszName);

}  //*** CNetwork::SetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::SetCommonProperties
//
//  Routine Description:
//      Set the common properties for this network in the cluster database.
//
//  Arguments:
//      rstrDesc        [IN] Description string.
//      cnr             [IN] Network role.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusterItem::SetCommonProperties().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::SetCommonProperties(
    IN const CString &      rstrDesc,
    IN CLUSTER_NETWORK_ROLE cnr,
    IN BOOL                 bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;
    m_rgProps[epropRole].m_value.pdw = (DWORD *) &cnr;

    try
    {
        CClusterItem::SetCommonProperties(bValidateOnly);
    }  // try
    catch (CNTException * pnte)
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    }  // catch:  CNTException

    m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
    m_rgProps[epropRole].m_value.pdw = (DWORD *) &m_cnr;

    if (nte.Sc() != ERROR_SUCCESS)
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );

}  //*** CNetwork::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::DwSetCommonProperties
//
//  Routine Description:
//      Set the common properties for this network in the cluster database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      Any status returned by ClusterNetworkControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetwork::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnetwork());

    if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if (bValidateOnly)
            dwControl = CLUSCTL_NETWORK_VALIDATE_COMMON_PROPERTIES;
        else
            dwControl = CLUSCTL_NETWORK_SET_COMMON_PROPERTIES;

        // Set common properties.
        dwStatus = ClusterNetworkControl(
                        Hnetwork(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        static_cast< DWORD >( rcpl.CbPropList() ),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
        dwStatus = ERROR_SUCCESS;

    return dwStatus;

}  //*** CNetwork::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::UpdateState(void)
{
    CClusterAdminApp *  papp = GetClusterAdminApp();

    Trace(g_tagNetwork, _T("(%s) (%s (%x)) - Updating state"), Pdoc()->StrNode(), StrName(), this);

    // Get the current state of the network.
    if (Hnetwork() == NULL)
        m_cns = ClusterNetworkStateUnknown;
    else
    {
        CWaitCursor wc;

        m_cns = GetClusterNetworkState(Hnetwork());
    }  // else:  network is available

    // Save the current state image index.
    switch (Cns())
    {
        case ClusterNetworkStateUnknown:
        case ClusterNetworkUnavailable:
            m_iimgState = papp->Iimg(IMGLI_NETWORK_UNKNOWN);
            break;
        case ClusterNetworkUp:
            m_iimgState = papp->Iimg(IMGLI_NETWORK);
            break;
        case ClusterNetworkPartitioned:
            m_iimgState = papp->Iimg(IMGLI_NETWORK_PARTITIONED);
            break;
        case ClusterNetworkDown:
            m_iimgState = papp->Iimg(IMGLI_NETWORK_DOWN);
            break;
        default:
            Trace(g_tagNetwork, _T("(%s) (%s (%x)) - UpdateState: Unknown state '%d' for network '%s'"), Pdoc()->StrNode(), StrName(), this, Cns(), StrName());
            m_iimgState = (UINT) -1;
            break;
    }  // switch:  Crs()

    // Call the base class method.
    CClusterItem::UpdateState();

}  //*** CNetwork::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetwork::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
    BOOL    bSuccess;

    switch (colid)
    {
        case IDS_COLTEXT_STATE:
            GetStateName(rstrText);
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_ROLE:
            GetRoleName(rstrText);
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_ADDRESS:
            rstrText = m_strAddress;
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_MASK:
            rstrText = m_strAddressMask;
            bSuccess = TRUE;
            break;
        default:
            bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CNetwork::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::GetTreeName
//
//  Routine Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CNetwork::GetTreeName(OUT CString & rstrName) const
{
    CString     strState;

    GetStateName(strState);
    rstrName.Format(_T("%s (%s)"), StrName(), strState);

}  //*** CNetwork::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::GetStateName
//
//  Routine Description:
//      Returns a string with the name of the current state.
//
//  Arguments:
//      rstrState   [OUT] String in which to return the name of the current state.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::GetStateName(OUT CString & rstrState) const
{
    switch (Cns())
    {
        case ClusterNetworkStateUnknown:
            rstrState.LoadString(IDS_UNKNOWN);
            break;
        case ClusterNetworkUp:
            rstrState.LoadString(IDS_UP);
            break;
        case ClusterNetworkPartitioned:
            rstrState.LoadString(IDS_PARTITIONED);
            break;
        case ClusterNetworkDown:
            rstrState.LoadString(IDS_DOWN);
            break;
        case ClusterNetworkUnavailable:
            rstrState.LoadString(IDS_UNAVAILABLE);
            break;
        default:
            rstrState.Empty();
            break;
    }  // switch:  Crs()

}  //*** CNetwork::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::GetRoleName
//
//  Routine Description:
//      Returns a string with the name of the current network role.
//
//  Arguments:
//      rstrRole    [OUT] String in which to return the name of the current role.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::GetRoleName(OUT CString & rstrRole) const
{
    switch (Cnr())
    {
        case ClusterNetworkRoleInternalAndClient:
            rstrRole.LoadString(IDS_CLIENT_AND_CLUSTER);
            break;
        case ClusterNetworkRoleClientAccess:
            rstrRole.LoadString(IDS_CLIENT_ONLY);
            break;
        case ClusterNetworkRoleInternalUse:
            rstrRole.LoadString(IDS_CLUSTER_ONLY);
            break;
        case ClusterNetworkRoleNone:
            rstrRole.LoadString(IDS_DONT_USE);
            break;
        default:
            rstrRole.Empty();
            break;
    }  // switch:  Cnr()

}  //*** CNetwork::GetRoleName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::BCanBeEdited
//
//  Routine Description:
//      Determines if the network can be renamed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Network can be renamed.
//      FALSE       Network cannot be renamed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetwork::BCanBeEdited(void) const
{
    BOOL    bCanBeEdited;

    if (   (Cns() == ClusterNetworkStateUnknown)
        || BReadOnly())
        bCanBeEdited  = FALSE;
    else
        bCanBeEdited = TRUE;

    return bCanBeEdited;

}  //*** CNetwork::BCanBeEdited()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::Rename
//
//  Routine Description:
//      Rename the network.
//
//  Arguments:
//      pszName         [IN] New name to give to the network.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors returned from SetClusterNetwName().
//      Any exceptions thrown by SetClusterNetworkName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::Rename(IN LPCTSTR pszName)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnetwork() != NULL);

    if (StrName() != pszName)
    {
        // Validate the name.
        if (!NcIsValidConnectionName(pszName))
        {
            ThrowStaticException((IDS) IDS_INVALID_NETWORK_CONNECTION_NAME);
        } // if:  error validating the name

        dwStatus = SetClusterNetworkName(Hnetwork(), pszName);
        if (dwStatus != ERROR_SUCCESS)
            ThrowStaticException(dwStatus, IDS_RENAME_NETWORK_ERROR, StrName(), pszName);
    }  // if:  the name changed

}  //*** CNetwork::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::OnBeginLabelEdit
//
//  Routine Description:
//      Prepare an edit control in a view for editing the cluster name.
//
//  Arguments:
//      pedit       [IN OUT] Edit control to prepare.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::OnBeginLabelEdit(IN OUT CEdit * pedit)
{
    ASSERT_VALID(pedit);

    pedit->SetLimitText(NETCON_MAX_NAME_LEN);

}  //*** CNetwork::OnBeginLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::OnUpdateProperties(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(TRUE);

}  //*** CNetwork::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetwork::BDisplayProperties(IN BOOL bReadOnly)
{
    BOOL                bChanged = FALSE;
    CNetworkPropSheet   sht(AfxGetMainWnd());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if (BChanged())
        ReadItem();

    // Display the property sheet.
    try
    {
        sht.SetReadOnly(bReadOnly);
        if (sht.BInit(this, IimgObjectType()))
            bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CNetwork::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CNetwork::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
    ASSERT(pnotify != NULL);
    ASSERT_VALID(this);

    try
    {
        switch (pnotify->m_dwFilterType)
        {
            case CLUSTER_CHANGE_NETWORK_STATE:
                Trace(g_tagNetNotify, _T("(%s) - Network '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                UpdateState();
                break;

            case CLUSTER_CHANGE_NETWORK_DELETED:
                Trace(g_tagNetNotify, _T("(%s) - Network '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    Delete();
                break;

            case CLUSTER_CHANGE_NETWORK_PROPERTY:
                Trace(g_tagNetNotify, _T("(%s) - Network '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    ReadItem();
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace(g_tagNetRegNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace(g_tagNetRegNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace(g_tagNetRegNotify, _T("(%s) - Registry value '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            default:
                Trace(g_tagNetNotify, _T("(%s) - Unknown network notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
        }  // switch:  dwFilterType
    }  // try
    catch (CException * pe)
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    delete pnotify;
    return 0;

}  //*** CNetwork::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CNetworkList & rlp)
{
    POSITION    pos;
    CNetwork *  pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        pci = rlp.GetNext(pos);
        ASSERT_VALID(pci);
//      Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlp) - Deleting network cluster item '%s' (%x)"), pci->StrName(), pci);
        pci->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\netprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2002 Microsoft Corporation
//
//  Module Name:
//      NetProp.cpp
//
//  Abstract:
//      Implementation of the network property sheet and pages.
//
//  Author:
//      David Potter (davidp)   June 9, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "NetProp.h"
#include "HelpData.h"
#include "ExcOper.h"
#include "DDxDDv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetworkPropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CNetworkPropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetworkPropSheet, CBasePropertySheet)
    //{{AFX_MSG_MAP(CNetworkPropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkPropSheet::CNetworkPropSheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkPropSheet::CNetworkPropSheet(
    IN OUT CWnd *       pParentWnd,
    IN UINT             iSelectPage
    )
    : CBasePropertySheet(pParentWnd, iSelectPage)
{
    m_rgpages[0] = &PageGeneral();

}  //*** CNetworkPropSheet::CNetworkPropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkPropSheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkPropSheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    // Call the base class method.
    if (!CBasePropertySheet::BInit(pci, iimgIcon))
        return FALSE;

    // Set the read-only flag if the handles are invalid.
    m_bReadOnly = PciNet()->BReadOnly()
                    || (PciNet()->Cns() == ClusterNetworkStateUnknown);

    return TRUE;

}  //*** CNetworkPropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkPropSheet::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CNetworkPropSheet::Ppages(void)
{
    return m_rgpages;

}  //*** CNetworkPropSheet::Pppges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkPropSheet::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CNetworkPropSheet::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CNetworkPropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNetworkGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetworkGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetworkGeneralPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CNetworkGeneralPage)
    ON_BN_CLICKED(IDC_PP_NET_ROLE_ENABLE_NETWORK, OnEnableNetwork)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_NET_NAME, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_NET_DESC, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_NET_ROLE_ALL_COMM, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_NET_ROLE_INTERNAL_ONLY, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_NET_ROLE_CLIENT_ONLY, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_NET_ADDRESS_MASK, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkGeneralPage::CNetworkGeneralPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkGeneralPage::CNetworkGeneralPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_NET_GENERAL)
{
    //{{AFX_DATA_INIT(CNetworkGeneralPage)
    m_strName = _T("");
    m_strDesc = _T("");
    m_bEnabled = FALSE;
    m_nRole = -1;
    m_strAddressMask = _T("");
    m_strState = _T("");
    //}}AFX_DATA_INIT

}  //*** CNetworkGeneralPage::CNetworkGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkGeneralPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    bSuccess;

    ASSERT_KINDOF(CNetworkPropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);
    if (bSuccess)
    {
        try
        {
            m_strName = PciNet()->StrName();
            m_strDesc = PciNet()->StrDescription();
            m_cnr = PciNet()->Cnr();
            m_strAddressMask = PciNet()->StrAddressMask();
            PciNet()->GetStateName(m_strState);

            if (m_cnr == ClusterNetworkRoleNone)
            {
                m_bEnabled = FALSE;
                m_nRole = -1;
            }  // if:  network is disabled
            else
            {
                m_bEnabled = TRUE;
                if (m_cnr == ClusterNetworkRoleClientAccess)
                    m_nRole = 0;
                else if (m_cnr == ClusterNetworkRoleInternalUse)
                    m_nRole = 1;
                else if (m_cnr == ClusterNetworkRoleInternalAndClient)
                    m_nRole = 2;
                else
                {
                    ASSERT(0);
                    m_nRole = -1;
                    m_bEnabled = FALSE;
                }  // else;  Unknown role
            }  // else:  network not disabled
        } // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  //  if:  base class method was successful

    return bSuccess;

}  //*** CNetworkGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkGeneralPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkGeneralPage::DoDataExchange(CDataExchange* pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNetworkGeneralPage)
    DDX_Control(pDX, IDC_PP_NET_ADDRESS_MASK, m_editAddressMask);
    DDX_Control(pDX, IDC_PP_NET_ROLE_ENABLE_NETWORK, m_ckbEnable);
    DDX_Control(pDX, IDC_PP_NET_ROLE_CLIENT_ONLY, m_rbRoleClientOnly);
    DDX_Control(pDX, IDC_PP_NET_ROLE_INTERNAL_ONLY, m_rbRoleInternalOnly);
    DDX_Control(pDX, IDC_PP_NET_ROLE_ALL_COMM, m_rbRoleAllComm);
    DDX_Control(pDX, IDC_PP_NET_DESC, m_editDesc);
    DDX_Control(pDX, IDC_PP_NET_NAME, m_editName);
    DDX_Text(pDX, IDC_PP_NET_NAME, m_strName);
    DDX_Text(pDX, IDC_PP_NET_DESC, m_strDesc);
    DDX_Text(pDX, IDC_PP_NET_ADDRESS_MASK, m_strAddressMask);
    DDX_Text(pDX, IDC_PP_NET_CURRENT_STATE, m_strState);
    DDX_Radio(pDX, IDC_PP_NET_ROLE_CLIENT_ONLY, m_nRole);
    DDX_Check(pDX, IDC_PP_NET_ROLE_ENABLE_NETWORK, m_bEnabled);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if ( ! BReadOnly() )
        {
            DDV_RequiredText(pDX, IDC_PP_NET_NAME, IDC_PP_NET_NAME_LABEL, m_strName);

            // Validate the name.
            if (!NcIsValidConnectionName(m_strName))
            {
                ThrowStaticException((IDS) IDS_INVALID_NETWORK_CONNECTION_NAME);
            } // if:  error validating the name

            // Convert address and address mask.
            if (m_bEnabled)
            {
                switch (m_nRole)
                {
                    case 0:
                        m_cnr = ClusterNetworkRoleClientAccess;
                        break;
                    case 1:
                        m_cnr = ClusterNetworkRoleInternalUse;
                        break;
                    case 2:
                        m_cnr = ClusterNetworkRoleInternalAndClient;
                        break;
                    default:
                        ASSERT(0);
                        break;
                }  // switch:  m_nRole
            } // if: not read only
        }  // if:  network is enabled
        else
            m_cnr = ClusterNetworkRoleNone;
    }  // if:  saving data from dialog

}  //*** CNetworkGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkGeneralPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_editName.SetReadOnly(TRUE);
        m_editDesc.SetReadOnly(TRUE);
        m_ckbEnable.EnableWindow(FALSE);
        m_rbRoleAllComm.EnableWindow(FALSE);
        m_rbRoleInternalOnly.EnableWindow(FALSE);
        m_rbRoleClientOnly.EnableWindow(FALSE);
        m_editAddressMask.SetReadOnly(TRUE);
    }  // if:  sheet is read-only
    else
    {
        m_editName.SetLimitText(NETCON_MAX_NAME_LEN);
    }  // else:  sheet is read/write

    OnEnableNetwork();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNetworkGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkGeneralPage::OnApply
//
//  Routine Description:
//      Handler for when the Apply button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkGeneralPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciNet()->SetName(m_strName);
        PciNet()->SetCommonProperties(
                            m_strDesc,
                            m_cnr
                            );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CNetworkGeneralPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkGeneralPage::OnEnableNetwork
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Enable network checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkGeneralPage::OnEnableNetwork(void)
{
    BOOL    bEnabled;

    OnChangeCtrl();

    bEnabled = (!BReadOnly() && (m_ckbEnable.GetCheck() == BST_CHECKED));

    m_rbRoleAllComm.EnableWindow(bEnabled);
    m_rbRoleInternalOnly.EnableWindow(bEnabled);
    m_rbRoleClientOnly.EnableWindow(bEnabled);
    GetDlgItem(IDC_PP_NET_ROLE_CAPTION)->EnableWindow(bEnabled);

    if (   bEnabled
        && (m_rbRoleAllComm.GetCheck() != BST_CHECKED)
        && (m_rbRoleInternalOnly.GetCheck() != BST_CHECKED)
        && (m_rbRoleClientOnly.GetCheck() != BST_CHECKED))
    {
        m_rbRoleAllComm.SetCheck(BST_CHECKED);
    } // if:

    if ( ! bEnabled )
    {
        m_cnr = ClusterNetworkRoleNone;
    } // if:

}  //*** CNetworkGeneralPage::OnEnableNetwork()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\node.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Node.cpp
//
//  Description:
//      Implementation of the CClusNode class.
//
//  Maintained By:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Node.h"
#include "ClusItem.inl"
#include "NodeProp.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "Cluster.h"
#include "CASvc.h"
#include "ResType.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagNode(_T("Document"), _T("NODE"), 0);
CTraceTag   g_tagNodeDrag(_T("Drag&Drop"), _T("NODE DRAG"), 0);
CTraceTag   g_tagNodeNotify(_T("Notify"), _T("NODE NOTIFY"), 0);
CTraceTag   g_tagNodeRegNotify(_T("Notify"), _T("NODE REG NOTIFY"), 0);
#endif


/////////////////////////////////////////////////////////////////////////////
// CClusterNode
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterNode, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CClusterNode, CClusterItem)
    //{{AFX_MSG_MAP(CClusterNode)
    ON_UPDATE_COMMAND_UI(ID_FILE_PAUSE_NODE, OnUpdatePauseNode)
    ON_UPDATE_COMMAND_UI(ID_FILE_RESUME_NODE, OnUpdateResumeNode)
    ON_UPDATE_COMMAND_UI(ID_FILE_EVICT_NODE, OnUpdateEvictNode)
    ON_UPDATE_COMMAND_UI(ID_FILE_START_SERVICE, OnUpdateStartService)
    ON_UPDATE_COMMAND_UI(ID_FILE_STOP_SERVICE, OnUpdateStopService)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_PAUSE_NODE, OnCmdPauseNode)
    ON_COMMAND(ID_FILE_RESUME_NODE, OnCmdResumeNode)
    ON_COMMAND(ID_FILE_EVICT_NODE, OnCmdEvictNode)
    ON_COMMAND(ID_FILE_START_SERVICE, OnCmdStartService)
    ON_COMMAND(ID_FILE_STOP_SERVICE, OnCmdStopService)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::CClusterNode
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNode::CClusterNode(void) : CClusterItem(NULL, IDS_ITEMTYPE_NODE)
{
    m_idmPopupMenu = IDM_NODE_POPUP;
    m_hnode = NULL;

    m_nNodeHighestVersion = 0;
    m_nNodeLowestVersion = 0;
    m_nMajorVersion = 0;
    m_nMinorVersion = 0;
    m_nBuildNumber = 0;

    m_plpcigrpOnline = NULL;
    m_plpciresOnline = NULL;
    m_plpciNetInterfaces = NULL;

    // Set the object type image.
    m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_NODE);

    // Setup the property array.
    {
        m_rgProps[epropName].Set(CLUSREG_NAME_NODE_NAME, m_strName, m_strName);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_NODE_DESC, m_strDescription, m_strDescription);
        m_rgProps[epropNodeHighestVersion].Set(CLUSREG_NAME_NODE_HIGHEST_VERSION, m_nNodeHighestVersion, m_nNodeHighestVersion);
        m_rgProps[epropNodeLowestVersion].Set(CLUSREG_NAME_NODE_LOWEST_VERSION, m_nNodeLowestVersion, m_nNodeLowestVersion);
        m_rgProps[epropMajorVersion].Set(CLUSREG_NAME_NODE_MAJOR_VERSION, m_nMajorVersion, m_nMajorVersion);
        m_rgProps[epropMinorVersion].Set(CLUSREG_NAME_NODE_MINOR_VERSION, m_nMinorVersion, m_nMinorVersion);
        m_rgProps[epropBuildNumber].Set(CLUSREG_NAME_NODE_BUILD_NUMBER, m_nBuildNumber, m_nBuildNumber);
        m_rgProps[epropCSDVersion].Set(CLUSREG_NAME_NODE_CSDVERSION, m_strCSDVersion, m_strCSDVersion);
    }  // Setup the property array

    // To keep the application running as long as an OLE automation
    //  object is active, the constructor calls AfxOleLockApp.

//  AfxOleLockApp();

}  //*** CClusterNode::CClusterNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::~CClusterNode
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNode::~CClusterNode(void)
{
    delete m_plpcigrpOnline;
    delete m_plpciresOnline;
    delete m_plpciNetInterfaces;

    // Close the node.
    if (Hnode() != NULL)
    {
        CloseClusterNode(Hnode());
    }

    // To terminate the application when all objects created with
    //  with OLE automation, the destructor calls AfxOleUnlockApp.

//  AfxOleUnlockApp();

}  //*** CClusterNode::~CClusterNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::Cleanup
//
//  Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::Cleanup(void)
{
    // Delete the Groups Online list.
    if (m_plpcigrpOnline != NULL)
    {
        m_plpcigrpOnline->RemoveAll();
    }

    // Delete the Resources Online list.
    if (m_plpciresOnline != NULL)
    {
        m_plpciresOnline->RemoveAll();
    }

    // Delete the Network Interfaces list.
    if (m_plpciNetInterfaces != NULL)
    {
        m_plpciNetInterfaces->RemoveAll();
    }

    // Remove the item from the node list.
    {
        POSITION    posPci;

        posPci = Pdoc()->LpciNodes().Find(this);
        if (posPci != NULL)
        {
            Pdoc()->LpciNodes().RemoveAt(posPci);
        }  // if:  found in the document's list
    }  // Remove the item from the node list

}  //*** CClusterNode::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::Init
//
//  Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenClusterGroup or ClusterRegOpenKey.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LONG        lResult;
    CWaitCursor wc;

    ASSERT(Hnode() == NULL);
    ASSERT(Hkey() == NULL);

    // Call the base class method.
    CClusterItem::Init(pdoc, lpszName);

    try
    {
        // Open the node.
        m_hnode = OpenClusterNode(Hcluster(), lpszName);
        if (Hnode() == NULL)
        {
            dwStatus = GetLastError();
            ThrowStaticException(dwStatus, IDS_OPEN_NODE_ERROR, lpszName);
        }  // if:  error opening the cluster node

        // Get the node registry key.
        m_hkey = GetClusterNodeKey(Hnode(), MAXIMUM_ALLOWED);
        if (Hkey() == NULL)
        {
            ThrowStaticException(GetLastError(), IDS_GET_NODE_KEY_ERROR, lpszName);
        }

        ASSERT(Pcnk() != NULL);
        Trace(g_tagClusItemNotify, _T("CClusterNode::Init() - Registering for node notifications (%08.8x) for '%s'"), Pcnk(), StrName());

        // Register for node notifications.
        lResult = RegisterClusterNotify(
                            GetClusterAdminApp()->HchangeNotifyPort(),
                            (CLUSTER_CHANGE_NODE_STATE
                                | CLUSTER_CHANGE_NODE_DELETED
                                | CLUSTER_CHANGE_NODE_PROPERTY),
                            Hnode(),
                            (DWORD_PTR) Pcnk()
                            );
        if (lResult != ERROR_SUCCESS)
        {
            dwStatus = lResult;
            ThrowStaticException(dwStatus, IDS_NODE_NOTIF_REG_ERROR, lpszName);
        }  // if:  error registering for node notifications

        // Register for registry notifications.
        if (Hkey() != NULL)
        {
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (CLUSTER_CHANGE_REGISTRY_NAME
                                    | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                    | CLUSTER_CHANGE_REGISTRY_VALUE
                                    | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                Hkey(),
                                (DWORD_PTR) Pcnk()
                                );
            if (lResult != ERROR_SUCCESS)
            {
                dwStatus = lResult;
                ThrowStaticException(dwStatus, IDS_NODE_NOTIF_REG_ERROR, lpszName);
            }  // if:  error registering for registry notifications
        }  // if:  there is a key

        // Allocate lists.
        m_plpcigrpOnline = new CGroupList;
        if ( m_plpcigrpOnline == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the group list

        m_plpciresOnline = new CResourceList;
        if ( m_plpciresOnline == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the resource list

        m_plpciNetInterfaces = new CNetInterfaceList;
        if ( m_plpciNetInterfaces == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the net interface list

        // Read the initial state.
        UpdateState();
    }  // try
    catch (CException *)
    {
        if (Hkey() != NULL)
        {
            ClusterRegCloseKey(Hkey());
            m_hkey = NULL;
        }  // if:  registry key opened
        if (Hnode() != NULL)
        {
            CloseClusterNode(Hnode());
            m_hnode = NULL;
        }  // if:  node opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CClusterNode::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::ReadItem
//
//  Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions from CClusterItem::ReadItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::ReadItem(void)
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT(Hnode() != NULL);

    if (Hnode() != NULL)
    {
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;

        // Call the base class method.
        CClusterItem::ReadItem();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNodeProperties(
                                Hnode(),
                                CLUSCTL_NODE_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                dwStatus = DwParseProperties(cpl);
            }
            if (dwStatus != ERROR_SUCCESS)
            {
                dwRetStatus = dwStatus;
            }
        }  // Read and parse the common properties

        // Read and parse the read-only common properties.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNodeProperties(
                                Hnode(),
                                CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                dwStatus = DwParseProperties(cpl);
            }
            if (dwStatus != ERROR_SUCCESS)
            {
                dwRetStatus = dwStatus;
            }
        }  // if:  no error yet

        // Read extension lists.
        ReadExtensions();

    }  // if:  node is avaialble

    // Read the initial state.
    UpdateState();

//  ConstructActiveGroupList();
//  ConstructActiveResourceList();

    // If any errors occurred, throw an exception.
    if (dwRetStatus != ERROR_SUCCESS)
    {
        m_bReadOnly = TRUE;
        ThrowStaticException(dwRetStatus, IDS_READ_NODE_PROPS_ERROR, StrName());
    }  // if:  error reading properties

    MarkAsChanged(FALSE);

}  //*** CClusterNode::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::PlstrExtensions
//
//  Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Values:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CClusterNode::PlstrExtensions(void) const
{
    return &Pdoc()->PciCluster()->LstrNodeExtensions();

}  //*** CClusterNode::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::ReadExtensions
//
//  Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::ReadExtensions(void)
{
}  //*** CClusterNode::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::AddActiveGroup
//
//  Description:
//      Add a group to the list of active groups.
//
//  Arguments:
//      pciGroup    [IN OUT] New active group.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::AddActiveGroup(IN OUT CGroup * pciGroup)
{
    POSITION    posPci;

    Trace(g_tagNode, _T("Adding active group '%s' (%x) to node '%s"), (pciGroup ? pciGroup->StrName() : _T("")), pciGroup, StrName());

    // Make sure the group is not already in the list.
    VERIFY((posPci = LpcigrpOnline().Find(pciGroup)) == NULL);

    if (posPci == NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiGroups;

        // Loop through each tree item to update the Active Groups list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Groups child tree item and add the new group.
            ptiGroups = ptiNode->PtiChildFromName(IDS_TREEITEM_ACTIVEGROUPS);
            ASSERT_VALID(ptiGroups);
            VERIFY(ptiGroups->PliAddChild(pciGroup) != NULL);
        }  // while:  more tree items for this node

        m_plpcigrpOnline->AddTail(pciGroup);
    }  // if:  group not in the list yet

}  //*** CClusterNode::AddActiveGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::AddActiveResource
//
//  Description:
//      Add a resource to the list of active resources.
//
//  Arguments:
//      pciRes      [IN OUT] New active resource.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::AddActiveResource(IN OUT CResource * pciRes)
{
    POSITION    posPci;

    Trace(g_tagNode, _T("Adding active resource '%s' (%x) to node '%s"), (pciRes ? pciRes->StrName() : _T("")), pciRes, StrName());

    // Make sure the resource is not already in the list.
    VERIFY((posPci = LpciresOnline().Find(pciRes)) == NULL);

    if (posPci == NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiResources;

        // Loop through each tree item to update the Active Resources list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Resources child tree item and add the new resource.
            ptiResources = ptiNode->PtiChildFromName(IDS_TREEITEM_ACTIVERESOURCES);
            ASSERT_VALID(ptiResources);
            VERIFY(ptiResources->PliAddChild(pciRes) != NULL);
        }  // while:  more tree items for this node

        m_plpciresOnline->AddTail(pciRes);

    }  // if:  resource not in the list yet

}  //*** CClusterNode::AddActiveResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::AddNetInterface
//
//  Description:
//      Add a network interface to the list of interaces installed in this node.
//
//  Arguments:
//      pciNetIFace     [IN OUT] New network interface.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::AddNetInterface(IN OUT CNetInterface * pciNetIFace)
{
    POSITION    posPci;

    ASSERT_VALID(pciNetIFace);
    Trace(g_tagNode, _T("(%s) (%s (%x)) - Adding network interface '%s'"), Pdoc()->StrNode(), StrName(), this, pciNetIFace->StrName());

    // Make sure the resource is not already in the list.
    VERIFY((posPci = LpciNetInterfaces().Find(pciNetIFace)) == NULL);

    if (posPci == NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiNetIFace;

        // Loop through each tree item to update the Network Interfaces list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Resources child tree item and add the new resource.
            ptiNetIFace = ptiNode->PtiChildFromName(IDS_TREEITEM_NETIFACES);
            ASSERT_VALID(ptiNetIFace);
            VERIFY(ptiNetIFace->PliAddChild(pciNetIFace) != NULL);
        }  // while:  more tree items for this node

        m_plpciNetInterfaces->AddTail(pciNetIFace);

    }  // if:  network interface not in the list yet

}  //*** CClusterNode::AddNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::RemoveActiveGroup
//
//  Description:
//      Remove a group from the list of active groups.
//
//  Arguments:
//      pciGroup    [IN OUT] Group that is no longer active on this node.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::RemoveActiveGroup(IN OUT CGroup * pciGroup)
{
    POSITION    posPci;

    Trace(g_tagNode, _T("Removing active group '%s' (%x) from node '%s"), (pciGroup ? pciGroup->StrName() : _T("")), pciGroup, StrName());

    // Make sure the group is in the list.
    VERIFY((posPci = LpcigrpOnline().Find(pciGroup)) != NULL);

    if (posPci != NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiGroups;

        // Loop through each tree item to update the Active Groups list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Groups child tree item and remove the group.
            ptiGroups = ptiNode->PtiChildFromName(IDS_TREEITEM_ACTIVEGROUPS);
            ASSERT_VALID(ptiGroups);
            ptiGroups->RemoveChild(pciGroup);
        }  // while:  more tree items for this node

        m_plpcigrpOnline->RemoveAt(posPci);

    }  // if:  group in the list

}  //*** CClusterNode::RemoveActiveGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::RemoveActiveResource
//
//  Description:
//      Remove a resource from the list of active resources.
//
//  Arguments:
//      pciRes      [IN OUT] Resource that is no longer active on this node.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::RemoveActiveResource(IN OUT CResource * pciRes)
{
    POSITION    posPci;

    Trace(g_tagNode, _T("Removing active resource '%s' (%x) from node '%s"), (pciRes ? pciRes->StrName() : _T("")), pciRes, StrName());

    // Make sure the resource is in the list.
    VERIFY((posPci = LpciresOnline().Find(pciRes)) != NULL);

    if (posPci != NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiResources;

        // Loop through each tree item to update the Active Resources list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Resources child tree item and remove the resource.
            ptiResources = ptiNode->PtiChildFromName(IDS_TREEITEM_ACTIVERESOURCES);
            ASSERT_VALID(ptiResources);
            ptiResources->RemoveChild(pciRes);
        }  // while:  more tree items for this node

        m_plpciresOnline->RemoveAt(posPci);

    }  // if:  resource in the list

}  //*** CClusterNode::RemoveActiveResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::RemoveNetInterface
//
//  Description:
//      Remove a network interface from the list of interaces installed in this node.
//
//  Arguments:
//      pciNetIFace     [IN OUT] Network interface that is no longer
//                          connected to this network.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::RemoveNetInterface(IN OUT CNetInterface * pciNetIFace)
{
    POSITION    posPci;

    ASSERT_VALID(pciNetIFace);
    Trace(g_tagNode, _T("(%s) (%s (%x)) - Removing network interface '%s'"), Pdoc()->StrNode(), StrName(), this, pciNetIFace->StrName());

    // Make sure the network interface is in the list.
    VERIFY((posPci = LpciNetInterfaces().Find(pciNetIFace)) != NULL);

    if (posPci != NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiNetIFace;

        // Loop through each tree item to update the Network Interfaces list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Network Interfaces child tree item and remove the resource.
            ptiNetIFace = ptiNode->PtiChildFromName(IDS_TREEITEM_NETIFACES);
            ASSERT_VALID(ptiNetIFace);
            ptiNetIFace->RemoveChild(pciNetIFace);
        }  // while:  more tree items for this network

        m_plpciNetInterfaces->RemoveAt(posPci);

    }  // if:  network interface in the list

}  //*** CClusterNode::RemoveNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::SetDescription
//
//  Description:
//      Set the description in the cluster database.
//
//  Arguments:
//      rstrDesc        [IN] Description to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::SetDescription(
    IN const CString &  rstrDesc,
    IN BOOL             bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;

    try
    {
        CClusterItem::SetCommonProperties(bValidateOnly);
    }  // try
    catch (CNTException * pnte)
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    }  // catch:  CNTException

    m_rgProps[epropDescription].m_value.pstr = &m_strDescription;

    if (nte.Sc() != ERROR_SUCCESS)
    {
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );
    }

}  //*** CClusterNode::SetDescription()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::DwSetCommonProperties
//
//  Description:
//      Set the common properties for this resource in the cluster database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Values:
//      Any status returned by ClusterResourceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNode::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnode());

    if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if (bValidateOnly)
            dwControl = CLUSCTL_NODE_VALIDATE_COMMON_PROPERTIES;
        else
            dwControl = CLUSCTL_NODE_SET_COMMON_PROPERTIES;

        // Set private properties.
        dwStatus = ClusterNodeControl(
                        Hnode(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        static_cast< DWORD >( rcpl.CbPropList() ),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
    {
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;

}  //*** CClusterNode::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::BCanBeDropTarget
//
//  Description:
//      Determine if the specified item can be dropped on this item.
//
//  Arguments:
//      pci         [IN OUT] Item to be dropped on this item.
//
//  Return Values:
//      TRUE        Can be drop target.
//      FALSE       Can NOT be drop target.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNode::BCanBeDropTarget(IN const CClusterItem * pci) const
{
    BOOL    bCan;

    // This node can be a drop target only if the specified item
    // is a group and it is not already a running on this node.

    if (    (Cns() == ClusterNodeUp)
        &&  (pci->IdsType() == IDS_ITEMTYPE_GROUP))
    {
        CGroup *    pciGroup = (CGroup *) pci;
        ASSERT_KINDOF(CGroup, pciGroup);
        if (pciGroup->StrOwner() != StrName())
        {
            bCan = TRUE;
        }
        else
        {
            bCan = FALSE;
        }
        Trace(g_tagNodeDrag, _T("BCanBeDropTarget() - Dragging group '%s' (%x) (owner = '%s') over node '%s' (%x)"), pciGroup->StrName(), pciGroup, pciGroup->StrOwner(), StrName(), this);
    }  // if:  node is up and dropping group item
    else
    {
        bCan = FALSE;
    }

    return bCan;

}  //*** CClusterNode::BCanBeDropTarget()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::DropItem
//
//  Description:
//      Process an item being dropped on this item.
//
//  Arguments:
//      pci         [IN OUT] Item dropped on this item.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::DropItem(IN OUT CClusterItem * pci)
{
    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    if (BCanBeDropTarget(pci))
    {
        POSITION        pos;
        UINT            imenu;
        UINT            idMenu;
        CClusterNode *  pciNode;
        CGroup *        pciGroup;

        // Calculate the ID of this node.
        pos = Pdoc()->LpciNodes().GetHeadPosition();
        for (imenu = 0, idMenu = ID_FILE_MOVE_GROUP_1
                ; pos != NULL
                ; idMenu++)
        {
            pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext(pos);
            ASSERT_VALID(pciNode);
            if (pciNode == this)
            {
                break;
            }
        }  // for:  each group
        ASSERT(imenu < (UINT) Pdoc()->LpciNodes().GetCount());

        // Change the group of the specified resource.
        pciGroup = (CGroup *) pci;
        ASSERT_KINDOF(CGroup, pci);
        ASSERT_VALID(pciGroup);

        // Verify that the resource should be moved.
        {
            CString strMsg;

            strMsg.FormatMessage(IDS_VERIFY_MOVE_GROUP, pciGroup->StrName(), pciGroup->StrOwner(), StrName());
            if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
            {
                goto Cleanup;
            }
        }  // Verify that the resource should be moved

        // Move the group.
        pciGroup->OnCmdMoveGroup(idMenu);
    }  // if:  item can be dropped on this item
    else if (pci->IdsType() == IDS_ITEMTYPE_GROUP)
    {
        CString     strMsg;

#ifdef _DEBUG
        CGroup *    pciGroup = (CGroup *) pci;

        ASSERT_KINDOF(CGroup, pci);
        ASSERT_VALID(pciGroup);
#endif // _DEBUG

        // Format the proper message.
        if (Cns() != ClusterNodeUp)
        {
            strMsg.FormatMessage(IDS_CANT_MOVE_GROUP_TO_DOWN_NODE, pci->StrName(), StrName());
        }
        else
        {
            ASSERT(pciGroup->StrOwner() == StrName());
            strMsg.FormatMessage(IDS_CANT_MOVE_GROUP_TO_SAME_NODE, pci->StrName(), StrName());
        }  // else:  problem is not that the node is not up
        AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
    }  // else if:  dropped item is a group
    else
    {
        CClusterItem::DropItem(pci);
    }

Cleanup:

    Release();

}  //*** CClusterNode::DropItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::UpdateState
//
//  Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::UpdateState( void )
{
    CClusterAdminApp *  papp    = GetClusterAdminApp();
    CLUSTER_NODE_STATE  cnsPrev = m_cns;

    // Get the current state of the node.
    if ( Hnode() == NULL )
    {
        m_cns = ClusterNodeStateUnknown;
    } // if: node is not valid
    else
    {
        CWaitCursor wc;

        m_cns = GetClusterNodeState( Hnode() );
    }  // else:  node is valid

    // Save the current state image index.
    switch ( Cns() )
    {
        case ClusterNodeStateUnknown:
            m_iimgState = papp->Iimg( IMGLI_NODE_UNKNOWN );
            break;
        case ClusterNodeUp:
            m_iimgState = papp->Iimg( IMGLI_NODE );
            if ( cnsPrev == ClusterNodeDown )
            {
                UpdateResourceTypePossibleOwners();
            } // if: node was previously down
            break;
        case ClusterNodeDown:
            m_iimgState = papp->Iimg( IMGLI_NODE_DOWN );
            break;
        case ClusterNodePaused:
            m_iimgState = papp->Iimg( IMGLI_NODE_PAUSED );
            break;
        case ClusterNodeJoining:
            m_iimgState = papp->Iimg( IMGLI_NODE_UNKNOWN );
            break;
        default:
            Trace( g_tagNode, _T("(%s (%x)) - UpdateState: Unknown state '%d' for node '%s'"), StrName(), this, Cns(), StrName() );
            m_iimgState = (UINT) -1;
            break;
    }  // switch:  Cns()

    // Call the base class method.
    CClusterItem::UpdateState();

}  //*** CClusterNode::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::UpdateResourceTypePossibleOwners
//
//  Description:
//      Update the possible owner lists of any resource types that have
//      faked them because of nodes being down.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::UpdateResourceTypePossibleOwners( void )
{
    POSITION        pos;
    CResourceType * pciResType;

    pos = Pdoc()->LpciResourceTypes().GetHeadPosition();
    while ( pos != NULL )
    {
        pciResType = (CResourceType *) Pdoc()->LpciResourceTypes().GetNext( pos );
        ASSERT_VALID( pciResType );
        if ( pciResType->BPossibleOwnersAreFake() )
        {
            pciResType->CollectPossibleOwners();
        } // if: possible owners have been faked
    } // while: more resource types

} //*** CClusterNode::UpdateResourceTypePossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnFinalRelease
//
//  Description:
//      Called when the last OLE reference to or from the object is released.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnFinalRelease(void)
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CClusterItem::OnFinalRelease();

}  //*** CClusterNode::OnFinalRelease()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::BGetColumnData
//
//  Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid       [IN] Column ID.
//      rstrText    [OUT] String in which to return the text for the column.
//
//  Return Values:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNode::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
    BOOL    bSuccess;

    switch (colid)
    {
        case IDS_COLTEXT_STATE:
            GetStateName(rstrText);
            bSuccess = TRUE;
            break;
        default:
            bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CClusterNode::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::GetTreeName
//
//  Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CClusterNode::GetTreeName(OUT CString & rstrName) const
{
    CString     strState;

    GetStateName(strState);
    rstrName.Format(_T("%s (%s)"), StrName(), strState);

}  //*** CClusterNode::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::GetStateName
//
//  Description:
//      Returns a string with the name of the current state.
//
//  Arguments:
//      rstrState   [OUT] String in which to return the name of the current state.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::GetStateName(OUT CString & rstrState) const
{
    switch (Cns())
    {
        case ClusterNodeStateUnknown:
            rstrState.LoadString(IDS_UNKNOWN);
            break;
        case ClusterNodeUp:
            rstrState.LoadString(IDS_UP);
            break;
        case ClusterNodeDown:
            rstrState.LoadString(IDS_DOWN);
            break;
        case ClusterNodePaused:
            rstrState.LoadString(IDS_PAUSED);
            break;
        case ClusterNodeJoining:
            rstrState.LoadString(IDS_JOINING);
            break;
        default:
            rstrState.Empty();
            break;
    }  // switch:  Cns()

}  //*** CClusterNode::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdatePauseNode
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_PAUSE_NODE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdatePauseNode(CCmdUI * pCmdUI)
{
    if (Cns() == ClusterNodeUp)
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

}  //*** CClusterNode::OnUpdatePauseNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateResumeNode
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_RESUME_NODE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateResumeNode(CCmdUI * pCmdUI)
{
    if (Cns() == ClusterNodePaused)
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

}  //*** CClusterNode::OnUpdateResumeNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateEvictNode
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_EVICT_NODE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateEvictNode( CCmdUI * pCmdUI )
{
    BOOL    fCanEvict;

    fCanEvict = FCanBeEvicted();

    pCmdUI->Enable( fCanEvict );

}  //*** CClusterNode::OnUpdateEvictNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateStartService
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_START_SERVICE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateStartService(CCmdUI * pCmdUI)
{
    if (    (Cns() == ClusterNodeStateUnknown)
        ||  (Cns() == ClusterNodeDown))
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

}  //*** CClusterNode::OnUpdateStartService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateStopService
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_STOP_SERVICE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateStopService(CCmdUI * pCmdUI)
{
    if (    (Cns() == ClusterNodeStateUnknown)
        ||  (Cns() == ClusterNodeUp))
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

}  //*** CClusterNode::OnUpdateStopService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdPauseNode
//
//  Description:
//      Processes the ID_FILE_PAUSE_NODE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdPauseNode(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnode() != NULL);

    dwStatus = PauseClusterNode(Hnode());
    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException    nte(dwStatus, IDS_PAUSE_NODE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
        nte.ReportError();
    }  // if:  error pausing node

    UpdateState();

}  //*** CClusterNode::OnCmdPauseNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdResumeNode
//
//  Description:
//      Processes the ID_FILE_RESUME_NODE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdResumeNode(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnode() != NULL);

    dwStatus = ResumeClusterNode(Hnode());
    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException    nte(dwStatus, IDS_RESUME_NODE_ERROR, StrName(), NULL, FALSE /*bAUtoDelete*/);
        nte.ReportError();
    }  // if:  error resuming node

    UpdateState();

}  //*** CClusterNode::OnCmdResumeNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdEvictNode
//
//  Description:
//      Processes the ID_FILE_EVICT_NODE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdEvictNode(void)
{
    ASSERT(Hnode() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    if ( ! FCanBeEvicted() )
    {
        TCHAR   szMsg[1024];
        CNTException nte(ERROR_CANT_EVICT_ACTIVE_NODE, 0, NULL, NULL, FALSE /*bAutoDelete*/);
        nte.FormatErrorMessage(szMsg, sizeof(szMsg) / sizeof(TCHAR), NULL, FALSE /*bIncludeID*/);
        AfxMessageBox(szMsg);
    }  // if:  node can not be evicted
    else
    {
        DWORD       dwStatus;
        UINT        cNodes;
        DWORD       dwCleanupStatus;
        HRESULT     hrCleanupStatus;
        CString     strMsg;
        CWaitCursor wc;

        try
        {
            // Verify that the user really wants to evict this node.
            strMsg.FormatMessage(IDS_VERIFY_EVICT_NODE, StrName());
            if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) == IDYES)
            {
                // How many nodes are in the cluster?
                cNodes = (UINT)Pdoc()->LpciNodes().GetCount();

                // Evict the node.
                dwStatus = EvictClusterNodeEx(Hnode(), INFINITE, &hrCleanupStatus);
               
                // convert any cleanup error from an hresult to a win32 error code 
                dwCleanupStatus = HRESULT_CODE( hrCleanupStatus );

                if( ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP == dwStatus )
                {
                    //
                    // Eviction was successful, but cleanup failed.  dwCleanupStatus contains
                    // the cleanup error code. 
                    //
                    CNTException nte( dwCleanupStatus, IDS_EVICT_NODE_ERROR_UNAVAILABLE, StrName(), NULL, FALSE /*bAutoDelete*/ );
                    nte.ReportError();

                    // Reset dwStatus to use in our test on whether or not to close the window.
                    dwStatus = ERROR_SUCCESS;
                }
                else if( ERROR_SUCCESS != dwStatus )
                {
                    //
                    // Eviction was not successful.  Display the error.
                    //
                    CNTException nte(dwStatus, IDS_EVICT_NODE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
                    nte.ReportError();
                }  // if:  error evicting the node
                // else: eviction and cleanup successful

                if ( cNodes == 1 && dwStatus == ERROR_SUCCESS )
                {
                    // This was the last node, so close the window since the cluster doesn't exist any more.
                    m_pdoc->OnCloseDocument();
                }

                UpdateState();

            } // if: user selected yes from message box (to online resource)

        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // else:  node is down

    Release();

}  //*** CClusterNode::OnCmdEvictNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdStartService
//
//  Description:
//      Processes the ID_FILE_START_SERVICE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdStartService(void)
{
    HRESULT     hr;
    BOOL        bRefresh = FALSE;
    CWaitCursor wc;

    // If all nodes are down or unavailable, we need to refresh.
    if ( Cns() == ClusterNodeStateUnknown )
    {
        bRefresh = TRUE;
    }
    else
    {
        int             cNodesUp = 0;
        POSITION        pos;
        CClusterNode *  pciNode;

        pos = Pdoc()->LpciNodes().GetHeadPosition();
        while ( pos != NULL )
        {
            pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext( pos );
            ASSERT_VALID( pciNode );
            if ( pciNode->Cns() == ClusterNodeStateUnknown )
            {
                cNodesUp++;
            }
        }  // while:  more items in the list
        if ( cNodesUp > 0 )
        {
            bRefresh = TRUE;
        }
    }  // else:  node state is available

    // Start the service.
    hr = HrStartService( CLUSTER_SERVICE_NAME, StrName() );
    if ( FAILED( hr ) )
    {
        CNTException    nte( hr, IDS_START_CLUSTER_SERVICE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/ );
        nte.ReportError();
    }  // if:  error starting the service
    else if ( bRefresh )
    {
        Sleep( 2000 );
        Pdoc()->Refresh();
    }  // else if:  we need to refresh

} //*** CClusterNode::OnCmdStartService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdStopService
//
//  Description:
//      Processes the ID_FILE_STOP_SERVICE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdStopService(void)
{
    HRESULT                 hr;

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // Stop the service.
    hr = HrStopService( CLUSTER_SERVICE_NAME, StrName() );
    if ( FAILED( hr ) )
    {
        CNTException    nte( hr, IDS_STOP_CLUSTER_SERVICE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/ );
        nte.ReportError();
    }

    Release();

} //*** CClusterNode::OnCmdStopService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateProperties
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateProperties(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(TRUE);

}  //*** CClusterNode::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::BDisplayProperties
//
//  Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Values:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNode::BDisplayProperties(IN BOOL bReadOnly)
{
    BOOL            bChanged = FALSE;
    CNodePropSheet  sht(AfxGetMainWnd());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if (BChanged())
    {
        ReadItem();
    }

    // Display the property sheet.
    try
    {
        sht.SetReadOnly(bReadOnly);
        if (sht.BInit(this, IimgObjectType()))
        {
            bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
        }
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CClusterNode::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnClusterNotify
//
//  Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Values:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterNode::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
    ASSERT(pnotify != NULL);
    ASSERT_VALID(this);

    try
    {
        switch (pnotify->m_dwFilterType)
        {
            case CLUSTER_CHANGE_NODE_STATE:
                Trace(g_tagNodeNotify, _T("(%s) - Node '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                UpdateState();
                break;

            case CLUSTER_CHANGE_NODE_DELETED:
                Trace(g_tagNodeNotify, _T("(%s) - Node '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    Delete();
                break;

            case CLUSTER_CHANGE_NODE_PROPERTY:
                Trace(g_tagNodeNotify, _T("(%s) - Node '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    ReadItem();
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace(g_tagNodeRegNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace(g_tagNodeRegNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace(g_tagNodeRegNotify, _T("(%s) - Registry value '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            default:
                Trace(g_tagNodeNotify, _T("(%s) - Unknown node notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
        }  // switch:  dwFilterType
    }  // try
    catch (CException * pe)
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    delete pnotify;
    return 0;

}  //*** CClusterNode::OnClusterNotify()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::Delete
//
//  Description:
//      Do the CClusterItem::Delete processing unique to this class.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::Delete(void)
{
    POSITION        _pos = NULL;
    CResourceType * _ptype = NULL;
    CResource *     _pres = NULL;

    //
    // Remove this node from the resource types possible owners list
    //
    _pos = Pdoc()->LpciResourceTypes().GetHeadPosition();

    while (_pos != NULL)
    {
        _ptype = dynamic_cast<CResourceType *>(Pdoc()->LpciResourceTypes().GetNext(_pos));
        if (_ptype != NULL)
        {
            _ptype->RemoveNodeFromPossibleOwners(NULL, this);
        } // if: _ptype != NULL
    } // while: _pos != NULL

    //
    // Remove this node from the resources possible owners list
    //
    _pos = Pdoc()->LpciResources().GetHeadPosition();

    while (_pos != NULL)
    {
        _pres = dynamic_cast<CResource *>(Pdoc()->LpciResources().GetNext(_pos));
        if (_pres != NULL)
        {
            _pres->RemoveNodeFromPossibleOwners(NULL, this);
        } // if: _pres != NULL
    } // while: _pos != NULL

    CClusterItem::Delete();             // do the old processing

}  //*** CClusterNode::Delete()
*/

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::FCanBeEvicted
//
//  Description:
//      Determine if the node can be evicted.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        Node can be evicted.
//      FALSE       Node can not be evicted.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CClusterNode::FCanBeEvicted( void )
{
    BOOL    fCanEvict;

    if ( ( m_nMajorVersion < 5 )
      || ( ( m_nMajorVersion == 5 )
        && ( m_nMinorVersion < 1 ) ) )
    {
        //
        //  GPotts: BUG 480540:  We should only be able to evict a pre-Whistler 
        //  node if it is offline.  For Whistler+ nodes if it is the last node 
        //  and online then we can evict it as well.
        //
        if ( Cns() == ClusterNodeDown )
        {
            fCanEvict = TRUE;
        }
        else
        {
            fCanEvict = FALSE;
        }
    } // if: pre-Whistler node
    else
    {
        if ( ( Cns() == ClusterNodeDown )
          || ( Pdoc()->LpciNodes().GetCount() == 1 ) )
        {
            fCanEvict = TRUE;
        }
        else
        {
            fCanEvict = FALSE;
        }
    } // else: Whistler or higher node

    return fCanEvict;

} //*** CClusterNode::FCanBeEvicted()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CNodeList & rlp)
{
    POSITION        pos;
    CClusterNode *  pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        pci = rlp.GetNext(pos);
        ASSERT_VALID(pci);
//      Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlpcinode) - Deleting node cluster item '%s' (%x)"), pci->StrName(), pci);
        pci->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\network.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  Module Name:
//      Network.h
//
//  Abstract:
//      Definition of the CNetwork class.
//
//  Implementation File:
//      Network.cpp
//
//  Author:
//      David Potter (davidp)   May 28, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETWORK_H_
#define _NETWORK_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetwork;
class CNetworkList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetInterface;
class CNetInterfaceList;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetwork command target
/////////////////////////////////////////////////////////////////////////////

class CNetwork : public CClusterItem
{
    DECLARE_DYNCREATE(CNetwork)

// Construction
public:
    CNetwork(void);     // protected constructor used by dynamic creation
    void                    Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

protected:
    void                    CommonConstruct(void);

// Attributes
protected:
    HNETWORK                m_hnetwork;
    CLUSTER_NETWORK_STATE   m_cns;

    CLUSTER_NETWORK_ROLE    m_cnr;
    CString                 m_strAddress;
    CString                 m_strAddressMask;

    DWORD                   m_dwCharacteristics;
    DWORD                   m_dwFlags;

    CNetInterfaceList *     m_plpciNetInterfaces;

    enum
    {
        epropName = 0,
        epropRole,
        epropAddress,
        epropAddressMask,
        epropDescription,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

public:
    HNETWORK                Hnetwork(void) const                { return m_hnetwork; }
    CLUSTER_NETWORK_STATE   Cns(void) const                     { return m_cns; }

    CLUSTER_NETWORK_ROLE    Cnr(void) const                     { return m_cnr; }
    const CString &         StrAddress(void) const              { return m_strAddress; }
    const CString &         StrAddressMask(void) const          { return m_strAddressMask; }
    DWORD                   DwCharacteristics(void) const       { return m_dwCharacteristics; }
    DWORD                   DwFlags(void) const                 { return m_dwFlags; }

    const CNetInterfaceList &   LpciNetInterfaces(void) const   { ASSERT(m_plpciNetInterfaces != NULL); return *m_plpciNetInterfaces; }

    void                    GetStateName(OUT CString & rstrState) const;
    void                    GetRoleName(OUT CString & rstrRole) const;

// Operations
public:
    void                    CollectInterfaces(IN OUT CNetInterfaceList * plpci) const;

    void                    ReadExtensions(void);

    void                    AddNetInterface(IN OUT CNetInterface * pciNetIFace);
    void                    RemoveNetInterface(IN OUT CNetInterface * pciNetIFace);

    void                    SetName(IN LPCTSTR pszName);
    void                    SetCommonProperties(
                                IN const CString &      rstrDesc,
                                IN CLUSTER_NETWORK_ROLE cnr,
                                IN BOOL                 bValidateOnly
                                );
    void                    SetCommonProperties(
                                IN const CString &      rstrDesc,
                                IN CLUSTER_NETWORK_ROLE cnr
                                )
    {
        SetCommonProperties(rstrDesc, cnr, FALSE /*bValidateOnly*/);
    }
    void                    ValidateCommonProperties(
                                IN const CString &      rstrDesc,
                                IN CLUSTER_NETWORK_ROLE cnr
                                )
    {
        SetCommonProperties(rstrDesc, cnr, TRUE /*bValidateOnly*/);
    }

// Overrides
public:
    virtual void            Cleanup(void);
    virtual void            ReadItem(void);
    virtual void            UpdateState(void);
    virtual void            Rename(IN LPCTSTR pszName);
    virtual BOOL            BGetColumnData(IN COLID colid, OUT CString & rstrText);
    virtual BOOL            BCanBeEdited(void) const;
    virtual void            OnBeginLabelEdit(IN OUT CEdit * pedit);
    virtual BOOL            BDisplayProperties(IN BOOL bReadOnly = FALSE);

    virtual const CStringList * PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
    virtual void            GetTreeName(OUT CString & rstrName) const;
#endif

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CNetwork)
    //}}AFX_VIRTUAL

    virtual LRESULT         OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(m_rgProps[0]); }
    virtual DWORD                   DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
public:
    virtual ~CNetwork(void);

public:
    // Generated message map functions
    //{{AFX_MSG(CNetwork)
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

};  //*** class CNetwork

/////////////////////////////////////////////////////////////////////////////
// CNetworkList
/////////////////////////////////////////////////////////////////////////////

class CNetworkList : public CClusterItemList
{
public:
    CNetwork *      PciNetworkFromName(
                        IN LPCTSTR      pszName,
                        OUT POSITION *  ppos = NULL
                        )
    {
        return (CNetwork *) PciFromName(pszName, ppos);
    }

};  //*** class CNetworkList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CNetworkList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagNetwork;
extern CTraceTag g_tagNetNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _NETWORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\node.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Node.h
//
//  Description:
//      Definition of the CClusterNode class.
//
//  Implementation File:
//      Node.cpp
//
//  Maintained By:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NODE_H_
#define _NODE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNode;
class CNodeList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _GROUP_H_
#include "Group.h"      // for CGroupList
#endif

#ifndef _RES_H_
#include "Res.h"        // for CResourceList
#endif

#ifndef _NETIFACE_H_
#include "NetIFace.h"   // for CNetInterfaceList
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterNode command target
/////////////////////////////////////////////////////////////////////////////

class CClusterNode : public CClusterItem
{
    DECLARE_DYNCREATE(CClusterNode)

    CClusterNode(void);     // protected constructor used by dynamic creation
    void                    Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

// Attributes
protected:
    HNODE                   m_hnode;
    CLUSTER_NODE_STATE      m_cns;
    DWORD                   m_nNodeHighestVersion;
    DWORD                   m_nNodeLowestVersion;
    DWORD                   m_nMajorVersion;
    DWORD                   m_nMinorVersion;
    DWORD                   m_nBuildNumber;
    CString                 m_strCSDVersion;
    CGroupList *            m_plpcigrpOnline;
    CResourceList *         m_plpciresOnline;
    CNetInterfaceList *     m_plpciNetInterfaces;

    enum
    {
        epropName = 0,
        epropDescription,
        epropNodeHighestVersion,
        epropNodeLowestVersion,
        epropMajorVersion,
        epropMinorVersion,
        epropBuildNumber,
        epropCSDVersion,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

public:
    HNODE                   Hnode(void) const           { return m_hnode; }
    CLUSTER_NODE_STATE      Cns(void) const             { return m_cns; }
    DWORD                   NNodeHighestVersion(void) const { return m_nNodeHighestVersion; }
    DWORD                   NNodeLowestVersion(void) const  { return m_nNodeLowestVersion; }
    DWORD                   NMajorVersion(void) const   { return m_nMajorVersion; }
    DWORD                   NMinorVersion(void) const   { return m_nMinorVersion; }
    DWORD                   NBuildNumber(void) const    { return m_nBuildNumber; }
    const CString &         StrCSDVersion(void) const   { return m_strCSDVersion; }
    const CGroupList &      LpcigrpOnline(void) const   { ASSERT(m_plpcigrpOnline != NULL); return *m_plpcigrpOnline; }
    const CResourceList &   LpciresOnline(void) const   { ASSERT(m_plpciresOnline != NULL); return *m_plpciresOnline; }
    const CNetInterfaceList & LpciNetInterfaces(void) const { ASSERT(m_plpciNetInterfaces != NULL); return *m_plpciNetInterfaces; }

    void                    GetStateName(OUT CString & rstrState) const;
//  void                    Delete(void);

// Operations
public:
    void                    ReadExtensions(void);

    void                    AddActiveGroup(IN OUT CGroup * pciGroup);
    void                    AddActiveResource(IN OUT CResource * pciResource);
    void                    AddNetInterface(IN OUT CNetInterface * pciNetIFace);
    void                    RemoveActiveGroup(IN OUT CGroup * pciGroup);
    void                    RemoveActiveResource(IN OUT CResource * pciResource);
    void                    RemoveNetInterface(IN OUT CNetInterface * pciNetIFace);

    void                    SetDescription(IN const CString & rstrDesc, IN BOOL bValidateOnly = FALSE);
    void                    UpdateResourceTypePossibleOwners( void );

// Overrides
public:
    virtual void            Cleanup(void);
    virtual void            ReadItem(void);
    virtual void            UpdateState(void);
    virtual BOOL            BGetColumnData(IN COLID colid, OUT CString & rstrText);
    virtual BOOL            BDisplayProperties(IN BOOL bReadOnly = FALSE);

    // Drag & Drop
    virtual BOOL            BCanBeDropTarget(IN const CClusterItem * pci) const;
    virtual void            DropItem(IN OUT CClusterItem * pci);

    virtual const CStringList * PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
    virtual void            GetTreeName(OUT CString & rstrName) const;
#endif

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterNode)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    virtual LRESULT         OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(m_rgProps[0]); }
    virtual DWORD                   DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
public:
    virtual ~CClusterNode(void);

protected:
    CTreeItem *             m_ptiActiveGroups;
    CTreeItem *             m_ptiActiveResources;

    BOOL
        FCanBeEvicted( void );

protected:
    // Generated message map functions
    //{{AFX_MSG(CClusterNode)
    afx_msg void OnUpdatePauseNode(CCmdUI* pCmdUI);
    afx_msg void OnUpdateResumeNode(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEvictNode(CCmdUI* pCmdUI);
    afx_msg void OnUpdateStartService(CCmdUI* pCmdUI);
    afx_msg void OnUpdateStopService(CCmdUI* pCmdUI);
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnCmdPauseNode();
    afx_msg void OnCmdResumeNode();
    afx_msg void OnCmdEvictNode();
    afx_msg void OnCmdStartService();
    afx_msg void OnCmdStopService();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
#ifdef _CLUADMIN_USE_OLE_
    DECLARE_OLECREATE(CClusterNode)

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CClusterNode)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
#endif // _CLUADMIN_USE_OLE_

};  //*** class CClusterNode

/////////////////////////////////////////////////////////////////////////////
// CNodeList
/////////////////////////////////////////////////////////////////////////////

class CNodeList : public CClusterItemList
{
public:
    CClusterNode *      PciNodeFromName(
                            IN LPCTSTR      pszName,
                            OUT POSITION *  ppos = NULL
                            )
    {
        return (CClusterNode *) PciFromName(pszName, ppos);
    }

};  //*** class CNodeList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CNodeList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagNode;
extern CTraceTag g_tagNodeNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\nodeprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		NodeProp.cpp
//
//	Abstract:
//		Implementation of the node property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NodeProp.h"
#include "Node.h"
#include "HelpData.h"	// for g_rghelpmapNodeGeneral

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNodePropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CNodePropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNodePropSheet, CBasePropertySheet)
	//{{AFX_MSG_MAP(CNodePropSheet)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::CNodePropSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pci			[IN OUT] Cluster item whose properties are to be displayed.
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodePropSheet::CNodePropSheet(
	IN OUT CWnd *			pParentWnd,
	IN UINT					iSelectPage
	)
	: CBasePropertySheet(pParentWnd, iSelectPage)
{
	m_rgpages[0] = &PageGeneral();

}  //*** CNodePropSheet::CNodePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::BInit
//
//	Routine Description:
//		Initialize the property sheet.
//
//	Arguments:
//		pci			[IN OUT] Cluster item whose properties are to be displayed.
//		iimgIcon	[IN] Index in the large image list for the image to use
//					  as the icon on each page.
//
//	Return Value:
//		TRUE		Property sheet initialized successfully.
//		FALSE		Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNodePropSheet::BInit(
	IN OUT CClusterItem *	pci,
	IN IIMG					iimgIcon
	)
{
	// Call the base class method.
	if (!CBasePropertySheet::BInit(pci, iimgIcon))
		return FALSE;

	// Set the read-only flag.
	m_bReadOnly = PciNode()->BReadOnly()
					|| (PciNode()->Cns() == ClusterNodeStateUnknown);

	return TRUE;

}  //*** CNodePropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::~CNodePropSheet
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodePropSheet::~CNodePropSheet(void)
{
}  //*** CNodePropSheet::~CNodePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::Ppages
//
//	Routine Description:
//		Returns the array of pages to add to the property sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CNodePropSheet::Ppages(void)
{
	return m_rgpages;

}  //*** CNodePropSheet::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::Cpages
//
//	Routine Description:
//		Returns the count of pages in the array.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CNodePropSheet::Cpages(void)
{
	return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CNodePropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNodeGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNodeGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CNodeGeneralPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CNodeGeneralPage)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_NODE_DESC, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::CNodeGeneralPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodeGeneralPage::CNodeGeneralPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_NODE_GENERAL)
{
	//{{AFX_DATA_INIT(CNodeGeneralPage)
	m_strName = _T("");
	m_strDesc = _T("");
	m_strState = _T("");
	//}}AFX_DATA_INIT

}  //*** CNodeGeneralPage::CNodeGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNodeGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
	BOOL	bSuccess;

	ASSERT_KINDOF(CNodePropSheet, psht);

	bSuccess = CBasePropertyPage::BInit(psht);
	if (bSuccess)
	{
		try
		{
			m_strName = PciNode()->StrName();
			m_strDesc = PciNode()->StrDescription();
			m_strVersion.Format(
				IDS_VERSION_NUMBER_FORMAT,
				PciNode()->NMajorVersion(),
				PciNode()->NMinorVersion(),
				PciNode()->NBuildNumber(),
				0
				);
			m_strCSDVersion = PciNode()->StrCSDVersion();

			PciNode()->GetStateName(m_strState);
		}  // try
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
			bSuccess = FALSE;
		}  // catch:  CException
	}  // if:  base class method was successful

	return bSuccess;

}  //*** CNodeGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNodeGeneralPage::DoDataExchange(CDataExchange * pDX)
{
	CBasePropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNodeGeneralPage)
	DDX_Control(pDX, IDC_PP_NODE_DESC, m_editDesc);
	DDX_Control(pDX, IDC_PP_NODE_NAME, m_editName);
	DDX_Text(pDX, IDC_PP_NODE_NAME, m_strName);
	DDX_Text(pDX, IDC_PP_NODE_DESC, m_strDesc);
	DDX_Text(pDX, IDC_PP_NODE_CURRENT_STATE, m_strState);
	DDX_Text(pDX, IDC_PP_NODE_VERSION, m_strVersion);
	DDX_Text(pDX, IDC_PP_NODE_CSD_VERSION, m_strCSDVersion);
	//}}AFX_DATA_MAP

}  //*** CNodeGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNodeGeneralPage::OnInitDialog(void)
{
	CBasePropertyPage::OnInitDialog();

	m_editName.SetReadOnly(TRUE);

	// If read-only, set all controls to be either disabled or read-only.
	if (BReadOnly())
	{
		m_editDesc.SetReadOnly(TRUE);
	}  // if:  sheet is read-only

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNodeGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::OnApply
//
//	Routine Description:
//		Handler for when the Apply button is pressed.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNodeGeneralPage::OnApply(void)
{
	// Set the data from the page in the cluster item.
	try
	{
		CWaitCursor	wc;

		PciNode()->SetDescription(m_strDesc);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		return FALSE;
	}  // catch:  CException

	return CBasePropertyPage::OnApply();

}  //*** CNodeGeneralPage::OnApply()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\notify.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Notify.h
//
//  Implementation File:
//      Notify.cpp
//
//  Description:
//      Definition of the CNotify class.
//
//  Maintained By:
//      David Potter (davidp)   May 22, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once
#ifndef _NOTIFY_H_
#define _NOTIFY_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNotifyKey;
class CClusterNotify;
class CClusterNotifyContext;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterItem;

/////////////////////////////////////////////////////////////////////////////
// ClusterNotifyKeyType
/////////////////////////////////////////////////////////////////////////////

enum ClusterNotifyKeyType
{
    cnktUnknown,
    cnktDoc,
    cnktClusterItem
};

/////////////////////////////////////////////////////////////////////////////
// CNotifyKey
/////////////////////////////////////////////////////////////////////////////

class CClusterNotifyKey
{
public:
    CClusterNotifyKey( CClusterDoc * pdocIn );
    CClusterNotifyKey( CClusterItem * pciIn, LPCTSTR pszNameIn );

    ClusterNotifyKeyType    m_cnkt;
    CString                 m_strName;
    union
    {
        CClusterDoc *       m_pdoc;
        CClusterItem *      m_pci;
    };

}; //*** class CNotifyKey

typedef CList< CClusterNotifyKey *, CClusterNotifyKey * > CClusterNotifyKeyList;

/////////////////////////////////////////////////////////////////////////////
// CClusterNotify
/////////////////////////////////////////////////////////////////////////////

class CClusterNotify
{
public:
    enum EMessageType
    {
          mtMIN = 0             // Below the minimum valid value.
        , mtNotify              // Normal notification message.
        , mtRefresh             // Request to refresh the connections.
        , mtMAX                 // Above the maximum valid value.
    };

    EMessageType            m_emt;
    union
    {
        DWORD_PTR           m_dwNotifyKey;
        CClusterNotifyKey * m_pcnk;
    };
    DWORD                   m_dwFilterType;
    CString                 m_strName;

    CClusterNotify(
          EMessageType  emtIn
        , DWORD_PTR     dwNotifyKeyIn
        , DWORD         dwFilterTypeIn
        , LPCWSTR       pszNameIn
        );

}; //*** class CClusterNotify

/////////////////////////////////////////////////////////////////////////////
// CClusterNotifyList
/////////////////////////////////////////////////////////////////////////////

class CClusterNotifyList
{
private:

    // The actual list containing the data.
    CList< CClusterNotify *, CClusterNotify * > m_list;

    // Synchronization object to make sure only one caller is making changes to the list.
    CRITICAL_SECTION    m_cs;

public:
    CClusterNotifyList( void );
    ~CClusterNotifyList( void );
    POSITION Add( CClusterNotify ** ppcnNotifyInout );
    CClusterNotify * Remove( void );
    void RemoveAll( void );

    INT_PTR GetCount( void ) const { return m_list.GetCount(); }
    BOOL IsEmpty( void ) const { return m_list.IsEmpty(); }

}; //*** class CClusterNotifyList


/////////////////////////////////////////////////////////////////////////////
// CClusterNotifyContext
/////////////////////////////////////////////////////////////////////////////

class CClusterNotifyContext : public CObject
{
    DECLARE_DYNAMIC( CClusterNotifyContext )

public:
    HCHANGE                 m_hchangeNotifyPort;
    HWND                    m_hwndFrame;
    CClusterNotifyList *    m_pcnlList;

}; //*** class CClusterNotifyContext

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
LPCTSTR PszNotificationName( DWORD dwNotificationIn );
#endif // _DEBUG

void DeleteAllItemData( CClusterNotifyKeyList & rcnklInout );

/////////////////////////////////////////////////////////////////////////////

#endif // _NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\nodeprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		NodeProp.cpp
//
//	Abstract:
//		Definition of the node property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NODEPROP_H_
#define _NODEPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNodeGeneralPage;
class CNodePropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNode;

/////////////////////////////////////////////////////////////////////////////
// CNodeGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNodeGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CNodeGeneralPage)

// Construction
public:
	CNodeGeneralPage(void);

	virtual	BOOL		BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CNodeGeneralPage)
	enum { IDD = IDD_PP_NODE_GENERAL };
	CEdit	m_editDesc;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strState;
	CString	m_strVersion;
	CString	m_strCSDVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNodeGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CNodePropSheet *	PshtNode(void)	{ return (CNodePropSheet *) Psht(); }
	CClusterNode *		PciNode(void)	{ return (CClusterNode *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CNodeGeneralPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNodeGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CNodePropSheet
/////////////////////////////////////////////////////////////////////////////

class CNodePropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CNodePropSheet)

// Construction
public:
	CNodePropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[1];

	// Pages
	CNodeGeneralPage				m_pageGeneral;

	CNodeGeneralPage &				PageGeneral(void)		{ return m_pageGeneral; }

public:
	CClusterNode *					PciNode(void) const		{ return (CClusterNode *) Pci(); }

// Operations

// Overrides
protected:
	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNodePropSheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNodePropSheet(void);

	// Generated message map functions
protected:
	//{{AFX_MSG(CNodePropSheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNodePropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _NODEPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\notify.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Notify.cpp
//
//  Description:
//      Implementation of the notification classes.
//
//  Maintained By:
//      David Potter (davidp)   Septemper 26, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Notify.h"
#include "ClusDoc.h"
#include "ClusItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterNotifyKey
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyKey::CClusterNotifyKey
//
//  Routine Description:
//      Cluster notification key constructor for documents.
//
//  Arguments:
//      pdocIn      Pointer to the document.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyKey::CClusterNotifyKey(
    IN CClusterDoc *    pdocIn
    )
{
    ASSERT_VALID( pdocIn );

    m_cnkt = cnktDoc;
    m_pdoc = pdocIn;

} //*** CClusterNotifyKey::CClusterNotifyKey(CClusterDoc*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyKey::CClusterNotifyKey
//
//  Routine Description:
//      Cluster notification key constructor.
//
//  Arguments:
//      pciIn       Pointer to the cluster item.
//      pszNameIn  Name of the object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyKey::CClusterNotifyKey(
    IN CClusterItem *   pciIn,
    IN LPCTSTR          pszNameIn
    )
{
    ASSERT_VALID( pciIn );
    ASSERT( pszNameIn != NULL );
    ASSERT( *pszNameIn != _T('\0') );

    m_cnkt = cnktClusterItem;
    m_pci = pciIn;

    try
    {
        m_strName = pszNameIn;
    }
    catch ( ... )
    {
    } // catch: anything

} //*** CClusterNotifyKey::CClusterNotifyKey(CClusterItem*)


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterNotify
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotify::CClusterNotify
//
//  Routine Description:
//      Constructor for cluster notification objects used to transfer
//      a notification from the notification thread to the main UI thread.
//
//  Arguments:
//      pdoc        Pointer to the document.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotify::CClusterNotify(
      EMessageType  emtIn
    , DWORD_PTR     dwNotifyKeyIn
    , DWORD         dwFilterTypeIn
    , LPCWSTR       pszNameIn
    )
    : m_emt( emtIn )
    , m_dwNotifyKey( dwNotifyKeyIn )
    , m_dwFilterType( dwFilterTypeIn )
    , m_strName( pszNameIn )
{
    ASSERT( ( mtMIN < emtIn ) && ( emtIn < mtMAX ) );
    ASSERT( pszNameIn != NULL );

} //*** CClusterNotify::CClusterNotify


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterNotifyList
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyList::CClusterNotifyList
//
//  Routine Description:
//      Constructor for the cluster notification list object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyList::CClusterNotifyList( void )
{
    InitializeCriticalSection( &m_cs );

} //*** CClusterNotifyList::CClusterNotifyList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyList::~CClusterNotifyList
//
//  Routine Description:
//      Destructor for the cluster notification list object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyList::~CClusterNotifyList( void )
{
    DeleteCriticalSection( &m_cs );
    
} //*** CClusterNotifyList::~CClusterNotifyList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyList::Add
//
//  Routine Description:
//      Add a notification to the list.  This method will make sure that
//      only one caller is making changes to the list at a time.
//
//  Arguments:
//      ppcnNotifyInout
//          Notify object to add.  Pointer is set to NULL if the item was
//          successfully added.
//
//  Return Value:
//      Position of the added item in the list.
//
//--
/////////////////////////////////////////////////////////////////////////////
POSITION
CClusterNotifyList::Add( CClusterNotify ** ppcnNotifyInout )
{
    POSITION pos = NULL;

    ASSERT( ppcnNotifyInout );

    //
    // Take out the list lock to make sure that we are the only ones
    // making changes to the list.
    //
    EnterCriticalSection( &m_cs );

    //
    // Add the item to the end of the list.
    // If successful, clear the caller's pointer.
    //
    pos = m_list.AddTail( *ppcnNotifyInout );
    if ( pos != NULL )
    {
        *ppcnNotifyInout = NULL;
    }

    //
    // Leave the critical section now that we are done making changes to it.
    //
    LeaveCriticalSection( &m_cs );

    return pos;

} //*** CClusterNotifyList::Add

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyList::Remove
//
//  Routine Description:
//      Remove the first notification from the list.  This method will make
//      sure that only one caller is making changes to the list at a time.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NULL        The list was empty.
//      pcnNotify   The notification that was removed from the list.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotify *
CClusterNotifyList::Remove( void )
{
    CClusterNotify *    pcnNotify = NULL;

    //
    // Take out the list lock to make sure that we are the only ones
    // making changes to the list.
    //
    EnterCriticalSection( &m_cs );

    //
    // Remove an item from the head of the list.
    //
    if ( m_list.IsEmpty() == FALSE )
    {
        pcnNotify = m_list.RemoveHead();
        ASSERT( pcnNotify != NULL );
    } // if: list is NOT empty

    //
    // Leave the critical section now that we are done making changes to it.
    //
    LeaveCriticalSection( &m_cs );

    //
    // Return the notification we removed to the caller.
    //
    return pcnNotify;

} //*** CClusterNotifyList::Remove

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNotifyList::RemoveAll
//
//  Routine Description:
//      Removes all elements from the list and deallocates the memory
//      used by each element.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CClusterNotifyList::RemoveAll( void )
{
    POSITION            pos;
    CClusterNotify *    pcn;

    //
    // Take out the list lock to make sure that we are the only ones
    // making changes to the list.
    //
    EnterCriticalSection( &m_cs );

    //
    // Delete all the items in the Contained list.
    //
    pos = m_list.GetHeadPosition();
    while ( pos != NULL )
    {
        pcn = m_list.GetNext( pos );
        ASSERT( pcn != NULL );
        delete pcn;
    } // while: more items in the list

    //
    // Remove all the elements in the list.
    //
    m_list.RemoveAll();

    //
    // Leave the critical section now that we are done making changes to it.
    //
    LeaveCriticalSection( &m_cs );

} //*** CClusterNotifyList::RemoveAll


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  PszNotificationName
//
//  Routine Description:
//      Get the name of a notification.
//
//  Arguments:
//      dwNotificationIn    Notification whose name is to be returned.
//
//  Return Value:
//      Name of the notificaiton.
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR PszNotificationName( DWORD dwNotificationIn )
{
    LPCTSTR pszName = NULL;

    switch ( dwNotificationIn )
    {
        case CLUSTER_CHANGE_NODE_STATE:
            pszName = _T("NODE_STATE");
            break;
        case CLUSTER_CHANGE_NODE_DELETED:
            pszName = _T("NODE_DELETED");
            break;
        case CLUSTER_CHANGE_NODE_ADDED:
            pszName = _T("NODE_ADDED");
            break;
        case CLUSTER_CHANGE_NODE_PROPERTY:
            pszName = _T("NODE_PROPERTY");
            break;

        case CLUSTER_CHANGE_REGISTRY_NAME:
            pszName = _T("REGISTRY_NAME");
            break;
        case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
            pszName = _T("REGISTRY_ATTRIBUTES");
            break;
        case CLUSTER_CHANGE_REGISTRY_VALUE:
            pszName = _T("REGISTRY_VALUE");
            break;
        case CLUSTER_CHANGE_REGISTRY_SUBTREE:
            pszName = _T("REGISTRY_SUBTREE");
            break;

        case CLUSTER_CHANGE_RESOURCE_STATE:
            pszName = _T("RESOURCE_STATE");
            break;
        case CLUSTER_CHANGE_RESOURCE_DELETED:
            pszName = _T("RESOURCE_DELETED");
            break;
        case CLUSTER_CHANGE_RESOURCE_ADDED:
            pszName = _T("RESOURCE_ADDED");
            break;
        case CLUSTER_CHANGE_RESOURCE_PROPERTY:
            pszName = _T("RESOURCE_PROPERTY");
            break;

        case CLUSTER_CHANGE_GROUP_STATE:
            pszName = _T("GROUP_STATE");
            break;
        case CLUSTER_CHANGE_GROUP_DELETED:
            pszName = _T("GROUP_DELETED");
            break;
        case CLUSTER_CHANGE_GROUP_ADDED:
            pszName = _T("GROUP_ADDED");
            break;
        case CLUSTER_CHANGE_GROUP_PROPERTY:
            pszName = _T("GROUP_PROPERTY");
            break;

        case CLUSTER_CHANGE_RESOURCE_TYPE_DELETED:
            pszName = _T("RESOURCE_TYPE_DELETED");
            break;
        case CLUSTER_CHANGE_RESOURCE_TYPE_ADDED:
            pszName = _T("RESOURCE_TYPE_ADDED");
            break;
        case CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY:
            pszName = _T("RESOURCE_TYPE_PROPERTY");
            break;

        case CLUSTER_CHANGE_NETWORK_STATE:
            pszName = _T("NETWORK_STATE");
            break;
        case CLUSTER_CHANGE_NETWORK_DELETED:
            pszName = _T("NETWORK_DELETED");
            break;
        case CLUSTER_CHANGE_NETWORK_ADDED:
            pszName = _T("NETWORK_ADDED");
            break;
        case CLUSTER_CHANGE_NETWORK_PROPERTY:
            pszName = _T("NETWORK_PROPERTY");
            break;

        case CLUSTER_CHANGE_NETINTERFACE_STATE:
            pszName = _T("NETINTERFACE_STATE");
            break;
        case CLUSTER_CHANGE_NETINTERFACE_DELETED:
            pszName = _T("NETINTERFACE_DELETED");
            break;
        case CLUSTER_CHANGE_NETINTERFACE_ADDED:
            pszName = _T("NETINTERFACE_ADDED");
            break;
        case CLUSTER_CHANGE_NETINTERFACE_PROPERTY:
            pszName = _T("NETINTERFACE_PROPERTY");
            break;

        case CLUSTER_CHANGE_QUORUM_STATE:
            pszName = _T("QUORUM_STATE");
            break;
        case CLUSTER_CHANGE_CLUSTER_STATE:
            pszName = _T("CLUSTER_STATE");
            break;
        case CLUSTER_CHANGE_CLUSTER_PROPERTY:
            pszName = _T("CLUSTER_PROPERTY");
            break;

        default:
            pszName = _T("<UNKNOWN>");
            break;
    } // switch: dwNotification

    return pszName;

} //*** PszNotificationName
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rcnlInout   List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData( CClusterNotifyKeyList & rcnklInout )
{
    POSITION            pos;
    CClusterNotifyKey * pcnk;

    // Delete all the items in the Contained list.
    pos = rcnklInout.GetHeadPosition();
    while ( pos != NULL )
    {
        pcnk = rcnklInout.GetNext( pos );
        ASSERT( pcnk != NULL );
        delete pcnk;
    } // while: more items in the list

} //*** DeleteAllItemData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\olcpair.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		OLCPair.h
//
//	Abstract:
//		Definition of the CListCtrlPair dialog.
//
//	Implementation File:
//		OLCPair.cpp
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _OLCPAIR_H_
#define _OLCPAIR_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPAIR_H_
#include "LCPair.h"		// for CListCtrlPair
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class COrderedListCtrlPair;

/////////////////////////////////////////////////////////////////////////////
// COrderedListCtrlPair command target
/////////////////////////////////////////////////////////////////////////////

class COrderedListCtrlPair : public CListCtrlPair
{
	DECLARE_DYNCREATE(COrderedListCtrlPair)

// Construction
public:
	COrderedListCtrlPair(void);			// protected constructor used by dynamic creation
	COrderedListCtrlPair(
		IN OUT CDialog *			pdlg,
		IN OUT CClusterItemList *	plpobjRight,
		IN const CClusterItemList *	plpobjLeft,
		IN DWORD					dwStyle,
		IN PFNLCPGETCOLUMN			pfnGetColumn,
		IN PFNLCPDISPPROPS			pfnDisplayProps
		);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COrderedListCtrlPair)
	//}}AFX_VIRTUAL
	virtual BOOL	OnSetActive(void);
	virtual void	DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	CButton			m_pbMoveUp;
	CButton			m_pbMoveDown;

	void			SetUpDownState(void);

	// Generated message map functions
	//{{AFX_MSG(COrderedListCtrlPair)
	//}}AFX_MSG
public:
	virtual BOOL OnInitDialog();
protected:
	afx_msg void OnClickedMoveUp();
	afx_msg void OnClickedMoveDown();
	afx_msg void OnItemChangedRightList(NMHDR* pNMHDR, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()

};  //*** class COrderedListCtrlPair

/////////////////////////////////////////////////////////////////////////////

#endif // _OLCPAIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      PropLstS.cpp
//
//  Abstract:
//      Stub for implementation of property list classes.
//
//  Author:
//      David Potter (davidp)   February 24, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <PropListSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\openclus.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      OpenClus.cpp
//
//  Abstract:
//      Implementation of the COpenClusterDialog class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "OpenClus.h"
#include "ClusMru.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include <lmcons.h>
#include <lmserver.h>
#include <lmapibuf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COpenClusterDialog dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(COpenClusterDialog, CBaseDialog)
    //{{AFX_MSG_MAP(COpenClusterDialog)
    ON_BN_CLICKED(IDC_OCD_BROWSE, OnBrowse)
    ON_CBN_SELCHANGE(IDC_OCD_ACTION, OnSelChangeAction)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::COpenClusterDialog
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd          [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
COpenClusterDialog::COpenClusterDialog(CWnd * pParentWnd /*=NULL*/)
    : CBaseDialog(IDD, g_aHelpIDs_IDD_OPEN_CLUSTER, pParentWnd)
{
    CClusterAdminApp *      papp    = GetClusterAdminApp();
    CRecentClusterList *    prcl    = papp->PrclRecentClusterList();

    //{{AFX_DATA_INIT(COpenClusterDialog)
    m_strName = _T("");
    //}}AFX_DATA_INIT

    m_nAction = -1;

    // If there are no items in the MRU list, set the default action
    // to Create New Cluster.  Otherwise, set the default action to
    // Open Connection.
    if ( prcl->GetSize() == 0 )
    {
        m_nAction = OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER;
    } // if: nothing in the MRU list
    else
    {
        m_nAction = OPEN_CLUSTER_DLG_OPEN_CONNECTION;
    } // else: something in the MRU list

}  //*** COpenClusterDialog::COpenClusterDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COpenClusterDialog::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(COpenClusterDialog)
    DDX_Control(pDX, IDC_OCD_NAME_LABEL, m_staticName);
    DDX_Control(pDX, IDC_OCD_BROWSE, m_pbBrowse);
    DDX_Control(pDX, IDC_OCD_ACTION, m_cboxAction);
    DDX_Control(pDX, IDOK, m_pbOK);
    DDX_Control(pDX, IDC_OCD_NAME, m_cboxName);
    DDX_Text(pDX, IDC_OCD_NAME, m_strName);
    //}}AFX_DATA_MAP

    if ( pDX->m_bSaveAndValidate )
    {
        m_nAction = m_cboxAction.GetCurSel();
        if ( m_nAction != OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER )
        {
            DDV_RequiredText(pDX, IDC_OCD_NAME, IDC_OCD_NAME_LABEL, m_strName);
            DDV_MaxChars(pDX, m_strName, MAX_PATH - 1);
        } // if: not creating a new cluster
    } // if: saving data
    else
    {
        m_cboxAction.SetCurSel( m_nAction );
        OnSelChangeAction();
    } // else: setting data

}  //*** COpenClusterDialog::DoDataExchange

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL COpenClusterDialog::OnInitDialog(void)
{
    CClusterAdminApp *      papp    = GetClusterAdminApp();
    CRecentClusterList *    prcl    = papp->PrclRecentClusterList();
    int                     iMRU;
    CString                 strName;
    CWaitCursor             wc;

    // Call the base class method to get our control mappings.
    CBaseDialog::OnInitDialog();

    // Add the items to the Action combobox.
    strName.LoadString( IDS_OCD_CREATE_CLUSTER );
    m_cboxAction.AddString( strName );
    strName.LoadString( IDS_OCD_ADD_NODES );
    m_cboxAction.AddString( strName );
    strName.LoadString( IDS_OCD_OPEN_CONNECTION );
    m_cboxAction.AddString( strName );

    // Set the proper selection in the Action combobox.
    m_cboxAction.SetCurSel( m_nAction );
    OnSelChangeAction();

    // Set limits on the combobox edit control.
    m_cboxName.LimitText(MAX_PATH - 1);

    // Loop through the MRU items and add each one to the list in order.
    for (iMRU = 0 ; iMRU < prcl->GetSize() ; iMRU++)
    {
        if (!prcl->GetDisplayName(strName, iMRU, NULL, 0))
            break;
        try
        {
            m_cboxName.InsertString(iMRU, strName);
            if ((iMRU == 0) && (m_strName.GetLength() == 0))
                m_strName = strName;
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // for:  each MRU item

    // Select an item in the list.
    if (m_strName.GetLength() > 0)
    {
        int     istr;

        istr = m_cboxName.FindStringExact(-1, m_strName);
        if (istr == CB_ERR)
            m_cboxName.SetWindowText(m_strName);
        else
            m_cboxName.SetCurSel(istr);
    }  // if:  name already specified
    else if (prcl->GetDisplayName(strName, 0, NULL, 0))
        m_cboxName.SelectString(-1, strName);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE

}  //*** COpenClusterDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::OnBrowse
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Browse button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COpenClusterDialog::OnBrowse(void)
{
    ID              id;
    int             istr;
    CBrowseClusters dlg(this);

    id = (ID)dlg.DoModal();
    if (id == IDOK)
    {
        istr = m_cboxName.FindStringExact(-1, dlg.m_strCluster);
        if (istr == CB_ERR)
            m_cboxName.SetWindowText(dlg.m_strCluster);
        else
            m_cboxName.SetCurSel(istr);
    }  // if:  user selected a cluster name

}  //*** COpenClusterDialog::OnBrowse()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::OnSelChangeAction
//
//  Routine Description:
//      Handler for the CBN_SELCHANGE message on the Action combobox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COpenClusterDialog::OnSelChangeAction( void )
{
    if ( m_cboxAction.GetCurSel() == OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER )
    {
        m_staticName.EnableWindow( FALSE );
        m_cboxName.EnableWindow( FALSE );
        m_pbBrowse.EnableWindow( FALSE );
    } // if: create cluster option selected
    else
    {
        m_staticName.EnableWindow( TRUE );
        m_cboxName.EnableWindow( TRUE );
        m_pbBrowse.EnableWindow( TRUE );
    } // else: create cluster option NOT selected

} //*** COpenClusterDialog::OnSelChangeAction()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBrowseClusters dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBrowseClusters, CBaseDialog)
    //{{AFX_MSG_MAP(CBrowseClusters)
    ON_EN_CHANGE(IDC_BC_CLUSTER, OnChangeCluster)
    ON_LBN_SELCHANGE(IDC_BC_LIST, OnSelChangeList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::CBrowseClusters
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd          [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBrowseClusters::CBrowseClusters(CWnd * pParent /*=NULL*/)
    : CBaseDialog(IDD, g_aHelpIDs_IDD_BROWSE_CLUSTERS, pParent)
{
    //{{AFX_DATA_INIT(CBrowseClusters)
    m_strCluster = _T("");
    //}}AFX_DATA_INIT

}  //*** CBrowseClusters::CBrowseClusters()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBrowseClusters::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBrowseClusters)
    DDX_Control(pDX, IDOK, m_pbOK);
    DDX_Control(pDX, IDC_BC_LIST, m_lbList);
    DDX_Control(pDX, IDC_BC_CLUSTER, m_editCluster);
    DDX_Text(pDX, IDC_BC_CLUSTER, m_strCluster);
    //}}AFX_DATA_MAP

}  //*** CBrowseClusters::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBrowseClusters::OnInitDialog(void)
{
    CWaitCursor wc;

    // Call the base class method.
    CBaseDialog::OnInitDialog();

    // Collect list of clusters from the network.
    {
        DWORD               dwStatus;
        DWORD               nEntriesRead;
        DWORD               nTotalEntries;
        DWORD               iEntry;
        SERVER_INFO_100 *   pServerInfo = NULL;
        SERVER_INFO_100 *   pCurServerInfo;

        dwStatus = NetServerEnum(
                        NULL,               // servername
                        100,                // level
                        (LPBYTE *) &pServerInfo,
                        1000000,            // prefmaxlen
                        &nEntriesRead,      // entriesread
                        &nTotalEntries,     // totalentries
                        SV_TYPE_CLUSTER_NT, // servertype
                        NULL,               // domain
                        NULL                // resume_handle
                        );
        if (dwStatus == ERROR_SUCCESS)
        {
            ASSERT(pServerInfo != NULL);
            pCurServerInfo = pServerInfo;
            for (iEntry = 0 ; iEntry < nTotalEntries ; iEntry++, pCurServerInfo++)
            {
                if (m_lbList.FindStringExact(-1, pCurServerInfo->sv100_name) == LB_ERR)
                {
                    try
                    {
                        m_lbList.AddString(pCurServerInfo->sv100_name);
                    }  // try
                    catch (CException * pe)
                    {
                        pe->Delete();
                    }  // catch:  CException
                }  // if:  cluster not in list yet
            }  // for:  each entry in the array
        }  // if:  successfully retrieved list of clusters
        NetApiBufferFree(pServerInfo);
    }  // Collect list of clusters from the network

    // Enable/disable controls.
    OnChangeCluster();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBrowseClusters::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::OnChangeCluster
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Cluster edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBrowseClusters::OnChangeCluster(void)
{
    BOOL    bEnable;

    bEnable = m_editCluster.GetWindowTextLength() != 0;
    m_pbOK.EnableWindow(bEnable);

}  //*** CBrowseClusters::OnChangeCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::OnSelChangeList
//
//  Routine Description:
//      Handler for the LBN_SELCHANGE message on the list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBrowseClusters::OnSelChangeList(void)
{
    int     istr;

    istr = m_lbList.GetCurSel();
    if (istr != LB_ERR)
    {
        CString strText;

        m_lbList.GetText(istr, strText);
        m_editCluster.SetWindowText(strText);
    }  // if:  there is a selection

}  //*** CBrowseClusters::OnSelChangeList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\openclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      OpenClus.h
//
//  Abstract:
//      Definition of the COpenClusterDialog class.
//
//  Author:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _OPENCLUS_H_
#define _OPENCLUS_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER     0
#define OPEN_CLUSTER_DLG_ADD_NODES              1
#define OPEN_CLUSTER_DLG_OPEN_CONNECTION        2

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class COpenClusterDialog;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"    // for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// COpenCluster class
/////////////////////////////////////////////////////////////////////////////

class COpenClusterDialog : public CBaseDialog
{
// Construction
public:
    COpenClusterDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(COpenClusterDialog)
	enum { IDD = IDD_OPEN_CLUSTER };
    CButton     m_pbOK;
	CButton	    m_pbBrowse;
    CComboBox   m_cboxAction;
    CComboBox   m_cboxName;
	CStatic	    m_staticName;
    CString     m_strName;
	//}}AFX_DATA
	int		m_nAction;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COpenClusterDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(COpenClusterDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnBrowse();
	afx_msg void OnSelChangeAction();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class COpenClusterDialog

/////////////////////////////////////////////////////////////////////////////
// CBrowseClusters dialog
/////////////////////////////////////////////////////////////////////////////

class CBrowseClusters : public CBaseDialog
{
// Construction
public:
    CBrowseClusters(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CBrowseClusters)
    enum { IDD = IDD_BROWSE_CLUSTERS };
    CButton m_pbOK;
    CListBox    m_lbList;
    CEdit   m_editCluster;
    CString m_strCluster;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CBrowseClusters)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CBrowseClusters)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeCluster();
    afx_msg void OnSelChangeList();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CBrowseClusters

/////////////////////////////////////////////////////////////////////////////

#endif // _OPENCLUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\olcpair.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		OLCPair.cpp
//
//	Abstract:
//		Implementation of the COrderedListCtrlPair class.
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "OLCPair.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COrderedListCtrlPair
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(COrderedListCtrlPair, CListCtrlPair)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(COrderedListCtrlPair, CListCtrlPair)
	//{{AFX_MSG_MAP(COrderedListCtrlPair)
	//}}AFX_MSG_MAP
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LCP_RIGHT_LIST, OnItemChangedRightList)
	ON_BN_CLICKED(IDC_LCP_MOVE_UP, OnClickedMoveUp)
	ON_BN_CLICKED(IDC_LCP_MOVE_DOWN, OnClickedMoveDown)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::COrderedListCtrlPair
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
COrderedListCtrlPair::COrderedListCtrlPair(void)
{
	ModifyStyle(0, LCPS_ORDERED);

}  //*** COrderedListCtrlPair::COrderedListCtrlPair()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::COrderedListCtrlPair
//
//	Routine Description:
//		Cconstructor.
//
//	Arguments:
//		pdlg			[IN OUT] Dialog to which controls belong.
//		plpobjRight		[IN OUT] List for the right list control.
//		plpobjLeft		[IN] List for the left list control.
//		dwStyle			[IN] Style:
//							LCPS_SHOW_IMAGES	Show images to left of items.
//							LCPS_ALLOW_EMPTY	Allow right list to be empty.
//							LCPS_ORDERED		Ordered right list.
//		pfnGetColumn	[IN] Function pointer for retrieving columns.
//		pfnDisplayProps	[IN] Function pointer for displaying properties.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
COrderedListCtrlPair::COrderedListCtrlPair(
	IN OUT CDialog *			pdlg,
	IN OUT CClusterItemList *	plpobjRight,
	IN const CClusterItemList *	plpobjLeft,
	IN DWORD					dwStyle,
	IN PFNLCPGETCOLUMN			pfnGetColumn,
	IN PFNLCPDISPPROPS			pfnDisplayProps
	)
	: CListCtrlPair(
			pdlg,
			plpobjRight,
			plpobjLeft,
			dwStyle,
			pfnGetColumn,
			pfnDisplayProps
			)
{
}  //*** COrderedListCtrlPair::COrderedListCtrlPair()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::DoDataExchange(CDataExchange * pDX)
{
	CListCtrlPair::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LCP_MOVE_UP, m_pbMoveUp);
	DDX_Control(pDX, IDC_LCP_MOVE_DOWN, m_pbMoveDown);

}  //*** COrderedListCtrlPair::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL COrderedListCtrlPair::OnInitDialog(void)
{
	// Call the base class method.
	CListCtrlPair::OnInitDialog();

	// If this is an ordered list, show the Move buttons.
	// Otherwise, hide them.
	SetUpDownState();

	// If this is an ordered list, don't sort items in the right list.
	if (BOrdered())
		m_lcRight.ModifyStyle(LVS_SORTASCENDING, 0, 0);
	else
		m_lcRight.ModifyStyle(0, LVS_SORTASCENDING, 0);

	// Reload the list control.
	Pdlg()->UpdateData(FALSE /*bSaveAndValidate*/);

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** COrderedListCtrlPair::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL COrderedListCtrlPair::OnSetActive(void)
{
	UINT	nSelCount;

	nSelCount = m_lcRight.GetSelectedCount();
	if (BPropertiesButton())
		m_pbProperties.EnableWindow(nSelCount == 1);

	// Enable or disable the other buttons.
	if (!BReadOnly())
		SetUpDownState();

	return CListCtrlPair::OnSetActive();

}  //*** COrderedListCtrlPair::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnItemChangedRightList
//
//	Routine Description:
//		Handler method for the LVN_ITEMCHANGED message in the right list.
//
//	Arguments:
//		pNMHDR		[IN OUT] WM_NOTIFY structure.
//		pResult		[OUT] LRESULT in which to return the result of this operation.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::OnItemChangedRightList(NMHDR * pNMHDR, LRESULT * pResult)
{
	NM_LISTVIEW *	pNMListView = (NM_LISTVIEW *) pNMHDR;

	// Call the base class method.
	CListCtrlPair::OnItemChangedRightList(pNMHDR, pResult);

	if (BOrdered())
	{
		// If the selection changed, enable/disable the Remove button.
		if ((pNMListView->uChanged & LVIF_STATE)
				&& ((pNMListView->uOldState & LVIS_SELECTED)
						|| (pNMListView->uNewState & LVIS_SELECTED)))
		{
			SetUpDownState();
		}  // if:  selection changed
	}  // if:  list is ordered

	*pResult = 0;

}  //*** COrderedListCtrlPair::OnItemChangedRightList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnClickedMoveUp
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Move Up button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::OnClickedMoveUp(void)
{
	int				nItem;
	CClusterItem *	pci;

	// Find the index of the selected item.
	nItem = m_lcRight.GetNextItem(-1, LVNI_SELECTED);
	ASSERT(nItem != -1);

	// Get the item pointer.
	pci = (CClusterItem *) m_lcRight.GetItemData(nItem);
	ASSERT_VALID(pci);

	// Remove the selected item from the list and add it back in.
	{
		POSITION	posRemove;
		POSITION	posAdd;

		// Find the position of the item to be removed and the item before
		// which the item is to be inserted.
		posRemove = LpobjRight().FindIndex(nItem);
		ASSERT(posRemove != NULL);
		ASSERT(posRemove == LpobjRight().Find(pci));
		posAdd = LpobjRight().FindIndex(nItem - 1);
		ASSERT(posAdd != NULL);
		VERIFY(LpobjRight().InsertBefore(posAdd, pci) != NULL);
		LpobjRight().RemoveAt(posRemove);
	}  // Remove the selected item from the list and add it back in

	// Remove the selected item from the list control and add it back in.
	VERIFY(m_lcRight.DeleteItem(nItem));
	NInsertItemInListCtrl(nItem - 1, pci, m_lcRight);
	m_lcRight.SetItemState(
		nItem - 1,
		LVIS_SELECTED | LVIS_FOCUSED,
		LVIS_SELECTED | LVIS_FOCUSED
		);
	m_lcRight.EnsureVisible(nItem - 1, FALSE /*bPartialOK*/);
	m_lcRight.SetFocus();

}  //*** COrderedListCtrlPair::OnClickedMoveUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnClickedMoveDown
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Move Down button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::OnClickedMoveDown(void)
{
	int				nItem;
	CClusterItem *	pci;

	// Find the index of the selected item.
	nItem = m_lcRight.GetNextItem(-1, LVNI_SELECTED);
	ASSERT(nItem != -1);

	// Get the item pointer.
	pci = (CClusterItem *) m_lcRight.GetItemData(nItem);
	ASSERT_VALID(pci);

	// Remove the selected item from the list and add it back in.
	{
		POSITION	posRemove;
		POSITION	posAdd;

		// Find the position of the item to be removed and the item after
		// which the item is to be inserted.
		posRemove = LpobjRight().FindIndex(nItem);
		ASSERT(posRemove != NULL);
		ASSERT(posRemove == LpobjRight().Find(pci));
		posAdd = LpobjRight().FindIndex(nItem + 1);
		ASSERT(posAdd != NULL);
		VERIFY(LpobjRight().InsertAfter(posAdd, pci) != NULL);
		LpobjRight().RemoveAt(posRemove);
	}  // Remove the selected item from the list and add it back in

	// Remove the selected item from the list control and add it back in.
	VERIFY(m_lcRight.DeleteItem(nItem));
	NInsertItemInListCtrl(nItem + 1, pci, m_lcRight);
	m_lcRight.SetItemState(
		nItem + 1,
		LVIS_SELECTED | LVIS_FOCUSED,
		LVIS_SELECTED | LVIS_FOCUSED
		);
	m_lcRight.EnsureVisible(nItem + 1, FALSE /*bPartialOK*/);
	m_lcRight.SetFocus();

}  //*** COrderedListCtrlPair::OnClickedMoveDown()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::SetUpDownState
//
//	Routine Description:
//		Set the state of the Up/Down buttons based on the selection.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::SetUpDownState(void)
{
	BOOL	bEnableUp;
	BOOL	bEnableDown;

	if (   BOrdered()
		&& !BReadOnly()
		&& (m_lcRight.GetSelectedCount() == 1))
	{
		int		nItem;

		bEnableUp = TRUE;
		bEnableDown = TRUE;

		// Find the index of the selected item.
		nItem = m_lcRight.GetNextItem(-1, LVNI_SELECTED);
		ASSERT(nItem != -1);

		// If the first item is selected, can't move up.
		if (nItem == 0)
			bEnableUp = FALSE;

		// If the last item is selected, can't move down.
		if (nItem == m_lcRight.GetItemCount() - 1)
			bEnableDown = FALSE;
	}  // if:  only one item selected
	else
	{
		bEnableUp = FALSE;
		bEnableDown = FALSE;
	}  // else:  zero or more than one item selected

	m_pbMoveUp.EnableWindow(bEnableUp);
	m_pbMoveDown.EnableWindow(bEnableDown);

}  //*** COrderedListCtrlPair::SetUpDownState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\res.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Res.h
//
//  Abstract:
//      Definition of the CResource class.
//
//  Implementation File:
//      Res.cpp
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RES_H_
#define _RES_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResource;
class CResourceList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroup;
class CResourceType;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNode;
class CNodeList;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _RESTYPE_H_
#include "ResType.h"    // for CResourceType
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CResource command target
/////////////////////////////////////////////////////////////////////////////

class CResource : public CClusterItem
{
    DECLARE_DYNCREATE(CResource)

// Construction
public:
    CResource(void);        // protected constructor used by dynamic creation
    CResource(IN BOOL bDocobj);
    void                    Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);
    void                    Create(
                                IN OUT CClusterDoc *    pdoc,
                                IN LPCTSTR              lpszName,
                                IN LPCTSTR              lpszType,
                                IN LPCTSTR              lpszGroup,
                                IN BOOL                 bSeparateMonitor
                                );

protected:
    void                    CommonConstruct(void);

// Attributes
protected:
    HRESOURCE               m_hresource;
    CLUSTER_RESOURCE_STATE  m_crs;
    CString                 m_strOwner;
    CClusterNode *          m_pciOwner;
    CString                 m_strGroup;
    CGroup *                m_pciGroup;

    BOOL                    m_bSeparateMonitor;
    DWORD                   m_nLooksAlive;
    DWORD                   m_nIsAlive;
    CRRA                    m_crraRestartAction;
    DWORD                   m_nRestartThreshold;
    DWORD                   m_nRestartPeriod;
    DWORD                   m_nPendingTimeout;

    CString                 m_strResourceType;
    CResourceType *         m_pciResourceType;
    PCLUSPROP_REQUIRED_DEPENDENCY   m_pcrd;
    CLUS_RESOURCE_CLASS_INFO        m_rciResClassInfo;
    DWORD                   m_dwCharacteristics;
    DWORD                   m_dwFlags;

    CResourceList *         m_plpciresDependencies;
    CNodeList *             m_plpcinodePossibleOwners;

    enum
    {
        epropName = 0,
        epropType,
        epropDescription,
        epropSeparateMonitor,
        epropLooksAlive,
        epropIsAlive,
        epropRestartAction,
        epropRestartThreshold,
        epropRestartPeriod,
        epropPendingTimeout,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

public:
    HRESOURCE               Hresource(void) const               { return m_hresource; }
    CLUSTER_RESOURCE_STATE  Crs(void) const                     { return m_crs; }
    const CString &         StrOwner(void) const                { return m_strOwner; }
    CClusterNode *          PciOwner(void) const                { return m_pciOwner; }
    const CString &         StrGroup(void) const                { return m_strGroup; }
    CGroup *                PciGroup(void) const                { return m_pciGroup; }

    const CString &         StrResourceType(void) const         { return m_strResourceType; }
    const CString &         StrRealResourceType(void) const
    {
        if (PciResourceType() == NULL)
            return StrResourceType();
        else
        {
            ASSERT_VALID(PciResourceType());
            return PciResourceType()->StrName();
        }
    }
    const CString &         StrRealResourceTypeDisplayName(void) const
    {
        if (PciResourceType() == NULL)
            return StrResourceType();
        else
        {
            ASSERT_VALID(PciResourceType());
            if (PciResourceType()->StrDisplayName().GetLength() == 0)
                return PciResourceType()->StrName();
            else
                return PciResourceType()->StrDisplayName();
        }
    }

    CResourceType *         PciResourceType(void) const         { return m_pciResourceType; }
    BOOL                    BSeparateMonitor(void) const        { return m_bSeparateMonitor; }
    DWORD                   NLooksAlive(void) const             { return m_nLooksAlive; }
    DWORD                   NIsAlive(void) const                { return m_nIsAlive; }
    CRRA                    CrraRestartAction(void) const       { return m_crraRestartAction; }
    DWORD                   NRestartThreshold(void) const       { return m_nRestartThreshold; }
    DWORD                   NRestartPeriod(void) const          { return m_nRestartPeriod; }
    DWORD                   NPendingTimeout(void) const         { return m_nPendingTimeout; }
    const PCLUSPROP_REQUIRED_DEPENDENCY Pcrd(void) const        { return m_pcrd; }
    CLUSTER_RESOURCE_CLASS  ResClass(void) const                { return m_rciResClassInfo.rc; }
    PCLUS_RESOURCE_CLASS_INFO   PrciResClassInfo(void)          { return &m_rciResClassInfo; }
    DWORD                   DwCharacteristics(void) const       { return m_dwCharacteristics; }
    DWORD                   DwFlags(void) const                 { return m_dwFlags; }
    BOOL                    BQuorumCapable( void ) const        { return (m_dwCharacteristics & CLUS_CHAR_QUORUM) != 0; }
    BOOL                    BLocalQuorum( void ) const          { return (m_dwCharacteristics & CLUS_CHAR_LOCAL_QUORUM) != 0; }
    BOOL                    BLocalQuorumDebug( void ) const     { return (m_dwCharacteristics & CLUS_CHAR_LOCAL_QUORUM_DEBUG) != 0; }
    BOOL                    BDeleteRequiresAllNodes( void ) const { return (m_dwCharacteristics & CLUS_CHAR_DELETE_REQUIRES_ALL_NODES) != 0; }
    BOOL                    BCore( void ) const                 { return (m_dwFlags & CLUS_FLAG_CORE) != 0; }

    const CResourceList &   LpciresDependencies(void) const     { ASSERT(m_plpciresDependencies != NULL); return *m_plpciresDependencies; }
    const CNodeList &       LpcinodePossibleOwners(void) const  { ASSERT(m_plpcinodePossibleOwners != NULL); return *m_plpcinodePossibleOwners; }

    void                    GetStateName(OUT CString & rstrState) const;

    BOOL                    BCanBeDependent(IN CResource * pciRes);
    BOOL                    BIsDependent(IN CResource * pciRes);
    BOOL                    BGetNetworkName(OUT WCHAR * lpszNetName, IN OUT DWORD * pcchNetName);
    BOOL                    BGetNetworkName(OUT CString & rstrNetName);

// Operations
public:
    void                    SetOwnerState(IN LPCTSTR pszNewOwner);
    void                    SetGroupState(IN LPCTSTR pszNewGroup);

    void                    CollectPossibleOwners(IN OUT CNodeList * plpci) const;
//  void                    RemoveNodeFromPossibleOwners(IN OUT CNodeList * plpci, IN const CClusterNode * pNode);
    void                    CollectDependencies(IN OUT CResourceList * plpci, IN BOOL bFullTree = FALSE) const;
    void                    CollectProvidesFor(IN OUT CResourceList * plpci, IN BOOL bFullTree = FALSE) const;
    void                    CollectDependencyTree(IN OUT CResourceList * plpci) const;

    void                    DeleteResource(void);
    void                    Move(IN const CGroup * pciGroup);
    void                    ReadExtensions(void);

    void                    SetName(IN LPCTSTR pszName);
    void                    SetGroup(IN LPCTSTR pszGroup);
    void                    SetDependencies(IN const CResourceList & rlpci);
    void                    SetPossibleOwners(IN const CNodeList & rlpci);
    void                    SetCommonProperties(
                                IN const CString &  rstrDesc,
                                IN BOOL             bSeparate,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive,
                                IN CRRA             crra,
                                IN DWORD            nThreshold,
                                IN DWORD            nPeriod,
                                IN DWORD            nTimeout,
                                IN BOOL             bValidateOnly
                                );
    void                    SetCommonProperties(
                                IN const CString &  rstrDesc,
                                IN BOOL             bSeparate,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive,
                                IN CRRA             crra,
                                IN DWORD            nThreshold,
                                IN DWORD            nPeriod,
                                IN DWORD            nTimeout
                                )
    {
        SetCommonProperties(rstrDesc, bSeparate, nLooksAlive, nIsAlive,crra,
                            nThreshold, nPeriod, nTimeout, FALSE /*bValidateOnly*/ );
    }
    void                    ValidateCommonProperties(
                                IN const CString &  rstrDesc,
                                IN BOOL             bSeparate,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive,
                                IN CRRA             crra,
                                IN DWORD            nThreshold,
                                IN DWORD            nPeriod,
                                IN DWORD            nTimeout
                                )
    {
        SetCommonProperties(rstrDesc, bSeparate, nLooksAlive, nIsAlive,crra,
                            nThreshold, nPeriod, nTimeout, TRUE /*bValidateOnly*/ );
    }

    DWORD                   DwResourceControlGet(
                                IN DWORD        dwFunctionCode,
                                IN PBYTE        pbInBuf,
                                IN DWORD        cbInBuf,
                                OUT PBYTE *     ppbOutBuf
                                );
    DWORD                   DwResourceControlGet(
                                IN DWORD        dwFunctionCode,
                                OUT PBYTE *     ppbOutBuf
                                )                           { return DwResourceControlGet(dwFunctionCode, NULL, NULL, ppbOutBuf); }
    BOOL                    BRequiredDependenciesPresent(
                                IN const CResourceList &    rlpciRes,
                                OUT CString &               rstrMissing
                                );

// Overrides
public:
    virtual void            Cleanup(void);
    virtual void            ReadItem(void);
    virtual void            UpdateState(void);
    virtual void            Rename(IN LPCTSTR pszName);
    virtual BOOL            BGetColumnData(IN COLID colid, OUT CString & rstrText);
    virtual BOOL            BCanBeEdited(void) const;
    virtual BOOL            BDisplayProperties(IN BOOL bReadOnly = FALSE);

    // Drag & Drop
    virtual BOOL            BCanBeDragged(void) const   { return TRUE; }

    virtual const CStringList * PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
    virtual void            GetTreeName(OUT CString & rstrName) const;
#endif

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CResource)
    public:
    virtual void OnFinalRelease();
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
    //}}AFX_VIRTUAL

    virtual LRESULT         OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(m_rgProps[0]); }
    virtual DWORD                   DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
protected:
    CStringList             m_lstrCombinedExtensions;
    BOOL                    m_bInitializing;
    BOOL                    m_bDeleting;

    const CStringList &     LstrCombinedExtensions(void) const  { return m_lstrCombinedExtensions; }

public:
    virtual ~CResource(void);
    BOOL                    BInitializing(void) const               { return m_bInitializing; }
    BOOL                    BDeleting(void) const                   { return m_bDeleting; }
    void                    SetInitializing(IN BOOL bInit = TRUE)   { m_bInitializing = bInit; }

protected:
    void                    DeleteResource(IN const CResourceList & rlpci);
    void                    Move(IN const CGroup * pciGroup, IN const CResourceList & rlpci);
    BOOL                    BAllowedToTakeOffline(void);
    void                    WaitForOffline( void );

public:
    // Generated message map functions
    //{{AFX_MSG(CResource)
    afx_msg void OnUpdateBringOnline(CCmdUI* pCmdUI);
    afx_msg void OnUpdateTakeOffline(CCmdUI* pCmdUI);
    afx_msg void OnUpdateInitiateFailure(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMoveResource1(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMoveResourceRest(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDelete(CCmdUI* pCmdUI);
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnCmdBringOnline();
    afx_msg void OnCmdTakeOffline();
    afx_msg void OnCmdInitiateFailure();
    afx_msg void OnCmdDelete();
    //}}AFX_MSG
    afx_msg void OnCmdMoveResource(IN UINT nID);

    DECLARE_MESSAGE_MAP()
#ifdef _CLUADMIN_USE_OLE_
    DECLARE_OLECREATE(CResource)

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CResource)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
#endif // _CLUADMIN_USE_OLE_

}; //*** class CResource

/////////////////////////////////////////////////////////////////////////////
// CResourceList
/////////////////////////////////////////////////////////////////////////////

class CResourceList : public CClusterItemList
{
public:
    CResource *     PciResFromName(
                        IN LPCTSTR      pszName,
                        OUT POSITION *  ppos = NULL
                        )
    {
        return (CResource *) PciFromName(pszName, ppos);
    }

}; //*** class CResourceList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CResourceList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagResource;
extern CTraceTag g_tagResNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _RES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\res.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Res.cpp
//
//  Abstract:
//      Implementation of the CResource class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Res.h"
#include "ClusItem.inl"
#include "ResProp.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "Cluster.h"
#include "DelRes.h"
#include "MoveRes.h"
#include "WaitDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagResource(_T("Document"), _T("RESOURCE"), 0);
CTraceTag   g_tagResNotify(_T("Notify"), _T("RES NOTIFY"), 0);
CTraceTag   g_tagResRegNotify(_T("Notify"), _T("RES REG NOTIFY"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CResource
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResource, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResource, CClusterItem)
    //{{AFX_MSG_MAP(CResource)
    ON_UPDATE_COMMAND_UI(ID_FILE_BRING_ONLINE, OnUpdateBringOnline)
    ON_UPDATE_COMMAND_UI(ID_FILE_TAKE_OFFLINE, OnUpdateTakeOffline)
    ON_UPDATE_COMMAND_UI(ID_FILE_INITIATE_FAILURE, OnUpdateInitiateFailure)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_1, OnUpdateMoveResource1)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_2, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_3, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_4, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_5, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_6, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_7, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_8, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_9, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_10, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_11, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_12, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_13, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_14, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_15, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_16, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_17, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_18, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_19, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_20, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_DELETE, OnUpdateDelete)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_BRING_ONLINE, OnCmdBringOnline)
    ON_COMMAND(ID_FILE_TAKE_OFFLINE, OnCmdTakeOffline)
    ON_COMMAND(ID_FILE_INITIATE_FAILURE, OnCmdInitiateFailure)
    ON_COMMAND(ID_FILE_DELETE, OnCmdDelete)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CResource
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResource::CResource(void)
    : CClusterItem(NULL, IDS_ITEMTYPE_RESOURCE)
{
    CommonConstruct();

} //*** CResoruce::CResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CResource
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      bDocObj     [IN] TRUE = object is part of the document.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResource::CResource(IN BOOL bDocObj)
    : CClusterItem(NULL, IDS_ITEMTYPE_RESOURCE)
{
    CommonConstruct();
    m_bDocObj = bDocObj;

} //*** CResource::CResource(bDocObj)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CommonConstruct(void)
{
    m_idmPopupMenu = IDM_RESOURCE_POPUP;
    m_bInitializing = FALSE;
    m_bDeleting = FALSE;

    m_hresource = NULL;

    m_bSeparateMonitor = FALSE;
    m_nLooksAlive = CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE;
    m_nIsAlive = CLUSTER_RESOURCE_DEFAULT_IS_ALIVE;
    m_crraRestartAction = CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION;
    m_nRestartThreshold = CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD;
    m_nRestartPeriod = CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD;
    m_nPendingTimeout = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;

    m_rciResClassInfo.rc = CLUS_RESCLASS_UNKNOWN;
    m_rciResClassInfo.SubClass = 0;
    m_dwCharacteristics = CLUS_CHAR_UNKNOWN;
    m_dwFlags = 0;

    m_pciOwner = NULL;
    m_pciGroup = NULL;
    m_pciResourceType = NULL;
    m_pcrd = NULL;

    m_plpciresDependencies = NULL;
    m_plpcinodePossibleOwners = NULL;

    // Set the object type image.
    m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_RES);

    // Setup the property array.
    {
        m_rgProps[epropName].Set(CLUSREG_NAME_RES_NAME, m_strName, m_strName);
        m_rgProps[epropType].Set(CLUSREG_NAME_RES_TYPE, m_strResourceType, m_strResourceType);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_RES_DESC, m_strDescription, m_strDescription);
        m_rgProps[epropSeparateMonitor].Set(CLUSREG_NAME_RES_SEPARATE_MONITOR, m_bSeparateMonitor, m_bSeparateMonitor);
        m_rgProps[epropLooksAlive].Set(CLUSREG_NAME_RES_LOOKS_ALIVE, m_nLooksAlive, m_nLooksAlive);
        m_rgProps[epropIsAlive].Set(CLUSREG_NAME_RES_IS_ALIVE, m_nIsAlive, m_nIsAlive);
        m_rgProps[epropRestartAction].Set(CLUSREG_NAME_RES_RESTART_ACTION, (DWORD &) m_crraRestartAction, (DWORD &) m_crraRestartAction);
        m_rgProps[epropRestartThreshold].Set(CLUSREG_NAME_RES_RESTART_THRESHOLD, m_nRestartThreshold, m_nRestartThreshold);
        m_rgProps[epropRestartPeriod].Set(CLUSREG_NAME_RES_RESTART_PERIOD, m_nRestartPeriod, m_nRestartPeriod);
        m_rgProps[epropPendingTimeout].Set(CLUSREG_NAME_RES_PENDING_TIMEOUT, m_nPendingTimeout, m_nPendingTimeout);
    } // Setup the property array

#ifdef _CLUADMIN_USE_OLE_
    EnableAutomation();
#endif

    // To keep the application running as long as an OLE automation
    //  object is active, the constructor calls AfxOleLockApp.

//  AfxOleLockApp();

} //*** CResource::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::~CResource
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResource::~CResource(void)
{
    // Cleanup this object.
    Cleanup();

    delete m_plpciresDependencies;
    delete m_plpcinodePossibleOwners;
    delete [] (PBYTE) m_pcrd;

    // Close the resource handle.
    if (Hresource() != NULL)
    {
        CloseClusterResource(Hresource());
        m_hresource = NULL;
    } // if:  resource is open

    // To terminate the application when all objects created with
    //  with OLE automation, the destructor calls AfxOleUnlockApp.

//  AfxOleUnlockApp();

} //*** CResource::~CResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Cleanup(void)
{
    // Delete the Dependencies list.
    if (m_plpciresDependencies != NULL)
    {
        m_plpciresDependencies->RemoveAll();
    }

    // Delete the PossibleOwners list.
    if (m_plpcinodePossibleOwners != NULL)
    {
        m_plpcinodePossibleOwners->RemoveAll();
    }

    // If we are active on a node, remove ourselves from that active list.
    if (PciOwner() != NULL)
    {
        if (BDocObj())
        {
            PciOwner()->RemoveActiveResource(this);
        }
        PciOwner()->Release();
        m_pciOwner = NULL;
    } // if:  there is an owner

    // Remove ourselves from the group's list.
    if (PciGroup() != NULL)
    {
        if (BDocObj())
        {
            PciGroup()->RemoveResource(this);
        }
        PciGroup()->Release();
        m_pciGroup = NULL;
    } // if:  there is a group

    // Update the reference count to the resource type
    if (PciResourceType() != NULL)
    {
        PciResourceType()->Release();
        m_pciResourceType = NULL;
    } // if:  there is a resource type

    // Remove the item from the resource list.
    if (BDocObj())
    {
        POSITION    posPci;

        posPci = Pdoc()->LpciResources().Find(this);
        if (posPci != NULL)
        {
            Pdoc()->LpciResources().RemoveAt(posPci);
        } // if:  found in the document's list
    } // if:  this is a document object

} //*** CResource::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Create
//
//  Routine Description:
//      Create a resource.
//
//  Arguments:
//      pdoc                [IN OUT] Document to which this item belongs.
//      lpszName            [IN] Name of the resource.
//      lpszType            [IN] Type of the resource.
//      lpszGroup           [IN] Group in which to create the resource.
//      bSeparateMonitor    [IN] TRUE = run resource in separate monitor.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from CreateClusterResource.
//      Any exceptions thrown by CResource::Init(), CResourceList::new(),
//      or CNodeList::new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Create(
    IN OUT CClusterDoc *    pdoc,
    IN LPCTSTR              lpszName,
    IN LPCTSTR              lpszType,
    IN LPCTSTR              lpszGroup,
    IN BOOL                 bSeparateMonitor
    )
{
    DWORD       dwStatus;
    DWORD       dwFlags;
    HRESOURCE   hresource;
    CGroup *    pciGroup;
    CString     strName(lpszName);  // Required if built non-Unicode
    CString     strType(lpszType);  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(Hresource() == NULL);
    ASSERT(Hkey() == NULL);
    ASSERT_VALID(pdoc);
    ASSERT(lpszName != NULL);
    ASSERT(lpszType != NULL);
    ASSERT(lpszGroup != NULL);

    // Find the specified group.
    pciGroup = pdoc->LpciGroups().PciGroupFromName(lpszGroup);
    ASSERT_VALID(pciGroup);

    // Set the flags.
    if (bSeparateMonitor)
    {
        dwFlags = CLUSTER_RESOURCE_SEPARATE_MONITOR;
    }
    else
    {
        dwFlags = 0;
    }

    // Create the resource.
    hresource = CreateClusterResource(pciGroup->Hgroup(), strName, strType, dwFlags);
    if (hresource == NULL)
    {
        dwStatus = GetLastError();
        ThrowStaticException(dwStatus, IDS_CREATE_RESOURCE_ERROR, lpszName);
    } // if:  error creating the cluster resource

    CloseClusterResource(hresource);

    // Open the resource.
    Init(pdoc, lpszName);

} //*** CResource::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenClusterResource or GetClusterResourceKey.
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LONG        lResult;
    CString     strName(lpszName);  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(Hresource() == NULL);
    ASSERT(Hkey() == NULL);

    // Call the base class method.
    CClusterItem::Init(pdoc, lpszName);

    try
    {
        // Open the resource.
        m_hresource = OpenClusterResource(Hcluster(), strName);
        if (Hresource() == NULL)
        {
            dwStatus = GetLastError();
            ThrowStaticException(dwStatus, IDS_OPEN_RESOURCE_ERROR, lpszName);
        } // if:  error opening the cluster resource

        // Get the resource registry key.
        m_hkey = GetClusterResourceKey(Hresource(), MAXIMUM_ALLOWED);
        if (Hkey() == NULL)
        {
            ThrowStaticException(GetLastError(), IDS_GET_RESOURCE_KEY_ERROR, lpszName);
        }

        if (BDocObj())
        {
            ASSERT(Pcnk() != NULL);
            Trace(g_tagClusItemNotify, _T("CResource::Init() - Registering for resource notifications (%08.8x) for '%s'"), Pcnk(), StrName());

            // Register for resource notifications.
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (CLUSTER_CHANGE_RESOURCE_STATE
                                    | CLUSTER_CHANGE_RESOURCE_DELETED
                                    | CLUSTER_CHANGE_RESOURCE_PROPERTY),
                                Hresource(),
                                (DWORD_PTR) Pcnk()
                                );
            if (lResult != ERROR_SUCCESS)
            {
                dwStatus = lResult;
                ThrowStaticException(dwStatus, IDS_RES_NOTIF_REG_ERROR, lpszName);
            } // if:  error registering for resource notifications

            // Register for registry notifications.
            if (Hkey != NULL)
            {
                lResult = RegisterClusterNotify(
                                    GetClusterAdminApp()->HchangeNotifyPort(),
                                    (CLUSTER_CHANGE_REGISTRY_NAME
                                        | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                        | CLUSTER_CHANGE_REGISTRY_VALUE
                                        | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                    Hkey(),
                                    (DWORD_PTR) Pcnk()
                                    );
                if (lResult != ERROR_SUCCESS)
                {
                    dwStatus = lResult;
                    ThrowStaticException(dwStatus, IDS_RES_NOTIF_REG_ERROR, lpszName);
                } // if:  error registering for registry notifications
            } // if:  there is a key
        } // if:  document object

        // Allocate lists.
        m_plpciresDependencies = new CResourceList;
        if ( m_plpciresDependencies == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the dependency list

        m_plpcinodePossibleOwners = new CNodeList;
        if ( m_plpcinodePossibleOwners == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the possible owners list

        // Read the initial state.
        UpdateState();
    } // try
    catch (CException *)
    {
        if (Hkey() != NULL)
        {
            ClusterRegCloseKey(Hkey());
            m_hkey = NULL;
        } // if:  registry key opened
        if (Hresource() != NULL)
        {
            CloseClusterResource(Hresource());
            m_hresource = NULL;
        } // if:  resource opened
        m_bReadOnly = TRUE;
        throw;
    } // catch:  CException

} //*** CResource::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::ReadItem(void)
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT_VALID(this);

    m_bInitializing = FALSE;

    if (Hresource() != NULL)
    {
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
        m_rgProps[epropSeparateMonitor].m_value.pb = &m_bSeparateMonitor;
        m_rgProps[epropLooksAlive].m_value.pdw = &m_nLooksAlive;
        m_rgProps[epropIsAlive].m_value.pdw = &m_nIsAlive;
        m_rgProps[epropRestartAction].m_value.pdw = (DWORD *) &m_crraRestartAction;
        m_rgProps[epropRestartThreshold].m_value.pdw = &m_nRestartThreshold;
        m_rgProps[epropRestartPeriod].m_value.pdw = &m_nRestartPeriod;
        m_rgProps[epropPendingTimeout].m_value.pdw = &m_nPendingTimeout;

        // Call the base class method.
        Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Calling CClusterItem::ReadItem()"), Pdoc()->StrNode(), StrName(), this );
        CClusterItem::ReadItem();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Getting common properties"), Pdoc()->StrNode(), StrName(), this );
            dwStatus = cpl.ScGetResourceProperties(
                                Hresource(),
                                CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Parsing common properties"), Pdoc()->StrNode(), StrName(), this );
                dwStatus = DwParseProperties(cpl);
            } // if: properties read successfully
            if (dwStatus != ERROR_SUCCESS)
            {
                Trace( g_tagError, _T("(%s) (%s (%x)) - CResource::ReadItem() - Error 0x%08.8x getting or parsing common properties"), Pdoc()->StrNode(), StrName(), this, dwStatus );
                dwRetStatus = dwStatus;
            } // if: error reading or parsing properties
        } // Read and parse the common properties

        // Read and parse the read-only common properties.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            CClusPropList   cpl;

            Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Getting common RO properties"), Pdoc()->StrNode(), StrName(), this );
            dwStatus = cpl.ScGetResourceProperties(
                                Hresource(),
                                CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Parsing common RO properties"), Pdoc()->StrNode(), StrName(), this );
                dwStatus = DwParseProperties(cpl);
            } // if: properties read successfully
            if (dwStatus != ERROR_SUCCESS)
            {
                Trace( g_tagError, _T("(%s) (%s (%x)) - CResource::ReadItem() - Error 0x%08.8x getting or parsing common RO properties"), Pdoc()->StrNode(), StrName(), this, dwStatus );
                dwRetStatus = dwStatus;
            } // if: error reading or parsing properties
        } // if:  no error yet

        // Find the resource type object.
        {
            CResourceType * pciResType;

            pciResType = Pdoc()->LpciResourceTypes().PciResTypeFromName(StrResourceType());
            if (m_pciResourceType != NULL)
            {
                m_pciResourceType->Release();
            }
            m_pciResourceType = pciResType;
            if (m_pciResourceType != NULL)
            {
                m_pciResourceType->AddRef();
            }
        } // Find the resource type object

        // Read the required dependencies.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            PCLUSPROP_REQUIRED_DEPENDENCY pcrd;

            Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Getting required dependencies"), Pdoc()->StrNode(), StrName(), this );
            dwStatus = DwResourceControlGet(CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES, (PBYTE *) &pcrd);
            if (dwStatus != ERROR_SUCCESS)
            {
                Trace( g_tagError, _T("(%s) (%s (%x)) - CResource::ReadItem() - Error 0x%08.8x getting required dependencies"), Pdoc()->StrNode(), StrName(), this, dwStatus );
                dwRetStatus = dwStatus;
            } // if: error getting required dependencies
            delete [] (PBYTE) m_pcrd;
            m_pcrd = pcrd;
        } // if:  no error yet

        // Read the resource class.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceControl(
                            Hresource(),
                            NULL,
                            CLUSCTL_RESOURCE_GET_CLASS_INFO,
                            NULL,
                            NULL,
                            &m_rciResClassInfo,
                            sizeof(m_rciResClassInfo),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
            {
                dwRetStatus = dwStatus;
            }
            else
            {
                ASSERT(cbReturned == sizeof(m_rciResClassInfo));
            } // else:  data retrieved successfully
        } // if:  no error yet

        // Read the characteristics.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceControl(
                            Hresource(),
                            NULL,
                            CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                            NULL,
                            NULL,
                            &m_dwCharacteristics,
                            sizeof(m_dwCharacteristics),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
            {
                dwRetStatus = dwStatus;
            }
            else
            {
                ASSERT(cbReturned == sizeof(m_dwCharacteristics));
            } // else:  data retrieved successfully
        } // if:  no error yet

        // Read the flags.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceControl(
                            Hresource(),
                            NULL,
                            CLUSCTL_RESOURCE_GET_FLAGS,
                            NULL,
                            NULL,
                            &m_dwFlags,
                            sizeof(m_dwFlags),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
            {
                dwRetStatus = dwStatus;
            }
            else
            {
                ASSERT(cbReturned == sizeof(m_dwFlags));
            } // else:  data retrieved successfully
        } // if:  no error yet

        // Construct the list of extensions.
        ReadExtensions();

        if (dwRetStatus == ERROR_SUCCESS)
        {
            // Construct the lists.
            CollectPossibleOwners(NULL);
            CollectDependencies(NULL);
        } // if:  no error reading properties
    } // if:  resource is available

    // Read the initial state.
    UpdateState();

    // If any errors occurred, throw an exception.
    if (dwRetStatus != ERROR_SUCCESS)
    {
        m_bReadOnly = TRUE;
        if (   (dwRetStatus != ERROR_RESOURCE_NOT_AVAILABLE)
            && (dwRetStatus != ERROR_KEY_DELETED))
        {
            ThrowStaticException(dwRetStatus, IDS_READ_RESOURCE_PROPS_ERROR, StrName());
        }
    } // if:  error reading properties

    MarkAsChanged(FALSE);

} //*** CResource::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::DwResourceControlGet
//
//  Routine Description:
//      Send a control function to the resource to get information from it.
//
//  Arguments:
//      dwFunctionCode  [IN] Control function code.
//      pbInBuf         [IN] Input buffer to pass to the resource.
//      cbInBuf         [IN] Size of data in input buffer.
//      ppbOutBuf       [OUT] Output buffer.
//
//  Return Value:
//      Any status returned from ClusterResourceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResource::DwResourceControlGet(
    IN DWORD        dwFunctionCode,
    IN PBYTE        pbInBuf,
    IN DWORD        cbInBuf,
    OUT PBYTE *     ppbOutBuf
    )
{
    DWORD       dwStatus    = ERROR_SUCCESS;
    DWORD       cbOutBuf    = 512;
    CWaitCursor wc;

    ASSERT(ppbOutBuf != NULL);
    *ppbOutBuf = NULL;

    // Allocate memory for the buffer.
    try
    {
        *ppbOutBuf = new BYTE[cbOutBuf];
        if ( *ppbOutBuf == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the output buffer
    } // try
    catch (CMemoryException * pme)
    {
        *ppbOutBuf = NULL;
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        pme->Delete();
    } // catch:  CMemoryException
    if (dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }

    // Call the control function to get the data.
    dwStatus = ClusterResourceControl(
                    Hresource(),
                    NULL,
                    dwFunctionCode,
                    pbInBuf,
                    cbInBuf,
                    *ppbOutBuf,
                    cbOutBuf,
                    &cbOutBuf
                    );
    if (dwStatus == ERROR_MORE_DATA)
    {
        // Allocate more memory for the buffer.
        try
        {
            dwStatus = ERROR_SUCCESS;
            delete [] *ppbOutBuf;
            *ppbOutBuf = new BYTE[cbOutBuf];
            if ( *ppbOutBuf == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the output buffer
        } // try
        catch (CMemoryException * pme)
        {
            *ppbOutBuf = NULL;
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            pme->Delete();
        } // catch:  CMemoryException
        if (dwStatus != ERROR_SUCCESS)
        {
            return dwStatus;
        }

        // Call the control function again to get the data.
        dwStatus = ClusterResourceControl(
                        Hresource(),
                        NULL,
                        dwFunctionCode,
                        pbInBuf,
                        cbInBuf,
                        *ppbOutBuf,
                        cbOutBuf,
                        &cbOutBuf
                        );
    } // if:  our buffer is too small
    if ((dwStatus != ERROR_SUCCESS) || (cbOutBuf == 0))
    {
        delete [] *ppbOutBuf;
        *ppbOutBuf = NULL;
    } // if:  error getting data or no data returned

    return dwStatus;

} //*** CResource::DwResourceControlGet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::PlstrExtension
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CResource::PlstrExtensions(void) const
{
    return &LstrCombinedExtensions();

} //*** CResource::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::ReadExtensions
//
//  Routine Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::ReadExtensions(void)
{
    CWaitCursor wc;

    // Construct the list of extensions.
    {
        POSITION            posStr;
        const CStringList * plstr;

        ASSERT_VALID(Pdoc());

        m_lstrCombinedExtensions.RemoveAll();

        // Add resource-specific extensions first.
        if (PciResourceType() != NULL)
        {
            ASSERT_VALID(PciResourceType());
            plstr = &PciResourceType()->LstrAdminExtensions();
            posStr = plstr->GetHeadPosition();
            while (posStr != NULL)
            {
                m_lstrCombinedExtensions.AddTail(plstr->GetNext(posStr));
            } // while:  more extensions available
        } // if:  valid resource type found

        // Add extensions for all resources next.
        plstr = &Pdoc()->PciCluster()->LstrResourceExtensions();
        posStr = plstr->GetHeadPosition();
        while (posStr != NULL)
        {
            m_lstrCombinedExtensions.AddTail(plstr->GetNext(posStr));
        } // while:  more extensions available
    } // Construct the list of extensions

} //*** CResource::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CollecPossibleOwners
//
//  Routine Description:
//      Construct a list of node items which are enumerable on the
//      resource.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterResourceOpenEnum() or
//                        ClusterResourceEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CollectPossibleOwners(IN OUT CNodeList * plpci) const
{
    DWORD           dwStatus;
    HRESENUM        hresenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CClusterNode *  pciNode;
    CWaitCursor     wc;

    ASSERT_VALID(Pdoc());
    ASSERT(Hresource() != NULL);

    if (plpci == NULL)
    {
        plpci = m_plpcinodePossibleOwners;
    }

    ASSERT(plpci != NULL);

    // Remove the previous contents of the list.
    plpci->RemoveAll();

    if (Hresource() != NULL)
    {
        // Open the enumeration.
        hresenum = ClusterResourceOpenEnum(Hresource(), CLUSTER_RESOURCE_ENUM_NODES);
        if (hresenum == NULL)
        {
            ThrowStaticException(GetLastError(), IDS_ENUM_POSSIBLE_OWNERS_ERROR, StrName());
        }

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            // Loop through the enumeration and add each dependent resource to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating the name buffer
                    dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                } // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                {
                    break;
                }
                else if (dwStatus != ERROR_SUCCESS)
                {
                    ThrowStaticException(dwStatus, IDS_ENUM_POSSIBLE_OWNERS_ERROR, StrName());
                }

                ASSERT(dwRetType == CLUSTER_RESOURCE_ENUM_NODES);

                // Find the item in the list of resources on the document.
                pciNode = Pdoc()->LpciNodes().PciNodeFromName(pwszName);
                ASSERT_VALID(pciNode);

                // Add the resource to the list.
                if (pciNode != NULL)
                {
                    plpci->AddTail(pciNode);
                } // if:  found node in list

            } // for:  each item in the group

            delete [] pwszName;
            ClusterResourceCloseEnum(hresenum);

        } // try
        catch (CException *)
        {
            delete [] pwszName;
            ClusterResourceCloseEnum(hresenum);
            throw;
        } // catch:  any exception
    } // if:  resource is available

} //*** CResource::CollecPossibleOwners()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::RemoveNodeFromPossibleOwners
//
//  Routine Description:
//      Remove the passed in node from the possible owners list.
//
//  Arguments:
//      plpci       [IN OUT] List to fill.
//      pNode       [IN] The node to remove from the list
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CList.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::RemoveNodeFromPossibleOwners(
    IN OUT      CNodeList *     plpci,
    IN const    CClusterNode *  pNode
    )
{
    if (plpci == NULL)
    {
        plpci = m_plpcinodePossibleOwners;
    } // if: plpci is NULL

    ASSERT(plpci != NULL);

    POSITION        _pos;
    CClusterNode *  _pnode = plpci->PciNodeFromName(pNode->StrName(), &_pos);

    if ((_pnode != NULL) && (_pos != NULL))
    {
        plpci->RemoveAt(_pos);
    } // if: node was found in the list

} //*** CResource::RemoveNodeFromPossibleOwners()
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CollectDependencies
//
//  Routine Description:
//      Collect the resources on which this resource is dependent.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//      bFullTree       [IN] TRUE = collect dependencies of dependencies.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterResourceOpenEnum() or
//                        ClusterResourceEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CollectDependencies(
    IN OUT CResourceList *  plpci,
    IN BOOL                 bFullTree
    ) const
{
    DWORD           dwStatus;
    HRESENUM        hresenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CResource *     pciRes;
    CWaitCursor     wc;

    ASSERT_VALID(Pdoc());
    ASSERT(Hresource() != NULL);

    if (plpci == NULL)
    {
        plpci = m_plpciresDependencies;
    }

    ASSERT(plpci != NULL);

    // Remove the previous contents of the list.
    if (!bFullTree)
    {
        plpci->RemoveAll();
    }

    if (Hresource() != NULL)
    {
        // Open the enumeration.
        hresenum = ClusterResourceOpenEnum(Hresource(), CLUSTER_RESOURCE_ENUM_DEPENDS);
        if (hresenum == NULL)
        {
            ThrowStaticException(GetLastError(), IDS_ENUM_DEPENDENCIES_ERROR, StrName());
        }

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            // Loop through the enumeration and add each dependent resource to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating the name buffer
                    dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                } // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                {
                    break;
                }
                else if (dwStatus != ERROR_SUCCESS)
                {
                    ThrowStaticException(dwStatus, IDS_ENUM_DEPENDENCIES_ERROR, StrName());
                }

                ASSERT(dwRetType == CLUSTER_RESOURCE_ENUM_DEPENDS);

                // Find the item in the list of resources on the document and
                // add its dependencies to the list.
                pciRes = Pdoc()->LpciResources().PciResFromName(pwszName);
                if (pciRes != NULL)
                {
                    // Add this resource to the list.
                    if (plpci->Find(pciRes) == NULL)
                    {
                        plpci->AddTail(pciRes);
                    } // if:  resource not in the list yet

                    // Add the resources on which this resource is dependent to the list.
                    if (bFullTree)
                    {
                        pciRes->CollectDependencies(plpci, bFullTree);
                    }
                } // if:  resource found in the list
            } // for:  each item in the group

            delete [] pwszName;
            ClusterResourceCloseEnum(hresenum);

        } // try
        catch (CException *)
        {
            delete [] pwszName;
            if (hresenum != NULL)
            {
                ClusterResourceCloseEnum(hresenum);
            }
            throw;
        } // catch:  any exception
    } // if:  resource is available

} //*** CResource::CollectDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CollectProvidesFor
//
//  Routine Description:
//      Collect the list of resources which are dependent on this resource.
//
//  Arguments:
//      plpci       [IN OUT] List of resources.
//      bFullTree   [IN] TRUE = collect dependencies of dependencies.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from ClusterResourceOpenEnum() or
//                            ClusterResourceEnum().
//      Any exceptions thrown by CList::AddHead().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CollectProvidesFor(
    IN OUT CResourceList *  plpci,
    IN BOOL                 bFullTree
    ) const
{
    DWORD           dwStatus;
    HRESENUM        hresenum    = NULL;
    WCHAR *         pwszName    = NULL;
    int             ienum;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwType;
    CResource *     pciRes;
    CWaitCursor     wc;

    ASSERT_VALID(this);
    ASSERT(Hresource != NULL);

    ASSERT(plpci != NULL);

    // Remove the previous contents of the list.
    if (!bFullTree)
    {
        plpci->RemoveAll();
    }

    if (Hresource() != NULL)
    {
        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            // Open the enumeration.
            hresenum = ClusterResourceOpenEnum(Hresource(), CLUSTER_RESOURCE_ENUM_PROVIDES);
            if (hresenum == NULL)
            {
                ThrowStaticException(GetLastError(), IDS_ENUM_PROVIDES_FOR_ERROR, StrName());
            }

            // Loop through the enumeration and add each one's providers to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterResourceEnum(hresenum, ienum, &dwType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating the name buffer
                    dwStatus = ClusterResourceEnum(hresenum, ienum, &dwType, pwszName, &cchName);
                } // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                {
                    break;
                }
                else if (dwStatus != ERROR_SUCCESS)
                {
                    ThrowStaticException(dwStatus, IDS_ENUM_PROVIDES_FOR_ERROR, StrName());
                }

                ASSERT(dwType == CLUSTER_RESOURCE_ENUM_PROVIDES);

                // Find the item in the list of resources on the document and
                // add its providers to the list.
                pciRes = Pdoc()->LpciResources().PciResFromName(pwszName);
                if (pciRes != NULL)
                {
                    // Add this resource to the list.
                    if (plpci->Find(pciRes) == NULL)
                    {
                        plpci->AddHead(pciRes);
                    } // if:  resource not in the list yet

                    // Add the resources this resource provides for to the list.
                    if (bFullTree)
                    {
                        pciRes->CollectProvidesFor(plpci, bFullTree);
                    }
                } // if:  resource found in the list
            } // for:  each dependent resource

            // Close the enumeration.
            delete [] pwszName;
            pwszName = NULL;
            ClusterResourceCloseEnum(hresenum);
            hresenum = NULL;

        } // try
        catch (CException *)
        {
            delete [] pwszName;
            if (hresenum != NULL)
            {
                ClusterResourceCloseEnum(hresenum);
            }
            throw;
        } // catch:  CException
    } // if:  resource is available

} //*** CResource::CollectProvidesFor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CollectDependencyTree
//
//  Routine Description:
//      Collect the resources on which this resource is dependent and which
//      are dependent on it.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterResourceOpenEnum() or
//                        ClusterResourceEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CollectDependencyTree(
    IN OUT CResourceList *  plpci
    ) const
{
    DWORD           dwStatus;
    HRESENUM        hresenum = NULL;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CResource *     pciRes;
    CWaitCursor     wc;
    int             iType;
    static DWORD    rgdwType[]  = { CLUSTER_RESOURCE_ENUM_DEPENDS, CLUSTER_RESOURCE_ENUM_PROVIDES };
    static IDS      rgidsTypeError[] = { IDS_ENUM_DEPENDENCIES_ERROR, IDS_ENUM_PROVIDES_FOR_ERROR };

    ASSERT_VALID(Pdoc());
    ASSERT(Hresource() != NULL);

    ASSERT(plpci != NULL);

    if (Hresource() != NULL)
    {
        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            for (iType = 0 ; iType < sizeof(rgdwType) / sizeof(DWORD) ; iType++)
            {
                // Open the enumeration.
                hresenum = ClusterResourceOpenEnum(Hresource(), rgdwType[iType]);
                if (hresenum == NULL)
                {
                    ThrowStaticException(GetLastError(), rgidsTypeError[iType], StrName());
                }

                // Loop through the enumeration and add each dependent or
                // provider resource to the list.
                for (ienum = 0 ; ; ienum++)
                {
                    // Get the next item in the enumeration.
                    cchName = cchmacName;
                    dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                    if (dwStatus == ERROR_MORE_DATA)
                    {
                        delete [] pwszName;
                        cchmacName = ++cchName;
                        pwszName = new WCHAR[cchmacName];
                        if ( pwszName == NULL )
                        {
                            AfxThrowMemoryException();
                        } // if: error allocating the name buffer
                        dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                    } // if:  name buffer was too small
                    if (dwStatus == ERROR_NO_MORE_ITEMS)
                    {
                        break;
                    }
                    else if (dwStatus != ERROR_SUCCESS)
                    {
                        ThrowStaticException(dwStatus, rgidsTypeError[iType], StrName());
                    }

                    ASSERT(dwRetType == rgdwType[iType]);

                    // Find the item in the list of resources on the document and
                    // add its dependencies and providers to the list.
                    pciRes = Pdoc()->LpciResources().PciResFromName(pwszName);
                    if (pciRes != NULL)
                    {
                        // Add this resource to the list.
                        if (plpci->Find(pciRes) == NULL)
                        {
                            plpci->AddTail(pciRes);
                            pciRes->CollectDependencyTree(plpci);
                        } // if:  resource not in the list yet
                    } // if:  resource found in the list
                } // for:  each item in the group

                ClusterResourceCloseEnum(hresenum);
                hresenum = NULL;

            } // for:  each type of enumeration

            delete [] pwszName;

        } // try
        catch (CException *)
        {
            delete [] pwszName;
            if (hresenum != NULL)
            {
                ClusterResourceCloseEnum(hresenum);
            }
            throw;
        } // catch:  any exception
    } // if:  resource is available

} //*** CResource::CollectDependencyTree()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetName
//
//  Routine Description:
//      Set the name of this resource.
//
//  Arguments:
//      pszName         [IN] New name of the resource.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by Rename.
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetName(IN LPCTSTR pszName)
{
    Rename(pszName);

} //*** CResource::SetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetGroup
//
//  Routine Description:
//      Set the group to which this resource belongs.
//
//  Arguments:
//      pszGroup        [IN] New group for the resource.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_MOVE_RESOURCE_ERROR - errors from
//                          ChangeClusterResourceGroup().
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetGroup(IN LPCTSTR pszGroup)
{
    DWORD       dwStatus;
    CGroup *    pciGroup;
    CString     strGroup(pszGroup); // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(pszGroup != NULL);
    ASSERT(Hresource() != NULL);

    if ((Hresource() != NULL) && (StrGroup() != pszGroup))
    {
        // Find the group.
        pciGroup = Pdoc()->LpciGroups().PciGroupFromName(pszGroup);
        ASSERT_VALID(pciGroup);

        // Change the group.
        dwStatus = ChangeClusterResourceGroup(Hresource(), pciGroup->Hgroup());
        if (dwStatus != ERROR_SUCCESS)
        {
            ThrowStaticException(dwStatus, IDS_MOVE_RESOURCE_ERROR, StrName(), pszGroup);
        }

        SetGroupState(pciGroup->StrName());
    } // if:  the name changed

} //*** CResource::SetGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetDependencies
//
//  Routine Description:
//      Set the list of resources on which this resource depends on
//      in the cluster database.
//
//  Arguments:
//      rlpci       [IN] List of resources on which this resource depends on.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException(dwStatus)  Errors from AddClusterResourceDependency()
//                                and RemoveClusterResourceDependency().
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetDependencies(IN const CResourceList & rlpci)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    if (Hresource() != NULL)
    {
        // Add any entries that are in the new last but not in the old list as
        // new dependencies.
        {
            POSITION    posPci;
            CResource * pciRes;

            posPci = rlpci.GetHeadPosition();
            while (posPci != NULL)
            {
                pciRes = (CResource *) rlpci.GetNext(posPci);
                ASSERT_VALID(pciRes);

                if (LpciresDependencies().Find(pciRes) == NULL)
                {
                    // Add the resource as a dependency of this one.
                    dwStatus = AddClusterResourceDependency(Hresource(), pciRes->Hresource());
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        ThrowStaticException(dwStatus, IDS_ADD_DEPENDENCY_ERROR, pciRes->StrName(), StrName());
                    }

                    // Add the resource into our list.
                    m_plpciresDependencies->AddTail(pciRes);
                } // if:  item not found in existing list
            } // while:  more items in the list
        } // Add new dependencies

        // Delete any entries that are in the new old but not in the new list.
        {
            POSITION    posPci;
            POSITION    posPrev;
            CResource * pciRes;

            posPci = LpciresDependencies().GetHeadPosition();
            while (posPci != NULL)
            {
                posPrev = posPci;
                pciRes = (CResource *) LpciresDependencies().GetNext(posPci);
                if (rlpci.Find(pciRes) == NULL)
                {
                    // Remove the resource as a dependency of this one.
                    dwStatus = RemoveClusterResourceDependency(Hresource(), pciRes->Hresource());
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        ThrowStaticException(dwStatus, IDS_REMOVE_DEPENDENCY_ERROR, pciRes->StrName(), StrName());
                    }

                    // Remove the resource from our list.
                    m_plpciresDependencies->RemoveAt(posPrev);
                } // if:  item not found in new list
            } // while:  more items in the list
        } // Remove old dependencies
    } // if:  resource is available

} //*** CResource::SetDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetPossibleOwners
//
//  Routine Description:
//      Set the list of possible owners of this resource in the cluster
//      database.
//
//  Arguments:
//      rlpci       [IN] List of possible owners (nodes).
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException            IDS_TAKE_RESOURCE_OFFLINE_ERROR.
//      CNTException(dwStatus)  Errors from AddClusterResourceNode()
//                                and RemoveClusterResourceNode().
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetPossibleOwners(IN const CNodeList & rlpci)
{
    DWORD           dwStatus;
    CWaitCursor     wc;
    POSITION        posPci;
    POSITION        posPrev;
    CClusterNode *  pciNode;

    ASSERT( Hresource() != NULL );

    if ( Hresource() == NULL )
    {
        ThrowStaticException( ERROR_INVALID_HANDLE, IDS_MODIFY_RES_OWNER_ERROR, StrName() );
        return;
    }

    //
    // Add any entries that are in the new list but not in the old list as
    // new owners.
    //
    posPci = rlpci.GetHeadPosition();
    while (posPci != NULL)
    {
        pciNode = (CClusterNode *) rlpci.GetNext(posPci);
        ASSERT_VALID(pciNode);

        if (LpcinodePossibleOwners().Find(pciNode) == NULL)
        {
            // Add the node as an owner of this resource.
            dwStatus = AddClusterResourceNode(Hresource(), pciNode->Hnode());
            if (dwStatus != ERROR_SUCCESS)
            {
                ThrowStaticException(dwStatus, IDS_ADD_RES_OWNER_ERROR, pciNode->StrName(), StrName());
            }

            // Add the node into our list.
            m_plpcinodePossibleOwners->AddTail(pciNode);

        } // if:  item not found in existing list

    } // while:  more items in the list to add

    //
    // Delete any entries that are in the old but not in the new list.
    //
    posPci = LpcinodePossibleOwners().GetHeadPosition();
    while (posPci != NULL)
    {
        posPrev = posPci;
        pciNode = (CClusterNode *) LpcinodePossibleOwners().GetNext(posPci);
        if (rlpci.Find(pciNode) == NULL)
        {
            // Remove the node as an owner of this resource.
            dwStatus = RemoveClusterResourceNode(Hresource(), pciNode->Hnode());
            if (dwStatus != ERROR_SUCCESS)
            {
                if ( dwStatus == ERROR_INVALID_STATE )
                {
                    ThrowStaticException(dwStatus, IDS_REMOVE_RES_OWNER_GROUP_STATE_ERROR, pciNode->StrName(), StrName());
                }
                else
                {
                    ThrowStaticException(dwStatus, IDS_REMOVE_RES_OWNER_ERROR, pciNode->StrName(), StrName());
                }

            } // if: error removing node as owner

            // Remove the node from our list.
            m_plpcinodePossibleOwners->RemoveAt(posPrev);

        } // if:  item not found in new list

    } // while:  more items in the list to delete

} //*** CResource::SetPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetCommonProperties
//
//  Routine Description:
//      Set the common properties for this resource in the cluster database.
//
//  Arguments:
//      rstrDesc        [IN] Description string.
//      bSeparate       [IN] TRUE = run resource in separate monitor, FALSE = run with other resources.
//      nLooksAlive     [IN] Looks Alive poll interval.
//      nIsAlive        [IN] Is Alive poll interval.
//      crra            [IN] Restart action.
//      nThreshold      [IN] Restart threshold.
//      nPeriod         [IN] Restart period.
//      nTimeout        [IN] Pending timeout in minutes.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusterItem::SetCommonProperties().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetCommonProperties(
    IN const CString &  rstrDesc,
    IN BOOL             bSeparate,
    IN DWORD            nLooksAlive,
    IN DWORD            nIsAlive,
    IN CRRA             crra,
    IN DWORD            nThreshold,
    IN DWORD            nPeriod,
    IN DWORD            nTimeout,
    IN BOOL             bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;
    m_rgProps[epropSeparateMonitor].m_value.pb = &bSeparate;
    m_rgProps[epropLooksAlive].m_value.pdw = &nLooksAlive;
    m_rgProps[epropIsAlive].m_value.pdw = &nIsAlive;
    m_rgProps[epropRestartAction].m_value.pdw = (DWORD *) &crra;
    m_rgProps[epropRestartThreshold].m_value.pdw = &nThreshold;
    m_rgProps[epropRestartPeriod].m_value.pdw = &nPeriod;
    m_rgProps[epropPendingTimeout].m_value.pdw = &nTimeout;

    try
    {
        CClusterItem::SetCommonProperties(bValidateOnly);
    } // try
    catch (CNTException * pnte)
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    } // catch:  CNTException

    m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
    m_rgProps[epropSeparateMonitor].m_value.pb = &m_bSeparateMonitor;
    m_rgProps[epropLooksAlive].m_value.pdw = &m_nLooksAlive;
    m_rgProps[epropIsAlive].m_value.pdw = &m_nIsAlive;
    m_rgProps[epropRestartAction].m_value.pdw = (DWORD *) &m_crraRestartAction;
    m_rgProps[epropRestartThreshold].m_value.pdw = &m_nRestartThreshold;
    m_rgProps[epropRestartPeriod].m_value.pdw = &m_nRestartPeriod;
    m_rgProps[epropPendingTimeout].m_value.pdw = &m_nPendingTimeout;

    if (nte.Sc() != ERROR_SUCCESS)
    {
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );
    }

} //*** CResource::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::DwSetCommonProperties
//
//  Routine Description:
//      Set the common properties for this resource in the cluster database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      Any status returned by ClusterResourceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResource::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource());

    if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if (bValidateOnly)
        {
            dwControl = CLUSCTL_RESOURCE_VALIDATE_COMMON_PROPERTIES;
        }
        else
        {
            dwControl = CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES;
        }

        // Set common properties.
        dwStatus = ClusterResourceControl(
                        Hresource(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        static_cast< DWORD >( rcpl.CbPropList() ),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    } // if:  there is data to set
    else
    {
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;

} //*** CResource::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BRequiredDependenciesPresent
//
//  Routine Description:
//      Determine if the specified list contains each required resource
//      for this type of resource.
//
//  Arguments:
//      rlpciRes        [IN] List of resources.
//      rstrMissing     [OUT] String in which to return a missing resource
//                          class name or type name.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CString::LoadString() or CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BRequiredDependenciesPresent(
    IN const CResourceList &    rlpciRes,
    OUT CString &               rstrMissing
    )
{
    POSITION                pos;
    BOOL                    bFound = TRUE;
    const CResource *       pciRes;
    CLUSPROP_BUFFER_HELPER  props;

    if (Pcrd() == NULL)
    {
        return TRUE;
    }

    // Collect the list of required dependencies.
    props.pRequiredDependencyValue = Pcrd();

    // Loop through each required dependency and make sure
    // there is a dependency on a resource of that type.
    while (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
    {
        bFound = FALSE;
        pos = rlpciRes.GetHeadPosition();
        while (pos != NULL)
        {
            // Get the next resource.
            pciRes = (CResource *) rlpciRes.GetNext(pos);
            ASSERT_VALID(pciRes);
            ASSERT_KINDOF(CResource, pciRes);

            // If this is the right type, we've satisfied the
            // requirement so exit the loop.
            if (props.pSyntax->dw == CLUSPROP_SYNTAX_RESCLASS)
            {
                if (props.pResourceClassValue->rc == pciRes->ResClass())
                {
                    bFound = TRUE;
                    props.pb += sizeof(*props.pResourceClassValue);
                } // if:  match found
            } // if:  resource class
            else if (props.pSyntax->dw == CLUSPROP_SYNTAX_NAME)
            {
                if (pciRes->StrRealResourceType().CompareNoCase(props.pStringValue->sz) == 0)
                {
                    bFound = TRUE;
                    props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(props.pStringValue->cbLength);
                } // if:  match found
            } // else if:  resource name
            else
            {
                ASSERT(0);
                break;
            } // else:  unknown data type

            if (bFound)
            {
                break;
            }
        } // while:  more items in the list

        // If a match was not found, changes cannot be applied.
        if (!bFound)
        {
            if (props.pSyntax->dw == CLUSPROP_SYNTAX_RESCLASS)
            {
                if (!rstrMissing.LoadString(IDS_RESCLASS_UNKNOWN + props.pResourceClassValue->rc))
                {
                    rstrMissing.LoadString(IDS_RESCLASS_UNKNOWN);
                }
            } // if:  resource class not found
            else if (props.pSyntax->dw == CLUSPROP_SYNTAX_NAME)
            {
                CResourceType * pciResType;

                // Find the resource type in our list.
                pciResType = (CResourceType *) Pdoc()->LpciResourceTypes().PciFromName(props.pStringValue->sz);
                if (pciResType != NULL)
                {
                    rstrMissing = pciResType->StrDisplayName();
                }
                else
                {
                    rstrMissing = props.pStringValue->sz;
                }
            } // else if:  resource type name not found
            break;
        } // if:  not found

    } // while:  more dependencies required

    return bFound;

} //*** CResource::BRequiredDependenciesPresent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::DeleteResource
//
//  Routine Description:
//      Delete this resource and all dependent resources.
//
//  Arguments:
//      rlpci       [IN] List of resources to delete in addition to this one.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CResource::DeleteResource().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::DeleteResource(IN const CResourceList & rlpci)
{
    CWaitCursor wc;

    // Delete each resource in the list.
    {
        POSITION    pos;
        CResource * pciRes;

        pos = rlpci.GetHeadPosition();
        while (pos != NULL)
        {
            pciRes = (CResource *) rlpci.GetNext(pos);
            if (pciRes != NULL)
            {
                pciRes->DeleteResource();
            }
        } // while:  more items in the list
    } // Delete each resource in the list

    // Delete this resource.
    DeleteResource();

} //*** CResource::DeleteResource(rlpci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::DeleteResource
//
//  Routine Description:
//      Delete this resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from DeleteClusterResource().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::DeleteResource(void)
{
    DWORD       dwStatus;
    BOOL        bWeTookOffline = FALSE;
    CWaitCursor wc;

    ASSERT(!BDeleting());

    if (Hresource() != NULL)
    {
        // Make sure the resource is offline.
        if (    (Crs() != ClusterResourceOffline)
            &&  (Crs() != ClusterResourceFailed))
        {
            dwStatus = OfflineClusterResource(Hresource());
            if (dwStatus == ERROR_IO_PENDING)
            {
                WaitForOffline();
                if (    (Crs() != ClusterResourceOffline)
                    &&  (Crs() != ClusterResourceFailed))
                {
                    ThrowStaticException(IDS_DELETE_RESOURCE_ERROR_OFFLINE_PENDING, StrName());
                }  // if: resource still not offline
            } // if: offline pending
            else if (  (dwStatus != ERROR_SUCCESS)
                    && (dwStatus != ERROR_FILE_NOT_FOUND)
                    && (dwStatus != ERROR_RESOURCE_NOT_AVAILABLE))
            {
                ThrowStaticException(dwStatus, IDS_TAKE_RESOURCE_OFFLINE_ERROR, StrName());
            }
            bWeTookOffline = TRUE;
        } // if: resource is not offline

        // Delete the resource itself.
        Trace(g_tagResource, _T("(%s) DeleteResource() - Deleting '%s' (%x)"), Pdoc()->StrNode(), StrName(), this);
        dwStatus = DeleteClusterResource(Hresource());
        if (   (dwStatus != ERROR_SUCCESS)
            && (dwStatus != ERROR_FILE_NOT_FOUND)
            && (dwStatus != ERROR_RESOURCE_NOT_AVAILABLE))
        {
            if (bWeTookOffline)
            {
                OnlineClusterResource(Hresource());
            }
            ThrowStaticException(dwStatus, IDS_DELETE_RESOURCE_ERROR, StrName());
        } // if:  error occurred

        m_bDeleting = TRUE;

        UpdateState();
    } // if:  resource has been opened/created

} //*** CResource::DeleteResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::WaitForOffline
//
//  Routine Description:
//      Wait for the resource to go offline.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CResource::Move().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::WaitForOffline( void )
{
    CWaitForResourceOfflineDlg  dlg( this, AfxGetMainWnd() );

    dlg.DoModal();
    UpdateState();

} //*** CResource::WaitForOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Move
//
//  Routine Description:
//      Move this resource and all dependent and depending resources to
//      another group.
//
//  Arguments:
//      pciGroup    [IN] Group to move resources to.
//      rlpci       [IN] List of resources to move in addition to this one.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CResource::Move().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Move(
    IN const CGroup *           pciGroup,
    IN const CResourceList &    rlpci
    )
{
    CWaitCursor wc;

    // Move each resource in the list.
    {
        POSITION    pos;
        CResource * pciRes;

        pos = rlpci.GetHeadPosition();
        while (pos != NULL)
        {
            pciRes = (CResource *) rlpci.GetNext(pos);
            if (pciRes != NULL)
            {
                pciRes->Move(pciGroup);
            }
        } // while:  more items in the list
    } // Move each resource in the list

    // Move this resource.
    Move(pciGroup);

} //*** CResource::Move(rlpci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Move
//
//  Routine Description:
//      Move this resource.
//
//  Arguments:
//      pciGroup    [IN] Group to move resources to.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from ChangeClusterResourceGroup().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Move(IN const CGroup * pciGroup)
{
    DWORD           dwStatus;

    ASSERT_VALID(pciGroup);

    if ((Hresource() != NULL)
            && (pciGroup != NULL)
            && (pciGroup->Hgroup() != NULL))
    {
        // Move the resource.
        Trace(g_tagResource, _T("(%s) Move() - moving '%s' (%x) from '%s' (%x) to '%s' (%x)"), Pdoc()->StrNode(), StrName(), this, StrGroup(), PciGroup(), pciGroup->StrName(), pciGroup);
        dwStatus = ChangeClusterResourceGroup(Hresource(), pciGroup->Hgroup());
        if ((dwStatus != ERROR_SUCCESS)
                && (dwStatus != ERROR_FILE_NOT_FOUND))
            ThrowStaticException(dwStatus, IDS_MOVE_RESOURCE_ERROR, StrName(), pciGroup->StrName());

        UpdateState();
    } // if:  resource has been opened/created

} //*** CResource::Move()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnFinalRelease
//
//  Routine Description:
//      Called when the last OLE reference to or from the object is released.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnFinalRelease(void)
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CClusterItem::OnFinalRelease();

} //*** CResource::OnFinalRelease()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BCanBeDependent
//
//  Routine Description:
//      Determine whether this resource can be dependent on the specified one.
//
//  Arguments:
//      pciRes      [IN] Resource to check.
//
//  Return Value:
//      TRUE        Resource can be a dependent.
//      FALSE       Resource can NOT be a dependent.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BCanBeDependent(IN CResource * pciRes)
{
    CWaitCursor wc;

    ASSERT_VALID(pciRes);

    if ((Hresource() != NULL)
            && (pciRes->Hresource() != NULL)
            && (pciRes != this)
            && (StrGroup() == pciRes->StrGroup())
            )
    {
        return ::CanResourceBeDependent(Hresource(), pciRes->Hresource());
    }
    else
    {
        return FALSE;
    }

} //*** CResource::BCanBeDependent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BIsDependent
//
//  Routine Description:
//      Determine whether this resource is dependent on the specified one.
//
//  Arguments:
//      pciRes      [IN] Resource to check.
//
//  Return Value:
//      TRUE        Resource is a dependent.
//      FALSE       Resource is NOT a dependent.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BIsDependent(IN CResource * pciRes)
{
    ASSERT_VALID(pciRes);

    if ((m_plpciresDependencies != NULL)
            && (LpciresDependencies().Find(pciRes) != NULL))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

} //*** CResource::BIsDependent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BGetNetworkName
//
//  Routine Description:
//      Returns the name of the network name of the first Network Name
//      resource on which the specified resource depends.
//
//  Arguments:
//      lpszNetName     [OUT] String in which to return the network name.
//      pcchNetName     [IN OUT] Points to a variable that specifies the
//                          maximum size, in characters, of the buffer.  This
//                          value should be large enough to contain
//                          MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//                          return it contains the actual number of characters
//                          copied.
//
//  Return Value:
//      TRUE        Resource is dependent on a network name resource.
//      FALSE       Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BGetNetworkName(
    OUT WCHAR *     lpszNetName,
    IN OUT DWORD *  pcchNetName
    )
{
    CWaitCursor wc;

    ASSERT_VALID(this);
    ASSERT(m_hresource != NULL);

    ASSERT(lpszNetName != NULL);
    ASSERT(pcchNetName != NULL);

    return GetClusterResourceNetworkName(m_hresource, lpszNetName, pcchNetName);

} //*** CResource::BGetNetworkName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BGetNetworkName
//
//  Routine Description:
//      Returns the name of the network name of the first Network Name
//      resource on which the specified resource depends.
//
//  Arguments:
//      rstrNetName     [OUT] String in which to return the network name.
//
//  Return Value:
//      TRUE        Resource is dependent on a network name resource.
//      FALSE       Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BGetNetworkName(OUT CString & rstrNetName)
{
    BOOL    bSuccess;
    WCHAR   szNetName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD   nSize = sizeof(szNetName) / sizeof(WCHAR);

    bSuccess = BGetNetworkName(szNetName, &nSize);
    if (bSuccess)
    {
        rstrNetName = szNetName;
    }
    else
    {
        rstrNetName = _T("");
    }

    return bSuccess;

} //*** CResource::BGetNetworkName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::UpdateState(void)
{
    CClusterAdminApp *      papp        = GetClusterAdminApp();
    WCHAR *                 pwszOwner   = NULL;
    WCHAR *                 pwszGroup   = NULL;
    WCHAR *                 prgwszOwner = NULL;
    WCHAR *                 prgwszGroup = NULL;
    DWORD                   cchOwner;
    DWORD                   cchGroup;
    DWORD                   sc;
    DWORD                   oldcchOwner;
    DWORD                   oldcchGroup;

    Trace(g_tagResource, _T("(%s) (%s (%x)) - Updating state"), Pdoc()->StrNode(), StrName(), this);

    // Get the current state of the resource.
    if (Hresource() == NULL)
    {
        m_crs = ClusterResourceStateUnknown;
    }
    else
    {
        CWaitCursor wc;

        cchOwner = 100;
        oldcchOwner = cchOwner;
        prgwszOwner = new WCHAR[cchOwner];
        if ( prgwszOwner == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the buffer

        cchGroup = 100;
        oldcchGroup = cchGroup;
        prgwszGroup = new WCHAR[cchGroup];
        if ( prgwszGroup == NULL )
        {
            delete [] prgwszOwner;
            AfxThrowMemoryException();
        } // if: error allocating the buffer

        m_crs = GetClusterResourceState(Hresource(), prgwszOwner, &cchOwner, prgwszGroup, &cchGroup);
        sc = GetLastError();
        
        if ( sc == ERROR_MORE_DATA )
        {
            //
            // Increment before the check.  This way we'll know whether we'll need to resize the buffer,
            // and if not then we report it as being just big enough.
            //
            cchOwner++;
            if ( cchOwner > oldcchOwner )
            {
                delete [] prgwszOwner;
                oldcchOwner = cchOwner;
                prgwszOwner = new WCHAR[cchOwner];
                if( prgwszOwner == NULL )
                {
                    delete [] prgwszGroup;
                    AfxThrowMemoryException();
                } // if: error allocating the buffer
            }

            cchGroup++;
            if ( cchGroup > oldcchGroup )
            {
                delete [] prgwszGroup;
                oldcchGroup = cchGroup;
                prgwszGroup = new WCHAR[cchGroup];
                if ( prgwszGroup == NULL )
                {
                    delete [] prgwszOwner;
                    AfxThrowMemoryException();
                } // if: error allocating the buffer
            }

            //
            // Note that it's possible that the owning group or node changed since the last call to 
            // GetClusterResourceState.  In that case our buffers may still be too small.  Hit F5 to refresh.
            //
            m_crs = GetClusterResourceState(Hresource(), prgwszOwner, &cchOwner, prgwszGroup, &cchGroup);
        }
        pwszOwner = prgwszOwner;
        pwszGroup = prgwszGroup;
    } // else:  resource is available

    // Save the current state image index.
    switch (Crs())
    {
        case ClusterResourceStateUnknown:
            m_iimgState = papp->Iimg(IMGLI_RES_UNKNOWN);
            pwszOwner = NULL;
            pwszGroup = NULL;
            break;
        case ClusterResourceOnline:
            m_iimgState = papp->Iimg(IMGLI_RES);
            break;
        case ClusterResourceOnlinePending:
            m_iimgState = papp->Iimg(IMGLI_RES_PENDING);
            break;
        case ClusterResourceOffline:
            m_iimgState = papp->Iimg(IMGLI_RES_OFFLINE);
            break;
        case ClusterResourceOfflinePending:
            m_iimgState = papp->Iimg(IMGLI_RES_PENDING);
            break;
        case ClusterResourceFailed:
            m_iimgState = papp->Iimg(IMGLI_RES_FAILED);
            break;
        default:
            Trace(g_tagResource, _T("(%s) (%s (%x)) - UpdateState: Unknown state '%d' for resource '%s'"), Pdoc()->StrNode(), StrName(), this, Crs(), StrName());
            m_iimgState = (UINT) -1;
            break;
    } // switch:  Crs()

    SetOwnerState(pwszOwner);
    SetGroupState(pwszGroup);

    if( NULL != prgwszOwner )
    {
        delete [] prgwszOwner;
    }
    
    if( NULL != prgwszGroup )
    {
        delete [] prgwszGroup;
    }

    // Call the base class method.
    CClusterItem::UpdateState();

} //*** CResource::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetOwnerState
//
//  Routine Description:
//      Set a new owner for this resource.
//
//  Arguments:
//      pszNewOwner     [IN] Name of the new owner.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetOwnerState(IN LPCTSTR pszNewOwner)
{
    CClusterNode *  pciOldOwner = PciOwner();
    CClusterNode *  pciNewOwner;

    Trace(g_tagResource, _T("(%s) (%s (%x)) - Setting owner to '%s'"), Pdoc()->StrNode(), StrName(), this, pszNewOwner);

    if (pszNewOwner == NULL)
    {
        pciNewOwner = NULL;
    }
    else
    {
        pciNewOwner = Pdoc()->LpciNodes().PciNodeFromName(pszNewOwner);
    }

    if (pciNewOwner != pciOldOwner)
    {
#ifdef _DEBUG
        if (g_tagResource.BAny())
        {
            CString     strMsg;
            CString     strMsg2;

            strMsg.Format(_T("(%s) (%s (%x)) - Changing owner from "), Pdoc()->StrNode(), StrName(), this);
            if (pciOldOwner == NULL)
            {
                strMsg += _T("nothing ");
            }
            else
            {
                strMsg2.Format(_T("'%s' "), pciOldOwner->StrName());
                strMsg += strMsg2;
            } // else:  previous owner
            if (pciNewOwner == NULL)
            {
                strMsg += _T("to nothing");
            }
            else
            {
                strMsg2.Format(_T("to '%s'"), pciNewOwner->StrName());
                strMsg += strMsg2;
            } // else:  new owner
            Trace(g_tagResource, strMsg);
        } // if:  trace tag turned on
#endif
        m_strOwner = pszNewOwner;
        m_pciOwner = pciNewOwner;

        // Update reference counts.
        if (pciOldOwner != NULL)
        {
            pciOldOwner->Release();
        }
        if (pciNewOwner != NULL)
        {
            pciNewOwner->AddRef();
        }

        if (BDocObj())
        {
            if (pciOldOwner != NULL)
            {
                pciOldOwner->RemoveActiveResource(this);
            }
            if (pciNewOwner != NULL)
            {
                pciNewOwner->AddActiveResource(this);
            }
        } // if:  this is a document object
    } // if:  owner changed
    else if ((pszNewOwner != NULL) && (StrOwner() != pszNewOwner))
    {
        m_strOwner = pszNewOwner;
    }

} //*** CResource::SetOwnerState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetGroupState
//
//  Routine Description:
//      Set a new group for this resource.
//
//  Arguments:
//      pszNewGroup     [IN] Name of the new group.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetGroupState(IN LPCTSTR pszNewGroup)
{
    CGroup *    pciOldGroup = PciGroup();
    CGroup *    pciNewGroup;

    Trace(g_tagResource, _T("(%s) (%s (%x)) - Setting group to '%s'"), Pdoc()->StrNode(), StrName(), this, (pszNewGroup == NULL ? _T("") : pszNewGroup));

    if (pszNewGroup == NULL)
    {
        pciNewGroup = NULL;
    }
    else
    {
        pciNewGroup = Pdoc()->LpciGroups().PciGroupFromName(pszNewGroup);
    }

    if (pciNewGroup != pciOldGroup)
    {
#ifdef _DEBUG
        if (g_tagResource.BAny())
        {
            CString     strMsg;
            CString     strMsg2;

            strMsg.Format(_T("(%s) (%s (%x)) - Changing group from "), Pdoc()->StrNode(), StrName(), this);
            if (pciOldGroup == NULL)
            {
                strMsg += _T("nothing ");
            }
            else
            {
                strMsg2.Format(_T("'%s' "), pciOldGroup->StrName());
                strMsg += strMsg2;
            } // else:  previous group
            if (pciNewGroup == NULL)
            {
                strMsg += _T("to nothing");
            }
            else
            {
                strMsg2.Format(_T("to '%s'"), pciNewGroup->StrName());
                strMsg += strMsg2;
            } // else:  new group
            Trace(g_tagResource, strMsg);
        } // if:  trace tag turned on
#endif
        m_strGroup = pszNewGroup;
        m_pciGroup = pciNewGroup;

        // Update reference counts.
        if (pciOldGroup != NULL)
        {
            pciOldGroup->Release();
        }

        if (pciNewGroup != NULL)
        {
            pciNewGroup->AddRef();
        }

        if (BDocObj())
        {
            if (pciOldGroup != NULL)
            {
                pciOldGroup->RemoveResource(this);
            }

            if (pciNewGroup != NULL)
            {
                pciNewGroup->AddResource(this);
            }
        } // if:  this is a document object
    } // if:  owner changed
    else if ((pszNewGroup != NULL) && (StrGroup() != pszNewGroup))
    {
        m_strGroup = pszNewGroup;
    }

} //*** CResource::SetGroupState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
    BOOL    bSuccess;

    switch (colid)
    {
        case IDS_COLTEXT_STATE:
            GetStateName(rstrText);
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_RESTYPE:
            rstrText = StrRealResourceTypeDisplayName();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_OWNER:
            rstrText = StrOwner();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_GROUP:
            if (PciGroup() == NULL)
            {
                rstrText = StrGroup();
            }
            else
            {
                rstrText = PciGroup()->StrName();
            }
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_RESOURCE: // This is for showing dependencies
            colid = IDS_COLTEXT_NAME;
            // FALL THROUGH
        default:
            bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
            break;
    } // switch:  colid

    return bSuccess;

} //*** CResource::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::GetTreeName
//
//  Routine Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CResource::GetTreeName(OUT CString & rstrName) const
{
    CString     strState;

    GetStateName(strState);
    rstrName.Format(_T("%s (%s)"), StrName(), strState);

} //*** CResource::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::GetStateName
//
//  Routine Description:
//      Returns a string with the name of the current state.
//
//  Arguments:
//      rstrState   [OUT] String in which to return the name of the current state.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::GetStateName(OUT CString & rstrState) const
{
    switch (Crs())
    {
        case ClusterResourceStateUnknown:
            rstrState.LoadString(IDS_UNKNOWN);
            break;
        case ClusterResourceOnline:
            rstrState.LoadString(IDS_ONLINE);
            break;
        case ClusterResourceOnlinePending:
            rstrState.LoadString(IDS_ONLINE_PENDING);
            break;
        case ClusterResourceOffline:
            rstrState.LoadString(IDS_OFFLINE);
            break;
        case ClusterResourceOfflinePending:
            rstrState.LoadString(IDS_OFFLINE_PENDING);
            break;
        case ClusterResourceFailed:
            rstrState.LoadString(IDS_FAILED);
            break;
        default:
            rstrState.Empty();
            break;
    } // switch:  Crs()

} //*** CResource::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BCanBeEdited
//
//  Routine Description:
//      Determines if the resource can be renamed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource can be renamed.
//      FALSE       Resource cannot be renamed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BCanBeEdited(void) const
{
    BOOL    bCanBeEdited;

    if (   (Crs() == ClusterResourceStateUnknown)
        || BReadOnly())
    {
        bCanBeEdited  = FALSE;
    }
    else
    {
        bCanBeEdited = TRUE;
    }

    return bCanBeEdited;

} //*** CResource::BCanBeEdited()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Rename
//
//  Routine Description:
//      Rename the resource.
//
//  Arguments:
//      pszName         [IN] New name to give to the resource.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors returned from SetClusterResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Rename(IN LPCTSTR pszName)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    if (StrName() != pszName)
    {
        dwStatus = SetClusterResourceName(Hresource(), pszName);
        if (dwStatus != ERROR_SUCCESS)
        {
            ThrowStaticException(dwStatus, IDS_RENAME_RESOURCE_ERROR, StrName(), pszName);
        }
        m_strName = pszName;
    } // if:  the name changed

} //*** CResource::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL        bHandled    = FALSE;

    // If this is a MOVE_RESOURCE command, process it here.
    if ((ID_FILE_MOVE_RESOURCE_1 <= nID) && (nID <= ID_FILE_MOVE_RESOURCE_20))
    {
        Trace(g_tagResource, _T("(%s) OnCmdMsg() %s (%x) - ID = %d, code = %d"), Pdoc()->StrNode(), StrName(), this, nID, nCode);
        if (nCode == 0)
        {
            OnCmdMoveResource(nID);
            bHandled = TRUE;
        } // if:  code = 0
    } // if:  move resource

    if (!bHandled)
    {
        bHandled = CClusterItem::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    }

    return bHandled;

} //*** CResource::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateBringOnline
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_BRING_ONLINE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateBringOnline(CCmdUI * pCmdUI)
{
    if ((Crs() != ClusterResourceOnline)
            && (Crs() != ClusterResourceOnlinePending)
            && (Crs() != ClusterResourceStateUnknown))
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

} //*** CResource::OnUpdateBringOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateTakeOffline
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_TAKE_OFFLINE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateTakeOffline(CCmdUI * pCmdUI)
{
    if (Crs() == ClusterResourceOnline)
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

} //*** CResource::OnUpdateTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateInitiateFailure
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_INITIATE_FAILURE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateInitiateFailure(CCmdUI * pCmdUI)
{
    if (Crs() == ClusterResourceOnline)
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

} //*** CResource::OnUpdateInitiateFailure()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateMoveResource1
//
//  Routine Description:
//      Determines whether menu items corresponding to
//      ID_FILE_MOVE_RESOURCE_1 should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateMoveResource1(CCmdUI * pCmdUI)
{
    if (pCmdUI->m_pSubMenu == NULL)
    {
        CString     strMenuName;

        if ((pCmdUI->m_pMenu != NULL) && (pCmdUI->m_pSubMenu == NULL))
        {
            pCmdUI->m_pMenu->GetMenuString(pCmdUI->m_nID, strMenuName, MF_BYCOMMAND);
        }

        if ((strMenuName != StrGroup())
                && ((Crs() == ClusterResourceOnline)
                        || (Crs() == ClusterResourceOffline)))
        {
            pCmdUI->Enable(TRUE);
        }
        else
        {
            pCmdUI->Enable(FALSE);
        }
    } // if:  nested menu is being displayed
    else
    {
        BOOL    bEnabled;

        if (Pdoc()->LpciGroups().GetCount() < 2)
        {
            bEnabled = FALSE;
        }
        else
        {
            POSITION    pos;
            UINT        imenu;
            UINT        idMenu;
            UINT        cmenu;
            CGroup *    pciGroup;
            CMenu *     pmenu   = pCmdUI->m_pSubMenu;

            bEnabled = TRUE;

            // Delete the items in the menu.
            cmenu = pmenu->GetMenuItemCount();
            while (cmenu-- > 0)
                pmenu->DeleteMenu(0, MF_BYPOSITION);

            // Add each group to the menu.
            pos = Pdoc()->LpciGroups().GetHeadPosition();
            for (imenu = 0, idMenu = ID_FILE_MOVE_RESOURCE_1
                    ; pos != NULL
                    ; idMenu++)
            {
                pciGroup = (CGroup *) Pdoc()->LpciGroups().GetNext(pos);
                ASSERT_VALID(pciGroup);
                pmenu->InsertMenu(
                            imenu++,
                            MF_BYPOSITION,
                            idMenu,
                            pciGroup->StrName()
                            );
            } // for:  each group
        } // else:  move user is available

        // Enable or disable the Move menu.
        pCmdUI->m_pMenu->EnableMenuItem(
                            pCmdUI->m_nIndex,
                            MF_BYPOSITION
                            | (bEnabled ? MF_ENABLED : MF_GRAYED)
                            );
    } // else:  top-level menu is being displayed

} //*** CResource::OnUpdateMoveResource1()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateMoveResourceRest
//
//  Routine Description:
//      Determines whether menu items corresponding to
//      ID_FILE_MOVE_RESOURCE_2 through ID_FILE_MOVE_RESOURCE_20
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateMoveResourceRest(CCmdUI * pCmdUI)
{
    CString     strMenuName;

    if ((pCmdUI->m_pMenu != NULL) && (pCmdUI->m_pSubMenu == NULL))
    {
        pCmdUI->m_pMenu->GetMenuString(pCmdUI->m_nID, strMenuName, MF_BYCOMMAND);
    }

    if ((strMenuName != StrGroup())
            && ((Crs() == ClusterResourceOnline)
                    || (Crs() == ClusterResourceOffline)))
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

} //*** CResource::OnUpdateMoveResourceRest()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateDelete
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_DELETE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateDelete(CCmdUI * pCmdUI)
{
    if (Crs() != ClusterResourceStateUnknown)
    {
        pCmdUI->Enable(TRUE);
    }
    else
    {
        pCmdUI->Enable(FALSE);
    }

} //*** CResource::OnUpdateDelete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdBringOnline
//
//  Routine Description:
//      Processes the ID_FILE_BRING_ONLINE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdBringOnline(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If there are no possible owners for this resource, display a message.
    if (LpcinodePossibleOwners().GetCount() == 0)
    {
        AfxMessageBox(IDS_NO_POSSIBLE_OWNERS, MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        dwStatus = OnlineClusterResource(Hresource());
        if ((dwStatus != ERROR_SUCCESS)
                && (dwStatus != ERROR_IO_PENDING))
        {
            CNTException    nte(dwStatus, IDS_BRING_RESOURCE_ONLINE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
            nte.ReportError();
        } // if:  error bringing the resource online

        UpdateState();
    } // else:  resource has at least one possible owner

    Release();

} //*** CResource::OnCmdBringOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdTakeOffline
//
//  Routine Description:
//      Processes the ID_FILE_TAKE_OFFLINE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdTakeOffline(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If this connection was made through the cluster name and this is
    // either the cluster name resource or one of the resources on which
    // it is dependent, warn the user.
    if (!BAllowedToTakeOffline())
    {
        goto Cleanup;
    }

    dwStatus = OfflineClusterResource(Hresource());
    if ((dwStatus != ERROR_SUCCESS)
            && (dwStatus != ERROR_IO_PENDING))
    {
        CNTException    nte(dwStatus, IDS_TAKE_RESOURCE_OFFLINE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
        nte.ReportError();
    } // if:  error taking the resource offline

    UpdateState();

Cleanup:

    Release();

} //*** CResource::OnCmdTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdInitiateFailure
//
//  Routine Description:
//      Processes the ID_FILE_INITIATE_FAILURE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdInitiateFailure(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    dwStatus = FailClusterResource(Hresource());
    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException    nte(dwStatus, IDS_INIT_RESOURCE_FAILURE_ERROR, StrName(), NULL /*bAutoDelete*/);
        nte.ReportError();
    } // if:  error initiating failure

    UpdateState();

} //*** CResource::OnCmdInitiateFailure()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdMoveResource
//
//  Routine Description:
//      Processes the ID_FILE_MOVE_RESOURCE_# menu commands.
//
//  Arguments:
//      nID             [IN] Command ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdMoveResource(IN UINT nID)
{
    int         ipci;

    ASSERT(Hresource() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    ipci = (int) (nID - ID_FILE_MOVE_RESOURCE_1);
    ASSERT(ipci < Pdoc()->LpciGroups().GetCount());
    if (ipci < Pdoc()->LpciGroups().GetCount())
    {
        POSITION        pos;
        CResourceList   lpciMove;
        CString         strMsg;
        CGroup *        pciGroup;

        // Get the group.
        pos = Pdoc()->LpciGroups().FindIndex(ipci);
        ASSERT(pos != NULL);
        pciGroup = (CGroup *) Pdoc()->LpciGroups().GetAt(pos);
        ASSERT_VALID(pciGroup);

        try
        {
            // Verify that the user really wants to move this resource.
            strMsg.FormatMessage(IDS_VERIFY_MOVE_RESOURCE, StrName(), StrGroup(), pciGroup->StrName());
            if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) == IDNO)
            {
                goto Cleanup;
            }

            // Collect the list of resources which will be moved if confirmed.
            lpciMove.AddTail(this);
            CollectDependencyTree(&lpciMove);

            // If this resource is dependent on or is a dependent of any other resource,
            // display another warning message.
            if (lpciMove.GetCount() > 0)
            {
                CMoveResourcesDlg   dlg(this, &lpciMove, AfxGetMainWnd());
                if (dlg.DoModal() != IDOK)
                {
                    goto Cleanup;
                }
            } // if:  resource is dependent of another resource

            // Move the resource.
            {
                CWaitCursor wc;
                Move(pciGroup);
            } // Move the resource
        } // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    } // if:  valid index

Cleanup:

    Release();

} //*** CResource::OnCmdMoveResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdDelete
//
//  Routine Description:
//      Processes the ID_FILE_DELETE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdDelete(void)
{
    CResourceList   lpci;
    CString         strMsg;

    ASSERT(Hresource() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    try
    {
        // If this is a core resource, we can't delete it.
        if (BCore())
        {
            AfxMessageBox(IDS_CANT_DELETE_CORE_RESOURCE, MB_OK | MB_ICONSTOP);
            goto Cleanup;
        } // If this is a core resource

        // Verify that the user really wants to delete this resource.
        strMsg.FormatMessage(IDS_VERIFY_DELETE_RESOURCE, StrName());
        if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) == IDNO)
        {
            goto Cleanup;
        }

        if (Hresource() != NULL)
        {
            // Collect the list of resources which will be deleted if confirmed.
            CollectProvidesFor(&lpci, TRUE /*bFullTree*/);

            // If any of these resources are core resources, we can't
            // delete any of the resources.
            {
                POSITION    pos;
                CResource * pciRes = NULL;

                pos = lpci.GetHeadPosition();
                while (pos != NULL)
                {
                    pciRes = (CResource *) lpci.GetNext(pos);
                    ASSERT_VALID(pciRes);
                    if (pciRes->BCore())
                    {
                        AfxMessageBox(IDS_CANT_DELETE_CORE_RESOURCE, MB_OK | MB_ICONSTOP);
                        goto Cleanup;
                    } // if:  found a core resource
                    pciRes = NULL;
                } // while:  more items in the list
                if (pciRes != NULL)
                {
                    goto Cleanup;
                }
            } // Check for core resources

            // If this resource is a dependent of any other resource, display
            // another warning message.
            if (lpci.GetCount() > 0)
            {
                CDeleteResourcesDlg dlg(this, &lpci, AfxGetMainWnd());
                if (dlg.DoModal() != IDOK)
                {
                    goto Cleanup;
                }
            } // if:  resource is dependent of another resource

            // Delete the resource.
            {
                CWaitCursor wc;
                DeleteResource(lpci);
            } // Delete the resource
        } // if:  resource still exists
    } // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() != ERROR_RESOURCE_NOT_AVAILABLE)
        {
            pnte->ReportError();
        }

        pnte->Delete();
    } // catch:  CNTException
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    } // catch:  CException

Cleanup:

    Release();

} //*** CResource::OnCmdDelete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateProperties(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(TRUE);

} //*** CResource::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BDisplayProperties(IN BOOL bReadOnly)
{
    BOOL                bChanged = FALSE;
    CResourcePropSheet  sht(AfxGetMainWnd());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if (BChanged())
    {
        ReadItem();
    }

    // Display the property sheet.
    try
    {
        sht.SetReadOnly(bReadOnly);
        if (sht.BInit(this, IimgObjectType()))
        {
            bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
        }
    } // try
    catch (CException * pe)
    {
        pe->Delete();
    } // catch:  CException

    Release();
    return bChanged;

} //*** CResource::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BAllowedToTakeOffline
//
//  Routine Description:
//      Determine if this resource is allowed to be taken offline.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource is allowed to be taken offline.
//      FALSE       Resource is NOT allowed to be taken offline.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BAllowedToTakeOffline(void)
{
    BOOL    bAllowed = TRUE;

    ASSERT_VALID(Pdoc());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // Check to see if document is connected via the cluster name.
    if (Pdoc()->StrName() == Pdoc()->StrNode())
    {
        // If this is the core network name resource, we need to ask
        // the user first.
        if (   (StrRealResourceType().CompareNoCase(CLUS_RESTYPE_NAME_NETNAME) == 0)
            && BCore() )
        {
            bAllowed = FALSE;
        }
        else
        {
            CResourceList   lpci;
            CResource *     pciRes;
            POSITION        pos;

            // Collect all the resources above this resource in the
            // dependency tree.  If one of them is the cluster name
            // resource, we need to ask the user first.
            try
            {
                CollectProvidesFor(&lpci, TRUE /*bFullTree*/);
                pos = lpci.GetHeadPosition();
                while (pos != NULL)
                {
                    pciRes = (CResource *) lpci.GetNext(pos);
                    ASSERT_VALID(pciRes);

                    if (   (pciRes->StrRealResourceType().CompareNoCase(CLUS_RESTYPE_NAME_NETNAME) == 0)
                        && pciRes->BCore() )
                    {
                        bAllowed = FALSE;
                    }
                } // while:  more resources in the list
            } // try
            catch (CException * pe)
            {
                pe->Delete();
            } // catch:  CException
        } // else:  not the cluster name resource
    } // if:  connected via the cluster name

    // If not allowed to take offline, ask the user to confirm.
    if (!bAllowed)
    {
        ID      id;
        CString strMsg;

        strMsg.FormatMessage(IDS_TAKE_CLUSTER_NAME_OFFLINE_QUERY, StrName(), Pdoc()->StrName());
        id = AfxMessageBox(strMsg, MB_OKCANCEL | MB_ICONEXCLAMATION);
        bAllowed = (id == IDOK);
    } // if:  not allowed to atake offline

    Release();

    return bAllowed;

} //*** CResource::BAllowedToTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CResource::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
    ASSERT(pnotify != NULL);
    ASSERT_VALID(this);

    try
    {
        switch (pnotify->m_dwFilterType)
        {
            case CLUSTER_CHANGE_RESOURCE_STATE:
                Trace(g_tagResNotify, _T("(%s) - Resource '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                UpdateState();
                break;

            case CLUSTER_CHANGE_RESOURCE_DELETED:
                Trace(g_tagResNotify, _T("(%s) - Resource '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                {
                    Delete();
                }
                break;

            case CLUSTER_CHANGE_RESOURCE_PROPERTY:
                Trace(g_tagResNotify, _T("(%s) - Resource '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (!BDeleting() && Pdoc()->BClusterAvailable())
                {
                    ReadItem();
                }
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace(g_tagResRegNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace(g_tagResRegNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace(g_tagResRegNotify, _T("(%s) - Registry value '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            default:
                Trace(g_tagResNotify, _T("(%s) - Unknown resource notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
        } // switch:  dwFilterType
    } // try
    catch (CException * pe)
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    } // catch:  CException

    delete pnotify;
    return 0;

} //*** CResource::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CResourceList & rlp)
{
    POSITION    pos;
    CResource * pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        pci = rlp.GetNext(pos);
        ASSERT_VALID(pci);
//      Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlpcires) - Deleting resource cluster item '%s' (%x)"), pci->StrName(), pci);
        pci->Delete();
    } // while:  more items in the list

} //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\resprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ResProp.h
//
//	Abstract:
//		Definition of the resource property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 16, 1996
//
//	Implementation File:
//		ResProp.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESPROP_H_
#define _RESPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _RES_H_
#include "Res.h"		// for CResource, RRA
#endif

#ifndef _NODE_H_
#include "Node.h"		// for CNodeList
#endif

#ifndef _LCPRPAGE_H_
#include "LCPrPage.h"	// for CListCtrlPairPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResourceGeneralPage;
class CResourceDependsPage;
class CResourceAdvancedPage;
class CResourcePropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CResourceGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CResourceGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CResourceGeneralPage)

// Construction
public:
	CResourceGeneralPage(void);

	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CResourceGeneralPage)
	enum { IDD = IDD_PP_RES_GENERAL };
	CEdit	m_editDesc;
	CButton	m_ckbSeparateMonitor;
	CButton	m_pbPossibleOwnersModify;
	CListBox	m_lbPossibleOwners;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strType;
	CString	m_strGroup;
	CString	m_strState;
	CString	m_strNode;
	BOOL	m_bSeparateMonitor;
	//}}AFX_DATA

	CNodeList				m_lpciPossibleOwners;

	const CNodeList &		LpciPossibleOwners(void) const	{ return m_lpciPossibleOwners; }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResourceGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResourcePropSheet *	PshtResource(void) const	{ return (CResourcePropSheet *) Psht(); }
	CResource *				PciRes(void) const			{ return (CResource *) Pci(); }

	void					FillPossibleOwners(void);

	// Generated message map functions
	//{{AFX_MSG(CResourceGeneralPage)
	afx_msg void OnModifyPossibleOwners();
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDblClkPossibleOwners();
	//}}AFX_MSG
	afx_msg void OnProperties();
	DECLARE_MESSAGE_MAP()

};  //*** class CResourceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CResourceDependsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CResourceDependsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CResourceDependsPage)

// Construction
public:
	CResourceDependsPage(void);

	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CResourceDependsPage)
	enum { IDD = IDD_PP_RES_DEPENDS };
	CButton	m_pbProperties;
	CButton	m_pbModify;
	CListCtrl	m_lcDependencies;
	//}}AFX_DATA
	CResourceList			m_lpciresAvailable;
	CResourceList			m_lpciresDependencies;

	CResourceList &			LpciresAvailable(void)		{ return m_lpciresAvailable; }
	CResourceList &			LpciresDependencies(void)	{ return m_lpciresDependencies; }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResourceDependsPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Callback Functions
protected:
	static int CALLBACK		CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);

public:
	static BOOL CALLBACK	BGetNetworkName(
								OUT WCHAR *			lpszNetName,
								IN OUT DWORD *		pcchNetName,
								IN OUT PVOID		pvContext
								);

// Implementation
protected:
	BOOL					m_bQuorumResource;

	BOOL					BQuorumResource(void) const	{ return m_bQuorumResource; }

	CResourcePropSheet *	PshtResource(void) const	{ return (CResourcePropSheet *) Psht(); }
	CResource *				PciRes(void) const			{ return (CResource *) Pci(); }

	void					FillDependencies(void);
	void					DisplayProperties(void);

	int						m_nSortDirection;
	int						m_nSortColumn;

	// Generated message map functions
	//{{AFX_MSG(CResourceDependsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnModify();
	afx_msg void OnDblClkDependsList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProperties();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnItemChangedDependsList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CResourceDependsPage

/////////////////////////////////////////////////////////////////////////////
// CResourceAdvancedPage dialog
/////////////////////////////////////////////////////////////////////////////

class CResourceAdvancedPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CResourceAdvancedPage)

// Construction
public:
	CResourceAdvancedPage(void);

	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CResourceAdvancedPage)
	enum { IDD = IDD_PP_RES_ADVANCED };
	CButton	m_ckbAffectTheGroup;
	CEdit	m_editPendingTimeout;
	CButton	m_rbDefaultLooksAlive;
	CButton	m_rbSpecifyLooksAlive;
	CButton	m_rbDefaultIsAlive;
	CButton	m_rbSpecifyIsAlive;
	CEdit	m_editLooksAlive;
	CEdit	m_editIsAlive;
	CButton	m_rbDontRestart;
	CButton	m_rbRestart;
	CEdit	m_editThreshold;
	CEdit	m_editPeriod;
	BOOL	m_bAffectTheGroup;
	int		m_nRestart;
	//}}AFX_DATA
	CRRA	m_crraRestartAction;
	DWORD	m_nThreshold;
	DWORD	m_nPeriod;
	DWORD	m_nLooksAlive;
	DWORD	m_nIsAlive;
	DWORD	m_nPendingTimeout;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResourceAdvancedPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResourcePropSheet *	PshtResource(void) const	{ return (CResourcePropSheet *) Psht(); }
	CResource *				PciRes(void) const			{ return (CResource *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CResourceAdvancedPage)
	afx_msg void OnClickedDontRestart();
	afx_msg void OnClickedRestart();
	afx_msg void OnClickedDefaultLooksAlive();
	afx_msg void OnClickedDefaultIsAlive();
	afx_msg void OnChangeLooksAlive();
	afx_msg void OnChangeIsAlive();
	virtual BOOL OnInitDialog();
	afx_msg void OnClickedSpecifyLooksAlive();
	afx_msg void OnClickedSpecifyIsAlive();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CResourceAdvancedPage

/////////////////////////////////////////////////////////////////////////////
// CResourcePropSheet
/////////////////////////////////////////////////////////////////////////////

class CResourcePropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CResourcePropSheet)

// Construction
public:
	CResourcePropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[3];

	// Pages
	CResourceGeneralPage			m_pageGeneral;
	CResourceDependsPage			m_pageDepends;
	CResourceAdvancedPage			m_pageAdvanced;

	CResourceGeneralPage &			PageGeneral(void)		{ return m_pageGeneral; }
	CResourceDependsPage &			PageDepends(void)		{ return m_pageDepends; }
	CResourceAdvancedPage &			PageAdvanced(void)		{ return m_pageAdvanced; }

public:
	CResource *						PciRes(void) const	{ return (CResource *) Pci(); }

// Operations

// Overrides
protected:
	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResourcePropSheet)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CResourcePropSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CResourcePropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _RESPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\restprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ResTProp.cpp
//
//  Abstract:
//      Implementation of the resource type property sheet and pages.
//
//  Author:
//      David Potter (davidp)   May 14, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ResTProp.h"
#include "ResType.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmap*

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResTypePropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CResTypePropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResTypePropSheet, CBasePropertySheet)
    //{{AFX_MSG_MAP(CResTypePropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypePropSheet::CResTypePropSheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResTypePropSheet::CResTypePropSheet(
    IN OUT CWnd *           pParentWnd,
    IN UINT                 iSelectPage
    )
    : CBasePropertySheet(pParentWnd, iSelectPage)
{
    m_rgpages[0] = &PageGeneral();

}  //*** CResTypePropSheet::CResTypePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypePropSheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResTypePropSheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    // Call the base class method.
    if (!CBasePropertySheet::BInit(pci, iimgIcon))
        return FALSE;

    // Set the read-only flag.
    m_bReadOnly = PciResType()->BReadOnly();

    return TRUE;

}  //*** CResTypePropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypePropSheet::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CResTypePropSheet::Ppages(void)
{
    return m_rgpages;

}  //*** CResTypePropSheet::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypePropSheet::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CResTypePropSheet::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CResTypePropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResTypeGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResTypeGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResTypeGeneralPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CResTypeGeneralPage)
    ON_EN_KILLFOCUS(IDC_PP_RESTYPE_DISPLAY_NAME, OnKillFocusDisplayName)
    ON_LBN_DBLCLK(IDC_PP_RESTYPE_POSSIBLE_OWNERS, OnDblClkPossibleOwners)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_RESTYPE_DISPLAY_NAME, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RESTYPE_DESC, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RESTYPE_LOOKS_ALIVE, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RESTYPE_IS_ALIVE, CBasePropertyPage::OnChangeCtrl)
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::CResTypeGeneralPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResTypeGeneralPage::CResTypeGeneralPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RESTYPE_GENERAL)
{
    //{{AFX_DATA_INIT(CResTypeGeneralPage)
    m_strDisplayName = _T("");
    m_strDesc = _T("");
    m_strName = _T("");
    m_strResDLL = _T("");
    m_strQuorumCapable = _T("");
    //}}AFX_DATA_INIT

}  //*** CResTypeGeneralPage::CResTypePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResTypeGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    bSuccess;

    ASSERT_KINDOF(CResTypePropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);

    if (bSuccess)
    {
        m_strDisplayName = PciResType()->StrDisplayName();
        m_strDesc = PciResType()->StrDescription();
        m_nLooksAlive = PciResType()->NLooksAlive();
        m_nIsAlive = PciResType()->NIsAlive();
        m_strName = PciResType()->StrName();
        m_strResDLL = PciResType()->StrResDLLName();
        if (PciResType()->BQuorumCapable())
            m_strQuorumCapable.LoadString(IDS_YES);
        else
            m_strQuorumCapable.LoadString(IDS_NO);

        // Duplicate the possible owners list.
        {
            POSITION        pos;
            CClusterNode *  pciNode;

            pos = PciResType()->LpcinodePossibleOwners().GetHeadPosition();
            while (pos != NULL)
            {
                pciNode = (CClusterNode *) PciResType()->LpcinodePossibleOwners().GetNext(pos);
                ASSERT_VALID(pciNode);
                m_lpciPossibleOwners.AddTail(pciNode);
            }  // while:  more nodes in the list
        }  // Duplicate the possible owners list
    } // if:  base class method was successful

    return bSuccess;

}  //*** CResTypeGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::DoDataExchange(CDataExchange * pDX)
{
    CString strValue;

    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CResTypeGeneralPage)
    DDX_Control(pDX, IDC_PP_RESTYPE_QUORUM_CAPABLE, m_editQuorumCapable);
    DDX_Control(pDX, IDC_PP_RESTYPE_RESDLL, m_editResDLL);
    DDX_Control(pDX, IDC_PP_RESTYPE_NAME, m_editName);
    DDX_Control(pDX, IDC_PP_RESTYPE_POSSIBLE_OWNERS, m_lbPossibleOwners);
    DDX_Control(pDX, IDC_PP_RESTYPE_IS_ALIVE, m_editIsAlive);
    DDX_Control(pDX, IDC_PP_RESTYPE_LOOKS_ALIVE, m_editLooksAlive);
    DDX_Control(pDX, IDC_PP_RESTYPE_DESC, m_editDesc);
    DDX_Control(pDX, IDC_PP_RESTYPE_DISPLAY_NAME, m_editDisplayName);
    DDX_Text(pDX, IDC_PP_RESTYPE_NAME, m_strName);
    DDX_Text(pDX, IDC_PP_RESTYPE_DISPLAY_NAME, m_strDisplayName);
    DDX_Text(pDX, IDC_PP_RESTYPE_DESC, m_strDesc);
    DDX_Text(pDX, IDC_PP_RESTYPE_RESDLL, m_strResDLL);
    DDX_Text(pDX, IDC_PP_RESTYPE_QUORUM_CAPABLE, m_strQuorumCapable);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BReadOnly())
        {
            DDX_Number(pDX, IDC_PP_RESTYPE_LOOKS_ALIVE, m_nLooksAlive, 10, 0xffffffff);
            DDX_Number(pDX, IDC_PP_RESTYPE_IS_ALIVE, m_nIsAlive, 10, 0xffffffff);
            DDV_RequiredText(pDX, IDC_PP_RESTYPE_DISPLAY_NAME, IDC_PP_RESTYPE_DISPLAY_NAME_LABEL, m_strDisplayName);

            try
            {
                PciResType()->ValidateCommonProperties(
                                    m_strDisplayName,
                                    m_strDesc,
                                    m_nLooksAlive,
                                    m_nIsAlive
                                    );
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                pDX->Fail();
            }  // catch:  CException
        }  // if:  not read only
    }  // if:  saving data
    else
    {
        if (PciResType()->BAvailable())
        {
            DDX_Number(pDX, IDC_PP_RESTYPE_LOOKS_ALIVE, m_nLooksAlive, CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE, CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE);
            DDX_Number(pDX, IDC_PP_RESTYPE_IS_ALIVE, m_nIsAlive, CLUSTER_RESTYPE_MINIMUM_IS_ALIVE, CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE);
        } // if:  resource type properties are available
        else
        {
            m_editLooksAlive.SetWindowText(_T(""));
            m_editIsAlive.SetWindowText(_T(""));
            m_editQuorumCapable.SetWindowText(_T(""));
        } // else:  resource type properties are NOT available
        FillPossibleOwners();
    }  // else:  setting data to dialog

}  //*** CResTypeGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::FillPossibleOwners
//
//  Routine Description:
//      Fill the Possible Owners list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::FillPossibleOwners(void)
{
    POSITION        posPci;
    CClusterNode *  pciNode;
    int             iitem;

    m_lbPossibleOwners.ResetContent();

    posPci = LpciPossibleOwners().GetHeadPosition();
    while (posPci != NULL)
    {
        pciNode = (CClusterNode *) LpciPossibleOwners().GetNext(posPci);
        iitem = m_lbPossibleOwners.AddString(pciNode->StrName());
        if (iitem >= 0)
            m_lbPossibleOwners.SetItemDataPtr(iitem, pciNode);
    }  // for:  each string in the list

}  //*** CResTypeGeneralPage::FillPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResTypeGeneralPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // Set the static edit controls ReadOnly
    m_editName.SetReadOnly(TRUE);
    m_editResDLL.SetReadOnly(TRUE);
    m_editQuorumCapable.SetReadOnly(TRUE);

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_editDisplayName.SetReadOnly(TRUE);
        m_editDesc.SetReadOnly(TRUE);
        m_editLooksAlive.SetReadOnly(TRUE);
        m_editIsAlive.SetReadOnly(TRUE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CResTypeGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnApply
//
//  Routine Description:
//      Handler for the PSN_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResTypeGeneralPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciResType()->SetCommonProperties(
                        m_strDisplayName,
                        m_strDesc,
                        m_nLooksAlive,
                        m_nIsAlive
                        );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CResTypeGeneralPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnKillFocusDisplayName
//
//  Routine Description:
//      Handler for the WM_KILLFOCUS message on the Display Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::OnKillFocusDisplayName(void)
{
    CString     strName;

    m_editDisplayName.GetWindowText(strName);
    SetObjectTitle(strName);
    Ppsht()->SetCaption(strName);

}  //*** CResTypeGeneralPage::OnKillFocusDisplayName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::OnProperties(void)
{
    int             iitem;
    CClusterNode *  pciNode;

    // Get the item with the focus.
    iitem = m_lbPossibleOwners.GetCurSel();
    ASSERT(iitem >= 0);

    if (iitem >= 0)
    {
        // Get the node pointer.
        pciNode = (CClusterNode *) m_lbPossibleOwners.GetItemDataPtr(iitem);
        ASSERT_VALID(pciNode);

        // Set properties of that item.
        if (pciNode->BDisplayProperties())
        {
        }  // if:  properties changed
    }  // if:  found an item with focus

}  //*** CResTypeGeneralPage::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListBox *      pListBox    = (CListBox *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list control, don't handle the message.
    if (pWnd == &m_lbPossibleOwners)
    {
        // Create the menu to display.
        try
        {
            pmenu = new CMenu;
            if (pmenu->CreatePopupMenu())
            {
                UINT    nFlags  = MF_STRING;

                // If there are no items in the list, disable the menu item.
                if (pListBox->GetCount() == 0)
                    nFlags |= MF_GRAYED;

                // Add the Properties item to the menu.
                strMenuName.LoadString(IDS_MENU_PROPERTIES);
                if (pmenu->AppendMenu(nFlags, ID_FILE_PROPERTIES, strMenuName))
                {
                    bHandled = TRUE;
                    if (pListBox->GetCurSel() == -1)
                        pListBox->SetCurSel(0);
                }  // if:  successfully added menu item
            }  // if:  menu created successfully
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // if:  focus is on list control

    if (bHandled)
    {
        // Display the menu.
        if (!pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        this
                        ))
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display
    else
        CBasePropertyPage::OnContextMenu(pWnd, point);

    delete pmenu;

}  //*** CResTypeGeneralPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnDblClkPossibleOwners
//
//  Routine Description:
//      Handler for the LBN_DBLCLK message on the Possible Owners listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::OnDblClkPossibleOwners(void)
{
    OnProperties();

}  //*** CResTypeGeneralPage::OnDblClkPossibleOwners()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CluAdmin.rc
//
#define IDP_OLE_INIT_FAILED             100
#define IDS_CLUADMIN_DESC               101
#define IDR_MAINFRAME                   102
#define IDR_CLUADMTYPE                  103
#define IDM_CLUSTER                     104
#define IDM_CLUSTER_POPUP               105
#define IDM_NODE                        106
#define IDM_NODE_POPUP                  107
#define IDM_GROUP                       108
#define IDM_GROUP_POPUP                 109
#define IDM_RESOURCE                    110
#define IDM_RESOURCE_POPUP              111
#define IDM_RESTYPE                     112
#define IDM_RESTYPE_POPUP               113
#define IDM_NETWORK                     114
#define IDM_NETWORK_POPUP               115
#define IDM_NETIFACE                    116
#define IDM_NETIFACE_POPUP              117
#define IDM_VIEW_POPUP                  118
#define IDM_MOVE_GROUP                  119
#define IDB_WIZ_NEW_GROUP               132
#define IDB_WIZ_NEW_RESOURCE            133
#define IDB_FOLDER_16                   140
#define IDB_FOLDER_32                   141
#define IDB_CLUSTER_16                  142
#define IDB_CLUSTER_32                  143
#define IDB_CLUSTER_64                  144
#define IDB_CLUSTER_UNKNOWN_16          145
#define IDB_CLUSTER_UNKNOWN_32          146
#define IDB_NODE_16                     147
#define IDB_NODE_32                     148
#define IDB_NODE_DOWN_16                149
#define IDB_NODE_DOWN_32                150
#define IDB_NODE_PAUSED_16              151
#define IDB_NODE_PAUSED_32              152
#define IDB_NODE_UNKNOWN_16             153
#define IDB_NODE_UNKNOWN_32             154
#define IDB_GROUP_16                    155
#define IDB_GROUP_32                    156
#define IDB_GROUP_PARTIAL_ONLINE_16     157
#define IDB_GROUP_PARTIAL_ONLINE_32     158
#define IDB_GROUP_PENDING_16            159
#define IDB_GROUP_PENDING_32            160
#define IDB_GROUP_OFFLINE_16            161
#define IDB_GROUP_OFFLINE_32            162
#define IDB_GROUP_FAILED_16             163
#define IDB_GROUP_FAILED_32             164
#define IDB_GROUP_UNKNOWN_16            165
#define IDB_GROUP_UNKNOWN_32            166
#define IDB_RES_16                      167
#define IDB_RES_32                      168
#define IDB_RES_OFFLINE_16              169
#define IDB_RES_OFFLINE_32              170
#define IDB_RES_PENDING_16              171
#define IDB_RES_PENDING_32              172
#define IDB_RES_FAILED_16               173
#define IDB_RES_FAILED_32               174
#define IDB_RES_UNKNOWN_16              175
#define IDB_RES_UNKNOWN_32              176
#define IDB_RESTYPE_16                  177
#define IDB_RESTYPE_32                  178
#define IDB_RESTYPE_UNKNOWN_16          179
#define IDB_RESTYPE_UNKNOWN_32          180
#define IDB_NETWORK_16                  181
#define IDB_NETWORK_32                  182
#define IDB_NETWORK_PARTITIONED_16      183
#define IDB_NETWORK_PARTITIONED_32      184
#define IDB_NETWORK_DOWN_16             185
#define IDB_NETWORK_DOWN_32             186
#define IDB_NETWORK_UNKNOWN_16          187
#define IDB_NETWORK_UNKNOWN_32          188
#define IDB_NETIFACE_16                 189
#define IDB_NETIFACE_32                 190
#define IDB_NETIFACE_UNREACHABLE_16     191
#define IDB_NETIFACE_UNREACHABLE_32     192
#define IDB_NETIFACE_FAILED_16          193
#define IDB_NETIFACE_FAILED_32          194
#define IDB_NETIFACE_UNKNOWN_16         195
#define IDB_NETIFACE_UNKNOWN_32         196
#define IDD_ABOUTBOX                    200
#define IDD_OPEN_CLUSTER                201
#define IDD_DELETE_RESOURCES            202
#define IDD_MOVE_RESOURCES              203
#define IDD_MODIFY_PREFERRED_OWNERS     204
#define IDD_MODIFY_POSSIBLE_OWNERS      205
#define IDD_MODIFY_DEPENDENCIES         206
#define IDD_YESTOALL                    207
#define IDD_BROWSE_CLUSTERS             208
#define IDD_PP_CLUSTER_GENERAL          220
#define IDD_PP_CLUSTER_QUORUM           221
#define IDD_PP_CLUSTER_NET_PRIORITY     222
#define IDD_PP_NODE_GENERAL             230
#define IDD_PP_GROUP_GENERAL            240
#define IDD_PP_GROUP_FAILOVER           241
#define IDD_PP_GROUP_FAILBACK           242
#define IDD_PP_RES_GENERAL              250
#define IDD_PP_RES_DEPENDS              251
#define IDD_PP_RES_ADVANCED             252
#define IDD_PP_RESTYPE_GENERAL          260
#define IDD_PP_NETWORK_GENERAL          263
#define IDD_PP_NETIFACE_GENERAL         267
#define IDD_WIZ_GROUP_NAME              270
#define IDD_WIZ_PREFERRED_OWNERS        271
#define IDD_WIZ_RESOURCE_NAME           280
#define IDD_WIZ_POSSIBLE_OWNERS         281
#define IDD_WIZ_DEPENDENCIES            282
#define IDD_TRACE_SETTINGS              300
#define IDD_BARF_SETTINGS               301
#define IDD_BARF_ALL_SETTINGS           302
#define IDD_PP_NET_GENERAL              303
#define IDD_WAIT                        304
#define IDI_PROGRESS_0                  500
#define IDI_PROGRESS_1                  501
#define IDI_PROGRESS_2                  502
#define IDI_PROGRESS_3                  503
#define IDI_PROGRESS_4                  504
#define IDI_PROGRESS_5                  505
#define IDI_PROGRESS_6                  506
#define IDI_PROGRESS_7                  507
#define IDI_PROGRESS_8                  508
#define IDI_PROGRESS_9                  509
#define IDI_PROGRESS_10                 510
#define IDI_PROGRESS_11                 511
#define IDC_ABOUT_ICON                  1001
#define IDC_ABOUT_PRODUCT_TITLE         1002
#define IDC_ABOUT_FILE_TITLE            1003
#define IDC_ABOUT_VERSION               1004
#define IDC_ABOUT_COPYRIGHT             1005
#define IDC_ABOUT_WARNING_LINE          1006
#define IDC_ABOUT_WARNING               1007
#define IDC_OCD_ACTION_LABEL            1010
#define IDC_OCD_ACTION                  1011
#define IDC_OCD_NAME_LABEL              1012
#define IDC_OCD_NAME                    1013
#define IDC_OCD_BROWSE                  1014
#define IDC_DR_LABEL_1                  1020
#define IDC_DR_RESOURCES_LIST           1021
#define IDC_DR_LABEL_2                  1022
#define IDC_MR_LABEL_1                  1030
#define IDC_MR_RESOURCES_LIST           1031
#define IDC_MR_LABEL_2                  1032
#define IDC_LCP_NOTE                    1050
#define IDC_LCP_LEFT_LABEL              1051
#define IDC_LCP_LEFT_LIST               1052
#define IDC_LCP_ADD                     1053
#define IDC_LCP_REMOVE                  1054
#define IDC_LCP_RIGHT_LABEL             1055
#define IDC_LCP_RIGHT_LIST              1056
#define IDC_LCP_MOVE_UP                 1057
#define IDC_LCP_MOVE_DOWN               1058
#define IDC_LCP_PROPERTIES              1059
#define IDC_YTA_MESSAGE                 1070
#define IDC_YTA_QUESTION                1071
#define IDC_YTA_YESTOALL                1072
#define IDC_BC_CLUSTER_LABEL            1075
#define IDC_BC_CLUSTER                  1076
#define IDC_BC_LIST                     1077
#define IDC_W_PROGRESS                  1080
#define IDC_W_MESSAGE                   1081
#define IDC_PP_TITLE                    1100
#define IDC_PP_ICON                     1101
#define IDC_PP_CLUS_NAME_LABEL          1110
#define IDC_PP_CLUS_NAME                1111
#define IDC_PP_CLUS_DESC_LABEL          1112
#define IDC_PP_CLUS_DESC                1113
#define IDC_PP_CLUS_INFO_LINE           1115
#define IDC_PP_CLUS_VENDOR_ID           1116
#define IDC_PP_CLUS_VERSION             1117
#define IDC_PP_CLUS_QUORUM_RESOURCE_LABEL 1119
#define IDC_PP_CLUS_QUORUM_RESOURCE     1120
#define IDC_PP_CLUS_QUORUM_LOGGING_GROUP 1121
#define IDC_PP_CLUS_QUORUM_PARTITION_LABEL 1122
#define IDC_PP_CLUS_QUORUM_PARTITION    1123
#define IDC_PP_CLUS_QUORUM_ROOT_PATH    1124
#define IDC_PP_CLUS_QUORUM_ROOT_PATH_LABEL 1125
#define IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE_LABEL 1126
#define IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE 1127
#define IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE_LABEL2 1128
#define IDC_PP_CLUS_PRIORITY_LIST_LABEL 1129
#define IDC_PP_CLUS_PRIORITY_LIST       1130
#define IDC_PP_CLUS_PRIORITY_UP         1131
#define IDC_PP_CLUS_PRIORITY_DOWN       1132
#define IDC_PP_CLUS_PRIORITY_NOTE       1133
#define IDC_PP_CLUS_PRIORITY_PROPERTIES 1134
#define IDC_PP_NODE_NAME_LABEL          1150
#define IDC_PP_NODE_NAME                1151
#define IDC_PP_NODE_DESC_LABEL          1152
#define IDC_PP_NODE_DESC                1153
#define IDC_PP_NODE_CURRENT_STATE_LABEL 1154
#define IDC_PP_NODE_CURRENT_STATE       1155
#define IDC_PP_NODE_VERSION             1156
#define IDC_PP_NODE_CSD_VERSION         1157
#define IDC_PP_GROUP_NAME               1200
#define IDC_PP_GROUP_NAME_LABEL         1201
#define IDC_PP_GROUP_DESC_LABEL         1202
#define IDC_PP_GROUP_DESC               1203
#define IDC_PP_GROUP_PREF_OWNERS_LABEL  1204
#define IDC_PP_GROUP_PREF_OWNERS        1205
#define IDC_PP_GROUP_PREF_OWNERS_MODIFY 1206
#define IDC_PP_GROUP_INFO_LINE          1207
#define IDC_PP_GROUP_CURRENT_STATE_LABEL 1208
#define IDC_PP_GROUP_CURRENT_STATE      1209
#define IDC_PP_GROUP_CURRENT_NODE_LABEL 1210
#define IDC_PP_GROUP_CURRENT_NODE       1211
#define IDC_PP_GROUP_FAILOVER_THRESH_LABEL 1212
#define IDC_PP_GROUP_FAILOVER_THRESH    1213
#define IDC_PP_GROUP_FAILOVER_PERIOD_LABEL 1214
#define IDC_PP_GROUP_FAILOVER_PERIOD    1215
#define IDC_PP_GROUP_FAILOVER_PERIOD_LABEL2 1216
#define IDC_PP_GROUP_AUTOFB_PREVENT     1217
#define IDC_PP_GROUP_AUTOFB_GROUP       1218
#define IDC_PP_GROUP_AUTOFB_ALLOW       1219
#define IDC_PP_GROUP_FB_IMMED           1220
#define IDC_PP_GROUP_FB_WINDOW          1221
#define IDC_PP_GROUP_FBWIN_START        1222
#define IDC_PP_GROUP_FBWIN_START_SPIN   1223
#define IDC_PP_GROUP_FB_WINDOW_LABEL1   1224
#define IDC_PP_GROUP_FBWIN_END          1225
#define IDC_PP_GROUP_FBWIN_END_SPIN     1226
#define IDC_PP_GROUP_FB_WINDOW_LABEL2   1227
#define IDC_PP_RES_NAME_LABEL           1250
#define IDC_PP_RES_NAME                 1251
#define IDC_PP_RES_DESC_LABEL           1252
#define IDC_PP_RES_DESC                 1253
#define IDC_PP_RES_POSSIBLE_OWNERS_LABEL 1254
#define IDC_PP_RES_POSSIBLE_OWNERS      1255
#define IDC_PP_RES_POSSIBLE_OWNERS_MODIFY 1256
#define IDC_PP_RES_SEPARATE_MONITOR     1257
#define IDC_PP_RES_INFO_LINE            1258
#define IDC_PP_RES_RESOURCE_TYPE_LABEL  1259
#define IDC_PP_RES_RESOURCE_TYPE        1260
#define IDC_PP_RES_GROUP_LABEL          1261
#define IDC_PP_RES_GROUP                1262
#define IDC_PP_RES_CURRENT_STATE_LABEL  1263
#define IDC_PP_RES_CURRENT_STATE        1264
#define IDC_PP_RES_CURRENT_NODE_LABEL   1265
#define IDC_PP_RES_CURRENT_NODE         1266
#define IDC_PP_RES_NOTE                 1267
#define IDC_PP_RES_DEPENDS_LIST_LABEL   1268
#define IDC_PP_RES_DEPENDS_LIST         1269
#define IDC_PP_RES_MODIFY               1270
#define IDC_PP_RES_PROPERTIES           1271
#define IDC_PP_RES_DONT_RESTART         1272
#define IDC_PP_RES_RESTART_GROUP        1273
#define IDC_PP_RES_RESTART              1274
#define IDC_PP_RES_AFFECT_THE_GROUP     1275
#define IDC_PP_RES_RESTART_THRESH_LABEL 1276
#define IDC_PP_RES_RESTART_THRESHOLD    1277
#define IDC_PP_RES_RESTART_PERIOD_LABEL 1278
#define IDC_PP_RES_RESTART_PERIOD       1279
#define IDC_PP_RES_RESTART_PERIOD_LABEL2 1280
#define IDC_PP_RES_LOOKS_ALIVE_GROUP    1281
#define IDC_PP_RES_DEFAULT_LOOKS_ALIVE  1282
#define IDC_PP_RES_SPECIFY_LOOKS_ALIVE  1283
#define IDC_PP_RES_LOOKS_ALIVE          1284
#define IDC_PP_RES_SPECIFY_LOOKS_ALIVE_LABEL 1285
#define IDC_PP_RES_IS_ALIVE_GROUP       1286
#define IDC_PP_RES_DEFAULT_IS_ALIVE     1287
#define IDC_PP_RES_SPECIFY_IS_ALIVE     1288
#define IDC_PP_RES_IS_ALIVE             1289
#define IDC_PP_RES_IS_ALIVE_LABEL       1290
#define IDC_PP_RES_PENDING_TIMEOUT_LABEL 1291
#define IDC_PP_RES_PENDING_TIMEOUT      1292
#define IDC_PP_RES_PENDING_TIMEOUT_LABEL2 1293
#define IDC_PP_RESTYPE_NAME_LABEL       1350
#define IDC_PP_RESTYPE_NAME             1351
#define IDC_PP_RESTYPE_DISPLAY_NAME_LABEL 1352
#define IDC_PP_RESTYPE_DISPLAY_NAME     1353
#define IDC_PP_RESTYPE_DESC_LABEL       1354
#define IDC_PP_RESTYPE_DESC             1355
#define IDC_PP_RESTYPE_POLLINT_GROUP    1356
#define IDC_PP_RESTYPE_LOOKS_ALIVE_LABEL 1357
#define IDC_PP_RESTYPE_LOOKS_ALIVE      1358
#define IDC_PP_RESTYPE_LOOKS_ALIVE_LABEL2 1359
#define IDC_PP_RESTYPE_IS_ALIVE_LABEL   1360
#define IDC_PP_RESTYPE_IS_ALIVE         1361
#define IDC_PP_RESTYPE_IS_ALIVE_LABEL2  1362
#define IDC_PP_RESTYPE_POSSIBLE_OWNERS_LABEL 1363
#define IDC_PP_RESTYPE_POSSIBLE_OWNERS  1364
#define IDC_PP_RESTYPE_RESDLL_LABEL     1365
#define IDC_PP_RESTYPE_RESDLL           1366
#define IDC_PP_RESTYPE_QUORUM_CAPABLE   1367
#define IDC_PP_RESTYPE_QUORUM_CAPABLE_LABEL 1368
#define IDC_PP_NET_NAME_LABEL           1370
#define IDC_PP_NET_NAME                 1371
#define IDC_PP_NET_DESC_LABEL           1372
#define IDC_PP_NET_DESC                 1373
#define IDC_PP_NET_ROLE_ENABLE_NETWORK  1374
#define IDC_PP_NET_ROLE_ALL_COMM        1375
#define IDC_PP_NET_ROLE_INTERNAL_ONLY   1376
#define IDC_PP_NET_ROLE_CLIENT_ONLY     1377
#define IDC_PP_NET_ADDRESS_LABEL        1378
#define IDC_PP_NET_ADDRESS              1379
#define IDC_PP_NET_ADDRESS_MASK_LABEL   1380
#define IDC_PP_NET_ADDRESS_MASK         1381
#define IDC_PP_NET_PRIORITY_LABEL       1382
#define IDC_PP_NET_PRIORITY             1383
#define IDC_PP_NET_CURRENT_STATE_LABEL  1384
#define IDC_PP_NET_CURRENT_STATE        1385
#define IDC_PP_NETIFACE_NODE_LABEL      1386
#define IDC_PP_NETIFACE_NODE            1387
#define IDC_PP_NETIFACE_NETWORK_LABEL   1388
#define IDC_PP_NETIFACE_NETWORK         1389
#define IDC_PP_NETIFACE_DESC_LABEL      1390
#define IDC_PP_NETIFACE_DESC            1391
#define IDC_PP_NETIFACE_ADAPTER_LABEL   1392
#define IDC_PP_NETIFACE_ADAPTER         1393
#define IDC_PP_NETIFACE_ADDRESS_LABEL   1394
#define IDC_PP_NETIFACE_ADDRESS         1395
#define IDC_PP_NETIFACE_NAME_LABEL      1396
#define IDC_PP_NETIFACE_NAME            1397
#define IDC_PP_NETIFACE_CURRENT_STATE_LABEL 1398
#define IDC_PP_NETIFACE_CURRENT_STATE   1399
#define IDC_WIZ_GRAPHIC                 1400
#define IDC_WIZ_GROUP_NAME_LABEL        1410
#define IDC_WIZ_GROUP_NAME              1411
#define IDC_WIZ_GROUP_DESC_LABEL        1412
#define IDC_WIZ_GROUP_DESC              1413
#define IDC_WIZ_GROUP_WIZ_DESC          1414
#define IDC_WIZ_GROUP_CLICK_NEXT        1415
#define IDC_WIZ_RES_NAME_LABEL          1450
#define IDC_WIZ_RES_NAME                1451
#define IDC_WIZ_RES_DESC_LABEL          1452
#define IDC_WIZ_RES_DESC                1453
#define IDC_WIZ_RES_RESTYPE_LABEL       1454
#define IDC_WIZ_RES_RESTYPE             1455
#define IDC_WIZ_RES_GROUP_LABEL         1456
#define IDC_WIZ_RES_GROUP               1457
#define IDC_WIZ_RES_SEPARATE_MONITOR    1458
#define IDC_WIZ_RES_CLICK_NEXT          1459
#define IDC_TS_LISTBOX                  2000
#define IDC_TS_TAGS_TO_DISPLAY_LABEL    2001
#define IDC_TS_TAGS_TO_DISPLAY_CB       2002
#define IDC_TS_TRACE_TO_LABEL           2003
#define IDC_TS_TRACE_TO_DEBUG           2004
#define IDC_TS_TRACE_DEBUG_BREAK        2005
#define IDC_TS_TRACE_TO_COM2            2006
#define IDC_TS_TRACE_TO_FILE            2007
#define IDC_TS_FILE                     2008
#define IDC_TS_SELECT_ALL               2009
#define IDC_TS_DEFAULT                  2010
#define IDC_BS_RESOURCE_LABEL           2020
#define IDC_BS_CURRENT_FAIL_AT_LABEL    2021
#define IDC_BS_CURRENT_COUNT_LABEL      2022
#define IDC_BS_CATEGORIES_LIST          2023
#define IDC_BS_FAIL_AT_LABEL            2024
#define IDC_BS_FAIL_AT                  2025
#define IDC_BS_CONTINUOUS               2026
#define IDC_BS_DISABLE                  2027
#define IDC_BS_GLOBAL_ENABLE            2028
#define IDC_BS_RESET_CURRENT_COUNT      2029
#define IDC_BS_RESET_ALL_COUNTS         2030
#define IDC_BAS_MAIN_LABEL              2040
#define IDC_BAS_HWND_LABEL              2041
#define IDC_BAS_HWND                    2042
#define IDC_BAS_WM_LABEL                2043
#define IDC_BAS_WM                      2044
#define IDC_BAS_WPARAM_LABEL            2045
#define IDC_BAS_WPARAM                  2046
#define IDC_BAS_LPARAM_LABEL            2047
#define IDC_BAS_LPARAM                  2049
#define IDC_BAS_MENU_ITEM               2050
#define IDC_PP_NET_ROLE_CAPTION         3017
#define ID_FILE_NEW_GROUP               32772
#define ID_FILE_NEW_RESOURCE            32773
#define ID_FILE_NEW_RESOURCE_TYPE       32774
#define ID_FILE_NEW_NODE                32775
#define ID_FILE_NEW_CLUSTER             32776
#define ID_FILE_CONFIG_APP              32777
#define ID_FILE_DELETE                  32780
#define ID_FILE_RENAME                  32781
#define ID_FILE_PROPERTIES              32782
#define ID_FILE_PAUSE_NODE              32783
#define ID_FILE_RESUME_NODE             32784
#define ID_FILE_EVICT_NODE              32785
#define ID_FILE_START_SERVICE           32786
#define ID_FILE_STOP_SERVICE            32787
#define ID_FILE_BRING_ONLINE            32788
#define ID_FILE_TAKE_OFFLINE            32789
#define ID_FILE_MOVE_GROUP              32790
#define ID_FILE_MOVE_GROUP_1            32791
#define ID_FILE_MOVE_GROUP_2            32792
#define ID_FILE_MOVE_GROUP_3            32793
#define ID_FILE_MOVE_GROUP_4            32794
#define ID_FILE_MOVE_GROUP_5            32795
#define ID_FILE_MOVE_GROUP_6            32796
#define ID_FILE_MOVE_GROUP_7            32797
#define ID_FILE_MOVE_GROUP_8            32798
#define ID_FILE_MOVE_GROUP_9            32799
#define ID_FILE_MOVE_GROUP_10           32800
#define ID_FILE_MOVE_GROUP_11           32801
#define ID_FILE_MOVE_GROUP_12           32802
#define ID_FILE_MOVE_GROUP_13           32803
#define ID_FILE_MOVE_GROUP_14           32804
#define ID_FILE_MOVE_GROUP_15           32805
#define ID_FILE_MOVE_GROUP_16           32806
#define ID_FILE_MOVE_RESOURCE_1         32807
#define ID_FILE_MOVE_RESOURCE_2         32808
#define ID_FILE_MOVE_RESOURCE_3         32809
#define ID_FILE_MOVE_RESOURCE_4         32810
#define ID_FILE_MOVE_RESOURCE_5         32811
#define ID_FILE_MOVE_RESOURCE_6         32812
#define ID_FILE_MOVE_RESOURCE_7         32813
#define ID_FILE_MOVE_RESOURCE_8         32814
#define ID_FILE_MOVE_RESOURCE_9         32815
#define ID_FILE_MOVE_RESOURCE_10        32816
#define ID_FILE_MOVE_RESOURCE_11        32817
#define ID_FILE_MOVE_RESOURCE_12        32818
#define ID_FILE_MOVE_RESOURCE_13        32819
#define ID_FILE_MOVE_RESOURCE_14        32820
#define ID_FILE_MOVE_RESOURCE_15        32821
#define ID_FILE_MOVE_RESOURCE_16        32822
#define ID_FILE_MOVE_RESOURCE_17        32823
#define ID_FILE_MOVE_RESOURCE_18        32824
#define ID_FILE_MOVE_RESOURCE_19        32825
#define ID_FILE_MOVE_RESOURCE_20        32826
#define ID_FILE_INITIATE_FAILURE        32827
#define ID_EDIT_INVERT_SELECTION        32828
#define ID_VIEW_LARGE_ICONS             32829
#define ID_VIEW_SMALL_ICONS             32830
#undef ID_VIEW_LIST
#undef ID_VIEW_DETAILS
#define ID_VIEW_LIST                    32831
#define ID_VIEW_DETAILS                 32832
#define ID_VIEW_REFRESH                 32833
#define ID_VIEW_OPTIONS                 32834
#define ID_WINDOW_CLOSE_ALL             32835
#define ID_DEBUG_TRACE_SETTINGS         32836
#define ID_OPEN_ITEM                    32837
#define ID_DEBUG_BARF_SETTINGS          32838
#define ID_DEBUG_BARF_ALL               32839
#define IDS_OPEN_CLUSTER_ERROR          40500
#define IDS_OPEN_NODE_ERROR             40501
#define IDS_OPEN_GROUP_ERROR            40502
#define IDS_OPEN_RESOURCE_ERROR         40503
#define IDS_OPEN_NETWORK_ERROR          40504
#define IDS_OPEN_NETIFACE_ERROR         40505
#define IDS_GET_CLUSTER_KEY_ERROR       40506
#define IDS_GET_NODE_KEY_ERROR          40507
#define IDS_GET_GROUP_KEY_ERROR         40508
#define IDS_GET_RESOURCE_KEY_ERROR      40509
#define IDS_GET_RESTYPE_KEY_ERROR       40510
#define IDS_GET_NETWORK_KEY_ERROR       40511
#define IDS_GET_NETIFACE_KEY_ERROR      40512
#define IDS_CLUSTER_NOTIF_REG_ERROR     40513
#define IDS_REG_NOTIF_REG_ERROR         40514
#define IDS_NODE_NOTIF_REG_ERROR        40515
#define IDS_GROUP_NOTIF_REG_ERROR       40516
#define IDS_RES_NOTIF_REG_ERROR         40517
#define IDS_RESTYPE_NOTIF_REG_ERROR     40518
#define IDS_NETWORK_NOTIF_REG_ERROR     40519
#define IDS_NETIFACE_NOTIF_REG_ERROR    40520
#define IDS_READ_CLUSTER_PROPS_ERROR    40521
#define IDS_READ_NODE_PROPS_ERROR       40522
#define IDS_READ_GROUP_PROPS_ERROR      40523
#define IDS_READ_RESOURCE_PROPS_ERROR   40524
#define IDS_READ_RESOURCE_TYPE_PROPS_ERROR 40525
#define IDS_READ_NETWORK_PROPS_ERROR    40526
#define IDS_READ_NETIFACE_PROPS_ERROR   40527
#define IDS_OPEN_CLUSTER_ENUM_ERROR     40528
#define IDS_ENUM_CLUSTER_ERROR          40529
#define IDS_ENUM_PREFERRED_OWNERS_ERROR 40530
#define IDS_ENUM_CONTAINS_ERROR         40531
#define IDS_ENUM_POSSIBLE_OWNERS_ERROR  40532
#define IDS_ENUM_DEPENDENCIES_ERROR     40533
#define IDS_ENUM_PROVIDES_FOR_ERROR     40534
#define IDS_ENUM_NETWORK_INTERFACES_ERROR 40535
#define IDS_ENUM_NETWORK_PRIORITY_ERROR 40536
#define IDS_CREATE_GROUP_ERROR          40537
#define IDS_CREATE_RESOURCE_ERROR       40538
#define IDS_DELETE_GROUP_ERROR          40539
#define IDS_DELETE_RESOURCE_ERROR       40540
#define IDS_RENAME_CLUSTER_ERROR        40541
#define IDS_RENAME_RESOURCE_ERROR       40542
#define IDS_RENAME_GROUP_ERROR          40543
#define IDS_RENAME_NETWORK_ERROR        40544
#define IDS_START_CLUSTER_SERVICE_ERROR 40545
#define IDS_STOP_CLUSTER_SERVICE_ERROR  40546
#define IDS_CANNOT_START_CLUSTER_SERVICE 40547
#define IDS_SET_QUORUM_RESOURCE_ERROR   40548
#define IDS_PAUSE_NODE_ERROR            40549
#define IDS_RESUME_NODE_ERROR           40550
#define IDS_EVICT_NODE_ERROR            40551
#define IDS_BRING_GROUP_ONLINE_ERROR    40552
#define IDS_TAKE_GROUP_OFFLINE_ERROR    40553
#define IDS_MOVE_GROUP_ERROR            40554
#define IDS_BRING_RESOURCE_ONLINE_ERROR 40555
#define IDS_TAKE_RESOURCE_OFFLINE_ERROR 40556
#define IDS_INIT_RESOURCE_FAILURE_ERROR 40557
#define IDS_MOVE_RESOURCE_ERROR         40558
#define IDS_ADD_RES_OWNER_ERROR         40559
#define IDS_REMOVE_RES_OWNER_ERROR      40560
#define IDS_ADD_DEPENDENCY_ERROR        40561
#define IDS_REMOVE_DEPENDENCY_ERROR     40562
#define IDS_LOAD_EXT_DLL_ERROR          40563
#define IDS_EXT_GET_ENTRY_POINT_ERROR   40564
#define IDS_EXT_GET_CLASS_FACTORY_ERROR 40565
#define IDS_EXT_CREATE_INSTANCE_ERROR   40566
#define IDS_EXT_GET_INTERFACE_ERROR     40567
#define IDS_EXT_INITIALIZE_ERROR        40568
#define IDS_EXT_ADD_PAGES_ERROR         40569
#define IDS_EXT_INVOKE_COMMAND_ERROR    40570
#define IDS_EXT_QUERY_CONTEXT_MENU_ERROR 40571
#define IDS_CREATE_PARAMS_KEY_ERROR     40572
#define IDS_SAME_START_AND_END          40573
#define IDS_EMPTY_RIGHT_LIST            40574
#define IDS_REMOVE_RES_OWNER_GROUP_STATE_ERROR 40575
#define IDS_NO_POSSIBLE_OWNERS_QUERY    40576
#define IDS_NO_POSSIBLE_OWNERS          40577
#define IDS_SET_GROUP_NODE_LIST_ERROR   40578
#define IDS_NO_AVAILABLE_NODES_FOR_GROUP 40579
#define IDS_CANT_MOVE_RES_DEPEND_ERROR  40580
#define IDS_NOACLEDITOR                 40581
#define IDS_CLSIDFROMSTRING_ERROR       40582
#define IDS_INSERT_MENU_ERROR           40583
#define IDS_DELETE_RESOURCE_ERROR_OFFLINE_PENDING 40584
#define IDS_CANT_MOVE_GROUP_TO_SAME_NODE 40585
#define IDS_CANT_MOVE_GROUP_TO_DOWN_NODE 40586
#define IDS_CANT_MOVE_RES_TO_GROUP      40587
#define IDS_REQUIRED_DEPENDENCY_NOT_FOUND 40588
#define IDS_APPLY_PARAM_CHANGES_ERROR   40589
#define IDS_INVALID_CLUSTER_NAME        40590
#define IDS_INVALID_CLUSTER_NAME_TOO_LONG 40591
#define IDS_INVALID_CLUSTER_NAME_INVALID_CHARS 40592
#define IDS_INVALID_CLUSTER_NAME_IN_USE 40593
#define IDS_DISPLAY_NAME_NOT_CHANGED    40594
#define IDS_LOCAL_ACCOUNTS_SPECIFIED    40595
#define IDS_NO_ACCESS_GRANTED           40596
#define IDS_QUORUM_RES_CANT_HAVE_DEPS   40597
#define IDS_RES_NOT_OWNED_BY_POSSIBLE_OWNER 40598
#define IDS_CANT_DELETE_CORE_RESOURCE   40599
#define IDS_SET_NET_PRIORITY_ERROR      40600
#define IDS_ERROR_VALIDATING_NETWORK_NAME 40601
#define IDS_INVALID_NETWORK_CONNECTION_NAME 40602
#define IDS_ERROR_MSG_ID                40609
#define IDS_CREATED_GROUP               40610
#define IDS_CREATED_RESOURCE            40611
#define IDS_CLUSTER_NOT_AVAILABLE       40612
#define IDS_VERIFY_DELETE_RESOURCE      40613
#define IDS_VERIFY_DELETE_GROUP         40614
#define IDS_VERIFY_EVICT_NODE           40616
#define IDS_START_CLUSTER_SERVICE       40617
#define IDS_GET_DISK_INFO_ERROR         40618
#define IDS_VERIFY_STOP_CLUSTER_SERVICE 40620
#define IDS_VERIFY_MOVE_GROUP           40621
#define IDS_VERIFY_MOVE_RESOURCE        40622
#define IDS_RESTART_CLUSTER_NAME        40623
#define IDS_CHANGE_RES_TYPE_NAME_EFFECT 40624
#define IDS_TAKE_CLUSTER_NAME_OFFLINE_QUERY 40625
#define IDS_GET_QUORUM_DEVICES_ERROR    40626
#define IDS_CREATE_CLUSCFGWIZ_OBJ_ERROR 40627
#define IDS_CREATE_CLUSTER_ERROR        40628
#define IDS_ADD_NODES_TO_CLUSTER_ERROR  40629
#define IDS_GET_RESOURCE_STATE_ERROR    40630
#define IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS 40631

#define IDS_WINDOW_TITLE_FORMAT         40640
#define IDS_PROPSHEET_CAPTION           40641
#define IDS_PROPSHEET_CAPTION_NEW       40642
#define IDS_OFFLINE                     40643
#define IDS_OFFLINE_PENDING             40644
#define IDS_ONLINE                      40645
#define IDS_ONLINE_PENDING              40646
#define IDS_PARTIAL_ONLINE              40647
#define IDS_FAILED                      40648
#define IDS_INITIALIZING                40649
#define IDS_PAUSED                      40650
#define IDS_DOWN                        40651
#define IDS_JOINING                     40652
#define IDS_UP                          40653
#define IDS_UNAVAILABLE                 40654
#define IDS_PARTITIONED                 40655
#define IDS_UNREACHABLE                 40656
#define IDS_UNKNOWN                     40657
#define IDS_PENDING                     40658
#define IDS_CLIENT_AND_CLUSTER          40660
#define IDS_CLIENT_ONLY                 40661
#define IDS_CLUSTER_ONLY                40662
#define IDS_DONT_USE                    40663
#define IDS_YES                         40664
#define IDS_NO                          40665
#define IDS_ABOUT_WARNING               40666
#define IDS_NEW_GROUP_TITLE             40667
#define IDS_NEW_RESOURCE_TITLE          40668
#define IDS_MENU_PROPERTIES             40670
#define IDS_MENU_WHATS_THIS             40671
#define IDS_SB_OPENING_CONNECTION       40680
#define IDS_SB_STARTING_CLUSTER_SERVICE 40681
#define IDS_SB_STARTING_SERVICE         40682
#define IDS_SB_STOPPING_SERVICE         40683
#define IDS_SB_ADDING_NODE              40684
#define IDS_SB_READING_NODE             40685
#define IDS_SB_ADDING_GROUP             40686
#define IDS_SB_READING_GROUP            40687
#define IDS_SB_ADDING_RESOURCE          40688
#define IDS_SB_READING_RESOURCE         40689
#define IDS_SB_ADDING_RESTYPE           40690
#define IDS_SB_READING_RESTYPE          40691
#define IDS_SB_ADDING_NETWORK           40692
#define IDS_SB_READING_NETWORK          40693
#define IDS_SB_ADDING_NETIFACE          40694
#define IDS_SB_READING_NETIFACE         40695
#define IDS_TREEITEM_NODES              40700
#define IDS_TREEITEM_GROUPS             40701
#define IDS_TREEITEM_RESOURCES          40703
#define IDS_TREEITEM_RESTYPES           40704
#define IDS_TREEITEM_NETWORKS           40705
#define IDS_TREEITEM_NETIFACES          40706
#define IDS_TREEITEM_ACTIVEGROUPS       40707
#define IDS_TREEITEM_ACTIVERESOURCES    40708
#define IDS_TREEITEM_PHYSDEVS           40709
#define IDS_TREEITEM_CLUSTER_CONFIG     40710
#define IDS_ITEMTYPE_CLUSTER            40720
#define IDS_ITEMTYPE_CONTAINER          40721
#define IDS_ITEMTYPE_NODE               40722
#define IDS_ITEMTYPE_GROUP              40723
#define IDS_ITEMTYPE_RESOURCE           40724
#define IDS_ITEMTYPE_RESTYPE            40725
#define IDS_ITEMTYPE_NETWORK            40726
#define IDS_ITEMTYPE_NETIFACE           40727
#define IDS_COLTEXT_NAME                40730
#define IDS_COLTEXT_TYPE                40731
#define IDS_COLTEXT_DESCRIPTION         40732
#define IDS_COLTEXT_OWNER               40733
#define IDS_COLTEXT_RESTYPE             40734
#define IDS_COLTEXT_RESDLL              40735
#define IDS_COLTEXT_EXTDLL              40736
#define IDS_COLTEXT_GROUP               40737
#define IDS_COLTEXT_RESOURCE            40738
#define IDS_COLTEXT_STATE               40739
#define IDS_COLTEXT_DISPLAY_NAME        40740
#define IDS_COLTEXT_ROLE                40741
#define IDS_COLTEXT_NODE                40742
#define IDS_COLTEXT_NETWORK             40743
#define IDS_COLTEXT_ADAPTER             40744
#define IDS_COLTEXT_ADDRESS             40745
#define IDS_COLTEXT_MASK                40746
#define IDS_RESCLASS_UNKNOWN            40750
#define IDS_RESCLASS_STORAGE            40751
#define IDS_CMDLINE_NORECONNECT         40800
#define IDS_CMDLINE_NORECON             40801
#define IDS_REGKEY_COMPANY              40850
#define IDS_VERSION_NUMBER_FORMAT       40851
#define IDS_OP_VERSION_NUMBER_FORMAT    40852
#define IDS_ACLEDIT_PERM_GEN_NO_ACCESS  40860
#define IDS_ACLEDIT_PERM_GEN_READ       40861
#define IDS_ACLEDIT_PERM_GEN_MODIFY     40862
#define IDS_ACLEDIT_PERM_GEN_ALL        40863
#define IDS_ACLEDIT_TITLE               40864
#define IDS_MENUNAME_DEFAULT_MOVE_GROUP 40870
#define IDS_OCD_CREATE_CLUSTER          40880
#define IDS_OCD_ADD_NODES               40881
#define IDS_OCD_OPEN_CONNECTION         40882
#define IDS_WAIT_TITLE                  40890
#define IDS_WAIT_FOR_OFFLINE_TITLE      40891
#define IDS_WAIT_FOR_OFFLINE_MESSAGE    40892
#define IDS_WAIT_FOR_ONLINE_TITLE       40893
#define IDS_WAIT_FOR_ONLINE_MESSAGE     40894
#define IDS_EVICT_NODE_ERROR_UNAVAILABLE 40895
#define IDS_SELECT_QUORUM_RESOURCE_ERROR 40896
#define IDS_ONLINE_QUORUM_RESOURCE_PROMPT 40897
#define IDS_CLUSTER_NOT_INSTALLED_OR_CONFIGURED 40898
#define IDS_SELECT_QUORUM_RESOURCE_PARTITION_ERROR 40899
#define IDS_MODIFY_RES_OWNER_ERROR      40900

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        352
#define _APS_NEXT_COMMAND_VALUE         32851
#define _APS_NEXT_CONTROL_VALUE         3018
#define _APS_NEXT_SYMED_VALUE           114
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\restprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ResTProp.cpp
//
//	Abstract:
//		Definition of the resource type property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESTPROP_H_
#define _RESTPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _NODE_H_
#include "Node.h"		// for CNodeList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResTypeGeneralPage;
class CResTypePropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResourceType;

/////////////////////////////////////////////////////////////////////////////
// CClusterGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CResTypeGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CResTypeGeneralPage)

// Construction
public:
	CResTypeGeneralPage(void);

	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CResTypeGeneralPage)
	enum { IDD = IDD_PP_RESTYPE_GENERAL };
	CEdit	m_editQuorumCapable;
	CEdit	m_editResDLL;
	CEdit	m_editName;
	CListBox	m_lbPossibleOwners;
	CEdit	m_editIsAlive;
	CEdit	m_editLooksAlive;
	CEdit	m_editDisplayName;
	CEdit	m_editDesc;
	CString	m_strDisplayName;
	CString	m_strDesc;
	CString	m_strName;
	CString	m_strResDLL;
	CString	m_strQuorumCapable;
	//}}AFX_DATA
	DWORD	m_nLooksAlive;
	DWORD	m_nIsAlive;

	CNodeList				m_lpciPossibleOwners;

	const CNodeList &		LpciPossibleOwners(void) const	{ return m_lpciPossibleOwners; }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResTypeGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResTypePropSheet *		PshtResType(void)	{ return (CResTypePropSheet *) Psht(); }
	CResourceType *			PciResType(void)	{ return (CResourceType *) Pci(); }

	void					FillPossibleOwners(void);

	// Generated message map functions
	//{{AFX_MSG(CResTypeGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillFocusDisplayName();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDblClkPossibleOwners();
	//}}AFX_MSG
	afx_msg void OnProperties();
	DECLARE_MESSAGE_MAP()

};  //*** class CResTypeGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CResTypePropSheet
/////////////////////////////////////////////////////////////////////////////

class CResTypePropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CResTypePropSheet)

// Construction
public:
	CResTypePropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[1];

	// Pages
	CResTypeGeneralPage				m_pageGeneral;

	CResTypeGeneralPage &			PageGeneral(void)		{ return m_pageGeneral; }

public:
	CResourceType *					PciResType(void) const	{ return (CResourceType *) Pci(); }

	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResTypePropSheet)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(CResTypePropSheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CResTypePropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _RESTPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\resprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ResProp.cpp
//
//  Abstract:
//      Implementation of the resource property sheet and pages.
//
//  Author:
//      David Potter (davidp)   May 16, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ResProp.h"
#include "Res.h"
#include "ClusDoc.h"
#include "Cluster.h"
#include "ModNodes.h"
#include "ModRes.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include "ExcOper.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResourcePropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CResourcePropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResourcePropSheet, CBasePropertySheet)
    //{{AFX_MSG_MAP(CResourcePropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePropSheet::CResourcePropSheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourcePropSheet::CResourcePropSheet(
    IN OUT CWnd *       pParentWnd,
    IN UINT             iSelectPage
    )
    : CBasePropertySheet(pParentWnd, iSelectPage)
{
    m_rgpages[0] = &PageGeneral();
    m_rgpages[1] = &PageDepends();
    m_rgpages[2] = &PageAdvanced();

}  //*** CResourcePropSheet::CResourcePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePropSheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourcePropSheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    // Call the base class method.
    if (!CBasePropertySheet::BInit(pci, iimgIcon))
        return FALSE;

    // Set the read-only flag if the handles are invalid.
    m_bReadOnly = PciRes()->BReadOnly()
                    || (PciRes()->Crs() == ClusterResourceStateUnknown);

    SetPfGetResNetName(CResourceDependsPage::BGetNetworkName, &PageDepends());

    return TRUE;

}  //*** CResourcePropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePropSheet::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CResourcePropSheet::Ppages(void)
{
    return m_rgpages;

}  //*** CResourcePropSheet::Pppges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePropSheet::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CResourcePropSheet::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CResourcePropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourceGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResourceGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResourceGeneralPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CResourceGeneralPage)
    ON_BN_CLICKED(IDC_PP_RES_POSSIBLE_OWNERS_MODIFY, OnModifyPossibleOwners)
    ON_LBN_DBLCLK(IDC_PP_RES_POSSIBLE_OWNERS, OnDblClkPossibleOwners)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_RES_NAME, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RES_DESC, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_RES_SEPARATE_MONITOR, CBasePropertyPage::OnChangeCtrl)
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::CResourceGeneralPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceGeneralPage::CResourceGeneralPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RES_GENERAL)
{
    //{{AFX_DATA_INIT(CResourceGeneralPage)
    m_strName = _T("");
    m_strDesc = _T("");
    m_strGroup = _T("");
    m_strState = _T("");
    m_strNode = _T("");
    m_bSeparateMonitor = FALSE;
    //}}AFX_DATA_INIT

}  //*** CResourceGeneralPage::CResourceGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    bSuccess;

    ASSERT_KINDOF(CResourcePropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);
    if (bSuccess)
    {
        try
        {
            m_strName = PciRes()->StrName();
            m_strDesc = PciRes()->StrDescription();
            if (PciRes()->PciResourceType() != NULL)
                m_strType = PciRes()->PciResourceType()->StrDisplayName();
            m_strGroup = PciRes()->StrGroup();
            m_strNode = PciRes()->StrOwner();
            m_bSeparateMonitor = PciRes()->BSeparateMonitor();

            // Duplicate the possible owners list.
            {
                POSITION        pos;
                CClusterNode *  pciNode;

                pos = PciRes()->LpcinodePossibleOwners().GetHeadPosition();
                while (pos != NULL)
                {
                    pciNode = (CClusterNode *) PciRes()->LpcinodePossibleOwners().GetNext(pos);
                    ASSERT_VALID(pciNode);
                    m_lpciPossibleOwners.AddTail(pciNode);
                }  // while:  more nodes in the list
            }  // Duplicate the possible owners list

            PciRes()->GetStateName(m_strState);
        } // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  //  if:  base class method was successful

    return bSuccess;

}  //*** CResourceGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CResourceGeneralPage)
    DDX_Control(pDX, IDC_PP_RES_DESC, m_editDesc);
    DDX_Control(pDX, IDC_PP_RES_SEPARATE_MONITOR, m_ckbSeparateMonitor);
    DDX_Control(pDX, IDC_PP_RES_POSSIBLE_OWNERS_MODIFY, m_pbPossibleOwnersModify);
    DDX_Control(pDX, IDC_PP_RES_POSSIBLE_OWNERS, m_lbPossibleOwners);
    DDX_Control(pDX, IDC_PP_RES_NAME, m_editName);
    DDX_Text(pDX, IDC_PP_RES_NAME, m_strName);
    DDX_Text(pDX, IDC_PP_RES_DESC, m_strDesc);
    DDX_Text(pDX, IDC_PP_RES_RESOURCE_TYPE, m_strType);
    DDX_Text(pDX, IDC_PP_RES_GROUP, m_strGroup);
    DDX_Text(pDX, IDC_PP_RES_CURRENT_STATE, m_strState);
    DDX_Text(pDX, IDC_PP_RES_CURRENT_NODE, m_strNode);
    DDX_Check(pDX, IDC_PP_RES_SEPARATE_MONITOR, m_bSeparateMonitor);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BReadOnly())
        {
            DDV_RequiredText(pDX, IDC_PP_RES_NAME, IDC_PP_RES_NAME_LABEL, m_strName);
            try
            {
                PciRes()->ValidateCommonProperties(
                                    m_strDesc,
                                    m_bSeparateMonitor,
                                    PciRes()->NLooksAlive(),
                                    PciRes()->NIsAlive(),
                                    PciRes()->CrraRestartAction(),
                                    PciRes()->NRestartThreshold(),
                                    PciRes()->NRestartPeriod(),
                                    PciRes()->NPendingTimeout()
                                    );
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                pDX->Fail();
            }  // catch:  CException

            if ((LpciPossibleOwners().GetCount() == 0))
            {
                ID id = AfxMessageBox(IDS_NO_POSSIBLE_OWNERS_QUERY, MB_YESNO | MB_ICONWARNING);
                if (id == IDNO)
                    pDX->Fail();
            }  // if:  no possible owners
        }  // if:  not read only
    }  // if:  saving data from the dialog
    else
    {
        FillPossibleOwners();
    }  // else:  setting data to the dialog

}  //*** CResourceGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::FillPossibleOwners
//
//  Routine Description:
//      Fill the Possible Owners list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::FillPossibleOwners(void)
{
    POSITION        posPci;
    CClusterNode *  pciNode;
    int             iitem;

    m_lbPossibleOwners.ResetContent();

    posPci = LpciPossibleOwners().GetHeadPosition();
    while (posPci != NULL)
    {
        pciNode = (CClusterNode *) LpciPossibleOwners().GetNext(posPci);
        iitem = m_lbPossibleOwners.AddString(pciNode->StrName());
        if (iitem >= 0)
            m_lbPossibleOwners.SetItemDataPtr(iitem, pciNode);
    }  // for:  each string in the list

}  //*** CResourceGeneralPage::FillPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceGeneralPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_editName.SetReadOnly(TRUE);
        m_editDesc.SetReadOnly(TRUE);
        m_pbPossibleOwnersModify.EnableWindow(FALSE);
        m_ckbSeparateMonitor.EnableWindow(FALSE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CResourceGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnApply
//
//  Routine Description:
//      Handler for when the Apply button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceGeneralPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciRes()->SetName(m_strName);
        PciRes()->SetPossibleOwners(LpciPossibleOwners());
        PciRes()->SetCommonProperties(
                            m_strDesc,
                            m_bSeparateMonitor,
                            PciRes()->NLooksAlive(),
                            PciRes()->NIsAlive(),
                            PciRes()->CrraRestartAction(),
                            PciRes()->NRestartThreshold(),
                            PciRes()->NRestartPeriod(),
                            PciRes()->NPendingTimeout()
                            );
    }  // try
    catch (CNTException * pnte)
    {
        pnte->ReportError();
        pnte->Delete();
        if (pnte->Sc() != ERROR_RESOURCE_PROPERTIES_STORED)
            return FALSE;
    }  // catch:  CNTException
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CResourceGeneralPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::OnProperties(void)
{
    int             iitem;
    CClusterNode *  pciNode;

    // Get the item with the focus.
    iitem = m_lbPossibleOwners.GetCurSel();
    ASSERT(iitem >= 0);

    if (iitem >= 0)
    {
        // Get the node pointer.
        pciNode = (CClusterNode *) m_lbPossibleOwners.GetItemDataPtr(iitem);
        ASSERT_VALID(pciNode);

        // Set properties of that item.
        if (pciNode->BDisplayProperties())
        {
        }  // if:  properties changed
    }  // if:  found an item with focus

}  //*** CResourceGeneralPage::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListBox *      pListBox    = (CListBox *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list control, don't handle the message.
    if ( pWnd == &m_lbPossibleOwners )
    {
        // Create the menu to display.
        try
        {
            pmenu = new CMenu;
            if ( pmenu == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the menu

            if ( pmenu->CreatePopupMenu() )
            {
                UINT    nFlags  = MF_STRING;

                // If there are no items in the list, disable the menu item.
                if ( pListBox->GetCount() == 0 )
                {
                    nFlags |= MF_GRAYED;
                } // if: no items in the list

                // Add the Properties item to the menu.
                strMenuName.LoadString( IDS_MENU_PROPERTIES );
                if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
                {
                    bHandled = TRUE;
                    if ( pListBox->GetCurSel() == -1 )
                    {
                        pListBox->SetCurSel( 0 );
                    } // if: no items selected
                }  // if:  successfully added menu item
            }  // if:  menu created successfully
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // if:  focus is on list control

    if ( bHandled )
    {
        // Display the menu.
        if ( ! pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        this
                        ) )
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display
    else
    {
        CBasePropertyPage::OnContextMenu( pWnd, point );
    } // else: no menu to display

    delete pmenu;

}  //*** CResourceGeneralPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnModifyPossibleOwners
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Modify Possible Owners button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::OnModifyPossibleOwners(void)
{
    CModifyNodesDlg dlg(
                        IDD_MODIFY_POSSIBLE_OWNERS,
                        g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS,
                        m_lpciPossibleOwners,
                        PciRes()->PciResourceType()->LpcinodePossibleOwners(),
                        LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY
                        );

    if (dlg.DoModal() == IDOK)
    {
        SetModified(TRUE);
        FillPossibleOwners();
    }  // if:  OK button pressed

}  //*** CResourceGeneralPage::OnModifyPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnDblClkPossibleOwners
//
//  Routine Description:
//      Handler for the LBN_DBLCLK message on the Possible Owners listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::OnDblClkPossibleOwners(void)
{
    OnProperties();

}  //*** CResourceGeneralPage::OnDblClkPossibleOwners()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourceDependsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResourceDependsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResourceDependsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CResourceDependsPage)
    ON_BN_CLICKED(IDC_PP_RES_MODIFY, OnModify)
    ON_NOTIFY(NM_DBLCLK, IDC_PP_RES_DEPENDS_LIST, OnDblClkDependsList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_PP_RES_DEPENDS_LIST, OnColumnClick)
    ON_BN_CLICKED(IDC_PP_RES_PROPERTIES, OnProperties)
    ON_WM_CONTEXTMENU()
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_PP_RES_DEPENDS_LIST, OnItemChangedDependsList)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::CResourceDependsPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceDependsPage::CResourceDependsPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RES_DEPENDS)

{
    //{{AFX_DATA_INIT(CResourceDependsPage)
    //}}AFX_DATA_INIT

    m_bQuorumResource = FALSE;

}  //*** CResourceDependsPage::CResourceDependsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceDependsPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL            bSuccess;

    ASSERT_KINDOF(CResourcePropSheet, psht);

    // Call the base class to do base-level initialization.
    // NOTE:  MUST BE DONE BEFORE ACCESSING THE SHEET.
    bSuccess = CBasePropertyPage::BInit(psht);
    if (bSuccess)
    {
        try
        {
            // Duplicate the dependencies list.
            {
                POSITION        pos;
                CResource *     pciRes;

                pos = PciRes()->LpciresDependencies().GetHeadPosition();
                while (pos != NULL)
                {
                    pciRes = (CResource *) PciRes()->LpciresDependencies().GetNext(pos);
                    ASSERT_VALID(pciRes);
                    m_lpciresDependencies.AddTail(pciRes);
                }  // while:  more nodes in the list
            }  // Duplicate the dependencies list

            // Create the list of resources on which this resource can be dependent.
            {
                POSITION                posPci;
                CResource *             pciRes;
                CResourceList &         rlpciResources      = PciRes()->Pdoc()->LpciResources();

                LpciresAvailable().RemoveAll();

                posPci = rlpciResources.GetHeadPosition();
                while (posPci != NULL)
                {
                    // Get the cluster item pointer.
                    pciRes = (CResource *) rlpciResources.GetNext(posPci);
                    ASSERT_VALID(pciRes);

                    // If we CAN be dependent on this resource, add it to our Available list.
                    if (PciRes()->BCanBeDependent(pciRes)
                            || PciRes()->BIsDependent(pciRes))
                        LpciresAvailable().AddTail(pciRes);
                }  // while:  more items in the list
            }  // Create the list of resources on which this resource can be dependent

            // Determine if we are the quorum resource.
            m_bQuorumResource = (PciRes()->StrName() == PciRes()->Pdoc()->PciCluster()->StrQuorumResource());
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  //  if:  base class method was successful

    return bSuccess;

}  //*** CResourceDependsPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CResourceDependsPage)
    DDX_Control(pDX, IDC_PP_RES_PROPERTIES, m_pbProperties);
    DDX_Control(pDX, IDC_PP_RES_MODIFY, m_pbModify);
    DDX_Control(pDX, IDC_PP_RES_DEPENDS_LIST, m_lcDependencies);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
    }  // if:  saving data from the dialog
    else
    {
        FillDependencies();
    }  // else:  setting data to the dialog

}  //*** CResourceDependsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::FillDependencies
//
//  Routine Description:
//      Fill the Possible Owners list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::FillDependencies(void)
{
    POSITION        pos;
    int             iitem;
    int             nitem;
    CResource *     pciRes;

    m_lcDependencies.DeleteAllItems();

    pos = LpciresDependencies().GetHeadPosition();
    for (iitem = 0 ; pos != NULL ; iitem++)
    {
        pciRes = (CResource *) LpciresDependencies().GetNext(pos);
        ASSERT_VALID(pciRes);
        nitem = m_lcDependencies.InsertItem(iitem, pciRes->StrName(), pciRes->IimgObjectType());
        m_lcDependencies.SetItemText(nitem, 1, pciRes->StrRealResourceTypeDisplayName());
        m_lcDependencies.SetItemData(nitem, (DWORD_PTR) pciRes);
    }  // for:  each string in the list

    // Sort the items.
    m_nSortColumn = 0;
    m_nSortDirection = 0;
    m_lcDependencies.SortItems(CompareItems, (LPARAM) this);

    // If there are any items, set the focus on the first one.
    if (m_lcDependencies.GetItemCount() != 0)
        m_lcDependencies.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);

}  //*** CResourceDependsPage::FillDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceDependsPage::OnInitDialog(void)
{
    // Call the base class method.
    CBasePropertyPage::OnInitDialog();

    // Enable the Properties button by default.
    m_pbProperties.EnableWindow(FALSE);

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        dwExtendedStyle = (DWORD)m_lcDependencies.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcDependencies.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    // Set the image list for the list control to use.
    m_lcDependencies.SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_SMALL);

    // Add the columns.
    {
        CString         strColumn;

        try
        {
            strColumn.LoadString(IDS_COLTEXT_NAME);
            m_lcDependencies.InsertColumn(0, strColumn, LVCFMT_LEFT, COLI_WIDTH_NAME * 3 / 2);
            strColumn.LoadString(IDS_COLTEXT_RESTYPE);
            m_lcDependencies.InsertColumn(1, strColumn, LVCFMT_LEFT, COLI_WIDTH_RESTYPE * 3 / 2);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // Add the columns

    // Fill the list control.
    FillDependencies();

    if (BReadOnly())
    {
        m_pbModify.EnableWindow(FALSE);
    }  // if:  read-only page

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CResourceDependsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnApply
//
//  Routine Description:
//      Handler for the PSM_APPLY message, which is sent when the Apply
//      button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceDependsPage::OnApply(void)
{
    ASSERT(!BReadOnly());

    // Check to see if required dependencies have been made.
    {
        CString     strMissing;
        CString     strMsg;

        try
        {
            if (!PciRes()->BRequiredDependenciesPresent(LpciresDependencies(), strMissing))
            {
                strMsg.FormatMessage(IDS_REQUIRED_DEPENDENCY_NOT_FOUND, strMissing);
                AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
                return FALSE;
            }  // if:  all required dependencies not present
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            return FALSE;
        }  // catch:  CException
    }  // Check to see if required dependencies have been made

    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciRes()->SetDependencies(LpciresDependencies());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CResourceDependsPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnModify
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Modify button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnModify(void)
{
    CModifyResourcesDlg dlg(
                            IDD_MODIFY_DEPENDENCIES,
                            g_aHelpIDs_IDD_MODIFY_DEPENDENCIES,
                            m_lpciresDependencies,
                            m_lpciresAvailable,
                            LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY
                            );

    ASSERT(!BReadOnly());

    // If this is the quorum resource, display an error message.
    if (BQuorumResource())
    {
        AfxMessageBox(IDS_QUORUM_RES_CANT_HAVE_DEPS);
    }  // if:  this is the quorum resource
    else
    {
        if (dlg.DoModal() == IDOK)
        {
            SetModified(TRUE);
            FillDependencies();
        }  // if:  OK button pressed
    }  // else:  not the quorum resource

}  //*** CResourceDependsPage::OnModify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnProperties(void)
{
    DisplayProperties();

}  //*** CResourceDependsPage::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnItemChangedDependsList
//
//  Routine Description:
//      Handler method for the LVN_ITEMCHANGED message in the dependencies
//      list.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnItemChangedDependsList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    // If the selection changed, enable/disable the Properties button.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                    || (pNMListView->uNewState & LVIS_SELECTED))
            && !BReadOnly())
    {
        UINT    cSelected = m_lcDependencies.GetSelectedCount();

        // If there is only one item selected, enable the Properties button.
        // Otherwise disable it.
        m_pbProperties.EnableWindow((cSelected == 1) ? TRUE : FALSE);
    }  // if:  selection changed

    *pResult = 0;

}  //*** CResourceDependsPage::OnItemChangedDependsList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListCtrl *     pListCtrl   = (CListCtrl *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list control, don't handle the message.
    if (pWnd == &m_lcDependencies)
    {
        // Create the menu to display.
        try
        {
            pmenu = new CMenu;
            if ( pmenu == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the menu

            if ( pmenu->CreatePopupMenu() )
            {
                UINT    nFlags  = MF_STRING;

                // If there are no items in the list, disable the menu item.
                if ( pListCtrl->GetItemCount() == 0 )
                {
                    nFlags |= MF_GRAYED;
                } // if: no items in the list

                // Add the Properties item to the menu.
                strMenuName.LoadString( IDS_MENU_PROPERTIES );
                if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
                {
                    bHandled = TRUE;
                    if ( ( pListCtrl->GetItemCount() != 0 )
                      && ( pListCtrl->GetNextItem( -1, LVNI_FOCUSED ) == -1 ) )
                    {
                        pListCtrl->SetItemState( 0, LVNI_FOCUSED, LVNI_FOCUSED );
                    } // if: no item selected
                }  // if:  successfully added menu item
            }  // if:  menu created successfully
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // if:  focus is on the list control

    if ( bHandled )
    {
        // Display the menu.
        if ( ! pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        this
                        ) )
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display
    else
    {
        CBasePropertyPage::OnContextMenu( pWnd, point );
    } // else: no menu to display

    delete pmenu;

}  //*** CResourceDependsPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnDblClkDependsList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnDblClkDependsList(NMHDR * pNMHDR, LRESULT * pResult)
{
    DisplayProperties();
    *pResult = 0;

}  //*** CResourceDependsPage::OnDblClkDependsList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnColumnClick
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnColumnClick(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    if (m_lcDependencies.GetItemCount() != 0)
    {
        // Save the current sort column and direction.
        if (pNMListView->iSubItem == m_nSortColumn)
            m_nSortDirection ^= -1;
        else
        {
            m_nSortColumn = pNMListView->iSubItem;
            m_nSortDirection = 0;
        }  // else:  different column

        // Sort the list.
        m_lcDependencies.SortItems(CompareItems, (LPARAM) this);
    }  // if:  there are items in the list

    *pResult = 0;

}  //*** CResourceDependsPage::OnColumnClick()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CResourceDependsPage::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CResource *         pciRes1 = (CResource *) lparam1;
    CResource *         pciRes2 = (CResource *) lparam2;
    CResourceDependsPage *  ppage   = (CResourceDependsPage *) lparamSort;
    const CString *     pstr1;
    const CString *     pstr2;
    int                 nResult;

    ASSERT_VALID(pciRes1);
    ASSERT_VALID(pciRes2);
    ASSERT_VALID(ppage);

    // Get the strings from the list items.
    if (ppage->m_nSortColumn == 1)
    {
        pstr1 = &pciRes1->StrRealResourceTypeDisplayName();
        pstr2 = &pciRes2->StrRealResourceTypeDisplayName();
    }  //  if:  sorting on name column
    else
    {
        pstr1 = &pciRes1->StrName();
        pstr2 = &pciRes2->StrName();
    }  // else:  sorting on resource type column

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                *pstr1,
                pstr1->GetLength(),
                *pstr2,
                pstr2->GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (ppage->m_nSortDirection != 0)
        nResult = -nResult;

    return nResult;

}  //*** CResourceDependsPage::CompareItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::DisplayProperties
//
//  Routine Description:
//      Display properties of the item with the focus.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::DisplayProperties()
{
    int             iitem;
    CResource *     pciRes;

    // Get the item with the focus.
    iitem = m_lcDependencies.GetNextItem(-1, LVNI_FOCUSED);
    ASSERT(iitem != -1);

    if (iitem != -1)
    {
        // Get the resource pointer.
        pciRes = (CResource *) m_lcDependencies.GetItemData(iitem);
        ASSERT_VALID(pciRes);

        // Set properties of that item.
        if (pciRes->BDisplayProperties())
        {
            m_lcDependencies.SetItem(
                    iitem,
                    0,
                    LVIF_TEXT | LVIF_IMAGE,
                    pciRes->StrName(),
                    pciRes->IimgObjectType(),
                    0,
                    0,
                    0
                    );
            m_lcDependencies.SetItemData(iitem, (DWORD_PTR) pciRes);
            m_lcDependencies.SetItemText(iitem, 1, pciRes->StrRealResourceTypeDisplayName());
        }  // if:  properties changed
    }  // if:  found an item with focus

}  //*** CResourceDependsPage::DisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::BGetNetworkName [static]
//
//  Routine Description:
//      Get the name of a network name resource on which this resource is
//      dependent.
//
//  Arguments:
//      lpszNetName     [OUT] String in which to return the network name resource name.
//      pcchNetName     [IN OUT] Points to a variable that specifies the
//                          maximum size, in characters, of the buffer.  This
//                          value shold be large enough to contain
//                          MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//                          return it contains the actual number of characters
//                          copied.
//      pvContext       [IN OUT] Context for the operation.
//
//  Return Value:
//      TRUE        Resource is dependent on a network name resource.
//      FALSE       Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CResourceDependsPage::BGetNetworkName(
    OUT WCHAR *     lpszNetName,
    IN OUT DWORD *  pcchNetName,
    IN OUT PVOID    pvContext
    )
{
    POSITION                pos;
    CResource *             pciRes;
    CResourceDependsPage *  ppage = (CResourceDependsPage *) pvContext;

    ASSERT(lpszNetName != NULL);
    ASSERT(pcchNetName != NULL);
    ASSERT(*pcchNetName > MAX_COMPUTERNAME_LENGTH);
    ASSERT_KINDOF(CResourceDependsPage, ppage);

    pos = ppage->LpciresDependencies().GetHeadPosition();
    while (pos != NULL)
    {
        pciRes = (CResource *) ppage->LpciresDependencies().GetNext(pos);
        ASSERT_VALID(pciRes);
        if (pciRes->StrRealResourceType().CompareNoCase(RESNAME_NETWORK_NAME) == 0)
        {
            DWORD   dwStatus;
            CString strNetName;
            HRESULT hr;

            // Read the network name.
            dwStatus = pciRes->DwReadValue(REGPARAM_NAME, REGPARAM_PARAMETERS, strNetName);
            if (dwStatus != ERROR_SUCCESS)
                return FALSE;

            ASSERT(strNetName.GetLength() < (int) *pcchNetName);
            hr = StringCchCopyNW( lpszNetName, *pcchNetName, strNetName, strNetName.GetLength() );
            ASSERT( SUCCEEDED( hr ) );
            return TRUE;
        }  // if:  found a match
        else if (pciRes->BGetNetworkName(lpszNetName, pcchNetName))
            return TRUE;
    }  // while:  more items in the list

    ASSERT_VALID(ppage->PciRes());

    // If the resource has a direct dependency on a Network Name resource,
    // we need to return FALSE because the user has removed it from the
    // list here.
    pos = ppage->PciRes()->LpciresDependencies().GetHeadPosition();
    while (pos != NULL)
    {
        pciRes = (CResource *) ppage->PciRes()->LpciresDependencies().GetNext(pos);
        ASSERT_VALID(pciRes);
        if (pciRes->StrRealResourceType().CompareNoCase(RESNAME_NETWORK_NAME) == 0)
            return FALSE;
    }  // while:  more items in the list

    // There is no direct dependency on a Network Name resource.  Call
    // the API to see if there is an indirect dependency.
    return ppage->PciRes()->BGetNetworkName(lpszNetName, pcchNetName);

}  //*** CResourceDependsPage::BGetNetworkName()

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourceAdvancedPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResourceAdvancedPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResourceAdvancedPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CResourceAdvancedPage)
    ON_BN_CLICKED(IDC_PP_RES_DONT_RESTART, OnClickedDontRestart)
    ON_BN_CLICKED(IDC_PP_RES_RESTART, OnClickedRestart)
    ON_BN_CLICKED(IDC_PP_RES_DEFAULT_LOOKS_ALIVE, OnClickedDefaultLooksAlive)
    ON_BN_CLICKED(IDC_PP_RES_DEFAULT_IS_ALIVE, OnClickedDefaultIsAlive)
    ON_EN_CHANGE(IDC_PP_RES_LOOKS_ALIVE, OnChangeLooksAlive)
    ON_EN_CHANGE(IDC_PP_RES_IS_ALIVE, OnChangeIsAlive)
    ON_BN_CLICKED(IDC_PP_RES_SPECIFY_LOOKS_ALIVE, OnClickedSpecifyLooksAlive)
    ON_BN_CLICKED(IDC_PP_RES_SPECIFY_IS_ALIVE, OnClickedSpecifyIsAlive)
    //}}AFX_MSG_MAP
    ON_BN_CLICKED(IDC_PP_RES_AFFECT_THE_GROUP, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RES_RESTART_THRESHOLD, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RES_RESTART_PERIOD, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RES_PENDING_TIMEOUT, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_RES_SPECIFY_LOOKS_ALIVE, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_RES_SPECIFY_IS_ALIVE, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::CResourceAdvancedPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceAdvancedPage::CResourceAdvancedPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RES_ADVANCED)
{
    //{{AFX_DATA_INIT(CResourceAdvancedPage)
    m_bAffectTheGroup = FALSE;
    m_nRestart = -1;
    //}}AFX_DATA_INIT

}  //*** CResourceAdvancedPage::CResourceAdvancedPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceAdvancedPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    bSuccess;

    ASSERT_KINDOF(CResourcePropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);
    if (bSuccess)
    {
        m_crraRestartAction = PciRes()->CrraRestartAction();
        m_nRestart = 1;
        m_bAffectTheGroup = FALSE;
        if (m_crraRestartAction == ClusterResourceDontRestart)
            m_nRestart = 0;
        else if (m_crraRestartAction == ClusterResourceRestartNotify)
            m_bAffectTheGroup = TRUE;

        m_nThreshold = PciRes()->NRestartThreshold();
        m_nPeriod = PciRes()->NRestartPeriod() / 1000; // display units are seconds, stored units are milliseconds
        m_nLooksAlive = PciRes()->NLooksAlive();
        m_nIsAlive = PciRes()->NIsAlive();
        m_nPendingTimeout = PciRes()->NPendingTimeout() / 1000; // display units are seconds, stored units are milliseconds
    }  // if:  base class method was successful

    return TRUE;

}  //*** CResourceAdvancedPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CResourceAdvancedPage)
    DDX_Control(pDX, IDC_PP_RES_AFFECT_THE_GROUP, m_ckbAffectTheGroup);
    DDX_Control(pDX, IDC_PP_RES_PENDING_TIMEOUT, m_editPendingTimeout);
    DDX_Control(pDX, IDC_PP_RES_DEFAULT_LOOKS_ALIVE, m_rbDefaultLooksAlive);
    DDX_Control(pDX, IDC_PP_RES_SPECIFY_LOOKS_ALIVE, m_rbSpecifyLooksAlive);
    DDX_Control(pDX, IDC_PP_RES_DEFAULT_IS_ALIVE, m_rbDefaultIsAlive);
    DDX_Control(pDX, IDC_PP_RES_SPECIFY_IS_ALIVE, m_rbSpecifyIsAlive);
    DDX_Control(pDX, IDC_PP_RES_LOOKS_ALIVE, m_editLooksAlive);
    DDX_Control(pDX, IDC_PP_RES_IS_ALIVE, m_editIsAlive);
    DDX_Control(pDX, IDC_PP_RES_DONT_RESTART, m_rbDontRestart);
    DDX_Control(pDX, IDC_PP_RES_RESTART, m_rbRestart);
    DDX_Control(pDX, IDC_PP_RES_RESTART_THRESHOLD, m_editThreshold);
    DDX_Control(pDX, IDC_PP_RES_RESTART_PERIOD, m_editPeriod);
    DDX_Check(pDX, IDC_PP_RES_AFFECT_THE_GROUP, m_bAffectTheGroup);
    DDX_Radio(pDX, IDC_PP_RES_DONT_RESTART, m_nRestart);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        CString strValue;

        if (!BReadOnly())
        {
            if (m_nRestart == 1)
            {
                DDX_Number(
                    pDX,
                    IDC_PP_RES_RESTART_THRESHOLD,
                    m_nThreshold,
                    CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD,
                    CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD
                    );
                DDX_Number(
                    pDX,
                    IDC_PP_RES_RESTART_PERIOD,
                    m_nPeriod,
                    CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,
                    CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD / 1000 // display units are seconds, stored units are milliseconds
                    );
            }  // if:  restart is enabled

            if (m_rbDefaultLooksAlive.GetCheck() == BST_CHECKED)
                m_nLooksAlive = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
            else
                DDX_Number(
                    pDX,
                    IDC_PP_RES_LOOKS_ALIVE,
                    m_nLooksAlive,
                    CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,
                    CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI
                    );

            if (m_rbDefaultIsAlive.GetCheck() == BST_CHECKED)
                m_nIsAlive = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
            else
                DDX_Number(
                    pDX,
                    IDC_PP_RES_IS_ALIVE,
                    m_nIsAlive,
                    CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,
                    CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI
                    );

            DDX_Number(
                pDX,
                IDC_PP_RES_PENDING_TIMEOUT,
                m_nPendingTimeout,
                CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,
                CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT / 1000 // display units are seconds, stored units are milliseconds
                );

            try
            {
                PciRes()->ValidateCommonProperties(
                                    PciRes()->StrDescription(),
                                    PciRes()->BSeparateMonitor(),
                                    m_nLooksAlive,
                                    m_nIsAlive,
                                    m_crraRestartAction,
                                    m_nThreshold,
                                    m_nPeriod * 1000, // display units are seconds, stored units are milliseconds
                                    m_nPendingTimeout * 1000 // display units are seconds, stored units are milliseconds
                                    );
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                pDX->Fail();
            }  // catch:  CException
        }  // if:  not read only
    }  // if:  saving data
    else
    {
        DDX_Number(
            pDX,
            IDC_PP_RES_RESTART_THRESHOLD,
            m_nThreshold,
            CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD,
            CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD
            );
        DDX_Number(
            pDX,
            IDC_PP_RES_RESTART_PERIOD,
            m_nPeriod,
            CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,
            CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD / 1000 // display units are seconds, stored units are milliseconds
            );
        if (m_nRestart == 0)
        {
            m_rbDontRestart.SetCheck(BST_CHECKED);
            m_rbRestart.SetCheck(BST_UNCHECKED);
            OnClickedDontRestart();
        }  // if:  Don't Restart selected
        else
        {
            m_rbDontRestart.SetCheck(BST_UNCHECKED);
            m_rbRestart.SetCheck(BST_CHECKED);
            OnClickedRestart();
        }  // else:  Restart selected

        if (m_nLooksAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL)
        {
            DWORD   nLooksAlive;
            
            if (PciRes()->PciResourceType() == NULL)
            {
                m_rbDefaultLooksAlive.EnableWindow(FALSE);
                m_rbSpecifyLooksAlive.EnableWindow(FALSE);
                m_editLooksAlive.EnableWindow(FALSE);
                m_editLooksAlive.SetWindowText(_T(""));
            }  // if:  no resource type
            else
            {
                ASSERT_VALID(PciRes()->PciResourceType());
                nLooksAlive = PciRes()->PciResourceType()->NLooksAlive();
                DDX_Text(pDX, IDC_PP_RES_LOOKS_ALIVE, nLooksAlive);
                m_editLooksAlive.SetReadOnly();
            }  // else:  resource type known
            m_rbDefaultLooksAlive.SetCheck(BST_CHECKED);
            m_rbSpecifyLooksAlive.SetCheck(BST_UNCHECKED);
        }  // if:  using default
        else
        {
            m_rbDefaultLooksAlive.SetCheck(BST_UNCHECKED);
            m_rbSpecifyLooksAlive.SetCheck(BST_CHECKED);
            DDX_Number(
                pDX,
                IDC_PP_RES_LOOKS_ALIVE,
                m_nLooksAlive,
                CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,
                CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI
                );
            m_editLooksAlive.SetReadOnly(FALSE);
        }  // if:  not using default

        if (m_nIsAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL)
        {
            DWORD   nIsAlive;
            
            if (PciRes()->PciResourceType() == NULL)
            {
                m_rbDefaultIsAlive.EnableWindow(FALSE);
                m_rbSpecifyIsAlive.EnableWindow(FALSE);
                m_editIsAlive.EnableWindow(FALSE);
                m_editIsAlive.SetWindowText(_T(""));
            }  // if:  no resource type
            else
            {
                ASSERT_VALID(PciRes()->PciResourceType());
                nIsAlive = PciRes()->PciResourceType()->NIsAlive();
                DDX_Text(pDX, IDC_PP_RES_IS_ALIVE, nIsAlive);
                m_editIsAlive.SetReadOnly();
            }  // else:  resource type known
            m_rbDefaultIsAlive.SetCheck(BST_CHECKED);
            m_rbSpecifyIsAlive.SetCheck(BST_UNCHECKED);
        }  // if:  using default
        else
        {
            m_rbDefaultIsAlive.SetCheck(BST_UNCHECKED);
            m_rbSpecifyIsAlive.SetCheck(BST_CHECKED);
            DDX_Number(
                pDX,
                IDC_PP_RES_IS_ALIVE,
                m_nIsAlive,
                CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,
                CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI
                );
            m_editIsAlive.SetReadOnly(FALSE);
        }  // if:  not using default

        DDX_Number(
            pDX,
            IDC_PP_RES_PENDING_TIMEOUT,
            m_nPendingTimeout,
            CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,
            CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT / 1000 // display units are seconds, stored units are milliseconds
            );
    }  // else:  not saving data

}  //*** CResourceAdvancedPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceAdvancedPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_rbDontRestart.EnableWindow(FALSE);
        m_rbRestart.EnableWindow(FALSE);
        m_ckbAffectTheGroup.EnableWindow(FALSE);
        m_editThreshold.SetReadOnly(TRUE);
        m_editPeriod.SetReadOnly(TRUE);
        m_rbDefaultLooksAlive.EnableWindow(FALSE);
        m_rbSpecifyLooksAlive.EnableWindow(FALSE);
        m_editLooksAlive.SetReadOnly(TRUE);
        m_rbDefaultIsAlive.EnableWindow(FALSE);
        m_rbSpecifyIsAlive.EnableWindow(FALSE);
        m_editIsAlive.SetReadOnly(TRUE);
        m_editPendingTimeout.SetReadOnly(TRUE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CResourceAdvancedPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnApply
//
//  Routine Description:
//      Handler for when the Apply button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceAdvancedPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        if (m_nRestart == 0)
            m_crraRestartAction = ClusterResourceDontRestart;
        else if (m_bAffectTheGroup)
            m_crraRestartAction = ClusterResourceRestartNotify;
        else
            m_crraRestartAction = ClusterResourceRestartNoNotify;

        PciRes()->SetCommonProperties(
                            PciRes()->StrDescription(),
                            PciRes()->BSeparateMonitor(),
                            m_nLooksAlive,
                            m_nIsAlive,
                            m_crraRestartAction,
                            m_nThreshold,
                            m_nPeriod * 1000, // display units are seconds, stored units are milliseconds
                            m_nPendingTimeout * 1000 // display units are seconds, stored units are milliseconds
                            );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CResourceAdvancedPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedDontRestart
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Don't Restart radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedDontRestart(void)
{
    // Disable the restart parameter controls.
    m_ckbAffectTheGroup.EnableWindow(FALSE);
    m_editThreshold.EnableWindow(FALSE);
    m_editPeriod.EnableWindow(FALSE);

    // Call the base class method if the state changed.
    if (m_nRestart != 0)
    {
        CBasePropertyPage::OnChangeCtrl();
    }  // if:  state changed

}  //*** CResourceAdvancedPage::OnClickedDontRestart()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedRestart
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Restart No Notify radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedRestart(void)
{
    // Enable the restart parameter controls.
    m_ckbAffectTheGroup.EnableWindow(TRUE);
    m_editThreshold.EnableWindow(TRUE);
    m_editPeriod.EnableWindow(TRUE);

    // Call the base class method if the state changed.
    if (m_nRestart != 1)
    {
        m_ckbAffectTheGroup.SetCheck(BST_CHECKED);
        CBasePropertyPage::OnChangeCtrl();
    }  // if:  state changed

}  //*** CResourceAdvancedPage::OnClickedRestart()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnChangeLooksAlive
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Looks Alive edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnChangeLooksAlive(void)
{
    m_rbDefaultLooksAlive.SetCheck(BST_UNCHECKED);
    m_rbSpecifyLooksAlive.SetCheck(BST_CHECKED);

    CBasePropertyPage::OnChangeCtrl();

}  //*** CResourceAdvancedPage::OnChangeLooksAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnChangeIsAlive
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Is Alive edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnChangeIsAlive(void)
{
    m_rbDefaultIsAlive.SetCheck(BST_UNCHECKED);
    m_rbSpecifyIsAlive.SetCheck(BST_CHECKED);

    CBasePropertyPage::OnChangeCtrl();

}  //*** CResourceAdvancedPage::OnChangeIsAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedDefaultLooksAlive
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Use Default Looks Alive radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedDefaultLooksAlive(void)
{
    if (m_nLooksAlive != (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL)
    {
        CString str;

        str.Format(_T("%u"), PciRes()->PciResourceType()->NLooksAlive());
        m_editLooksAlive.SetWindowText(str);

        m_rbDefaultLooksAlive.SetCheck(BST_CHECKED);
        m_rbSpecifyLooksAlive.SetCheck(BST_UNCHECKED);
        m_editLooksAlive.SetReadOnly();

        CBasePropertyPage::OnChangeCtrl();
    }  // if:  value changed

}  //*** CResourceAdvancedPage::OnClickedDefaultLooksAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedDefaultIsAlive
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Use Default Is Alive radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedDefaultIsAlive(void)
{
    if (m_nIsAlive != (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL)
    {
        CString str;

        str.Format(_T("%u"), PciRes()->PciResourceType()->NIsAlive());
        m_editIsAlive.SetWindowText(str);

        m_rbDefaultIsAlive.SetCheck(BST_CHECKED);
        m_rbSpecifyIsAlive.SetCheck(BST_UNCHECKED);
        m_editIsAlive.SetReadOnly();

        CBasePropertyPage::OnChangeCtrl();
    }  // if:  value changed

}  //*** CResourceAdvancedPage::OnClickedDefaultIsAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedSpecifyLooksAlive
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Specify Looks Alive radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedSpecifyLooksAlive(void)
{
    m_editLooksAlive.SetReadOnly(FALSE);
    CBasePropertyPage::OnChangeCtrl();

}  //*** CResourceAdvancedPage::OnClickedSpecifyLooksAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedSpecifyIsAlive
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Specify Is Alive radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedSpecifyIsAlive(void)
{
    m_editIsAlive.SetReadOnly(FALSE);
    CBasePropertyPage::OnChangeCtrl();

}  //*** CResourceAdvancedPage::OnClickedSpecifyIsAlive()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\restype.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ResType.cpp
//
//  Abstract:
//      Implementation of the CResourceType class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ResType.h"
#include "Node.h"
#include "ClusItem.inl"
#include "ResTProp.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "Cluster.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagResType( _T("Document"), _T("RESOURCE TYPE"), 0 );
CTraceTag   g_tagResTypeNotify( _T("Notify"), _T("RESTYPE NOTIFY"), 0 );
#endif

/////////////////////////////////////////////////////////////////////////////
// CResourceType
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CResourceType, CClusterItem )

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CResourceType, CClusterItem )
    //{{AFX_MSG_MAP(CResourceType)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::CResourceType
//
//  Routine Description:
//      Default construtor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceType::CResourceType( void ) : CClusterItem( NULL, IDS_ITEMTYPE_RESTYPE )
{
    m_idmPopupMenu = IDM_RESTYPE_POPUP;

    m_nLooksAlive = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
    m_nIsAlive = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;

    m_rciResClassInfo.rc = CLUS_RESCLASS_UNKNOWN;
    m_rciResClassInfo.SubClass = 0;
    m_dwCharacteristics = CLUS_CHAR_UNKNOWN;
    m_dwFlags = 0;
    m_bAvailable = FALSE;

    m_plpcinodePossibleOwners = NULL;

    m_bPossibleOwnersAreFake = FALSE;

    // Set the object type and state images.
    m_iimgObjectType = GetClusterAdminApp()->Iimg( IMGLI_RESTYPE );
    m_iimgState = m_iimgObjectType;

    // Setup the property array.
    {
        m_rgProps[ epropDisplayName ].Set( CLUSREG_NAME_RESTYPE_NAME, m_strDisplayName, m_strDisplayName );
        m_rgProps[ epropDllName ].Set( CLUSREG_NAME_RESTYPE_DLL_NAME, m_strResDLLName, m_strResDLLName );
        m_rgProps[ epropDescription ].Set( CLUSREG_NAME_RESTYPE_DESC, m_strDescription, m_strDescription );
        m_rgProps[ epropLooksAlive ].Set( CLUSREG_NAME_RESTYPE_LOOKS_ALIVE, m_nLooksAlive, m_nLooksAlive );
        m_rgProps[ epropIsAlive ].Set( CLUSREG_NAME_RESTYPE_IS_ALIVE, m_nIsAlive, m_nIsAlive );
    }  // Setup the property array

}  //*** CResourceType::CResourceType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::~CResourceType
//
//  Routine Description:
//      Destrutor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceType::~CResourceType( void )
{
    // Cleanup this object.
    Cleanup();

    delete m_plpcinodePossibleOwners;

}  //*** CResourceType::~CResourceType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::Cleanup( void )
{
    POSITION    posPci;

    // Delete the PossibleOwners list.
    if ( m_plpcinodePossibleOwners != NULL )
    {
        m_plpcinodePossibleOwners->RemoveAll();
    } // if: possible owners have been allocated

    // Remove the item from the resource type list.
    posPci = Pdoc()->LpciResourceTypes().Find( this );
    if ( posPci != NULL )
    {
        Pdoc()->LpciResourceTypes().RemoveAt( posPci );
    }  // if:  found in the document's list

}  //*** CResourceType::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from GetClusterResourceTypeKey.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::Init( IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LONG        lResult;
    CWaitCursor wc;

    ASSERT( Hkey() == NULL );

    // Call the base class method.
    CClusterItem::Init( pdoc, lpszName );

    try
    {
        // Open the resource type.
        m_hkey = GetClusterResourceTypeKey( Hcluster(), lpszName, MAXIMUM_ALLOWED );
        if ( Hkey() == NULL )
        {
            ThrowStaticException( GetLastError(), IDS_GET_RESTYPE_KEY_ERROR, lpszName );
        } // if: error getting the resource type key

        ASSERT( Pcnk() != NULL );
        Trace( g_tagClusItemNotify, _T("CResourceType::Init() - Registering for resource type notifications (%08.8x) for '%s'"), Pcnk(), StrName() );

        // Register for registry notifications.
        if ( Hkey() != NULL )
        {
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (CLUSTER_CHANGE_REGISTRY_NAME
                                    | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                    | CLUSTER_CHANGE_REGISTRY_VALUE
                                    | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                Hkey(),
                                (DWORD_PTR) Pcnk()
                                );
            if ( lResult != ERROR_SUCCESS )
            {
                dwStatus = lResult;
                ThrowStaticException( dwStatus, IDS_RESTYPE_NOTIF_REG_ERROR, lpszName );
            }  // if:  error registering for registry notifications
        }  // if:  there is a key

        // Allocate lists.
        m_plpcinodePossibleOwners = new CNodeList;
        if ( m_plpcinodePossibleOwners == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the node list

        // Read the initial state.
        UpdateState();
    }  // try
    catch ( CException * )
    {
        if ( Hkey() != NULL )
        {
            ClusterRegCloseKey( Hkey() );
            m_hkey = NULL;
        }  // if:  registry key opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CResourceType::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue() or
//                              CResourceType::ConstructResourceList().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::ReadItem( void )
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT_VALID( this );
    ASSERT( Hcluster() != NULL );

    if ( Hcluster() != NULL )
    {
        m_rgProps[ epropDisplayName ].m_value.pstr = (CString *) &m_strDisplayName;
        m_rgProps[ epropDescription ].m_value.pstr = (CString *) &m_strDescription;
        m_rgProps[ epropLooksAlive ].m_value.pdw = &m_nLooksAlive;
        m_rgProps[ epropIsAlive ].m_value.pdw = &m_nIsAlive;

        // Call the base class method.
        CClusterItem::ReadItem();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetResourceTypeProperties(
                                Hcluster(),
                                StrName(),
                                CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
                                );
            if ( dwStatus == ERROR_SUCCESS )
            {
                dwStatus = DwParseProperties( cpl );
            } // if: properties read successfully
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error reading or parsing properties
        }  // Read and parse the common properties

        // Read and parse the read-only common properties.
        if ( dwRetStatus == ERROR_SUCCESS )
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetResourceTypeProperties(
                                Hcluster(),
                                StrName(),
                                CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES
                                );
            if ( dwStatus == ERROR_SUCCESS )
            {
                dwStatus = DwParseProperties( cpl );
            } // if: properties read successfully
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error reading or parsing properties
        }  // if:  no error yet

        // Read the resource class information.
        if ( dwRetStatus == ERROR_SUCCESS )
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceTypeControl(
                            Hcluster(),
                            StrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                            NULL,
                            NULL,
                            &m_rciResClassInfo,
                            sizeof( m_rciResClassInfo ),
                            &cbReturned
                            );
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error getting class info
            else
            {
                ASSERT( cbReturned == sizeof( m_rciResClassInfo ) );
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Read the characteristics.
        if ( dwRetStatus == ERROR_SUCCESS )
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceTypeControl(
                            Hcluster(),
                            StrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS,
                            NULL,
                            NULL,
                            &m_dwCharacteristics,
                            sizeof( m_dwCharacteristics ),
                            &cbReturned
                            );
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error getting characteristics
            else
            {
                ASSERT( cbReturned == sizeof( m_dwCharacteristics ) );
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Read the flags.
        if ( dwRetStatus == ERROR_SUCCESS )
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceTypeControl(
                            Hcluster(),
                            StrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_FLAGS,
                            NULL,
                            NULL,
                            &m_dwFlags,
                            sizeof( m_dwFlags ),
                            &cbReturned
                            );
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error getting flags
            else
            {
                ASSERT( cbReturned == sizeof( m_dwFlags ) );
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Construct the list of extensions.
        ReadExtensions();

        if ( dwRetStatus == ERROR_SUCCESS )
        {
            // Construct the lists.
            CollectPossibleOwners();
        }  // if:  no error reading properties
    }  // if:  key is available

    // Set the image based on whether we were able to read the properties
    // or not.  If we weren't able to read the properties, read the display
    // name and DLL name so that we can clue the user in to the fact that
    // there is a problem.
    if ( dwRetStatus != ERROR_SUCCESS )
    {
        m_bAvailable = FALSE;
        m_iimgObjectType = GetClusterAdminApp()->Iimg( IMGLI_RESTYPE_UNKNOWN );
        if ( Hkey() != NULL )
        {
            DwReadValue( CLUSREG_NAME_RESTYPE_NAME, NULL, m_strDisplayName );
            DwReadValue( CLUSREG_NAME_RESTYPE_DLL_NAME, NULL, m_strResDLLName );
        } // if:  cluster database key is available
    } // if:  error reading properties
    else
    {
        m_bAvailable = TRUE;
        m_iimgObjectType = GetClusterAdminApp()->Iimg( IMGLI_RESTYPE );
    } // else:  no errors reading properties
    m_iimgState = m_iimgObjectType;

    // Read the initial state.
    UpdateState();

    // If any errors occurred, throw an exception.
    if ( dwRetStatus != ERROR_SUCCESS )
    {
        m_bReadOnly = TRUE;
        if ( dwRetStatus != ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND )
        {
            ThrowStaticException( dwRetStatus, IDS_READ_RESOURCE_TYPE_PROPS_ERROR, StrName() );
        } // if: error other than Resource Type Not Found occurred
    }  // if:  error reading properties

    MarkAsChanged( FALSE );

}  //*** CResourceType::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::PlstrExtensions
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CResourceType::PlstrExtensions( void ) const
{
    return &LstrCombinedExtensions();

}  //*** CResourceType::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::ReadExtensions
//
//  Routine Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::ReadExtensions( void )
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    if ( Hkey() != NULL )
    {
        // Read the Extension DLL name.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, NULL, m_lstrAdminExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            dwRetStatus = dwStatus;
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrAdminExtensions.RemoveAll();
    } // else: key is not available

    // Construct the list of extensions.
    {
        POSITION            posStr;
        const CStringList * plstr;

        ASSERT_VALID( Pdoc() );

        m_lstrCombinedExtensions.RemoveAll();

        // Add resource type-specific extensions first.
        plstr = &LstrAdminExtensions();
        posStr = plstr->GetHeadPosition();
        while ( posStr != NULL )
        {
            m_lstrCombinedExtensions.AddTail( plstr->GetNext( posStr ) );
        }  // while:  more extensions available

        // Add extensions for all resource types next.
        plstr = &Pdoc()->PciCluster()->LstrResTypeExtensions();
        posStr = plstr->GetHeadPosition();
        while ( posStr != NULL )
        {
            m_lstrCombinedExtensions.AddTail( plstr->GetNext( posStr ) );
        }  // while:  more extensions available
    }  // Construct the list of extensions

    // Loop through all the resources of this type and ask them
    // to read their extensions.
    {
        POSITION    pos;
        CResource * pciRes;

        pos = Pdoc()->LpciResources().GetHeadPosition();
        while ( pos != NULL )
        {
            pciRes = (CResource *) Pdoc()->LpciResources().GetNext( pos );
            ASSERT_VALID( pciRes );
            if ( pciRes->PciResourceType() == this )
            {
                pciRes->ReadExtensions();
            } // if: found resource of this type
        }  // while:  more resources in the list
    }  // Read resource extensions

}  //*** CResourceType::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::CollecPossibleOwners
//
//  Routine Description:
//      Construct a list of node items which are enumerable on the
//      resource type.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterResourceTypeOpenEnum() or
//                        ClusterResourceTypeEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::CollectPossibleOwners( void )
{
    DWORD           dwStatus;
    HRESTYPEENUM    hrestypeenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CClusterNode *  pciNode;
    CWaitCursor     wc;

    ASSERT_VALID( Pdoc() );
    ASSERT( Hcluster() != NULL );

    ASSERT( m_plpcinodePossibleOwners != NULL );

    // Remove the previous contents of the list.
    m_plpcinodePossibleOwners->RemoveAll();

    // Indicate that we need to re-read resource type possible owners
    // when a node comes online or is added.
    m_bPossibleOwnersAreFake = TRUE;

    if ( Hcluster() != NULL )
    {
        // Open the enumeration.
        hrestypeenum = ClusterResourceTypeOpenEnum( Hcluster(), StrName(), CLUSTER_RESOURCE_TYPE_ENUM_NODES );
        if ( hrestypeenum == NULL )
        {
            dwStatus = GetLastError();
            if ( dwStatus != ERROR_NODE_NOT_AVAILABLE )
            {
                ThrowStaticException( dwStatus, IDS_ENUM_POSSIBLE_OWNERS_ERROR, StrName() );
            } // if: error other than other node not up occurred

            // Add all nodes to the list so that the user can manipulate
            // possible owners of resources of this type.
            AddAllNodesAsPossibleOwners();

        } // if: error opening the enumeration
        else
        {
            try
            {
                // Allocate a name buffer.
                cchmacName = 128;
                pwszName = new WCHAR[ cchmacName ];
                if ( pwszName == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating the name buffer

                // Loop through the enumeration and add each dependent resource to the list.
                for ( ienum = 0 ; ; ienum++ )
                {
                    // Get the next item in the enumeration.
                    cchName = cchmacName;
                    dwStatus = ClusterResourceTypeEnum( hrestypeenum, ienum, &dwRetType, pwszName, &cchName );
                    if ( dwStatus == ERROR_MORE_DATA )
                    {
                        delete [] pwszName;
                        cchmacName = ++cchName;
                        pwszName = new WCHAR[ cchmacName];
                        if ( pwszName == NULL )
                        {
                            AfxThrowMemoryException();
                        } // if: error allocating the name buffer
                        dwStatus = ClusterResourceTypeEnum( hrestypeenum, ienum, &dwRetType, pwszName, &cchName );
                    }  // if:  name buffer was too small
                    if ( dwStatus == ERROR_NO_MORE_ITEMS )
                    {
                        break;
                    } // if: reached the end of the list
                    else if ( dwStatus != ERROR_SUCCESS )
                    {
                        ThrowStaticException( dwStatus, IDS_ENUM_POSSIBLE_OWNERS_ERROR, StrName() );
                    } // if: error getting the next item occurred

                    ASSERT( dwRetType == CLUSTER_RESOURCE_TYPE_ENUM_NODES );

                    // Find the item in the list of resources on the document.
                    pciNode = Pdoc()->LpciNodes().PciNodeFromName( pwszName );
                    ASSERT_VALID( pciNode );

                    // Add the resource to the list.
                    if ( pciNode != NULL )
                    {
                        m_plpcinodePossibleOwners->AddTail( pciNode );
                    }  // if:  found node in list

                }  // for:  each item in the resource type

                delete [] pwszName;
                ClusterResourceTypeCloseEnum( hrestypeenum );

                // Indicate that we have a real possible owners list.
                m_bPossibleOwnersAreFake = FALSE;

            }  // try
            catch ( CException * )
            {
                delete [] pwszName;
                ClusterResourceTypeCloseEnum( hrestypeenum );
                throw;
            }  // catch:  any exception
        } // else: no error opening the enumeration
    }  // if:  resource is available

}  //*** CResourceType::CollecPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::AddAllNodesAsPossibleOwners
//
//  Routine Description:
//      Add all nodes as possible owners to the specified list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::AddAllNodesAsPossibleOwners( void )
{
    POSITION        pos;
    CClusterNode *  pciNode;

    pos = Pdoc()->LpciNodes().GetHeadPosition();
    while ( pos != NULL )
    {
        pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext( pos );
        ASSERT_VALID( pciNode );
        m_plpcinodePossibleOwners->AddTail( pciNode );
    } // while: more nodes in the list

} //*** CResourceType::AddAllNodesAsPossibleOwners()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::RemoveNodeFromPossibleOwners
//
//  Routine Description:
//      Remove the passed in node from the possible owners list.
//
//  Arguments:
//      plpci       [IN OUT] List to fill.
//      pNode       [IN] The node to remove from the list
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CList.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::RemoveNodeFromPossibleOwners(
    IN OUT      CNodeList *     plpci,
    IN const    CClusterNode *  pNode
    )
{
    if ( plpci == NULL )
    {
        plpci = m_plpcinodePossibleOwners;
    } // if: plpci is NULL

    ASSERT( plpci != NULL );

    POSITION        pos;
    CClusterNode *  pnode = plpci->PciNodeFromName( pNode->StrName(), &_pos );

    if ( ( pnode != NULL ) && ( pos != NULL ) )
    {
        plpci->RemoveAt( pos );
    } // if: node was found in the list

}  //*** CResourceType::RemoveNodeFromPossibleOwners()
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::SetCommonProperties
//
//  Routine Description:
//      Set the parameters for this resource type in the cluster database.
//
//  Arguments:
//      rstrName        [IN] Display name string.
//      rstrDesc        [IN] Description string.
//      nLooksAlive     [IN] Looks Alive poll interval.
//      nIsAlive        [IN] Is Alive poll interval.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::SetCommonProperties(
    IN const CString &  rstrName,
    IN const CString &  rstrDesc,
    IN DWORD            nLooksAlive,
    IN DWORD            nIsAlive,
    IN BOOL             bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[ epropDisplayName ].m_value.pstr = (CString *) &rstrName;
    m_rgProps[ epropDescription ].m_value.pstr = (CString *) &rstrDesc;
    m_rgProps[ epropLooksAlive ].m_value.pdw = &nLooksAlive;
    m_rgProps[ epropIsAlive ].m_value.pdw = &nIsAlive;

    try
    {
        CClusterItem::SetCommonProperties( bValidateOnly );
    } // try
    catch ( CNTException * pnte )
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    } // catch: CNTException

    m_rgProps[ epropDisplayName ].m_value.pstr = (CString *) &m_strDisplayName;
    m_rgProps[ epropDescription ].m_value.pstr = (CString *) &m_strDescription;
    m_rgProps[ epropLooksAlive ].m_value.pdw = &m_nLooksAlive;
    m_rgProps[ epropIsAlive ].m_value.pdw = &m_nIsAlive;

    if ( nte.Sc() != ERROR_SUCCESS )
    {
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );
    } // if: error occurred

}  //*** CResourceType::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::DwSetCommonProperties
//
//  Routine Description:
//      Set the common properties for this resource type in the cluster database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      Any status returned by ClusterResourceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceType::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hcluster() );

    if ( ( rcpl.PbPropList() != NULL ) && ( rcpl.CbPropList() > 0 ) )
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if ( bValidateOnly )
        {
            dwControl = CLUSCTL_RESOURCE_TYPE_VALIDATE_COMMON_PROPERTIES;
        } // if: only validating the properties
        else
        {
            dwControl = CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES;
        } // else: setting the properties

        // Set private properties.
        dwStatus = ClusterResourceTypeControl(
                        Hcluster(),
                        StrName(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        static_cast< DWORD >( rcpl.CbPropList() ),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
    {
        dwStatus = ERROR_SUCCESS;
    } // if: no data to be set

    return dwStatus;

}  //*** CResourceType::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::OnFinalRelease
//
//  Routine Description:
//      Called when the last OLE reference to or from the object is released.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::OnFinalRelease( void )
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CClusterItem::OnFinalRelease();

}  //*** CResourceType::OnFinalRelease()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceType::BGetColumnData( IN COLID colid, OUT CString & rstrText )
{
    BOOL    bSuccess;

    switch ( colid )
    {
        case IDS_COLTEXT_DISPLAY_NAME:
            rstrText = StrDisplayName();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_RESDLL:
            rstrText = StrResDLLName();
            bSuccess = TRUE;
            break;
        default:
            bSuccess = CClusterItem::BGetColumnData( colid, rstrText );
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CResourceType::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::BCanBeEdited
//
//  Routine Description:
//      Determines if the resource can be renamed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource can be renamed.
//      FALSE       Resource cannot be renamed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceType::BCanBeEdited( void ) const
{
    return ! BReadOnly();

}  //*** CResourceType::BCanBeEdited()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Rename
//
//  Routine Description:
//      Rename the resource.
//
//  Arguments:
//      pszName         [IN] New name to give to the resource.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors returned from SetClusterResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::Rename( IN LPCTSTR pszName )
{
    CString     strName;

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    if ( StrDisplayName() != pszName )
    {
        ID  idReturn;

        idReturn = AfxMessageBox( IDS_CHANGE_RES_TYPE_NAME_EFFECT, MB_YESNO | MB_ICONEXCLAMATION );
        if ( idReturn != IDYES )
        {
            Release();
            ThrowStaticException( (IDS) IDS_DISPLAY_NAME_NOT_CHANGED );
        }  // if:  user doesn't want to change the name
    }  // if:  display name changed

    strName = pszName;

    SetCommonProperties( strName, m_strDescription, m_nLooksAlive, m_nIsAlive );

    Release();

}  //*** CResourceType::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::OnUpdateProperties( CCmdUI * pCmdUI )
{
    pCmdUI->Enable( TRUE );

}  //*** CResourceType::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceType::BDisplayProperties( IN BOOL bReadOnly )
{
    BOOL                bChanged = FALSE;
    CResTypePropSheet   sht( AfxGetMainWnd() );

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if ( BChanged() )
    {
        ReadItem();
    } // if: the object has changed

    // Display the property sheet.
    try
    {
        sht.SetReadOnly( bReadOnly );
        if ( sht.BInit( this, IimgObjectType() ) )
        {
            bChanged = ( ( sht.DoModal() == IDOK ) && ! bReadOnly );
        } // if: initialized successfully
    }  // try
    catch ( CException * pe )
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CResourceType::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CResourceType::OnClusterNotify( IN OUT CClusterNotify * pnotify )
{
    ASSERT( pnotify != NULL );
    ASSERT_VALID( this );

    try
    {
        switch ( pnotify->m_dwFilterType )
        {
            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace( g_tagResTypeNotify, _T("(%s) - Registry namespace '%s' changed (%s %s)"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName() );
                if ( Pdoc()->BClusterAvailable() )
                {
                    ReadItem();
                } // if: connection cluster is available
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace( g_tagResTypeNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s)"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName() );
                if ( Pdoc()->BClusterAvailable() )
                {
                    ReadItem();
                } // if: connection to cluster is available
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace( g_tagResTypeNotify, _T("(%s) - Registry value '%s' changed (%s %s)"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName() );
                if ( Pdoc()->BClusterAvailable() )
                {
                    ReadItem();
                } // if: connection to cluster is available
                break;

            default:
                Trace( g_tagResTypeNotify, _T("(%s) - Unknown resource type notification (%x) for '%s'"), Pdoc()->StrNode(), pnotify->m_dwFilterType, pnotify->m_strName );
        }  // switch:  dwFilterType
    }  // try
    catch ( CException * pe )
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    delete pnotify;
    return 0;

}  //*** CResourceType::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData( IN OUT CResourceTypeList & rlp )
{
    POSITION        pos;
    CResourceType * pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while ( pos != NULL )
    {
        pci = rlp.GetNext( pos );
        ASSERT_VALID( pci );
//      Trace( g_tagClusItemDelete, _T("DeleteAllItemData(rlpcirestype) - Deleting resource type cluster item '%s'"), pci->StrName() );
        pci->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\reswiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ResWiz.cpp
//
//  Abstract:
//      Implementation of the CCreateResourceWizard class and all pages
//      specific to a new resource wizard.
//
//  Author:
//      David Potter (davidp)   September 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ResWiz.h"
#include "ClusDoc.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include "TreeView.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateResourceWizard
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CCreateResourceWizard, CBaseWizard)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CCreateResourceWizard, CBaseWizard)
    //{{AFX_MSG_MAP(CCreateResourceWizard)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::CCreateResourceWizard
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pdoc        [IN OUT] Document in which resource is to be created.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCreateResourceWizard::CCreateResourceWizard(
    IN OUT CClusterDoc *    pdoc,
    IN OUT CWnd *           pParentWnd
    )
    : CBaseWizard(IDS_NEW_RESOURCE_TITLE, pParentWnd)
{
    ASSERT_VALID(pdoc);
    m_pdoc = pdoc;

    m_pciResType = NULL;
    m_pciGroup = NULL;
    m_pciRes = NULL;
    m_bCreated = FALSE;

    m_rgpages[0].m_pwpage = &m_pageName;
    m_rgpages[0].m_dwWizButtons = PSWIZB_NEXT;
    m_rgpages[1].m_pwpage = &m_pageOwners;
    m_rgpages[1].m_dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
    m_rgpages[2].m_pwpage = &m_pageDependencies;
    m_rgpages[2].m_dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;

}  //*** CCreateResourceWizard::CCreateResourceWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::~CCreateResourceWizard
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCreateResourceWizard::~CCreateResourceWizard(void)
{
    if (m_pciRes != NULL)
        m_pciRes->Release();
    if (m_pciResType != NULL)
        m_pciResType->Release();
    if (m_pciGroup != NULL)
        m_pciGroup->Release();

}  //*** CCreateResourceWizard::~CCreateResourceWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Wizard initialized successfully.
//      FALSE   Wizard not initialized successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCreateResourceWizard::BInit(void)
{
    // Call the base class method.
    CClusterAdminApp *  papp = GetClusterAdminApp();
    if (!CBaseWizard::BInit(papp->Iimg(IMGLI_RES)))
        return FALSE;

    // Get default group and/or resource type.
    {
        CTreeItem * pti;
        CListItem * pli;

        // Get the current MDI frame window.
        CSplitterFrame * pframe = (CSplitterFrame *) ((CFrameWnd*)AfxGetMainWnd())->GetActiveFrame();
        ASSERT_VALID(pframe);
        ASSERT_KINDOF(CSplitterFrame, pframe);

        // Get currently selected tree item and list item with focus.
        pti = pframe->PviewTree()->PtiSelected();
        pli = pframe->PviewList()->PliFocused();

        // If the currently selected item in the tree view is a group,
        // default to using that group.
        ASSERT_VALID(pti);
        ASSERT_VALID(pti->Pci());
        if (pti->Pci()->IdsType() == IDS_ITEMTYPE_GROUP)
        {
            ASSERT_KINDOF(CGroup, pti->Pci());
            m_pciGroup = (CGroup *) pti->Pci();
        }  // if:  group selected
        else
        {
            // If the item with the focus in the list control is a group,
            // default to using it.  If it is a resource, use its group.
            if (pli != NULL)
            {
                ASSERT_VALID(pli->Pci());
                if (pli->Pci()->IdsType() == IDS_ITEMTYPE_GROUP)
                {
                    ASSERT_KINDOF(CGroup, pli->Pci());
                    m_pciGroup = (CGroup *) pli->Pci();
                }  // if:  group has focus
                else if (pli->Pci()->IdsType() == IDS_ITEMTYPE_RESOURCE)
                {
                    ASSERT_KINDOF(CResource, pli->Pci());
                    m_pciGroup = ((CResource *) pli->Pci())->PciGroup();
                }  // else if:  resource has focus
            }  // if:  a list item has focus
        }  // else:  tree item not a group

        // Increment the reference count on the group.
        if (m_pciGroup != NULL)
            m_pciGroup->AddRef();

        // If a resource is selected, set the default resource type from it.
        // If a resource type is selected, set the default resource type to it.
        if (pli != NULL)
        {
            ASSERT_VALID(pli->Pci());
            if (pli->Pci()->IdsType() == IDS_ITEMTYPE_RESOURCE)
            {
                ASSERT_KINDOF(CResource, pli->Pci());
                m_pciResType = ((CResource *) pli->Pci())->PciResourceType();
            }  // if:  resource has focus
            else if (pli->Pci()->IdsType() == IDS_ITEMTYPE_RESTYPE)
            {
                ASSERT_KINDOF(CResourceType, pli->Pci());
                m_pciResType = (CResourceType *) pli->Pci();
            }  // else if:  resource type has focus
        }  // if:  a list item has focus

        // Increment the reference count on the resource type.
        if (m_pciResType != NULL)
            m_pciResType->AddRef();
    }  // // Get currently selected group

    return TRUE;

}  //*** CCreateResourceWizard::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::OnCancel
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Cancel button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCreateResourceWizard::OnCancel(void)
{
    if (BCreated())
    {
        ASSERT_VALID(PciRes());
        try
        {
            PciRes()->DeleteResource();
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
        catch (...)
        {
        }  // catch:  anything
        m_bCreated = FALSE;
    }  // if:  we created the object

}  //*** CCreateResourceWizard::OnCancel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::OnWizardFinish
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Finish button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCreateResourceWizard::OnWizardFinish(void)
{
    CResource * pciResDoc;

    ASSERT_VALID(PciRes());

    try
    {
        pciResDoc = (CResource *) Pdoc()->LpciResources().PciFromName(PciRes()->StrName());
        ASSERT_VALID(pciResDoc);
        if (pciResDoc != NULL)
            pciResDoc->ReadItem();
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

}  //*** CCreateResourceWizard::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizPage * CCreateResourceWizard::Ppages(void)
{
    return m_rgpages;

}  //*** CCreateResourceWizard::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CCreateResourceWizard::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CWizPage);

}  //*** CCreateResourceWizard::Cpages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::BSetRequiredFields
//
//  Routine Description:
//      Set the required fields of the resource, creating it if necessary.
//
//  Arguments:
//      rstrName            [IN] Name of the resource.
//      pciResType          [IN] The resource type of the resource.
//      pciGroup            [IN] The group to which the resource belongs.
//      bSeparateMonitor    [IN] TRUE = Resource runs in a separate moniotor.
//      rstrDesc            [IN] Description of the resource.
//
//  Return Value:
//      TRUE            Required fields set successfully.
//      FALSE           Error setting the required fields.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCreateResourceWizard::BSetRequiredFields(
    IN const CString &  rstrName,
    IN CResourceType *  pciResType,
    IN CGroup *         pciGroup,
    IN BOOL             bSeparateMonitor,
    IN const CString &  rstrDesc
    )
{
    BOOL        bSuccess = TRUE;
    CResource * pciResDoc;
    CWaitCursor wc;

    ASSERT(pciGroup != NULL);

    try
    {
        if (   BCreated()
            && (   (pciResType->StrName().CompareNoCase(PciRes()->StrRealResourceType()) != 0)
                || (PciRes()->PciGroup() == NULL)
                || (pciGroup->StrName().CompareNoCase(PciRes()->PciGroup()->StrName()) != 0)))
        {
            PciRes()->DeleteResource();
            m_bCreated = FALSE;
        }  // if:  object created already but resource type changed
        if (!BCreated())
        {
            // Allocate an item.
            if (PciRes() != NULL)
            {
                VERIFY(m_pciRes->Release() == 0);
            }  // if:  item already allocated
            m_pciRes = new CResource(FALSE);
            if ( m_pciRes == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the resource
            m_pciRes->AddRef();

            // Create the resource.
            PciRes()->Create(
                        Pdoc(),
                        rstrName,
                        pciResType->StrName(),
                        pciGroup->StrName(),
                        bSeparateMonitor
                        );

            // Create the resource in the document.
            pciResDoc = Pdoc()->PciAddNewResource(rstrName);
            if (pciResDoc != NULL)
                pciResDoc->SetInitializing();

            // Read the resource.
            PciRes()->ReadItem();

            // Set the description field.
            try
            {
                PciRes()->SetCommonProperties(
                            rstrDesc,
                            bSeparateMonitor,
                            PciRes()->NLooksAlive(),
                            PciRes()->NIsAlive(),
                            PciRes()->CrraRestartAction(),
                            PciRes()->NRestartThreshold(),
                            PciRes()->NRestartPeriod(),
                            PciRes()->NPendingTimeout()
                            );
            }  // try
            catch (CNTException * pnte)
            {
                if (pnte->Sc() != ERROR_RESOURCE_PROPERTIES_STORED)
                    throw;
                pnte->Delete();
            }  // catch:  CNTException

            m_strName = rstrName;
            m_strDescription = rstrDesc;
            m_bCreated = TRUE;
            m_bNeedToLoadExtensions = TRUE;
        }  // if:  object not created yet
        else
        {
            ASSERT_VALID(PciRes());

            // If the group changed, clear the dependencies.
            if (pciGroup->StrName() != PciRes()->StrGroup())
            {
                CResourceList   lpobjRes;
                PciRes()->SetDependencies(lpobjRes);
                PciRes()->SetGroup(pciGroup->StrName());
            }  // if:  group name changed

            PciRes()->SetName(rstrName);
            try
            {
                PciRes()->SetCommonProperties(
                            rstrDesc,
                            bSeparateMonitor,
                            PciRes()->NLooksAlive(),
                            PciRes()->NIsAlive(),
                            PciRes()->CrraRestartAction(),
                            PciRes()->NRestartThreshold(),
                            PciRes()->NRestartPeriod(),
                            PciRes()->NPendingTimeout()
                            );
            }  // try
            catch (CNTException * pnte)
            {
                if (pnte->Sc() != ERROR_RESOURCE_PROPERTIES_STORED)
                    throw;
                pnte->Delete();
            }  // catch:  CNTException
            m_strName = rstrName;
            m_strDescription = rstrDesc;
        }  // else:  object already exists

        // Save the resource type pointer.
        if (pciResType != m_pciResType)
        {
            pciResType->AddRef();
            if (m_pciResType != NULL)
                m_pciResType->Release();
            m_pciResType = pciResType;
        }  // if:  the resource type changed
        // Save the group pointer.
        if (pciGroup != m_pciGroup)
        {
            pciGroup->AddRef();
            if (m_pciGroup != NULL)
                m_pciGroup->Release();
            m_pciGroup = pciGroup;
        }  // if:  the group changed
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        if (PciRes() != NULL)
        {
            try
            {
                PciRes()->DeleteResource();
            }  // try
            catch (...)
            {
            }  // catch:  Anything
            VERIFY(m_pciRes->Release() == 0);
            m_pciRes = NULL;
            m_bCreated = FALSE;
        }  // if:  there is a resource
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CCreateResourceWizard::BSetRequiredFields()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewResNamePage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewResNamePage, CBaseWizardPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNewResNamePage, CBaseWizardPage)
    //{{AFX_MSG_MAP(CNewResNamePage)
    ON_EN_CHANGE(IDC_WIZ_RES_NAME, OnChangeResName)
    ON_EN_KILLFOCUS(IDC_WIZ_RES_NAME, OnKillFocusResName)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::CNewResNamePage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewResNamePage::CNewResNamePage(void)
    : CBaseWizardPage(IDD, g_aHelpIDs_IDD_WIZ_RESOURCE_NAME)
{
    //{{AFX_DATA_INIT(CNewResNamePage)
    m_strName = _T("");
    m_strDesc = _T("");
    m_strGroup = _T("");
    m_strResType = _T("");
    m_bSeparateMonitor = FALSE;
    //}}AFX_DATA_INIT

    m_pciResType = NULL;
    m_pciGroup = NULL;

}  //*** CNewResNamePage::CNewResNamePage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResNamePage::DoDataExchange(CDataExchange * pDX)
{
    CBaseWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewResNamePage)
    DDX_Control(pDX, IDC_WIZ_RES_GROUP, m_cboxGroups);
    DDX_Control(pDX, IDC_WIZ_RES_RESTYPE, m_cboxResTypes);
    DDX_Control(pDX, IDC_WIZ_RES_DESC, m_editDesc);
    DDX_Control(pDX, IDC_WIZ_RES_NAME, m_editName);
    DDX_Text(pDX, IDC_WIZ_RES_NAME, m_strName);
    DDX_Text(pDX, IDC_WIZ_RES_DESC, m_strDesc);
    DDX_CBString(pDX, IDC_WIZ_RES_GROUP, m_strGroup);
    DDX_CBString(pDX, IDC_WIZ_RES_RESTYPE, m_strResType);
    DDX_Check(pDX, IDC_WIZ_RES_SEPARATE_MONITOR, m_bSeparateMonitor);
    //}}AFX_DATA_MAP

    DDV_RequiredText(pDX, IDC_WIZ_RES_NAME, IDC_WIZ_RES_NAME_LABEL, m_strName);

    if (pDX->m_bSaveAndValidate)
    {
        int     icbi;

        icbi = m_cboxResTypes.GetCurSel();
        ASSERT(icbi != CB_ERR);
        m_pciResType = (CResourceType *) m_cboxResTypes.GetItemDataPtr(icbi);

        icbi = m_cboxGroups.GetCurSel();
        ASSERT(icbi != CB_ERR);
        m_pciGroup = (CGroup *) m_cboxGroups.GetItemDataPtr(icbi);
    }  // if:  saving data from dialog
    else
    {
        // Select the proper resource type item.
        if (m_cboxResTypes.GetCurSel() == CB_ERR)
            m_cboxResTypes.SetCurSel(0);

        // Select the proper group item.
        if (m_cboxGroups.GetCurSel() == CB_ERR)
            m_cboxGroups.SetCurSel(0);
    }  // else:  setting to dialog

}  //*** CNewResNamePage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResNamePage::OnInitDialog(void)
{
    CBaseWizardPage::OnInitDialog();

    // Fill the Resource Type list.
    {
        POSITION        pos;
        CResourceType * pciResType;
        int             icbi;

        CDC           * pCboxDC;
        CFont         * pfontOldFont;
        CFont         * pfontCBFont;
        int             nCboxHorizExtent = 0;
        CSize           cboxTextSize;
        TEXTMETRIC      tm;

        tm.tmAveCharWidth = 0;

        //
        // Refer to Knowledge base article Q66370 for details on how to
        // set the horizontal extent of a list box (or drop list).
        //

        pCboxDC = m_cboxResTypes.GetDC();                   // Get the device context (DC) from the combo box.
        pfontCBFont = m_cboxResTypes.GetFont();             // Get the combo box font.
        pfontOldFont = pCboxDC->SelectObject(pfontCBFont);  // Select this font into the DC. Save the old font.
        pCboxDC->GetTextMetrics(&tm);                       // Get the text metrics of this DC.

        pos = PwizRes()->Pdoc()->LpciResourceTypes().GetHeadPosition();
        while (pos != NULL)
        {
            pciResType = (CResourceType *) PwizRes()->Pdoc()->LpciResourceTypes().GetNext(pos);

            const CString &rstrCurResTypeString = pciResType->StrDisplayName();

            ASSERT_VALID(pciResType);
            if (   (pciResType->Hkey() != NULL)
                && (rstrCurResTypeString.GetLength() > 0)
                && (pciResType->StrName() != CLUS_RESTYPE_NAME_FTSET)
                )
            {
                icbi = m_cboxResTypes.AddString(rstrCurResTypeString);
                
                // Compute the horizontal extent of this string.
                cboxTextSize = pCboxDC->GetTextExtent(rstrCurResTypeString);
                if (cboxTextSize.cx > nCboxHorizExtent)
                {
                    nCboxHorizExtent = cboxTextSize.cx;
                }

                ASSERT(icbi != CB_ERR);
                m_cboxResTypes.SetItemDataPtr(icbi, pciResType);
                pciResType->AddRef();
            }  // if:  resource type is valid
        }  // while:  more items in the list

        pCboxDC->SelectObject(pfontOldFont);                // Reset the original font in the DC
        m_cboxResTypes.ReleaseDC(pCboxDC);                  // Release the DC
        m_cboxResTypes.SetHorizontalExtent(nCboxHorizExtent + tm.tmAveCharWidth);

    }  // Fill the Resource Type list

    // Fill the Group list.
    {
        POSITION    pos;
        CGroup *    pciGroup;
        int         icbi;

        pos = PwizRes()->Pdoc()->LpciGroups().GetHeadPosition();
        while (pos != NULL)
        {
            pciGroup = (CGroup *) PwizRes()->Pdoc()->LpciGroups().GetNext(pos);
            ASSERT_VALID(pciGroup);
            if (   (pciGroup->Hgroup() != NULL)
                && (pciGroup->Hkey() != NULL))
            {
                icbi = m_cboxGroups.AddString(pciGroup->StrName());
                ASSERT(icbi != CB_ERR);
                m_cboxGroups.SetItemDataPtr(icbi, pciGroup);
                pciGroup->AddRef();
            }  // if:  group is valid
        }  // while:  more items in the list
    }  // Fill the Group list

    // If there is a group already selected, get its name.
    if (PwizRes()->PciGroup() != NULL)
        m_strGroup = PwizRes()->PciGroup()->StrName();

    // If there is a resource type already selected, get its name.
    if (PwizRes()->PciResType() != NULL)
        m_strResType = PwizRes()->PciResType()->StrName();

    UpdateData(FALSE /*bSaveAndValidate*/);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNewResNamePage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResNamePage::OnSetActive(void)
{
    BOOL    bSuccess;

    bSuccess = CBaseWizardPage::OnSetActive();
    if (bSuccess)
    {
        if (m_strName.IsEmpty())
            EnableNext(FALSE);
    }  // if:  successful thus far

    return bSuccess;

}  //*** CNewResNamePage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::BApplyChanges
//
//  Routine Description:
//      Apply changes from this page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Changes applied successfully.
//      FALSE       Error applying changes.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResNamePage::BApplyChanges(void)
{
    CWaitCursor wc;

    ASSERT(Pwiz() != NULL);

    // Get the data from the dialog.
    if (!UpdateData(TRUE /*bSaveAndValidate*/))
        return FALSE;

    // Save the data in the sheet.
    if (!PwizRes()->BSetRequiredFields(
                        m_strName,
                        m_pciResType,
                        m_pciGroup,
                        m_bSeparateMonitor,
                        m_strDesc))
        return FALSE;

    // Load extensions here.
    Pwiz()->LoadExtensions(PwizRes()->PciRes());

    return TRUE;

}  //*** CNewResNamePage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnDestroy
//
//  Routine Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResNamePage::OnDestroy(void)
{
    // Release references on resource type pointers.
    if (m_cboxResTypes.m_hWnd != NULL)
    {
        int             icbi;
        CResourceType * pciResType;

        for (icbi = m_cboxResTypes.GetCount() - 1 ; icbi >= 0 ; icbi--)
        {
            pciResType = (CResourceType *) m_cboxResTypes.GetItemDataPtr(icbi);
            ASSERT_VALID(pciResType);
            ASSERT_KINDOF(CResourceType, pciResType);

            pciResType->Release();
        }  // while:  more items in the list control
    }  // if:  resource types combobox has been initialized

    // Release references on group pointers.
    if (m_cboxGroups.m_hWnd != NULL)
    {
        int         icbi;
        CGroup *    pciGroup;

        for (icbi = m_cboxGroups.GetCount() - 1 ; icbi >= 0 ; icbi--)
        {
            pciGroup = (CGroup *) m_cboxGroups.GetItemDataPtr(icbi);
            ASSERT_VALID(pciGroup);
            ASSERT_KINDOF(CGroup, pciGroup);

            pciGroup->Release();
        }  // while:  more items in the list control
    }  // if:  groups combobox has been initialized

    CBaseWizardPage::OnDestroy();

}  //*** CNewResNamePage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnChangeResName
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Resource Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResNamePage::OnChangeResName(void)
{
    if (m_editName.GetWindowTextLength() == 0)
        EnableNext(FALSE);
    else
        EnableNext(TRUE);

}  //*** CNewResNamePage::OnChangeResName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnKillFocusResName
//
//  Routine Description:
//      Handler for the WM_KILLFOCUS message on the Resource Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResNamePage::OnKillFocusResName(void)
{
    CString     strName;

    m_editName.GetWindowText(strName);
    SetObjectTitle(strName);

}  //*** CNewResNamePage::OnKillFocusResName()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewResOwnersPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewResOwnersPage, CListCtrlPairWizPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CNewResOwnersPage, CListCtrlPairWizPage)
    //{{AFX_MSG_MAP(CNewResOwnersPage)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::CNewResOwnersPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewResOwnersPage::CNewResOwnersPage(void)
    : CListCtrlPairWizPage(
            IDD,
            g_aHelpIDs_IDD_WIZ_POSSIBLE_OWNERS,
            LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY,
            GetColumn,
            BDisplayProperties
            )
{
    //{{AFX_DATA_INIT(CNewResOwnersPage)
    //}}AFX_DATA_INIT

}  //*** CNewResOwnersPage::CNewResOwnersPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResOwnersPage::DoDataExchange(CDataExchange * pDX)
{
    // Initialize the lists before the list pair control is updated.
    if (!pDX->m_bSaveAndValidate)
    {
        if (!BInitLists())
            pDX->Fail();
    }  // if:  setting data to the dialog

    CListCtrlPairWizPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewResOwnersPage)
    DDX_Control(pDX, IDC_LCP_NOTE, m_staticNote);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BBackPressed())
        {
#if 0
            // If user removed node on which group is online,
            // display message and fail.
            if (!BOwnedByPossibleOwner())
            {
                CString strMsg;
                strMsg.FormatMessage(IDS_RES_NOT_OWNED_BY_POSSIBLE_OWNER, PciRes()->StrGroup(), PciRes()->StrOwner());
                AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
                strMsg.Empty(); // prepare to throw exception in Fail()
                pDX->Fail();
            }  // if:  not owned by possible owner
#endif
        }  // if:  Back button not pressed
    }  // if:  saving data from dialog

}  //*** CNewResOwnersPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::BInitLists
//
//  Routine Description:
//      Initialize the lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::BInitLists(void)
{
    BOOL        bSuccess = TRUE;

    ASSERT_VALID(PciRes());

    try
    {
        SetLists(&PciRes()->LpcinodePossibleOwners(), &PciRes()->Pdoc()->LpciNodes());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CNewResOwnersPage::BInitLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::OnInitDialog(void)
{
    // Add columns.
    try
    {
        NAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    // Call the base class method.
    CListCtrlPairWizPage::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNewResOwnersPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::OnSetActive(void)
{
    BOOL    bSuccess;

    PciRes()->CollectPossibleOwners(NULL);
    bSuccess = CListCtrlPairWizPage::OnSetActive();

    return bSuccess;

}  //*** CNewResOwnersPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::BApplyChanges(void)
{
    CWaitCursor wc;

    try
    {
        // Set the data from the page in the cluster item.
        PciRes()->SetPossibleOwners((CNodeList &) Plcp()->LpobjRight());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CListCtrlPairWizPage::BApplyChanges();

}  //*** CNewResOwnersPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::BOwnedByPossibleOwner
//
//  Routine Description:
//      Determine if the group in which this resource resides is owned by
//      a node in the proposed possible owners list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Group owned by node in possible owners list.
//      FALSE       Group NOT owned by node in possible owners list.
//
//  Exceptions Thrown:
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::BOwnedByPossibleOwner(void) const
{
    CClusterNode *  pciNode = NULL;

    // Get the node on which the resource is online.
    PciRes()->UpdateState();

    // Find the owner node in the proposed possible owners list.
    {
        POSITION        pos;

        pos = Plcp()->LpobjRight().GetHeadPosition();
        while (pos != NULL)
        {
            pciNode = (CClusterNode *) Plcp()->LpobjRight().GetNext(pos);
            ASSERT_VALID(pciNode);

            if (PciRes()->StrOwner().CompareNoCase(pciNode->StrName()) == 0)
                break;
            pciNode = NULL;
        }  // while:  more items in the list
    }  // Find the owner node in the proposed possible owners list

    return (pciNode != NULL);

}  //*** CNewResOwnersPage::BOwnedByPossibleOwner()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::GetColumn [static]
//
//  Routine Description:
//      Returns a column for an item.
//
//  Arguments:
//      pobj        [IN OUT] Object for which the column is to be displayed.
//      iItem       [IN] Index of the item in the list.
//      icol        [IN] Column number whose text is to be retrieved.
//      pdlg        [IN OUT] Dialog to which object belongs.
//      rstr        [OUT] String in which to return column text.
//      piimg       [OUT] Image index for the object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CNewResOwnersPage::GetColumn(
    IN OUT CObject *    pobj,
    IN int              iItem,
    IN int              icol,
    IN OUT CDialog *    pdlg,
    OUT CString &       rstr,
    OUT int *           piimg
    )
{
    CClusterNode *  pciNode = (CClusterNode *) pobj;
    int             colid;

    ASSERT_VALID(pciNode);
    ASSERT((0 <= icol) && (icol <= 1));

    switch (icol)
    {
        // Sorting by resource name.
        case 0:
            colid = IDS_COLTEXT_NAME;
            break;

        default:
            ASSERT(0);
            colid = IDS_COLTEXT_NAME;
            break;
    }  // switch:  pdlg->NSortColumn()

    pciNode->BGetColumnData(colid, rstr);
    if (piimg != NULL)
        *piimg = pciNode->IimgObjectType();

}  //*** CNewResOwnersPage::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::BDisplayProperties [static]
//
//  Routine Description:
//      Display the properties of the specified object.
//
//  Arguments:
//      pobj    [IN OUT] Cluster item whose properties are to be displayed.
//
//  Return Value:
//      TRUE    Properties where accepted.
//      FALSE   Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CNewResOwnersPage::BDisplayProperties(IN OUT CObject * pobj)
{
    CClusterItem *  pci = (CClusterItem *) pobj;

    ASSERT_KINDOF(CClusterItem, pobj);

    return pci->BDisplayProperties();

}  //*** CNewResOwnersPage::BDisplayProperties();


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewResDependsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewResDependsPage, CListCtrlPairWizPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CNewResDependsPage, CListCtrlPairWizPage)
    //{{AFX_MSG_MAP(CNewResDependsPage)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::CNewResDependsPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewResDependsPage::CNewResDependsPage(void)
    : CListCtrlPairWizPage(
            IDD,
            g_aHelpIDs_IDD_WIZ_DEPENDENCIES,
            LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY,
            GetColumn,
            BDisplayProperties
            )
{
    //{{AFX_DATA_INIT(CNewResDependsPage)
    //}}AFX_DATA_INIT

}  //*** CNewResDependsPage::CNewResDependsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResDependsPage::DoDataExchange(CDataExchange * pDX)
{
    // Initialize the lists before the list pair control is updated.
    if (!pDX->m_bSaveAndValidate)
    {
        if (!BInitLists())
            pDX->Fail();
    }  // if:  setting data to the dialog

    CListCtrlPairWizPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewResDependsPage)
    //}}AFX_DATA_MAP

}  //*** CNewResDependsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::BInitLists
//
//  Routine Description:
//      Initialize the lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResDependsPage::BInitLists(void)
{
    BOOL        bSuccess = TRUE;

    ASSERT_VALID(PciRes());

    try
    {
        // Create the list of resources on which this resource can be dependent.
        {
            POSITION                posPci;
            CResource *             pciRes;
            const CResourceList &   rlpciResources = PciGroup()->Lpcires();

            LpciresAvailable().RemoveAll();

            posPci = rlpciResources.GetHeadPosition();
            while (posPci != NULL)
            {
                // Get the cluster item pointer.
                pciRes = (CResource *) rlpciResources.GetNext(posPci);
                ASSERT_VALID(pciRes);

                // If we CAN be dependent on this resource, add it to our Available list.
                if (PciRes()->BCanBeDependent(pciRes)
                        || PciRes()->BIsDependent(pciRes))
                    LpciresAvailable().AddTail(pciRes);
            }  // while:  more items in the list
        }  // Create the list of resources on which this resource can be dependent

        SetLists(&PciRes()->LpciresDependencies(), &LpciresAvailable());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CNewResDependsPage::BInitLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResDependsPage::OnInitDialog(void)
{
    // Add columns.
    try
    {
        NAddColumn(IDS_COLTEXT_RESOURCE, COLI_WIDTH_NAME);
        NAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    // Call the base class method.
    CListCtrlPairWizPage::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNewResDependsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResDependsPage::BApplyChanges(void)
{
    CWaitCursor wc;

    // Check to see if required dependencies have been made.
    {
        CString     strMissing;
        CString     strMsg;

        try
        {
            if (!PciRes()->BRequiredDependenciesPresent((const CResourceList &)Plcp()->LpobjRight(), strMissing))
            {
                strMsg.FormatMessage(IDS_REQUIRED_DEPENDENCY_NOT_FOUND, strMissing);
                AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
                return FALSE;
            }  // if:  all required dependencies not present
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            return FALSE;
        }  // catch:  CException
    }  // Check to see if required dependencies have been made

    // Set the data from the page in the cluster item.
    try
    {
        PciRes()->SetDependencies((CResourceList &) Plcp()->LpobjRight());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CListCtrlPairWizPage::BApplyChanges();

}  //*** CNewResDependsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::GetColumn [static]
//
//  Routine Description:
//      Returns a column for an item.
//
//  Arguments:
//      pobj        [IN OUT] Object for which the column is to be displayed.
//      iItem       [IN] Index of the item in the list.
//      icol        [IN] Column number whose text is to be retrieved.
//      pdlg        [IN OUT] Dialog to which object belongs.
//      rstr        [OUT] String in which to return column text.
//      piimg       [OUT] Image index for the object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CNewResDependsPage::GetColumn(
    IN OUT CObject *    pobj,
    IN int              iItem,
    IN int              icol,
    IN OUT CDialog *    pdlg,
    OUT CString &       rstr,
    OUT int *           piimg
    )
{
    CResource * pciRes  = (CResource *) pobj;
    int         colid;

    ASSERT_VALID(pciRes);
    ASSERT((0 <= icol) && (icol <= 1));

    switch (icol)
    {
        // Sorting by resource name.
        case 0:
            colid = IDS_COLTEXT_RESOURCE;
            break;

        // Sorting by resource type.
        case 1:
            colid = IDS_COLTEXT_RESTYPE;
            break;

        default:
            ASSERT(0);
            colid = IDS_COLTEXT_RESOURCE;
            break;
    }  // switch:  pdlg->NSortColumn()

    pciRes->BGetColumnData(colid, rstr);
    if (piimg != NULL)
        *piimg = pciRes->IimgObjectType();

}  //*** CNewResDependsPage::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::BDisplayProperties [static]
//
//  Routine Description:
//      Display the properties of the specified object.
//
//  Arguments:
//      pobj    [IN OUT] Cluster item whose properties are to be displayed.
//
//  Return Value:
//      TRUE    Properties where accepted.
//      FALSE   Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CNewResDependsPage::BDisplayProperties(IN OUT CObject * pobj)
{
    CClusterItem *  pci = (CClusterItem *) pobj;

    ASSERT_KINDOF(CClusterItem, pobj);

    return pci->BDisplayProperties();

}  //*** CNewResDependsPage::BDisplayProperties();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\restype.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Res.h
//
//  Abstract:
//      Definition of the CResource class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESTYPE_H_
#define _RESTYPE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResourceType;
class CResourceTypeList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNodeList;
class CClusterNode;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CResourceType command target
/////////////////////////////////////////////////////////////////////////////

class CResourceType : public CClusterItem
{
    DECLARE_DYNCREATE( CResourceType )

    CResourceType( void );      // protected constructor used by dynamic creation
    void                    Init( IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName );

// Attributes
protected:
    CString                 m_strDisplayName;
    CString                 m_strResDLLName;
    CStringList             m_lstrAdminExtensions;
    DWORD                   m_nLooksAlive;
    DWORD                   m_nIsAlive;
    CLUS_RESOURCE_CLASS_INFO    m_rciResClassInfo;
    DWORD                   m_dwCharacteristics;
    DWORD                   m_dwFlags;
    BOOL                    m_bAvailable;

    CNodeList *             m_plpcinodePossibleOwners;

    enum
    {
        epropDisplayName = 0,
        epropDllName,
        epropDescription,
        epropLooksAlive,
        epropIsAlive,
        epropMAX
    };

    CObjectProperty         m_rgProps[ epropMAX ];

public:
    const CString &         StrDisplayName( void ) const        { return m_strDisplayName; }
    const CString &         StrResDLLName( void ) const         { return m_strResDLLName; }
    const CStringList &     LstrAdminExtensions( void ) const   { return m_lstrAdminExtensions; }
    DWORD                   NLooksAlive( void ) const           { return m_nLooksAlive; }
    DWORD                   NIsAlive( void ) const              { return m_nIsAlive; }
    CLUSTER_RESOURCE_CLASS  ResClass( void ) const              { return m_rciResClassInfo.rc; }
    PCLUS_RESOURCE_CLASS_INFO   PrciResClassInfo( void )        { return &m_rciResClassInfo; }
    DWORD                   DwCharacteristics( void ) const     { return m_dwCharacteristics; }
    DWORD                   DwFlags( void ) const               { return m_dwFlags; }
    BOOL                    BQuorumCapable( void ) const        { return (m_dwCharacteristics & CLUS_CHAR_QUORUM) != 0; }
    BOOL                    BAvailable( void ) const            { return m_bAvailable; }

    const CNodeList &       LpcinodePossibleOwners( void ) const
    {
        ASSERT( m_plpcinodePossibleOwners != NULL );
        return *m_plpcinodePossibleOwners;

    } //*** LpcinodePossibleOwners()


// Operations
public:
    void                    ReadExtensions( void );
    void                    CollectPossibleOwners( void );
    void                    AddAllNodesAsPossibleOwners( void );
//  void                    RemoveNodeFromPossibleOwners( IN OUT CNodeList * plpci, IN const CClusterNode * pNode );

    void                    SetCommonProperties(
                                IN const CString &  rstrName,
                                IN const CString &  rstrDesc,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive,
                                IN BOOL             bValidateOnly
                                );
    void                    SetCommonProperties(
                                IN const CString &  rstrName,
                                IN const CString &  rstrDesc,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive
                                )
    {
        SetCommonProperties( rstrName, rstrDesc, nLooksAlive, nIsAlive, FALSE /*bValidateOnly*/ );
    }
    void                    ValidateCommonProperties(
                                IN const CString &  rstrName,
                                IN const CString &  rstrDesc,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive
                                )
    {
        SetCommonProperties( rstrName, rstrDesc, nLooksAlive, nIsAlive, TRUE /*bValidateOnly*/ );
    }

// Overrides
public:
    virtual LPCTSTR         PszTitle( void ) const      { return m_strDisplayName; }
    virtual void            Cleanup( void );
    virtual void            ReadItem( void );
    virtual void            Rename( IN LPCTSTR pszName );
    virtual BOOL            BGetColumnData( IN COLID colid, OUT CString & rstrText );
    virtual BOOL            BCanBeEdited( void ) const;
    virtual BOOL            BDisplayProperties( IN BOOL bReadOnly = FALSE );

    virtual const CStringList * PlstrExtensions( void ) const;

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CResourceType)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    virtual LRESULT         OnClusterNotify( IN OUT CClusterNotify * pnotify );

protected:
    virtual const CObjectProperty * Pprops( void ) const    { return m_rgProps; }
    virtual DWORD                   Cprops( void ) const    { return sizeof(m_rgProps) / sizeof(m_rgProps[0]); }
    virtual DWORD                   DwSetCommonProperties( IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE );

// Implementation
protected:
    CStringList             m_lstrCombinedExtensions;
    BOOL                    m_bPossibleOwnersAreFake;

    const CStringList &     LstrCombinedExtensions( void ) const    { return m_lstrCombinedExtensions; }

public:
    virtual                 ~CResourceType( void );
    BOOL                    BPossibleOwnersAreFake( void ) const    { return m_bPossibleOwnersAreFake; }

protected:
    // Generated message map functions
    //{{AFX_MSG(CResourceType)
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

};  //*** class CResourceType

/////////////////////////////////////////////////////////////////////////////
// CResourceTypeList
/////////////////////////////////////////////////////////////////////////////

class CResourceTypeList : public CClusterItemList
{
public:
    CResourceType * PciResTypeFromName(
                        IN LPCTSTR      pszName,
                        OUT POSITION *  ppos = NULL
                        )
    {
        return (CResourceType *) PciFromName( pszName, ppos );
    }

};  //*** class CResourceTypeList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData( IN OUT CResourceTypeList & rlp );

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagResType;
extern CTraceTag g_tagResTypeNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _RESTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CluAdmin.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\splitfrm.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      SplitFrm.cpp
//
//  Abstract:
//      Implementation of the CSplitterFrame class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ConstDef.h"
#include "SplitFrm.h"
#include "MainFrm.h"
#include "TreeView.h"
#include "ListView.h"
#include "TraceTag.h"
#include "ExtDll.h"
#include "ClusItem.h"
#include "ClusDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagSplitFrame(_T("UI"), _T("SPLITTER FRAME"), 0);
CTraceTag   g_tagSplitFrameMenu(_T("Menu"), _T("SPLITTER FRAME MENU"), 0);
CTraceTag   g_tagSplitFrameDrag(_T("Drag&Drop"), _T("SPLITTER FRAME DRAG"), 0);
CTraceTag   g_tagSplitFrameDragMouse(_T("Drag&Drop"), _T("SPLITTER FRAME DRAG MOUSE"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CSplitterFrame
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CSplitterFrame, CMDIChildWnd)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CSplitterFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CSplitterFrame)
    ON_WM_CONTEXTMENU()
    ON_WM_DESTROY()
    ON_UPDATE_COMMAND_UI(ID_VIEW_LARGE_ICONS, OnUpdateLargeIconsView)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SMALL_ICONS, OnUpdateSmallIconsView)
    ON_UPDATE_COMMAND_UI(ID_VIEW_LIST, OnUpdateListView)
    ON_UPDATE_COMMAND_UI(ID_VIEW_DETAILS, OnUpdateDetailsView)
    ON_COMMAND(ID_VIEW_LARGE_ICONS, OnLargeIconsView)
    ON_COMMAND(ID_VIEW_SMALL_ICONS, OnSmallIconsView)
    ON_COMMAND(ID_VIEW_LIST, OnListView)
    ON_COMMAND(ID_VIEW_DETAILS, OnDetailsView)
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_RBUTTONUP()
    //}}AFX_MSG_MAP
#ifdef _DEBUG
    ON_WM_MDIACTIVATE()
#endif
    ON_MESSAGE(WM_CAM_UNLOAD_EXTENSION, OnUnloadExtension)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 0, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 1, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 2, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 3, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 4, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 5, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 6, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 7, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 8, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 9, OnUpdateExtMenu)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::CSplitterFrame
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSplitterFrame::CSplitterFrame(void)
{
    m_pdoc = NULL;
    m_iFrame = 0;
    m_pext = NULL;

    // Initialize drag & drop.
    m_bDragging = FALSE;
    m_pimagelist = NULL;
    m_pciDrag = NULL;

}  //*** CSplitterFrame::CSplitterFrame()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::CSplitterFrame
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSplitterFrame::~CSplitterFrame(void)
{
    // Cleanup after ourselves.
    if ((Pdoc() != NULL) && (Pdoc()->PtiCluster() != NULL))
        Pdoc()->PtiCluster()->PreRemoveFromFrameWithChildren(this);

    // Cleanup any extensions.
    delete Pext();

}  //*** CSplitterFrame::~CSplitterFrame()

#ifdef _DEBUG
void CSplitterFrame::AssertValid(void) const
{
    CMDIChildWnd::AssertValid();

}  //*** CSplitterFrame::AssertValid()

void CSplitterFrame::Dump(CDumpContext& dc) const
{
    CMDIChildWnd::Dump(dc);

}  //*** CSplitterFrame::Dump()

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::CalculateFrameNumber
//
//  Routine Description:
//      Calculate the number of this frame connected to the document.  This
//      should only be called before the views have been created.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::CalculateFrameNumber(void)
{
    POSITION            pos;
    CView *             pview;

    if (Pdoc() != NULL)
    {
        // At least frame # 1 'cause we exist.
        m_iFrame = 1;

        pos = Pdoc()->GetFirstViewPosition();
        while (pos != NULL)
        {
            pview = Pdoc()->GetNextView(pos);
            ASSERT_VALID(pview);
            if (pview->IsKindOf(RUNTIME_CLASS(CClusterTreeView)))
            {
                if (pview->GetParentFrame() == this)
                    break;
                m_iFrame++;
            }  // if:  found another tree view
        }  // while:  more views in the list
    }  // if:  document associated with frame

}  //*** CSplitterFrame::CalculateFrameNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::InitFrame
//
//  Routine Description:
//      Called to initialize the frame after being initially created and
//      after the document has been initialized.
//
//  Arguments:
//      pDoc        Document associated with the frame.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::InitFrame(IN OUT CClusterDoc * pDoc)
{
    m_pdoc = pDoc;
    ASSERT_VALID(Pdoc());

    // Calculate the number of our frame so the views can use it.
    CalculateFrameNumber();

    // Read from the profile.
    {
        CString         strSection;

        strSection.Format(REGPARAM_CONNECTIONS _T("\\%s"), Pdoc()->StrNode());
        // Set window placement.
        {
            WINDOWPLACEMENT wp;

            if (ReadWindowPlacement(&wp, strSection, NFrameNumber()))
                SetWindowPlacement(&wp);

        }  // Set window placement

        // Set splitter bar position.
        {
            CString     strValueName;
            CString     strPosition;
            int         nCurWidth;
            int         nMaxWidth;
            int         nRead;

            try
            {
                ConstructProfileValueName(strValueName, REGPARAM_SPLITTER_BAR_POS);
                strPosition = AfxGetApp()->GetProfileString(strSection, strValueName);
                nRead = _stscanf(strPosition, _T("%d,%d"), &nCurWidth, &nMaxWidth);
                if (nRead == 2)
                {
                    m_wndSplitter.SetColumnInfo(0, nCurWidth, nMaxWidth);
                    m_wndSplitter.RecalcLayout();
                }  // if:  correct number of parameters specified
            }  // try
            catch (CException * pe)
            {
                pe->Delete();
            }  // catch:  CException
        }  // Save the splitter bar position

        // Set the view style of the list view.
        {
            DWORD       dwView;
            CString     strValueName;

            try
            {
                // Construct the value name.
                ConstructProfileValueName(strValueName, REGPARAM_VIEW);

                // Read the view setting.
                dwView = AfxGetApp()->GetProfileInt(strSection, strValueName, (LVS_ICON | LVS_REPORT));
                PviewList()->SetView(dwView);
            }  // try
            catch (CException * pe)
            {
                pe->Delete();
            }  // catch:  CException
        }  // Set the view style of the list view
    }  // Read from the profile

}  //*** CSplitterFrame::InitFrame()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnCreateClient
//
//  Routine Description:
//      Called to create the client views for the frame.  Here we create
//      a splitter window with two views -- a tree view and a list view.
//
//  Arguments:
//      lpcs        Pointer to a CREATESTRUCT.
//      pContext    Pointer to a create context.
//
//  Return Value:
//      TRUE        Client created successfully.
//      FALSE       Failed to create client.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CSplitterFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) 
{
    // Create a splitter window with 1 row & 2 columns.
    if (!m_wndSplitter.CreateStatic(this, 1, 2))
    {
        Trace(g_tagSplitFrame, _T("Failed to CreateStaticSplitter"));
        return FALSE;
    }  // if:  error creating splitter window

    // Add the first splitter pane.
    if (!m_wndSplitter.CreateView(0, 0, pContext->m_pNewViewClass, CSize(200, 50), pContext))
    {
        Trace(g_tagSplitFrame, _T("Failed to create first pane"));
        return FALSE;
    }  // if:  error creating first splitter pane

    // Add the second splitter pane.
    if (!m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CClusterListView), CSize(0, 0), pContext))
    {
        Trace(g_tagSplitFrame, _T("Failed to create second pane"));
        return FALSE;
    }  // if:  error creating second pane

    // Activate the tree view.
//  SetActiveView((CView *) PviewTree());

    // If this is not the first frame on the document, initialize the frame.
    {
        CClusterDoc * pdoc = (CClusterDoc *) pContext->m_pCurrentDoc;
        if (pdoc->StrNode().GetLength() > 0)
            InitFrame(pdoc);
    }  // If this is not the first frame on the document, initialize the frame

    return TRUE;
    
}  //*** CSplitterFrame::OnCreateClient()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::ConstructProfileValueName
//
//  Routine Description:
//      Construct the name of a value that is to be written to the user's
//      profile.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the constructed name.
//      pszPrefix   [IN] String to prefix the name with.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::ConstructProfileValueName(
    OUT CString &   rstrName,
    IN LPCTSTR      pszPrefix
    ) const
{
    ASSERT(pszPrefix != NULL);

    // Construct the name of the value to read.
    if (NFrameNumber() <= 1)
        rstrName = pszPrefix;
    else
        rstrName.Format(_T("%s-%d"), pszPrefix, NFrameNumber());

}  //*** CSplitterFrame::ConstructProfileValueName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::GetMessageString
//
//  Routine Description:
//      Get a string for a command ID.
//
//  Arguments:
//      nID         [IN] Command ID for which a string should be returned.
//      rMessage    [OUT] String in which to return the message.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::GetMessageString(UINT nID, CString& rMessage) const
{
    BOOL        bHandled    = FALSE;

    if ((Pext() != NULL)
            && (CAEXT_MENU_FIRST_ID <= nID))
        bHandled = Pext()->BGetCommandString(nID, rMessage);

    if (!bHandled)
        CMDIChildWnd::GetMessageString(nID, rMessage);

}  //*** CSplitterFrame::GetMessageString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnContextMenu(CWnd * pWnd, CPoint point)
{
    CView *         pviewActive = GetActiveView();
    CMenu *         pmenu       = NULL;
    CClusterItem *  pci         = NULL;

    Trace(g_tagSplitFrame, _T("OnContextMenu()"));

    if (!BDragging())
    {
        if (pviewActive == PviewTree())
            pmenu = PviewTree()->PmenuPopup(point, pci);
        else if (pviewActive == PviewList())
            pmenu = PviewList()->PmenuPopup(point, pci);

        if (pmenu == NULL)
            pmenu = PmenuPopup();
    }  // if:  not dragging

    if (pmenu != NULL)
    {
        // If there is an extension already loaded, unload it.
        delete Pext();
        m_pext = NULL;

        // If there is an extension for this item, load it.
        if ((pci != NULL)
                && (pci->PlstrExtensions() != NULL)
                && (pci->PlstrExtensions()->GetCount() > 0))
        {
            CWaitCursor     wc;

            try
            {
                m_pext = new CExtensions;
                if ( m_pext == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating the extensions object
                Pext()->AddContextMenuItems(
                            pmenu->GetSubMenu(0),
                            *pci->PlstrExtensions(),
                            pci
                            );
            }  // try
            catch (CException * pe)
            {
#ifdef _DEBUG
                TCHAR       szError[256];
                pe->GetErrorMessage(szError, sizeof(szError) / sizeof(TCHAR));
                Trace(g_tagError, _T("CSplitterFrame::OnContextMenu() - Error loading extension DLL - %s"), szError);
#endif
                pe->Delete();

                delete Pext();
                m_pext = NULL;
            }  // catch:  CException
        }  // if:  this item has an extension

        // Display the menu.
        if (!pmenu->GetSubMenu(0)->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        AfxGetMainWnd()
                        ))
        {
            delete Pext();
            m_pext = NULL;
        }  // if:  unsuccessfully displayed the menu
        else if (Pext() != NULL)
            PostMessage(WM_CAM_UNLOAD_EXTENSION, NULL, NULL);;
        pmenu->DestroyMenu();
        delete pmenu;
    }  // if:  there is a menu to display

}  //*** CSplitterFrame::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::PmenuPopup
//
//  Routine Description:
//      Returns a popup menu.
//
//  Arguments:
//      None.
//
//  Return Value:
//      pmenu       A popup menu for the item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMenu * CSplitterFrame::PmenuPopup( void ) const
{
    CMenu * pmenu;

    // Load the menu.
    pmenu = new CMenu;
    if ( pmenu == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating the menu

    if ( ! pmenu->LoadMenu( IDM_VIEW_POPUP ) )
    {
        delete pmenu;
        pmenu = NULL;
    }  // if:  error loading the menu

    return pmenu;

}  //*** CSplitterFrame::PmenuPopup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  If an extension DLL is loaded and the
//      message is a command selection, pass it on to the DLL.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CSplitterFrame::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL        bHandled    = FALSE;

    // If there is an extension DLL loaded, see if it wants to handle this message.
    if ((Pext() != NULL) && (nCode == 0))
    {
        Trace(g_tagSplitFrame, _T("OnCmdMsg() - Passing message to extension (ID = %d)"), nID);
        bHandled = Pext()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

        // Unload the extension DLL if there is one loaded.
        if (bHandled)
        {
            delete Pext();
            m_pext = NULL;
        }  // if:  message was handled
    }  // if:  there is an extension DLL loaded

//  if ((CAEXT_MENU_FIRST_ID <= nID) && (nID <= CAEXT_MENU_LAST_ID))
//      Trace(g_tagSplitFrame, _T("CSplitterFrame::OnCmdMsg() - nID = %d, nCode = 0x%08.8x, pExtra = 0x%08.8x\n"), nID, nCode, pExtra);

    if (!bHandled)
        bHandled = CMDIChildWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

    return bHandled;

}  //*** CSplitterFrame::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnUpdateExtMenu
//
//  Routine Description:
//      Determines whether extension menu items should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnUpdateExtMenu(CCmdUI * pCmdUI)
{
    if (Pext() != NULL)
        Pext()->OnUpdateCommand(pCmdUI);

}  //*** CSplitterFrame::OnUpdateExtMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnUnloadExtension
//
//  Routine Description:
//      Handler for the WM_CAM_UNLOAD_EXTENSION message.
//
//  Arguments:
//      wparam      1st parameter.
//      lparam      2nd parameter.
//
//  Return Value:
//      ERROR_SUCCESS
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CSplitterFrame::OnUnloadExtension(WPARAM wparam, LPARAM lparam)
{
    Trace(g_tagSplitFrame, _T("OnUnloadExtension() - m_pext = 0x%08.8x"), Pext());
    delete Pext();
    m_pext = NULL;
    return ERROR_SUCCESS;

}  //*** CSplitterFrame::OnUnloadExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnDestroy(void)
{
    // Display information about the current menu.
    TraceMenu(g_tagSplitFrameMenu, AfxGetMainWnd()->GetMenu(), _T("Menu before child wnd destroyed: "));

    // Save current settings.
    if (Pdoc() != NULL)
    {
        CString         strSection;

        // Construct the section name.
        ASSERT_VALID(Pdoc());
        strSection.Format(REGPARAM_CONNECTIONS _T("\\%s"), Pdoc()->StrNode());

        // Save the current window position information.
        {
            WINDOWPLACEMENT wp;

            wp.length = sizeof wp;
            if (GetWindowPlacement(&wp))
            {
                wp.flags = 0;
                if (IsZoomed())
                    wp.flags |= WPF_RESTORETOMAXIMIZED;

                // and write it to the .INI file
                WriteWindowPlacement(&wp, strSection, NFrameNumber());
            }  // if:  window placement retrieved successfully
        }  // Save the current window position information

        // Save the splitter bar position.
        {
            CString     strValueName;
            CString     strPosition;
            int         nCurWidth;
            int         nMaxWidth;

            m_wndSplitter.GetColumnInfo(0, nCurWidth, nMaxWidth);
            ConstructProfileValueName(strValueName, REGPARAM_SPLITTER_BAR_POS);
            strPosition.Format(_T("%d,%d"), nCurWidth, nMaxWidth);
            AfxGetApp()->WriteProfileString(strSection, strValueName, strPosition);
        }  // Save the splitter bar position

        // Save the current list view style.
        {
            DWORD       dwView;
            CString     strValueName;

            // Construct the value name.
            ConstructProfileValueName(strValueName, REGPARAM_VIEW);

            // Save the view setting.
            dwView = PviewList()->GetView();
            AfxGetApp()->WriteProfileInt(strSection, strValueName, dwView);
        }  // Save the current list view style
    }  // if:  document is valid

    // Call the base class method.
    CMDIChildWnd::OnDestroy();

    // Display information about the current menu.
    TraceMenu(g_tagSplitFrameMenu, AfxGetMainWnd()->GetMenu(), _T("Menu after child wnd destroyed: "));

}  //*** CSplitterFrame::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnUpdateLargeIconsView
//  CSplitterFrame::OnUpdateSmallIconsView
//  CSplitterFrame::OnUpdateListView
//  CSplitterFrame::OnUpdateDetailsView
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_VIEW_LARGE_ICONS,
//      ID_VIEW_SMALL_ICONS, ID_VIEW_LIST, and ID_VIEW_DETAILS should be
//      enabled or not.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnUpdateLargeIconsView(CCmdUI * pCmdUI)
{
    int     nCheck;

    nCheck = PviewList()->GetView();
    pCmdUI->SetRadio(nCheck == LVS_ICON);
    pCmdUI->Enable();

}  //*** CSplitterFrame::OnUpdateLargeIconsView()

void CSplitterFrame::OnUpdateSmallIconsView(CCmdUI * pCmdUI)
{
    int     nCheck;

    nCheck = PviewList()->GetView();
    pCmdUI->SetRadio(nCheck == LVS_SMALLICON);
    pCmdUI->Enable();

}  //*** CSplitterFrame::OnUpdateSmallIconsView()

void CSplitterFrame::OnUpdateListView(CCmdUI * pCmdUI)
{
    int     nCheck;

    nCheck = PviewList()->GetView();
    pCmdUI->SetRadio(nCheck == LVS_LIST);
    pCmdUI->Enable();

}  //*** CSplitterFrame::OnUpdateListView()

void CSplitterFrame::OnUpdateDetailsView(CCmdUI * pCmdUI)
{
    int     nCheck;

    nCheck = PviewList()->GetView();
    pCmdUI->SetRadio(nCheck == (LVS_REPORT | LVS_ICON));
    pCmdUI->Enable();

}  //*** CSplitterFrame::OnUpdateDetailsView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnCmdLargeIconsView
//  CSplitterFrame::OnCmdSmallIconsView
//  CSplitterFrame::OnCmdListView
//  CSplitterFrame::OnCmdDetailsView
//
//  Routine Description:
//      Processes the ID_VIEW_LARGE_ICONS, ID_VIEW_SMALL_ICONS, ID_VIEW_LIST,
//      and ID_VIEW_DETAILS menu commands.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnLargeIconsView(void)
{
    PviewList()->SetView(LVS_ICON);

}  //*** CSplitterFrame::OnLargeIconsView()

void CSplitterFrame::OnSmallIconsView(void)
{
    PviewList()->SetView(LVS_SMALLICON);

}  //*** CSplitterFrame::OnSmallIconsView()

void CSplitterFrame::OnListView(void)
{
    PviewList()->SetView(LVS_LIST);

}  //*** CSplitterFrame::OnListView()

void CSplitterFrame::OnDetailsView(void)
{
    PviewList()->SetView(LVS_REPORT | LVS_ICON);

}  //*** CSplitterFrame::OnDetailsView()

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnMDIActivate
//
//  Routine Description:
//      Handler method for the WM_MDIACTIVATE message.
//
//  Arguments:
//      bActivate       [IN] TRUE if the child is being activated and FALSE
//                          if it is being deactivated.
//      pActivateWnd    [IN OUT] Child window to be activated.
//      pDeactivateWnd  [IN OUT] Child window being deactivated.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd)
{
    if (g_tagSplitFrameMenu.BAny())
    {
        if (!bActivate)
        {
            CMDIFrameWnd *  pFrame = GetMDIFrame();
            CMenu           menuDefault;

            TraceMenu(g_tagSplitFrameMenu, AfxGetMainWnd()->GetMenu(), _T("Menu before deactivating: "));
            menuDefault.Attach(pFrame->m_hMenuDefault);
            TraceMenu(g_tagSplitFrameMenu, &menuDefault, _T("Frame menu before deactivating: "));
            menuDefault.Detach();
        }  // if:  deactivating
        else
        {
            CMDIFrameWnd *  pFrame = GetMDIFrame();
            CMenu           menuDefault;

            menuDefault.Attach(pFrame->m_hMenuDefault);
            TraceMenu(g_tagSplitFrameMenu, &menuDefault, _T("Frame menu before activating: "));
            menuDefault.Detach();
        }  // else:  activating
    }  // if:  tag is active

    CMDIChildWnd::OnMDIActivate(bActivate, pActivateWnd, pDeactivateWnd);

    if (!bActivate)
        TraceMenu(g_tagSplitFrameMenu, AfxGetMainWnd()->GetMenu(), _T("Menu after deactivating: "));

}  //*** CSplitterFrame::OnMDIActivate()
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::BeginDrag
//
//  Routine Description:
//      Called by a view to begin a drag operation.
//
//  Arguments:
//      pimagelist  [IN OUT] Image list to use for the drag operation.
//      pci         [IN OUT] Cluster item being dragged.
//      ptImage     [IN] Specifies the x- and y-coordinate of the cursor.
//      ptStart     [IN] Specifies the x- and y-coordinate of the start position.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::BeginDrag(
    IN OUT CImageList *     pimagelist,
    IN OUT CClusterItem *   pci,
    IN CPoint               ptImage,
    IN CPoint               ptStart
    )
{
    ASSERT(!BDragging());
    ASSERT(pimagelist != NULL);
    ASSERT_VALID(pci);

    // Save the cluster item.
    m_pciDrag = pci;

    // Prepare the image list.
    m_pimagelist = pimagelist;
    VERIFY(Pimagelist()->BeginDrag(0, ptStart));
    VERIFY(Pimagelist()->DragEnter(this, ptImage));
    SetCapture();

    // Set the dragging state.
    m_bDragging = TRUE;

    // Let each view initialize for the drag operation.
    PviewTree()->BeginDrag();
    PviewList()->BeginDrag();

}  //*** CSplitterFrame::BeginDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnMouseMove
//
//  Routine Description:
//      Handler method for the WM_MOUSEMOVE message during a drag operation.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor in frame
//                      coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnMouseMove(UINT nFlags, CPoint point)
{
    // If we are dragging, move the drag image.
    if (BDragging())
    {
        CWnd *  pwndDrop;

        Trace(g_tagSplitFrameDragMouse, _T("OnMouseMove() - Moving to (%d,%d)"), point.x, point.y);

        // Move the item.
        ASSERT(Pimagelist() != NULL);
        VERIFY(Pimagelist()->DragMove(point));

        // Get the child window for this point.
        pwndDrop = ChildWindowFromPoint(point);
        if (pwndDrop == &m_wndSplitter)
            pwndDrop = m_wndSplitter.ChildWindowFromPoint(point);
        if ((pwndDrop == PviewTree()) || (pwndDrop == PviewList()))
            pwndDrop->SetFocus();
        PviewTree()->OnMouseMoveForDrag(nFlags, point, pwndDrop);
        PviewList()->OnMouseMoveForDrag(nFlags, point, pwndDrop);

    }  // if:  tree item is being dragged

    // Call the base class method.
    CMDIChildWnd::OnMouseMove(nFlags, point);

}  //*** CSplitterFrame::OnMouseMove()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnLButtonUp
//  CSplitterFrame::OnRButtonUp
//  CSplitterFrame::OnButtonUp
//
//  Routine Description:
//      Handler method for the WM_LBUTTONUP and WM_RBUTTONUP messages.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnLButtonUp(UINT nFlags, CPoint point)
{
    CMDIChildWnd::OnLButtonUp(nFlags, point);
    OnButtonUp(nFlags, point);

}  //*** CSplitterFrame::OnLButtonUp()

void CSplitterFrame::OnRButtonUp(UINT nFlags, CPoint point)
{
    CMDIChildWnd::OnRButtonUp(nFlags, point);
    OnButtonUp(nFlags, point);

}  //*** CSplitterFrame::OnRButtonUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnButtonUp
//
//  Routine Description:
//      Process a button up event by ending an active drag operation.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnButtonUp(UINT nFlags, CPoint point)
{
    // If we are dragging, process the drop.
    if (BDragging())
    {
        CWnd *          pwndChild;

        Trace(g_tagSplitFrameDrag, _T("OnButtonUp() - Dropping at (%d,%d)"), point.x, point.y);

        // Cleanup the image list.
        ASSERT(Pimagelist() != NULL);
        VERIFY(Pimagelist()->DragLeave(this));
        Pimagelist()->EndDrag();
        delete m_pimagelist;
        m_pimagelist = NULL;

        // Get the child window for this point.
        pwndChild = ChildWindowFromPoint(point);
        if (pwndChild == &m_wndSplitter)
            pwndChild = m_wndSplitter.ChildWindowFromPoint(point);
        if (pwndChild == PviewTree())
            PviewTree()->OnButtonUpForDrag(nFlags, point);
        else if (pwndChild == PviewList())
            PviewList()->OnButtonUpForDrag(nFlags, point);

        // Cleanup.
        PviewTree()->EndDrag();
        PviewList()->EndDrag();
        VERIFY(ReleaseCapture());
        m_bDragging = FALSE;
        m_pciDrag = NULL;
    }  // if:  tree item is being dragged

}  //*** CSplitterFrame::OnButtonUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::ChangeDragCursor
//
//  Routine Description:
//      Changes the cursor used for dragging.
//
//  Arguments:
//      pszCursor   [IN] System cursor to load.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::ChangeDragCursor(LPCTSTR pszCursor)
{
    HCURSOR hcurDrag = LoadCursor(NULL, pszCursor);
    ASSERT(hcurDrag != NULL);
    SetCursor(hcurDrag);
    Pimagelist()->SetDragCursorImage(0, CPoint(0, 0));  // define the hot spot for the new cursor image

}  //*** CSplitterFrame::ChangeDragCursor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::AbortDrag
//
//  Routine Description:
//      Abort the drag & drop operation currently in progress.
//
//  Arguments:
//      pszCursor   [IN] System cursor to load.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::AbortDrag(void)
{
    ASSERT(BDragging());

    Trace(g_tagSplitFrameDrag, _T("AbortDrag() - Aborting drag & drop"));

    // Cleanup the image list.
    ASSERT(Pimagelist() != NULL);
    VERIFY(Pimagelist()->DragLeave(this));
    Pimagelist()->EndDrag();
    delete m_pimagelist;
    m_pimagelist = NULL;

    // Cleanup.
    PviewTree()->EndDrag();
    PviewList()->EndDrag();
    VERIFY(ReleaseCapture());
    m_bDragging = FALSE;
    m_pciDrag = NULL;

}  //*** CSplitterFrame::AbortDrag()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\reswiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ResWiz.h
//
//	Abstract:
//		Definition of the CCreateResourceWizard class and all pages specific
//		to a new resource wizard.
//
//	Implementation File:
//		ResWiz.cpp
//
//	Author:
//		David Potter (davidp)	September 2, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESWIZ_H_
#define _RESWIZ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEWIZ_H_
#include "BaseWiz.h"	// for CBaseWizard
#endif

#ifndef _BASEWPAG_H_
#include "BaseWPag.h"	// for CBaseWizardPage
#endif

#ifndef _LCPRPAGE_H_
#include "LCPrWPag.h"	// for CListCtrlPairWizPage
#endif

#ifndef _RES_H_
#include "Res.h"		// for CResourceList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNewResNamePage;
class CCreateResourceWizard;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroup;
class CResource;
class CResourceType;
class CClusterDoc;

/////////////////////////////////////////////////////////////////////////////
// CNewResNamePage property page
/////////////////////////////////////////////////////////////////////////////

class CNewResNamePage : public CBaseWizardPage
{
	DECLARE_DYNCREATE(CNewResNamePage)

// Construction
public:
	CNewResNamePage(void);

// Dialog Data
	//{{AFX_DATA(CNewResNamePage)
	enum { IDD = IDD_WIZ_RESOURCE_NAME };
	CComboBox	m_cboxGroups;
	CComboBox	m_cboxResTypes;
	CEdit	m_editDesc;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strGroup;
	CString	m_strResType;
	BOOL	m_bSeparateMonitor;
	//}}AFX_DATA
	CResourceType *	m_pciResType;
	CGroup *		m_pciGroup;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewResNamePage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateResourceWizard *	PwizRes(void) const		{ return (CCreateResourceWizard *) Pwiz(); }

	// Generated message map functions
	//{{AFX_MSG(CNewResNamePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeResName();
	afx_msg void OnKillFocusResName();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewResNamePage

/////////////////////////////////////////////////////////////////////////////
// CNewResOwnersPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNewResOwnersPage : public CListCtrlPairWizPage
{
	DECLARE_DYNCREATE(CNewResOwnersPage)

// Construction
public:
	CNewResOwnersPage(void);

// Dialog Data
	//{{AFX_DATA(CNewResOwnersPage)
	enum { IDD = IDD_WIZ_POSSIBLE_OWNERS };
	CStatic	m_staticNote;
	//}}AFX_DATA

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewResOwnersPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateResourceWizard *	PwizRes(void) const		{ return (CCreateResourceWizard *) Pwiz(); }
	CResource *				PciRes(void) const;

	BOOL					BInitLists(void);
	BOOL					BOwnedByPossibleOwner(void) const;

	// Generated message map functions
	//{{AFX_MSG(CNewResOwnersPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewResOwnersPage

/////////////////////////////////////////////////////////////////////////////
// CNewResDependsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNewResDependsPage : public CListCtrlPairWizPage
{
	DECLARE_DYNCREATE(CNewResDependsPage)

// Construction
public:
	CNewResDependsPage(void);

// Dialog Data
	//{{AFX_DATA(CNewResDependsPage)
	enum { IDD = IDD_WIZ_DEPENDENCIES };
	//}}AFX_DATA
	CResourceList			m_lpciresAvailable;

	CResourceList &			LpciresAvailable(void)	{ return m_lpciresAvailable; }

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewResDependsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateResourceWizard *	PwizRes(void) const		{ return (CCreateResourceWizard *) Pwiz(); }
	CResource *				PciRes(void) const;
	CGroup *				PciGroup(void) const;

	BOOL					BInitLists(void);

	// Generated message map functions
	//{{AFX_MSG(CNewResDependsPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewResDependsPage

/////////////////////////////////////////////////////////////////////////////
// CCreateResourceWizard
/////////////////////////////////////////////////////////////////////////////

class CCreateResourceWizard : public CBaseWizard
{
	friend class CNewResNamePage;
	friend class CNewResOwnersPage;
	friend class CNewResDependsPage;

	DECLARE_DYNAMIC(CCreateResourceWizard)

// Construction
public:
	CCreateResourceWizard(IN OUT CClusterDoc * pdoc, IN OUT CWnd * pParentWnd);
	virtual				~CCreateResourceWizard(void);

	BOOL				BInit(void);

// Attributes
protected:
	enum { NumStdPages = 3 };
	CWizPage			m_rgpages[NumStdPages];

	CClusterDoc *		m_pdoc;
	CString				m_strName;
	CString				m_strDescription;
	CStringList			m_lstrPossibleOwners;
	CResourceType *		m_pciResType;
	CGroup *			m_pciGroup;

public:
	CClusterDoc *		Pdoc(void) const				{ return m_pdoc; }
	const CString &		StrName(void) const				{ return m_strName; }
	const CString &		StrDescription(void) const		{ return m_strDescription; }
	const CStringList &	LstrPossibleOwners(void) const	{ return m_lstrPossibleOwners; }
	CGroup *			PciGroup(void) const			{ return m_pciGroup; }
	CResourceType *		PciResType(void) const			{ return m_pciResType; }

// Operations
public:
	BOOL				BSetRequiredFields(
							IN const CString &	rstrName,
							IN CResourceType *	pciResType,
							IN CGroup *			pciGroup,
							IN BOOL				bSeparateMonitor,
							IN const CString &	rstrDesc
							);

// Overrides
protected:
	virtual void		OnWizardFinish(void);
	virtual void		OnCancel(void);
	virtual CWizPage *	Ppages(void);
	virtual int			Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateResourceWizard)
	//}}AFX_VIRTUAL

// Implementation
public:

protected:
	CNewResNamePage		m_pageName;
	CNewResOwnersPage	m_pageOwners;
	CNewResDependsPage	m_pageDependencies;
	CResource *			m_pciRes;
	BOOL				m_bCreated;

	CResource *			PciRes(void) const				{ return m_pciRes; }
	BOOL				BCreated(void) const			{ return m_bCreated; }


	// Generated message map functions
protected:
	//{{AFX_MSG(CCreateResourceWizard)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CCreateResourceWizard

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline CResource * CNewResOwnersPage::PciRes(void) const
{
	ASSERT_VALID(PwizRes());
	return PwizRes()->PciRes();
}

inline CResource * CNewResDependsPage::PciRes(void) const
{
	ASSERT_VALID(PwizRes());
	return PwizRes()->PciRes();
}

inline CGroup * CNewResDependsPage::PciGroup(void) const
{
	ASSERT_VALID(PwizRes());
	return PwizRes()->PciGroup();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _RESWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\splitfrm.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		SplitFrm.h
//
//	Abstract:
//		Definition of the CSplitterFrame class.
//
//	ImplementationFile:
//		SplitFrm.cpp
//
//	Author:
//		David Potter (davidp)	May 1, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SPLITFRM_H_
#define _SPLITFRM_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CSplitterFrame;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterTreeView;
class CClusterListView;
class CClusterItem;
class CExtensions;
class CTreeItem;

/////////////////////////////////////////////////////////////////////////////
// CSplitterFrame
/////////////////////////////////////////////////////////////////////////////

class CSplitterFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CSplitterFrame)
public:
	CSplitterFrame();

// Attributes
protected:
	CSplitterWnd		m_wndSplitter;
	CClusterDoc *		m_pdoc;
	int					m_iFrame;

	BOOL				m_bDragging;
	CImageList *		m_pimagelist;
	CClusterItem *		m_pciDrag;

public:
	CClusterDoc *		Pdoc(void) const			{ return m_pdoc; }
	int					NFrameNumber(void) const	{ return m_iFrame; }

	BOOL				BDragging(void) const		{ return m_bDragging; }
	CImageList *		Pimagelist(void) const		{ return m_pimagelist; }
	CClusterItem *		PciDrag(void) const			{ return m_pciDrag; }

// Operations
public:
	CClusterTreeView *	PviewTree(void) const		{ return (CClusterTreeView *) m_wndSplitter.GetPane(0, 0); }
	CClusterListView *	PviewList(void)const		{ return (CClusterListView *) m_wndSplitter.GetPane(0, 1); }

	void				CalculateFrameNumber();
	void				InitFrame(IN OUT CClusterDoc * pdoc);
	void				ConstructProfileValueName(
							OUT CString &	rstrName,
							IN LPCTSTR		pszPrefix
							) const;

	void				BeginDrag(
							IN OUT CImageList *		pimagelist,
							IN OUT CClusterItem *	pci,
							IN CPoint				ptImage,
							IN CPoint				ptStart
							);
	void				ChangeDragCursor(LPCTSTR pszCursor);
	void				AbortDrag(void);

	// For customizing the default messages on the status bar
	virtual void		GetMessageString(UINT nID, CString& rMessage) const;

protected:
	CMenu *				PmenuPopup(void) const;
	void				Cleanup(void);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSplitterFrame)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSplitterFrame(void);
#ifdef _DEBUG
	virtual void AssertValid(void) const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	CExtensions *		m_pext;
	CExtensions *		Pext(void) const			{ return m_pext; }

	void				OnButtonUp(UINT nFlags, CPoint point);

// Generated message map functions
protected:
	//{{AFX_MSG(CSplitterFrame)
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnUpdateLargeIconsView(CCmdUI* pCmdUI);
	afx_msg void OnUpdateSmallIconsView(CCmdUI* pCmdUI);
	afx_msg void OnUpdateListView(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDetailsView(CCmdUI* pCmdUI);
	afx_msg void OnLargeIconsView();
	afx_msg void OnSmallIconsView();
	afx_msg void OnListView();
	afx_msg void OnDetailsView();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
#ifdef _DEBUG
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
#endif
	afx_msg void OnUpdateExtMenu(CCmdUI* pCmdUI);
	afx_msg LRESULT	OnUnloadExtension(WPARAM wparam, LPARAM lparam);
	DECLARE_MESSAGE_MAP()

};  //*** class CSplitterFrame

/////////////////////////////////////////////////////////////////////////////

#endif // _SPLITFRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\tracedlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      TraceDlg.h
//
//  Abstract:
//      Definition of the CTraceDialog class.
//
//  Implementation File:
//      TraceDlg.cpp
//
//  Author:
//      David Potter (davidp)   May 29, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACEDLG_H_
#define _TRACEDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceDialog;
#endif

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#include "TraceTag.h"   // for CTraceTag
#endif

/////////////////////////////////////////////////////////////////////////////
// CTraceDialog dialog
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceDialog : public CDialog
{
// Construction
public:
    CTraceDialog(CWnd * pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CTraceDialog)
    enum { IDD = IDD_TRACE_SETTINGS };
    CListCtrl   m_lcTagList;
    CButton m_chkboxTraceToDebugWin;
    CButton m_chkboxDebugBreak;
    CButton m_chkboxTraceToCom2;
    CButton m_chkboxTraceToFile;
    CEdit   m_editFile;
    CComboBox   m_cboxDisplayOptions;
    CString m_strFile;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CTraceDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    static int CALLBACK CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);
    static void         ConstructStateString(IN const CTraceTag * ptag, OUT CString & rstr);

    void                OnSelChangedListbox(void);
    void                AdjustButton(IN BOOL bEnable, IN OUT CButton & rchkbox, IN int nState);
    void                ChangeState(IN OUT CButton & rchkbox, IN CTraceTag::TraceFlags tfMask);
    void                LoadListbox(void);
    BOOL                BDisplayTag(IN const CTraceTag * ptag);

    int                 m_nCurFilter;
    int                 m_nSortDirection;
    int                 m_nSortColumn;

    int                 NSortDirection(void)        { return m_nSortDirection; }
    int                 NSortColumn(void)           { return m_nSortColumn; }

    // Generated message map functions
    //{{AFX_MSG(CTraceDialog)
    afx_msg void OnSelectAll();
    afx_msg void OnItemChangedListbox(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnClickedTraceToDebug();
    afx_msg void OnClickedTraceDebugBreak();
    afx_msg void OnClickedTraceToCom2();
    afx_msg void OnClickedTraceToFile();
    afx_msg void OnSelChangeTagsToDisplay();
    afx_msg void OnColumnClickListbox(NMHDR* pNMHDR, LRESULT* pResult);
    virtual void OnOK();
    afx_msg void OnDefault();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CTraceDialog
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\tracetag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      TraceTag.cpp
//
//  Abstract:
//      Implementation of the CTraceTag class.
//
//  Author:
//      David Potter (davidp)   May 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <winnls.h>
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef  _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CTraceTag   g_tagAlways(_T("Debug"), _T("Always"), CTraceTag::tfDebug);
CTraceTag   g_tagError(_T("Debug"), _T("Error"), CTraceTag::tfDebug);

// g_pszTraceIniFile must be an LPTSTR so it exists before "{" of WinMain.
// If we make it a CString, it may not be constructed when some of the
// tags are constructed, so we won't restore their value.
//LPTSTR        g_pszTraceIniFile       = _T("Trace.INI");
CString     g_strTraceFile;
BOOL        g_bBarfDebug            = TRUE;

CRITICAL_SECTION    CTraceTag::s_critsec;
BOOL                CTraceTag::s_bCritSecValid = FALSE;

#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTraceTag
/////////////////////////////////////////////////////////////////////////////

#ifdef  _DEBUG

//  Static Variables...

CTraceTag *     CTraceTag::s_ptagFirst  = NULL;
CTraceTag *     CTraceTag::s_ptagLast   = NULL;
//HANDLE            CTraceTag::s_hfileCom2  = NULL;
LPCTSTR         CTraceTag::s_pszCom2    = _T(" com2 ");
LPCTSTR         CTraceTag::s_pszFile    = _T(" file ");
LPCTSTR         CTraceTag::s_pszDebug   = _T(" debug ");
LPCTSTR         CTraceTag::s_pszBreak   = _T(" break ");

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::CTraceTag
//
//  Routine Description:
//      Constructor.  "Initializes" the tag by giving it its name, giving
//      it a startup value (from the registry if possible), and adding it
//      to the list of current tags.
//
//  Arguments:
//      pszSubsystem    [IN] 8 char string to say to what the tag applies
//      pszName         [IN] Description of the tag (~30 chars)
//      uiFlagsDefault  [IN] Default value.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::CTraceTag(
    IN LPCTSTR  pszSubsystem,
    IN LPCTSTR  pszName,
    IN UINT     uiFlagsDefault
    )
{
    //  Store the calling parameters
    m_pszSubsystem = pszSubsystem;
    m_pszName = pszName;
    m_uiFlagsDefault = uiFlagsDefault;
    m_uiFlags = uiFlagsDefault;

    //  Add the tag to the list of tags
    if (s_ptagLast != NULL)
        s_ptagLast->m_ptagNext = this;
    else
        s_ptagFirst = this;

    s_ptagLast = this;
    m_ptagNext = NULL;

    m_uiFlags = 0;

}  //*** CTraceTag::CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::~CTraceTag
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::~CTraceTag(void)
{
#ifdef NEVER
    if (s_hfileCom2 && (s_hfileCom2 != INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(s_hfileCom2);
        s_hfileCom2 = NULL;
    }
#endif

}  //*** CTraceTag::~CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::Init
//
//  Routine Description:
//      Initializes the tag by giving it its name and giving it a startup value
//      (from the registry if possible).
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::Init(void)
{
    CString     strSection;
    CString     strValue;

    //  Get the value from the Registry.
    strSection.Format(TRACE_TAG_REG_SECTION_FMT, m_pszSubsystem);
    strValue = AfxGetApp()->GetProfileString(strSection, m_pszName, 0);
    strValue.MakeLower();
    if (strValue.Find(s_pszCom2) != -1)
        m_uiFlags |= tfCom2;
    if (strValue.Find(s_pszFile) != -1)
        m_uiFlags |= tfFile;
    if (strValue.Find(s_pszDebug) != -1)
        m_uiFlags |= tfDebug;
    if (strValue.Find(s_pszBreak) != -1)
        m_uiFlags |= tfBreak;

}  //*** CTraceTag::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::ConstructRegState
//
//  Routine Description:
//      Constructs the registry state string.
//
//  Arguments:
//      rstr        [OUT] String in which to return the state string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::ConstructRegState(OUT CString & rstr)
{
    rstr = "";
    if (BDebug())
        rstr += s_pszDebug;
    if (BBreak())
        rstr += s_pszBreak;
    if (BCom2())
        rstr += s_pszCom2;
    if (BFile())
        rstr += s_pszFile;

}  //*** CTraceTag::ConstructRegState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::SetFlags
//
//  Routine Description:
//      Sets/Resets TraceFlags.
//
//  Arguments:
//      tf          [IN] Flags to set.
//      bEnable     [IN] TRUE = set the flags, FALSE = clear the flags.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlags(IN UINT tf, IN BOOL bEnable)
{
    if (bEnable)
        m_uiFlags |= tf;
    else
        m_uiFlags &= ~tf;

}  //*** CTraceTag::SetFlags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::SetFlagsDialog
//
//  Routine Description:
//      Sets/Resets the "Dialog Settings"  version of the TraceFlags.
//
//  Arguments:
//      tf          [IN] Flags to set.
//      bEnable     [IN] TRUE = set the flags, FALSE = clear the flags.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlagsDialog(IN UINT tf, IN BOOL bEnable)
{
    if (bEnable)
        m_uiFlagsDialog |= tf;
    else
        m_uiFlagsDialog &= ~tf;

}  //*** CTraceTag::SetFlagsDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::PszFile
//
//  Routine Description:
//      Returns the name of the file where to write the trace output.
//      The filename is read from the registry if it is unknown.
//
//  Arguments:
//      None.
//
//  Return Value:
//      psz     Name of the file.
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CTraceTag::PszFile(void)
{
    static  BOOL    bInitialized    = FALSE;

    if (!bInitialized)
    {
        g_strTraceFile = AfxGetApp()->GetProfileString(
                                        TRACE_TAG_REG_SECTION,
                                        TRACE_TAG_REG_FILE,
                                        _T("C:\\Trace.out")
                                        );
#ifdef NEVER
        ::GetPrivateProfileString(
            _T("Trace File"),
            _T("Trace File"),
            _T("\\Trace.OUT"),
            g_strTraceFile.Sz(),
            g_strTraceFile.CchMac(),
            g_pszTraceIniFile
            );
#endif
        bInitialized = TRUE;
    }

    return g_strTraceFile;

}  //*** CTraceTag::PszFile()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::TraceV
//
//  Routine Description:
//      Processes a Trace statement based on the flags of the tag.
//
//  Arguments:
//      pszFormat   [IN] printf-style format string.
//      va_list     [IN] Argument block for the format string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::TraceV(IN LPCTSTR pszFormat, va_list marker)
{
    CString     strTraceMsg;
    LPSTR       psz;
    CB          cb;
    CB          cbActual;
    
    // Get out quick with any formats if we're not turned on
    if (!m_pszName || !BAny())
        return;

    if (BCritSecValid())
        EnterCriticalSection(&s_critsec);

    FormatV(pszFormat, marker);
    strTraceMsg.Format(_T("%s: %s\x0D\x0A"), m_pszName, m_pchData);

    // Send trace output to the debug window.
    if (BDebug())
        OutputDebugString(strTraceMsg);

    if (BCom2() || BFile())
    {
#ifdef _UNICODE
        // Not much point in sending UNICODE output to COMM or file at the moment,
        // so convert to ANSI
        CHAR    aszTraceMsg[256];
        cb = ::WideCharToMultiByte(
                    CP_ANSI,
                    NULL,
                    strTraceMsg,
                    strTraceMsg.GetLength(),
                    aszTraceMsg,
                    sizeof(aszTraceMsg),
                    NULL,
                    NULL
                    );
        psz = aszTraceMsg;
#else
        cb = strTraceMsg.GetLength();
        psz = (LPSTR) (LPCSTR) strTraceMsg;
#endif

        // Send trace output to COM2.
        if (BCom2())
        {
            HANDLE          hfile           = INVALID_HANDLE_VALUE;
            static  BOOL    bOpenFailed     = FALSE;

            if (!bOpenFailed)
            {
                hfile = ::CreateFile(
                                _T("COM2:"),
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_WRITE_THROUGH,
                                NULL
                                );
            }  // if:  not currently in a 'COM2 failed to open' state
            
            if (hfile != INVALID_HANDLE_VALUE)
            {
                ASSERT(::WriteFile(hfile, psz, cb, (LPDWORD) &cbActual, NULL));
//              ASSERT(::FlushFileBuffers(hfile));
                ASSERT(::CloseHandle(hfile));
            }  // if:  COM2 opened successfully
            else
            {
                if (!bOpenFailed)
                {
                    bOpenFailed = TRUE;     // Do this first, so the str.Format
                                            // do not cause problems with their trace statement.

                    AfxMessageBox(_T("COM2 could not be opened."), MB_OK | MB_ICONINFORMATION);
                }  // if:  open file didn't fail
            }  // else:  file not opened successfully
        }  // if:  sending trace output to COM2

        // Send trace output to a file.
        if (BFile())
        {
            HANDLE          hfile           = INVALID_HANDLE_VALUE;
            static  BOOL    bOpenFailed     = FALSE;

            if (!bOpenFailed)
            {
                hfile = ::CreateFile(
                                PszFile(),
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_FLAG_WRITE_THROUGH,
                                NULL
                                );
            }  // if:  not currently in a 'file failed to open' state

            if (hfile != INVALID_HANDLE_VALUE)
            {
                // Fail these calls silently to avoid recursive failing calls.
                ::SetFilePointer(hfile, NULL, NULL, FILE_END);
                ::WriteFile(hfile, psz, cb, (LPDWORD) &cbActual, NULL);
                ::CloseHandle(hfile);
            }  // if:  file opened successfully
            else
            {
                if (!bOpenFailed)
                {
                    CString     strMsg;

                    bOpenFailed = TRUE;     // Do this first, so the str.Format
                                            // do not cause problems with their trace statement.

                    strMsg.Format(_T("The DEBUG ONLY trace log file '%s' could not be opened"), PszFile());
                    AfxMessageBox(strMsg, MB_OK | MB_ICONINFORMATION);
                }  // if:  open file didn't fail
            }  // else:  file not opened successfully
        }  // if:  sending trace output to a file
    }  // if:  tracing to com and/or file

    // Do a DebugBreak on the trace.
    if (BBreak())
        DebugBreak();

    if (BCritSecValid())
        LeaveCriticalSection(&s_critsec);

}  //*** CTraceTag::TraceFn()

#endif // _DEBUG


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#ifdef  _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  Trace
//
//  Routine Description:
//      Maps the Trace statement to the proper method call.  This is needed
//      (instead of doing directly ptag->Trace()) to guarantee that no code
//      is added in the retail build.
//
//  Arguments:
//      rtag        [IN OUT] Tag controlling the debug output
//      pszFormat   [IN] printf style formatting string.
//      ...         [IN] printf style parameters, depends on pszFormat
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void __cdecl Trace(IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ...)
{
    va_list     marker;

    va_start(marker, pszFormat);
    rtag.TraceV(pszFormat, marker);
    va_end(marker);

}  //*** Trace()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceError
//
//  Routine Description:
//      Formats a standard error string and outputs it to all trace outputs.
//
//  Arguments:
//      rexcept     [IN OUT] Exception from which to obtain the message.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError(IN OUT CException & rexcept)
{
    TCHAR           szMessage[1024];

    rexcept.GetErrorMessage(szMessage, sizeof(szMessage) / sizeof(TCHAR));

    Trace(
        g_tagError,
        _T("EXCEPTION: %s"),
        szMessage
        );

}  //*** TraceError(CException&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceError
//
//  Routine Description:
//      Formats a standard error string and outputs it to all trace outputs.
//
//  Arguments:
//      pszModule   [IN] Name of module in which error occurred.
//      sc          [IN] NT status code.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError(IN LPCTSTR pszModule, IN SC sc)
{
    TCHAR           szMessage[1024];
    CNTException    nte(sc);

    nte.GetErrorMessage(szMessage, sizeof(szMessage) / sizeof(TCHAR));

    Trace(
        g_tagError,
        _T("Module %s, SC = %#08lX = %d (10)\r\n = '%s'"),
        pszModule,
        sc,
        sc,
        szMessage
        );

}  //*** TraceError(pszModule, sc)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  InitAllTraceTags
//
//  Routine Description:
//      Initializes all trace tags in the tag list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void InitAllTraceTags(void)
{
    CTraceTag * ptag;

    // Loop through the tag list.
    for (ptag = CTraceTag::s_ptagFirst ; ptag != NULL ; ptag = ptag->m_ptagNext)
        ptag->Init();

    InitializeCriticalSection(&CTraceTag::s_critsec);
    CTraceTag::s_bCritSecValid = TRUE;

}  //*** InitAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CleanupAllTraceTags
//
//  Routine Description:
//      Cleanup after the trace tags.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupAllTraceTags(void)
{
    if (CTraceTag::BCritSecValid())
    {
        DeleteCriticalSection(&CTraceTag::s_critsec);
        CTraceTag::s_bCritSecValid = FALSE;
    }  // if:  critical section is valid

}  //*** CleanupAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceMenu
//
//  Routine Description:
//      Display information about menus.
//
//  Arguments:
//      rtag        [IN OUT] Trace tag to use to display information.
//      pmenu       [IN] Menu to traverse.
//      pszPrefix   [IN] Prefix string to display.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceMenu(
    IN OUT CTraceTag &  rtag,
    IN const CMenu *    pmenu,
    IN LPCTSTR          pszPrefix
    )
{
    if (rtag.BAny())
    {
        UINT    cItems;
        UINT    iItem;
        UINT    nState;
        CString strMenu;
        CString strPrefix(pszPrefix);
        
        strPrefix += _T("->");

        cItems = pmenu->GetMenuItemCount();
        for (iItem = 0 ; iItem < cItems ; iItem++)
        {
            pmenu->GetMenuString(iItem, strMenu, MF_BYPOSITION);
            nState = pmenu->GetMenuState(iItem, MF_BYPOSITION);
            if (nState & MF_SEPARATOR)
                strMenu += _T("SEPARATOR");
            if (nState & MF_CHECKED)
                strMenu += _T(" (checked)");
            if (nState & MF_DISABLED)
                strMenu += _T(" (disabled)");
            if (nState & MF_GRAYED)
                strMenu += _T(" (grayed)");
            if (nState & MF_MENUBARBREAK)
                strMenu += _T(" (MenuBarBreak)");
            if (nState & MF_MENUBREAK)
                strMenu += _T(" (MenuBreak)");
            if (nState & MF_POPUP)
                strMenu += _T(" (popup)");

            Trace(rtag, _T("(0x%08.8x) %s%s"), pszPrefix, pmenu->m_hMenu, strMenu);

            if (nState & MF_POPUP)
                TraceMenu(rtag, pmenu->GetSubMenu(iItem), strPrefix);
        }  // for:  each item in the menu
    }  // if:  any output is enabled

}  //*** TraceMenu()

struct AFX_MAP_MESSAGE
{
    UINT    nMsg;
    LPCSTR  lpszMsg;
};

#include "dde.h"
#define DEFINE_MESSAGE(wm)  { wm, #wm }

static const AFX_MAP_MESSAGE allMessages[] =
{
    DEFINE_MESSAGE(WM_CREATE),
    DEFINE_MESSAGE(WM_DESTROY),
    DEFINE_MESSAGE(WM_MOVE),
    DEFINE_MESSAGE(WM_SIZE),
    DEFINE_MESSAGE(WM_ACTIVATE),
    DEFINE_MESSAGE(WM_SETFOCUS),
    DEFINE_MESSAGE(WM_KILLFOCUS),
    DEFINE_MESSAGE(WM_ENABLE),
    DEFINE_MESSAGE(WM_SETREDRAW),
    DEFINE_MESSAGE(WM_SETTEXT),
    DEFINE_MESSAGE(WM_GETTEXT),
    DEFINE_MESSAGE(WM_GETTEXTLENGTH),
    DEFINE_MESSAGE(WM_PAINT),
    DEFINE_MESSAGE(WM_CLOSE),
    DEFINE_MESSAGE(WM_QUERYENDSESSION),
    DEFINE_MESSAGE(WM_QUIT),
    DEFINE_MESSAGE(WM_QUERYOPEN),
    DEFINE_MESSAGE(WM_ERASEBKGND),
    DEFINE_MESSAGE(WM_SYSCOLORCHANGE),
    DEFINE_MESSAGE(WM_ENDSESSION),
    DEFINE_MESSAGE(WM_SHOWWINDOW),
    DEFINE_MESSAGE(WM_CTLCOLORMSGBOX),
    DEFINE_MESSAGE(WM_CTLCOLOREDIT),
    DEFINE_MESSAGE(WM_CTLCOLORLISTBOX),
    DEFINE_MESSAGE(WM_CTLCOLORBTN),
    DEFINE_MESSAGE(WM_CTLCOLORDLG),
    DEFINE_MESSAGE(WM_CTLCOLORSCROLLBAR),
    DEFINE_MESSAGE(WM_CTLCOLORSTATIC),
    DEFINE_MESSAGE(WM_WININICHANGE),
    DEFINE_MESSAGE(WM_DEVMODECHANGE),
    DEFINE_MESSAGE(WM_ACTIVATEAPP),
    DEFINE_MESSAGE(WM_FONTCHANGE),
    DEFINE_MESSAGE(WM_TIMECHANGE),
    DEFINE_MESSAGE(WM_CANCELMODE),
    DEFINE_MESSAGE(WM_SETCURSOR),
    DEFINE_MESSAGE(WM_MOUSEACTIVATE),
    DEFINE_MESSAGE(WM_CHILDACTIVATE),
    DEFINE_MESSAGE(WM_QUEUESYNC),
    DEFINE_MESSAGE(WM_GETMINMAXINFO),
    DEFINE_MESSAGE(WM_ICONERASEBKGND),
    DEFINE_MESSAGE(WM_NEXTDLGCTL),
    DEFINE_MESSAGE(WM_SPOOLERSTATUS),
    DEFINE_MESSAGE(WM_DRAWITEM),
    DEFINE_MESSAGE(WM_MEASUREITEM),
    DEFINE_MESSAGE(WM_DELETEITEM),
    DEFINE_MESSAGE(WM_VKEYTOITEM),
    DEFINE_MESSAGE(WM_CHARTOITEM),
    DEFINE_MESSAGE(WM_SETFONT),
    DEFINE_MESSAGE(WM_GETFONT),
    DEFINE_MESSAGE(WM_QUERYDRAGICON),
    DEFINE_MESSAGE(WM_COMPAREITEM),
    DEFINE_MESSAGE(WM_COMPACTING),
    DEFINE_MESSAGE(WM_NCCREATE),
    DEFINE_MESSAGE(WM_NCDESTROY),
    DEFINE_MESSAGE(WM_NCCALCSIZE),
    DEFINE_MESSAGE(WM_NCHITTEST),
    DEFINE_MESSAGE(WM_NCPAINT),
    DEFINE_MESSAGE(WM_NCACTIVATE),
    DEFINE_MESSAGE(WM_GETDLGCODE),
    DEFINE_MESSAGE(WM_NCMOUSEMOVE),
    DEFINE_MESSAGE(WM_NCLBUTTONDOWN),
    DEFINE_MESSAGE(WM_NCLBUTTONUP),
    DEFINE_MESSAGE(WM_NCLBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_NCRBUTTONDOWN),
    DEFINE_MESSAGE(WM_NCRBUTTONUP),
    DEFINE_MESSAGE(WM_NCRBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_NCMBUTTONDOWN),
    DEFINE_MESSAGE(WM_NCMBUTTONUP),
    DEFINE_MESSAGE(WM_NCMBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_KEYDOWN),
    DEFINE_MESSAGE(WM_KEYUP),
    DEFINE_MESSAGE(WM_CHAR),
    DEFINE_MESSAGE(WM_DEADCHAR),
    DEFINE_MESSAGE(WM_SYSKEYDOWN),
    DEFINE_MESSAGE(WM_SYSKEYUP),
    DEFINE_MESSAGE(WM_SYSCHAR),
    DEFINE_MESSAGE(WM_SYSDEADCHAR),
    DEFINE_MESSAGE(WM_KEYLAST),
    DEFINE_MESSAGE(WM_INITDIALOG),
    DEFINE_MESSAGE(WM_COMMAND),
    DEFINE_MESSAGE(WM_SYSCOMMAND),
    DEFINE_MESSAGE(WM_TIMER),
    DEFINE_MESSAGE(WM_HSCROLL),
    DEFINE_MESSAGE(WM_VSCROLL),
    DEFINE_MESSAGE(WM_INITMENU),
    DEFINE_MESSAGE(WM_INITMENUPOPUP),
    DEFINE_MESSAGE(WM_MENUSELECT),
    DEFINE_MESSAGE(WM_MENUCHAR),
    DEFINE_MESSAGE(WM_ENTERIDLE),
    DEFINE_MESSAGE(WM_MOUSEMOVE),
    DEFINE_MESSAGE(WM_LBUTTONDOWN),
    DEFINE_MESSAGE(WM_LBUTTONUP),
    DEFINE_MESSAGE(WM_LBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_RBUTTONDOWN),
    DEFINE_MESSAGE(WM_RBUTTONUP),
    DEFINE_MESSAGE(WM_RBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_MBUTTONDOWN),
    DEFINE_MESSAGE(WM_MBUTTONUP),
    DEFINE_MESSAGE(WM_MBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_PARENTNOTIFY),
    DEFINE_MESSAGE(WM_MDICREATE),
    DEFINE_MESSAGE(WM_MDIDESTROY),
    DEFINE_MESSAGE(WM_MDIACTIVATE),
    DEFINE_MESSAGE(WM_MDIRESTORE),
    DEFINE_MESSAGE(WM_MDINEXT),
    DEFINE_MESSAGE(WM_MDIMAXIMIZE),
    DEFINE_MESSAGE(WM_MDITILE),
    DEFINE_MESSAGE(WM_MDICASCADE),
    DEFINE_MESSAGE(WM_MDIICONARRANGE),
    DEFINE_MESSAGE(WM_MDIGETACTIVE),
    DEFINE_MESSAGE(WM_MDISETMENU),
    DEFINE_MESSAGE(WM_CUT),
    DEFINE_MESSAGE(WM_COPY),
    DEFINE_MESSAGE(WM_PASTE),
    DEFINE_MESSAGE(WM_CLEAR),
    DEFINE_MESSAGE(WM_UNDO),
    DEFINE_MESSAGE(WM_RENDERFORMAT),
    DEFINE_MESSAGE(WM_RENDERALLFORMATS),
    DEFINE_MESSAGE(WM_DESTROYCLIPBOARD),
    DEFINE_MESSAGE(WM_DRAWCLIPBOARD),
    DEFINE_MESSAGE(WM_PAINTCLIPBOARD),
    DEFINE_MESSAGE(WM_VSCROLLCLIPBOARD),
    DEFINE_MESSAGE(WM_SIZECLIPBOARD),
    DEFINE_MESSAGE(WM_ASKCBFORMATNAME),
    DEFINE_MESSAGE(WM_CHANGECBCHAIN),
    DEFINE_MESSAGE(WM_HSCROLLCLIPBOARD),
    DEFINE_MESSAGE(WM_QUERYNEWPALETTE),
    DEFINE_MESSAGE(WM_PALETTEISCHANGING),
    DEFINE_MESSAGE(WM_PALETTECHANGED),
    DEFINE_MESSAGE(WM_DDE_INITIATE),
    DEFINE_MESSAGE(WM_DDE_TERMINATE),
    DEFINE_MESSAGE(WM_DDE_ADVISE),
    DEFINE_MESSAGE(WM_DDE_UNADVISE),
    DEFINE_MESSAGE(WM_DDE_ACK),
    DEFINE_MESSAGE(WM_DDE_DATA),
    DEFINE_MESSAGE(WM_DDE_REQUEST),
    DEFINE_MESSAGE(WM_DDE_POKE),
    DEFINE_MESSAGE(WM_DDE_EXECUTE),
    DEFINE_MESSAGE(WM_DROPFILES),
    DEFINE_MESSAGE(WM_POWER),
    DEFINE_MESSAGE(WM_WINDOWPOSCHANGED),
    DEFINE_MESSAGE(WM_WINDOWPOSCHANGING),
// MFC specific messages
    DEFINE_MESSAGE(WM_SIZEPARENT),
    DEFINE_MESSAGE(WM_SETMESSAGESTRING),
    DEFINE_MESSAGE(WM_IDLEUPDATECMDUI),
    DEFINE_MESSAGE(WM_INITIALUPDATE),
    DEFINE_MESSAGE(WM_COMMANDHELP),
    DEFINE_MESSAGE(WM_HELPHITTEST),
    DEFINE_MESSAGE(WM_EXITHELPMODE),
    DEFINE_MESSAGE(WM_HELP),
    DEFINE_MESSAGE(WM_NOTIFY),
    DEFINE_MESSAGE(WM_CONTEXTMENU),
    DEFINE_MESSAGE(WM_TCARD),
    DEFINE_MESSAGE(WM_MDIREFRESHMENU),
    DEFINE_MESSAGE(WM_MOVING),
    DEFINE_MESSAGE(WM_STYLECHANGED),
    DEFINE_MESSAGE(WM_STYLECHANGING),
    DEFINE_MESSAGE(WM_SIZING),
    DEFINE_MESSAGE(WM_SETHOTKEY),
    DEFINE_MESSAGE(WM_PRINT),
    DEFINE_MESSAGE(WM_PRINTCLIENT),
    DEFINE_MESSAGE(WM_POWERBROADCAST),
    DEFINE_MESSAGE(WM_HOTKEY),
    DEFINE_MESSAGE(WM_GETICON),
    DEFINE_MESSAGE(WM_EXITMENULOOP),
    DEFINE_MESSAGE(WM_ENTERMENULOOP),
    DEFINE_MESSAGE(WM_DISPLAYCHANGE),
    DEFINE_MESSAGE(WM_STYLECHANGED),
    DEFINE_MESSAGE(WM_STYLECHANGING),
    DEFINE_MESSAGE(WM_GETICON),
    DEFINE_MESSAGE(WM_SETICON),
    DEFINE_MESSAGE(WM_SIZING),
    DEFINE_MESSAGE(WM_MOVING),
    DEFINE_MESSAGE(WM_CAPTURECHANGED),
    DEFINE_MESSAGE(WM_DEVICECHANGE),
    DEFINE_MESSAGE(WM_PRINT),
    DEFINE_MESSAGE(WM_PRINTCLIENT),
// MFC private messages
    DEFINE_MESSAGE(WM_QUERYAFXWNDPROC),
    DEFINE_MESSAGE(WM_RECALCPARENT),
    DEFINE_MESSAGE(WM_SIZECHILD),
    DEFINE_MESSAGE(WM_KICKIDLE),
    DEFINE_MESSAGE(WM_QUERYCENTERWND),
    DEFINE_MESSAGE(WM_DISABLEMODAL),
    DEFINE_MESSAGE(WM_FLOATSTATUS),
    DEFINE_MESSAGE(WM_ACTIVATETOPLEVEL),
    DEFINE_MESSAGE(WM_QUERY3DCONTROLS),
    DEFINE_MESSAGE(WM_RESERVED_0370),
    DEFINE_MESSAGE(WM_RESERVED_0371),
    DEFINE_MESSAGE(WM_RESERVED_0372),
    DEFINE_MESSAGE(WM_SOCKET_NOTIFY),
    DEFINE_MESSAGE(WM_SOCKET_DEAD),
    DEFINE_MESSAGE(WM_POPMESSAGESTRING),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTREAM),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTORAGE),
    DEFINE_MESSAGE(WM_OCC_INITNEW),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTREAM_EX),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTORAGE_EX),
    DEFINE_MESSAGE(WM_QUEUE_SENTINEL),
    DEFINE_MESSAGE(WM_RESERVED_037C),
    DEFINE_MESSAGE(WM_RESERVED_037D),
    DEFINE_MESSAGE(WM_RESERVED_037E),
    { 0, NULL, }    // end of message list
};

#undef DEFINE_MESSAGE
#define _countof(array) (sizeof(array)/sizeof(array[0]))

void AFXAPI TraceMsg(LPCTSTR lpszPrefix, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    ASSERT(lpszPrefix != NULL);

    if (message == WM_MOUSEMOVE || message == WM_NCMOUSEMOVE ||
        message == WM_NCHITTEST || message == WM_SETCURSOR ||
        message == WM_CTLCOLORBTN ||
        message == WM_CTLCOLORDLG ||
        message == WM_CTLCOLOREDIT ||
        message == WM_CTLCOLORLISTBOX ||
        message == WM_CTLCOLORMSGBOX ||
        message == WM_CTLCOLORSCROLLBAR ||
        message == WM_CTLCOLORSTATIC ||
        message == WM_ENTERIDLE || message == WM_CANCELMODE ||
        message == 0x0118)    // WM_SYSTIMER (caret blink)
    {
        // don't report very frequently sent messages
        return;
    }

    LPCSTR lpszMsgName = NULL;
    char szBuf[80];

    // find message name
    if (message >= 0xC000)
    {
        // Window message registered with 'RegisterWindowMessage'
        //  (actually a USER atom)
        if (::GetClipboardFormatNameA(message, szBuf, _countof(szBuf)))
            lpszMsgName = szBuf;
    }
    else if (message >= WM_USER)
    {
        // User message
        wsprintfA(szBuf, "WM_USER+0x%04X", message - WM_USER);
        lpszMsgName = szBuf;
    }
    else
    {
        // a system windows message
        const AFX_MAP_MESSAGE* pMapMsg = allMessages;
        for (/*null*/; pMapMsg->lpszMsg != NULL; pMapMsg++)
        {
            if (pMapMsg->nMsg == message)
            {
                lpszMsgName = pMapMsg->lpszMsg;
                break;
            }
        }
    }

    if (lpszMsgName != NULL)
    {
        AfxTrace(_T("%s: hwnd=0x%04X, msg = %hs (0x%04X, 0x%08lX)\n"),
            lpszPrefix, (UINT)hwnd, lpszMsgName,
            wParam, lParam);
    }
    else
    {
        AfxTrace(_T("%s: hwnd=0x%04X, msg = 0x%04X (0x%04X, 0x%08lX)\n"),
            lpszPrefix, (UINT)hwnd, message,
            wParam, lParam);
    }

//#ifndef _MAC
//  if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST)
//      TraceDDE(lpszPrefix, pMsg);
//#endif

}  //*** TraceMsg()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

//#define _DISPLAY_STATE_TEXT_IN_TREE
#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__
#undef DEVMODEW2A
#undef DEVMODEA2W
#undef TEXTMETRICW2A
#undef TEXTMETRICA2W

#include <afxtempl.h>       // MFC template classes

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifndef _WINREG_
#include <winreg.h>     // for REGSAM (needed by clusapi.h)
#endif

#ifndef _CLUSTER_API_
#include <clusapi.h>    // for cluster definitions
#endif

#ifndef _CLUSUDEF_H_
#include "clusudef.h"   // for cluster project-wide definitions
#endif

#ifndef _CLUSRTL_INCLUDED_
#include "clusrtl.h"
#endif

#include <netcon.h>
#include <htmlhelp.h>
#include <windns.h>

#ifndef _CADMTYPE_H_
#include "cadmtype.h"
#endif

#include <ClusCfgWizard.h>
#include <ClusCfgGuids.h>

#include <StrSafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      TraceTag.h
//
//  Abstract:
//      Definition of the CTraceTag class.
//
//  Implementation File:
//      TraceTag.cpp
//
//  Author:
//      David Potter (davidp)   May 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceTag;
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define TRACE_TAG_REG_SECTION       TEXT("Debug")
#define TRACE_TAG_REG_SECTION_FMT   TRACE_TAG_REG_SECTION TEXT("\\%s")
#define TRACE_TAG_REG_FILE          TEXT("Trace File")

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//  CTraceTag
//
//  Purpose:
//      Object containing a specific set of trace settings allowing trace
//      output to go to multiple outputs.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceTag : public CString
{
    friend class CTraceDialog;
    friend void InitAllTraceTags(void);
    friend void CleanupAllTraceTags(void);

public:
    CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL);
    ~CTraceTag(void);

    enum    TraceFlags
    {
        tfCom2      = 1,
        tfFile      = 2,
        tfDebug     = 4,
        tfBreak     = 8
    };

// Attributes
protected:
    UINT        m_uiFlags;
    UINT        m_uiFlagsDialog;
    UINT        m_uiFlagsDefault;
    UINT        m_uiFlagsDialogStart;   // of Selection...

    LPCTSTR     m_pszSubsystem;
    LPCTSTR     m_pszName;

    LPCTSTR     PszSubsystem(void)                  { return m_pszSubsystem; }
    LPCTSTR     PszName(void)                       { return m_pszName; }

    void        ConstructRegState(OUT CString & rstr);

    void        SetFlags(IN UINT tf, IN BOOL bEnable);
    void        SetFlagsDialog(IN UINT tf, IN BOOL bEnable);

    void        SetBCom2(IN BOOL bEnable)           { SetFlags(tfCom2, bEnable); }
    void        SetBCom2Dialog(IN BOOL bEnable)     { SetFlagsDialog(tfCom2, bEnable); }
    BOOL        BCom2Dialog(void) const             { return m_uiFlagsDialog & tfCom2 ? TRUE : FALSE; }

    void        SetBFile(IN BOOL bEnable)           { SetFlags(tfFile, bEnable); }
    void        SetBFileDialog(IN BOOL bEnable)     { SetFlagsDialog(tfFile, bEnable); }
    BOOL        BFileDialog(void) const             { return m_uiFlagsDialog & tfFile ? TRUE : FALSE; }

    void        SetBDebug(IN BOOL bEnable)          { SetFlags(tfDebug, bEnable); }
    void        SetBDebugDialog(IN BOOL bEnable)    { SetFlagsDialog(tfDebug, bEnable); }
    BOOL        BDebugDialog(void) const            { return m_uiFlagsDialog & tfDebug ? TRUE : FALSE; }

    void        SetBBreak(IN BOOL bEnable)          { SetFlags(tfBreak, bEnable); }
    void        SetBBreakDialog(IN BOOL bEnable)    { SetFlagsDialog(tfBreak, bEnable); }
    BOOL        BBreakDialog(void) const            { return m_uiFlagsDialog & tfBreak ? TRUE : FALSE; }

public:
    BOOL        BCom2(void) const                   { return m_uiFlags & tfCom2 ? TRUE : FALSE; }
    BOOL        BFile(void) const                   { return m_uiFlags & tfFile ? TRUE : FALSE; }
    BOOL        BDebug(void) const                  { return m_uiFlags & tfDebug ? TRUE : FALSE; }
    BOOL        BBreak(void) const                  { return m_uiFlags & tfBreak ? TRUE : FALSE; }
    BOOL        BAny(void) const                    { return m_uiFlags != 0; }

// Operations
public:

// Implementation
public:
    void                TraceV(IN LPCTSTR pszFormat, va_list);

protected:
    void                Init(void);

    static LPCTSTR      s_pszCom2;
    static LPCTSTR      s_pszFile;
    static LPCTSTR      s_pszDebug;
    static LPCTSTR      s_pszBreak;

    static LPCTSTR      PszFile(void);

    static CTraceTag *  s_ptagFirst;
    static CTraceTag *  s_ptagLast;
    CTraceTag *         m_ptagNext;
//  static HANDLE           s_hfileCom2;

    static CRITICAL_SECTION s_critsec;
    static BOOL             s_bCritSecValid;

    static BOOL             BCritSecValid(void) { return s_bCritSecValid; }

};  //*** class CTraceTag

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

 extern     CTraceTag               g_tagAlways;
 extern     CTraceTag               g_tagError;
 void __cdecl Trace(IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ...);
 void       TraceError(IN OUT CException & rexcept);
 void       TraceError(IN LPCTSTR pszModule, IN SC sc);
 void       InitAllTraceTags(void);
 void       CleanupAllTraceTags(void);
 void       TraceMenu(IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix);

// extern       LPTSTR      g_pszTraceIniFile;
 extern     CString     g_strTraceFile;
 extern     BOOL        g_bBarfDebug;

#else // _DEBUG

 //         Expand to ";", <tab>, one "/" followed by another "/"
 //         (which is //).
 //         NOTE: This means the Trace statements have to be on ONE line.
 //         If you need multiple line Trace statements, enclose them in
 //         a #ifdef _DEBUG block.
 #define    Trace                   ;   /##/
 inline void TraceError(IN OUT CException & rexcept)    { }
 inline void TraceError(IN LPCTSTR pszModule, IN SC sc) { }
 #define TraceMenu(_rtag, _pmenu, _pszPrefix)
 inline void InitAllTraceTags(void)                     { }
 inline void CleanupAllTraceTags(void)                  { }

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\treeitem.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      TreeItem.cpp
//
//  Abstract:
//      Implementation of the CTreeItem class.
//
//  Author:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ConstDef.h"
#include "TreeItem.h"
#include "TreeItem.inl"
#include "TreeView.h"
#include "ListView.h"
#include "ClusDoc.h"
#include "SplitFrm.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag g_tagTreeItemUpdate(_T("UI"), _T("TREE ITEM UPDATE"), 0);
CTraceTag g_tagTreeItemSelect(_T("UI"), _T("TREE ITEM SELECT"), 0);
CTraceTag g_tagTreeItemCreate(_T("Create"), _T("TREE ITEM CREATE"), 0);
CTraceTag g_tagTreeItemDelete(_T("Delete"), _T("TREE ITEM DELETE"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CTreeItemList
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItemList::PtiFromPci
//
//  Routine Description:
//      Find a tree item in the list by its cluster item.
//
//  Arguments:
//      pci         [IN] Cluster item to search for.
//      ppos        [OUT] Position of the item in the list.
//
//  Return Value:
//      pti         Tree item corresponding to the cluster item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItemList::PtiFromPci(
    IN const CClusterItem * pci,
    OUT POSITION *          ppos    // = NULL
    ) const
{
    POSITION    posPti;
    POSITION    posCurPti;
    CTreeItem * pti = NULL;

    posPti = GetHeadPosition();
    while (posPti != NULL)
    {
        posCurPti = posPti;
        pti = GetNext(posPti);
        ASSERT_VALID(pti);

        if (pti->Pci() == pci)
        {
            if (ppos != NULL)
                *ppos = posCurPti;
            break;
        }  // if:  found a match

        pti = NULL;
    }  // while:  more resources in the list

    return pti;

}  //*** CTreeItemList::PtiFromPci()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// CTreeItem
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CTreeItem, CBaseCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CTreeItem, CBaseCmdTarget)
    //{{AFX_MSG_MAP(CTreeItem)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::CTreeItem
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem::CTreeItem(void)
{
    m_ptiParent = NULL;
    m_pci = NULL;
    m_bWeOwnPci = FALSE;

}  //*** CTreeItem::CTreeItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::CTreeItem
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      ptiParent       [IN OUT] Parent item for this item.
//      pci             [IN OUT] Cluster item represented by this tree item.
//      bTakeOwnership  [IN] TRUE = delete pci when this object is destroyed.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem::CTreeItem(
    IN OUT CTreeItem *      ptiParent,
    IN OUT CClusterItem *   pci,
    IN BOOL                 bTakeOwnership  // = FALSE
    )
{
    ASSERT_VALID(pci);

    m_ptiParent = ptiParent;
    m_pci = pci;
    m_bWeOwnPci = bTakeOwnership;

    m_pci->AddRef();

    // Set the column section name.  If there is a parent, append our name
    // onto the parent's section name.
    try
    {
        if (PtiParent() == NULL)
            m_strProfileSection.Format(
                REGPARAM_CONNECTIONS _T("\\%s\\%s"),
                Pci()->Pdoc()->StrNode(),
                Pci()->StrName()
                );
        else
            m_strProfileSection.Format(
                _T("%s\\%s"),
                PtiParent()->StrProfileSection(),
                Pci()->StrName()
                );
    }  // try
    catch (CException * pe)
    {
        // If an error occurs constructing the section name, just ignore it.
        pe->Delete();
    }  // catch:  CException

    Trace(g_tagTreeItemCreate, _T("CTreeItem() - Creating '%s', parent = '%s', owned = %d"), pci->StrName(), (ptiParent ? ptiParent->Pci()->StrName() : _T("<None>")), bTakeOwnership);

}  //*** CTreeItem::CTreeItem(pci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::Init
//
//  Routine Description:
//      Initialize the tree item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::Init(void)
{
}  //*** CTreeItem::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::~CTreeItem
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem::~CTreeItem(void)
{
#ifdef _DEBUG
    TCHAR   szName[1024];
    HRESULT hr;

    if (Pci() != NULL)
    {
        hr = StringCchCopyN( szName, RTL_NUMBER_OF( szName ), Pci()->StrName(), Pci()->StrName().GetLength() );
        ASSERT( SUCCEEDED( hr ) );
    }
    else
    {
        hr = StringCchCopy( szName, RTL_NUMBER_OF( szName ), _T("<Unknown>") );
        ASSERT( SUCCEEDED( hr ) );
    }

    Trace(g_tagTreeItemDelete, _T("~CTreeItem() - Deleting tree item '%s'"), szName);
#endif

    // Cleanup this object.
    Cleanup();

    Trace(g_tagTreeItemDelete, _T("~CTreeItem() - Done deleting tree item '%s'"), szName);

}  //*** CTreeItem::~CTreeItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::Delete
//
//  Routine Description:
//      Delete the item.  If the item still has references, add it to the
//      document's pending delete list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::Delete(void)
{
    // Add a reference so that we don't delete ourselves while
    // still doing cleanup.
    AddRef();

    // Cleanup this object.
    Cleanup();

    // If there are still references to this object, add it to the delete
    // pending list.  Check for greater than 1 because we added a reference
    // at the beginning of this method.
//  if (NReferenceCount() > 1)
//  {
//      ASSERT(Pdoc()->LpciToBeDeleted().Find(this) == NULL);
//      Pdoc()->LpciToBeDeleted().AddTail(this);
//  }  // if:  object still has references to it

    // Release the reference we added at the beginning.  This will
    // cause the object to be deleted if we were the last reference.
    Release();

}  //*** CTreeItem::Delete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::Cleanup(void)
{
    // Delete our children first.
    // NOTE:  List items MUST be deleted first since tree items delete
    // owned cluster items.
    DeleteAllItemData(m_lpliChildren);
    DeleteAllItemData(m_lptiChildren);
    m_lpliChildren.RemoveAll();
    m_lptiChildren.RemoveAll();

    // Remove ourself from all views.
    RemoveFromAllLists();

    // Delete all other lists.
    DeleteAllItemData(m_lpcoli);
    DeleteAllItemData(m_lptic);
    m_lpcoli.RemoveAll();
    m_lptic.RemoveAll();

    // If we own the cluster item, delete it.
    if (m_bWeOwnPci)
    {
#ifdef _DEBUG
        TCHAR   szName[1024];
        HRESULT hr;

        if (Pci() != NULL)
        {
            hr = StringCchCopyN( szName, RTL_NUMBER_OF( szName ), Pci()->StrName(), Pci()->StrName().GetLength() );
            ASSERT( SUCCEEDED( hr ) );
        }
        else
        {
            hr = StringCchCopy( szName, RTL_NUMBER_OF( szName ), _T("<Unknown>") );
            ASSERT( SUCCEEDED( hr ) );
        }
        Trace(g_tagTreeItemDelete, _T("Cleanup --> Deleting cluster item '%s'"), szName);
#endif
        delete m_pci;
    }  // if:  we own the cluster item
    else if (m_pci != NULL)
        m_pci->Release();
    m_pci = NULL;

}  //*** CTreeItem::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::StrProfileSection
//
//  Routine Description:
//      Return the profile section name for this item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      CString     Reference to profile section string.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CTreeItem::StrProfileSection(void)
{
    ASSERT_VALID(Pci());

    if (Pci() != NULL)
    {
        // Set the column section name.  If there is a parent, append our name
        // onto the parent's section name.
        try
        {
            if (PtiParent() == NULL)
            {
                ASSERT_VALID(Pci()->Pdoc());
                m_strProfileSection.Format(
                    REGPARAM_CONNECTIONS _T("\\%s\\%s"),
                    Pci()->Pdoc()->StrNode(),
                    Pci()->StrName()
                    );
            }  // if:  item has no parent
            else
            {
                m_strProfileSection.Format(
                    _T("%s\\%s"),
                    PtiParent()->StrProfileSection(),
                    Pci()->StrName()
                    );
            }  // else:  item has a parent
        }  // try
        catch (CException * pe)
        {
            // If an error occurs constructing the section name, just ignore it.
            pe->Delete();
        }  // catch:  CException
    }  // if:  valid cluster item and document

    return m_strProfileSection;

}  //*** CTreeItem::StrProfileSection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PtiAddChildBefore
//
//  Routine Description:
//      Add a child to the item's list of children following the specified
//      item.  Also creates an entry in the list of children list items.
//
//  Arguments:
//      pciOld          [IN] Cluster item to follow the new tree item.
//      pciNew          [IN OUT] Cluster item represented by the new tree item.
//      bTakeOwnership  [IN] TRUE = delete pci when done, FALSE = don't delete.
//
//  Return Value:
//      ptiChild        The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiAddChildBefore(
    IN const CClusterItem * pciOld,
    OUT CClusterItem *      pciNew,
    IN BOOL                 bTakeOwnership  // = FALSE
    )
{
    CTreeItem *     ptiOldChild;
    CTreeItem *     ptiNewChild;
    CListItem *     pliChild;
    POSITION        posOld;

    // If no old was specified, add to the tail.
    if (pciOld == NULL)
        return PtiAddChild(pciNew, bTakeOwnership);

    // Find the old item.
    ptiOldChild = LptiChildren().PtiFromPci(pciOld, &posOld);
    ASSERT_VALID(ptiOldChild);

    // Create a child tree item.
    ptiNewChild = new CTreeItem(this, pciNew, bTakeOwnership);
    if (ptiNewChild == NULL)
    {
        ThrowStaticException(GetLastError());
    } // if: error allocating the tree item
    ASSERT_VALID(ptiNewChild);
    ptiNewChild->Init();

    // Add the item before the specified item.
    VERIFY((m_lptiChildren.InsertBefore(posOld, ptiNewChild)) != NULL);

    // Add it to the back of the cluster item's list.
    pciNew->AddTreeItem(ptiNewChild);

    // Create a list item.
    pliChild = PliAddChild(pciNew);
    ASSERT_VALID(pliChild);

    // Insert the new tree item in all tree controls.
    InsertChildInAllTrees(ptiNewChild);

    return ptiNewChild;

}  //*** CTreeItem::PtiAddChildBefore()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::InsertChildInAllTrees
//
//  Routine Description:
//      Insert a child item in all tree controls.  The child item must have
//      already been inserted in the list of child tree items.
//
//  Arguments:
//      ptiNewChild     [IN OUT] Tree item to be inserted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::InsertChildInAllTrees(IN OUT CTreeItem * ptiNewChild)
{
    POSITION            posPtic;
    CTreeItemContext *  pticParent;
    POSITION            posPrevChild;
    HTREEITEM           htiPrevChild;
    CTreeItemContext *  pticPrevChild;
    CTreeItem *         ptiPrevChild;
    CTreeItemContext *  pticNewChild;
    CTreeCtrl *         ptc;
    CString             strName;

    ASSERT_VALID(ptiNewChild);

    // Find the position of the child being inserted.  Then get the address
    // of the child before the one being inserted.  This requires two calls
    // to GetPrev.
    VERIFY((posPrevChild = LptiChildren().Find(ptiNewChild)) != NULL);      // Get new child pos.
    VERIFY((ptiPrevChild = LptiChildren().GetPrev(posPrevChild)) != NULL);  // Get pointer to new child.
    if (posPrevChild == NULL)                                               // If this is the first child,
    {
        htiPrevChild = TVI_FIRST;                                           //   set the hti to that value.
        ptiPrevChild = NULL;
    }  // if:  new child is not the first child
    else
    {
        htiPrevChild = NULL;
        ptiPrevChild = LptiChildren().GetPrev(posPrevChild);                // Get pointer to prev child.
        ASSERT_VALID(ptiPrevChild);
    }  // else:  new child is the first child

    // Loop through all the tree item contexts and add this item
    // to the tree controls.
    posPtic = Lptic().GetHeadPosition();
    while (posPtic != NULL)
    {
        // Get the parent's tree item context.
        pticParent = Lptic().GetNext(posPtic);
        ASSERT_VALID(pticParent);

        // Get the child's tree item context.
        if (ptiPrevChild != NULL)
        {
            pticPrevChild = ptiPrevChild->PticFromFrame(pticParent->m_pframe);
            ASSERT_VALID(pticPrevChild);
            htiPrevChild = pticPrevChild->m_hti;
        }  // if:  not inserting at beginning of list

        // Allocate a new tree item context.
        pticNewChild = new CTreeItemContext(pticParent->m_pframe, ptiNewChild, NULL, FALSE /*bExpanded*/);
        if (pticNewChild == NULL)
        {
            ThrowStaticException(GetLastError());
        } // if: error allocating the tree item context
        ASSERT_VALID(pticNewChild);
        pticNewChild->Init();
        ptiNewChild->m_lptic.AddTail(pticNewChild);

        // Get the name to show in the tree.
        ptiNewChild->Pci()->GetTreeName(strName);

        // Insert the item in the tree.
        ASSERT_VALID(pticParent->m_pframe);
        ASSERT_VALID(pticParent->m_pframe->PviewTree());
        ptc = &pticParent->m_pframe->PviewTree()->GetTreeCtrl();
        VERIFY((pticNewChild->m_hti = ptc->InsertItem(strName, pticParent->m_hti, htiPrevChild)) != NULL);
        VERIFY(ptc->SetItemData(pticNewChild->m_hti, (DWORD_PTR) ptiNewChild));
    }  // while:  more tree item contexts in the list

}  //*** CTreeItem::InsertChildInAllTrees()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PtiAddChild(CClusterItem*)
//
//  Routine Description:
//      Add a child to the item's list of children.  Also creates an entry
//      in the list of children list items.
//
//  Arguments:
//      pci             [IN OUT] Cluster item represented by the new tree item.
//      bTakeOwnership  [IN] TRUE = delete pci when done, FALSE = don't delete.
//
//  Return Value:
//      ptiChild        The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiAddChild(
    IN OUT CClusterItem *   pci,
    IN BOOL                 bTakeOwnership  // = FALSE
    )
{
    CTreeItem *     ptiChild;
    CListItem *     pliChild;

    ASSERT_VALID(pci);

    // Create a child tree item.
    ptiChild = new CTreeItem(this, pci, bTakeOwnership);
    if (ptiChild == NULL)
    {
        ThrowStaticException(GetLastError());
        goto Cleanup;
    } // if: error allocating the child tree item
    ASSERT_VALID(ptiChild);
    ptiChild->Init();

    // Add the item to the list of child tree items.
    m_lptiChildren.AddTail(ptiChild);

    // Add ourselves to the back of the cluster item's list.
    pci->AddTreeItem(ptiChild);

    // Create a list item.
    pliChild = PliAddChild(pci);
    ASSERT_VALID(pliChild);

    // Insert the new tree item in all tree controls.
    InsertChildInAllTrees(ptiChild);

Cleanup:

    return ptiChild;

}  //*** CTreeItem::PtiAddChild(CClusterItem*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PtiAddChild(CString&)
//
//  Routine Description:
//      Add a child to the item's list of children.  Also creates an entry
//      in the list of children list items.
//
//  Arguments:
//      rstrName    [IN] String for the name of the item.
//
//  Return Value:
//      ptiChild    The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiAddChild(IN const CString & rstrName)
{
    CClusterItem *  pci;
    CTreeItem *     ptiChild;

    // Create the cluster item.
    pci = new CClusterItem(&rstrName);
    if (pci == NULL)
    {
        ThrowStaticException(GetLastError());
    } // if: error allocating the cluster item
    ASSERT_VALID(pci);

    // Add the cluster item to our list of children.
    ptiChild = PtiAddChild(pci, TRUE /*bTakeOwnership*/);
    ASSERT_VALID(ptiChild);

    return ptiChild;

}  //*** CTreeItem::PtiAddChild(CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PtiAddChild(IDS)
//
//  Routine Description:
//      Add a child to the item's list of children.  Also creates an entry
//      in the list of children list items.
//
//  Arguments:
//      idsName     [IN] String resource ID for the name of the item.
//
//  Return Value:
//      ptiChild    The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiAddChild(IN IDS idsName)
{
    CString     strName;

    ASSERT(idsName != 0);

    strName.LoadString(idsName);
    return PtiAddChild(strName);

}  //*** CTreeItem::PtiAddChild(IDS)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PliAddChild
//
//  Routine Description:
//      Add a child to the item's list of children list items.
//
//  Arguments:
//      pci         [IN OUT] Cluster item represented by the list item.
//
//  Return Value:
//      pliChild    The new child item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem * CTreeItem::PliAddChild(IN OUT CClusterItem * pci)
{
    CListItem *     pliChild;

    ASSERT_VALID(pci);

    // Create a list item.
    pliChild = new CListItem(pci, this);
    if (pliChild == NULL)
    {
        ThrowStaticException(GetLastError());
    } // if: error allocating the list item
    ASSERT_VALID(pliChild);

    // Add the list item to the list of child list items.
    m_lpliChildren.AddTail(pliChild);

    // Add the list item to the cluster item's list.
    pci->AddListItem(pliChild);

    // Add the list item to any list views.
    {
        POSITION            posPtic;
        CTreeItemContext *  ptic;
        int                 ili;

        posPtic = Lptic().GetHeadPosition();
        while (posPtic != NULL)
        {
            ptic = Lptic().GetNext(posPtic);
            ASSERT_VALID(ptic);

            if (ptic->m_pframe->PviewTree()->HtiSelected() == ptic->m_hti)
            {
                ASSERT_VALID(ptic->m_pframe);
                VERIFY((ili = pliChild->IliInsertInList(ptic->m_pframe->PviewList())) != -1);
            }  // if:  currently showing children in list view
        }  // while:  item is showing in more views
    }  // Add the list item to any list views

    return pliChild;

}  //*** CTreeItem::PliAddChild()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::RemoveItem
//
//  Routine Description:
//      Remove the item from the tree.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::RemoveItem(void)
{
    ASSERT_VALID(PtiParent());
    PtiParent()->RemoveChild(Pci());

}  //*** CTreeItem::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::RemoveChild
//
//  Routine Description:
//      Remove a child from the item's list of children list items.
//
//  Arguments:
//      pci         [IN OUT] Cluster item represented by the list item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::RemoveChild(IN OUT CClusterItem * pci)
{
    ASSERT_VALID(pci);

    // Remove the item from the list of list items.
    {
        CListItem *     pliChild;
        POSITION        posPli;

        pliChild = PliChildFromPci(pci);
        if (pliChild != NULL)
        {
            pliChild->RemoveFromAllLists();
            posPli = LpliChildren().Find(pliChild);
            ASSERT(posPli != NULL);
            m_lpliChildren.RemoveAt(posPli);
            Trace(g_tagTreeItemDelete, _T("RemoveChild() - Deleting child list item '%s' from '%s' - %d left"), pliChild->Pci()->StrName(), Pci()->StrName(), LpliChildren().GetCount());
            delete pliChild;
        }  // if:  child lives in the list

    }  // Remove the item from the list of list items

    // Remove the item from the list of tree items.
    {
        CTreeItem *     ptiChild;
        CTreeItem *     ptiChildChild;
        POSITION        posPti;
        ULONG           nReferenceCount;

        ptiChild = PtiChildFromPci(pci);
        if (ptiChild != NULL)
        {
            // Remove the children of this child.
            {
                posPti = ptiChild->LptiChildren().GetHeadPosition();
                while (posPti != NULL)
                {
                    ptiChildChild = ptiChild->LptiChildren().GetNext(posPti);
                    ASSERT_VALID(ptiChildChild);
                    ptiChildChild->RemoveItem();
                }  // while:  more items in the list
            }  // Remove the children of this child

            posPti = LptiChildren().Find(ptiChild);
            ASSERT(posPti != NULL);
            nReferenceCount = ptiChild->NReferenceCount();
            m_lptiChildren.RemoveAt(posPti);
            Trace(g_tagTreeItemDelete, _T("RemoveChild() - Deleting child tree item '%s' from '%s' - %d left"), ptiChild->Pci()->StrName(), Pci()->StrName(), LptiChildren().GetCount());
            if (nReferenceCount > 1)
            {
                ptiChild->AddRef();
                ptiChild->RemoveFromAllLists();
                ptiChild->Release();
            }  // if:  child not deleted yet
        }  // if:  child lives in the tree

    }  // Remove the item from the list of tree items

}  //*** CTreeItem::RemoveChild()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PtiChildFromName
//
//  Routine Description:
//      Find a child tree item from its name.
//
//  Arguments:
//      rstrName    [IN] Name of the item.
//      ppos        [OUT] Position of the item in the list.
//
//  Return Value:
//      ptiChild    Child item corresponding to the specified name.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiChildFromName(
    IN const CString &  rstrName,
    OUT POSITION *      ppos        // = NULL
    ) const
{
    POSITION    posPtiChild;
    POSITION    posCurPtiChild;
    CTreeItem * ptiChild    = NULL;

    // Loop through each child item to find the specified item.
    posPtiChild = LptiChildren().GetHeadPosition();
    while (posPtiChild != NULL)
    {
        posCurPtiChild = posPtiChild;
        ptiChild = LptiChildren().GetNext(posPtiChild);
        ASSERT_VALID(ptiChild);

        if (ptiChild->StrName() == rstrName)
        {
            if (ppos != NULL)
                *ppos = posCurPtiChild;
            break;
        }  // if:  found a match
    }  // while:  more children of this tree item

    return ptiChild;

}  //*** CTreeItem::PtiChildFromName(CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PtiChildFromName
//
//  Routine Description:
//      Find a child tree item from its name.
//
//  Arguments:
//      idsName     [IN] ID of the name of the item.
//      ppos        [OUT] Position of the item in the list.
//
//  Return Value:
//      ptiChild    Child item corresponding to the specified name.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiChildFromName(
    IN IDS          idsName,
    OUT POSITION *  ppos    // = NULL
    ) const
{
    CString     strName;

    VERIFY(strName.LoadString(idsName));
    return PtiChildFromName(strName, ppos);

}  //*** CTreeItem::PtiChildFromName(IDS)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PtiChildFromPci
//
//  Routine Description:
//      Find a child tree item from its cluster item.
//
//  Arguments:
//      pci         [IN] Cluster item to search for.
//
//  Return Value:
//      ptiChild    Child item corresponding to the specified cluster item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItem::PtiChildFromPci(IN const CClusterItem * pci) const
{
    POSITION    posPtiChild;
    CTreeItem * ptiChild    = NULL;

    ASSERT_VALID(pci);

    // Loop through each child item to find the specified item.
    posPtiChild = LptiChildren().GetHeadPosition();
    while (posPtiChild != NULL)
    {
        ptiChild = LptiChildren().GetNext(posPtiChild);
        ASSERT_VALID(ptiChild);

        if (ptiChild->Pci() == pci)
            break;
    }  // while:  more children of this tree item

    return ptiChild;

}  //*** CTreeItem::PtiChildFromPci()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PliChildFromPci
//
//  Routine Description:
//      Find a child list item from its cluster item.
//
//  Arguments:
//      pci         [IN] Cluster item to search for.
//
//  Return Value:
//      pliChild    Child item corresponding to the specified cluster item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem * CTreeItem::PliChildFromPci(IN const CClusterItem * pci) const
{
    POSITION    posPliChild;
    CListItem * pliChild    = NULL;

    // Loop through each child item to find the specified item.
    posPliChild = LpliChildren().GetHeadPosition();
    while (posPliChild != NULL)
    {
        pliChild = LpliChildren().GetNext(posPliChild);
        ASSERT_VALID(pliChild);

        if (pliChild->Pci() == pci)
            break;
    }  // while:  more children of this tree item

    return pliChild;

}  //*** CTreeItem::PliChildFromPci()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::HtiInsertInTree
//
//  Routine Description:
//      Insert the item in a tree under the specified parent.
//
//  Arguments:
//      pctv        [IN OUT] Cluster tree view in which item is displayed.
//
//  Return Value:
//      m_hti       Handle of the new item in the tree.
//
//--
/////////////////////////////////////////////////////////////////////////////
HTREEITEM CTreeItem::HtiInsertInTree(
    IN OUT CClusterTreeView *   pctv
    )
{
    CTreeItemContext *  ptic;
    HTREEITEM           htiParent;
    CSplitterFrame *    pframe;

    ASSERT_VALID(pctv);
    ASSERT_VALID(Pci());

    // Get the frame pointer.
    pframe = (CSplitterFrame *) pctv->GetParent()->GetParent();
    ASSERT_VALID(pframe);

    // Get the tree item context for this item.
    // If it doesn't exist yet, create one.
    ptic = PticFromView(pctv);
    if (ptic == NULL)
    {
        // Create the new tree item context.
        ptic = new CTreeItemContext(pframe, this, NULL, FALSE /*bExpanded*/);
        if (ptic == NULL)
        {
            ThrowStaticException(GetLastError());
        } // if: error allcoating the tree item context
        ASSERT_VALID(ptic);
        ptic->Init();
        m_lptic.AddTail(ptic);
    }  // if:  no entry found

    // Get our parent's handle.
    if (PtiParent() != NULL)
    {
        CTreeItemContext *  pticParent;

        pticParent = PtiParent()->PticFromFrame(pframe);
        ASSERT_VALID(pticParent);
        htiParent = pticParent->m_hti;
    }  // if:  parent specified
    else
        htiParent = NULL;

    // Insert the item in the tree.
    {
        CTreeCtrl *         ptc;
        CString             strName;

        ASSERT_VALID(pframe->PviewTree());

        Pci()->GetTreeName(strName);

        ptc = &pframe->PviewTree()->GetTreeCtrl();
        VERIFY((ptic->m_hti = ptc->InsertItem(strName, htiParent)) != NULL);
        VERIFY(ptc->SetItemData(ptic->m_hti, (DWORD_PTR) this));
    }  // Insert the item in the tree

    UpdateState();
    return ptic->m_hti;

}  //*** CTreeItem::HtiInsertInTree()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::RemoveFromAllLists
//
//  Routine Description:
//      Remove this item from all lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::RemoveFromAllLists(void)
{
    if (Pci() != NULL)
    {
        ASSERT_VALID(Pci());

        // Loop through each view and remove the item from the list.
        {
            POSITION            posPtic;
            POSITION            posPticPrev;
            CTreeItemContext *  ptic;
            CTreeCtrl *         ptc;
            CClusterListView *  pviewList;

            posPtic = Lptic().GetHeadPosition();
            while (posPtic != NULL)
            {
                // Get the next tree item context list entry.
                posPticPrev = posPtic;
                ptic = Lptic().GetNext(posPtic);
                ASSERT_VALID(ptic);

                // Get the tree control and list view from the frame.
                ASSERT_VALID(ptic->m_pframe);
                ptc = &ptic->m_pframe->PviewTree()->GetTreeCtrl();
                pviewList = ptic->m_pframe->PviewList();

                // If this tree item is the parent of the list control items,
                // refresh the list control with no selection.
                if (pviewList->PtiParent() == this)
                    pviewList->Refresh(NULL);

                // Delete the item from the tree control and the list.
                VERIFY(ptc->DeleteItem(ptic->m_hti));
                m_lptic.RemoveAt(posPticPrev);
                delete ptic;
            }  // while:  more lists
        }  // Loop through each view and remove the item from the list

        // Remove ourselves from the cluster item's list.
        Pci()->RemoveTreeItem(this);
    }  // if:  valid cluster item pointer

}  //*** CTreeItem::RemoveFromAllLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::Select
//
//  Routine Description:
//      Select this item in the specified tree view.  This causes the
//      children of this item to be displayed in a list view.
//
//  Arguments:
//      pctv            [IN OUT] Tree view in which item was selected.
//      bSelectInTree   [IN] TRUE = select in tree control also.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::Select(IN OUT CClusterTreeView * pctv, IN BOOL bSelectInTree)
{
    CTreeItemContext *  ptic;

    ASSERT_VALID(pctv);

    // Get the tree item context.
    ptic = PticFromView(pctv);
    ASSERT_VALID(ptic);
    Trace(g_tagTreeItemSelect, _T("'%s' selected"), Pci()->StrName());

    // Select the item in the tree control.
    if (bSelectInTree)
        ptic->m_pframe->PviewTree()->GetTreeCtrl().Select(ptic->m_hti, TVGN_CARET);

    // Refresh the list control.
    ASSERT_VALID(ptic->m_pframe);
    ASSERT_VALID(ptic->m_pframe->PviewList());
    ptic->m_pframe->PviewList()->Refresh(this);

}  //*** CTreeItem::Select()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PreRemoveFromFrameWithChildren
//
//  Routine Description:
//      Cleanup an item and all its children.
//
//  Arguments:
//      pframe  [IN OUT] Frame window item is being removed from.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::PreRemoveFromFrameWithChildren(IN OUT CSplitterFrame * pframe)
{
    POSITION    posChild;
    CTreeItem * ptiChild;

    ASSERT_VALID(this);

    // Cleanup all child items.
    posChild = LptiChildren().GetHeadPosition();
    while (posChild != NULL)
    {
        ptiChild = LptiChildren().GetNext(posChild);
        ASSERT_VALID(ptiChild);
        ptiChild->PreRemoveFromFrameWithChildren(pframe);
    }  // while:  more items in the list

    // Cleanup this item.
    PreRemoveFromFrame(pframe);

}  //*** CTreeItem::PreRemoveFromFrameWithChildren()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PreRemoveFromFrame
//
//  Routine Description:
//      Prepare to remove the item from a tree.
//
//  Arguments:
//      pframe      [IN OUT] Frame window item is being removed from.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::PreRemoveFromFrame(IN OUT CSplitterFrame * pframe)
{
    CTreeItemContext *  ptic;
    POSITION            posPtic;

    ASSERT_VALID(pframe);

    // Find the view in our list.
    ptic = PticFromFrame(pframe);
    if (ptic == NULL)
        return;
    ASSERT_VALID(ptic);
    VERIFY((posPtic = Lptic().Find(ptic)) != NULL);

    // Remove the view from the list.
    m_lptic.RemoveAt(posPtic);

    // Delete the context item.
    delete ptic;

}  //*** CTreeItem::PreRemoveFromFrame(pframe)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PticFromFrame
//
//  Routine Description:
//      Find a tree item context from a frame.
//
//  Arguments:
//      pframe      [IN] Frame to search on.
//
//  Return Value:
//      ptic        Found context, or NULL if not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItemContext * CTreeItem::PticFromFrame(IN const CSplitterFrame * pframe) const
{
    POSITION            posPtic;
    CTreeItemContext *  ptic;

    ASSERT_VALID(pframe);

    posPtic = Lptic().GetHeadPosition();
    while (posPtic != NULL)
    {
        ptic = Lptic().GetNext(posPtic);
        ASSERT_VALID(ptic);
        if (ptic->m_pframe == pframe)
            return ptic;
    }  // while:  more items in the list

    return NULL;

}  //*** CTreeItem::PticFromFrame()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PticFromView
//
//  Routine Description:
//      Find a tree item context from a tree view.
//
//  Arguments:
//      pctv        [IN] Tree view to search on.
//
//  Return Value:
//      ptic        Found context, or NULL if not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItemContext * CTreeItem::PticFromView(IN const CClusterTreeView * pctv) const
{
    POSITION            posPtic;
    CTreeItemContext *  ptic;

    ASSERT_VALID(pctv);

    posPtic = Lptic().GetHeadPosition();
    while (posPtic != NULL)
    {
        ptic = Lptic().GetNext(posPtic);
        ASSERT_VALID(ptic);
        ASSERT_VALID(ptic->m_pframe);
        if (ptic->m_pframe->PviewTree() == pctv)
            return ptic;
    }  // while:  more items in the list

    return NULL;

}  //*** CTreeItem::PticFromView(CClusterTreeView*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PticFromView
//
//  Routine Description:
//      Find a tree item context from a list view.
//
//  Arguments:
//      pclv        [IN] List view to search on.
//
//  Return Value:
//      ptic        Found context, or NULL if not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItemContext * CTreeItem::PticFromView(IN const CClusterListView * pclv) const
{
    POSITION            posPtic;
    CTreeItemContext *  ptic;

    ASSERT_VALID(pclv);

    posPtic = Lptic().GetHeadPosition();
    while (posPtic != NULL)
    {
        ptic = Lptic().GetNext(posPtic);
        ASSERT_VALID(ptic);
        ASSERT_VALID(ptic->m_pframe);
        if (ptic->m_pframe->PviewList() == pclv)
            return ptic;
    }  // while:  more items in the list

    return NULL;

}  //*** CTreeItem::PticFromView(CClusterListView*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::HtiFromView
//
//  Routine Description:
//      Find a tree item handle from a view.
//
//  Arguments:
//      pctv        [IN] View to search on.
//
//  Return Value:
//      hti         Found tree item handle, or NULL if not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
HTREEITEM CTreeItem::HtiFromView(IN const CClusterTreeView * pctv) const
{
    CTreeItemContext *  ptic;
    HTREEITEM           hti     = NULL;

    ASSERT_VALID(pctv);

    ptic = PticFromView(pctv);
    if (ptic != NULL)
        hti = ptic->m_hti;

    return hti;

}  //*** CTreeItem::HtiFromView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PcoliAddColumn
//
//  Routine Description:
//      Add a column to the list of column header items.
//
//  Arguments:
//      rstrText        [IN] Reference to the text of the column.
//      idsColumnID     [IN] ID of the column to identify the data.
//      nDefaultWidth   [IN] Default width of the column.
//      nWidth          [IN] Actual width of the column.
//
//  Return Value:
//      pcoli           Column item added to the list.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem * CTreeItem::PcoliAddColumn(
    IN const CString &  rstrText,
    IN IDS              idsColumnID,
    IN int              nDefaultWidth,
    IN int              nWidth
    )
{
    CColumnItem *   pcoli;

    pcoli = new CColumnItem(rstrText, idsColumnID, nDefaultWidth, nWidth);
    if (pcoli == NULL)
    {
        ThrowStaticException(GetLastError());
    } // if: error allocating the column item
    m_lpcoli.AddTail(pcoli);

    return pcoli;

}  //*** CTreeItem::PcoliAddColumn(CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::PcoliAddColumn
//
//  Routine Description:
//      Add a column to the list of column header items.
//
//  Arguments:
//      idsText         [IN] String resource ID for the text of the column.
//                        Also used as the column ID.
//      nDefaultWidth   [IN] Default width of the column.
//      nWidth          [IN] Actual width of the column.
//
//  Return Value:
//      pcoli           Column item added to the list.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem * CTreeItem::PcoliAddColumn(IN IDS idsText, IN int nDefaultWidth, IN int nWidth)
{
    CString     strText;

    strText.LoadString(idsText);
    return PcoliAddColumn(strText, idsText, nDefaultWidth, nWidth);

}  //*** CTreeItem::PcoliAddColumn(IDS)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::BSelectItem
//
//  Routine Description:
//      Select the item in the specified tree control.
//
//  Arguments:
//      pctv    [IN OUT] Cluster tree view in which to select the item.
//
//  Return Value:
//      TRUE    Item was selected successfully.
//      FALSE   Item not selected.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItem::BSelectItem(IN OUT CClusterTreeView  * pctv)
{
    HTREEITEM   hti;

    ASSERT_VALID(pctv);

    VERIFY((hti = HtiFromView(pctv)) != NULL);
    return (pctv->GetTreeCtrl().SelectItem(hti) != 0);

}  //*** CTreeItem::BSelectItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::SelectInAllViews
//
//  Routine Description:
//      Select this item in all views in which it is being displayed.  This
//      causes the children of this item to be displayed in a list view.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::SelectInAllViews(void)
{
    POSITION            posPtic;
    CTreeItemContext *  ptic;

    posPtic = Lptic().GetHeadPosition();
    while (posPtic != NULL)
    {
        // Get the next tree item context list entry.
        ptic = Lptic().GetNext(posPtic);
        ASSERT_VALID(ptic);

        // Select the item in this list.
        ASSERT_VALID(ptic->m_pframe);
        BSelectItem(ptic->m_pframe->PviewTree());
        ptic->m_pframe->PviewTree()->SetFocus();
    }  // while:  more items in the list

}  //*** CTreeItem::SelectInAllViews()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::BExpand
//
//  Routine Description:
//      Expand the item in the specified tree control.
//
//  Arguments:
//      pctv    [IN OUT] Cluster tree view in which to expand the item.
//      nCode   [IN] Flag indicating the type of action to be taken.
//
//  Return Value:
//      TRUE    Item was expanded successfully.
//      FALSE   Item not expanded.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItem::BExpand(IN OUT CClusterTreeView  * pctv, IN UINT nCode)
{
    CTreeItemContext *  ptic;

    ASSERT_VALID(pctv);
    ASSERT(nCode != 0);

    ptic = PticFromView(pctv);
    ASSERT_VALID(ptic);
    if (nCode == TVE_EXPAND)
        ptic->m_bExpanded = TRUE;
    else
        ptic->m_bExpanded = FALSE;
    return (pctv->GetTreeCtrl().Expand(ptic->m_hti, nCode) != 0);

}  //*** CTreeItem::BExpand()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::ExpandInAllViews
//
//  Routine Description:
//      Expand the item in all views in which it is displayed.
//
//  Arguments:
//      nCode   [IN] Flag indicating the type of action to be taken.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::ExpandInAllViews(IN UINT nCode)
{
    POSITION            posPtic;
    CTreeItemContext *  ptic;

    ASSERT(nCode != 0);

    posPtic = Lptic().GetHeadPosition();
    while (posPtic != NULL)
    {
        // Get the next tree item context list entry.
        ptic = Lptic().GetNext(posPtic);
        ASSERT_VALID(ptic);

        // Select the item in this list.
        ASSERT_VALID(ptic->m_pframe);
        BExpand(ptic->m_pframe->PviewTree(), nCode);
    }  // while:  more items in the list

}  //*** CTreeItem::ExpandInAllViews()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::SetExpandedState
//
//  Routine Description:
//      Save the expanded state of the item in the specified view.
//
//  Arguments:
//      pctv        [IN] Tree view in which expanded state is being saved.
//      bExpanded   [IN] TRUE = item is expanded in the specified view.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::SetExpandedState(
    IN const CClusterTreeView * pctv,
    IN BOOL                     bExpanded
    )
{
    CTreeItemContext *  ptic;

    ASSERT_VALID(pctv);

    ptic = PticFromView(pctv);
    ASSERT_VALID(ptic);
    ptic->m_bExpanded = bExpanded;

}  //*** CTreeItem::SetExpandedState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::BShouldBeExpanded
//
//  Routine Description:
//      Returns whether the item should be expanded in the specified tree
//      view based on the user's profile.
//
//  Arguments:
//      pctv        [IN] Tree view in which expanded state is being saved.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItem::BShouldBeExpanded(IN const CClusterTreeView * pctv) const
{
    CTreeItemContext *  ptic;

    ASSERT_VALID(pctv);

    ptic = PticFromView(pctv);
    ASSERT_VALID(ptic);
    return ptic->m_bExpanded;

}  //*** CTreeItem::BShouldBeExpanded()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::UpdateState(void)
{
    ASSERT_VALID(this);
    ASSERT_VALID(Pci());

    // Ask the item to update its state.
    if (Pci() != NULL)
        Pci()->UpdateState();

}  //*** CTreeItem::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::UpdateAllStatesInTree
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::UpdateAllStatesInTree(void)
{
    POSITION    posPti;
    CTreeItem * ptiChild;

    UpdateState();
    posPti = LptiChildren().GetHeadPosition();
    while (posPti != NULL)
    {
        ptiChild = LptiChildren().GetNext(posPti);
        ASSERT_VALID(ptiChild);
        ptiChild->UpdateAllStatesInTree();
    }  // while:  more children

}  //*** CTreeItem::UpdateAllStatesInTree()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::UpdateUIState
//
//  Routine Description:
//      Update the current UI state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::UpdateUIState(void)
{
    POSITION            posPtic;
    CTreeItemContext *  ptic;
    UINT                nMask;
    UINT                nImage;
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
    CString             strText;
#endif

    ASSERT_VALID(Pci());

    // Loop through the views and update the state on each one.
    posPtic = Lptic().GetHeadPosition();
    while (posPtic != NULL)
    {
        ptic = Lptic().GetNext(posPtic);
        ASSERT_VALID(ptic);

        // Set the images that are displayed for the item.
        ASSERT_VALID(ptic->m_pframe);
        ASSERT_VALID(ptic->m_pframe->PviewTree());
        nMask = TVIF_TEXT;
        if (Pci() == NULL)
        {
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
            strText = StrName();
#endif
            nImage = 0;
        }  // if:  invalid cluster item
        else
        {
            nMask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
            Pci()->GetTreeName(strText);
#endif
            nImage = Pci()->IimgState();
        }  // else:  valid cluster item
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
        Trace(g_tagTreeItemUpdate, _T("Updating item '%s' (pci name = '%s')"), strText, Pci()->StrName());
#else
        Trace(g_tagTreeItemUpdate, _T("Updating item '%s' (pci name = '%s')"), StrName(), Pci()->StrName());
#endif
        ptic->m_pframe->PviewTree()->GetTreeCtrl().SetItem(
                                            ptic->m_hti,    // hItem
                                            nMask,          // nMask
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
                                            strText,        // lpszItem
#else
                                            StrName(),      // lpszItem
#endif
                                            nImage,         // nImage
                                            nImage,         // nSelectedImage
                                            0,              // nState
                                            0,              // nStatemask
                                            NULL            // lParam
                                            );
    }  // while:  more view

}  //*** CTreeItem::UpdateUIState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItem::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    if (Pci() != NULL)
    {
        // Give the cluster item a chance to handle the message.
        if (Pci()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
            return TRUE;
    }  // if:  valid cluster item

    return CBaseCmdTarget::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

}  //*** CTreeItem::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::OpenChild
//
//  Routine Description:
//      Open the specified child item.
//
//  Arguments:
//      pti         [IN OUT] Child tree item to open.
//      pframe      [IN OUT] Frame in which to open the item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::OpenChild(
    IN OUT CTreeItem *      pti,
    IN OUT CSplitterFrame * pframe
    )
{
    CTreeItemContext *  ptic;

    ASSERT_VALID(pti);
    ASSERT_VALID(pframe);

    // Find the tree item context for the frame.
    ptic = PticFromFrame(pframe);
    ASSERT_VALID(ptic);

    // Expand the parent item and then select the child item.
    if (pframe->PviewTree()->GetTreeCtrl().Expand(ptic->m_hti, TVE_EXPAND))
        pti->Select(pframe->PviewTree(), TRUE /*bSelectInTree*/);

}  //*** CTreeItem::OpenChild()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItem::EditLabel
//
//  Routine Description:
//      Processes the ID_FILE_RENAME menu command.
//
//  Arguments:
//      pctv        [IN OUT] Cluster tree view item is being edited in.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::EditLabel(IN OUT CClusterTreeView * pctv)
{
    HTREEITEM   hti;

    ASSERT_VALID(pctv);
    ASSERT_VALID(Pci());
    ASSERT(Pci()->BCanBeEdited());

    hti = HtiFromView(pctv);
    ASSERT(hti != NULL);
    pctv->GetTreeCtrl().EditLabel(hti);

}  //*** CTreeItem::EditLabel()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// CTreeItemContext
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CTreeItemContext, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItemContext::Init
//
//  Routine Description:
//      Initialize the tree item context.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItemContext::Init(void)
{
    BOOL    bExpanded;
    UINT    cbColumnInfo;
    CString strValueName;

    ASSERT_VALID(m_pti);
    ASSERT(m_pti->StrProfileSection().GetLength() > 0);
    ASSERT(m_prgnColumnInfo == NULL);

    try
    {
        // Read the expanded state.
        m_pframe->ConstructProfileValueName(strValueName, REGPARAM_EXPANDED);
        bExpanded = AfxGetApp()->GetProfileInt(
            m_pti->StrProfileSection(),
            strValueName,
            m_bExpanded
            );
        if (bExpanded)
            m_bExpanded = bExpanded;

        // Read the column information.
        m_pframe->ConstructProfileValueName(strValueName, REGPARAM_COLUMNS);
        AfxGetApp()->GetProfileBinary(
            m_pti->StrProfileSection(),
            strValueName,
            (BYTE **) &m_prgnColumnInfo,
            &cbColumnInfo
            );
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

}  //*** CTreeItemContext::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItemContext::SaveProfileInfo
//
//  Routine Description:
//      Save state information to the user's profile.  This includes column
//      widths and positions as well as whether the tree item was expanded
//      or not.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItemContext::SaveProfileInfo(void)
{
    CString     strValueName;

    try
    {
        ASSERT_VALID(m_pti);
        ASSERT(m_pti->StrProfileSection().GetLength() > 0);

        // Save expansion info to the user's profile.
        m_pframe->ConstructProfileValueName(strValueName, REGPARAM_EXPANDED);
        AfxGetApp()->WriteProfileInt(
            m_pti->StrProfileSection(),
            strValueName,
            m_bExpanded
            );

        if (m_prgnColumnInfo != NULL)
        {
            // Save column info to the user's profile.
            m_pframe->ConstructProfileValueName(strValueName, REGPARAM_COLUMNS);
            AfxGetApp()->WriteProfileBinary(
                m_pti->StrProfileSection(),
                strValueName,
                (PBYTE) m_prgnColumnInfo,
                ((m_prgnColumnInfo[0] * 2) + 1) * sizeof(DWORD)
                );
        }  // if:  there is column info
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

}  //*** CTreeItemContext::SaveProfileInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItemContext::PrgnColumnInfo
//
//  Routine Description:
//      Return the column info.  If it doesn't exist or isn't the right
//      size, allocate one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      prgnColumnInfo  The column info array.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD * CTreeItemContext::PrgnColumnInfo(void)
{
    DWORD   cColumns;

    ASSERT_VALID(m_pti);

    cColumns = (DWORD)m_pti->Lpcoli().GetCount();

    if ((m_prgnColumnInfo == NULL)
            || (cColumns != m_prgnColumnInfo[0]))
    {
        DWORD cnColumnInfo = (cColumns * 2) + 1;
        delete [] m_prgnColumnInfo;
        m_prgnColumnInfo = new DWORD[cnColumnInfo];
        if (m_prgnColumnInfo == NULL)
        {
            ThrowStaticException(GetLastError());
        } // if: error allocating column info array

        //
        // Initialize the column info array
        //
        {
            DWORD   inColumnInfo;

            // The first entry is the number of columns.
            m_prgnColumnInfo[0] = cColumns;

            // The second set of entries is the width of each column.
            {
                POSITION        pos;
                CColumnItem *   pcoli;

                inColumnInfo = 1;
                pos = m_pti->Lpcoli().GetHeadPosition();
                while (pos != NULL)
                {
                    pcoli = m_pti->Lpcoli().GetNext(pos);
                    ASSERT_VALID(pcoli);

                    ASSERT(inColumnInfo <= cColumns);
                    m_prgnColumnInfo[inColumnInfo++] = pcoli->NWidth();
                }  // while:  more items in the list
            }  // The second set of entries is the width of each column

            // The third set of entries is the order of the columns.
            {
                DWORD * prgnColumnInfo = &m_prgnColumnInfo[inColumnInfo];
                for (inColumnInfo = 0 ; inColumnInfo < cColumns ; inColumnInfo++)
                    prgnColumnInfo[inColumnInfo] = inColumnInfo;
            }  // The third set of entries is the order of the columns
        }  // Initialize the column info array
    }  // if:  column info array doesn't exist or is wrong size

    return m_prgnColumnInfo;

}  //*** CTreeItemContext::PrgnColumnInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTreeItemContext::BIsExpanded
//
//  Routine Description:
//      Return the EXPANDED state of the item in this tree view.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Item is expanded.
//      FALSE       Item is not expanded.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTreeItemContext::BIsExpanded(void) const
{
    ASSERT_VALID(this);
    ASSERT_VALID(m_pframe);
    ASSERT_VALID(m_pframe->PviewTree());
    ASSERT(m_hti != NULL);
    return (m_pframe->PviewTree()->GetTreeCtrl().GetItemState(m_hti, TVIS_EXPANDED) == TVIS_EXPANDED);

}  //*** CTreeItemContext::BIsExpanded()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DestructElements
//
//  Routine Description:
//      Destroys CTreeItem* elements.
//
//  Arguments:
//      pElements   Array of pointers to elements to destruct.
//      nCount      Number of elements to destruct.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////

template<>
void AFXAPI DestructElements(CTreeItem ** pElements, INT_PTR nCount)
{
    ASSERT(nCount == 0 ||
        AfxIsValidAddress(pElements, nCount * sizeof(CTreeItem *)));

    // call the destructor(s)
    for (; nCount--; pElements++)
    {
        ASSERT_VALID(*pElements);
        (*pElements)->Release();
    }  // for:  each item in the array

}  //*** DestructElements(CTreeItem**)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] Reference to the list whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData(IN OUT CTreeItemList & rlp)
{
    POSITION    pos;
    CTreeItem * pti;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        pti = rlp.GetNext(pos);
        ASSERT_VALID(pti);
//      Trace(g_tagTreeItemDelete, _T("DeleteAllItemData(rlpti) - Deleting tree item '%s'"), pti->Pci()->StrName());
        pti->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] Reference to the list whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData(IN OUT CTreeItemContextList & rlp)
{
    POSITION            pos;
    CTreeItemContext *  ptic;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        ptic = rlp.GetNext(pos);
        ASSERT_VALID(ptic);
        delete ptic;
    }  // while:  more items in the list

}  //*** DeleteAllItemData()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\tracedlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      TraceDlg.cpp
//
//  Abstract:
//      Implementation of the CTraceDialog class.
//
//  Author:
//      David Potter (davidp)   May 29, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#define _RESOURCE_H_
#include "TraceDlg.h"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CTraceDialog dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CTraceDialog, CDialog)
    //{{AFX_MSG_MAP(CTraceDialog)
    ON_BN_CLICKED(IDC_TS_SELECT_ALL, OnSelectAll)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_TS_LISTBOX, OnItemChangedListbox)
    ON_BN_CLICKED(IDC_TS_TRACE_TO_DEBUG, OnClickedTraceToDebug)
    ON_BN_CLICKED(IDC_TS_TRACE_DEBUG_BREAK, OnClickedTraceDebugBreak)
    ON_BN_CLICKED(IDC_TS_TRACE_TO_COM2, OnClickedTraceToCom2)
    ON_BN_CLICKED(IDC_TS_TRACE_TO_FILE, OnClickedTraceToFile)
    ON_CBN_SELCHANGE(IDC_TS_TAGS_TO_DISPLAY_CB, OnSelChangeTagsToDisplay)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_TS_LISTBOX, OnColumnClickListbox)
    ON_BN_CLICKED(IDC_TS_DEFAULT, OnDefault)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::CTraceDialog
//
//  Routine Description:
//      Constructor.  Initializes the dialog class.
//
//  Arguments:
//      pParent     [IN OUT] Parent window.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceDialog::CTraceDialog(CWnd * pParent /*=NULL*/)
    : CDialog(CTraceDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(CTraceDialog)
    m_strFile = _T("");
    //}}AFX_DATA_INIT

}  //*** CTraceDialog::CTraceDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTraceDialog)
    DDX_Control(pDX, IDC_TS_LISTBOX, m_lcTagList);
    DDX_Control(pDX, IDC_TS_TRACE_TO_DEBUG, m_chkboxTraceToDebugWin);
    DDX_Control(pDX, IDC_TS_TRACE_DEBUG_BREAK, m_chkboxDebugBreak);
    DDX_Control(pDX, IDC_TS_TRACE_TO_COM2, m_chkboxTraceToCom2);
    DDX_Control(pDX, IDC_TS_TRACE_TO_FILE, m_chkboxTraceToFile);
    DDX_Control(pDX, IDC_TS_FILE, m_editFile);
    DDX_Control(pDX, IDC_TS_TAGS_TO_DISPLAY_CB, m_cboxDisplayOptions);
    DDX_Text(pDX, IDC_TS_FILE, m_strFile);
    //}}AFX_DATA_MAP

}  //*** CTraceDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTraceDialog::OnInitDialog(void)
{
    CDialog::OnInitDialog();

    // Set the dialog flags.
    {
        CTraceTag * ptag;

        ptag = CTraceTag::s_ptagFirst;
        while (ptag != NULL)
        {
            ptag->m_uiFlagsDialog = ptag->m_uiFlags;
            ptag = ptag->m_ptagNext;
        }  // while:  more tags in the list
    }  // Set the dialog flags

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        dwExtendedStyle = m_lcTagList.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcTagList.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    // Set the columns in the listbox.
    VERIFY(m_lcTagList.InsertColumn(0, TEXT("Section"), LVCFMT_LEFT, 75) != -1);
    VERIFY(m_lcTagList.InsertColumn(1, TEXT("Name"), LVCFMT_LEFT, 125) != -1);
    VERIFY(m_lcTagList.InsertColumn(2, TEXT("State"), LVCFMT_CENTER, 50) != -1);

    // Load the combobox.
    /*0*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("All Tags")) != CB_ERR);
    /*1*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("Debug Window Enabled")) != CB_ERR);
    /*2*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("Break Enabled")) != CB_ERR);
    /*3*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("COM2 Enabled")) != CB_ERR);
    /*4*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("File Enabled")) != CB_ERR);
    /*5*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("Anything Enabled")) != CB_ERR);
    VERIFY(m_cboxDisplayOptions.SetCurSel(0) != CB_ERR);
    m_nCurFilter = 0;

    // Set maximum length of the file edit control.
    m_editFile.LimitText(_MAX_PATH);

    // Load the listbox.
    LoadListbox();

    // Set sort info.
    m_nSortDirection = -1;
    m_nSortColumn = -1;

    m_strFile = CTraceTag::PszFile();
    m_nCurFilter = -1;

    UpdateData(FALSE);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CTraceDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::ConstructStateString [static]
//
//  Routine Description:
//      Construct a string to display from the state of the trace tag.
//
//  Arguments:
//      ptag        [IN] Tag from which to construct the state string.
//      rstr        [OUT] String in which to return the state string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::ConstructStateString(
    IN const CTraceTag *    ptag,
    OUT CString &           rstr
    )
{
    rstr = "";
    if (ptag->BDebugDialog())
        rstr += "D";
    if (ptag->BBreakDialog())
        rstr += "B";
    if (ptag->BCom2Dialog())
        rstr += "C";
    if (ptag->BFileDialog())
        rstr += "F";

}  //*** CTraceDialog::ConstructStateString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnOK
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnOK(void)
{
    CTraceTag * ptag;
    CString     strSection;
    CString     strState;

    // Write tag states.
    ptag = CTraceTag::s_ptagFirst;
    while (ptag != NULL)
    {
        if (ptag->m_uiFlags != ptag->m_uiFlagsDialog)
        {
            ptag->m_uiFlags = ptag->m_uiFlagsDialog;
            strSection.Format(TRACE_TAG_REG_SECTION_FMT, ptag->PszSubsystem());
            ptag->ConstructRegState(strState);
            AfxGetApp()->WriteProfileString(strSection, ptag->PszName(), strState);
        }  // if:  tag state changed
        ptag = ptag->m_ptagNext;
    }  // while:  more tags int he list.

    // Write the file.
    if (m_strFile != CTraceTag::PszFile())
    {
        g_strTraceFile = m_strFile;
        AfxGetApp()->WriteProfileString(TRACE_TAG_REG_SECTION, TRACE_TAG_REG_FILE, m_strFile);
    }  // if:  file changed

    CDialog::OnOK();

}  //*** CTraceDialog::OnOK()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnSelectAll
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Select All button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnSelectAll(void)
{
    int     ili;

    // Select all the items in the list control.
    ili = m_lcTagList.GetNextItem(-1, LVNI_ALL);
    while (ili != -1)
    {
        m_lcTagList.SetItemState(ili, LVIS_SELECTED, LVIS_SELECTED);
        ili = m_lcTagList.GetNextItem(ili, LVNI_ALL);
    }  // while:  more items in the list

}  //*** CTraceDialog::OnSelectAll()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnDefault
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Default button.
//      Resets the trace tags to their default settings.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnDefault(void)
{
    CTraceTag * ptag;
    
    ptag = CTraceTag::s_ptagFirst;
    while (ptag != NULL)
    {
        ptag->m_uiFlagsDialog = ptag->m_uiFlagsDefault;
        ptag = ptag->m_ptagNext;
    }  // while:  more tags int he list.

    // Reload the listbox, keeping the same items
    LoadListbox();

}  //*** CTraceDialog::OnDefault()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnItemChangedListbox
//
//  Routine Description:
//      Handler for the LVN_ITEMCHANGED message on the listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnItemChangedListbox(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;

    // If the item just became unselected or selected, change the checkboxes to match.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                || (pNMListView->uNewState & LVIS_SELECTED)))
    {
        // Handle a selection change.
        OnSelChangedListbox();
    }  // if:  item received the focus

    *pResult = 0;

}  //*** CTraceDialog::OnItemChangedListbox()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnSelChangedListbox
//
//  Routine Description:
//      Handles all that needs to when the listbox selection changes. That
//      is adjust the checkbox to their new value and determine if they need
//      to be simple or TRI-state checkboxes.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnSelChangedListbox(void)
{
    int         ili;
    int         nDebugWin       = BST_UNCHECKED;
    int         nDebugBreak     = BST_UNCHECKED;
    int         nCom2           = BST_UNCHECKED;
    int         nFile           = BST_UNCHECKED;
    BOOL        bFirstItem      = TRUE;
    CTraceTag * ptag;

    ili = m_lcTagList.GetNextItem(-1, LVNI_SELECTED);
    while (ili != -1)
    {
        // Get the tag for the selected item.
        ptag = (CTraceTag *) m_lcTagList.GetItemData(ili);
        ASSERT(ptag != NULL);

        ptag->m_uiFlagsDialogStart = ptag->m_uiFlagsDialog;
        if (bFirstItem)
        {
            nDebugWin = ptag->BDebugDialog();
            nDebugBreak = ptag->BBreakDialog();
            nCom2 = ptag->BCom2Dialog();
            nFile = ptag->BFileDialog();
            bFirstItem = FALSE;
        }  // if:  first selected item
        else
        {
            if (ptag->BDebugDialog() != nDebugWin)
                nDebugWin = BST_INDETERMINATE;
            if (ptag->BBreakDialog() != nDebugBreak)
                nDebugBreak = BST_INDETERMINATE;
            if (ptag->BCom2Dialog() != nCom2)
                nCom2 = BST_INDETERMINATE;
            if (ptag->BFileDialog() != nFile)
                nFile = BST_INDETERMINATE;
        }  // else:  not first selected item

        // Get the next selected item.
        ili = m_lcTagList.GetNextItem(ili, LVNI_SELECTED);
    }  // while:  more selected items

    AdjustButton(!bFirstItem, m_chkboxTraceToDebugWin, nDebugWin);
    AdjustButton(!bFirstItem, m_chkboxDebugBreak, nDebugBreak);
    AdjustButton(!bFirstItem, m_chkboxTraceToCom2, nCom2);
    AdjustButton(!bFirstItem, m_chkboxTraceToFile, nFile);

}  //*** CTraceDialog::OnSelChangedListbox()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::AdjustButton
//
//  Routine Description:
//      Configures the checkboxes of the dialog.  This includes setting the
//      style and the value of the buttons.
//
//  Arguments:
//      bEnable     [IN] Determines if the given checkbox is enabled or not
//                    (not when the selection is NULL!).
//      rchkbox     [IN OUT] Checkbox to adjust.
//      nState      [IN] State of the button (BST_CHECKED, BST_UNCHECKED,
//                    or BST_INDETERMINATE).
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::AdjustButton(
    IN BOOL             bEnable,
    IN OUT CButton &    rchkbox,
    IN int              nState
    )
{
    rchkbox.EnableWindow(bEnable);
    
    if (nState == BST_INDETERMINATE)
        rchkbox.SetButtonStyle(BS_AUTO3STATE, FALSE);
    else
        rchkbox.SetButtonStyle(BS_AUTOCHECKBOX, FALSE);

    rchkbox.SetCheck(nState);

}  //*** CTraceDialog::AdjustButton()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnColumnClickListbox
//
//  Routine Description:
//      Handler for the LVN_COLUMNCLICK message on the listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnColumnClickListbox(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    // Save the current sort column and direction.
    if (pNMListView->iSubItem == NSortColumn())
        m_nSortDirection ^= -1;
    else
    {
        m_nSortColumn = pNMListView->iSubItem;
        m_nSortDirection = 0;
    }  // else:  different column

    // Sort the list.
    VERIFY(m_lcTagList.SortItems(CompareItems, (LPARAM) this));

    *pResult = 0;

}  //*** CTraceDialog::OnColumnClickListbox()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CTraceDialog::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CTraceTag *     ptag1   = (CTraceTag *) lparam1;
    CTraceTag *     ptag2   = (CTraceTag *) lparam2;
    CTraceDialog *  pdlg    = (CTraceDialog *) lparamSort;
    int             nResult;

    ASSERT(ptag1 != NULL);
    ASSERT(ptag2 != NULL);
    ASSERT_VALID(pdlg);
    ASSERT(pdlg->NSortColumn() >= 0);

    switch (pdlg->NSortColumn())
    {
        // Sorting by subsystem.
        case 0:
            nResult = _tcscmp(ptag1->PszSubsystem(), ptag2->PszSubsystem());
            break;

        // Sorting by name.
        case 1:
            nResult = _tcscmp(ptag1->PszName(), ptag2->PszName());
            break;

        // Sorting by state.
        case 2:
        {
            CString strState1;
            CString strState2;

            ConstructStateString(ptag1, strState1);
            ConstructStateString(ptag2, strState2);

            // Compare the two strings.
            // Use CompareString() so that it will sort properly on localized builds.
            nResult = CompareString(
                        LOCALE_USER_DEFAULT,
                        0,
                        strState1,
                        strState1.GetLength(),
                        strState2,
                        strState2.GetLength()
                        );
            if ( nResult == CSTR_LESS_THAN )
            {
                nResult = -1;
            }
            else if ( nResult == CSTR_EQUAL )
            {
                nResult = 0;
            }
            else if ( nResult == CSTR_GREATER_THAN )
            {
                nResult = 1;
            }
            else
            {
                // An error occurred.  Ignore it.
                nResult = 0;
            }
            break;
        }  // if:  sorting by state

        default:
            nResult = 0;
            break;
    }  // switch:  pdlg->NSortColumn()

    // Return the result based on the direction we are sorting.
    if (pdlg->NSortDirection() != 0)
        nResult = -nResult;

    return nResult;

}  //*** CTraceDialog::CompareItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnClickedTraceToDebug
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Trace to Debug Window checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnClickedTraceToDebug(void)
{
    ChangeState(m_chkboxTraceToDebugWin, CTraceTag::tfDebug);

}  //*** CTraceDialog::OnClickedTraceToDebug()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnClickedTraceDebugBreak
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Debug Break checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnClickedTraceDebugBreak(void)
{
    ChangeState(m_chkboxDebugBreak, CTraceTag::tfBreak);

}  //*** CTraceDialog::OnClickedTraceDebugBreak()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnClickedTraceToCom2
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Trace to COM2 checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnClickedTraceToCom2(void)
{
    ChangeState(m_chkboxTraceToCom2, CTraceTag::tfCom2);

}  //*** CTraceDialog::OnClickedTraceToCom2()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnClickedTraceToFile
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Trace to File checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnClickedTraceToFile(void)
{
    ChangeState(m_chkboxTraceToFile, CTraceTag::tfFile);

}  //*** CTraceDialog::OnClickedTraceToFile()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::ChangeState
//
//  Routine Description:
//      Change the state of selected items.
//
//  Arguments:
//      rchkbox     [IN OUT] Checkbox whose state is changing.
//      tfMask      [IN] Mask of state flags to change.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::ChangeState(
    IN OUT CButton &            rchkbox,
    IN CTraceTag::TraceFlags    tfMask
    )
{
    int             ili;
    CTraceTag *     ptag;
    CString         strState;
    int             nState;

    nState = rchkbox.GetCheck();

    // Set the proper flag on all selected items.
    ili = m_lcTagList.GetNextItem(-1, LVNI_SELECTED);
    while (ili != -1)
    {
        // Get the selected item.
        ptag = (CTraceTag *) m_lcTagList.GetItemData(ili);
        ASSERT(ptag != NULL);

        // Set the proper flag in the trace tag.
        if (nState == BST_INDETERMINATE)
        {
            ptag->m_uiFlagsDialog &= ~tfMask;
            ptag->m_uiFlagsDialog |= (tfMask & ptag->m_uiFlagsDialogStart);
        }  // if:  checkbox is in an indeterminate state
        else
            ptag->SetFlagsDialog(tfMask, nState);

        // Set the State column.
        ConstructStateString(ptag, strState);
        VERIFY(m_lcTagList.SetItem(ili, 2, LVIF_TEXT, strState, 0, 0, 0, 0) != 0);

        // Get the next item.
        ili = m_lcTagList.GetNextItem(ili, LVNI_SELECTED);
    }  // while:  more items in the list

}  //*** CTraceDialog::ChangeState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnSelChangeTagsToDisplay
//
//  Routine Description:
//      Handler for the CBN_SELCHANGE message on the Tags To Display combobox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnSelChangeTagsToDisplay(void)
{
    int             nCurFilter;

    // If a change was actually made, reload the listbox.
    nCurFilter = m_cboxDisplayOptions.GetCurSel();
    if (nCurFilter != m_nCurFilter)
    {
        m_nCurFilter = nCurFilter;
        LoadListbox();
    }  // if:  filter changed

}  //*** CTraceDialog::OnSelChangeTagsToDisplay()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::LoadListbox
//
//  Routine Description:
//      Load the listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::LoadListbox(void)
{
    int             ili;
    int             iliReturn;
    CTraceTag *     ptag;
    CString         strState;

    m_lcTagList.DeleteAllItems();
    ptag = CTraceTag::s_ptagFirst;
    for (ili = 0 ; ptag != NULL ; )
    {
        // Insert the item in the list if it should be displayed.
        if (BDisplayTag(ptag))
        {
            iliReturn = m_lcTagList.InsertItem(
                                        LVIF_TEXT | LVIF_PARAM,
                                        ili,
                                        ptag->PszSubsystem(),
                                        0,
                                        0,
                                        0,
                                        (LPARAM) ptag
                                        );
            ASSERT(iliReturn != -1);
            VERIFY(m_lcTagList.SetItem(iliReturn, 1, LVIF_TEXT, ptag->PszName(), 0, 0, 0, 0) != 0);
            ConstructStateString(ptag, strState);
            VERIFY(m_lcTagList.SetItem(iliReturn, 2, LVIF_TEXT, strState, 0, 0, 0, 0) != 0);
            ili++;
        }  // if:  tag shold be displayed

        // Get the next tag.
        ptag = ptag->m_ptagNext;
    }  // while:  more tags in the list

    // If the list is not empty, select the first item.
    if (m_lcTagList.GetItemCount() > 0)
        VERIFY(m_lcTagList.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED) != 0);

}  //*** CTraceDialog::LoadListbox()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::BDisplayTag
//
//  Purpose:
//      Determines if a given tag should be displayed based on
//      the current filter selection.
//
//  Arguments:
//      ptag        [IN] Pointer to the tag to test
//
//  Return Value:
//      TRUE        Display the tag.
//      FALSE       Don't display the tag.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTraceDialog::BDisplayTag(IN const CTraceTag * ptag)
{
    BOOL    bDisplay        = TRUE;
    
    switch (m_nCurFilter)
    {
        default:
//          AssertAlways(LITERAL("Unknown Filter, adjust CTraceDialog::FDisplayFilter"));
            break;

        case 0:
            break;

        case 1:
            if (!ptag->BDebugDialog())
                bDisplay = FALSE;
            break;
            
        case 2:
            if (!ptag->BBreakDialog())
                bDisplay = FALSE;
            break;

        case 3:
            if (!ptag->BCom2Dialog())
                bDisplay = FALSE;
            break;

        case 4:
            if (!ptag->BFileDialog())
                bDisplay = FALSE;
            break;

        case 5:
            if (!ptag->m_uiFlagsDialog)
                bDisplay = FALSE;
            break;
    }
    
    return bDisplay;

}  //*** CTraceDialog::BDisplayTag()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\treeitem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		TreeItem.h
//
//	Abstract:
//		Definition of the CTreeItem class.
//
//	Implementation File:
//		TreeItem.cpp
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#define _TREEITEM_H_

#ifndef __AFXTEMPL_H__
#include "afxtempl.h"	// for CList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CTreeItemList;
class CTreeItemContext;
class CTreeItem;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CSplitterFrame;
class CClusterListView;
class CClusterTreeView;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CTreeItemContext *, CTreeItemContext *> CTreeItemContextList;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASECMDT_H_
#include "BaseCmdT.h"	// for CBaseCmdTarget
#endif

#ifndef _COLITEM_H_
#include "ColItem.h"	// for CColumnItem
#endif

#ifndef _LISTITEM_H_
#include "ListItem.h"	// for CListItemList
#endif

/////////////////////////////////////////////////////////////////////////////
// CTreeItemList
/////////////////////////////////////////////////////////////////////////////

class CTreeItemList : public CList<CTreeItem *, CTreeItem *>
{
public:
	CTreeItem *		PtiFromPci(
						IN const CClusterItem *	pci,
						OUT POSITION *			ppos = NULL
						) const;

	// add before head or after tail
	POSITION AddHead(CTreeItem * newElement);
	POSITION AddTail(CTreeItem * newElement);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CTreeItem * newElement);
	POSITION InsertAfter(POSITION position, CTreeItem * newElement);

};  //*** class CTreeItemList

/////////////////////////////////////////////////////////////////////////////
// CTreeItemContext
/////////////////////////////////////////////////////////////////////////////

class CTreeItemContext : public CObject
{
	DECLARE_DYNCREATE(CTreeItemContext)

public:
	CSplitterFrame *	m_pframe;
	CTreeItem *			m_pti;
	HTREEITEM			m_hti;
	BOOL				m_bExpanded;
	DWORD *				m_prgnColumnInfo;

	CTreeItemContext(void)
	{
		CommonConstruct();
	};
	CTreeItemContext(
		CSplitterFrame *	pframe,
		CTreeItem *			pti,
		HTREEITEM			hti,
		BOOL				bExpanded
		)
	{
		CommonConstruct();
		m_pframe = pframe;
		m_pti = pti;
		m_hti = hti;
		m_bExpanded = bExpanded;
	}
	~CTreeItemContext(void)
	{
		SaveProfileInfo();
		delete [] m_prgnColumnInfo;
		m_prgnColumnInfo = NULL;
	}
		
	void CommonConstruct(void)
	{
		m_pframe = NULL;
		m_pti = NULL;
		m_hti = NULL;
		m_bExpanded = FALSE;
		m_prgnColumnInfo = NULL;
	}
	void Init(void);
	void SaveProfileInfo(void);
	DWORD * PrgnColumnInfo(void);

	BOOL BIsExpanded(void) const;

};  //*** class CTreeItemContext

/////////////////////////////////////////////////////////////////////////////
// CTreeItem command target
/////////////////////////////////////////////////////////////////////////////

class CTreeItem : public CBaseCmdTarget
{
	friend class CClusterTreeView;

	DECLARE_DYNCREATE(CTreeItem)

	CTreeItem(void);				// protected constructor used by dynamic creation
	CTreeItem(IN OUT CTreeItem * ptiParent, IN OUT CClusterItem * pci, IN BOOL m_fTakeOwnership = FALSE);
	void					Init(void);

// Attributes
protected:
	CTreeItem *				m_ptiParent;
	CClusterItem *			m_pci;
	BOOL					m_bWeOwnPci;
	CString					m_strProfileSection;

	CColumnItemList			m_lpcoli;
	CTreeItemList			m_lptiChildren;
	CListItemList			m_lpliChildren;

	CTreeItemContextList	m_lptic;

	const CTreeItemContextList &	Lptic(void) const		{ return m_lptic; }

public:
	CTreeItem *				PtiParent(void) const			{ return m_ptiParent; }
	CClusterItem *			Pci(void) const					{ return m_pci; }
	const CString &			StrProfileSection(void);

	const CColumnItemList &	Lpcoli(void) const				{ return m_lpcoli; }
	const CTreeItemList &	LptiChildren(void) const		{ return m_lptiChildren; }
	const CListItemList &	LpliChildren(void) const		{ return m_lpliChildren; }

	const CString &			StrName(void) const;

	DWORD *					PrgnColumnInfo(IN const CClusterListView * pclv)
	{
		CTreeItemContext *	ptic;

		ptic = PticFromView(pclv);
		ASSERT_VALID(ptic);
		return ptic->PrgnColumnInfo();

	}  //*** CTreeItem::PrgnColumnInfo()

// Operations
public:
	HTREEITEM				HtiInsertInTree(IN OUT CClusterTreeView * pctv);
	void					RemoveFromAllLists(void);
	void					PreRemoveFromFrame(IN OUT CSplitterFrame * pframe);
	void					PreRemoveFromFrameWithChildren(IN OUT CSplitterFrame * pframe);
	CColumnItem *			PcoliAddColumn(
								IN const CString &	rstrText,
								IN IDS				idsColumnID,
								IN int				nDefaultWidth = -1,
								IN int				nWidth = -1
								);
	CColumnItem *			PcoliAddColumn(IN IDS idsText, IN int nDefaultWidth = -1, IN int nWidth = -1);
	void					DeleteAllColumns(void)			{ m_lpcoli.RemoveAll(); }
	void					UpdateState(void);
	void					UpdateAllStatesInTree(void);
	void					UpdateUIState(void);

	void					Select(IN OUT CClusterTreeView * pctv, IN BOOL bSelectInTree);
//	void					Unselect(CClusterTreeView * pctv);

	CTreeItem *				PtiAddChildBefore(
								IN const CClusterItem *	pciOld,
								OUT CClusterItem *		pciNew,
								IN BOOL					bTakeOwnership = FALSE
								);
	void					InsertChildInAllTrees(IN OUT CTreeItem * ptiNewChild);
	CTreeItem *				PtiAddChild(IN OUT CClusterItem * pci, IN BOOL bTakeOwnership = FALSE);
	CTreeItem *				PtiAddChild(IN const CString & rstrName);
	CTreeItem *				PtiAddChild(IN IDS idsName);
	CListItem *				PliAddChild(IN OUT CClusterItem * pci);

	CTreeItem *				PtiChildFromName(IN const CString & rstrName, OUT POSITION * ppos = NULL) const;
	CTreeItem *				PtiChildFromName(IN IDS idsName, OUT POSITION * ppos = NULL) const;
	CTreeItem *				PtiChildFromPci(IN const CClusterItem * pci) const;
	CListItem *				PliChildFromPci(IN const CClusterItem * pci) const;

	void					RemoveItem(void);
	void					RemoveChild(IN OUT CClusterItem * pci);

	CMenu *					PmenuPopup(void);
	BOOL					BSelectItem(IN OUT CClusterTreeView * pctv);
	BOOL					BExpand(IN OUT CClusterTreeView * pctv, IN UINT nCode);
	void					SelectInAllViews(void);
	void					ExpandInAllViews(IN UINT nCode);
	void					SetExpandedState(IN const CClusterTreeView * pctv, IN BOOL bExpanded);
	BOOL					BShouldBeExpanded(IN const CClusterTreeView * pctv) const;

	void					OpenChild(IN OUT CTreeItem * pti, IN OUT CSplitterFrame * pframe);
	void					EditLabel(IN OUT CClusterTreeView * pctv);

	void					Delete(void);

protected:
	void					Cleanup(void);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTreeItem)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual					~CTreeItem(void);

protected:
	CTreeItemContext *		PticFromFrame(IN const CSplitterFrame * pframe) const;
	CTreeItemContext *		PticFromView(IN const CClusterTreeView * pctv) const;
	CTreeItemContext *		PticFromView(IN const CClusterListView * pclv) const;
	HTREEITEM				HtiFromView(IN const CClusterTreeView * pctv) const;

	// Generated message map functions
	//{{AFX_MSG(CTreeItem)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CTreeItem

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

template<>
void AFXAPI DestructElements(CTreeItem ** pElements, INT_PTR nCount);
void DeleteAllItemData(IN OUT CTreeItemList & rlp);
void DeleteAllItemData(IN OUT CTreeItemContextList & rlp);

/////////////////////////////////////////////////////////////////////////////
// Inline Functions
/////////////////////////////////////////////////////////////////////////////

inline POSITION CTreeItemList::AddHead(CTreeItem * newElement)
{
	ASSERT_VALID(newElement);
	POSITION pos = CList<CTreeItem *,CTreeItem *>::AddHead(newElement);
	if (pos != NULL)
		newElement->AddRef();
	return pos;

}  //*** CTreeItemList::AddHead()

inline POSITION CTreeItemList::AddTail(CTreeItem * newElement)
{
	ASSERT_VALID(newElement);
	POSITION pos = CList<CTreeItem *,CTreeItem *>::AddTail(newElement);
	if (pos != NULL)
		newElement->AddRef();
	return pos;

}  //*** CTreeItemList::AddTail()

inline POSITION CTreeItemList::InsertBefore(POSITION position, CTreeItem * newElement)
{
	ASSERT_VALID(newElement);
	POSITION pos = CList<CTreeItem *,CTreeItem *>::InsertBefore(position, newElement);
	if (pos != NULL)
		newElement->AddRef();
	return pos;

}  //*** CTreeItemList::InsertBefore()

inline POSITION CTreeItemList::InsertAfter(POSITION position, CTreeItem * newElement)
{
	ASSERT_VALID(newElement);
	POSITION pos = CList<CTreeItem *,CTreeItem *>::InsertAfter(position, newElement);
	if (pos != NULL)
		newElement->AddRef();
	return pos;

}  //*** CTreeItemList::InsertAfter()

/////////////////////////////////////////////////////////////////////////////

#endif // _TREEITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\treeview.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		TreeView.h
//
//	Abstract:
//		Definition of the CClusterTreeView class.
//
//	Implementation File:
//		TreeView.cpp
//
//	Author:
//		David Potter (davidp)	May 1, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEVIEW_H_
#define _TREEVIEW_H_

/////////////////////////////////////////////////////////////////////////////
//	Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterTreeView;

/////////////////////////////////////////////////////////////////////////////
//	External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CSplitterFrame;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CClusterTreeView *, CClusterTreeView *> CClusterTreeViewList;

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#include "TreeItem.h"	// for CTreeItem
#endif

#ifndef _SPLITFRM_H
#include "SplitFrm.h"	// for CSplitterFrame
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterTreeView view
/////////////////////////////////////////////////////////////////////////////

class CClusterTreeView : public CTreeView
{
	friend class CTreeItem;
	friend class CClusterDoc;
	friend class CSplitterFrame;

protected: // create from serialization only
	CClusterTreeView(void);
	DECLARE_DYNCREATE(CClusterTreeView)

// Attributes
protected:
	CSplitterFrame *	m_pframe;

	BOOL				BDragging(void) const		{ ASSERT_VALID(Pframe()); return Pframe()->BDragging(); }
	CImageList *		Pimagelist(void) const		{ ASSERT_VALID(Pframe()); return Pframe()->Pimagelist(); }

public:
	CClusterDoc *		GetDocument(void);
	CSplitterFrame *	Pframe(void) const			{ return m_pframe; }
	CTreeItem *			PtiSelected(void) const;
	HTREEITEM			HtiSelected(void) const		{ return GetTreeCtrl().GetSelectedItem(); }

// Operations
public:
	CMenu *			PmenuPopup(
						IN CPoint &			rpointScreen,
						OUT CClusterItem *&	rpci
						);
	void			SaveCurrentSelection(void);
	void			ReadPreviousSelection(OUT CString & rstrSelection);

protected:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClusterTreeView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CClusterTreeView(void);
#ifdef _DEBUG
	virtual void	AssertValid(void) const;
	virtual void	Dump(CDumpContext& dc) const;
#endif

protected:
	// Label editing.
	CTreeItem *		m_ptiBeingEdited;
	BOOL			m_bShiftPressed;
	BOOL			m_bControlPressed;
	BOOL			m_bAltPressed;
	MSG				m_msgControl;

	// Drag & drop.
	HTREEITEM		m_htiDrag;
	CTreeItem *		m_ptiDrag;
	HTREEITEM		m_htiDrop;
	void			OnMouseMoveForDrag(IN UINT nFlags, IN CPoint point, IN const CWnd * pwndDrop);
	void			OnButtonUpForDrag(IN UINT nFlags, IN CPoint point);
	void			BeginDrag(void);
	void			EndDrag(void);
	
	BOOL			BAddItems(
						IN OUT CTreeItem *	pti,
						IN const CString &	rstrSelection,
						IN BOOL				bExpanded = FALSE
						);

// Generated message map functions
protected:
	//{{AFX_MSG(CClusterTreeView)
	afx_msg void OnDestroy();
	afx_msg void OnCmdRename();
	afx_msg void OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBeginLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in TreeView.cpp
inline CClusterDoc * CClusterTreeView::GetDocument(void)
   { return (CClusterDoc *) m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _TREEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\verinfo.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		VerInfo.h
//
//	Abstract:
//		Definition of the CVersionInfo class.
//
//	Implementation File:
//		VerInfo.cpp
//
//	Author:
//		David Potter (davidp)	October 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _VERINFO_H_
#define _VERINFO_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CVersionInfo;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVersionInfo:
/////////////////////////////////////////////////////////////////////////////

class CVersionInfo
{
public:
	// Construction
	CVersionInfo(void);
	~CVersionInfo(void);

	// Secondary construction.
	void		Init(void);

// Operations
public:
	LPCTSTR		PszQueryValue(IN LPCTSTR pszValueName);
	BOOL		BQueryValue(
					IN LPCTSTR	pszValueName,
					OUT DWORD &	rdwValue
					);
	const VS_FIXEDFILEINFO *	PffiQueryValue(void);
	void		QueryFileVersionDisplayString(OUT CString & rstrValue);

// Implementation
protected:
	LPBYTE		m_pbVerInfo;

	LPBYTE		PbVerInfo(void)		{ return m_pbVerInfo; }

};  //*** class CVersionInfo

/////////////////////////////////////////////////////////////////////////////

#endif // _VERINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\treeitem.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		TreeItem.inl
//
//	Abstract:
//		Inline function implementations for the CTreeItem class.
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_INL_
#define _TREEITEM_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#include "TreeItem.h"	// for CTreeItem
#endif

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItem
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline CMenu * CTreeItem::PmenuPopup(void)
{
	ASSERT(Pci() != NULL);
	return Pci()->PmenuPopup();

}  //*** CTreeItem::PmenuPopup()

inline const CString & CTreeItem::StrName(void) const
{
	ASSERT(Pci() != NULL);
	return Pci()->StrName();

}  //*** CTreeItem::StrName()

/////////////////////////////////////////////////////////////////////////////

#endif // _TREEITEM_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\treeview.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      TreeView.cpp
//
//  Abstract:
//      Implementation of the CClusterTreeView class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ClusDoc.h"
#include "TreeView.h"
#include "ListView.h"
#include "SplitFrm.h"
#include "TreeItem.inl"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagTreeView(_T("UI"), _T("TREE VIEW"), 0);
CTraceTag   g_tagTreeDrag(_T("Drag&Drop"), _T("TREE VIEW DRAG"), 0);
CTraceTag   g_tagTreeDragMouse(_T("Drag&Drop"), _T("TREE VIEW DRAG MOUSE"), 0);
CTraceTag   g_tagTreeViewSelect(_T("UI"), _T("TREE VIEW SELECT"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterTreeView
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterTreeView, CTreeView)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterTreeView, CTreeView)
    //{{AFX_MSG_MAP(CClusterTreeView)
    ON_WM_DESTROY()
    ON_COMMAND(ID_FILE_RENAME, OnCmdRename)
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelChanged)
    ON_NOTIFY_REFLECT(TVN_BEGINLABELEDIT, OnBeginLabelEdit)
    ON_NOTIFY_REFLECT(TVN_ENDLABELEDIT, OnEndLabelEdit)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED, OnItemExpanded)
    ON_NOTIFY_REFLECT(TVN_BEGINDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(TVN_BEGINRDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(TVN_KEYDOWN, OnKeyDown)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::CClusterTreeView
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterTreeView::CClusterTreeView(void)
{
    m_pframe = NULL;

    // Initialize label editing.
    m_ptiBeingEdited = NULL;
    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

    // Initialize drag & drop.
    m_htiDrag = NULL;
    m_ptiDrag = NULL;
    m_htiDrop = NULL;

}  //*** CClusterTreeView::CClusterTreeView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::~CClusterTreeView
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterTreeView::~CClusterTreeView(void)
{
}  //*** CClusterTreeView::~CClusterTreeView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::PreCreateWindow
//
//  Routine Description:
//      Called before the window has been created.
//
//  Arguments:
//      cs      CREATESTRUCT
//
//  Return Value:
//      TRUE    Successful.
//      FALSE   Failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::PreCreateWindow(CREATESTRUCT & cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CTreeView::PreCreateWindow(cs);

}  //*** CClusterTreeView::PreCreateWindow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::Create
//
//  Routine Description:
//      Create the window.
//
//  Arguments:
//      lpszClassName   [IN] Name of the window class to create.
//      lpszWindowName  [IN] Name of the window (used as the caption).
//      dwStyle         [IN] Window styles.
//      rect            [IN] Size and position of the window
//      pParentWnd      [IN OUT] Parent window.
//      nID             [IN] ID of the window.
//      pContext        [IN OUT] Create context of the window.
//
//  Return Value:
//      0               Successful.
//      !0              Unsuccessful.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::Create(
    LPCTSTR             lpszClassName,
    LPCTSTR             lpszWindowName,
    DWORD               dwStyle,
    const RECT &        rect,
    CWnd *              pParentWnd,
    UINT                nID,
    CCreateContext *    pContext
    )
{
    dwStyle |= TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_EDITLABELS | TVS_SHOWSELALWAYS;
    return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);

}  //*** CClusterTreeView::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnDraw
//
//  Routine Description:
//      Called to draw the view.
//
//  Arguments:
//      pDC     [IN OUT] Device Context for the view.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnDraw(IN OUT CDC* pDC)
{
#if 0
    CClusterDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: add draw code for native data here
#endif
}  //*** CClusterTreeView::OnDraw()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnInitialUpdate
//
//  Routine Description:
//      Do one-time initialization.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnInitialUpdate(void)
{
    CClusterAdminApp *  papp        = GetClusterAdminApp();
    CClusterDoc *       pdocCluster = GetDocument();
    CString             strSelection;

    CTreeView::OnInitialUpdate();

    // Save the frame pointer.
//  ASSERT(m_pframe == NULL);
    m_pframe = (CSplitterFrame *) GetParentFrame();
    ASSERT_VALID(m_pframe);
    ASSERT_KINDOF(CSplitterFrame, m_pframe);

    // Tell the tree control about our images.  We are using the
    // same image list for both normal and state images.
    GetTreeCtrl().SetImageList(papp->PilSmallImages(), TVSIL_NORMAL);
//  GetTreeCtrl().SetImageList(papp->PilSmallImages(), TVSIL_STATE);

    // Read the last selection.
    ReadPreviousSelection(strSelection);

    // Recursively add items starting with the cluster.
    BAddItems(pdocCluster->PtiCluster(), strSelection, TRUE /*bExpanded*/);

    // Expand the Cluster item by default.
//  pdocCluster->PtiCluster()->BExpand(this, TVE_EXPAND);

}  //*** CClusterTreeView::OnInitialUpdate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::BAddItems
//
//  Routine Description:
//      Add an item and then add all its children.
//
//  Arguments:
//      pti             [IN OUT] Item to add to the tree.
//      rstrSelection   [IN] Previous selection.
//      bExpanded       [IN] TRUE = add expanded.
//
//  Return Value:
//      TRUE        Parent needs to be expanded.
//      FALSE       Parent does not need to be expanded.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::BAddItems(
    IN OUT CTreeItem *  pti,
    IN const CString &  rstrSelection,
    IN BOOL             bExpanded       // = FALSE
    )
{
    POSITION        posChild;
    CTreeItem *     ptiChild;
    BOOL            bRetExpanded = FALSE;

    ASSERT_VALID(pti);

    // Insert this item into the tree.
    pti->HtiInsertInTree(this);
    if (bExpanded || pti->BShouldBeExpanded(this))
        bRetExpanded = TRUE;

    // Add all the child items.
    posChild = pti->LptiChildren().GetHeadPosition();
    while (posChild != NULL)
    {
        ptiChild = pti->LptiChildren().GetNext(posChild);
        ASSERT_VALID(ptiChild);
        bExpanded = BAddItems(ptiChild, rstrSelection);
        if (bExpanded)
            bRetExpanded = TRUE;
    }  // while:  more child items

    if (bRetExpanded)
        pti->BExpand(this, TVE_EXPAND);

    if (rstrSelection == pti->StrProfileSection())
    {
        pti->Select(this, TRUE /*bSelectInTrue*/);
        bRetExpanded = TRUE;
    }  // if:  this is the selected item

    return bRetExpanded;

}  //*** CClusterTreeView::BAddItems()

#ifdef NEVER
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::CleanupItems
//
//  Routine Description:
//      Cleanup an item and all its children.
//
//  Arguments:
//      ptiParent   [IN OUT] Parent item to cleanup.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::CleanupItems(IN OUT CTreeItem * ptiParent)
{
    POSITION    posChild;
    CTreeItem * ptiChild;

    // Cleanup all child items.
    if (ptiParent != NULL)
    {
        posChild = ptiParent->LptiChildren().GetHeadPosition();
        while (posChild != NULL)
        {
            ptiChild = ptiParent->LptiChildren().GetNext(posChild);
            ASSERT_VALID(ptiChild);
            CleanupItems(ptiChild);
        }  // while:  more items in the list

        // Cleanup this item.
        ptiParent->PreRemoveFromTree(this);
    }  // if:  parent was specified

}  //*** CClusterTreeView::CleanupItems()
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterTreeView diagnostics

#ifdef _DEBUG
void CClusterTreeView::AssertValid(void) const
{
    CTreeView::AssertValid();

}  //*** CClusterTreeView::AssertValid()

void CClusterTreeView::Dump(CDumpContext & dc) const
{
    CTreeView::Dump(dc);

}  //*** CClusterTreeView::Dump()

CClusterDoc * CClusterTreeView::GetDocument(void) // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClusterDoc)));
    return (CClusterDoc *) m_pDocument;

}  //*** CClusterTreeView::GetDocument()
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::PtiSelected
//
//  Routine Description:
//      Get the tree item that is selected.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ptiSelected     The selected item or NULL if no item is selected.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CClusterTreeView::PtiSelected(void) const
{
    HTREEITEM   htiSelected;
    CTreeItem * ptiSelected;

    htiSelected = HtiSelected();
    if (htiSelected != NULL)
    {
        ptiSelected = (CTreeItem *) GetTreeCtrl().GetItemData(htiSelected);
        ASSERT_VALID(ptiSelected);
    }  // if:  selected item found
    else
        ptiSelected = NULL;

    return ptiSelected;

}  //*** CClusterTreeView::PtiSelected()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::SaveCurrentSelection
//
//  Routine Description:
//      Save the current selection.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::SaveCurrentSelection(void)
{
    CTreeItem * ptiSelected = PtiSelected();

    if (ptiSelected != NULL)
    {
        CString             strSection;
        CString             strValueName;

        ASSERT_VALID(Pframe());

        try
        {
            strSection.Format(
                REGPARAM_CONNECTIONS _T("\\%s"),
                GetDocument()->StrNode()
                );

            Pframe()->ConstructProfileValueName(strValueName, REGPARAM_SELECTION);

            AfxGetApp()->WriteProfileString(
                strSection,
                strValueName,
                ptiSelected->StrProfileSection()
                );
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // if:  there is a current selection

}  //*** CClusterTreeView::SaveCurrentSelection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::ReadPreviousSelection
//
//  Routine Description:
//      Read the previous selection.
//
//  Arguments:
//      rstrSelection   [OUT] Previous selection read from the user's profile.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::ReadPreviousSelection(OUT CString & rstrSelection)
{
    CString             strSection;
    CString             strValueName;

    ASSERT_VALID(Pframe());

    try
    {
        // Get the selected item.
        strSection.Format(
            REGPARAM_CONNECTIONS _T("\\%s"),
            GetDocument()->StrNode()
            );

        Pframe()->ConstructProfileValueName(strValueName, REGPARAM_SELECTION);

        rstrSelection = AfxGetApp()->GetProfileString(
                            strSection,
                            strValueName,
                            _T("")
                            );
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

}  //*** CClusterTreeView::ReadPreviousSelection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnSelChanged
//
//  Routine Description:
//      Handler method for the TVN_SELCHANGED message.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnSelChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_TREEVIEW *       pNMTreeView = (NM_TREEVIEW *) pNMHDR;
    CTreeItem *         ptiSelected;

    if (!BDragging())
    {
        Trace(g_tagTreeViewSelect, _T("OnSelChanged() - BEGIN"));

        // Get the selected item.
        ptiSelected = (CTreeItem *) pNMTreeView->itemNew.lParam;
        ASSERT_VALID(ptiSelected);

        // Ask the list view to display the items for this tree item.
        ASSERT_VALID(ptiSelected->Pci());
        Trace(g_tagTreeViewSelect, _T("OnSelChanged() - '%s' selected"), ptiSelected->Pci()->StrName());
        ptiSelected->Select(this, FALSE /*bSelectInTree*/);

        // Tell the document of the new selection.
        if (m_pDocument != NULL)  // this happens on system shutdown
            GetDocument()->OnSelChanged(ptiSelected->Pci());

        *pResult = 0;
        Trace(g_tagTreeViewSelect, _T("OnSelChanged() - END"));
    }  // if:  not dragging

}  //*** CClusterTreeView::OnSelChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL        bHandled    = FALSE;

    // If there is a current item selected, give it a chance
    // to handle the message.
    if (HtiSelected() != NULL)
        bHandled = PtiSelected()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

    if (!bHandled)
        bHandled = CTreeView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

    return bHandled;

}  //*** CClusterTreeView::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::PmenuPopup
//
//  Routine Description:
//      Returns a popup menu.
//
//  Arguments:
//      rpointScreen    [IN OUT] Position of the cursor, in screen coordinates.
//      rpci            [OUT] Pointer in which to return associated cluster item.
//
//  Return Value:
//      pmenu       A popup menu for the item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMenu * CClusterTreeView::PmenuPopup(
    IN OUT CPoint &     rpointScreen,
    OUT CClusterItem *& rpci
    )
{
    CTreeItem * pti     = NULL;
    CMenu *     pmenu   = NULL;

    rpci = NULL;

    // If there are no coordinates (-1,-1), display a menu for the selected item.
    if ((rpointScreen.x == -1) && (rpointScreen.y == -1))
    {
        CRect       rect;
        CTreeItem * ptiSelected = PtiSelected();

        if ((ptiSelected != NULL)
                && GetTreeCtrl().GetItemRect(HtiSelected(), &rect, FALSE))
        {
            pti = ptiSelected;
        }  // if:  selected item and it is visible
        else
            GetWindowRect(&rect);
        rpointScreen.x = (rect.right - rect.left) / 2;
        rpointScreen.y = (rect.bottom - rect.top) / 2;
        ClientToScreen(&rpointScreen);
    }  // if:  no coordinates
    else
    {
        CPoint      pointClient;
        HTREEITEM   hti;
        UINT        uiFlags;

        // Get the coordinates of the point where the user clicked the right mouse
        // button.  We need in both screen and client coordinates.
        pointClient = rpointScreen;
        ScreenToClient(&pointClient);

        // Get the item under the cursor and get its popup menu.
        hti = GetTreeCtrl().HitTest(pointClient, &uiFlags);
        if (hti != NULL)
        {
            // Get the tree item for the item under the cursor.
            pti = (CTreeItem *) GetTreeCtrl().GetItemData(hti);
            ASSERT_VALID(pti);

            // Select the item because that's the only way for it us process the menu.
            pti->BSelectItem(this);
        }  // if:  on an item
    }  // else:  coordinates specified

    if (pti != NULL)
    {
        // Get a menu from the item.
        pmenu = pti->PmenuPopup();
        rpci = pti->Pci();
    }  // if:  item found

    return pmenu;

}  //*** CClusterTreeView::PmenuPopup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnActivateView
//
//  Routine Description:
//      Called when the view is activated.
//
//  Arguments:
//      bActivate       [IN] Indicates whether the view being activated or deactivated.
//      pActivateView   [IN OUT] Points to the view object that is being activated.
//      peactiveView    [IN OUT] Points to the view object that is being deactivated.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnActivateView(
    BOOL        bActivate,
    CView *     pActivateView,
    CView *     pDeactiveView
    )
{
    CTreeItem * ptiSelected = PtiSelected();

    if (m_pDocument != NULL)  // this happens on system shutdown
    {
        if (bActivate && (ptiSelected != NULL))
        {
            ASSERT_VALID(ptiSelected->Pci());
            Trace(g_tagTreeViewSelect, _T("OnActiveView: '%s' selected"), ptiSelected->Pci()->StrName());

            // Tell the document of the new selection.
            GetDocument()->OnSelChanged(ptiSelected->Pci());
        }  // if:  we are being activated
    }  // if:  document is available

    CTreeView::OnActivateView(bActivate, pActivateView, pDeactiveView);

}  //*** CClusterTreeView::OnActivateView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnDestroy(void)
{
    // Clean up the control.
    if (m_pDocument != NULL)  // this happens on system shutdown
    {
        // Save the currently selected item.
        SaveCurrentSelection();

        // Cleanup after ourselves.
//      CleanupItems(GetDocument()->PtiCluster());
    }  // if:  the document is still available

    CTreeView::OnDestroy();

}  //*** CClusterTreeView::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnItemExpanded
//
//  Routine Description:
//      Handler method for the TVN_ITEMEXPANDED message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnItemExpanded(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_TREEVIEW * pNMTreeView = (NM_TREEVIEW *) pNMHDR;

    if (pNMTreeView->itemNew.mask & TVIF_STATE)
    {
        BOOL        bExpanded;
        CTreeItem * pti;

        bExpanded = (pNMTreeView->itemNew.state & TVIS_EXPANDED) != 0;
        ASSERT(pNMTreeView->itemNew.mask & TVIF_PARAM);
        pti = (CTreeItem *) pNMTreeView->itemNew.lParam;
        ASSERT_VALID(pti);
        ASSERT_KINDOF(CTreeItem, pti);
        pti->SetExpandedState(this, bExpanded);
    }  // if:  expanded state changed.

    *pResult = 0;

}  //*** CClusterTreeView::OnItemExpanded()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnBeginLabelEdit
//
//  Routine Description:
//      Handler method for the TVN_BEGINLABELEDIT message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//                      TRUE = don't edit, FALSE = edit.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnBeginLabelEdit(NMHDR * pNMHDR, LRESULT * pResult) 
{
    ASSERT(pNMHDR != NULL);

    TV_DISPINFO * pTVDispInfo = (TV_DISPINFO *) pNMHDR;
    CTreeItem * pti = (CTreeItem *) pTVDispInfo->item.lParam;

    ASSERT(m_ptiBeingEdited == NULL);
    ASSERT_VALID(pti);
    ASSERT_VALID(pti->Pci());

    if (!BDragging() && pti->Pci()->BCanBeEdited())
    {
        pti->Pci()->OnBeginLabelEdit(GetTreeCtrl().GetEditControl());
        m_ptiBeingEdited = pti;
        *pResult = FALSE;
    }  // if:  not dragging and object can be edited
    else
        *pResult = TRUE;

    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

}  //*** CClusterTreeView::OnBeginLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnEndLabelEdit
//
//  Routine Description:
//      Handler method for the TVN_ENDLABELEDIT message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnEndLabelEdit(NMHDR * pNMHDR, LRESULT * pResult) 
{
    ASSERT(pNMHDR != NULL);

    TV_DISPINFO * pTVDispInfo = (TV_DISPINFO *) pNMHDR;
    CTreeItem * pti = (CTreeItem *) pTVDispInfo->item.lParam;

    ASSERT_VALID(pti);
    ASSERT(pti == m_ptiBeingEdited);
    ASSERT_VALID(pti->Pci());

    // If the edit wasn't cancelled, rename it.
    if (pTVDispInfo->item.mask & LVIF_TEXT)
    {
        ASSERT(pti->Pci()->BCanBeEdited());
        ASSERT(pTVDispInfo->item.pszText != NULL);

        Trace(g_tagTreeView, _T("Ending edit of item '%s' (Saving as '%s')"), pti->Pci()->StrName(), pTVDispInfo->item.pszText);

        if ( pti->Pci()->BIsLabelEditValueValid( pTVDispInfo->item.pszText ) )
        {
            try
            {
                pti->Pci()->Rename(pTVDispInfo->item.pszText);
                *pResult = TRUE;
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                *pResult = FALSE;
            }  // catch:  CException
        } // if:  name is valid
        else
        {
            *pResult = FALSE;
        }
    }  // if:  the edit wasn't cancelled
    else
    {
        Trace(g_tagTreeView, _T("Ending edit of item '%s' (Not Saving)"), pti->Pci()->StrName());
        *pResult = TRUE;
    }  // else:  edit was cancelled

    m_ptiBeingEdited = NULL;
    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

}  //*** CClusterTreeView::OnEndLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnBeginDrag
//
//  Routine Description:
//      Handler method for the TVN_BEGINDRAG and TVN_BEGINRDRAG messages.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnBeginDrag(NMHDR * pNMHDR, LRESULT * pResult)
{
    CTreeCtrl &     rtc         = GetTreeCtrl();
    CPoint          ptScreen;
    CPoint          ptFrame;
    CPoint          ptView;
    UINT            nFlags;
    CClusterItem *  pci = NULL;
    CImageList *    pimagelist;

    ASSERT_VALID(Pframe());

    // Get the current cursor position for identifying the item being dragged.
    GetCursorPos(&ptScreen);
    ptFrame = ptScreen;
    Pframe()->ScreenToClient(&ptFrame);
    ptView = ptScreen;
    rtc.ScreenToClient(&ptView);

    // Get the item being dragged.
    {
        HTREEITEM   hti;
        CTreeItem * pti;

        hti = rtc.HitTest(ptView, &nFlags);
        if (hti == NULL)
            return;

        pti = (CTreeItem *) rtc.GetItemData(hti);
        ASSERT_VALID(pti);
        ASSERT_KINDOF(CTreeItem, pti);
        ASSERT_VALID(pti->Pci());

        // If the item can not be dragged, abort the operation.
        if (!pti->Pci()->BCanBeDragged())
            return;

        // Save info for later.
        m_htiDrag = hti;
        m_ptiDrag = pti;
        m_htiDrop = NULL;
        pci = pti->Pci();
    }  // Get the item being dragged

    Trace(g_tagTreeDrag, _T("OnBeginDrag() - Dragging '%s' at (%d,%d)"), m_ptiDrag->StrName(), ptFrame.x, ptFrame.y);

    // Create an image list for the image being dragged.
    pimagelist = rtc.CreateDragImage(m_htiDrag);

    // Let the frame window initialize the drag operation.
    Pframe()->BeginDrag(pimagelist, pci, ptFrame, CPoint(0, -16));

    *pResult = 0;

}  //*** CClusterTreeView::OnBeginDrag(pNMHDR, pResult)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnMouseMoveForDrag
//
//  Routine Description:
//      Handler method for the WM_MOUSEMOVE message during a drag operation.
//      This function is only responsible for providing view-specific
//      functionality, such as selecting the drop target if it is valid.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor in frame
//                      coordinates.
//      pwndDrop    Specifies the window under the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnMouseMoveForDrag(
    IN UINT         nFlags,
    IN CPoint       point,
    IN const CWnd * pwndDrop
    )
{
    ASSERT(BDragging());
    ASSERT_VALID(Pframe());

    // If we are dragging, select the drop target.
    if (BDragging())
    {
        HTREEITEM       hti;
        UINT            flags;
        CPoint          ptView;
        CTreeCtrl &     rtc     = GetTreeCtrl();

        // Convert the point to view coordinates.
        ptView = point;
        Pframe()->ClientToScreen(&ptView);
        rtc.ScreenToClient(&ptView);

        // If this window is the drop target, find the item under the cursor.
        if (pwndDrop == &rtc)
        {
            // If we are over a tree item, highlight it.
            hti = rtc.HitTest(ptView, &flags);
            if (hti != NULL)
            {
                CTreeItem * pti;

                // Get the item to be highlight.
                pti = (CTreeItem *) rtc.GetItemData(hti);
                ASSERT_VALID(pti);
                ASSERT_KINDOF(CTreeItem, pti);
                ASSERT_VALID(pti->Pci());

                // If this is not a drop target, change the cursor.
                if (pti->Pci()->BCanBeDropTarget(Pframe()->PciDrag()))
                    Pframe()->ChangeDragCursor(IDC_ARROW);
                else
                    Pframe()->ChangeDragCursor(IDC_NO);
            }  // if:  over a tree item
        }  // if:  this window is the drop target
        else
            hti = NULL;

        // Unlock window updates.
        VERIFY(Pimagelist()->DragShowNolock(FALSE /*bShow*/));

        // Highlight the new drop target.
        rtc.SelectDropTarget(hti);
        m_htiDrop = hti;

        VERIFY(Pimagelist()->DragShowNolock(TRUE /*bShow*/));
    }  // if:  tree item is being dragged

}  //*** CClusterTreeView::OnMouseMoveForDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnButtonUpForDrag
//
//  Routine Description:
//      Called to handle a button up event during drag and drop.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnButtonUpForDrag(IN UINT nFlags, IN CPoint point)
{
    ASSERT(BDragging());
    ASSERT_VALID(Pframe());
    ASSERT_VALID(Pframe()->PciDrag());

    // If we are dragging, process the drop.
    if (BDragging())
    {
        HTREEITEM       hti;
        UINT            flags;
        CPoint          ptView;
        CTreeCtrl &     rtc     = GetTreeCtrl();

        Trace(g_tagTreeDrag, _T("OnButtonUpForDrag()"));

        // Convert the point to view coordinates.
        ptView = point;
        Pframe()->ClientToScreen(&ptView);
        rtc.ScreenToClient(&ptView);

        // If we are over a tree item, drop the item being dragged.
        hti = rtc.HitTest(ptView, &flags);
        if (hti != NULL)
        {
            CTreeItem * ptiDropTarget;

            // Get the item to drop on.
            ptiDropTarget = (CTreeItem *) rtc.GetItemData(hti);
            ASSERT_VALID(ptiDropTarget);
            ASSERT_KINDOF(CTreeItem, ptiDropTarget);
            ASSERT_VALID(ptiDropTarget->Pci());

            if (ptiDropTarget->Pci() != Pframe()->PciDrag())
                ptiDropTarget->Pci()->DropItem(Pframe()->PciDrag());

        }  // if:  over a tree item
    }  // if:  tree item is being dragged

}  //*** CClusterTreeView::OnButtonUpForDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::BeginDrag
//
//  Routine Description:
//      Called by the frame to begin a drag operation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::BeginDrag(void)
{
    Trace(g_tagTreeDrag, _T("BeginDrag()"));

}  //*** CClusterTreeView::BeginDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::EndDrag
//
//  Routine Description:
//      Called by the frame to end a drag operation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::EndDrag(void)
{
    // Cleanup.
    GetTreeCtrl().SelectDropTarget(NULL);
    m_htiDrag = NULL;
    m_ptiDrag = NULL;
    m_htiDrop = NULL;

    Trace(g_tagTreeDrag, _T("EndDrag()"));

}  //*** CClusterTreeView::EndDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::PreTranslateMessage
//
//  Routine Description:
//      Translate window messages before they are dispatched.
//
//  Arguments:
//      pMsg    Points to a MSG structure that contains the message to process.
//
//  Return Value:
//      TRUE    Message was handled.
//      FALSE   Message was not handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterTreeView::PreTranslateMessage(MSG * pMsg)
{
    BOOL    bForward    = FALSE;

    if (m_ptiBeingEdited != NULL)
    {
        CEdit * pedit = GetTreeCtrl().GetEditControl();
        ASSERT(pedit != NULL);

        if (pMsg->message == WM_KEYDOWN)
        {
            if (pMsg->wParam == VK_SHIFT)
                m_bShiftPressed = TRUE;
            else if (pMsg->wParam == VK_CONTROL)
            {
                ::CopyMemory(&m_msgControl, pMsg, sizeof(m_msgControl));
                m_bControlPressed = TRUE;
            }  // else if:  control key pressed
            else if ((pMsg->wParam == VK_RETURN)
                        || (pMsg->wParam == VK_ESCAPE)
                        || (pMsg->wParam == VK_INSERT)
                        || (pMsg->wParam == VK_DELETE)
                        || (pMsg->wParam == VK_F1)
                        || (pMsg->wParam == VK_F5)
                        || (pMsg->wParam == VK_F6)
                        )
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Forwarding WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                bForward = TRUE;
                if (m_bControlPressed)
                {
                    if (pMsg->wParam == VK_RETURN)
                        pedit->SendMessage(WM_KEYUP, m_msgControl.wParam, m_msgControl.lParam);
                }  // if:  control key pressed
            }  // else if:  editing key pressed
            else if ((pMsg->wParam == VK_TAB)
                        || (m_bControlPressed
                                && (_T('A') <= pMsg->wParam) && (pMsg->wParam <= _T('Y'))
                                && (pMsg->wParam != _T('C'))
                                && (pMsg->wParam != _T('H'))
                                && (pMsg->wParam != _T('M'))
                                && (pMsg->wParam != _T('V'))
                                && (pMsg->wParam != _T('X'))
                            )
                        )
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Ignoring WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                MessageBeep(MB_ICONEXCLAMATION);
                return TRUE;
            }  // else if:  key pressed that should be ignored
#ifdef NEVER
            else
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Not forwarding WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
            }  // else:  not processing key
#endif
        }  // if:  key pressed while editing label
        else if (pMsg->message == WM_SYSKEYDOWN)
        {
            if (pMsg->wParam == VK_MENU)
                m_bAltPressed = TRUE;
            else if ((pMsg->wParam == VK_RETURN)
                    )
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Forwarding WM_SYSKEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                bForward = TRUE;
            }  // else if:  editing key pressed
#ifdef NEVER
            else
            {
                Trace(g_tagTreeView, _T("PreTranslateMessage() - Not forwarding WM_SYSKEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
            }  // else:  not processing key
#endif
        }  // else if:  system key pressed while editing label
        if (bForward)
        {
            pedit->SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
            return TRUE;
        }  // if:  forwarding the message
        else if (pMsg->message == WM_KEYUP)
        {
            if (pMsg->wParam == VK_SHIFT)
                m_bShiftPressed = FALSE;
            else if (pMsg->wParam == VK_CONTROL)
                m_bControlPressed = FALSE;
        }  // else if:  key up
        else if (pMsg->message == WM_SYSKEYUP)
        {
            if (pMsg->wParam == VK_MENU)
                m_bAltPressed = FALSE;
        }  // else if:  system key up
    }  // if:  editing a label

    return CTreeView::PreTranslateMessage(pMsg);

}  //*** CClusterTreeView::PreTranslateMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnCmdRename
//
//  Routine Description:
//      Processes the ID_FILE_RENAME menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnCmdRename(void)
{
    CTreeItem * ptiSelected = PtiSelected();

    // If an item has benn selected, begin label editing
    if (ptiSelected != NULL)
    {
        ASSERT_VALID(ptiSelected);
        ptiSelected->EditLabel(this);
    }  // if:  an item has the focus

}  //*** CClusterTreeView::OnCmdRename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterTreeView::OnKeyDown
//
//  Routine Description:
//      Handler method for the TVN_KEYDOWN message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterTreeView::OnKeyDown(NMHDR * pNMHDR, LRESULT * pResult)
{
    TV_KEYDOWN * pTVKeyDown = (TV_KEYDOWN *) pNMHDR;

    if (BDragging() && (pTVKeyDown->wVKey == VK_ESCAPE))
        Pframe()->AbortDrag();

    *pResult = 0;

}  //*** CClusterTreeView::OnKeyDown()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\waitdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      WaitDlg.cpp
//
//  Abstract:
//      Implementation of the CWaitDlg class.
//
//  Author:
//      David Potter (davidp)   07-NOV-2000
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "CluAdmin.h"
#include "WaitDlg.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define WAIT_DLG_TIMER_ID   10
#define WAIT_DLG_WAIT_TIME  500
#define WAIT_DLG_SKIP_COUNT 6
#define PROGRESS_ICON_COUNT 12

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CWaitDlg, CDialog )
    //{{AFX_MSG_MAP(CWaitDlg)
    ON_BN_CLICKED(IDCANCEL, OnCancel)
    ON_WM_CLOSE()
    ON_WM_TIMER()
    ON_COMMAND(IDCANCEL, OnClose)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::CWaitDlg
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pcszMessageIn   -- Message to display.
//      idsTitleIn      -- Title of the dialog.
//      pwndParentIn    -- Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWaitDlg::CWaitDlg(
    LPCTSTR pcszMessageIn,
    UINT    idsTitleIn,     // = 0
    CWnd *  pwndParentIn    // = NULL
    )
    : CDialog( IDD, pwndParentIn )
    , m_idsTitle( idsTitleIn )
    , m_nTickCounter( WAIT_DLG_SKIP_COUNT )
    , m_nTotalTickCount( 0 )
    , m_timerId( 0 )
{
    //{{AFX_DATA_INIT(CWaitDlg)
    //}}AFX_DATA_INIT

    m_strMessage = pcszMessageIn;
    if ( m_idsTitle == 0 )
    {
        m_idsTitle = IDS_WAIT_TITLE;
    }

} //*** CWaitDlg::CWaitDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::DoDataExchange( CDataExchange * pDX )
{
    CDialog::DoDataExchange( pDX );
    //{{AFX_DATA_MAP(CWaitDlg)
    DDX_Control(pDX, IDC_W_MESSAGE, m_staticMessage);
    DDX_Control(pDX, IDC_W_PROGRESS, m_iconProgress);
    DDX_Text(pDX, IDC_W_MESSAGE, m_strMessage);
    //}}AFX_DATA_MAP

} //*** CWaitDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CWaitDlg::OnInitDialog(void)
{
    CString strSubTitle;

    CDialog::OnInitDialog();

    // Start the timer.
    m_timerId = SetTimer( WAIT_DLG_TIMER_ID, WAIT_DLG_WAIT_TIME, NULL );

    // Set the title of the dialog.
    strSubTitle.LoadString( m_idsTitle );
    m_strTitle.Format( _T("%s - %s"), AfxGetApp()->m_pszAppName, strSubTitle );
    SetWindowText( m_strTitle );

    // Update the progress indicator.
    UpdateIndicator();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

} //*** CWaitDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::OnClose
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Cancel push button and
//      for the WM_CLOSE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::OnClose( void )
{
    CloseTimer();
    CDialog::OnClose();

}  //*** CWaitDlg::OnClose()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::CloseTimer
//
//  Routine Description:
//      Close the timer down.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::CloseTimer( void )
{
    if ( m_timerId != 0 )
    {
        KillTimer( m_timerId );
    } // if: timer is active

    m_timerId = 0;

}  //*** CWaitDlg::CloseTimer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::OnTimer
//
//  Routine Description:
//      Handler for the WM_TIMER message..
//
//  Arguments:
//      nIDTimer
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::OnTimer( UINT nIDTimer )
{
    //
    // Don't do anything if it isn't our timer.
    //
    if ( nIDTimer != WAIT_DLG_TIMER_ID )
        goto Cleanup;

    //
    //  Advance the progress indicator.
    //
    UpdateIndicator();

    //
    //  No need to continue if we're just amusing the user.
    //
    if ( --m_nTickCounter > 0 )
        goto Cleanup;

    m_nTickCounter = WAIT_DLG_SKIP_COUNT;

    //
    // Check here to see if we can exit out.
    // This method is typically overridden.
    //
    OnTimerTick();

Cleanup:
    return;

}  //*** CWaitDlg::OnTimer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitDlg::UpdateIndicator
//
//  Routine Description:
//      Update the indicator control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitDlg::UpdateIndicator( void )
{
    if ( m_nTotalTickCount % (1000 / WAIT_DLG_WAIT_TIME) == 0 )
    {
        int     nTempTickCount = m_nTotalTickCount / (1000 / WAIT_DLG_WAIT_TIME);
        HICON   hIcon;

        hIcon = AfxGetApp()->LoadIcon( IDI_PROGRESS_0 + (nTempTickCount % PROGRESS_ICON_COUNT) );
        m_iconProgress.SetIcon( hIcon );
    } // if: advancing to the next image
    
    m_nTotalTickCount++;

} //*** CWaitDlg::UpdateIndicator()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CWaitForResourceOfflineDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CWaitForResourceOfflineDlg, CWaitDlg )
    //{{AFX_MSG_MAP(CWaitForResourceOfflineDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOfflineDlg::CWaitForResourceOfflineDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pResIn          -- Resource to wait on.
//      pwndParentIn    -- Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWaitForResourceOfflineDlg::CWaitForResourceOfflineDlg(
    CResource const *   pResIn,
    CWnd *              pwndParentIn    // = NULL
    )
    : CWaitDlg( NULL, IDS_WAIT_FOR_OFFLINE_TITLE, pwndParentIn )
    , m_pRes( pResIn )
{
    ASSERT( pResIn != NULL );

    //{{AFX_DATA_INIT(CWaitForResourceOfflineDlg)
    //}}AFX_DATA_INIT

} //*** CWaitForResourceOfflineDlg::CWaitForResourceOfflineDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOfflineDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CWaitForResourceOfflineDlg::OnInitDialog( void )
{
    m_strMessage.Format( IDS_WAIT_FOR_OFFLINE_MESSAGE, m_pRes->StrName() );

    return CWaitDlg::OnInitDialog();

} //*** CWaitForResourceOfflineDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOfflineDlg::OnTimerTick
//
//  Routine Description:
//      Determine whether the timer should be terminated.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitForResourceOfflineDlg::OnTimerTick( void )
{
    DWORD                   dwStatus;
    CLUSTER_RESOURCE_STATE  crs;

    // Get the state of the resource in a loop until either the resource
    // is no longer in a pending state or the maximum number of retries
    // is exceeded.

    // Get the state of the resource.
    crs = GetClusterResourceState( m_pRes->Hresource(), NULL, NULL, NULL, NULL );
    if ( crs == ClusterResourceStateUnknown )
    {
        dwStatus = GetLastError();
        CloseTimer();
        CDialog::OnCancel();
        ThrowStaticException( dwStatus, IDS_GET_RESOURCE_STATE_ERROR, m_pRes->StrName() );
    } // if: error getting resource state

    // See if we reached a stable state.
    if ( crs < ClusterResourcePending )
    {
        CloseTimer();
        CDialog::OnOK();
    }

}  //*** CWaitForResourceOfflineDlg::OnTimerTick()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CWaitForResourceOnlineDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CWaitForResourceOnlineDlg, CWaitDlg )
    //{{AFX_MSG_MAP(CWaitForResourceOnlineDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOnlineDlg::CWaitForResourceOnlineDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pResIn          -- Resource to wait on.
//      pwndParentIn    -- Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWaitForResourceOnlineDlg::CWaitForResourceOnlineDlg(
    CResource const *   pResIn,
    CWnd *              pwndParentIn    // = NULL
    )
    : CWaitDlg( NULL, IDS_WAIT_FOR_ONLINE_TITLE, pwndParentIn )
    , m_pRes( pResIn )
{
    ASSERT( pResIn != NULL );

    //{{AFX_DATA_INIT(CWaitForResourceOnlineDlg)
    //}}AFX_DATA_INIT

} //*** CWaitForResourceOnlineDlg::CWaitForResourceOnlineDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOnlineDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CWaitForResourceOnlineDlg::OnInitDialog( void )
{
    m_strMessage.Format( IDS_WAIT_FOR_ONLINE_MESSAGE, m_pRes->StrName() );

    return CWaitDlg::OnInitDialog();

} //*** CWaitForResourceOnlineDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWaitForResourceOnlineDlg::OnTimerTick
//
//  Routine Description:
//      Determine whether the timer should be terminated.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CWaitForResourceOnlineDlg::OnTimerTick( void )
{
    DWORD                   dwStatus;
    CLUSTER_RESOURCE_STATE  crs;

    // Get the state of the resource in a loop until either the resource
    // is no longer in a pending state or the maximum number of retries
    // is exceeded.

    // Get the state of the resource.
    crs = GetClusterResourceState( m_pRes->Hresource(), NULL, NULL, NULL, NULL );
    if ( crs == ClusterResourceStateUnknown )
    {
        dwStatus = GetLastError();
        CloseTimer();
        CDialog::OnCancel();
        ThrowStaticException( dwStatus, IDS_GET_RESOURCE_STATE_ERROR, m_pRes->StrName() );
    } // if: error getting resource state

    // See if we reached a stable state.
    if ( crs < ClusterResourcePending )
    {
        CloseTimer();
        CDialog::OnOK();
    }

}  //*** CWaitForResourceOnlineDlg::OnTimerTick()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\yestoall.cpp ===
// YesToAll.cpp : implementation file
//

#include "stdafx.h"
#include "cluadmin.h"
#include "YesToAll.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CYesToAllDialog dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CYesToAllDialog, CDialog)
	//{{AFX_MSG_MAP(CYesToAllDialog)
	ON_BN_CLICKED(IDYES, OnYes)
	ON_BN_CLICKED(IDNO, OnNo)
	ON_BN_CLICKED(IDC_YTA_YESTOALL, OnYesToAll)
	//}}AFX_MSG_MAP
	ON_COMMAND(IDCANCEL, OnNo)
	ON_COMMAND(IDOK, OnYes)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::CYesToAllDialog
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		pszMessage	[IN] Message to display.
//		pParent		[IN] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CYesToAllDialog::CYesToAllDialog(LPCTSTR pszMessage, CWnd * pParent /*=NULL*/)
	: CDialog(IDD, pParent)
{
	//{{AFX_DATA_INIT(CYesToAllDialog)
	m_strMessage = _T("");
	//}}AFX_DATA_INIT

	ASSERT(pszMessage != NULL);
	m_pszMessage = pszMessage;

}  //*** CYesToAllDialog::CYesToAllDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CYesToAllDialog::DoDataExchange(CDataExchange * pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CYesToAllDialog)
	DDX_Text(pDX, IDC_YTA_MESSAGE, m_strMessage);
	//}}AFX_DATA_MAP

}  //*** CYesToAllDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus not set yet.
//		FALSE		Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CYesToAllDialog::OnInitDialog(void)
{
	LPCTSTR	pszAppName;

	m_strMessage = m_pszMessage;

	CDialog::OnInitDialog();

	pszAppName = AfxGetApp()->m_pszAppName;
	SetWindowText(pszAppName);

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CYesToAllDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::OnYes
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Yes push button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CYesToAllDialog::OnYes(void)
{
	EndDialog(IDYES);

}  //*** CYesToAllDialog::OnYes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::OnNo
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the No push button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CYesToAllDialog::OnNo(void)
{
	EndDialog(IDNO);

}  //*** CYesToAllDialog::OnNo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CYesToAllDialog::OnYesToAll
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Yes To All push button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CYesToAllDialog::OnYesToAll(void)
{
	EndDialog(IDC_YTA_YESTOALL);

}  //*** CYesToAllDialog::OnYesToAll()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\waitdlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      WaitDlg.h
//
//  Implementation File:
//      WaitDlg.cpp
//
//  Description:
//      Definition of the CWaitDlg class.
//
//  Maintained By:
//      David Potter (davidp)   07-NOV-2000
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWaitDlg;
class CWaitForResourceOfflineDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RES_H_
#include "Res.h"    // for CResource
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWaitDlg
//
//  Description:
//      Display a dialog while waiting for something to complete.
//
//--
/////////////////////////////////////////////////////////////////////////////
class CWaitDlg : public CDialog
{
public:
    CWaitDlg(
        LPCTSTR pcszMessageIn,
        UINT    idsTitleIn      = 0,
        CWnd *  pwndParentIn    = NULL
        );

// Dialog Data
    //{{AFX_DATA(CWaitDlg)
    enum { IDD = IDD_WAIT };
    CStatic m_staticMessage;
    CStatic m_iconProgress;
    CString m_strMessage;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWaitDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWaitDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnTimer(UINT nIDTimer);
    afx_msg void OnClose();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Override this function to provide your own implementation
    // To exit out of the dialog, call CDialog::OnOK() here.
    virtual void OnTimerTick( void )
    {
        CDialog::OnOK();

    } //*** CWaitDlg::OnTimerTick()

    void    UpdateIndicator( void );
    void    CloseTimer( void );

    CString     m_strTitle;
    UINT        m_idsTitle;
    UINT_PTR    m_timerId;
    int         m_nTickCounter;
    int         m_nTotalTickCount;

}; //*** class CWaitDlg

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWaitForResourceOfflineDlg
//
//  Description:
//      Display a dialog while waiting for a resource to go offline.
//
//--
/////////////////////////////////////////////////////////////////////////////
class CWaitForResourceOfflineDlg : public CWaitDlg
{
public:
    CWaitForResourceOfflineDlg(
        CResource const *   pResIn,
        CWnd *              pwndParentIn = NULL
        );

// Dialog Data
    //{{AFX_DATA(CWaitForResourceOfflineDlg)
    enum { IDD = IDD_WAIT };
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWaitForResourceOfflineDlg)
    protected:
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWaitForResourceOfflineDlg)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Override this function to provide your own implementation
    // To exit out of the dialog, call CDialog::OnOK() here.
    virtual void OnTimerTick( void );

    CResource const *   m_pRes;

}; //*** class CWaitForResourceOfflineDlg

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CWaitForResourceOnlineDlg
//
//  Description:
//      Display a dialog while waiting for a resource to go online.
//
//--
/////////////////////////////////////////////////////////////////////////////
class CWaitForResourceOnlineDlg : public CWaitDlg
{
public:
    CWaitForResourceOnlineDlg(
        CResource const *   pResIn,
        CWnd *              pwndParentIn = NULL
        );

// Dialog Data
    //{{AFX_DATA(CWaitForResourceOnlineDlg)
    enum { IDD = IDD_WAIT };
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWaitForResourceOnlineDlg)
    protected:
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWaitForResourceOnlineDlg)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Override this function to provide your own implementation
    // To exit out of the dialog, call CDialog::OnOK() here.
    virtual void OnTimerTick( void );

    CResource const *   m_pRes;

}; //*** class CWaitForResourceOnlineDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\verinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      VerInfo.cpp
//
//  Abstract:
//      Implementation of the CVersionInfo class.
//
//  Author:
//      David Potter (davidp)   October 11, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VerInfo.h"
#include "ExcOper.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagVersionInfo(_T("Misc"), _T("CVersionInfo"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CVersionInfo
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::CVersionInfo
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CVersionInfo::CVersionInfo(void)
{
    m_pbVerInfo = NULL;

}  //*** CVersionInfo::CVersionInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::~CVersionInfo
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CVersionInfo::~CVersionInfo(void)
{
    delete [] m_pbVerInfo;

}  //*** CVersionInfo::~CVersionInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::Init
//
//  Routine Description:
//      Initialize the class instance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from GetModuleFileName(),
//                              GetFileVersionInfoSize(), and
//                              GetFileVersionInfo().
//      Any exceptions thrown by new[]().
//--
/////////////////////////////////////////////////////////////////////////////
void CVersionInfo::Init(void)
{
    TCHAR       szExeName[MAX_PATH];
    DWORD       dwVerHandle;
    DWORD       cbVerInfo;

    ASSERT(m_pbVerInfo == NULL);

    // Get the name of the file from which to read version information.
    if (!::GetModuleFileName(
                    AfxGetInstanceHandle(),
                    szExeName,
                    sizeof(szExeName) / sizeof(TCHAR)
                    ))
        ThrowStaticException(::GetLastError());

    // Trace(...)

    try
    {
        // Get the size of the version information
        cbVerInfo = ::GetFileVersionInfoSize(szExeName, &dwVerHandle);
        if (cbVerInfo == 0)
            ThrowStaticException(::GetLastError());

        // Allocate the version info buffer.
        m_pbVerInfo = new BYTE[cbVerInfo];
        if ( m_pbVerInfo == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the version info buffer

        // Read the version info from the file.
        if (!::GetFileVersionInfo(szExeName, dwVerHandle, cbVerInfo, PbVerInfo()))
            ThrowStaticException(::GetLastError());
    }  // try
    catch (CException *)
    {
        delete [] m_pbVerInfo;
        m_pbVerInfo = NULL;
        throw;
    }  // catch:  CException

}  //*** CVersionInfo::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::PszQueryValue
//
//  Routine Description:
//      Read a string value from the version resource.
//
//  Arguments:
//      pszValueName    [IN] Name of value to get.
//
//  Return Value:
//      Pointer to value string buffer.
//      The string pointed to belongs to CVersionInfo and
//      is valid until the object is destructed.
//
//  Exceptions Thrown:
//      CNTException        Errors from VerQueryValue().
//      Any exceptions thrown by CString::Format().
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CVersionInfo::PszQueryValue(IN LPCTSTR pszValueName)
{
    CString     strValueName;
    LPDWORD     pdwTranslation;
    LPTSTR      pszReturn;
    UINT        cbReturn;
    UINT        cchReturn;

    ASSERT(pszValueName != NULL);
    ASSERT(PbVerInfo() != NULL);

    // Get the LangID and CharSetID.
    strValueName = _T("\\VarFileInfo\\Translation");
    if (!::VerQueryValue(
                PbVerInfo(),
                (LPTSTR) (LPCTSTR) strValueName,
                (LPVOID *) &pdwTranslation,
                &cbReturn
                )
            || (cbReturn == 0))
    {
        pszReturn = NULL;
    }  // if:  error getting LangID and CharSetID
    else
    {
        // Construct the name of the value to read.
        strValueName.Format(
                        _T("\\StringFileInfo\\%04X%04X\\%s"), 
                        LOWORD(*pdwTranslation), // LangID
                        HIWORD(*pdwTranslation), // CharSetID
                        pszValueName
                        );
        Trace(g_tagVersionInfo, _T("Querying '%s'"), strValueName);

        // Read the value.
        if (!::VerQueryValue(
                    PbVerInfo(),
                    (LPTSTR) (LPCTSTR) strValueName,
                    (LPVOID *) &pszReturn,
                    &cchReturn
                    )
                || (cchReturn == 0))
            pszReturn = NULL;
    }  // else:  

#ifdef _DEBUG
    if (pszReturn != NULL)
        Trace(g_tagVersionInfo, _T("PszQueryValue(%s) = '%s'"), pszValueName, pszReturn);
    else
        Trace(g_tagVersionInfo, _T("PszQueryValue(%s) = Not Available"), pszValueName);
#endif

    return pszReturn;

}  //*** CVersionInfo::PszQueryValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::BQueryValue
//
//  Routine Description:
//      Read a value from the version resource.
//
//  Arguments:
//      pszValueName    [IN] Name of value to get.
//      rdwValue        [OUT] DWORD in which to return the value.
//
//  Return Value:
//      TRUE = success, FALSE = failure
//
//  Exceptions Thrown:
//      None.
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CVersionInfo::BQueryValue(
    IN LPCTSTR  pszValueName,
    OUT DWORD & rdwValue
    )
{
    BOOL        bSuccess;
    UINT        cbReturn;
    DWORD *     pdwValue;

    ASSERT(pszValueName != NULL);
    ASSERT(PbVerInfo() != NULL);

    // Read the value.
    if (!::VerQueryValue(
                PbVerInfo(),
                (LPTSTR) pszValueName,
                (LPVOID *) &pdwValue,
                &cbReturn
                )
            || (cbReturn == 0))
        bSuccess = FALSE;
    else
    {
        rdwValue = *pdwValue;
        bSuccess = TRUE;
    }  // else:  value read successfully

#ifdef _DEBUG
    if (bSuccess)
        Trace(g_tagVersionInfo, _T("BQueryValue(%s) = '%lx'"), pszValueName, rdwValue);
    else
        Trace(g_tagVersionInfo, _T("BQueryValue(%s) = Not Available"), pszValueName);
#endif

    return bSuccess;

}  //*** CVersionInfo::BQueryValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::PffiQueryValue
//
//  Routine Description:
//      Read the VS_FIXEDFILEINFO information from the version resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      pffi            Pointer to a VS_FIXEDFILEINFO structure.  The buffer
//                          pointerd to belongs to CVersionInfo and is valid
//                          until the object is destructed.
//
//  Exceptions Thrown:
//      CNTException        Errors from VerQueryValue().
//      Any exceptions thrown by CString::Format().
//--
/////////////////////////////////////////////////////////////////////////////
const VS_FIXEDFILEINFO * CVersionInfo::PffiQueryValue(void)
{
    VS_FIXEDFILEINFO *  pffi;
    UINT                cbReturn;

    ASSERT(PbVerInfo() != NULL);

    // Read the FixedFileInfo.
    if (!::VerQueryValue(PbVerInfo(), _T("\\"), (LPVOID *) &pffi, &cbReturn)
            || (cbReturn == 0))
        pffi = NULL;

#ifdef _DEBUG
    if (pffi != NULL)
        Trace(g_tagVersionInfo, _T("PffiQueryValue() version = %d.%d.%d.%d"),
            HIWORD(pffi->dwFileVersionMS),
            LOWORD(pffi->dwFileVersionMS),
            HIWORD(pffi->dwFileVersionLS),
            LOWORD(pffi->dwFileVersionLS));
    else
        Trace(g_tagVersionInfo, _T("PffiQueryValue() = Not Available"));
#endif

    return pffi;

}  //*** CVersionInfo::PffiQueryValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CVersionInfo::QueryFileVersionDisplayString
//
//  Routine Description:
//      Read the file version as a display string from the version resource.
//
//  Arguments:
//      rstrValue   [OUT] String in which to return the version display string.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        ERROR_RESOURCE_TYPE_NOT_FOUND.
//      Any exceptions thrown by CString::Format().
//--
/////////////////////////////////////////////////////////////////////////////
void CVersionInfo::QueryFileVersionDisplayString(OUT CString & rstrValue)
{
    const VS_FIXEDFILEINFO *    pffi;

    // Get the file version information.
    pffi = PffiQueryValue();
    if (pffi == NULL)
    {
        ThrowStaticException((SC) ERROR_RESOURCE_TYPE_NOT_FOUND);
        return;
    }

    // Format the display string.
    rstrValue.Format(
        IDS_VERSION_NUMBER_FORMAT,
        HIWORD(pffi->dwFileVersionMS),
        LOWORD(pffi->dwFileVersionMS),
        HIWORD(pffi->dwFileVersionLS),
        LOWORD(pffi->dwFileVersionLS)
        );

    Trace(g_tagVersionInfo, _T("QueryFileVersionDisplayString() = %s"), rstrValue);

}  //*** CVersionInfo::QueryFileVersionDisplayString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\yestoall.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		YesToAll.h
//
//	Abstract:
//		Definition of the CYesToAllDialog class.
//
//	Implementation File:
//		YesToAll.cpp
//
//	Author:
//		David Potter (davidp)	May 20, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _YESTOALL_H_
#define _YESTOALL_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CYesToAllDialog;

/////////////////////////////////////////////////////////////////////////////
// class CYesToAllDialog
/////////////////////////////////////////////////////////////////////////////

class CYesToAllDialog : public CDialog
{
// Construction
public:
	CYesToAllDialog(LPCTSTR pszMessage, CWnd * pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CYesToAllDialog)
	enum { IDD = IDD_YESTOALL };
	CString	m_strMessage;
	//}}AFX_DATA
	LPCTSTR	m_pszMessage;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CYesToAllDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CYesToAllDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnYes();
	afx_msg void OnNo();
	afx_msg void OnYesToAll();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CYesToAllDialog

/////////////////////////////////////////////////////////////////////////////

#endif // _YESTOALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\basedata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BaseData.cpp
//
//	Abstract:
//		Implementation of the CBaseSnapInDataInterface template class.
//
//	Author:
//		David Potter (davidp)	November 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseData.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\basedata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BaseData.h
//
//  Abstract:
//      Definition of the CBaseSnapInDataInterface template class.
//
//  Implementation File:
//      BaseData.cpp
//
//  Author:
//      David Potter (davidp)   November 11, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEDATA_H_
#define __BASEDATA_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseNodeObj;
template < class T > class CBaseNodeObjImpl;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMPDATA_H_
#include "CompData.h"   // for CClusterComponentData
#endif

/////////////////////////////////////////////////////////////////////////////
// class CBaseNodeObj
/////////////////////////////////////////////////////////////////////////////

class CBaseNodeObj
{
public:
    //
    // Object construction and destruction.
    //

    CBaseNodeObj( CClusterComponentData * pcd )
    {
        _ASSERTE( pcd != NULL );
        m_pcd = pcd;

    } //*** CBaseNodeObj()

    ~CBaseNodeObj( void )
    {
        m_pcd = NULL;

    } //*** ~CBaseNodeObj()

public:
    //
    // CBaseNodeObj-specific methods.
    //

    // Object is being destroyed
    STDMETHOD( OnDestroy )( void ) = 0;

    // Set the scope pane ID.
    STDMETHOD_( void, SetScopePaneID )( HSCOPEITEM hsi ) = 0;

public:
    //
    // IConsole methods through m_pcd.
    //

    // Returns a handle to the main frame window
    HWND GetMainWindow( void )
    {
        _ASSERTE( m_pcd != NULL );
        return m_pcd->GetMainWindow();

    } //*** GetMainWindow()

    // Display a message box as a child of the console
    int MessageBox(
        LPCWSTR lpszText,
        LPCWSTR lpszTitle = NULL,
        UINT fuStyle = MB_OK
        )
    {
        _ASSERTE( m_pcd != NULL );
        return m_pcd->MessageBox( lpszText, lpszTitle, fuStyle );

    } //*** MessageBox()

protected:
    CClusterComponentData * m_pcd;

public:
    CClusterComponentData * Pcd( void )
    {
        return m_pcd;

    } //*** Pcd()

}; //*** class CBaseNodeObj

/////////////////////////////////////////////////////////////////////////////
// class CBaseNodeObjImpl
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CBaseNodeObjImpl :
    public CSnapInItemImpl< T >,
    public CBaseNodeObj
{
public:
    //
    // Construction and destruction.
    //

    CBaseNodeObjImpl( CClusterComponentData * pcd ) : CBaseNodeObj( pcd )
    {
    } //*** CBaseNodeObjImpl()

public:
    //
    // CBaseNodeObj methods.
    //

    // Object is being destroyed
    STDMETHOD( OnDestroy )( void )
    {
        return S_OK;

    } //*** OnDestroy()

    // Set the scope pane ID.
    STDMETHOD_( void, SetScopePaneID )( HSCOPEITEM hsi )
    {
        m_scopeDataItem.ID = hsi;

    } //*** SetScopePaneID()

public:
    //
    // CBaseNodeObjImpl-specific methods.
    //

    // Insert the item into the namespace (scope pane)
    HRESULT InsertIntoNamespace( HSCOPEITEM hsiParent )
    {
        _ASSERTE( m_pcd != NULL );
        _ASSERTE( m_pcd->m_spConsoleNameSpace != NULL );

        HRESULT         hr = S_OK;
        SCOPEDATAITEM   sdi;

        ZeroMemory( &sdi, sizeof(sdi) );

        //
        // Fill in the scope data item structure.
        //
        sdi.mask        = SDI_STR
                            | SDI_IMAGE
                            | SDI_OPENIMAGE
                            | SDI_PARAM
                            | SDI_PARENT;
        sdi.displayname = MMC_CALLBACK;
        sdi.nImage      = m_scopeDataItem.nImage;
        sdi.nOpenImage  = m_scopeDataItem.nImage;
        sdi.lParam      = (LPARAM) this;
        sdi.relativeID  = hsiParent;

        //
        // Insert the item into the namespace.
        //
        hr = m_pcd->m_spConsoleNameSpace->InsertItem( &sdi );
        if ( SUCCEEDED(hr) )
            m_scopeDataItem.ID = hsiParent;

        return hr;

    } //*** InsertIntoNamespace()

public:
    //
    // CSnapInItem methods
    //

    STDMETHOD_( LPWSTR, PszGetDisplayName )( void ) = 0;

    // Get display info for a scope pane item
    STDMETHOD( GetScopePaneInfo )(
        SCOPEDATAITEM * pScopeDataItem
        )
    {
        _ASSERTE( pScopeDataItem != NULL );

        if ( pScopeDataItem->mask & SDI_STR )
        {
            pScopeDataItem->displayname = PszGetDisplayName();
        }
        if ( pScopeDataItem->mask & SDI_IMAGE )
        {
            pScopeDataItem->nImage = m_scopeDataItem.nImage;
        }
        if ( pScopeDataItem->mask & SDI_OPENIMAGE )
        {
            pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
        }
        if ( pScopeDataItem->mask & SDI_PARAM )
        {
            pScopeDataItem->lParam = m_scopeDataItem.lParam;
        }
        if ( pScopeDataItem->mask & SDI_STATE )
        {
            pScopeDataItem->nState = m_scopeDataItem.nState;
        }

        return S_OK;

    } //*** GetScopePaneInfo()

    // Get display info for a result pane item
    STDMETHOD( GetResultPaneInfo )(
        RESULTDATAITEM * pResultDataItem
        )
    {
        _ASSERTE( pResultDataItem != NULL );

        if ( pResultDataItem->bScopeItem )
        {
            if ( pResultDataItem->mask & RDI_STR )
            {
                pResultDataItem->str = GetResultPaneColInfo( pResultDataItem->nCol );
            }
            if ( pResultDataItem->mask & RDI_IMAGE )
            {
                pResultDataItem->nImage = m_scopeDataItem.nImage;
            }
            if ( pResultDataItem->mask & RDI_PARAM )
            {
                pResultDataItem->lParam = m_scopeDataItem.lParam;
            }

            return S_OK;
        }

        if ( pResultDataItem->mask & RDI_STR )
        {
            pResultDataItem->str = GetResultPaneColInfo( pResultDataItem->nCol );
        }
        if ( pResultDataItem->mask & RDI_IMAGE )
        {
            pResultDataItem->nImage = m_resultDataItem.nImage;
        }
        if ( pResultDataItem->mask & RDI_PARAM )
        {
            pResultDataItem->lParam = m_resultDataItem.lParam;
        }
        if ( pResultDataItem->mask & RDI_INDEX )
        {
            pResultDataItem->nIndex = m_resultDataItem.nIndex;
        }
        return S_OK;

    } //*** GetResultPaneInfo()

    // Get column info for the result pane
    virtual LPOLESTR GetResultPaneColInfo( int nCol )
    {
        LPOLESTR polesz = L"";

        switch ( nCol )
        {
            case 0:
                polesz = PszGetDisplayName();
                break;
        } // switch:  nCol

        return polesz;

    } //*** GetResultPaneColInfo()

}; //*** class CBaseNodeObjImpl

/////////////////////////////////////////////////////////////////////////////

#endif // __BASEDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\cluadmmc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		CluAdMMC.cpp
//
//	Abstract:
//		Implementation of DLL Exports.
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL,
//		run nmake -f CluAdMMCps.mk in the project directory.

#include "stdafx.h"
#include <StrSafe.h>
#include "resource.h"
#include "initguid.h"

#include "CompData.h"
#include "SnapAbout.h"

/////////////////////////////////////////////////////////////////////////////
// Single module object
/////////////////////////////////////////////////////////////////////////////

CMMCSnapInModule _Module;

/////////////////////////////////////////////////////////////////////////////
// Objects supported by this DLL
/////////////////////////////////////////////////////////////////////////////

BEGIN_OBJECT_MAP( ObjectMap )
	OBJECT_ENTRY( CLSID_ClusterAdmin, CClusterComponentData )
	OBJECT_ENTRY( CLSID_ClusterAdminAbout, CClusterAdminAbout )
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllMain
//
//	Routine Description:
//		DLL Entry Point.
//
//	Arguments:
//		hInstance		Handle to this DLL.
//		dwReason		Reason this function was called.
//							Can be Process/Thread Attach/Detach.
//		lpReserved		Reserved.
//
//	Return Value:
//		TRUE			No error.
//		FALSE			Error occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/ )
{
	if ( dwReason == DLL_PROCESS_ATTACH )
	{
		_Module.Init( ObjectMap, hInstance );
		CSnapInItem::Init();
		DisableThreadLibraryCalls( hInstance );
	} // if:  attaching to a process
	else if ( dwReason == DLL_PROCESS_DETACH )
	{
		_Module.Term();
	} // else:  detaching from a process

	return TRUE;    // ok

} //*** DllMain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllCanUnloadNow
//
//	Routine Description:
//		Used to determine whether the DLL can be unloaded by OLE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		DLL can be unloaded.
//		S_FALSE		DLL can not be unloaded.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow( void )
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

} //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllGetClassObject
//
//	Routine Description:
//		Returns a class factory to create an object of the requested type.
//
//	Arguments:
//		rclsid		CLSID of class desired.
//		riid		IID of interface on class factory desired.
//		ppv			Filled with interface pointer to class factory.
//
//	Return Value:
//		S_OK		Class object returned successfully.
//		Any status codes returned from _Module.GetClassObject().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID * ppv )
{
	return _Module.GetClassObject( rclsid, riid, ppv );

} //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterServer
//
//	Routine Description:
//		Registers the interfaces and objects that this DLL supports in the
//		system registry.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		DLL registered successfully.
//		Any status codes returned from _Module.RegisterServer().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer( TRUE /*bRegTypeLib*/ );

} //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterServer
//
//	Routine Description:
//		Unregisters the interfaces and objects that this DLL supports in the
//		system registry.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		DLL unregistered successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer( void )
{
	_Module.UnregisterServer();
	return S_OK;

} //*** DllUnregisterServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\comp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      Comp.cpp
//
//  Abstract:
//      Implementation of the CClusterComponent class.
//
//  Author:
//      David Potter (davidp)   November 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <StrSafe.h>
#include "Comp.h"

/////////////////////////////////////////////////////////////////////////////
// class CClusterComponent
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponent::GetHelpTopic [ISnapinHelp]
//
//  Routine Description:
//      Merge our help file into the MMC help file.
//
//  Arguments:
//      lpCompiledHelpFile  [OUT] Pointer to the address of the NULL-terminated
//                              UNICODE string that contains the full path of
//                              compiled help file (.chm) for the snap-in.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponent::GetHelpTopic(
    OUT LPOLESTR * lpCompiledHelpFile
    )
{
    HRESULT hr = S_OK;

    ATLTRACE( _T("Entering CClusterComponent::GetHelpTopic()\n") );

    if ( lpCompiledHelpFile == NULL )
    {
        hr = E_POINTER;
    } // if: no output string
    else
    {
        *lpCompiledHelpFile = reinterpret_cast< LPOLESTR >( CoTaskMemAlloc( MAX_PATH * sizeof( OLECHAR ) ) );
        if ( *lpCompiledHelpFile == NULL )
        {
            hr = E_OUTOFMEMORY;
        } // if: error allocating memory for the string
        else
        {
            ExpandEnvironmentStringsW( HELP_FILE_NAME, *lpCompiledHelpFile, MAX_PATH );
            ATLTRACE( _T("CClusterComponent::GetHelpTopic() - Returning %s as help file\n"), *lpCompiledHelpFile );
        } // else: allocated memory successfully
    } // else: help string specified

    ATLTRACE( _T("Leaving CClusterComponent::GetHelpTopic()\n") );

    return hr;

} //*** CClusterComponent::GetHelpTopic()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\comp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		Comp.h
//
//	Abstract:
//		Definition of the CClusterComponent class.
//
//	Implementation File:
//		Comp.cpp
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMP_H_
#define __COMP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterComponent;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include "resource.h"
//#include <atlsnap.h>

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

// Enumeration for the icon index in the image list.
enum
{
	IMGLI_ROOT = 0,
	IMGLI_CLUSTER,
	IMGLI_NODE,
	IMGLI_GROUP,
	IMGLI_RES,
	IMGLI_RESTYPE,
	IMGLI_NETWORK,
	IMGLI_NETIFACE,

	IMGLI_MAX	// Must be last
};

#define HELP_FILE_NAME	L"%SystemRoot%\\Help\\mscs.chm"
#define FULL_HELP_TOPIC	L"mscsConcepts.chm::/mscsQuick.htm"

/////////////////////////////////////////////////////////////////////////////
// class CClusterComponent
/////////////////////////////////////////////////////////////////////////////

class CClusterComponent :
	public CComObjectRootEx< CComSingleThreadModel >,
	public CSnapInObjectRoot,
	public IExtendContextMenuImpl< CClusterComponent >,
	public ISnapinHelp,
	public IComponentImpl< CClusterComponent >
{
public:
	//
	// Map interfaces to this class.
	//
	BEGIN_COM_MAP( CClusterComponent )
		COM_INTERFACE_ENTRY( IComponent )
		COM_INTERFACE_ENTRY( IExtendContextMenu )
		COM_INTERFACE_ENTRY( ISnapinHelp )
	END_COM_MAP()

public:
	//
	// Object construction and destruction.
	//

	CClusterComponent( void )
	{
	}

public:
	//
	// ISnapinHelp methods.
	//

	// Merge our help file into the MMC help file
	STDMETHOD( GetHelpTopic )( OUT LPOLESTR * lpCompiledHelpFile );

}; // class CClusterComponent

/////////////////////////////////////////////////////////////////////////////

#endif // __COMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ExcOperS.cpp
//
//  Abstract:
//      Stub for implementation of exception classes.
//
//  Author:
//      David Potter (davidp)   October 10, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

inline int EXC_AppMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
    UNREFERENCED_PARAMETER( nIDHelp );
    return MMCMessageBox(NULL, lpszText, nType);
}

inline int EXC_AppMessageBox(UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
    UNREFERENCED_PARAMETER( nIDHelp );
    return MMCMessageBox(NULL, nIDPrompt, nType);
}

inline int EXC_AppMessageBox(HWND hwndParent, LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
    UNREFERENCED_PARAMETER( nIDHelp );
    return MMCMessageBox(hwndParent, lpszText, nType);
}

inline int EXC_AppMessageBox(HWND hwndParent, UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
    UNREFERENCED_PARAMETER( nIDHelp );
    return MMCMessageBox(hwndParent, nIDPrompt, nType);
}

inline HINSTANCE EXC_GetResourceInstance(void)
{
    return _Module.GetResourceInstance();
}

#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CluAdMMC.rc
//
#define IDR_CLUSTERADMIN                100
#define IDR_CLUSTERADMIN_MENU           101
#define IDR_CLUSTER_MENU                102
#define IDB_CLUSTER_16                  130
#define IDB_CLUSTER_32                  131
#define IDB_CLUSTER_64                  132
#define IDD_CLUSTERADMIN                200
#define IDS_PROJNAME                    10000
#define IDS_CLUSTERADMIN_DESC           10001
#define IDS_CLUSTERADMIN_PROVIDER       10002
#define IDS_CLUSTERADMIN_VERSION        10003
#define IDS_CLUSTERADMIN_APP_NAME       10004
#define IDS_CLUSTERADMIN_SNAPIN_NAME    10005
#define IDS_CLUSTERADMIN_SNAPIN_TYPE    10006
#define IDS_NODETYPE_STATIC_NODE        20000
#define ID_MANAGE_CLUSTER               32768
#define IDS_ERROR_MSG_ID                40609
#define IDS_ERROR_FINDING_CLUADMIN      41000
#define IDS_ERROR_LAUNCHING_CLUADMIN    41001
#define IDP_NO_ERROR_AVAILABLE          61472

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        300
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           150
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\mmcapp.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      MMCApp.inl
//
//  Abstract:
//      Inline method implementations for the CMMCSnapInModule class.
//
//  Author:
//      David Potter (davidp)   November 12, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __MMCAPP_INL_
#define __MMCAPP_INL_

/////////////////////////////////////////////////////////////////////////////
// class CMMCSnapInModule
/////////////////////////////////////////////////////////////////////////////

// Returns a handle to the main MMC frame window
inline HWND CMMCSnapInModule::GetMainWindow(void)
{
    _ASSERTE(m_spConsole != NULL);

    HWND hwnd;
    HRESULT hr;
    hr = m_spConsole->GetMainWindow(&hwnd);
    _ASSERTE(SUCCEEDED(hr));
    return hwnd;

} //*** CMMCSnapInModule::GetMainWindow()

// Display a message box as a child of the console
inline int CMMCSnapInModule::MessageBox(
    HWND hwndParent,
    LPCWSTR lpszText,
    UINT fuStyle
    )
{
    if (hwndParent == NULL)
    {
        hwndParent = GetMainWindow();
    }

    return ::MessageBox(
            hwndParent,
            lpszText,
            m_pszAppName,
            fuStyle
            );

} //*** CMMCSnapInModule::MessageBox(lpszText)

// Display a message box as a child of the console
inline int CMMCSnapInModule::MessageBox(
    HWND hwndParent,
    UINT nID,
    UINT fuStyle
    )
{
    CString strMsg;

    strMsg.LoadString(nID);

    if (hwndParent == NULL)
    {
        hwndParent = GetMainWindow();
    }

    return ::MessageBox(
            hwndParent,
            strMsg,
            m_pszAppName,
            fuStyle
            );

} //*** CMMCSnapInModule::MessageBox(nID)

/////////////////////////////////////////////////////////////////////////////
// Helper Functions
/////////////////////////////////////////////////////////////////////////////

// Get a pointer to the MMC application object
inline CMMCSnapInModule * MMCGetApp(void)
{
    return &_Module;
}

// Retuns a handle to the main MMC frame window
inline HWND MMCGetMainWindow(void)
{
    return MMCGetApp()->GetMainWindow();
}

// Display a message box with the MMC console as the parent
inline int MMCMessageBox(HWND hwndParent, LPCWSTR lpszText, UINT fuStyle)
{
    return MMCGetApp()->MessageBox(hwndParent, lpszText, fuStyle);

} // MMCMessageBox()

// Display a message box with the MMC console as the parent
inline int MMCMessageBox(HWND hwndParent, UINT nID, UINT fuStyle)
{
    return MMCGetApp()->MessageBox(hwndParent, nID, fuStyle);

} // MMCMessageBox()

/////////////////////////////////////////////////////////////////////////////
// Provide TRACE support
/////////////////////////////////////////////////////////////////////////////

// Get a pointer to the application object
inline CMMCSnapInModule * TRACE_GetApp(void)
{
    return MMCGetApp();
}

inline int TRACE_AppMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
    UNREFERENCED_PARAMETER( nIDHelp );

    return MMCMessageBox(NULL, lpszText, nType);
}

inline int TRACE_AppMessageBox(UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
    UNREFERENCED_PARAMETER( nIDHelp );

    return MMCMessageBox(NULL, nIDPrompt, nType);
}

/////////////////////////////////////////////////////////////////////////////

#endif // __MMCAPP_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\mmcapp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1998 Microsoft Corporation
//
//  Module Name:
//      MMCApp.h
//
//  Abstract:
//      Definition of the CMMCSnapInModule class.
//
//  Implementation File:
//      MMCApp.cpp
//
//  Author:
//      David Potter (davidp)   November 11, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __MMCAPP_H_
#define __MMCAPP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CMMCSnapInModule;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

interface IConsole;
namespace ATL
{
    class CString;
}

/////////////////////////////////////////////////////////////////////////////
// External Declarations
/////////////////////////////////////////////////////////////////////////////

EXTERN_C const IID IID_IConsole;
extern CMMCSnapInModule _Module;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CMMCSnapInModule
/////////////////////////////////////////////////////////////////////////////

class CMMCSnapInModule : public CComModule
{
protected:
    int     m_crefs;
    LPWSTR  m_pszAppName;

public:
    CComQIPtr< IConsole, &IID_IConsole > m_spConsole;

    // Default constructor
    CMMCSnapInModule( void )
    {
        m_crefs = 0;
        m_pszAppName = NULL;

    } //*** CMMCSnapInModule()

    // Destructor
    ~CMMCSnapInModule( void )
    {
        delete [] m_pszAppName;

    } //*** ~CMMCSnapInModule()

    // Increment the reference count to this object
    int AddRef( void )
    {
        m_crefs++;
        return m_crefs;

    } //*** AddRef()

    // Decrement the reference count to this object
    int Release( void );

    // Initialize the module.
    void Init( _ATL_OBJMAP_ENTRY * p, HINSTANCE h )
    {
        CComModule::Init( p, h );

    } //*** Init( p, h )

    // Initialize the application object
    int Init( IUnknown * pUnknown, UINT idsAppName );

    // Terminate the module
    void Term( void )
    {
        CComModule::Term();

    } //*** Term()

    // Returns the name of the application.
    LPCWSTR GetAppName( void )
    {
        return m_pszAppName;

    } //*** GetAppName()

    // Initialize the application object
    int Init( IUnknown * pUnknown, LPCWSTR pszAppName );

    // Returns a handle to the main MMC frame window
    HWND GetMainWindow( void );

    // Display a message box as a child of the console
    int MessageBox(
        HWND hwndParent,
        LPCWSTR lpszText,
        UINT fuStyle = MB_OK
        );

    // Display a message box as a child of the console
    int MessageBox(
        HWND hwndParent,
        UINT nID,
        UINT fuStyle = MB_OK
        );

    // Read a value from the profile
    CString GetProfileString(
        LPCTSTR lpszSection,
        LPCTSTR lpszEntry,
        LPCTSTR lpszDefault = NULL
        );

}; // class CMMCSnapInModule

/////////////////////////////////////////////////////////////////////////////

#endif // __MMCAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\compdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      CompData.cpp
//
//  Abstract:
//      Implementation of the CClusterComponent class.
//
//  Author:
//      David Potter (davidp)   November 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <StrSafe.h>
#include "CompData.h"
#include "RootNode.h"

/////////////////////////////////////////////////////////////////////////////
// class CClusterComponentData
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Extension Snap-In Node Info Map

//BEGIN_EXTENSION_SNAPIN_NODEINFO_PTR_MAP( CClusterComponentData(
//  EXTENSION_SNAPIN_NODEINFO_PTR_ENTRY( CServerAppsNodeData(
//END_EXTENSION_SNAPIN_NODEINFO_MAP()

/////////////////////////////////////////////////////////////////////////////
// Static Variables

_declspec( selectany ) CLIPFORMAT CClusterComponentData::s_CCF_MACHINE_NAME = 0;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::CClusterComponentData
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterComponentData::CClusterComponentData( void )
{
    m_pNode = NULL;
    ZeroMemory( m_wszMachineName, sizeof(m_wszMachineName) );

//  m_pNode = new CRootNodeData( this );
//  _ASSERTE( m_pNode != NULL );

    //
    // Initialize the extension node objects.
    //
//  INIT_EXTENSION_SNAPIN_DATACLASS_PTR( CServerAppsNodeData );

} //*** CClusterComponentData::CClusterComponentData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::~CClusterComponentData
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterComponentData::~CClusterComponentData( void )
{
    delete m_pNode;
    m_pNode = NULL;

    //
    // Cleanup the extension node objects.
    //
//  DEINIT_EXTENSION_SNAPIN_DATACLASS_PTR( CServerAppsNodeData );

} //*** CClusterComponentData::~CClusterComponentData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::UpdateRegistry
//
//  Routine Description:
//      Update the registry for this object.
//
//  Arguments:
//      bRegister   TRUE = register, FALSE = unregister.
//
//  Return Value:
//      Any return values from _Module.UpdateRegistryFromResource.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CClusterComponentData::UpdateRegistry( BOOL bRegister )
{
    HRESULT hr = S_OK;

    static WCHAR oszAppDisplayName[256] = { 0 };
    static WCHAR oszSnapInDisplayName[256] = { 0 };
    static _ATL_REGMAP_ENTRY rgRegMap[] =
    {
        { OLESTR("AppDisplayName"),     oszAppDisplayName },
        { OLESTR("SnapInDisplayName"),  oszSnapInDisplayName },
        { NULL, NULL }
    };

    //
    // Load replacement values.
    //
    if ( oszAppDisplayName[0] == OLESTR('\0') )
    {
        CString str;

        str.LoadString( IDS_CLUSTERADMIN_APP_NAME );
        hr = StringCchCopyW( oszAppDisplayName, RTL_NUMBER_OF( oszAppDisplayName ), str );
        if ( SUCCEEDED( hr ) )
        {
            str.LoadString( IDS_CLUSTERADMIN_SNAPIN_NAME );
            hr = StringCchCopyW( oszSnapInDisplayName, RTL_NUMBER_OF( oszSnapInDisplayName ), str );
        } // if:
    } // if:  replacement values not loaded yet

    if ( SUCCEEDED( hr ) )
    {
        hr = _Module.UpdateRegistryFromResourceS( IDR_CLUSTERADMIN, bRegister, rgRegMap );
    } // if:

    return hr;

} //*** CClusterComponentData::UpdateRegistry()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::Initialize [IComponentData]
//
//  Routine Description:
//      Initialize this object.
//
//  Arguments:
//      pUnknown    IUnknown pointer from the console.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponentData::Initialize( LPUNKNOWN pUnknown )
{
    HRESULT hr = S_OK;
    HBITMAP hBitmap16 = NULL;
    HBITMAP hBitmap32 = NULL;

    //
    // Add bitmaps to the scope page image list.
    //

    CComPtr<IImageList> spImageList;

    // Call the base class.
    hr = IComponentDataImpl< CClusterComponentData, CClusterComponent >::Initialize( pUnknown );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Initialize the application.
    //
    MMCGetApp()->Init( m_spConsole, IDS_CLUSTERADMIN_APP_NAME );

    //
    // Get a pointer to the IConsoleNameSpace interface.
    //
    m_spConsoleNameSpace = pUnknown;
    if ( m_spConsoleNameSpace == NULL )
    {
        ATLTRACE( _T("QI for IConsoleNameSpace failed\n") );
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // Register the clipboard formats we will be using.
    //
    if ( s_CCF_MACHINE_NAME == NULL )
    {
        s_CCF_MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat( _T("MMC_SNAPIN_MACHINE_NAME") );
    }

    if ( m_spConsole->QueryScopeImageList( &spImageList ) != S_OK )
    {
        ATLTRACE( _T("IConsole::QueryScopeImageList failed\n") );
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // Load bitmaps associated with the scope pane
    // and add them to the image list
    // Loads the default bitmaps generated by the wizard
    // Change as needed
    hBitmap16 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_CLUSTER_16 ) );
    if ( hBitmap16 == NULL )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hBitmap32 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_CLUSTER_32 ) );
    if ( hBitmap32 == NULL )
    {
        hr = S_OK;
        goto Cleanup;
    }

    if ( spImageList->ImageListSetStrip( (LONG_PTR*)hBitmap16,
        (LONG_PTR*)hBitmap32, IMGLI_ROOT, RGB( 255, 0, 255 ) ) != S_OK )
    {
        ATLTRACE( _T("IImageList::ImageListSetStrip failed\n") );
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    if ( spImageList->ImageListSetStrip( (LONG_PTR*)hBitmap16,
        (LONG_PTR*)hBitmap32, IMGLI_CLUSTER, RGB( 255, 0, 255 ) ) != S_OK )
    {
        ATLTRACE( _T("IImageList::ImageListSetStrip failed\n") );
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // Allocate the extension node objects.
    //

//  ALLOC_EXTENSION_SNAPIN_DATACLASS_PTR( CServerAppsNodeData );

Cleanup:
    if ( hBitmap16 != NULL )
    {
        DeleteObject( hBitmap16 );
    }
    if ( hBitmap32 != NULL )
    {
        DeleteObject( hBitmap32 );
    }

    return hr;

} //*** CClusterComponentData::Initialize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::Destroy [IComponentData]
//
//  Routine Description:
//      Object is being destroyed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponentData::Destroy( void )
{
    //
    // Notify the node that it is being destroyed.
    //
    if ( m_pNode != NULL )
    {
        CBaseNodeObj * pBaseNode = dynamic_cast< CBaseNodeObj * >( m_pNode );
        _ASSERTE( pBaseNode != NULL );
        pBaseNode->OnDestroy();
        m_pNode = NULL;
    } // if:  we have a reference to a node

    //
    // Notify the application that we are going away.
    //
    MMCGetApp()->Release();

    return S_OK;

} //*** CClusterComponentData::Destroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::Notify [IComponentData]
//
//  Routine Description:
//      Handle notification messages from MMC.
//
//  Arguments:
//      lpDataObject    [IN] Data object containing info about event.
//      event           [IN] The event that occurred.
//      arg             [IN] Event-specific argument.
//      param           [IN] Event-specific parameter.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponentData::Notify(
    LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    long arg,
    long param
    )
{
    HRESULT hr = S_OK;

    switch ( event )
    {
        case MMCN_EXPAND:
            //
            // Create the node if it doesn't exist.
            //
            if ( m_pNode != NULL )
            {
                hr = IComponentDataImpl< CClusterComponentData, CClusterComponent >::Notify( lpDataObject, event, arg, param );
            } // if:  node already created
            else
            {
                hr = CreateNode( lpDataObject, arg, param );
            } // else:  no node created yet
            break;

        case MMCN_REMOVE_CHILDREN:
            if ( m_pNode != NULL )
            {
                CBaseNodeObj * pBaseNode = dynamic_cast< CBaseNodeObj * >( m_pNode );
                _ASSERTE( pBaseNode != NULL );
                pBaseNode->OnDestroy();
                m_pNode = NULL;
            } // if:  node not released yet
            ZeroMemory( m_wszMachineName, sizeof( m_wszMachineName ) );
            break;

        case MMCN_CONTEXTHELP:
            hr = HrDisplayContextHelp();
            break;

        default:
            hr = IComponentDataImpl< CClusterComponentData, CClusterComponent >::Notify( lpDataObject, event, arg, param );
            break;
    } // switch:  event

    return hr;

} //*** CClusterComponentData::Notify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::CreateNode
//
//  Routine Description:
//      Create the root node object.
//
//  Arguments:
//      lpDataObject    [IN] Data object containing info about event.
//      arg             [IN] Event-specific argument.
//      param           [IN] Event-specific parameter.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterComponentData::CreateNode(
    LPDATAOBJECT lpDataObject,
    long arg,
    long param
    )
{
    UNREFERENCED_PARAMETER( arg );

    _ASSERTE( m_pNode == NULL );

    HRESULT hr = S_OK;

    //
    // Get the parent scope item.
    //
    HSCOPEITEM hsiParent = (HSCOPEITEM) param;
    _ASSERTE( hsiParent != NULL );

    //
    // Save the name of the computer being managed.
    //
    hr = HrSaveMachineNameFromDataObject( lpDataObject );
    if ( FAILED( hr ) )
    {
        CNTException nte( hr );
        nte.ReportError();
        goto Cleanup;
    } // if:  error saving the machine name

    //
    // Allocate a new CRootNodeData object.
    //
    CRootNodeData * pData = new CRootNodeData( this );
    _ASSERTE( pData != NULL );

    //
    // Insert the node into the namespace.
    //
    hr = pData->InsertIntoNamespace( hsiParent );
    if ( FAILED( hr ) )
    {
        delete pData;
    } // if:  failed to insert it into the namespace
    else
    {
        m_pNode = pData;
    } // else:  inserted into the namespace successfully

Cleanup:

    return hr;

} //*** CClusterComponentData::CreateNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::HrSaveMachineNameFromDataObject
//
//  Routine Description:
//      Get the machine name from the data object and save it.
//
//  Arguments:
//      lpDataObject    [IN] Data object containing info about event.
//
//  Return Value:
//      S_OK        Operation completed successfully.
//      HRESULT from CClusterComponentData::ExtractFromDataObject().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterComponentData::HrSaveMachineNameFromDataObject(
    LPDATAOBJECT lpDataObject
    )
{
    _ASSERTE( m_pNode == NULL );

    HRESULT     hr = S_OK;
    HGLOBAL     hGlobal = NULL;

    //
    // Get the name of the computer being managed.
    //
    hr = ExtractFromDataObject(
            lpDataObject,
            s_CCF_MACHINE_NAME,
            sizeof( m_wszMachineName ),
            &hGlobal
            );
    if ( SUCCEEDED( hr ) )
    {
        SetMachineName( (LPCWSTR) hGlobal );
        GlobalFree( hGlobal );
    } // if:  successfully extracted the machine name

    return hr;

} //*** CClusterComponentData::HrSaveMachineNameFromDataObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::ExtractFromDataObject
//
//  Routine Description:
//      Extract data from a data object.
//
//  Arguments:
//      pDataObject Data object from which to extract the string.
//      cf          Clipboard format of the data.
//      cb          Size, in bytes, of requested data.
//      phGlobal    Filled with handle to data.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterComponentData::ExtractFromDataObject(
    LPDATAOBJECT    pDataObject,
    CLIPFORMAT      cf,
    DWORD           cb,
    HGLOBAL *       phGlobal
    )
{
    _ASSERTE( pDataObject != NULL );
    _ASSERTE( phGlobal != NULL );
    _ASSERTE( cb > 0 );

    STGMEDIUM   stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC   formatetc = { cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    HRESULT     hr = S_OK;

    *phGlobal = NULL;

    //
    // Allocate memory for the stream.
    //
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, cb );
    if ( stgmedium.hGlobal == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if:  error allocating memory

    //
    // Attempt to get data from the object.
    //
    hr = pDataObject->GetDataHere( &formatetc, &stgmedium );
    if ( FAILED( hr ) )
        goto Cleanup;

    *phGlobal = stgmedium.hGlobal;
    stgmedium.hGlobal = NULL;

Cleanup:

    if ( FAILED( hr ) && (stgmedium.hGlobal != NULL) )
        GlobalFree( stgmedium.hGlobal );

    return hr;

} //*** CClusterComponentData::ExtractFromDataObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::SetMachineName
//
//  Routine Description:
//      Set the machine name being managed.
//
//  Arguments:
//      pszMachineName  Name of machine being managed.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterComponentData::SetMachineName( LPCWSTR pwszMachineName )
{
    HRESULT hr;
    //
    // Copy the data to the class member variable.
    //
    _ASSERTE( wcslen( pwszMachineName ) < RTL_NUMBER_OF( m_wszMachineName ) );
    hr = StringCchCopyW( m_wszMachineName, RTL_NUMBER_OF(m_wszMachineName ), pwszMachineName );
    _ASSERTE( hr == S_OK );

} //*** CClusterComponentData::SetMachineName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::GetHelpTopic [ISnapinHelp]
//
//  Routine Description:
//      Merge our help file into the MMC help file.
//
//  Arguments:
//      lpCompiledHelpFile  [OUT] Pointer to the address of the NULL-terminated
//                              UNICODE string that contains the full path of
//                              compiled help file (.chm) for the snap-in.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterComponentData::GetHelpTopic(
    OUT LPOLESTR * lpCompiledHelpFile
    )
{
    HRESULT hr = S_OK;
    size_t  cb = 0;

    ATLTRACE( _T("Entering CClusterComponentData::GetHelpTopic()\n") );

    if ( lpCompiledHelpFile == NULL )
    {
        hr = E_POINTER;
    } // if: no output string
    else
    {
        cb = sizeof( HELP_FILE_NAME );

        *lpCompiledHelpFile = reinterpret_cast< LPOLESTR >( CoTaskMemAlloc( cb ) );
        if ( *lpCompiledHelpFile == NULL )
        {
            hr = E_OUTOFMEMORY;
        } // if: error allocating memory for the string
        else
        {
            ATLTRACE( _T("CClusterComponentData::GetHelpTopic() - Returning %s as help file\n"), HELP_FILE_NAME );
            hr = StringCbCopyW( *lpCompiledHelpFile, cb, HELP_FILE_NAME );
        } // else: allocated memory successfully
    } // else: help string specified

    ATLTRACE( _T("Leaving CClusterComponentData::GetHelpTopic()\n") );

    return hr;

} //*** CClusterComponentData::GetHelpTopic()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterComponentData::HrDisplayContextHelp
//
//  Routine Description:
//      Display context-sensitive help.
//
//  Arguments:
//      pszHelpTopic    [OUT] Pointer to the address of the NULL-terminated
//                              UNICODE string that contains the full path of
//                              compiled help file (.chm) for the snap-in.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterComponentData::HrDisplayContextHelp( void )
{
    HRESULT         hr = S_OK;
    IDisplayHelp *  pi = NULL;
    LPOLESTR        postr = NULL;
    size_t          cb = 0;

    //
    // Get the IDisplayHelp interface pointer.
    //
    hr = m_spConsole->QueryInterface(
            IID_IDisplayHelp,
            reinterpret_cast< void ** >( &pi )
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: error getting interface pointer

    //
    // Construct the help topic path.
    //
    cb = sizeof( FULL_HELP_TOPIC );
    postr = reinterpret_cast< LPOLESTR >( CoTaskMemAlloc( cb ) );
    if ( postr == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if: error allocating memory
    hr = StringCbCopyW( postr, cb, FULL_HELP_TOPIC );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Show the topic.
    //
    hr = pi->ShowTopic( postr );
    if ( SUCCEEDED( hr ) )
    {
        postr = NULL;
    } // if: topic shown successfully

Cleanup:

    //
    // Cleanup before returning.
    //
    if ( postr != NULL )
    {
        CoTaskMemFree( postr );
    } // if: topic string not passed to MMC successfully
    if ( pi != NULL )
    {
        pi->Release();
    } // if:  valid interface pointer

    return hr;

} //*** CClusterComponentData::HrDisplayContextHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\mmcapp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      MMCApp.cpp
//
//  Abstract:
//      Implementation of the CMMCSnapInModule class.
//
//  Author:
//      David Potter (davidp)   November 11, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <StrSafe.h>
#include "MMCApp.h"

/////////////////////////////////////////////////////////////////////////////
// class CMMCSnapInModule
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMMCSnapInModule::Init
//
//  Routine Description:
//      Initialize the application object
//
//  Arguments:
//      pUnknown    IUnknown pointer for getting the IConsole interface pointer.
//      pszAppName  Pointer to the application name.
//
//  Return Value:
//      Reference count after decrementing
//
//--
/////////////////////////////////////////////////////////////////////////////
int CMMCSnapInModule::Init( IUnknown * pUnknown, LPCWSTR pszAppName )
{
    _ASSERTE( pUnknown != NULL );
    _ASSERTE( pszAppName != NULL );

    if ( m_spConsole == NULL )
    {
        m_spConsole = pUnknown;
    } // if:  console interface not set yet
    if ( m_pszAppName == NULL )
    {
        size_t  cch = wcslen( pszAppName ) + 1;
        HRESULT hr = S_OK;

        m_pszAppName = new WCHAR[ cch ];
        _ASSERTE( m_pszAppName != NULL );
        hr = StringCchCopyW( m_pszAppName, cch, pszAppName );
        _ASSERTE( hr == S_OK );
    } //** if:  app name specified
    return AddRef();

} //*** Init( pUnknown, pszAppName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMMCSnapInModule::Release
//
//  Routine Description:
//      Decrement the reference count.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Reference count after decrementing
//
//--
/////////////////////////////////////////////////////////////////////////////
int CMMCSnapInModule::Release( void )
{
    //
    // Decrement the reference count.
    //
    int crefs = --m_crefs;

    //
    // If there are no more references to this object, free up all our
    // pointers, allocations, etc.
    //
    if ( crefs == 0 )
    {
        m_spConsole.Release();
        if ( m_pszAppName != NULL )
        {
            delete [] m_pszAppName;
            m_pszAppName = NULL;
        } // if:  app name string was allocated
    } // if:  no more references to this object

    return crefs;

} //*** CMMCSnapInModule::Release()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMMCSnapInModule::Init
//
//  Routine Description:
//      Initialize the module with a console interface pointer.
//
//  Arguments:
//      pUnknown    IUnknown pointer for getting the IConsole interface pointer.
//      UINT        idsAppName
//
//  Return Value:
//      Reference count.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CMMCSnapInModule::Init( IUnknown * pUnknown, UINT idsAppName )
{
    CString strAppName;
    strAppName.LoadString( idsAppName );
    return Init( pUnknown, strAppName );

} //*** CMMCSnapInModule::Init( pUnknown, idsAppName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMMCSnapInModule::GetProfileString
//
//  Routine Description:
//      Read a value from the profile.
//
//  Arguments:
//      lpszSection [IN] Name of subkey below HKEY_CURRENT_USER to read from.
//      lpszEntry   [IN] Name of value to read.
//      lpszDefault [IN] Default if no value found.
//
//  Return Value:
//      CString value.
//
//--
/////////////////////////////////////////////////////////////////////////////
CString CMMCSnapInModule::GetProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault // = NULL
    )
{
    CRegKey key;
    CString strKey;
    CString strValue;
    LPTSTR  pszValue;
    DWORD   dwCount;
    DWORD   dwStatus;

    _ASSERTE( m_pszAppName != NULL );

    //
    // Open the key.
    //
    strKey.Format( _T("Software\\%s\\%s"), m_pszAppName, lpszSection );
    dwStatus = key.Open( HKEY_CURRENT_USER, strKey, KEY_READ );
    if ( dwStatus != ERROR_SUCCESS )
    {
        return lpszDefault;
    } // if:  error opening the registry key

    //
    // Read the value.
    //
    dwCount = 256;
    pszValue = strValue.GetBuffer( dwCount );
    dwStatus = key.QueryValue( pszValue, lpszEntry, &dwCount );
    if ( dwStatus != ERROR_SUCCESS )
    {
        return lpszDefault;
    } // if:  error reading the value

    //
    // Return the buffer to the caller.
    //
    strValue.ReleaseBuffer();
    return strValue;

} //*** CMMCSnapInModule::GetProfileString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\compdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		CompData.h
//
//	Abstract:
//		Definition of the CClusterComponentData class.
//
//	Implementation File:
//		CompData.cpp
//
//	Author:
//		David Potter (davidp)	November 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterComponentData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseNodeObj;
class CServerAppsNodeData;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMP_H_
#include "Comp.h"			// for CClusterComponent
#endif

#ifndef __SERVERAPPSNODE_H_
#include "ServerAppsNode.h"	// for CServerAppsNodeData
#endif

/////////////////////////////////////////////////////////////////////////////
// class CClusterComponentData
/////////////////////////////////////////////////////////////////////////////

class CClusterComponentData :
	public CComObjectRootEx< CComSingleThreadModel >,
	public CSnapInObjectRoot,
	public IComponentDataImpl< CClusterComponentData, CClusterComponent >,
	public IExtendContextMenuImpl< CClusterComponentData >,
	public ISnapinHelp,
	public CComCoClass< CClusterComponentData, &CLSID_ClusterAdmin >
{
public:
	//
	// Object construction and destruction.
	//

	CClusterComponentData( void );
	~CClusterComponentData( void );

	//
	// Map interfaces to this class.
	//
	BEGIN_COM_MAP( CClusterComponentData )
		COM_INTERFACE_ENTRY( IComponentData )
		COM_INTERFACE_ENTRY( IExtendContextMenu )
		COM_INTERFACE_ENTRY( ISnapinHelp )
	END_COM_MAP()

	static HRESULT WINAPI UpdateRegistry( BOOL bRegister );

	//
	// If this is an extension, map the node type.
	//
	EXTENSION_SNAPIN_DATACLASS( CServerAppsNodeData )

	BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP( CClusterComponentData )
		EXTENSION_SNAPIN_NODEINFO_ENTRY( CServerAppsNodeData )
	END_EXTENSION_SNAPIN_NODEINFO_MAP()

	DECLARE_NOT_AGGREGATABLE( CClusterComponentData )

public:
	//
	// IComponentData methods.
	//

	// Initialize this object
	STDMETHOD( Initialize )( LPUNKNOWN pUnknown );

	// Object is being destroyed
	STDMETHOD( Destroy )( void );

public:
	//
	// IComponentDatImpl methods.
	//

	// Handle notification messages from MMC
	STDMETHOD( Notify )( 
		LPDATAOBJECT lpDataObject,
		MMC_NOTIFY_TYPE event,
		long arg,
		long param
		);

public:
	//
	// ISnapinHelp methods.
	//

	// Merge our help file into the MMC help file
	STDMETHOD( GetHelpTopic )( OUT LPOLESTR * lpCompiledHelpFile );

public:
	//
	// CClusterComponentData-specific methods.
	//

	// Returns a handle to the main frame window
	HWND GetMainWindow( void )
	{
		_ASSERTE( m_spConsole != NULL );

		HWND hwnd;
		HRESULT hr;
		hr = m_spConsole->GetMainWindow( &hwnd );
		_ASSERTE( SUCCEEDED( hr ) );
		return hwnd;
	}

	// Display a message box as a child of the console
	int MessageBox(
		LPCWSTR lpszText,
		LPCWSTR lpszTitle = NULL,
		UINT fuStyle = MB_OK
		)
	{
		_ASSERTE( m_spConsole != NULL );
		_ASSERTE( lpszText != NULL );

		int iRetVal;
		HRESULT hr;

		if ( lpszTitle == NULL )
			lpszTitle = _Module.GetAppName();

		hr = m_spConsole->MessageBox(
				lpszText,
				lpszTitle,
				fuStyle,
				&iRetVal
				);
		_ASSERTE( SUCCEEDED( hr ) );

		return iRetVal;
	}

protected:
	// Extract data from a data object
	HRESULT ExtractFromDataObject(
		LPDATAOBJECT	pDataObject,
		CLIPFORMAT		cf,
		DWORD			cb,
		HGLOBAL *		phGlobal
		);

	// Save the machine name from the data object
	HRESULT HrSaveMachineNameFromDataObject( LPDATAOBJECT lpDataObject );

	// Set the machine name being managed
	void SetMachineName( LPCWSTR pwszMachineName );

	// Create the root node object
	HRESULT CreateNode(
				LPDATAOBJECT lpDataObject,
				long arg,
				long param
				);

	// Display context-sensitive help
	HRESULT HrDisplayContextHelp( void );

protected:
	//
	// Clipboard formats we will be using.
	//
	static CLIPFORMAT	s_CCF_MACHINE_NAME;

	//
	// Name of machine being managed.
	//
	WCHAR m_wszMachineName[ MAX_PATH ];

public:
	LPCWSTR PwszMachineName( void ) const { return m_wszMachineName; }

	CComQIPtr< IConsoleNameSpace, &IID_IConsoleNameSpace > m_spConsoleNameSpace;

}; // class CClusterComponentData

/////////////////////////////////////////////////////////////////////////////

#endif // __COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\rootnode.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      RootNode.cpp
//
//  Abstract:
//      Implementation of the CRootNodeData and CRootNodeDataPage classes.
//
//  Author:
//      David Potter (davidp)   November 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RootNode.h"
#include <StrSafe.h>

/////////////////////////////////////////////////////////////////////////////
// class CRootNodeData
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// static variables

static const GUID g_CClusterAdminGUID_NODETYPE =
    { 0x12e7ed20, 0x5540, 0x11d1, { 0x9a, 0xa4, 0x0, 0xc0, 0x4f, 0xb9, 0x3a, 0x80 } };

const GUID *    CRootNodeData::s_pguidNODETYPE = &g_CClusterAdminGUID_NODETYPE;
LPCWSTR         CRootNodeData::s_pszNODETYPEGUID = _T("12E7ED20-5540-11D1-9AA4-00C04FB93A80");
WCHAR           CRootNodeData::s_szDISPLAY_NAME[256] = { 0 };
const CLSID *   CRootNodeData::s_pclsidSNAPIN_CLASSID = &CLSID_ClusterAdmin;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::CRootNodeData
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pComponentData  Pointer to component data object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRootNodeData::CRootNodeData( CClusterComponentData * pcd )
    : CBaseNodeObjImpl< CRootNodeData >( pcd )
{
    //
    // Initialize the scope data item.
    //
    memset( &m_scopeDataItem, 0, sizeof(SCOPEDATAITEM) );
    m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
    m_scopeDataItem.displayname = MMC_CALLBACK;
    m_scopeDataItem.nImage = IMGLI_CLUSTER;
    m_scopeDataItem.nOpenImage = IMGLI_CLUSTER;
    m_scopeDataItem.lParam = (LPARAM) this;

    //
    // Initialize the result data item.
    //
    memset( &m_resultDataItem, 0, sizeof(RESULTDATAITEM) );
    m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    m_resultDataItem.str = MMC_CALLBACK;
    m_resultDataItem.nImage = IMGLI_CLUSTER;
    m_resultDataItem.lParam = (LPARAM) this;

} //*** CRootNodeData::CRootNodeData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::~CRootNodeData
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRootNodeData::~CRootNodeData( void )
{
} //*** CRootNodeData::CRootNodeData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::CreatePropertyPages [IExtendPropertySheet]
//
//  Routine Description:
//      Called to create property pages for the MMC node and add them to
//      the sheet.
//
//  Arguments:
//      lpProvider  [IN] Pointer to the IPropertySheetCallback interface.
//      handle      [IN] Specifies the handle used to route the
//                      MMCN_PROPERTY_CHANGE notification message to the
//                      appropriate IComponent or IComponentData.
//      pUnk        [IN] Pointer to the IDataObject interface on the object
//                      that contains context information about the node.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CRootNodeData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    long handle,
    IUnknown * pUnk
    )
{
    HRESULT hr = S_OK;
    CRootNodeDataPage * pPage = new CRootNodeDataPage( _T("ClusterAdmin") );

    UNREFERENCED_PARAMETER( handle );
    UNREFERENCED_PARAMETER( pUnk );

    if ( pPage == NULL )
    {
        hr = E_OUTOFMEMORY;
    } // if: error allocating memory
    else
    {
        lpProvider->AddPage( pPage->Create() );
    } // else: memory allocated successfully

    return hr;

} //*** CRootNodeData::CreatePropertyPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::GetDisplayName [CSnapInDataInterface]
//
//  Routine Description:
//      Returns the display name of this node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Pointer to Unicode string containing the display name.
//
//--
/////////////////////////////////////////////////////////////////////////////
void * CRootNodeData::GetDisplayName( void )
{
    // If the display name hasn't been read from the
    if ( s_szDISPLAY_NAME[0] == L'\0' )
    {
        CString strDisplayName;
        HRESULT hr = S_OK;

        strDisplayName.LoadString( IDS_NODETYPE_STATIC_NODE );
        hr = StringCchCopyW(s_szDISPLAY_NAME, RTL_NUMBER_OF( s_szDISPLAY_NAME ), strDisplayName);
        _ASSERTE( hr == S_OK );
    } // if:  display name hasn't been loaded yet

    return (void *) s_szDISPLAY_NAME;

} //*** CRootNodeData::GetDisplayName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::Notify [ISnapInDataInterface]
//
//  Routine Description:
//      Notifies the snap-in of actions taken by the user.  Handles
//      notifications sent through both IComponent and IComponentData.
//
//  Arguments:
//      event           [IN] Identifies the action taken by the user.
//      arg             Depends on the notification type.
//      param           Depends on the notification type.
//      pComponentData  Pointer to the IComponentData interface if this
//                          was invoked through that interface.
//      pComponent      Pointer to the IComponent interface if this was
//                          invoked through that interface.
//      type            Type of object.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
//#if 0
STDMETHODIMP CRootNodeData::Notify(
    MMC_NOTIFY_TYPE     event,
    LPARAM              arg,
    LPARAM              param,
    IComponentData *    pComponentData,
    IComponent *        pComponent,
    DATA_OBJECT_TYPES   type
    )
{
    HRESULT hr = S_OK;

    if ( pComponentData != NULL )
        ATLTRACE( _T("IComponentData::Notify(%d, %d, %d, %d)"), event, arg, param, type );
    else
        ATLTRACE( _T("IComponent::Notify(%d, %d, %d, %d)"), event, arg, param, type );

    switch ( event )
    {
        case MMCN_ACTIVATE:
            ATLTRACE( _T(" - MMCN_ACTIVATE\n") );
            break;
        case MMCN_ADD_IMAGES:
            ATLTRACE( _T(" - MMCN_ADD_IMAGES\n") );
            hr = OnAddImages( (IImageList *) arg, (HSCOPEITEM) param, pComponentData, pComponent, type );
            break;
        case MMCN_BTN_CLICK:
            ATLTRACE( _T(" - MMCN_BTN_CLICK\n") );
            break;
        case MMCN_CLICK:
            ATLTRACE( _T(" - MMCN_CLICK\n") );
            break;
        case MMCN_CONTEXTHELP:
            hr = HrDisplayContextHelp();
            break;
        case MMCN_DBLCLICK:
            ATLTRACE( _T(" - MMCN_DBLCLICK\n") );
            break;
        case MMCN_DELETE:
            ATLTRACE( _T(" - MMCN_DELETE\n") );
            break;
        case MMCN_EXPAND:
            ATLTRACE( _T(" - MMCN_EXPAND\n") );
            hr = OnExpand( (BOOL) arg, (HSCOPEITEM) param, pComponentData, pComponent, type );
            break;
        case MMCN_MINIMIZED:
            ATLTRACE( _T(" - MMCN_MINIMIZED\n") );
            break;
        case MMCN_PROPERTY_CHANGE:
            ATLTRACE( _T(" - MMCN_PROPERTY_CHANGE\n") );
            break;
        case MMCN_REMOVE_CHILDREN:
            ATLTRACE( _T(" - MMCN_REMOVE_CHILDREN\n") );
            break;
        case MMCN_RENAME:
            ATLTRACE( _T(" - MMCN_RENAME\n") );
            break;
        case MMCN_SELECT:
            ATLTRACE( _T(" - MMCN_SELECT\n") );
            break;
        case MMCN_SHOW:
            ATLTRACE( _T(" - MMCN_SHOW\n") );
            break;
        case MMCN_VIEW_CHANGE:
            ATLTRACE( _T(" - MMCN_VIEW_CHANGE\n") );
            break;
        default:
            ATLTRACE( _T(" - *** UNKNOWN event ***\n") );
            break;
    } // switch:  event

    return hr;

} //*** CRootNodeData::Notify()
//#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::OnAddImages
//
//  Routine Description:
//      Adds images to the result pane image list.
//
//  Arguments:
//      pImageList      Pointer to the result pane's image list (IImageList).
//      hsi             Specifies the HSCOPEITEM of the item that was
//                          selected or deselected.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRootNodeData::OnAddImages(
    IImageList *        pImageList,
    HSCOPEITEM          hsi,
    IComponentData *    pComponentData,
    IComponent *        pComponent,
    DATA_OBJECT_TYPES   type
    )
{
    _ASSERTE( pImageList != NULL );

    CBitmap     bm16;
    CBitmap     bm32;
    COLORREF    crMaskColor = RGB( 255, 0, 255 );
    HRESULT     hr;

    UNREFERENCED_PARAMETER( hsi );
    UNREFERENCED_PARAMETER( pComponentData );
    UNREFERENCED_PARAMETER( pComponent );
    UNREFERENCED_PARAMETER( type );

    //
    // Add an image for the cluster object.
    //

    bm16.LoadBitmap( IDB_CLUSTER_16 );
    if ( bm16.m_hBitmap != NULL )
    {
        bm32.LoadBitmap( IDB_CLUSTER_32 );
        if ( bm32.m_hBitmap != NULL )
        {
            hr = pImageList->ImageListSetStrip(
                (LONG_PTR *) bm16.m_hBitmap,
                (LONG_PTR *) bm32.m_hBitmap,
                IMGLI_CLUSTER,
                crMaskColor
                );
            if ( FAILED( hr ) )
            {
                ATLTRACE( _T("CRootNodeData::OnAddImages() - IImageList::ImageListSetStrip failed with %08.8x\n"), hr );
            } // if:  error setting bitmaps into image list
        } // if:  32x32 bitmap loaded successfully
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        } // else:  error loading 32x32 bitmap
    } // if:  16x16 bitmap loaded successfully
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    } // else:  error loading 32x32 bitmap

    return hr;

} //*** CRootNodeData::OnAddImages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::OnExpand
//
//  Routine Description:
//      Node is expanding or contracting.
//
//  Arguments:
//      pImageList      Pointer to the result pane's image list (IImageList).
//      hsi             Specifies the HSCOPEITEM of the item that was
//                          selected or deselected.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRootNodeData::OnExpand(
    BOOL                bExpanding,
    HSCOPEITEM          hsi,
    IComponentData *    pComponentData,
    IComponent *        pComponent,
    DATA_OBJECT_TYPES   type
    )
{
    UNREFERENCED_PARAMETER( bExpanding );
    UNREFERENCED_PARAMETER( pComponentData );
    UNREFERENCED_PARAMETER( pComponent );
    UNREFERENCED_PARAMETER( type );

    m_scopeDataItem.ID = hsi;
    return S_OK;

} //*** CRootNodeData::OnExpand()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::OnManageCluster
//
//  Routine Description:
//      Manage the cluster on this node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRootNodeData::OnManageCluster(
    bool &              bHandled,
    CSnapInObjectRoot * pObj
    )
{
    BOOL                bSuccessful;
    DWORD               dwStatus;
    HRESULT             hr = S_OK;
    CString             strCommandLine;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    LPCWSTR             pszMachineName = Pcd()->PwszMachineName();

    UNREFERENCED_PARAMETER( bHandled );
    UNREFERENCED_PARAMETER( pObj );

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    //
    // Find the Cluster Administrator executable.
    //
    dwStatus = ScFindCluAdmin( strCommandLine );
    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        CNTException nte( dwStatus, IDS_ERROR_FINDING_CLUADMIN );
        nte.ReportError( MB_OK | MB_ICONEXCLAMATION );
        return hr;
    } // if:  failed to find the executable

    //
    // Construct the command line.  If the machine name is blank, we are
    // on the local machine.  Specify a dot (.) in its place.
    //
    if ( *pszMachineName == L'\0' )
    {
        strCommandLine += _T(" .");
    } // if:  running on the cluster node
    else
    {
        strCommandLine += _T(" ");
        strCommandLine += pszMachineName;
    } // else:  not running on the cluster node

    //
    // Create a process for Cluster Administrator.
    //
    bSuccessful = CreateProcess(
                    NULL,                               // lpApplicationName
                    (LPTSTR)(LPCTSTR) strCommandLine,   // lpCommandLine
                    NULL,                               // lpProcessAttributes
                    NULL,                               // lpThreadAttributes
                    FALSE,                              // bInheritHandles
                    CREATE_DEFAULT_ERROR_MODE           // dwCreationFlags
                    | CREATE_UNICODE_ENVIRONMENT,
                    NULL,                               // lpEnvironment
                    NULL,                               // lpCurrentDirectory
                    &si,                                // lpStartupInfo
                    &pi                                 // lpProcessInfo
                    );
    if ( !bSuccessful )
    {
        dwStatus = GetLastError();
        hr = HRESULT_FROM_WIN32( dwStatus );
        CNTException nte( dwStatus, IDS_ERROR_LAUNCHING_CLUADMIN, strCommandLine );
        nte.ReportError( MB_OK | MB_ICONEXCLAMATION );
    } // if:  error invoking Cluster Administrator
    else
    {
        CloseHandle( pi.hProcess );
    } // else:  no error invoking Cluster Administrator

    return hr;

} //*** CRootNodeData::OnManageCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::ScFindCluAdmin
//
//  Routine Description:
//      Find the Cluster Administrator image.
//
//  Arguments:
//      rstrImage       [OUT] String in which to return the path.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRootNodeData::ScFindCluAdmin( CString & rstrImage )
{
    DWORD   dwStatus;
    CRegKey rk;
    TCHAR   szImage[MAX_PATH];
    DWORD   cbImage = sizeof(szImage);

    //
    // Open the App Paths registry key for CluAdmin.
    //
    dwStatus = rk.Open(
        HKEY_LOCAL_MACHINE,
        _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CluAdmin.exe"),
        KEY_READ
        );
    if ( dwStatus != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:  error opening the registry key

    //
    // Read the value.
    //
    dwStatus = rk.QueryValue( szImage, _T(""), &cbImage );
    if ( dwStatus != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:  error reading the value

    //
    // Expand any environment string that may be embedded in the value.
    //

    TCHAR tszExpandedRegValue[_MAX_PATH];


    dwStatus = ExpandEnvironmentStrings( szImage, tszExpandedRegValue, (DWORD) RTL_NUMBER_OF( tszExpandedRegValue ) );
    _ASSERTE( dwStatus != 0 );

    if ( dwStatus != 0L )
    {
        rstrImage = tszExpandedRegValue;

        dwStatus = 0L;
    }
    else
    {
        // Could not expand the environment string.

        rstrImage = szImage;

        dwStatus = GetLastError();
    }  // if: testing value returned by ExpandEnvironmentStrings

Cleanup:

    return dwStatus;

} //*** CRootNodeData::ScFindCluAdmin()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRootNodeData::HrDisplayContextHelp
//
//  Routine Description:
//      Display context-sensitive help.
//
//  Arguments:
//      pszHelpTopic    [OUT] Pointer to the address of the NULL-terminated
//                              UNICODE string that contains the full path of
//                              compiled help file (.chm) for the snap-in.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRootNodeData::HrDisplayContextHelp( void )
{
    HRESULT         hr = S_OK;
    IDisplayHelp *  pi = NULL;
    LPOLESTR        postr = NULL;
    size_t          cb = 0;

    //
    // Get the IDisplayHelp interface pointer.
    //
    hr = Pcd()->m_spConsole->QueryInterface(
            IID_IDisplayHelp,
            reinterpret_cast< void ** >( &pi )
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: error getting interface pointer

    //
    // Construct the help topic path.
    //
    cb = sizeof( FULL_HELP_TOPIC );
    postr = reinterpret_cast< LPOLESTR >( CoTaskMemAlloc( cb ) );
    if ( postr == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    } // if: error allocating memory
    hr = StringCbCopyW( postr, cb, FULL_HELP_TOPIC );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Show the topic.
    //
    hr = pi->ShowTopic( postr );
    if ( ! FAILED( hr ) )
    {
        postr = NULL;
    } // if: topic shown successfully

Cleanup:

    //
    // Cleanup before returning.
    //
    if ( postr != NULL )
    {
        CoTaskMemFree( postr );
    } // if: topic string not passed to MMC successfully
    if ( pi != NULL )
    {
        pi->Release();
    } // if:  valid interface pointer

    return hr;

} //*** CRootNodeData::HrDisplayContextHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\rootnode.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      RootNode.h
//
//  Abstract:
//      Definition of the CRootNodeData and CRootNodeDataPage classes.
//
//  Implementation File:
//      RootNode.cpp
//
//  Author:
//      David Potter (davidp)   November 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ROOTNODE_H_
#define __ROOTNODE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CRootNodeData;
class CRootNodeDataPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __BASEDATA_H_
#include "BaseData.h" // CBaseNodeObjImpl
#endif

/////////////////////////////////////////////////////////////////////////////
// class CRootNodeData
/////////////////////////////////////////////////////////////////////////////

class CRootNodeData : public CBaseNodeObjImpl< CRootNodeData >
{
    typedef CBaseNodeObjImpl< CRootNodeData > baseClass;

    static const GUID * s_pguidNODETYPE;
    static LPCWSTR s_pszNODETYPEGUID;
    static WCHAR s_szDISPLAY_NAME[];
    static const CLSID * s_pclsidSNAPIN_CLASSID;

public:
    static CComPtr< IControlbar > m_spControlBar;

public:
    //
    // Object construction and destruction.
    //

    CRootNodeData( CClusterComponentData * pcd );

    ~CRootNodeData( void );

public:
    //
    // Map menu and controlbar commands to this class.
    //
#pragma warning( push )
#pragma warning( disable : 4100 ) // 'type' : unreferenced formal parameter
    BEGIN_SNAPINCOMMAND_MAP( CRootNodeData, FALSE )
        SNAPINCOMMAND_ENTRY( ID_MANAGE_CLUSTER, OnManageCluster )
    END_SNAPINCOMMAND_MAP()
#pragma warning( pop )

    //
    // Map a menu to this node type.
    //
    SNAPINMENUID( IDR_CLUSTERADMIN_MENU )

    //
    // Map event notifications to this class.
    //
#if 0
    BEGIN_SNAPINDATANOTIFY_MAP( CRootNodeData, FALSE )
        SNAPINDATANOTIFY_ADD_IMAGES( OnAddImages )
        SNAPINDATANOTIFY_EXPAND( OnExpand )
    END_SNAPINDATANOTIFY_MAP()
#endif

public:
    //
    // CBaseNodeObjImpl methods.
    //

    // Get column info for the result pane
    virtual LPOLESTR GetResultPaneColInfo( int nCol )
    {
        USES_CONVERSION;

        OLECHAR     olesz[ 256 ];
        LPOLESTR    polesz;
        CString     str;

        switch ( nCol )
        {
            case 1:
                str.LoadString( IDS_CLUSTERADMIN_SNAPIN_TYPE );
                ocscpy( T2OLE( olesz ), str );
                polesz = olesz;
                break;

            case 2:
                str.LoadString( IDS_CLUSTERADMIN_DESC );
                ocscpy( T2OLE( olesz ), str );
                polesz = olesz;
                break;

            default:
                polesz = baseClass::GetResultPaneColInfo( nCol );
                break;

        } // switch:  nCol

        return polesz;

    } //*** GetResultPaneColInfo()


public:
    //
    // ISnapInDataInterface methods
    //

    // Notifies the snap-in of actions taken by the user
    STDMETHOD( Notify )(
        MMC_NOTIFY_TYPE     event,
        LPARAM              arg,
        LPARAM              param,
        IComponentData *    pComponentData,
        IComponent *        pComponent,
        DATA_OBJECT_TYPES   type
        );

public:
    //
    // Notification handlers.
    //

    // Adds images to the result pane image list
    HRESULT OnAddImages(
        IImageList *        pImageList,
        HSCOPEITEM          hsi,
        IComponentData *    pComponentData,
        IComponent *        pComponent,
        DATA_OBJECT_TYPES   type
        );

    // Node is expanding or contracting
    HRESULT OnExpand(
        BOOL                bExpanding,
        HSCOPEITEM          hsi,
        IComponentData *    pComponentData,
        IComponent *        pComponent,
        DATA_OBJECT_TYPES   type
        );

public:
    //
    // Command handlers.
    //

    // Manage the cluster on this node
    HRESULT OnManageCluster( bool & bHandled, CSnapInObjectRoot * pObj );

protected:
    // Find the Cluster Administrator executable image
    DWORD ScFindCluAdmin( CString & rstrImage );

    // Display context-sensitive help
    HRESULT HrDisplayContextHelp( void );

public:
    //
    // IExtendPropertySheet methods.
    //

    // Adds pages to the property sheet
    STDMETHOD( CreatePropertyPages )(
        LPPROPERTYSHEETCALLBACK lpProvider,
        long handle,
        IUnknown * pUnk
        );

    // Determines whether the object requires pages
    STDMETHOD( QueryPagesFor )( void )
    {
        return S_FALSE;
    }

public:
    //
    // CSnapInDataInterface required methods
    //

    // Returns the node type GUID
    void * GetNodeType( void )
    {
        return (void *) s_pguidNODETYPE;
    }

    // Returns the stringized node type GUID
    void * GetSZNodeType( void )
    {
        return (void *) s_pszNODETYPEGUID;
    }

    // Returns the display name for this node type
    void * GetDisplayName( void );

    // Returns the display name for this node type as a string
    STDMETHOD_( LPWSTR, PszGetDisplayName )( void )
    {
        return (LPWSTR) GetDisplayName();
    }

    // Returns the CLSID for the snapin handling the node type
    void * GetSnapInCLSID( void )
    {
        return (void *) s_pclsidSNAPIN_CLASSID;
    }

}; // class CRootNodeData

/////////////////////////////////////////////////////////////////////////////
// class CRootNodeDataPage
/////////////////////////////////////////////////////////////////////////////

class CRootNodeDataPage : public CSnapInPropertyPageImpl< CRootNodeDataPage >
{
public :
    CRootNodeDataPage( TCHAR * pTitle = NULL )
        : CSnapInPropertyPageImpl< CRootNodeDataPage >( pTitle )
    {
    }

    enum { IDD = IDD_CLUSTERADMIN };

    //
    // Map Windows messages to class methods.
    //
    BEGIN_MSG_MAP( CRootNodeDataPage )
        MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
        CHAIN_MSG_MAP( CSnapInPropertyPageImpl< CRootNodeDataPage > )
    END_MSG_MAP()

    LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled )
    {
        UNREFERENCED_PARAMETER( uMsg );
        UNREFERENCED_PARAMETER( wParam );
        UNREFERENCED_PARAMETER( lParam );
        UNREFERENCED_PARAMETER( bHandled );
        ::SendMessage( GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH );
        return 1;
    }

}; // class CRootNodeDataPage

/////////////////////////////////////////////////////////////////////////////

#endif // __ROOTNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#pragma warning( push )
#pragma warning( disable: 4100 ) // unreferenced formal parameter
#pragma warning( disable: 4189 ) // local variable is initialize but not referenced
#pragma warning( disable: 4505 ) // unreferenced local function has been removed
#include <statreg.h>
#include <statreg.cpp>
#pragma warning( pop )
#endif

#pragma warning( push )
#pragma warning( disable: 4127 ) // conditional expression is constant
#include <atlimpl.cpp>
#include <atlwin21.cpp>
#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\snapabout.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      SnapAbout.h
//
//  Abstract:
//      Definition of the CClusterAdminAbout class.
//
//  Implementation File:
//      SnapAbout.cpp
//
//  Author:
//      David Potter (davidp)   November 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __SNAPABOUT_H_
#define __SNAPABOUT_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAdminAbout;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMPDATA_H_
#include "CompData.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// class CClusterAdminAbout
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CClusterAdminAbout :
    public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass< CClusterAdminAbout, &CLSID_ClusterAdminAbout >
{
private:
    HBITMAP     m_hSmallImage;
    HBITMAP     m_hSmallImageOpen;
    HBITMAP     m_hLargeImage;

public:
    CClusterAdminAbout( void )
        : m_hSmallImage( NULL )
        , m_hSmallImageOpen( NULL )
        , m_hLargeImage( NULL )
    {
    } //*** CClusterAdminAbout::CClusterAdminAbout()

    ~CClusterAdminAbout( void );

    DECLARE_REGISTRY(
        CClusterAdminAbout,
        _T("ClusterAdminAbout.1"),
        _T("ClusterAdminAbout"),
        IDS_CLUSTERADMIN_DESC,
        THREADFLAGS_BOTH
        );

    //
    // Map interfaces to this class.
    //
    BEGIN_COM_MAP(CClusterAdminAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    //
    // ISnapinAbout methods
    //

    STDMETHOD(GetSnapinDescription)(LPOLESTR * lpDescription)
    {
        WCHAR   szBuf[256];
        HRESULT hr = S_OK;
        size_t  cb = 0;

        if (::LoadString(_Module.GetResourceInstance(), IDS_CLUSTERADMIN_DESC, szBuf, 256) == 0)
            return E_FAIL;

        cb = (wcslen(szBuf) + 1) * sizeof(OLECHAR);

        *lpDescription = (LPOLESTR)CoTaskMemAlloc(cb);
        if (*lpDescription == NULL)
            return E_OUTOFMEMORY;

        hr = StringCbCopy(*lpDescription, cb, szBuf);
        if ( FAILED( hr ) )
            return hr;

        return S_OK;
    }

    STDMETHOD(GetProvider)(LPOLESTR * lpName)
    {
        WCHAR szBuf[256];
        HRESULT hr = S_OK;
        size_t  cb = 0;

        if (::LoadString(_Module.GetResourceInstance(), IDS_CLUSTERADMIN_PROVIDER, szBuf, 256) == 0)
            return E_FAIL;

        cb = (wcslen(szBuf ) + 1) * sizeof(WCHAR);
        *lpName = (LPOLESTR)CoTaskMemAlloc(cb);
        if (*lpName == NULL)
            return E_OUTOFMEMORY;

        hr = StringCbCopy(*lpName, cb, szBuf);
        if (FAILED(hr))
            return hr;;

        return S_OK;
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR * lpVersion)
    {
        WCHAR szBuf[256];
        HRESULT hr = S_OK;
        size_t  cb = 0;

        if (::LoadString(_Module.GetResourceInstance(), IDS_CLUSTERADMIN_VERSION, szBuf, 256) == 0)
            return E_FAIL;

        cb = (wcslen(szBuf) + 1) * sizeof(WCHAR);
        *lpVersion = (LPOLESTR)CoTaskMemAlloc(cb);
        if (*lpVersion == NULL)
            return E_OUTOFMEMORY;

        hr = StringCbCopy(*lpVersion, cb, szBuf);
        if (FAILED(hr))
            return hr;;

        return S_OK;
    }

    STDMETHOD(GetSnapinImage)(HICON * hAppIcon)
    {
        *hAppIcon = NULL;
        return S_OK;
    }

    STDMETHOD(GetStaticFolderImage)(
          HBITMAP *     phSmallImage
        , HBITMAP *     phSmallImageOpen
        , HBITMAP *     phLargeImage
        , COLORREF *    pcMask
        );

}; // class CClusterAdminAbout

/////////////////////////////////////////////////////////////////////////////

#endif // __SNAPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(__STDAFX_H_)
#define __STDAFX_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#pragma warning( disable : 4505 ) // unreferenced local function has been removed

//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


// This is required due to how ATLSNAP is implemented.
#pragma warning( push )
#pragma warning( disable : 4127 ) // conditional expression is constant
#pragma warning( disable : 4505 ) // unreferenced local function has been removed

// Enable some warnings.
#pragma warning( error : 4706 )  // assignment within conditional expression

#if defined(_DEBUG)
#define THIS_FILE __FILE__
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#define _CRTDBG_MAP_ALLOC
#endif // defined(_DEBUG)

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
#include "MMCApp.h"
extern CMMCSnapInModule _Module;

//#define _ATL_DEBUG_QI

#include <atlcom.h>

// atlwin.h needs this for the definition of DragAcceptFiles
#include <shellapi.h>

// atlwin.h needs this for the definition of psh1
#ifndef _DLGSH_INCLUDED_
#include <dlgs.h>
#endif

#if (_ATL_VER < 0x0300)
#include <atlwin21.h>
#endif //(_ATL_VER < 0x0300)

#pragma warning( push )
#pragma warning( disable : 4267 ) // conversion from 'size_t' to 'int', possible data loss
#include <atltmp.h>
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4100 ) // unreferenced formal parameter
#include <atlctrls.h>
#pragma warning( pop )

#include <atlgdi.h>
#include <atlapp.h>
#pragma warning( pop )

/////////////////////////////////////////////////////////////////////////////
// ATL Snap-In Classes
/////////////////////////////////////////////////////////////////////////////

#pragma warning( push )
#pragma warning( disable : 4127 ) // conditional expression is constant
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
#include <atlsnap.h>
#pragma warning( pop )

/////////////////////////////////////////////////////////////////////////////

#include <clusapi.h>

#ifndef ASSERT
#define ASSERT _ASSERTE
#endif

#include "WaitCrsr.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "MMCApp.inl"
#include "CluAdMMC.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(__STDAFX_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\tracetag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      TraceTag.cpp
//
//  Abstract:
//      Implementation of the CTraceTag class.
//
//  Author:
//      David Potter (davidp)   May 28, 1996
//
//  Revision History:
//
//  Notes:
//
//      TRACE_GetApp() must be defined to return a pointer to an object
//      that defines the GetProfileString() method.
//
//      TRACE_AppMessageBox must be defined and implemented.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <winnls.h>
#include "TraceTag.h"
#include "ExcOper.h"
#include <StrSafe.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef  _DEBUG

#ifndef CP_ANSI
#define CP_ANSI 1252
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CTraceTag   g_tagAlways(_T("Debug"), _T("Always"), CTraceTag::tfDebug);
CTraceTag   g_tagError(_T("Debug"), _T("Error"), CTraceTag::tfDebug);

// g_pszTraceIniFile must be an LPTSTR so it exists before "{" of WinMain.
// If we make it a CString, it may not be constructed when some of the
// tags are constructed, so we won't restore their value.
//LPTSTR        g_pszTraceIniFile       = _T("Trace.INI");
CString     g_strTraceFile;
BOOL        g_bBarfDebug            = TRUE;

CRITICAL_SECTION    CTraceTag::s_critsec;
BOOL                CTraceTag::s_bCritSecValid = FALSE;

#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTraceTag
/////////////////////////////////////////////////////////////////////////////

#ifdef  _DEBUG

//  Static Variables...

CTraceTag *     CTraceTag::s_ptagFirst  = NULL;
CTraceTag *     CTraceTag::s_ptagLast   = NULL;
//HANDLE            CTraceTag::s_hfileCom2  = NULL;
LPCTSTR         CTraceTag::s_pszCom2    = _T(" com2 ");
LPCTSTR         CTraceTag::s_pszFile    = _T(" file ");
LPCTSTR         CTraceTag::s_pszDebug   = _T(" debug ");
LPCTSTR         CTraceTag::s_pszBreak   = _T(" break ");

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::CTraceTag
//
//  Routine Description:
//      Constructor.  "Initializes" the tag by giving it its name, giving
//      it a startup value (from the registry if possible), and adding it
//      to the list of current tags.
//
//  Arguments:
//      pszSubsystem    [IN] 8 char string to say to what the tag applies
//      pszName         [IN] Description of the tag (~30 chars)
//      uiFlagsDefault  [IN] Default value.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::CTraceTag(
    IN LPCTSTR  pszSubsystem,
    IN LPCTSTR  pszName,
    IN UINT     uiFlagsDefault
    )
{
    //  Store the calling parameters
    m_pszSubsystem = pszSubsystem;
    m_pszName = pszName;
    m_uiFlagsDefault = uiFlagsDefault;
    m_uiFlags = uiFlagsDefault;

    //  Add the tag to the list of tags
    if (s_ptagLast != NULL)
        s_ptagLast->m_ptagNext = this;
    else
        s_ptagFirst = this;

    s_ptagLast = this;
    m_ptagNext = NULL;

    m_uiFlags = 0;

} //*** CTraceTag::CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::~CTraceTag
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::~CTraceTag(void)
{
#ifdef NEVER
    if (s_hfileCom2 && (s_hfileCom2 != INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(s_hfileCom2);
        s_hfileCom2 = NULL;
    }
#endif

} //*** CTraceTag::~CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::Init
//
//  Routine Description:
//      Initializes the tag by giving it its name and giving it a startup value
//      (from the registry if possible).
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::Init(void)
{
    CString     strSection;
    CString     strValue;

    //  Get the value from the Registry.
    strSection.Format(TRACE_TAG_REG_SECTION_FMT, m_pszSubsystem);
    strValue = TRACE_GetApp()->GetProfileString(strSection, m_pszName);
    strValue.MakeLower();
    if (strValue.Find(s_pszCom2) != -1)
        m_uiFlags |= tfCom2;
    if (strValue.Find(s_pszFile) != -1)
        m_uiFlags |= tfFile;
    if (strValue.Find(s_pszDebug) != -1)
        m_uiFlags |= tfDebug;
    if (strValue.Find(s_pszBreak) != -1)
        m_uiFlags |= tfBreak;

} //*** CTraceTag::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::ConstructRegState
//
//  Routine Description:
//      Constructs the registry state string.
//
//  Arguments:
//      rstr        [OUT] String in which to return the state string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::ConstructRegState(OUT CString & rstr)
{
    rstr = _T("");
    if (BDebug())
        rstr += s_pszDebug;
    if (BBreak())
        rstr += s_pszBreak;
    if (BCom2())
        rstr += s_pszCom2;
    if (BFile())
        rstr += s_pszFile;

} //*** CTraceTag::ConstructRegState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::SetFlags
//
//  Routine Description:
//      Sets/Resets TraceFlags.
//
//  Arguments:
//      tf          [IN] Flags to set.
//      bEnable     [IN] TRUE = set the flags, FALSE = clear the flags.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlags(IN UINT tf, IN BOOL bEnable)
{
    if (bEnable)
        m_uiFlags |= tf;
    else
        m_uiFlags &= ~tf;

} //*** CTraceTag::SetFlags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::SetFlagsDialog
//
//  Routine Description:
//      Sets/Resets the "Dialog Settings"  version of the TraceFlags.
//
//  Arguments:
//      tf          [IN] Flags to set.
//      bEnable     [IN] TRUE = set the flags, FALSE = clear the flags.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlagsDialog(IN UINT tf, IN BOOL bEnable)
{
    if (bEnable)
        m_uiFlagsDialog |= tf;
    else
        m_uiFlagsDialog &= ~tf;

} //*** CTraceTag::SetFlagsDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::PszFile
//
//  Routine Description:
//      Returns the name of the file where to write the trace output.
//      The filename is read from the registry if it is unknown.
//
//  Arguments:
//      None.
//
//  Return Value:
//      psz     Name of the file.
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CTraceTag::PszFile(void)
{
    static  BOOL    bInitialized    = FALSE;

    if (!bInitialized)
    {
        g_strTraceFile = TRACE_GetApp()->GetProfileString(
                                        TRACE_TAG_REG_SECTION,
                                        TRACE_TAG_REG_FILE,
                                        _T("C:\\Trace.out")
                                        );
        bInitialized = TRUE;
    }

    return g_strTraceFile;

} //*** CTraceTag::PszFile()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::TraceV
//
//  Routine Description:
//      Processes a Trace statement based on the flags of the tag.
//
//  Arguments:
//      pszFormat   [IN] printf-style format string.
//      va_list     [IN] Argument block for the format string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::TraceV(IN LPCTSTR pszFormat, va_list marker)
{
    CString     strTraceMsg;
    LPSTR       psz;
    int         cb;
    int         cbActual;

    // Get out quick with any formats if we're not turned on
    if (!m_pszName || !BAny())
        return;

    if (BCritSecValid())
        EnterCriticalSection(&s_critsec);

    FormatV(pszFormat, marker);
    strTraceMsg.Format(_T("%s: %s\x0D\x0A"), m_pszName, m_pchData);

    // Send trace output to the debug window.
    if (BDebug())
        OutputDebugString(strTraceMsg);

    if (BCom2() || BFile())
    {
#ifdef _UNICODE
        // Not much point in sending UNICODE output to COMM or file at the moment,
        // so convert to ANSI
        CHAR    aszTraceMsg[256];
        cb = ::WideCharToMultiByte(
                    CP_ANSI,
                    NULL,
                    strTraceMsg,
                    strTraceMsg.GetLength(),
                    aszTraceMsg,
                    sizeof(aszTraceMsg),
                    NULL,
                    NULL
                    );
        psz = aszTraceMsg;
#else
        cb = strTraceMsg.GetLength();
        psz = (LPSTR) (LPCSTR) strTraceMsg;
#endif

        // Send trace output to COM2.
        if (BCom2())
        {
            HANDLE          hfile           = INVALID_HANDLE_VALUE;
            static  BOOL    bOpenFailed     = FALSE;

            if (!bOpenFailed)
            {
                hfile = ::CreateFile(
                                _T("COM2:"),
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_WRITE_THROUGH,
                                NULL
                                );
            } // if:  not currently in a 'COM2 failed to open' state

            if (hfile != INVALID_HANDLE_VALUE)
            {
                _ASSERTE(::WriteFile(hfile, psz, cb, (LPDWORD) &cbActual, NULL));
//              _ASSERTE(::FlushFileBuffers(hfile));
                _ASSERTE(::CloseHandle(hfile));
            } // if:  COM2 opened successfully
            else
            {
                if (!bOpenFailed)
                {
                    bOpenFailed = TRUE;     // Do this first, so the str.Format
                                            // do not cause problems with their trace statement.

                    TRACE_AppMessageBox(_T("COM2 could not be opened."), MB_OK | MB_ICONINFORMATION);
                } // if:  open file didn't fail
            } // else:  file not opened successfully
        } // if:  sending trace output to COM2

        // Send trace output to a file.
        if (BFile())
        {
            HANDLE          hfile           = INVALID_HANDLE_VALUE;
            static  BOOL    bOpenFailed     = FALSE;

            if (!bOpenFailed)
            {
                hfile = ::CreateFile(
                                PszFile(),
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_FLAG_WRITE_THROUGH,
                                NULL
                                );
            } // if:  not currently in a 'file failed to open' state

            if (hfile != INVALID_HANDLE_VALUE)
            {
                // Fail these calls silently to avoid recursive failing calls.
                ::SetFilePointer(hfile, NULL, NULL, FILE_END);
                ::WriteFile(hfile, psz, cb, (LPDWORD) &cbActual, NULL);
                ::CloseHandle(hfile);
            } // if:  file opened successfully
            else
            {
                if (!bOpenFailed)
                {
                    CString     strMsg;

                    bOpenFailed = TRUE;     // Do this first, so the str.Format
                                            // do not cause problems with their trace statement.

                    strMsg.Format(_T("The DEBUG ONLY trace log file '%s' could not be opened"), PszFile());
                    TRACE_AppMessageBox(strMsg, MB_OK | MB_ICONINFORMATION);
                } // if:  open file didn't fail
            } // else:  file not opened successfully
        } // if:  sending trace output to a file
    } // if:  tracing to com and/or file

    // Do a DebugBreak on the trace.
    if (BBreak())
        DebugBreak();

    if (BCritSecValid())
        LeaveCriticalSection(&s_critsec);

} //*** CTraceTag::TraceFn()

#endif // _DEBUG


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#ifdef  _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  Trace
//
//  Routine Description:
//      Maps the Trace statement to the proper method call.  This is needed
//      (instead of doing directly ptag->Trace()) to guarantee that no code
//      is added in the retail build.
//
//  Arguments:
//      rtag        [IN OUT] Tag controlling the debug output
//      pszFormat   [IN] printf style formatting string.
//      ...         [IN] printf style parameters, depends on pszFormat
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void Trace(IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ...)
{
    va_list     marker;

    va_start(marker, pszFormat);
    rtag.TraceV(pszFormat, marker);
    va_end(marker);

} //*** Trace()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceError
//
//  Routine Description:
//      Formats a standard error string and outputs it to all trace outputs.
//
//  Arguments:
//      rexcept     [IN OUT] Exception from which to obtain the message.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError(IN OUT CException & rexcept)
{
    TCHAR           szMessage[1024];

    rexcept.GetErrorMessage(szMessage, sizeof(szMessage) / sizeof(TCHAR));

    Trace(
        g_tagError,
        _T("EXCEPTION: %s"),
        szMessage
        );

} //*** TraceError(CException&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceError
//
//  Routine Description:
//      Formats a standard error string and outputs it to all trace outputs.
//
//  Arguments:
//      pszModule   [IN] Name of module in which error occurred.
//      sc          [IN] NT status code.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError(IN LPCTSTR pszModule, IN SC sc)
{
    TCHAR           szMessage[1024];
    CNTException    nte(sc);

    nte.GetErrorMessage(szMessage, sizeof(szMessage) / sizeof(TCHAR));

    Trace(
        g_tagError,
        _T("Module %s, SC = %#08lX = %d (10)\r\n = '%s'"),
        pszModule,
        sc,
        sc,
        szMessage
        );

} //*** TraceError(pszModule, sc)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  InitAllTraceTags
//
//  Routine Description:
//      Initializes all trace tags in the tag list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void InitAllTraceTags(void)
{
    CTraceTag * ptag;

    // Loop through the tag list.
    for (ptag = CTraceTag::s_ptagFirst ; ptag != NULL ; ptag = ptag->m_ptagNext)
        ptag->Init();

    InitializeCriticalSection(&CTraceTag::s_critsec);
    CTraceTag::s_bCritSecValid = TRUE;

} //*** InitAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CleanupAllTraceTags
//
//  Routine Description:
//      Cleanup after the trace tags.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupAllTraceTags(void)
{
    if (CTraceTag::BCritSecValid())
    {
        DeleteCriticalSection(&CTraceTag::s_critsec);
        CTraceTag::s_bCritSecValid = FALSE;
    } // if:  critical section is valid

} //*** CleanupAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceMenu
//
//  Routine Description:
//      Display information about menus.
//
//  Arguments:
//      rtag        [IN OUT] Trace tag to use to display information.
//      pmenu       [IN] Menu to traverse.
//      pszPrefix   [IN] Prefix string to display.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceMenu(
    IN OUT CTraceTag &  rtag,
    IN const CMenu *    pmenu,
    IN LPCTSTR          pszPrefix
    )
{
    if (rtag.BAny())
    {
        UINT    cItems;
        UINT    iItem;
        UINT    nState;
        CString strMenu;
#ifndef __AFXWIN_H__
        BSTR    bstrMenu;
#endif
        CString strPrefix(pszPrefix);

        strPrefix += _T("->");

        cItems = pmenu->GetMenuItemCount();
        for (iItem = 0 ; iItem < cItems ; iItem++)
        {
#ifdef __AFXWIN_H__
            pmenu->GetMenuString(iItem, strMenu, MF_BYPOSITION);
#else // __ATLGDI_H__ must be defined
            pmenu->GetMenuString(iItem, bstrMenu, MF_BYPOSITION);
            strMenu = bstrMenu;
            SysFreeString(bstrMenu);
#endif
            nState = pmenu->GetMenuState(iItem, MF_BYPOSITION);
            if (nState & MF_SEPARATOR)
                strMenu += _T("SEPARATOR");
            if (nState & MF_CHECKED)
                strMenu += _T(" (checked)");
            if (nState & MF_DISABLED)
                strMenu += _T(" (disabled)");
            if (nState & MF_GRAYED)
                strMenu += _T(" (grayed)");
            if (nState & MF_MENUBARBREAK)
                strMenu += _T(" (MenuBarBreak)");
            if (nState & MF_MENUBREAK)
                strMenu += _T(" (MenuBreak)");
            if (nState & MF_POPUP)
                strMenu += _T(" (popup)");

            Trace(rtag, _T("(0x%08.8x) %s%s"), pszPrefix, pmenu->m_hMenu, strMenu);

            if (nState & MF_POPUP)
            {
#ifdef __AFXWIN_H__
                TraceMenu(rtag, pmenu->GetSubMenu(iItem), strPrefix);
#else // __ATLGDI_H__ must be defined
                CMenu submenu(pmenu->GetSubMenu(iItem));
                TraceMenu(rtag, &submenu, strPrefix);
            } // if:  popup menu
#endif
        } // for:  each item in the menu
    } // if:  any output is enabled

} //*** TraceMenu()

struct AFX_MAP_MESSAGE
{
    UINT    nMsg;
    LPCSTR  lpszMsg;
};

#include "dde.h"
#define DEFINE_MESSAGE(wm)  { wm, #wm }

static const AFX_MAP_MESSAGE allMessages[] =
{
    DEFINE_MESSAGE(WM_CREATE),
    DEFINE_MESSAGE(WM_DESTROY),
    DEFINE_MESSAGE(WM_MOVE),
    DEFINE_MESSAGE(WM_SIZE),
    DEFINE_MESSAGE(WM_ACTIVATE),
    DEFINE_MESSAGE(WM_SETFOCUS),
    DEFINE_MESSAGE(WM_KILLFOCUS),
    DEFINE_MESSAGE(WM_ENABLE),
    DEFINE_MESSAGE(WM_SETREDRAW),
    DEFINE_MESSAGE(WM_SETTEXT),
    DEFINE_MESSAGE(WM_GETTEXT),
    DEFINE_MESSAGE(WM_GETTEXTLENGTH),
    DEFINE_MESSAGE(WM_PAINT),
    DEFINE_MESSAGE(WM_CLOSE),
    DEFINE_MESSAGE(WM_QUERYENDSESSION),
    DEFINE_MESSAGE(WM_QUIT),
    DEFINE_MESSAGE(WM_QUERYOPEN),
    DEFINE_MESSAGE(WM_ERASEBKGND),
    DEFINE_MESSAGE(WM_SYSCOLORCHANGE),
    DEFINE_MESSAGE(WM_ENDSESSION),
    DEFINE_MESSAGE(WM_SHOWWINDOW),
    DEFINE_MESSAGE(WM_CTLCOLORMSGBOX),
    DEFINE_MESSAGE(WM_CTLCOLOREDIT),
    DEFINE_MESSAGE(WM_CTLCOLORLISTBOX),
    DEFINE_MESSAGE(WM_CTLCOLORBTN),
    DEFINE_MESSAGE(WM_CTLCOLORDLG),
    DEFINE_MESSAGE(WM_CTLCOLORSCROLLBAR),
    DEFINE_MESSAGE(WM_CTLCOLORSTATIC),
    DEFINE_MESSAGE(WM_WININICHANGE),
    DEFINE_MESSAGE(WM_DEVMODECHANGE),
    DEFINE_MESSAGE(WM_ACTIVATEAPP),
    DEFINE_MESSAGE(WM_FONTCHANGE),
    DEFINE_MESSAGE(WM_TIMECHANGE),
    DEFINE_MESSAGE(WM_CANCELMODE),
    DEFINE_MESSAGE(WM_SETCURSOR),
    DEFINE_MESSAGE(WM_MOUSEACTIVATE),
    DEFINE_MESSAGE(WM_CHILDACTIVATE),
    DEFINE_MESSAGE(WM_QUEUESYNC),
    DEFINE_MESSAGE(WM_GETMINMAXINFO),
    DEFINE_MESSAGE(WM_ICONERASEBKGND),
    DEFINE_MESSAGE(WM_NEXTDLGCTL),
    DEFINE_MESSAGE(WM_SPOOLERSTATUS),
    DEFINE_MESSAGE(WM_DRAWITEM),
    DEFINE_MESSAGE(WM_MEASUREITEM),
    DEFINE_MESSAGE(WM_DELETEITEM),
    DEFINE_MESSAGE(WM_VKEYTOITEM),
    DEFINE_MESSAGE(WM_CHARTOITEM),
    DEFINE_MESSAGE(WM_SETFONT),
    DEFINE_MESSAGE(WM_GETFONT),
    DEFINE_MESSAGE(WM_QUERYDRAGICON),
    DEFINE_MESSAGE(WM_COMPAREITEM),
    DEFINE_MESSAGE(WM_COMPACTING),
    DEFINE_MESSAGE(WM_NCCREATE),
    DEFINE_MESSAGE(WM_NCDESTROY),
    DEFINE_MESSAGE(WM_NCCALCSIZE),
    DEFINE_MESSAGE(WM_NCHITTEST),
    DEFINE_MESSAGE(WM_NCPAINT),
    DEFINE_MESSAGE(WM_NCACTIVATE),
    DEFINE_MESSAGE(WM_GETDLGCODE),
    DEFINE_MESSAGE(WM_NCMOUSEMOVE),
    DEFINE_MESSAGE(WM_NCLBUTTONDOWN),
    DEFINE_MESSAGE(WM_NCLBUTTONUP),
    DEFINE_MESSAGE(WM_NCLBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_NCRBUTTONDOWN),
    DEFINE_MESSAGE(WM_NCRBUTTONUP),
    DEFINE_MESSAGE(WM_NCRBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_NCMBUTTONDOWN),
    DEFINE_MESSAGE(WM_NCMBUTTONUP),
    DEFINE_MESSAGE(WM_NCMBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_KEYDOWN),
    DEFINE_MESSAGE(WM_KEYUP),
    DEFINE_MESSAGE(WM_CHAR),
    DEFINE_MESSAGE(WM_DEADCHAR),
    DEFINE_MESSAGE(WM_SYSKEYDOWN),
    DEFINE_MESSAGE(WM_SYSKEYUP),
    DEFINE_MESSAGE(WM_SYSCHAR),
    DEFINE_MESSAGE(WM_SYSDEADCHAR),
    DEFINE_MESSAGE(WM_KEYLAST),
    DEFINE_MESSAGE(WM_INITDIALOG),
    DEFINE_MESSAGE(WM_COMMAND),
    DEFINE_MESSAGE(WM_SYSCOMMAND),
    DEFINE_MESSAGE(WM_TIMER),
    DEFINE_MESSAGE(WM_HSCROLL),
    DEFINE_MESSAGE(WM_VSCROLL),
    DEFINE_MESSAGE(WM_INITMENU),
    DEFINE_MESSAGE(WM_INITMENUPOPUP),
    DEFINE_MESSAGE(WM_MENUSELECT),
    DEFINE_MESSAGE(WM_MENUCHAR),
    DEFINE_MESSAGE(WM_ENTERIDLE),
    DEFINE_MESSAGE(WM_MOUSEMOVE),
    DEFINE_MESSAGE(WM_LBUTTONDOWN),
    DEFINE_MESSAGE(WM_LBUTTONUP),
    DEFINE_MESSAGE(WM_LBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_RBUTTONDOWN),
    DEFINE_MESSAGE(WM_RBUTTONUP),
    DEFINE_MESSAGE(WM_RBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_MBUTTONDOWN),
    DEFINE_MESSAGE(WM_MBUTTONUP),
    DEFINE_MESSAGE(WM_MBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_PARENTNOTIFY),
    DEFINE_MESSAGE(WM_MDICREATE),
    DEFINE_MESSAGE(WM_MDIDESTROY),
    DEFINE_MESSAGE(WM_MDIACTIVATE),
    DEFINE_MESSAGE(WM_MDIRESTORE),
    DEFINE_MESSAGE(WM_MDINEXT),
    DEFINE_MESSAGE(WM_MDIMAXIMIZE),
    DEFINE_MESSAGE(WM_MDITILE),
    DEFINE_MESSAGE(WM_MDICASCADE),
    DEFINE_MESSAGE(WM_MDIICONARRANGE),
    DEFINE_MESSAGE(WM_MDIGETACTIVE),
    DEFINE_MESSAGE(WM_MDISETMENU),
    DEFINE_MESSAGE(WM_CUT),
    DEFINE_MESSAGE(WM_COPY),
    DEFINE_MESSAGE(WM_PASTE),
    DEFINE_MESSAGE(WM_CLEAR),
    DEFINE_MESSAGE(WM_UNDO),
    DEFINE_MESSAGE(WM_RENDERFORMAT),
    DEFINE_MESSAGE(WM_RENDERALLFORMATS),
    DEFINE_MESSAGE(WM_DESTROYCLIPBOARD),
    DEFINE_MESSAGE(WM_DRAWCLIPBOARD),
    DEFINE_MESSAGE(WM_PAINTCLIPBOARD),
    DEFINE_MESSAGE(WM_VSCROLLCLIPBOARD),
    DEFINE_MESSAGE(WM_SIZECLIPBOARD),
    DEFINE_MESSAGE(WM_ASKCBFORMATNAME),
    DEFINE_MESSAGE(WM_CHANGECBCHAIN),
    DEFINE_MESSAGE(WM_HSCROLLCLIPBOARD),
    DEFINE_MESSAGE(WM_QUERYNEWPALETTE),
    DEFINE_MESSAGE(WM_PALETTEISCHANGING),
    DEFINE_MESSAGE(WM_PALETTECHANGED),
    DEFINE_MESSAGE(WM_DDE_INITIATE),
    DEFINE_MESSAGE(WM_DDE_TERMINATE),
    DEFINE_MESSAGE(WM_DDE_ADVISE),
    DEFINE_MESSAGE(WM_DDE_UNADVISE),
    DEFINE_MESSAGE(WM_DDE_ACK),
    DEFINE_MESSAGE(WM_DDE_DATA),
    DEFINE_MESSAGE(WM_DDE_REQUEST),
    DEFINE_MESSAGE(WM_DDE_POKE),
    DEFINE_MESSAGE(WM_DDE_EXECUTE),
    DEFINE_MESSAGE(WM_DROPFILES),
    DEFINE_MESSAGE(WM_POWER),
    DEFINE_MESSAGE(WM_WINDOWPOSCHANGED),
    DEFINE_MESSAGE(WM_WINDOWPOSCHANGING),
#ifdef __AFXWIN_H__
// MFC specific messages
    DEFINE_MESSAGE(WM_SIZEPARENT),
    DEFINE_MESSAGE(WM_SETMESSAGESTRING),
    DEFINE_MESSAGE(WM_IDLEUPDATECMDUI),
    DEFINE_MESSAGE(WM_INITIALUPDATE),
    DEFINE_MESSAGE(WM_COMMANDHELP),
    DEFINE_MESSAGE(WM_HELPHITTEST),
    DEFINE_MESSAGE(WM_EXITHELPMODE),
#endif
    DEFINE_MESSAGE(WM_HELP),
    DEFINE_MESSAGE(WM_NOTIFY),
    DEFINE_MESSAGE(WM_CONTEXTMENU),
    DEFINE_MESSAGE(WM_TCARD),
    DEFINE_MESSAGE(WM_MDIREFRESHMENU),
    DEFINE_MESSAGE(WM_MOVING),
    DEFINE_MESSAGE(WM_STYLECHANGED),
    DEFINE_MESSAGE(WM_STYLECHANGING),
    DEFINE_MESSAGE(WM_SIZING),
    DEFINE_MESSAGE(WM_SETHOTKEY),
    DEFINE_MESSAGE(WM_PRINT),
    DEFINE_MESSAGE(WM_PRINTCLIENT),
    DEFINE_MESSAGE(WM_POWERBROADCAST),
    DEFINE_MESSAGE(WM_HOTKEY),
    DEFINE_MESSAGE(WM_GETICON),
    DEFINE_MESSAGE(WM_EXITMENULOOP),
    DEFINE_MESSAGE(WM_ENTERMENULOOP),
    DEFINE_MESSAGE(WM_DISPLAYCHANGE),
    DEFINE_MESSAGE(WM_STYLECHANGED),
    DEFINE_MESSAGE(WM_STYLECHANGING),
    DEFINE_MESSAGE(WM_GETICON),
    DEFINE_MESSAGE(WM_SETICON),
    DEFINE_MESSAGE(WM_SIZING),
    DEFINE_MESSAGE(WM_MOVING),
    DEFINE_MESSAGE(WM_CAPTURECHANGED),
    DEFINE_MESSAGE(WM_DEVICECHANGE),
    DEFINE_MESSAGE(WM_PRINT),
    DEFINE_MESSAGE(WM_PRINTCLIENT),
// MFC private messages
#ifdef __AFXWIN_H__
    DEFINE_MESSAGE(WM_QUERYAFXWNDPROC),
    DEFINE_MESSAGE(WM_RECALCPARENT),
    DEFINE_MESSAGE(WM_SIZECHILD),
    DEFINE_MESSAGE(WM_KICKIDLE),
    DEFINE_MESSAGE(WM_QUERYCENTERWND),
    DEFINE_MESSAGE(WM_DISABLEMODAL),
    DEFINE_MESSAGE(WM_FLOATSTATUS),
    DEFINE_MESSAGE(WM_ACTIVATETOPLEVEL),
    DEFINE_MESSAGE(WM_QUERY3DCONTROLS),
    DEFINE_MESSAGE(WM_RESERVED_0370),
    DEFINE_MESSAGE(WM_RESERVED_0371),
    DEFINE_MESSAGE(WM_RESERVED_0372),
    DEFINE_MESSAGE(WM_SOCKET_NOTIFY),
    DEFINE_MESSAGE(WM_SOCKET_DEAD),
    DEFINE_MESSAGE(WM_POPMESSAGESTRING),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTREAM),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTORAGE),
    DEFINE_MESSAGE(WM_OCC_INITNEW),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTREAM_EX),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTORAGE_EX),
    DEFINE_MESSAGE(WM_QUEUE_SENTINEL),
    DEFINE_MESSAGE(WM_RESERVED_037C),
    DEFINE_MESSAGE(WM_RESERVED_037D),
    DEFINE_MESSAGE(WM_RESERVED_037E),
    DEFINE_MESSAGE(WM_RESERVED_037F),
#endif
    { 0, NULL, }   // end of message list
};

#undef DEFINE_MESSAGE

void TraceMsg(LPCTSTR lpszPrefix, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    _ASSERTE(lpszPrefix != NULL);

    if (message == WM_MOUSEMOVE || message == WM_NCMOUSEMOVE ||
        message == WM_NCHITTEST || message == WM_SETCURSOR ||
        message == WM_CTLCOLORBTN ||
        message == WM_CTLCOLORDLG ||
        message == WM_CTLCOLOREDIT ||
        message == WM_CTLCOLORLISTBOX ||
        message == WM_CTLCOLORMSGBOX ||
        message == WM_CTLCOLORSCROLLBAR ||
        message == WM_CTLCOLORSTATIC ||
        message == WM_ENTERIDLE || message == WM_CANCELMODE ||
        message == 0x0118)    // WM_SYSTIMER (caret blink)
    {
        // don't report very frequently sent messages
        return;
    }

    LPCSTR lpszMsgName = NULL;
    char szBuf[80];

    // find message name
    if (message >= 0xC000)
    {
        // Window message registered with 'RegisterWindowMessage'
        //  (actually a USER atom)
        if (::GetClipboardFormatNameA(message, szBuf, RTL_NUMBER_OF(szBuf)))
            lpszMsgName = szBuf;
    }
    else if (message >= WM_USER)
    {
        // User message
        hr = StringCchPrintfA(szBuf, RTL_NUMBER_OF( szBuf ), "WM_USER+0x%04X", message - WM_USER);
        _ASSERTE( hr == S_OK );
        lpszMsgName = szBuf;
    }
    else
    {
        // a system windows message
        const AFX_MAP_MESSAGE* pMapMsg = allMessages;
        for (/*null*/; pMapMsg->lpszMsg != NULL; pMapMsg++)
        {
            if (pMapMsg->nMsg == message)
            {
                lpszMsgName = pMapMsg->lpszMsg;
                break;
            }
        }
    }

    if (lpszMsgName != NULL)
    {
        AtlTrace(_T("%s: hwnd=0x%04X, msg = %hs (0x%04X, 0x%08lX)\n"),
            lpszPrefix, (UINT)hwnd, lpszMsgName,
            wParam, lParam);
    }
    else
    {
        AtlTrace(_T("%s: hwnd=0x%04X, msg = 0x%04X (0x%04X, 0x%08lX)\n"),
            lpszPrefix, (UINT)hwnd, message,
            wParam, lParam);
    }

//#ifndef _MAC
//  if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST)
//      TraceDDE(lpszPrefix, pMsg);
//#endif

} //*** TraceMsg()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\serverappsnode.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ServerAppsNode.h
//
//  Abstract:
//      Definition of the CServerAppsNodeData class.
//
//  Implementation File:
//      ServerAppsNode.h (this file)
//
//  Author:
//      David Potter (davidp)   March 2, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __SERVERAPPSNODE_H_
#define __SERVERAPPSNODE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CServerAppsNodeData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CServerAppsNodeData
/////////////////////////////////////////////////////////////////////////////

#pragma warning( push )
#pragma warning( disable : 4100 ) // unreferenced formal parameter
class CServerAppsNodeData : public CSnapInItemImpl< CServerAppsNodeData, TRUE >
{
public:
    static const GUID *     m_NODETYPE;
    static const TCHAR *    m_SZNODETYPE;
    static const TCHAR *    m_SZDISPLAY_NAME;
    static const CLSID *    m_SNAPIN_CLASSID;

    IDataObject *           m_pDataObject;

public:
    //
    // Object construction and destruction.
    //

    CServerAppsNodeData( void )
    {
        ZeroMemory( &m_scopeDataItem, sizeof(m_scopeDataItem) );
        ZeroMemory( &m_resultDataItem, sizeof(m_resultDataItem) );

    } //*** CServerAppsNodeData()

public:
    //
    // Map menu and controlbar commands to this class.
    //
    BEGIN_SNAPINCOMMAND_MAP( CServerAppsNodeData, TRUE )
    END_SNAPINCOMMAND_MAP()

    //
    // Map a menu to this node type.
    //
    SNAPINMENUID( IDR_CLUSTERADMIN_MENU )

    virtual void InitDataClass( IDataObject * pDataObject, CSnapInItem * pDefault )
    {
        UNREFERENCED_PARAMETER( pDefault );

        m_pDataObject = pDataObject;
        // The default code stores off the pointer to the Dataobject the class is wrapping
        // at the time.
        // Alternatively you could convert the dataobject to the internal format
        // it represents and store that information
    }

    CSnapInItem * GetExtNodeObject( IDataObject * pDataObject, CSnapInItem * pDefault )
    {
        UNREFERENCED_PARAMETER( pDataObject );

        // Modify to return a different CSnapInItem* pointer.
        return pDefault;
    }

}; // class CServerAppsNodeData

/////////////////////////////////////////////////////////////////////////////
// Static Data
/////////////////////////////////////////////////////////////////////////////

_declspec( selectany ) extern const GUID CServerAppsNodeDataGUID_NODETYPE =
{ 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
_declspec( selectany ) const GUID *  CServerAppsNodeData::m_NODETYPE = &CServerAppsNodeDataGUID_NODETYPE;
_declspec( selectany ) const TCHAR * CServerAppsNodeData::m_SZNODETYPE = _T("476e6449-aaff-11d0-b944-00c04fd8d5b0");
_declspec( selectany ) const TCHAR * CServerAppsNodeData::m_SZDISPLAY_NAME = _T("Server Applications and Services");
_declspec( selectany ) const CLSID * CServerAppsNodeData::m_SNAPIN_CLASSID = &CLSID_ClusterAdmin;

/////////////////////////////////////////////////////////////////////////////

#pragma warning( pop )

#endif // __SERVERAPPSNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\snapabout.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      SnapAbout.cpp
//
//  Abstract:
//      Implementation of the CClusterAdminAbout class.
//
//  Author:
//      David Potter (davidp)	November 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <StrSafe.h>
#include "SnapAbout.h"

/////////////////////////////////////////////////////////////////////////////
// class CClusterAdminAbout
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminAbout::~CClusterAdminAbout
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterAdminAbout::~CClusterAdminAbout( void )
{
    if ( m_hSmallImage != NULL )
    {
        DeleteObject( m_hSmallImage );
    }
    if ( m_hSmallImageOpen != NULL )
    {
        DeleteObject( m_hSmallImageOpen );
    }
    if ( m_hLargeImage != NULL )
    {
        DeleteObject( m_hLargeImage );
    }

} //*** CClusterAdminAbout::~CClusterAdminAbout()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminAbout::GetStaticFolderImage
//
//  Description:
//      Get the static folder images for the snapin.
//
//  Arguments:
//      phSmallImage
//      phSmallImageOpen
//      phLargeImage
//      pcMask
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//      E_FAIL      - Error loading bitmaps.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusterAdminAbout::GetStaticFolderImage(
      HBITMAP *     phSmallImage
    , HBITMAP *     phSmallImageOpen
    , HBITMAP *     phLargeImage
    , COLORREF *    pcMask
    )
{
    HRESULT hr = S_OK;

    //
    // Load the images if they haven't been loaded yet.
    //

    if ( m_hSmallImage == NULL )
    {
        m_hSmallImage = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_CLUSTER_16 ) );
        if ( m_hSmallImage == NULL )
        {
            ATLTRACE( _T("Error %d loading the small bitmap # %d\n"), GetLastError(), IDB_CLUSTER_16 );
            hr = E_FAIL;
            goto Cleanup;
        }
    } // if: small image not loaded yet
    if ( m_hSmallImageOpen == NULL )
    {
        m_hSmallImageOpen = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_CLUSTER_16 ) );
        if ( m_hSmallImageOpen == NULL )
        {
            ATLTRACE( _T("Error %d loading the small open bitmap # %d\n"), GetLastError(), IDB_CLUSTER_16 );
            hr = E_FAIL;
            goto Cleanup;
        }
    } // if: small image open not loaded yet
    if ( m_hLargeImage == NULL )
    {
        m_hLargeImage = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDB_CLUSTER_32 ) );
        if ( m_hLargeImage == NULL )
        {
            ATLTRACE( _T("Error %d loading the large bitmap # %d\n"), GetLastError(), IDB_CLUSTER_32 );
            hr = E_FAIL;
            goto Cleanup;
        }
    } // if: large image not open yet

    //
    // Return the image handles.
    //

    *phSmallImage = m_hSmallImage;
    *phSmallImageOpen = m_hSmallImageOpen;
    *phLargeImage = m_hLargeImage;
    *pcMask = RGB(255, 0, 255);

Cleanup:
    return hr;

} //*** CClusterAdminAbout::GetStaticFolderImage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\types\idl\makefile.inc ===
CopyTLB :  CLUADMMC_TLB

CLUADMMC_TLB : $(O)\CluAdMMC.tlb
    copy $** ..\..\src\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\cluscfg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995-2002 Microsoft Corporation
//
//  Module Name:
//      ClusCfg.h
//
//  Description:
//      Defines the clases for creating clusters and adding nodes to
//      clusters.
//
//  Maintained By:
//      David Potter    (DavidP)    16-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#pragma warning( push )
#pragma warning( disable : 4100 )   // vector class instantiation error
#include <list>
#include <CritSec.h>
#pragma warning( pop )

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

class CBaseClusCfg;
class CCreateCluster;
class CAddNodesToCluster;

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

struct STaskToDescription
{
    CLSID   taskidMajor;
    CLSID   taskidMinor;
    BSTR    bstrNodeName;
    BSTR    bstrDescription;

    STaskToDescription( void )
        : bstrNodeName( NULL )
        , bstrDescription( NULL )
    {
    }

}; //*** struct STaskToDescription

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CBaseClusCfg
//
//  Description:
//      Base class for creating clusters or adding nodes to clusters.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CBaseClusCfg
    : public IClusCfgCallback
{
    friend class CCreateCluster;
    friend class CAddNodesToCluster;

private:
    BOOL                        m_fVerbose;             // Should we do verbose spew?
    int                         m_cSpins;               // Count of spins for UI progress

    CCritSec                    m_critsec;              // Critical section for notifications.

    IServiceProvider *          m_psp;                  // Service Manager
    IObjectManager *            m_pom;                  // Object Manager
    ITaskManager *              m_ptm;                  // Task Manager
    IConnectionPointContainer * m_pcpc;                 // Notification Manager's Connection Point Container interface
    OBJECTCOOKIE                m_cookieCluster;        // Cluster cookie

    std::list< STaskToDescription > m_lttd;             // List for translating tasks to descriptions

    //  IUnknown
    LONG                        m_cRef;                 // Reference count

    //  IClusCfgCallback
    ITaskAnalyzeCluster *       m_ptac;                 // Analyze Cluster Task
    ITaskCommitClusterChanges * m_ptccc;                // Commit Cluster Changes Task
    OBJECTCOOKIE                m_cookieCompletion;     // Completion cookie
    BOOL                        m_fTaskDone;            // Is the task done yet?
    HRESULT                     m_hrResult;             // Result of the analyze task
    HANDLE                      m_hEvent;               // Event handle to signal completion

    // Methods
    STaskToDescription *
        PttdFindTask(
              CLSID     taskidMajorIn
            , CLSID     taskidMinorIn
            , LPCWSTR   pcwszNodeName
            );

    STaskToDescription *
        PttdFindParentTask(
              CLSID     taskidIn
            , LPCWSTR   pcwszNodeNameIn
            );

    HRESULT
        HrInsertTask(
              CLSID                 taskidMajorIn
            , CLSID                 taskidMinorIn
            , LPCWSTR               pcwszNodeNameIn
            , LPCWSTR               pcwszDescriptionIn
            , STaskToDescription ** ppttd
            );

public:
    CBaseClusCfg( void );
    virtual ~CBaseClusCfg( void );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
          LPCWSTR       pcszNodeNameIn
        , CLSID         clsidTaskMajorIn
        , CLSID         clsidTaskMinorIn
        , ULONG         ulMinIn
        , ULONG         ulMaxIn
        , ULONG         ulCurrentIn
        , HRESULT       hrStatusIn
        , LPCWSTR       pcszDescriptionIn
        , FILETIME *    pftTimeIn
        , LPCWSTR       pcszReferenceIn
        );

}; //*** class CBaseClusCfg

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CCreateCluster
//
//  Description:
//      Class for creating clusters.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CCreateCluster
    : public CBaseClusCfg
{
private:
    HRESULT
        HrFindNetwork(
              OBJECTCOOKIE              cookieNodeIn
            , LPCWSTR                   pcwszNetworkIn
            , IClusCfgNetworkInfo **    pccniOut
            );

    HRESULT
        HrMatchNetworkInfo(
              OBJECTCOOKIE              cookieNodeIn
            , ULONG                     ulIPAddressIn
            , ULONG *                   pulIPSubnetOut
            , IClusCfgNetworkInfo **    pccniOut
            );

public:
    CCreateCluster( void )
    {
    }

    HRESULT
        HrCreateCluster(
              BOOL                      fVerboseIn
            , BOOL                      fMinConfigIn
            , LPCWSTR                   pcszClusterNameIn
            , LPCWSTR                   pcszNodeNameIn
            , LPCWSTR                   pcszUserAccountIn
            , LPCWSTR                   pcszUserDomainIn
            , const CEncryptedBSTR &    crencbstrPasswordIn
            , LPCWSTR                   pcwszIPAddressIn
            , LPCWSTR                   pcwszIPSubnetIn
            , LPCWSTR                   pcwszNetworkIn
            , BOOL                      fInteractIn
            );

    HRESULT
        HrInvokeWizard(
              LPCWSTR                   pcszClusterNameIn
            , LPCWSTR                   pcszNodeNameIn
            , LPCWSTR                   pcszUserAccountIn
            , LPCWSTR                   pcszUserDomainIn
            , const CEncryptedBSTR &    crencbstrPasswordIn
            , LPCWSTR                   pcwszIPAddressIn
            , BOOL                      fMinConfigIn
            );

}; //*** class CCreateCluster

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CAddNodesToCluster
//
//  Description:
//      Class for adding nodes to clusters.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CAddNodesToCluster
    : public CBaseClusCfg
{
public:
    CAddNodesToCluster( void )
    {
    }

    HRESULT
        HrAddNodesToCluster(
              BOOL                      fVerboseIn
            , BOOL                      fMinConfigIn
            , LPCWSTR                   pcszClusterNameIn
            , BSTR                      rgbstrNodesIn[]
            , DWORD                     cNodesIn
            , const CEncryptedBSTR &    crencbstrPasswordIn
            , BOOL                      fInteractIn
            );

    HRESULT
        HrInvokeWizard(
              LPCWSTR                   pcszClusterNameIn
            , BSTR                      rgbstrNodesIn[]
            , DWORD                     cNodesIn
            , const CEncryptedBSTR &    crencbstrPasswordIn
            , BOOL                      fMinConfigIn
            );

}; //*** class CAddNodesToCluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		Galen Barbee	(GalenB)	Dec 20, 1998
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\cluscfg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ClusCfg.cpp
//
//  Description:
//      Implementation of classes used to create new clusters or add nodes
//      to existing clusters.
//
//  Maintained By:
//      David Potter    (DavidP)    16-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <clusrtl.h>
#include <commctrl.h>
#include "ClusCfg.h"
#include "Util.h"
#include "Resource.h"
#include <NameUtil.h>
#include <Common.h>

//////////////////////////////////////////////////////////////////////////////
//++
//
//  __inline
//  void
//  FlipIpAddress(
//        ULONG *   pulAddrOut
//      , ULONG     ulAddrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
__inline
void
FlipIpAddress(
      ULONG *   pulAddrOut
    , ULONG     ulAddrIn
    )
{
    *pulAddrOut = ( FIRST_IPADDRESS( ulAddrIn ) )
                | ( SECOND_IPADDRESS( ulAddrIn ) << 8 )
                | ( THIRD_IPADDRESS( ulAddrIn ) << 16 )
                | ( FOURTH_IPADDRESS( ulAddrIn ) << 24 );

} //*** FlipIpAddress

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  HRESULT
//  HrGetClusterDomain(
//        PCWSTR    pcwszClusterNameIn
//      , BSTR *    pbstrClusterDomainOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
static
HRESULT
HrGetClusterDomain( PCWSTR pcwszClusterNameIn, BSTR * pbstrClusterDomainOut )
{
    HRESULT     hr = S_OK;
    HCLUSTER    hCluster = NULL;
    DWORD       scClusAPI = ERROR_SUCCESS;
    CString     strClusterName;
    DWORD       cchName = DNS_MAX_NAME_LENGTH;

    *pbstrClusterDomainOut = NULL;

    //
    //  If it's already fully qualified, simply copy domain to out parameter and quit.
    //
    hr = HrIsValidFQN( pcwszClusterNameIn, true );
    if ( hr == S_OK )
    {
        size_t idxDomain = 0;
        hr = HrFindDomainInFQN( pcwszClusterNameIn, &idxDomain );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        *pbstrClusterDomainOut = SysAllocString( pcwszClusterNameIn + idxDomain );
        if ( *pbstrClusterDomainOut == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = S_OK;
        goto Cleanup;
    }
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //
    //  Try to open the cluster using the given name.
    //
    hCluster = OpenCluster( pcwszClusterNameIn );
    if ( hCluster == NULL )
    {
        DWORD scLastError = GetLastError();
        hr = HRESULT_FROM_WIN32( scLastError );
        goto Cleanup;
    }

    //
    //  Get the FQDN, if it's a Windows Server 2003 cluster.
    //
    {
        DWORD cbFQDN = cchName * sizeof( TCHAR );
        DWORD cbBytesRequired = 0;
        scClusAPI = ClusterControl(
            hCluster,
            NULL,
            CLUSCTL_CLUSTER_GET_FQDN,
            NULL,
            NULL,
            strClusterName.GetBuffer( cchName ),
            cbFQDN,
            &cbBytesRequired
            );
        strClusterName.ReleaseBuffer( cchName );
        if ( scClusAPI == ERROR_MORE_DATA )
        {
            cchName = ( cbBytesRequired / sizeof( TCHAR ) ) + 1;
            cbFQDN = cchName * sizeof( TCHAR );
            scClusAPI = ClusterControl(
                hCluster,
                NULL,
                CLUSCTL_CLUSTER_GET_FQDN,
                NULL,
                NULL,
                strClusterName.GetBuffer( cchName ),
                cbFQDN,
                &cbBytesRequired
                );
            strClusterName.ReleaseBuffer( cchName );
        }
    }

    //
    //  If ClusterControl returned ERROR_INVALID_FUNCTION, it's downlevel,
    //  so use client's domain.
    //
    if ( scClusAPI == ERROR_INVALID_FUNCTION )
    {
        hr = HrGetComputerName(
            ComputerNamePhysicalDnsDomain,
            pbstrClusterDomainOut,
            FALSE // fBestEffortIn
            );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    else if ( scClusAPI == ERROR_SUCCESS )
    {
        size_t idxDomain = 0;
        hr = HrFindDomainInFQN( strClusterName, &idxDomain );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        *pbstrClusterDomainOut = SysAllocString( static_cast< PCWSTR >( strClusterName ) + idxDomain );
        if ( *pbstrClusterDomainOut == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    else // something went wrong
    {
        hr = HRESULT_FROM_WIN32( scClusAPI );
        goto Cleanup;
    }
    
Cleanup:

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    }

    return hr;
}


//****************************************************************************
//
//  class CBaseClusCfg
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusCfg::CBaseClusCfg
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusCfg::CBaseClusCfg( void )
    : m_fVerbose( FALSE )
    , m_cSpins( 0 )
    , m_psp( NULL )
    , m_pom( NULL )
    , m_ptm( NULL )
    , m_pcpc( NULL )
    , m_cookieCluster( 0 )
    , m_cRef( 0 )
    , m_ptac( NULL )
    , m_cookieCompletion( 0 )
    , m_fTaskDone( FALSE )
    , m_hrResult( S_OK )
    , m_hEvent( NULL )
{
    HRESULT                 hr = S_OK;
    CString                 strMsg;
    CString                 strDesc;
    STaskToDescription *    sttd = NULL;

    struct  STaskIDToIDS
    {
        const GUID *    pguid;
        UINT            ids;
    };

    STaskIDToIDS ttiMajor[] =
    {
         { &TASKID_Major_Checking_For_Existing_Cluster, IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER }
       , { &TASKID_Major_Establish_Connection,          IDS_TASKID_MAJOR_ESTABLISH_CONNECTION }
       , { &TASKID_Major_Check_Node_Feasibility,        IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY }
       , { &TASKID_Major_Find_Devices,                  IDS_TASKID_MAJOR_FIND_DEVICES }
       , { &TASKID_Major_Check_Cluster_Feasibility,     IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY }
       , { &TASKID_Major_Reanalyze,                     IDS_TASKID_MAJOR_REANALYZE }
       , { &TASKID_Major_Configure_Cluster_Services,    IDS_TASKID_MAJOR_CONFIGURE_CLUSTER_SERVICES }
       , { &TASKID_Major_Configure_Resource_Types,      IDS_TASKID_MAJOR_CONFIGURE_RESOURCE_TYPES }
       , { &TASKID_Major_Configure_Resources,           IDS_TASKID_MAJOR_CONFIGURE_RESOURCES }
       , { NULL, 0 }
    };

    //
    // Translate the major ID to a string ID.
    //

    for ( int idx = 0 ; ttiMajor[ idx ].pguid != NULL ; idx++ )
    {
        // Format the display text for the major ID.
        strMsg.LoadString( ttiMajor[ idx ].ids );
        strDesc.Format( L"\n  %ls", strMsg );
        hr = HrInsertTask( GUID_NULL, *(ttiMajor[ idx ].pguid),  NULL, strDesc.AllocSysString(), &sttd );
        if ( FAILED( hr ) )
        {
            // Ignore the failure.  What will happen if we can't insert a task is that
            // when we try to look up a parent task it will fail and we'll get an
            // "<Unknown Task>" string.
        }
    } // for: each task ID in the table

} //*** CBaseClusCfg::CBaseClusCfg

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusCfg::~CBaseClusCfg
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CBaseClusCfg::~CBaseClusCfg( void )
{
    if ( m_psp != NULL )
    {
        m_psp->Release();
    }
    if ( m_pom != NULL )
    {
        m_pom->Release();
    }
    if ( m_ptm != NULL )
    {
        m_ptm->Release();
    }
    if ( m_pcpc != NULL )
    {
        m_pcpc->Release();
    }
    if ( m_ptac != NULL )
    {
        m_ptac->Release();
    }
    if ( m_hEvent != NULL )
    {
        CloseHandle( m_hEvent );
    }

    _ASSERTE( m_cRef == 0 );

} //*** CBaseClusCfg::~CBaseClusCfg

//****************************************************************************
//
//  class CBaseClusCfg [IUnknown]
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CBaseClusCfg::AddRef
//
//  Description:
//      Add a reference to the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      m_cRef - the new reference count after adding the reference.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CBaseClusCfg::AddRef( void )
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;

} //*** CBaseClusCfg::AddRef

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CBaseClusCfg::Release
//
//  Description:
//      Release a reference to the COM object.
//
//  Arguments:
//      None.
//
//  Return Values:
//      cRef - the new reference count after releasing the reference.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CBaseClusCfg::Release( void )
{
    LONG    cRef;
    cRef = InterlockedDecrement( &m_cRef );
    return cRef;

} //*** CBaseClusCfg::Release

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CBaseClusCfg::QueryInterface
//
//  Description:
//      Query for an interface on this COM bject.
//
//  Arguments:
//      riidIn  - Interface being queried for.
//      ppvOut  - Interface pointer being returned.
//
//  Return Values:
//      S_OK            - Interface pointer returned successfully.
//      E_NOINTERFACE   - Interface not supported by this COM object.
//      E_POINTER       - ppvOut was NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBaseClusCfg::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    HRESULT hr = S_OK;

    //
    // Validate Arguments:
    //

    if ( ppvOut == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = this;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = this;
    } // else if: IClusCfgCallback
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

Cleanup:
    return hr;

} //*** CBaseClusCfg::QueryInterface

//****************************************************************************
//
//  class CBaseClusCfg [IClusCfgCallback]
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgCallback]
//  CBaseClusCfg::SendStatusReport
//
//  Description:
//      Process status reports and display them on the console.
//
//  Arguments:
//      pcszNodeNameIn
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//      hrStatusIn
//      pcszDescriptionIn
//      pftTimeIn
//      pcszReferenceIn
//
//  Return Values:
//      S_OK    - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBaseClusCfg::SendStatusReport(
      LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    HRESULT                 hr      = S_OK;
    CString                 strMsg;
    CString                 strMajorMsg;
    CString                 strMinorMsg;
    LPCWSTR                 pszErrorPad;
    STaskToDescription *    pttd    = NULL;
    STaskToDescription *    pttdParent = NULL;
    BSTR                    bstrShortNodeName = NULL;
    static CLSID            s_taskidMajor = { 0 };

    UNREFERENCED_PARAMETER( ulMinIn );
    UNREFERENCED_PARAMETER( pftTimeIn );
    UNREFERENCED_PARAMETER( pcszReferenceIn );

    // Make sure no one else is in this routine at the same time.
    m_critsec.Lock();

    m_cSpins++;

    if ( ! m_fVerbose )
    {
        putwchar( L'.' );
        goto Cleanup;
    }

    //
    // Don't display this report if it is only intended for a log file.
    //

    if (    IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_Log )
        ||  IsEqualIID( clsidTaskMajorIn, TASKID_Major_Server_Log )
        ||  IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_And_Server_Log )
        ||  IsEqualIID( clsidTaskMajorIn, IID_NULL )
        )
    {
        goto Cleanup;
    } // if: log-only message

    //
    // Translate the major ID to a string ID.  The clsidTaskMajorIn will
    // be a minor of some other entry.
    //

    pttdParent = PttdFindParentTask( clsidTaskMajorIn, pcszNodeNameIn ); 
    if ( pttdParent == NULL )
    {
        strMsg.LoadString( IDS_TASKID_UNKNOWN );
        strMajorMsg.Format( L"\n  %ls", strMsg );
    }
    else
    {
        strMajorMsg = pttdParent->bstrDescription;
    }

    //
    // Display the description if it is specified.
    // If it is not specified, search the minor task list for the minor task
    // ID and display the saved description for that node/task ID combination.
    //

    if ( pcszDescriptionIn != NULL )
    {
        //
        // If a node was specified, prefix the message with the node name.
        //

        if ( ( pcszNodeNameIn != NULL )
          && ( *pcszNodeNameIn != L'\0' ) )
        {
            hr = HrGetFQNDisplayName( pcszNodeNameIn, &bstrShortNodeName );
            if ( SUCCEEDED( hr ) )
            {
                strMinorMsg.Format( L"\n    %ls: %ls", bstrShortNodeName, pcszDescriptionIn );
            }
            else
            {
                strMinorMsg.Format( L"\n    %ls: %ls", pcszNodeNameIn, pcszDescriptionIn );
            }
        } // if: a node name was specified
        else
        {
            strMinorMsg.Format( L"\n    %ls", pcszDescriptionIn );
        }

        pszErrorPad = L"\n      ";

        //
        // Save the description in the list.
        //

        hr = HrInsertTask(
                  clsidTaskMajorIn
                , clsidTaskMinorIn
                , pcszNodeNameIn
                , strMinorMsg
                , &pttd
                );
        if ( FAILED( hr ) )
        {
        }
    } // if: description specified
    else
    {
        //
        // Find the node/task-ID combination in the list.
        //

        pttd = PttdFindTask( clsidTaskMajorIn, clsidTaskMinorIn, pcszNodeNameIn );
        if ( pttd != NULL )
        {
            strMinorMsg = pttd->bstrDescription;
            pszErrorPad = L"\n      ";
        }
        else
        {
            pszErrorPad = L"\n    ";
        }
    } // else: no description specified

    // If this is a different major task, display the major task information.
    if ( ! IsEqualIID( clsidTaskMajorIn, s_taskidMajor )
      || ( strMinorMsg.GetLength() == 0 ) )
    {
        PrintString( strMajorMsg );
    }
    CopyMemory( &s_taskidMajor, &clsidTaskMajorIn, sizeof( s_taskidMajor ) );

    // If there is a minor task message, display it.
    if ( strMinorMsg.GetLength() > 0 )
    {
        PrintString( strMinorMsg );
    }

    // Display the progress information.
    strMsg.Format( IDS_CLUSCFG_PROGRESS_FORMAT, ulCurrentIn, ulMaxIn );
    PrintString( strMsg );

    // If an error occurred, display the text translation.
    if ( FAILED( hrStatusIn ) )
    {
        PrintSystemError( hrStatusIn, pszErrorPad );
    }

Cleanup:
    m_critsec.Unlock();
    SysFreeString( bstrShortNodeName );
    return hr;

} //*** CBaseClusCfg::SendStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusCfg::PttdFindTask
//
//  Description:
//      Find the task that matches the CLSIDs and node name.
//
//  Arguments:
//      taskidMajorIn   The major task id of the task.
//
//      taskidMinorIn   The minor task id of the task.
//
//      pcwszNodeNameIn The node on which this was logged.
//
//  Return Values:
//      On success a pointer to the desired task.
//      
//      On failure NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
STaskToDescription *
CBaseClusCfg::PttdFindTask(
      CLSID     taskidMajorIn
    , CLSID     taskidMinorIn
    , LPCWSTR   pcwszNodeNameIn
    )
{
    std::list< STaskToDescription >::iterator   itCurValue  = m_lttd.begin();
    std::list< STaskToDescription >::iterator   itLast      = m_lttd.end();
    STaskToDescription *                        pttd        = NULL;
    STaskToDescription *                        pttdNext    = NULL;
    size_t                                      cchNodeName = 0;

    for ( ; itCurValue != itLast ; itCurValue++ )
    {
        pttdNext = &(*itCurValue);
        cchNodeName = SysStringLen( pttdNext->bstrNodeName );
        if ( IsEqualIID( pttdNext->taskidMajor, taskidMajorIn )
          && IsEqualIID( pttdNext->taskidMinor, taskidMinorIn )
          && ( ( pttdNext->bstrNodeName == pcwszNodeNameIn )
             || ( ( pcwszNodeNameIn != NULL )
                && ( ClRtlStrNICmp( pttdNext->bstrNodeName, pcwszNodeNameIn, cchNodeName ) == 0 ) ) )
            )
        {
            pttd = pttdNext;
            break;
        } // if: found a match
    } // for: each item in the list

    return pttd;

} //*** CBaseClusCfg::PttdFindTask

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusCfg::PttdFindParentTask
//
//  Description:
//      Find the parent task.  The taskidIn param is the major task id of
//      the task whose parent we are looking for.
//
//  Arguments:
//      taskidIn        The major task id of the task.
//
//      pcwszNodeNameIn The node on which this was logged.
//
//  Return Values:
//      On success a pointer to the parent task.
//      
//      On failure NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
STaskToDescription *
CBaseClusCfg::PttdFindParentTask(
      CLSID     taskidIn
    , LPCWSTR   pcwszNodeNameIn
    )
{
    std::list< STaskToDescription >::iterator   itCurValue  = m_lttd.begin();
    std::list< STaskToDescription >::iterator   itLast      = m_lttd.end();
    STaskToDescription *                        pttd        = NULL;
    STaskToDescription *                        pttdNext    = NULL;
    size_t                                      cchNodeName = 0;

    for ( ; itCurValue != itLast ; itCurValue++ )
    {
        //
        //  Make sure the CLSIDs match and that if a node name was specified that
        //  both node names match.
        //
        pttdNext = &(*itCurValue);
        if ( IsEqualIID( pttdNext->taskidMinor, taskidIn ) )
        {
            //
            //  CLSIDs match.  If pttdNext->bstrNodeName is null, we're a root node task,
            //  so we don't need to compare the strings.  Otherwise check whether
            //  pcwszNodeNameIn is null.  If it's not then compare the two strings.
            //
            cchNodeName = SysStringLen( pttdNext->bstrNodeName );
            if (   ( pttdNext->bstrNodeName == NULL )
                || (    ( pcwszNodeNameIn != NULL )
                     && ( ClRtlStrNICmp( pttdNext->bstrNodeName, pcwszNodeNameIn, cchNodeName ) == 0 ) ) 
               )
            {
                pttd = pttdNext;
                break;
            } // if: node names match

        } // if: CLSIDs match

    } // for: each item in the list

    return pttd;

} //*** CBaseClusCfg::PttdFindParentTask

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseClusCfg::HrInsertTask
//
//  Description:
//      Insert a task into the list at the correct position.  If it already
//      exists, just replace the description.
//
//  Arguments:
//      taskidMajorIn
//      taskidMinorIn
//      pcwszNodeNameIn
//      pcwszDescriptionIn
//      ppttd
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CBaseClusCfg::HrInsertTask(
      CLSID                 taskidMajorIn
    , CLSID                 taskidMinorIn
    , LPCWSTR               pcwszNodeNameIn
    , LPCWSTR               pcwszDescriptionIn
    , STaskToDescription ** ppttd
    )
{
    HRESULT                                     hr              = S_OK;
    std::list< STaskToDescription >::iterator   itCurValue      = m_lttd.begin();
    std::list< STaskToDescription >::iterator   itLast          = m_lttd.end();
    BSTR                                        bstrDescription = NULL;
    STaskToDescription *                        pttdNext        = NULL;
    STaskToDescription                          ttd;
    size_t                                      cchNodeName = 0;

    _ASSERTE( pcwszDescriptionIn != NULL );
    _ASSERTE( ppttd != NULL );

    // Find the task to see if all we need to do is replace the description.
    for ( ; itCurValue != itLast ; itCurValue++ )
    {
        pttdNext = &(*itCurValue);
        cchNodeName = SysStringLen( pttdNext->bstrNodeName );
        if ( IsEqualIID( pttdNext->taskidMajor, taskidMajorIn )
          && IsEqualIID( pttdNext->taskidMinor, taskidMinorIn )
          && ( ( pttdNext->bstrNodeName == pcwszNodeNameIn )
            || ( ClRtlStrNICmp( pttdNext->bstrNodeName, pcwszNodeNameIn, cchNodeName ) == 0 ) )
            )
        {
            bstrDescription = SysAllocString( pcwszDescriptionIn );
            if ( bstrDescription == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            SysFreeString( pttdNext->bstrDescription );
            pttdNext->bstrDescription = bstrDescription;
            bstrDescription = NULL;     // prevent cleanup after transfering ownership
            *ppttd = pttdNext;
            goto Cleanup;
        } // if: found a match
    } // for: each item in the list

    //
    // The task was not found in the list.  Insert a new entry.
    //

    CopyMemory( &ttd.taskidMajor, &taskidMajorIn, sizeof( ttd.taskidMajor ) );
    CopyMemory( &ttd.taskidMinor, &taskidMinorIn, sizeof( ttd.taskidMinor ) );
    if ( pcwszNodeNameIn == NULL )
    {
        ttd.bstrNodeName = NULL;
    }
    else
    {
        ttd.bstrNodeName = SysAllocString( pcwszNodeNameIn );
        if ( ttd.bstrNodeName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    ttd.bstrDescription = SysAllocString( pcwszDescriptionIn );
    if ( ttd.bstrDescription == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    itCurValue = m_lttd.insert( m_lttd.end(), ttd );
    ttd.bstrNodeName = NULL;
    ttd.bstrDescription = NULL;
    *ppttd = &(*itCurValue);

Cleanup:
    if ( bstrDescription != NULL )
    {
        SysFreeString( bstrDescription );
    }
    if ( ttd.bstrNodeName != NULL )
    {
        SysFreeString( ttd.bstrNodeName );
    }
    if ( ttd.bstrDescription != NULL )
    {
        SysFreeString( ttd.bstrDescription );
    }

    return hr;

} //*** CBaseClusCfg::HrInsertTask

//****************************************************************************
//
//  class CCreateCluster
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateCluster::HrCreateCluster
//
//  Description:
//      Create a cluster and display output on the console.
//
//  Arguments:
//      fVerboseIn
//      fMinConfigIn
//      pcszClusterNameIn
//      pcszNodeNameIn
//      pcszUserAccountIn
//      pcszUserDomainIn
//      crencbstrPasswordIn
//      pcwszIPAddressIn
//      pcwszIPSubnetIn
//      pcwszNetworkIn
//      fInteractIn
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      E_INVALIDARG    - Invalid cluster name.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateCluster::HrCreateCluster(
      BOOL                      fVerboseIn
    , BOOL                      fMinConfigIn
    , LPCWSTR                   pcszClusterNameIn
    , LPCWSTR                   pcszNodeNameIn
    , LPCWSTR                   pcszUserAccountIn
    , LPCWSTR                   pcszUserDomainIn
    , const CEncryptedBSTR &    crencbstrPasswordIn
    , LPCWSTR                   pcwszIPAddressIn
    , LPCWSTR                   pcwszIPSubnetIn
    , LPCWSTR                   pcwszNetworkIn
    , BOOL                      fInteractIn
    )
{
    HRESULT                 hr      = S_OK;
    DWORD                   dwStatus;
    DWORD                   dwAdviseCookie = 0;
    IUnknown *              punk    = NULL;
    IClusCfgClusterInfo *   pccci   = NULL;
    IClusCfgNetworkInfo *   pccni   = NULL;
    IClusCfgCredentials *   pccc    = NULL;
    IConnectionPoint *      pcp     = NULL;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;
    OBJECTCOOKIE            cookieNode;
    CString                 strMsg;
    BSTR                    bstrClusterLabel = NULL;
    BSTR                    bstrClusterFQN = NULL;
    size_t                  idxClusterDomain = 0;
    BSTR                    bstrNodeFQN = NULL;
    BSTR                    bstrPassword = NULL;
    GUID *                  pTaskGUID = NULL;

    UNREFERENCED_PARAMETER( fInteractIn );

    m_fVerbose = fVerboseIn;

    //
    // Summarize what we are doing.
    //

    strMsg.FormatMessage(
          IDS_CLUSCFG_PREPARING_TO_CREATE_CLUSTER
        , pcszClusterNameIn
        , pcszNodeNameIn
        , pcszUserDomainIn
        , pcszUserAccountIn
        );
    wprintf( L"%ls", (LPCWSTR) strMsg );

    if ( fMinConfigIn )
    {
        if ( strMsg.LoadString( IDS_CLUSCFG_MIN_CONFIG_CREATE_CLUSTER ) )
        {
            wprintf( L"\n%ls", (LPCWSTR) strMsg );
        } // if:
    } // if:

    //
    // Get the service manager.
    //

    hr = CoCreateInstance(
                  CLSID_ServiceManager
                , NULL
                , CLSCTX_INPROC_SERVER
                , IID_IServiceProvider
                , reinterpret_cast< void ** >( &m_psp )
                );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the object manager.
    //

    hr = m_psp->QueryService(
                  CLSID_ObjectManager
                , IID_IObjectManager
                , reinterpret_cast< void ** >( &m_pom )
                );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the notification manager.
    //

    hr = m_psp->QueryService(
                  CLSID_NotificationManager
                , IID_IConnectionPointContainer
                , reinterpret_cast< void ** >( &m_pcpc )
                );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Set the callback interface so the middle tier can report errors
    // back to the UI layer, in this case, cluster.exe.
    //

    hr = m_pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) ;
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = pcp->Advise( this, &dwAdviseCookie );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Make the cluster name into something usable for creating.
    //
    
    hr = HrMakeFQN(
            pcszClusterNameIn
          , NULL // Default to local machine's domain.
          , true // Accept non-RFC chars.
          , &bstrClusterFQN
          );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Extract the label from the fully-qualified cluster name for further checks.
    //

    hr = HrExtractPrefixFromFQN( bstrClusterFQN, &bstrClusterLabel );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Enforce more stringent rules for cluster name labels than those for plain hostnames;
    //  also, disallow an IP address as the cluster's name to create.
    //
    
    hr = HrValidateClusterNameLabel( bstrClusterLabel, true );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Obtain cluster's domain for use with non-fully-qualified node names.
    //

    hr = HrFindDomainInFQN( bstrClusterFQN, &idxClusterDomain );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    //
    // Get the cluster cookie.
    // This also starts the middle-tier searching for the specified cluster.
    //

    hr = m_pom->FindObject(
                  CLSID_ClusterConfigurationType
                , NULL
                , bstrClusterFQN
                , DFGUID_ClusterConfigurationInfo
                , &m_cookieCluster
                , &punk // dummy
                );
    _ASSERTE( punk == NULL );
    if ( hr == MAKE_HRESULT( 0, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE ) )
    {
        hr = S_OK;  // ignore it - we could be forming
    }
    else if ( hr == E_PENDING )
    {
        hr = S_OK;  // ignore it - we just want the cookie!
    }
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( punk != NULL )
    {
        punk->Release();
        punk = NULL;
    }

    //
    // Get the task manager.
    //

    hr = m_psp->QueryService(
                  CLSID_TaskManager
                , IID_ITaskManager
                , reinterpret_cast< void ** >( &m_ptm )
                );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create a new Analyze task.
    //

    if ( fMinConfigIn )
    {
        pTaskGUID = const_cast< GUID * >( &TASK_AnalyzeClusterMinConfig );
    } // if:
    else
    {
        pTaskGUID = const_cast< GUID * >( &TASK_AnalyzeCluster );
    } // else:

    // Create the task.
    hr = m_ptm->CreateTask( *pTaskGUID, &punk );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Get the task's interface.
    hr = punk->QueryInterface( IID_ITaskAnalyzeCluster, reinterpret_cast< void ** >( &m_ptac ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Set a cookie to the cluster into the task.
    hr = m_ptac->SetClusterCookie( m_cookieCluster );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Set the node as a child of the cluster.
    // This also starts the middle-teir searching for the specified node.
    //

    hr = HrMakeFQN(
            pcszNodeNameIn
          , bstrClusterFQN + idxClusterDomain  // Default to cluster's domain.
          , true // Accept non-RFC chars.
          , &bstrNodeFQN
          );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = m_pom->FindObject(
                  CLSID_NodeType
                , m_cookieCluster
                , bstrNodeFQN
                , DFGUID_NodeInformation
                , &cookieNode
                , &punk // dummy
                );
    if ( hr == E_PENDING )
    {
        hr = S_OK;  // ignore it - we just want the cookie!
    }
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( punk != NULL )
    {
        punk->Release();
        punk = NULL;
    }

    //
    // Execute the Analyze task and wait for it to complete.
    //

    strMsg.LoadString( IDS_CLUSCFG_ANALYZING );
    wprintf( L"\n%ls", (LPCWSTR) strMsg );

    hr = m_ptac->BeginTask();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the cluster configuration object interface
    // and indicate that we are forming.
    //

    // Get a punk from the cookie.
    hr = m_pom->GetObject(
                      DFGUID_ClusterConfigurationInfo
                    , m_cookieCluster
                    , &punk
                    );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Query for the IClusCfgClusterInfo interface.
    hr = punk->QueryInterface(
                      IID_IClusCfgClusterInfo
                    , reinterpret_cast< void ** >( &pccci )
                    );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    punk->Release();
    punk = NULL;

    // Indicate that we are creating a cluster
    hr = pccci->SetCommitMode( cmCREATE_CLUSTER );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Set the network information.
    //

    // Specify the IP address info.
    dwStatus = ClRtlTcpipStringToAddress( pcwszIPAddressIn, &ulIPAddress );
    if ( dwStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        goto Cleanup;
    }

    hr = pccci->SetIPAddress( ulIPAddress );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( ( pcwszIPSubnetIn != NULL )
      && ( *pcwszIPSubnetIn != L'\0' ) )
    {
        // Set the subnet mask.
        dwStatus = ClRtlTcpipStringToAddress( pcwszIPSubnetIn, &ulIPSubnet );
        if ( dwStatus != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwStatus );
            goto Cleanup;
        }

        hr = pccci->SetSubnetMask( ulIPSubnet );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Find the network object for the specified network.
        _ASSERTE( pcwszNetwork != NULL );
        hr = HrFindNetwork( cookieNode, pcwszNetworkIn, &pccni );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Set the network.
        hr = pccci->SetNetworkInfo( pccni );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: subnet was specified
    else
    {
        // Find a matching subnet mask and network.
        hr = HrMatchNetworkInfo( cookieNode, ulIPAddress, &ulIPSubnet, &pccni );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Set the subnet mask.
        hr = pccci->SetSubnetMask( ulIPSubnet );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Set the network.
        hr = pccci->SetNetworkInfo( pccni );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // else: no subnet specified

    //
    // Set service account credentials.
    //

    // Get the credentials object.
    hr = pccci->GetClusterServiceAccountCredentials( &pccc );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Set the new credentials.
    hr = crencbstrPasswordIn.HrGetBSTR( &bstrPassword );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = pccc->SetCredentials( pcszUserAccountIn, pcszUserDomainIn, bstrPassword );
    CEncryptedBSTR::SecureZeroBSTR( bstrPassword );
    TraceMemoryDelete( bstrPassword, false );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Create the Commit Cluster Changes task.
    //

    // Create the task.
    hr = m_ptm->CreateTask( TASK_CommitClusterChanges, &punk );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Get the task's interface.
    hr = punk->QueryInterface( IID_ITaskCommitClusterChanges, reinterpret_cast< void ** >( &m_ptccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Set a cookie to the cluster into the task.
    hr = m_ptccc->SetClusterCookie( m_cookieCluster );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // (jfranco, bug 352181)
    // Reset the proper codepage to use for CRT routines.
    // KB: somehow the locale gets screwed up in the preceding code.  Don't know why, but this fixes it.
    //
    MatchCRTLocaleToConsole( ); // okay to proceed if this fails?
    
    //
    // Create the cluster.
    //

    strMsg.LoadString( IDS_CLUSCFG_CREATING );
    wprintf( L"\n%ls", (LPCWSTR) strMsg );

    m_fTaskDone = FALSE;    // reset before commiting task

    hr = m_ptccc->BeginTask();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( ! FAILED( hr ) )
    {
        strMsg.LoadString( IDS_CLUSCFG_DONE );
        wprintf( L"\n%ls", (LPCWSTR) strMsg );
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pccc != NULL )
    {
        pccc->Release();
    }
    if ( pcp != NULL )
    {
        if ( dwAdviseCookie != 0 )
        {
            pcp->Unadvise( dwAdviseCookie );
        }

        pcp->Release( );
    }

    SysFreeString( bstrNodeFQN );
    SysFreeString( bstrClusterLabel );
    SysFreeString( bstrClusterFQN );
    SysFreeString( bstrPassword );

    wprintf( L"\n" );

    return hr;

} //*** CCreateCluster::HrCreateCluster

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateCluster::HrInvokeWizard
//
//  Description:
//      Invoke the New Server Cluster Wizard to create a cluster.
//
//  Arguments:
//      pcszClusterNameIn
//      pcszNodeNameIn
//      pcszUserAccountIn
//      pcszUserDomainIn
//      crencbstrPasswordIn
//      pcwszIPAddressIn
//      fMinCOnfigIn
//
//  Return Values:
//      S_OK    - Operations completed successfully.
//      ERROR_CANCELLED - User cancelled the wizard (returned as an HRSULT).
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateCluster::HrInvokeWizard(
      LPCWSTR                   pcszClusterNameIn
    , LPCWSTR                   pcszNodeNameIn
    , LPCWSTR                   pcszUserAccountIn
    , LPCWSTR                   pcszUserDomainIn
    , const CEncryptedBSTR &    crencbstrPasswordIn
    , LPCWSTR                   pcwszIPAddressIn
    , BOOL                      fMinConfigIn
    )
{
    HRESULT                         hr          = S_OK;
    IClusCfgCreateClusterWizard *   piWiz       = NULL;
    VARIANT_BOOL                    fCommitted  = VARIANT_FALSE;
    BSTR                            bstr        = NULL;

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance(
              CLSID_ClusCfgCreateClusterWizard
            , NULL
            , CLSCTX_INPROC_SERVER
            , IID_IClusCfgCreateClusterWizard
            , (LPVOID *) &piWiz
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Set the minconfig state.
    hr = piWiz->put_MinimumConfiguration( ( fMinConfigIn ? VARIANT_TRUE : VARIANT_FALSE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Set the cluster name.
    if ( ( pcszClusterNameIn != NULL )
      && ( *pcszClusterNameIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszClusterNameIn );
        if ( bstr == NULL )
        {
            goto OutOfMemory;
        }

        hr = piWiz->put_ClusterName( bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SysFreeString( bstr );
        bstr = NULL;
    } // if: cluster name specified

    // Set the node name.
    if ( ( pcszNodeNameIn != NULL )
      && ( *pcszNodeNameIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszNodeNameIn );
        if ( bstr == NULL )
        {
            goto OutOfMemory;
        }

        hr = piWiz->put_FirstNodeInCluster( bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SysFreeString( bstr );
        bstr = NULL;
    } // if: node name specified

    // Set the service account name.
    if ( ( pcszUserAccountIn != NULL )
      && ( *pcszUserAccountIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszUserAccountIn );
        if ( bstr == NULL )
        {
            goto OutOfMemory;
        }

        hr = piWiz->put_ServiceAccountName( bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SysFreeString( bstr );
        bstr = NULL;
    } // if: service account name specified

    // Set the service account password.
    if ( crencbstrPasswordIn.IsEmpty() == FALSE )
    {
        hr = crencbstrPasswordIn.HrGetBSTR( &bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = piWiz->put_ServiceAccountPassword( bstr );
        CEncryptedBSTR::SecureZeroBSTR( bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        TraceSysFreeString( bstr );
        bstr = NULL;
    } // if: service account password specified

    // Set the service account domain.
    if ( ( pcszUserDomainIn != NULL )
      && ( *pcszUserDomainIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszUserDomainIn );
        if ( bstr == NULL )
        {
            goto OutOfMemory;
        }

        hr = piWiz->put_ServiceAccountDomain( bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SysFreeString( bstr );
        bstr = NULL;
    } // if: service account domain specified

    // Set the IP address.
    if ( ( pcwszIPAddressIn != NULL )
      && ( *pcwszIPAddressIn != L'\0' ) )
    {
        bstr = SysAllocString( pcwszIPAddressIn );
        if ( bstr == NULL )
        {
            goto OutOfMemory;
        }

        hr = piWiz->put_ClusterIPAddress( bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SysFreeString( bstr );
        bstr = NULL;
    } // if: IP address specified

    // Display the wizard.
    hr = piWiz->ShowWizard( 0, &fCommitted );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
        
    if ( fCommitted == VARIANT_FALSE )
    {
        hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
    }

    goto Cleanup;

OutOfMemory:

    hr = E_OUTOFMEMORY;

Cleanup:
    if ( piWiz != NULL )
    {
        piWiz->Release();
    }

    SysFreeString( bstr );

    return hr;

} //*** CCreateCluster::HrInvokeWizard

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateCluster::HrFindNetwork
//
//  Description:
//      Find the network interface for the specified network.
//
//  Arguments:
//      cookieNodeIn
//      pcwszNetworkIn
//      ppcniOut
//
//  Return Values:
//      S_OK    - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateCluster::HrFindNetwork(
      OBJECTCOOKIE              cookieNodeIn
    , LPCWSTR                   pcwszNetworkIn
    , IClusCfgNetworkInfo **    ppccniOut
    )
{
    HRESULT                 hr      = S_OK;
    IUnknown *              punk    = NULL;
    IEnumClusCfgNetworks *  peccn   = NULL;
    IClusCfgNetworkInfo *   pccni   = NULL;
    OBJECTCOOKIE            cookieDummy;
    CComBSTR                combstr;
    ULONG                   celtDummy;
    size_t                  cchName;

    _ASSERTE( m_pom != NULL );

    //
    // Get the network enumerator.
    //
    hr = E_PENDING;
    while ( hr == E_PENDING )
    {
        hr = m_pom->FindObject(
                      CLSID_NetworkType
                    , cookieNodeIn
                    , NULL
                    , DFGUID_EnumManageableNetworks
                    , &cookieDummy
                    , &punk
                    );
        if ( hr == E_PENDING )
        {
            Sleep( 1000 );  // 1 second
            if ( punk != NULL )
            {
                punk->Release();
                punk = NULL;
            }
            continue;
        }
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // while: pending

    // Query for the IEnumClusCfgNetworks interface.
    hr = punk->QueryInterface(
                      IID_IEnumClusCfgNetworks
                    , reinterpret_cast< LPVOID * >( &peccn )
                    );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    punk->Release();
    punk = NULL;

    //
    // Loop through each network looking for one that matches the
    // one specified.
    //
    for ( ;; )
    {
        // Get the next network.
        hr = peccn->Next( 1, &pccni, &celtDummy );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        if ( hr == S_FALSE )
        {
            break;
        }

        // Get the name of the network.
        hr = pccni->GetName( &combstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        cchName = SysStringLen( combstr );
        if ( ClRtlStrNICmp( combstr, pcwszNetworkIn, cchName ) == 0 )
        {
            // Check to see if this is a public network or not.
            hr = pccni->IsPublic();
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            if ( hr == S_FALSE )
            {
                // Display an error message.
            } // if: not a public network

            *ppccniOut = pccni;
            pccni->AddRef();
            break;
        } // if: found a match
    } // forever

Cleanup:
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    return hr;

} //*** CCreateCluster::HrFindNetwork

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateCluster::HrMatchNetworkInfo
//
//  Description:
//      Match an IP address with a network and subnet mask.
//
//  Arguments:
//      cookieNodeIn
//      ulIPAddressIn
//      pulIPSubnetOut
//      ppccniOut
//
//  Return Values:
//      S_OK    - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCreateCluster::HrMatchNetworkInfo(
      OBJECTCOOKIE              cookieNodeIn
    , ULONG                     ulIPAddressIn
    , ULONG *                   pulIPSubnetOut
    , IClusCfgNetworkInfo **    ppccniOut
    )
{
    HRESULT                 hr      = S_OK;
    IUnknown *              punk    = NULL;
    IEnumClusCfgNetworks *  peccn   = NULL;
    IClusCfgNetworkInfo *   pccni   = NULL;
    IClusCfgIPAddressInfo * pccipai = NULL;
    OBJECTCOOKIE            cookieDummy;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;
    ULONG                   celtDummy;

    _ASSERTE( m_pom != NULL );

    //
    // Get the network enumerator.
    //
    hr = E_PENDING;
    while ( hr == E_PENDING )
    {
        hr = m_pom->FindObject(
                      CLSID_NetworkType
                    , cookieNodeIn
                    , NULL
                    , DFGUID_EnumManageableNetworks
                    , &cookieDummy
                    , &punk
                    );
        if ( hr == E_PENDING )
        {
            Sleep( 1000 );  // 1 second
            if ( punk != NULL )
            {
                punk->Release();
                punk = NULL;
            }
            continue;
        }
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // while: pending

    // Query for the IEnumClusCfgNetworks interface.
    hr = punk->QueryInterface(
                      IID_IEnumClusCfgNetworks
                    , reinterpret_cast< LPVOID * >( &peccn )
                    );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    punk->Release();
    punk = NULL;

    //
    // Loop through each network looking for one that matches the
    // IP address specified.
    //
    for ( ;; )
    {
        // Get the next network.
        hr = peccn->Next( 1, &pccni, &celtDummy );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        if ( hr == S_FALSE )
        {
            hr = HRESULT_FROM_WIN32( ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP );
            goto Cleanup;
        } // if: no match found

        // If this is a public network, check its address and subnet.
        hr = pccni->IsPublic();
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        if ( hr == S_OK )
        {
            // Get the IP Address Info for the network.
            hr = pccni->GetPrimaryNetworkAddress( &pccipai );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            // Get the address and subnet of the network.
            hr = pccipai->GetIPAddress( &ulIPAddress );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            hr = pccipai->GetSubnetMask( &ulIPSubnet );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            // Determine if these match.
            if ( ClRtlAreTcpipAddressesOnSameSubnet( ulIPAddressIn, ulIPAddress, ulIPSubnet ) )
            {
                *pulIPSubnetOut = ulIPSubnet;
                *ppccniOut = pccni;
                (*ppccniOut)->AddRef();
                break;
            } // if: IP address matches network
        } // if: network is public

    } // forever

Cleanup:
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pccipai != NULL )
    {
        pccipai->Release();
    }

    if ( *ppccniOut == NULL )
    {
    } // if: no match was found

    return hr;

} //*** CCreateCluster::HrMatchNetworkInfo

//****************************************************************************
//
//  class CAddNodesToCluster
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesToCluster::HrAddNodesToCluster
//
//  Description:
//      Add nodes to a cluster and display output on the console.
//
//  Arguments:
//      fVerboseIn
//      fMinConfigIn
//      pcszClusterNameIn
//      rgbstrNodesIn
//      cNodesIn
//      crencbstrPasswordIn
//      fInteractIn
//
//  Return Values:
//      S_OK    - Operation completed successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAddNodesToCluster::HrAddNodesToCluster(
      BOOL                      fVerboseIn
    , BOOL                      fMinConfigIn
    , LPCWSTR                   pcszClusterNameIn
    , BSTR                      rgbstrNodesIn[]
    , DWORD                     cNodesIn
    , const CEncryptedBSTR &    crencbstrPasswordIn
    , BOOL                      fInteractIn
    )
{
    HRESULT                 hr      = S_OK;
    IUnknown *              punk    = NULL;
    IClusCfgClusterInfo *   pccci   = NULL;
    IClusCfgCredentials *   pccc    = NULL;
    IConnectionPoint *      pcp     = NULL;
    OBJECTCOOKIE            cookieNode;
    DWORD                   dwAdviseCookie = 0;
    CString                 strMsg;
    DWORD                   idxNode;
    BSTR                    bstrUserAccount     = NULL;
    BSTR                    bstrUserDomain      = NULL;
    BSTR                    bstrUserPassword    = NULL;
    BSTR                    bstrClusterDomain = NULL;
    BSTR                    bstrClusterFQN = NULL;
    BSTR                    bstrNodeFQN = NULL;
    GUID *                  pTaskGUID = NULL;

    UNREFERENCED_PARAMETER( fInteractIn );

    m_fVerbose = fVerboseIn;

    //
    // Summarize what we are doing.
    //

    strMsg.FormatMessage(
          IDS_CLUSCFG_PREPARING_TO_ADD_NODES
        , pcszClusterNameIn
        );
    wprintf( L"%ls", (LPCWSTR) strMsg );
    for ( idxNode = 0 ; idxNode < cNodesIn ; idxNode++ )
    {
        strMsg.FormatMessage(
                  IDS_CLUSCFG_PREPARING_TO_ADD_NODES_2
                , rgbstrNodesIn[ idxNode ]
                );
        wprintf( L"\n%ls", (LPCWSTR) strMsg );
    } // for: each node

    if ( fMinConfigIn )
    {
        if ( strMsg.LoadString( IDS_CLUSCFG_MIN_CONFIG_ADD_NODES ) )
        {
            wprintf( L"\n%ls", (LPCWSTR) strMsg );
        } // if:
    } // if:

    //
    // Get the service manager.
    //

    hr = CoCreateInstance(
                  CLSID_ServiceManager
                , NULL
                , CLSCTX_INPROC_SERVER
                , IID_IServiceProvider
                , reinterpret_cast< void ** >( &m_psp )
                );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the object manager.
    //

    hr = m_psp->QueryService(
                  CLSID_ObjectManager
                , IID_IObjectManager
                , reinterpret_cast< void ** >( &m_pom )
                );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the notification manager.
    //

    hr = m_psp->QueryService(
                  CLSID_NotificationManager
                , IID_IConnectionPointContainer
                , reinterpret_cast< void ** >( &m_pcpc )
                );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Set the callback interface so the middle tier can report errors
    // back to the UI layer, in this case, cluster.exe.
    //

    hr = m_pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) ;
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = pcp->Advise( this, &dwAdviseCookie );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the cluster cookie.
    // This also starts the middle-tier searching for the specified cluster.
    //

    hr = HrGetClusterDomain( pcszClusterNameIn, &bstrClusterDomain );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = HrMakeFQN( pcszClusterNameIn, bstrClusterDomain, true, &bstrClusterFQN );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = m_pom->FindObject(
                  CLSID_ClusterConfigurationType
                , NULL
                , bstrClusterFQN
                , DFGUID_ClusterConfigurationInfo
                , &m_cookieCluster
                , &punk // dummy
                );
    _ASSERTE( punk == NULL );
    if ( hr == MAKE_HRESULT( 0, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE ) )
    {
        hr = S_OK;  // ignore it - we could be forming
    }
    else if ( hr == E_PENDING )
    {
        hr = S_OK;  // ignore it - we just want the cookie!
    }
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( punk != NULL )
    {
        punk->Release();
        punk = NULL;
    }

    //
    // Get the task manager.
    //

    hr = m_psp->QueryService(
                  CLSID_TaskManager
                , IID_ITaskManager
                , reinterpret_cast< void ** >( &m_ptm )
                );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create a new Analyze task.
    //

    if ( fMinConfigIn )
    {
        pTaskGUID = const_cast< GUID * >( &TASK_AnalyzeClusterMinConfig );
    } // if:
    else
    {
        pTaskGUID = const_cast< GUID * >( &TASK_AnalyzeCluster );
    } // else:

    // Create the task.
    hr = m_ptm->CreateTask( *pTaskGUID, &punk );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Get the task's interface.
    hr = punk->QueryInterface( IID_ITaskAnalyzeCluster, reinterpret_cast< void ** >( &m_ptac ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Set a cookie to the cluster into the task.
    hr = m_ptac->SetClusterCookie( m_cookieCluster );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Indicate to the task that we want to join.
    hr = m_ptac->SetJoiningMode();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Set each the node as a child of the cluster.
    // This also starts the middle-teir searching for the specified node.
    //

    for ( idxNode = 0 ; idxNode < cNodesIn ; idxNode++ )
    {
        hr = HrMakeFQN(
                rgbstrNodesIn[ idxNode ]
              , bstrClusterDomain
              , true // Accept non-RFC chars.
              , &bstrNodeFQN
              );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = m_pom->FindObject(
                      CLSID_NodeType
                    , m_cookieCluster
                    , bstrNodeFQN
                    , DFGUID_NodeInformation
                    , &cookieNode
                    , &punk // dummy
                    );
        if ( hr == E_PENDING )
        {
            hr = S_OK;  // ignore it - we just want the cookie!
        }
        else if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( punk != NULL )
        {
            punk->Release();
            punk = NULL;
        }
        
        SysFreeString( bstrNodeFQN );
        bstrNodeFQN = NULL;
    } // for: each node

    //
    // Execute the Analyze task and wait for it to complete.
    //

    strMsg.LoadString( IDS_CLUSCFG_ANALYZING );
    wprintf( L"\n%ls", (LPCWSTR) strMsg );

    hr = m_ptac->BeginTask();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the cluster configuration object interface
    // and indicate that we are joining.
    //

    // Get a punk from the cookie.
    hr = m_pom->GetObject(
                      DFGUID_ClusterConfigurationInfo
                    , m_cookieCluster
                    , &punk
                    );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Query for the IClusCfgClusterInfo interface.
    hr = punk->QueryInterface(
                      IID_IClusCfgClusterInfo
                    , reinterpret_cast< void ** >( &pccci )
                    );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    punk->Release();
    punk = NULL;

    // Indicate that we are adding a node to the cluster
    hr = pccci->SetCommitMode( cmADD_NODE_TO_CLUSTER );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Set service account credentials.
    //

    // Get the credentials object.
    hr = pccci->GetClusterServiceAccountCredentials( &pccc );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Get the existing credentials.
    hr = pccc->GetIdentity( &bstrUserAccount, &bstrUserDomain );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = crencbstrPasswordIn.HrGetBSTR( &bstrUserPassword );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Set the new credentials.
    hr = pccc->SetCredentials( bstrUserAccount, bstrUserDomain, bstrUserPassword );
    CEncryptedBSTR::SecureZeroBSTR( bstrUserPassword );
    TraceMemoryDelete( bstrUserPassword, false );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Create the Commit Cluster Changes task.
    //

    // Create the task.
    hr = m_ptm->CreateTask( TASK_CommitClusterChanges, &punk );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Get the task's interface.
    hr = punk->QueryInterface( IID_ITaskCommitClusterChanges, reinterpret_cast< void ** >( &m_ptccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Set a cookie to the cluster into the task.
    hr = m_ptccc->SetClusterCookie( m_cookieCluster );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // (jfranco, bug 352182)
    // KB: somehow the locale gets screwed up in the preceding code.  Don't know why, but this fixes it.
    //
    MatchCRTLocaleToConsole( ); // okay to proceed if this fails?
    
    //
    // Add the nodes to the cluster.
    //

    strMsg.LoadString( IDS_CLUSCFG_ADDING_NODES );
    wprintf( L"\n%ls", (LPCWSTR) strMsg );

    m_fTaskDone = FALSE;    // reset before commiting task

    hr = m_ptccc->BeginTask();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( ! FAILED( hr ) )
    {
        strMsg.LoadString( IDS_CLUSCFG_DONE );
        wprintf( L"\n%ls", (LPCWSTR) strMsg );
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccc != NULL )
    {
        pccc->Release();
    }
    if ( pcp != NULL )
    {
        if ( dwAdviseCookie != 0 )
        {
            pcp->Unadvise( dwAdviseCookie );
        }

        pcp->Release( );
    }

    SysFreeString( bstrNodeFQN );
    SysFreeString( bstrClusterFQN );
    SysFreeString( bstrUserAccount );
    SysFreeString( bstrUserDomain );
    SysFreeString( bstrClusterDomain );

    wprintf( L"\n" );

    return hr;

} //*** CAddNodesToCluster::HrAddNodesToCluster

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAddNodesToCluster::HrInvokeWizard
//
//  Description:
//      Invoke the Add Nodes To Cluster Wizard.
//
//  Arguments:
//      pcszClusterNameIn
//      rgbstrNodesIn[]
//      cNodesIn
//      crencbstrPasswordIn
//      fMinConfigIn
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      ERROR_CANCELLED - User cancelled the wizard (returned as an HRSULT).
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAddNodesToCluster::HrInvokeWizard(
      LPCWSTR                   pcszClusterNameIn
    , BSTR                      rgbstrNodesIn[]
    , DWORD                     cNodesIn
    , const CEncryptedBSTR &    crencbstrPasswordIn
    , BOOL                      fMinConfigIn
    )
{
    HRESULT                     hr          = S_OK;
    IClusCfgAddNodesWizard *    piWiz       = NULL;
    VARIANT_BOOL                fCommitted  = VARIANT_FALSE;
    BSTR                        bstr        = NULL;
    DWORD                       iNode = 0;

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance( CLSID_ClusCfgAddNodesWizard, NULL, CLSCTX_INPROC_SERVER, IID_IClusCfgAddNodesWizard, (LPVOID *) &piWiz );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Set the minconfig state.
    hr = piWiz->put_MinimumConfiguration( ( fMinConfigIn? VARIANT_TRUE: VARIANT_FALSE ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Set the cluster name.
    if ( ( pcszClusterNameIn != NULL )
      && ( *pcszClusterNameIn != L'\0' ) )
    {
        bstr = SysAllocString( pcszClusterNameIn );
        if ( bstr == NULL )
        {
            goto OutOfMemory;
        }

        hr = piWiz->put_ClusterName( bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SysFreeString( bstr );
        bstr = NULL;
    } // if: cluster name specified

    // Add each node.
    for ( iNode = 0 ; iNode < cNodesIn ; iNode++ )
    {
        hr = piWiz->AddNodeToList( rgbstrNodesIn[ iNode ] );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: node name specified

    // Set the service account password.
    if ( crencbstrPasswordIn.IsEmpty()  == FALSE )
    {
        hr = crencbstrPasswordIn.HrGetBSTR( &bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = piWiz->put_ServiceAccountPassword( bstr );
        CEncryptedBSTR::SecureZeroBSTR( bstr );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        TraceSysFreeString( bstr );
        bstr = NULL;
    } // if: service account password specified

    // Display the wizard.
    hr = piWiz->ShowWizard( 0, &fCommitted );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
        
    if ( fCommitted == VARIANT_FALSE )
    {
        hr = HRESULT_FROM_WIN32( ERROR_CANCELLED );
    }

    goto Cleanup;

OutOfMemory:

    hr = E_OUTOFMEMORY;

Cleanup:
    if ( piWiz != NULL )
    {
        piWiz->Release();
    }

    SysFreeString( bstr );

    return hr;

} //*** CAddNodesToCluster::HrInvokeWizard
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\cluscmd.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:                                                    
//      ClusCmd.cpp
//
//  Description:
//      Cluster Commands
//      Implements commands which may be performed on clusters.
//
//  Maintained By:
//      David Potter    (DavidP             11-JUL-2001
//      Vijay Vasu (VVasu)                  26-JUL-2000
//      Michael Burton (t-mburt)            04-AUG-1997
//      Charles Stacy Harris III (stacyh)   20-MAR-1997
//
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Resource.h"

#include <clusrtl.h>
#include "cluswrap.h"
#include "cluscmd.h"

#include "cmdline.h"
#include "util.h"
#include "ClusCfg.h"
#include "passwordcmd.h"
#include "QuorumUtils.h"

#include <NameUtil.h>

// For NetServerEnum
#include <lmcons.h>
#include <lmerr.h>
#include <lmserver.h>
#include <lmapibuf.h>


#define SERVER_INFO_LEVEL 101
#define MAX_BUF_SIZE 0x00100000 // 1MB

//zap! Temporary hack until windows.h update
#ifndef SV_TYPE_CLUSTER_NT
#define SV_TYPE_CLUSTER_NT 0x01000000
#endif


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::CClusterCmd
//
//  Description:
//      Constructor.
//
//  Arguments:
//      strClusterName
//          The name of the cluster being administered
//
//      cmdLine
//          CommandLine Object passed from DispatchCommand
//
//      vstrClusterNames
//          Cluster names passewd on the command line.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterCmd::CClusterCmd(
      const CString &               strClusterName
    , CCommandLine &                cmdLine
    , const vector < CString > &    vstrClusterNames
    )
    : m_strClusterName( strClusterName )
    , m_vstrClusterNames( vstrClusterNames )
    , m_theCommandLine( cmdLine )
    , m_hCluster( NULL )
{
} //*** CClusterCmd::CClusterCmd

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::~CClusterCmd
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterCmd::~CClusterCmd( void )
{
    CloseCluster();

} //*** CClusterCmd::~CClusterCmd

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScOpenCluster
//
//  Description:
//      Opens the cluster specified in the constructor
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hCluster                  SET
//      m_strClusterName            Specifies cluster name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScOpenCluster( void )
{
    DWORD   sc = ERROR_SUCCESS;

    if ( m_hCluster != NULL )
    {
        sc = ERROR_SUCCESS;
        goto Cleanup;
    }

    m_hCluster = ::OpenCluster( m_strClusterName );
    if ( m_hCluster == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

Cleanup:

    return sc;

} //*** CClusterCmd::ScOpenCluster

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::CloseCluster
//
//  Description:
//      Closes the cluster specified in the constructor
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hCluster
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CClusterCmd::CloseCluster( void )
{
    if ( m_hCluster )
    {
        ::CloseCluster( m_hCluster );
        m_hCluster = 0;
    }

} //*** CClusterCmd::CloseCluster



/////////////////////////////////////////////////////////////////////////////
//++
//
//  ParseParametersForChangePasswordOption
//
//  Description:
//      Parse parameters for change password option.
//
//  Arguments:
//      cpfFlags
//          Pointer to flag which encodes already parsed parameters for change password option.
//
//      thisOption
//          Contains the type, values and arguments of this option.
// 
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void 
ParseParametersForChangePasswordOption(
    int * mcpfFlags
  , const CCmdLineOption & thisOption
                              )
{
    const vector< CCmdLineParameter > & vclpParamList  = thisOption.GetParameters();
    CSyntaxException                    se( MSG_SEE_PASSWORD_HELP );
    DWORD                               idx;

    for ( idx = 0 ; idx < vclpParamList.size() ; idx++ )
    {
        switch ( vclpParamList[ idx ].GetType() )
        {
            case paramQuiet:
            {
               *mcpfFlags |= cpfQUIET_FLAG;
               break;
            }
            case paramSkipDC:
            {
               *mcpfFlags |= cpfSKIPDC_FLAG;
               break;
            }
            case paramTest:
            {
               *mcpfFlags |= cpfTEST_FLAG;
               break;
            }
            case paramVerbose:
            {
               *mcpfFlags |= cpfVERBOSE_FLAG;
               break;
            }
            case paramUnattend:
            {
               *mcpfFlags |= cpfUNATTEND_FLAG;
               break;
            }
            default:
            {
               se.LoadMessage( MSG_INVALID_PARAMETER, vclpParamList[ idx ].GetName() );
               throw se;
            }
        } // switch
    } // for 

} // ParseParametersForChangePasswordOption()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::Execute
//
//  Description:
//      Takes tokens from the command line and calls the appropriate
//      handling functions
//
//  Arguments:
//      None.
//
//  Return Value:
//      Whatever is returned by dispatched functions
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::Execute( void )
{
    DWORD   sc = ERROR_SUCCESS;

    m_theCommandLine.ParseStageTwo();

    const vector< CCmdLineOption > & vcloOptionList = m_theCommandLine.GetOptions();
    vector< CCmdLineOption >::const_iterator itCurOption  = vcloOptionList.begin();
        
    if ( vcloOptionList.empty() )
    {
        sc = ScPrintHelp();
        goto Cleanup;
    }

    // Process one option after another.
    while ( ( itCurOption != vcloOptionList.end() ) && ( sc == ERROR_SUCCESS ) )
    {
        // Look up the command
        switch( itCurOption->GetType() )
        {
            case optHelp:
            {
                // If help is one of the options, process no more options.
                sc = ScPrintHelp();
                goto Cleanup;
            }

            case optVersion:
            {
                sc = ScPrintClusterVersion( *itCurOption );
                break;
            }

            case optList:
            {
                sc = ScListClusters( *itCurOption );
                break;
            }

            case optRename:
            {
                sc = ScRenameCluster( *itCurOption );
                break;
            }

            case optQuorumResource:
            {
                sc = ScQuorumResource( *itCurOption );
                break;
            }

            case optProperties:
            {
                sc = ScDoProperties( *itCurOption, COMMON );
                break;
            }

            case optPrivateProperties:
            {
                sc = ScDoProperties( *itCurOption, PRIVATE );
                break;
            }

            case optChangePassword:
            {
                int                                      mcpfFlags = 0;
                vector< CCmdLineOption >::const_iterator itCurOptionSaved =  itCurOption;

                while ( ++itCurOption != vcloOptionList.end() )
                {
                   switch ( itCurOption->GetType() ) 
                   {
                       case optForceCleanup:
                       {
                           mcpfFlags = cpfFORCE_FLAG;   
                           ParseParametersForChangePasswordOption(
                                &mcpfFlags
                              , *itCurOption
                                );
                           break;
                       }
                       case optHelp:
                       {
                           sc = PrintMessage( MSG_HELP_CHANGEPASSWORD );
                           goto Cleanup;
                       }
                       default:
                       {
                           CSyntaxException se( MSG_SEE_PASSWORD_HELP );
                           se.LoadMessage( IDS_INVALID_OPTION, itCurOption->GetName() );
                           throw se;
                       }
                   } //switch
                }  // while

                sc = ScChangePassword( 
                             m_vstrClusterNames
                           , *itCurOptionSaved
                           , mcpfFlags 
                           );
                goto Cleanup;
            }

            case optListNetPriority:
            {
                sc = ScListNetPriority( *itCurOption, TRUE /* fCheckCmdLineIn */ );
                break;
            }

            case optSetNetPriority:
            {
                sc = ScSetNetPriority( *itCurOption );
                break;
            }

            case optSetFailureActions:
            {
                sc = ScSetFailureActions( *itCurOption );
                break;
            }

            case optRegisterAdminExtensions:
            {
                sc = ScRegUnregAdminExtensions(
                                      *itCurOption
                                    , TRUE // Register the extension
                                    );
                break;
            }

            case optUnregisterAdminExtensions:
            {
                sc = ScRegUnregAdminExtensions(
                                      *itCurOption
                                    , FALSE  // Unregister the extension
                                    );
                break;
            }

            case optCreate:
            {
                sc = HrCreateCluster( *itCurOption );
                break;
            }

            case optAddNodes:
            {
                sc = HrAddNodesToCluster( *itCurOption );
                break;
            }

            default:
            {
                CSyntaxException se;
                se.LoadMessage( IDS_INVALID_OPTION, itCurOption->GetName() );
                throw se;
            }

        } // switch: based on the type of option

        PrintMessage( MSG_OPTION_FOOTER, itCurOption->GetName() );
        ++itCurOption;
    } // for each option in the list

Cleanup:

    return sc;

} //*** CClusterCmd::Execute

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScPrintHelp
//
//  Description:
//      Prints out the help text for this command
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      Same as PrintMessage()
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScPrintHelp( void )
{
    return PrintMessage( MSG_HELP_CLUSTER );

} //*** CClusterCmd::ScPrintHelp

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScPrintClusterVersion
//
//  Description:
//      Prints out the version of the cluster
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScPrintClusterVersion( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD               sc = ERROR_SUCCESS;
    LPWSTR              pszName = NULL;
    CLUSTERVERSIONINFO  clusinfo;


    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    sc = ScOpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Assert( m_hCluster != NULL );

    clusinfo.dwVersionInfoSize = sizeof( clusinfo );

    sc = WrapGetClusterInformation( m_hCluster, &pszName, &clusinfo );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    PrintMessage(
          MSG_CLUSTER_VERSION
        , pszName
        , clusinfo.MajorVersion
        , clusinfo.MinorVersion
        , clusinfo.BuildNumber
        , clusinfo.szCSDVersion
        , clusinfo.szVendorId
        );

Cleanup:

    LocalFree( pszName );

    return sc;

} //*** CClusterCmd::ScPrintClusterVersion

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScListClusters
//
//  Description:
//      Lists all of the clusters on the network.
//      Optionally limit to a specific domain.
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//  Note:
//      zap! Must deal with buffer too small issue.
//      zap! Does NetServerEnum return ERROR_MORE_DATA or Err_BufTooSmall?
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScListClusters( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD               sc = ERROR_SUCCESS;
    DWORD               idx;
    LPCWSTR             pcszDomainName;
    SERVER_INFO_101 *   pServerInfoList = NULL;
    DWORD               cReturnCount = 0;
    DWORD               cTotalServers = 0;

    const vector< CString > & vstrValueList = thisOption.GetValues();

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // This option takes at most one parameter.
    if ( vstrValueList.size() > 1 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    if ( vstrValueList.size() == 0 )
    {
        pcszDomainName = NULL;
    }
    else
    {
        pcszDomainName = vstrValueList[ 0 ];
    }

    sc = NetServerEnum(
              0                             // servername = where command executes 0 = local
            , SERVER_INFO_LEVEL             // level = type of structure to return.
            , (LPBYTE *) &pServerInfoList   // bufptr = returned array of server info structures
            , MAX_BUF_SIZE                  // prefmaxlen = preferred max of returned data
            , &cReturnCount                 // entriesread = number of enumerated elements returned
            , &cTotalServers                // totalentries = total number of visible machines on the network
            , SV_TYPE_CLUSTER_NT            // servertype = filters the type of info returned
            , pcszDomainName                // domain = domain to limit search
            , 0                             // resume handle
            );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    if ( cReturnCount != 0 )
    {
        PrintMessage( MSG_CLUSTER_HEADER );
        for ( idx = 0 ; idx < cReturnCount ; idx++ )
        {
            PrintMessage( MSG_CLUSTER_DETAIL, pServerInfoList[ idx ].sv101_name );
        }
    }

Cleanup:

    if ( pServerInfoList != NULL )
    {
        NetApiBufferFree( pServerInfoList );
    }

    return sc;

} //*** CClusterCmd::ScListClusters

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScRenameCluster
//
//  Description:
//      Renames the cluster to the specified name
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      Same as SetClusterName
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScRenameCluster( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;

    const vector< CString > & vstrValueList = thisOption.GetValues();

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // This option takes exactly one value.
    if ( vstrValueList.size() != 1 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    CString strNewName = vstrValueList[ 0 ];

    sc = ScOpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Assert( m_hCluster != NULL );

    sc = SetClusterName( m_hCluster, strNewName );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

Cleanup:

    return sc;

} //*** CClusterCmd::ScRenameCluster

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScQuorumResource
//
//  Description:
//      Sets or Prints the Quorum resource
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScQuorumResource( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;

    const vector< CString > & vstrValueList = thisOption.GetValues();

    // This option takes at most one value.
    if ( vstrValueList.size() > 1 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_ONLY_ONE_VALUE, thisOption.GetName() );
        throw se;
    }

    sc = ScOpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Assert( m_hCluster != NULL );

    if ( ( vstrValueList.size() == 0 ) && ( thisOption.GetParameters().size() == 0 ) )
    {
        sc = ScPrintQuorumResource();
    }
    else
    {
        if ( vstrValueList.size() == 0 )
        {
            sc = ScSetQuorumResource( L"", thisOption );
        }
        else
        {
            sc = ScSetQuorumResource( vstrValueList[ 0 ], thisOption );
        }
    }

Cleanup:
    return sc;

} //*** CClusterCmd::ScQuorumResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScPrintQuorumResource
//
//  Description:
//      Prints the quorum resource
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//      m_strClusterName            Specifies cluster name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScPrintQuorumResource( void )
{
    DWORD   sc = ERROR_SUCCESS;

    LPWSTR  pszResourceName = NULL;
    LPWSTR  pszDevicePath = NULL;
    DWORD   dwMaxLogSize = 0;

    // Assert( m_hCluster != NULL );

    // Print the quorum resource information and return.
    sc = WrapGetClusterQuorumResource(
              m_hCluster
            , &pszResourceName
            , &pszDevicePath
            , &dwMaxLogSize
            );

    if ( sc == ERROR_SUCCESS )
    {
        sc = PrintMessage( MSG_QUORUM_RESOURCE, pszResourceName, pszDevicePath, dwMaxLogSize );
    }

    LocalFree( pszResourceName );
    LocalFree( pszDevicePath );

    return sc;

} //*** CClusterCmd::ScPrintQuorumResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScSetQuorumResource
//
//  Description:
//      Sets the quorum resource
//
//  Arguments:
//      pszResourceName
//          The name of the resource

//      thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScSetQuorumResource(
      LPCWSTR                   pszResourceName
    , const CCmdLineOption &    thisOption
    )
    throw( CSyntaxException )
{
    DWORD       sc = ERROR_SUCCESS;
    HRESOURCE   hResource = NULL;
    LPWSTR      pszDevicePath = NULL;
    LPWSTR      pszTempResourceName = NULL;
    CString     strResourceName( pszResourceName );
    CString     strDevicePath;
    DWORD       cchDevicePath;
    CString     strRootPath;
    DWORD       cchRootPath;
    CString     strMaxLogSize;
    DWORD       dwMaxLogSize = 0;
    BOOL        bPathFound = FALSE;
    BOOL        bSizeFound = FALSE;

    // Assert( m_hCluster != NULL );

    const vector< CCmdLineParameter > &         vclpParamList = thisOption.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam    = vclpParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLastParam   = vclpParamList.end();

    while ( itCurParam != itLastParam )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch( itCurParam->GetType() )
        {
            case paramPath:
                // Each of the parameters must have exactly one value.
                if ( vstrValueList.size() != 1 )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }

                if ( bPathFound != FALSE )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                strDevicePath = vstrValueList[ 0 ];
                bPathFound = TRUE;
                break;

            case paramMaxLogSize:
                // Each of the parameters must have exactly one value.
                if ( vstrValueList.size() != 1 )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }

                if ( bSizeFound != FALSE )
                {
                    CSyntaxException se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                strMaxLogSize = vstrValueList[ 0 ];

                bSizeFound = TRUE;
                break;

            default:
            {
                CSyntaxException se;
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }
        }

        ++itCurParam;
    } // while: more parameters

    if (    strResourceName.IsEmpty()
        &&  strDevicePath.IsEmpty()
        &&  strMaxLogSize.IsEmpty()
        )
    {
        CSyntaxException se;
        se.LoadMessage( IDS_MISSING_PARAMETERS );
        throw se;
    }

    //
    // Get Default values
    //
    sc = WrapGetClusterQuorumResource(
                  m_hCluster
                , &pszTempResourceName
                , &pszDevicePath
                , &dwMaxLogSize
                );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    // Get default resource name.
    //
    if ( strResourceName.IsEmpty() )
    {
        // The argument to this function is a non empty resource name.
        // Use the resource name got from the WrapGetClusterQuorumResource
        // call.
        strResourceName = pszTempResourceName;
    }

    //
    // Open a handle to the resource.
    //
    hResource = OpenClusterResource( m_hCluster, strResourceName );
    if ( hResource == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    if ( strDevicePath.IsEmpty() )
    {
        //
        // The device path parameter has not been specified.
        // Parse out the current root path and append it to the first
        // partition from the specified resource.
        //
        cchDevicePath = MAX_PATH;   // Select a reasonable value (MAX_PATH == 260, windef.h).
        cchRootPath = MAX_PATH;     // Select a reasonable value (MAX_PATH == 260, windef.h).
        sc = SplitRootPath( 
                      m_hCluster
                    , strDevicePath.GetBuffer( cchDevicePath )
                    , &cchDevicePath
                    , strRootPath.GetBuffer( cchRootPath )
                    , &cchRootPath
                    );
        strDevicePath.ReleaseBuffer();
        strRootPath.ReleaseBuffer();

        if ( sc == ERROR_MORE_DATA )
        {
            // Try again.
            sc = SplitRootPath( 
                          m_hCluster
                        , strDevicePath.GetBuffer( cchDevicePath )
                        , &cchDevicePath
                        , strRootPath.GetBuffer( cchRootPath )
                        , &cchRootPath
                        );
            strDevicePath.ReleaseBuffer();
            strRootPath.ReleaseBuffer();
        }

        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        //
        // We have the root path, now construct the full path.
        //
        sc = ConstructQuorumPath( 
                      hResource
                    , strRootPath.GetBuffer( cchRootPath )
                    , strDevicePath.GetBuffer( cchDevicePath )
                    , &cchDevicePath 
                    ); 

        strRootPath.ReleaseBuffer();
        strDevicePath.ReleaseBuffer();

        if ( sc == ERROR_MORE_DATA )
        {
            // Try again.
            sc = ConstructQuorumPath( 
                          hResource
                        , strRootPath.GetBuffer( cchRootPath )
                        , strDevicePath.GetBuffer( cchDevicePath )
                        , &cchDevicePath 
                        ); 

            strRootPath.ReleaseBuffer();
            strDevicePath.ReleaseBuffer();
        }

        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }

    if ( ! strMaxLogSize.IsEmpty() )
    {
        sc = MyStrToDWORD( strMaxLogSize, &dwMaxLogSize );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        dwMaxLogSize *= 1024; // Expressed in kb
    }

    sc = SetClusterQuorumResource( hResource, strDevicePath, dwMaxLogSize );

Cleanup:

    if ( hResource != NULL )
    {
        CloseClusterResource( hResource );
    }

    LocalFree( pszTempResourceName );
    LocalFree( pszDevicePath );

    return sc;

} //*** CClusterCmd::ScSetQuorumResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScChangePassword
//
//  Description:
//      Change cluster service account password.
//
//  Arguments:
//      rvstrClusterNames
//          Contains the name of clusters whose service account password 
//          will be changed.
//
//      thisOption
//          Contains the type, values and arguments of this option.
// 
//      mcpfFlagsIn
//          Flag that encodes already parsed parameters for change password option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      ERROR_INVALID_PASSWORD      user was prompted for the new password and
//                                  a confirmation of the new password, but the
//                                  two didn't match
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScChangePassword(
      const vector< CString > & rvstrClusterNames
    , const CCmdLineOption &    thisOption
    , int mcpfFlagsIn
    )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;

    BOOL    bNewPassword = FALSE;
    WCHAR   wszNewPassword[ 1024 ];
    CString strNewPasswordPrompt;

    WCHAR   wszConfirmNewPassword[ 1024 ];
    CString strConfirmNewPasswordPrompt;
    CString strPasswordMismatch;

    BOOL    bOldPassword = FALSE;
    WCHAR   wszOldPassword[ 1024 ];
    CString strOldPasswordPrompt;
    int     mcpfFlags;

    const vector< CString > &   vstrValueList = thisOption.GetValues();
    CSyntaxException            se;

    // Cluster name not specified.
    if ( rvstrClusterNames.size() == 0 )
    {
        se.LoadMessage( IDS_NO_CLUSTER_NAME );
        throw se;
    }

    mcpfFlags = mcpfFlagsIn;
    ParseParametersForChangePasswordOption( &mcpfFlags , thisOption );

    if ( ( mcpfFlags & cpfTEST_FLAG ) == 0 )
    {
        //
        // Check for too many passwords.
        //

        if ( vstrValueList.size() > 2 )
        {
            se.LoadMessage( MSG_TOO_MANY_PASSWORDS_SPECIFIED_ERROR );
            throw se;
        } // if: too many passwords specified

        //
        //  Can't prompt for passwords if running unattended.
        //
        if ( ( mcpfFlags & cpfUNATTEND_FLAG ) != 0 )
        {
            if ( ( mcpfFlags & cpfSKIPDC_FLAG ) != 0 ) // skipping DC
            {
                if ( vstrValueList.size() == 0 )
                {
                    //
                    //  Need new password when skipping DC.
                    //
                    se.LoadMessage( MSG_UNATTEND_SKIPDC_NEW_PASSWORD );
                    throw se;
                }
            }
            else // not skipping DC
            {
                if ( vstrValueList.size() < 2 )
                {
                    //
                    //  Need both old and new passwords when not skipping DC.
                    //
                    se.LoadMessage( MSG_UNATTEND_NEEDS_BOTH_PASSWORDS );
                    throw se;
                }
            }
        } // if: running unattended
        
        //
        // If no old password was specified, prompt for it.
        //

        if ( vstrValueList.size() < 2 )
        {
            if ( ( mcpfFlags & cpfSKIPDC_FLAG ) == 0 ) 
            {  // Do not skip DC
                // Get the old password.
                strOldPasswordPrompt.LoadString( IDS_OLD_PASSWORD_PROMPT );
                wprintf( L"%ls: ", (LPCWSTR) strOldPasswordPrompt );
                sc = ScGetPassword( wszOldPassword,  RTL_NUMBER_OF( wszOldPassword ) );
                if ( sc != ERROR_SUCCESS )
                {
                    goto Cleanup;
                }
                bOldPassword = TRUE;
            }
            else
            {  // skip DC
                bOldPassword = TRUE;
                wszOldPassword[ 0 ] = L'\0';
            }
        } // if: old password not specified

        //
        // If no new password was specified, prompt for it.
        //

        if ( vstrValueList.size() < 1 )
        {
            // Get the new password.
            strNewPasswordPrompt.LoadString( IDS_NEW_PASSWORD_PROMPT );
            wprintf( L"%ls: ", (LPCWSTR) strNewPasswordPrompt );
            sc = ScGetPassword( wszNewPassword, RTL_NUMBER_OF( wszNewPassword ) );
            if ( sc != ERROR_SUCCESS )
            {
                goto Cleanup;
            }

            strConfirmNewPasswordPrompt.LoadString( IDS_CONFIRM_NEW_PASSWORD_PROMPT );
            wprintf( L"%ls: ", (LPCWSTR) strConfirmNewPasswordPrompt );
            sc = ScGetPassword( wszConfirmNewPassword, RTL_NUMBER_OF( wszConfirmNewPassword ) );
            if ( sc != ERROR_SUCCESS )
            {
                goto Cleanup;
            }

            if ( wcsncmp( wszNewPassword, wszConfirmNewPassword, RTL_NUMBER_OF( wszNewPassword ) ) != 0 ) 
            {
                strPasswordMismatch.LoadString( IDS_PASSWORD_MISMATCH );
                wprintf( L"%ls\n", (LPCWSTR) strPasswordMismatch );
                sc = ERROR_INVALID_PASSWORD;
                goto Cleanup;
            }

            bNewPassword = TRUE;
        } // if: new password not specified
    } //  if: not just testing the change password operations
    else
    {
        bNewPassword = TRUE;
        bOldPassword = TRUE;
        wszNewPassword[ 0 ] = L'\0';
        wszOldPassword[ 0 ] = L'\0';
    } // if: just testing the command

    //
    // Change the password.
    //

    sc = ScChangePasswordEx(
              rvstrClusterNames
            , bNewPassword ? wszNewPassword : (LPCWSTR) vstrValueList[ 0 ] // new password
            , bOldPassword ? wszOldPassword : (LPCWSTR) vstrValueList[ 1 ] // old password
            , mcpfFlags
            );

Cleanup:

    //
    // Zero wszNewPassword and wszOldPassword buffers.  We use these
    // buffers to retrieve the passwords from the command prompt.
    //
    SecureZeroMemory( wszNewPassword, sizeof( wszNewPassword ) );
    SecureZeroMemory( wszOldPassword, sizeof( wszOldPassword ) );

    return sc;

} //*** CClusterCmd::ScChangePassword

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScDoProperties
//
//  Description:
//      Dispatches the property command to either Get or Set properties
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//      ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScDoProperties(
      const CCmdLineOption &    thisOption
    , PropertyType              ePropertyType
    )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;
    
    const vector< CCmdLineParameter > & vclpParamList = thisOption.GetParameters();

    sc = ScOpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Assert( m_hCluster != NULL );

    // If there are no property-value pairs on the command line,
    // then we print the properties otherwise we set them.
    if ( vclpParamList.size() == 0 )
    {
        PrintMessage(
              ePropertyType==PRIVATE ? MSG_PRIVATE_LISTING : MSG_PROPERTY_LISTING
            , (LPCWSTR) m_strClusterName
            );
        PrintMessage( MSG_PROPERTY_HEADER_CLUSTER_ALL );

        sc = ScGetProperties( thisOption, ePropertyType );
    }
    else
    {   
        sc = ScSetProperties( thisOption, ePropertyType );
    }

Cleanup:

    return sc;

} //*** CClusterCmd::ScDoProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScGetProperties
//
//  Description:
//      Prints out properties for this cluster
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//      ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScGetProperties(
      const CCmdLineOption &    thisOption
    , PropertyType              ePropType
    )
    throw( CSyntaxException )
{
    DWORD           sc = ERROR_SUCCESS;
    DWORD           dwControlCode;
    CClusPropList   cplPropList;

    // Assert( m_hCluster != NULL );

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // Get Read Only properties
    dwControlCode = ( ePropType == PRIVATE )
                    ? CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES
                    : CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES;

    sc = cplPropList.ScGetClusterProperties( m_hCluster, dwControlCode );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = ::PrintProperties( cplPropList, thisOption.GetValues(), READONLY, m_strClusterName );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Get Read/Write properties
    dwControlCode = ( ePropType == PRIVATE )
                    ? CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES
                    : CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES;


    sc = cplPropList.ScGetClusterProperties( m_hCluster, dwControlCode );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = ::PrintProperties( cplPropList, thisOption.GetValues(), READWRITE, m_strClusterName );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

Cleanup:

    return sc;

} //*** CClusterCmd::ScGetProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScSetProperties
//
//  Description:
//      Set the properties for this cluster
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//      ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::ScSetProperties(
      const CCmdLineOption &    thisOption
    , PropertyType              ePropType
    )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;
    DWORD   dwControlCode;
    DWORD   cbBytesReturned = 0;

    // Assert( m_hCluster != NULL );

    // Use the proplist helper class.
    CClusPropList cplCurrentProps;
    CClusPropList cplNewProps;

    // First get the existing properties...
    dwControlCode = ( ePropType == PRIVATE )
                    ? CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES
                    : CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES;

    sc = cplCurrentProps.ScGetClusterProperties( m_hCluster, dwControlCode );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // If values have been specified with this option, then it means that we want
    // to set these properties to their default values. So, there has to be
    // exactly one parameter and it has to be /USEDEFAULT.
    if ( thisOption.GetValues().size() != 0 )
    {
        const vector< CCmdLineParameter > & vclpParamList = thisOption.GetParameters();

        if ( vclpParamList.size() != 1 )
        {
            CSyntaxException se;

            se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_WITH_NAME, thisOption.GetName() );
            throw se;
        }

        if ( vclpParamList[ 0 ].GetType() != paramUseDefault )
        {
            CSyntaxException se;

            se.LoadMessage( MSG_INVALID_PARAMETER, vclpParamList[0].GetName() );
            throw se;
        }

        // This parameter does not take any values.
        if ( vclpParamList[ 0 ].GetValues().size() != 0 )
        {
            CSyntaxException se;

            se.LoadMessage( MSG_PARAM_NO_VALUES, vclpParamList[ 0 ].GetName() );
            throw se;
        }

        sc = ConstructPropListWithDefaultValues( cplCurrentProps, cplNewProps, thisOption.GetValues() );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

    } // if: values have been specified with this option.
    else
    {
        sc = ConstructPropertyList(
                  cplCurrentProps
                , cplNewProps
                , thisOption.GetParameters()
                , TRUE /* BOOL bClusterSecurity */
                );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

    } // else: no values have been specified with this option.

    //
    // If the user specified the same new value as en xisting value
    // then cplNewProps might not have been modified.  Consequently 
    // ClusterControl would return ERROR_INVALID_DATA because 
    // we'd be passing in a NULL buffer.
    //
    if ( cplNewProps.CbBufferSize() > 0 )
    {
        // Call the set function...
        dwControlCode = ( ePropType == PRIVATE )
                        ? CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES
                        : CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES;

        cbBytesReturned = 0;
        sc = ClusterControl(
                  m_hCluster
                , NULL // hNode
                , dwControlCode
                , cplNewProps.Plist()
                , (DWORD) cplNewProps.CbBufferSize()
                , 0
                , 0
                , &cbBytesReturned
                );
    } // if: there are no properties to set

Cleanup:

    return sc;

} //*** CClusterCmd::ScSetProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScSetFailureActions
//
//  Description:
//      Resets the service controller failure actions back to the installed
//      default for the specified nodes
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS. If an individual reset fails, that is noted but doesn't
//      fail the entire operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterCmd::ScSetFailureActions( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD       sc = ERROR_SUCCESS;
    DWORD       idx;
    HCLUSENUM   hclusenum = NULL;

    const vector< CString > & vstrValueList = thisOption.GetValues();

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // Open a handle to the cluster.
    sc = ScOpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Assert( m_hCluster != NULL );

    // Open the node enumerator.
    hclusenum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_NODE );
    if ( hclusenum == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    // If no values are specified then reset all nodes in the cluster
    if ( vstrValueList.size() == 0 )
    {
        DWORD   nObjectType;
        DWORD   cchNodeNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;
        CString strNodeName;
        LPWSTR  pszNodeNameBuffer;

        // Enum the nodes and reset the failure actions on each one.
        pszNodeNameBuffer = strNodeName.GetBuffer( cchNodeNameBufferSize );
        if ( pszNodeNameBuffer == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        for ( idx = 0 ; ; ++idx )
        {
            sc = ClusterEnum(
                      hclusenum
                    , idx
                    , &nObjectType
                    , pszNodeNameBuffer
                    , &cchNodeNameBufferSize
                    );
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            }
            if ( sc == ERROR_MORE_DATA )
            {
                cchNodeNameBufferSize++;
                pszNodeNameBuffer = strNodeName.GetBuffer( cchNodeNameBufferSize );
                if ( pszNodeNameBuffer == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }
                sc = ClusterEnum(
                          hclusenum
                        , idx
                        , &nObjectType
                        , pszNodeNameBuffer
                        , &cchNodeNameBufferSize
                        );
            } // if: name buffer too small

            if ( sc != ERROR_SUCCESS )
            {
                goto Cleanup;
            }

            PrintMessage( MSG_SETTING_FAILURE_ACTIONS, pszNodeNameBuffer );

            sc = ClRtlSetSCMFailureActions( pszNodeNameBuffer );
            if ( sc != ERROR_SUCCESS )
            {
                PrintMessage( MSG_FAILURE_ACTIONS_FAILED, pszNodeNameBuffer, sc );
            }

            cchNodeNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;
        } // for: each item in the enumeration

    } // if: no node list specified
    else
    {
        //
        // List of nodes was specified.
        // Verify that all nodes are part of the target cluster.
        //

        DWORD   nObjectType;
        DWORD   cchNodeNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;
        CString strNodeName;
        LPWSTR  pszNodeNameBuffer;
        DWORD   idxName;

        pszNodeNameBuffer = strNodeName.GetBuffer( cchNodeNameBufferSize );
        if ( pszNodeNameBuffer == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        for ( idxName = 0 ; idxName < vstrValueList.size() ; ++idxName )
        {
            // Get the name of each node in the cluster.
            for ( idx = 0 ; ; ++idx )
            {
                cchNodeNameBufferSize = MAX_COMPUTERNAME_LENGTH + 1;
                sc = ClusterEnum(
                              hclusenum
                            , idx
                            , &nObjectType
                            , pszNodeNameBuffer
                            , &cchNodeNameBufferSize
                            );
                if ( sc == ERROR_NO_MORE_ITEMS )
                {
                    break;
                }
                if ( sc == ERROR_MORE_DATA )
                {
                    cchNodeNameBufferSize++;
                    pszNodeNameBuffer = strNodeName.GetBuffer( cchNodeNameBufferSize );
                    if ( pszNodeNameBuffer == NULL )
                    {
                        sc = ERROR_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }
                    sc = ClusterEnum(
                              hclusenum
                            , (DWORD) idx
                            , &nObjectType
                            , pszNodeNameBuffer
                            , &cchNodeNameBufferSize
                            );
                } // if: name buffer too small

                if ( sc != ERROR_SUCCESS )
                {
                    goto Cleanup;
                }

                if ( vstrValueList[ idxName ].CompareNoCase( pszNodeNameBuffer ) == 0 )
                {
                    break;
                }
            } // for: each node in the enumeration

            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                CString strValueUpcaseName( vstrValueList[ idxName ]);
                strValueUpcaseName.MakeUpper();

                PrintMessage( MSG_NODE_NOT_CLUSTER_MEMBER, strValueUpcaseName );
                sc = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        } // for: each name in the value list

        // Everything is hunky-dory. go ahead and set the failure actions.
        for ( idx = 0 ; idx < vstrValueList.size() ; ++idx )
        {
            CString strUpcaseName( vstrValueList[ idx ] );
            strUpcaseName.MakeUpper();

            PrintMessage( MSG_SETTING_FAILURE_ACTIONS, strUpcaseName );

            sc = ClRtlSetSCMFailureActions( (LPWSTR)(LPCWSTR) vstrValueList[ idx ] );
            if ( sc != ERROR_SUCCESS )
            {
                PrintMessage( MSG_FAILURE_ACTIONS_FAILED, strUpcaseName, sc );
            }
        } // for: each node
    } // else: node list specified

Cleanup:

    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    }

    return sc;

} //*** CClusterCmd::ScSetFailureActions

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScListNetPriority
//
//  Description:
//      Lists the priority of internal networks for cluster communications.
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//      fCheckCmdLineIn
//          TRUE = make sure the command line is correct for this command.
//          FALSE = just perform the operation without checking the command
//          line.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScListNetPriority(
      const CCmdLineOption &    thisOption
    , BOOL                      fCheckCmdLineIn
    )
    throw( CSyntaxException )
{
    DWORD       sc = ERROR_SUCCESS;
    DWORD       idx;
    DWORD       cchNameBufferSize = 256;
    DWORD       nObjectType;
    HCLUSENUM   hclusenum = NULL;
    CString     strName;
    LPWSTR      pszNameBuffer;

    const vector< CString > & vstrValueList = thisOption.GetValues();

    if ( fCheckCmdLineIn )
    {
        // This option takes no parameters.
        if ( thisOption.GetParameters().size() != 0 )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
            throw se;
        }

        // This option takes no values.
        if ( vstrValueList.size() != 0 )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
            throw se;
        }
    } // if: validating the command line

    // Make sure the cluster is open.
    sc = ScOpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Assert( m_hCluster != NULL );

    // Open the cluster enumeration for internal networks (network priority).
    hclusenum = ClusterOpenEnum( m_hCluster, (DWORD) CLUSTER_ENUM_INTERNAL_NETWORK );
    if ( hclusenum == NULL )
    {
        goto Cleanup;
    }

    // Print a title message.
    PrintMessage( MSG_NETWORK_PRIORITY_HEADER );

    // Loop through each of the networks and display a line for each one.
    pszNameBuffer = strName.GetBuffer( cchNameBufferSize );
    if ( pszNameBuffer == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    for ( idx = 0 ; ; idx++ )
    {
        // Get the next network name.
        sc = ClusterEnum(
                  hclusenum
                , idx
                , &nObjectType
                , pszNameBuffer
                , &cchNameBufferSize
                );
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
            sc = ERROR_SUCCESS;
            break;
        }
        if ( sc == ERROR_MORE_DATA )
        {
            pszNameBuffer = strName.GetBuffer( ++cchNameBufferSize );
            if ( pszNameBuffer == NULL )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            sc = ClusterEnum(
                      hclusenum
                    , idx
                    , &nObjectType
                    , pszNameBuffer
                    , &cchNameBufferSize
                    );
        } // if: name buffer too small

        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        // Display the information for the line.
        // Display the index as a 1-relative number instead of a 0-relative number.
        PrintMessage( MSG_NETWORK_PRIORITY_DETAIL, idx + 1, pszNameBuffer );
    } // for: each internal network

Cleanup:

    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    }

    return sc;

} //*** CClusterCmd::ScListNetPriority

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScSetNetPriority
//
//  Description:
//      Sets the priority of internal networks for cluster communications.
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScSetNetPriority( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD       sc = ERROR_SUCCESS;
    DWORD       idx;
    DWORD       cNetworks = 0;
    HCLUSENUM   hclusenum = NULL;
    CString     strName;
    HNETWORK *  phNetworks = NULL;
    BOOL        fNeedToThrowException = FALSE;

    CSyntaxException            se;
    const vector< CString > &   vstrValueList = thisOption.GetValues();

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // Make sure the cluster is open.
    sc = ScOpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Assert( m_hCluster != NULL );

    // Open the cluster enumeration for internal networks (network priority).
    hclusenum = ClusterOpenEnum( m_hCluster, (DWORD) CLUSTER_ENUM_INTERNAL_NETWORK );
    if ( hclusenum == NULL )
    {
        goto Cleanup;
    }

    // Make sure that the user entered the same number of networks as
    // there are internal networks.
    cNetworks = ClusterGetEnumCount( hclusenum );
    if ( vstrValueList.size() != cNetworks )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_WRONG_NUMBER_OF_NETWORKS, thisOption.GetName() );
        throw se;
    }

    // Allocate an array of network handles.
    phNetworks = new HNETWORK[ cNetworks ];
    if ( phNetworks == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    ZeroMemory( phNetworks, sizeof( HNETWORK ) * cNetworks );

    // Loop through each network specified by the user, open each one,
    // and add its handle to the array of handles.
    for ( idx = 0 ; idx < cNetworks ; idx++ )
    {
        // Open the network.
        phNetworks[ idx ] = OpenClusterNetwork( m_hCluster, vstrValueList[ idx ] );
        if ( phNetworks[ idx ] == NULL )
        {
            se.LoadMessage( MSG_NETWORK_NOT_FOUND, vstrValueList[ idx ] );
            fNeedToThrowException = TRUE;
            goto Cleanup;
        }
    } // for; each network

    // Print a title message.
    PrintMessage( MSG_SETTING_NETWORK_PRIORITY );

    // Set the network priority.
    sc = SetClusterNetworkPriorityOrder( m_hCluster, cNetworks, phNetworks );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = ScListNetPriority( thisOption, FALSE /* fCheckCmdLineIn */ );

Cleanup:

    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    }

    if ( phNetworks != NULL )
    {
        for ( idx = 0 ; idx < cNetworks ; idx++ )
        {
            if ( phNetworks[ idx ] != NULL )
            {
                CloseClusterNetwork( phNetworks[ idx ] );
            }
        }
        delete [] phNetworks;
    } // if: network handle array was allocated

    if ( fNeedToThrowException )
    {
        throw se;
    }

    return sc;

} //*** CClusterCmd::ScSetNetPriority

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::ScRegUnregAdminExtensions
//
//  Description:
//      Registers or unregisters an admin extension on the specified cluster.
//      The DLL for the admin extension need not actually exist on the cluster
//      nodes. This function just creates or deletes the AdminExtensions key
//      in the cluster database.
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//      fRegisterIn
//          If this parameter is TRUE, the admin extension is registered.
//          Otherwise it is unregistered.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS if the registration or unregistration succeeded.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusterCmd::ScRegUnregAdminExtensions(
      const CCmdLineOption &    thisOption
    , BOOL                      fRegisterIn
    )
    throw( CSyntaxException )
{
    DWORD       sc = ERROR_SUCCESS;
    size_t      cExtensions;
    size_t      idxExtension;
    HINSTANCE   hExtModuleHandle = NULL;

    const vector< CString > & vstrValueList = thisOption.GetValues();

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    } // if: this option was passed a parameter

    cExtensions = vstrValueList.size();

    // This option takes at least one value.
    if ( cExtensions < 1 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_AT_LEAST_ONE_VALUE, thisOption.GetName() );
        throw se;
    } // if: this option had less than one value

    // Open the cluster.
    sc = ScOpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: the cluster could not be opened.

    // Assert( m_hCluster != NULL );

    for ( idxExtension = 0 ; idxExtension < cExtensions ; ++idxExtension )
    {
        typedef HRESULT (*PFREGISTERADMINEXTENSION)( HCLUSTER hcluster );
        typedef HRESULT (*PFREGISTERSERVER)( void );

        const CString &             rstrCurrentExt = vstrValueList[ idxExtension ];
        PFREGISTERADMINEXTENSION    pfnRegUnregExtProc;
        PFREGISTERSERVER            pfnRegUnregSvrProc;
        CHAR *                      pszRegUnregExtProcName;
        CHAR *                      pszRegUnregSvrProcName;
        DWORD                       dwMessageId;

        if ( fRegisterIn )
        {
            pszRegUnregExtProcName = "DllRegisterCluAdminExtension";
            pszRegUnregSvrProcName = "DllRegisterServer";
            dwMessageId = MSG_CLUSTER_REG_ADMIN_EXTENSION;
        } // if: register admin extension
        else
        {
            pszRegUnregExtProcName = "DllUnregisterCluAdminExtension";
            pszRegUnregSvrProcName = "DllUnregisterServer";
            dwMessageId = MSG_CLUSTER_UNREG_ADMIN_EXTENSION;

        } // else: unregister admin extension

        //
        PrintMessage(
            dwMessageId,
            static_cast< LPCWSTR >( rstrCurrentExt ),
            static_cast< LPCWSTR >( m_strClusterName )
            );

        // Load the admin extension DLL.
        hExtModuleHandle = LoadLibrary( rstrCurrentExt );
        if ( hExtModuleHandle == NULL )
        {
            sc = GetLastError();
            break;
        } // if: load library failed

        //
        // Register or unregister the admin extension with the cluster.
        //
        pfnRegUnregExtProc = reinterpret_cast< PFREGISTERADMINEXTENSION >(
                                GetProcAddress( hExtModuleHandle, pszRegUnregExtProcName )
                                );

        if ( pfnRegUnregExtProc == NULL )
        {
            sc = GetLastError();
            goto Cleanup;
        } // if: GetProcAddress failed

        sc = static_cast< DWORD >( pfnRegUnregExtProc( m_hCluster ) );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if: reg/unreg extension failed

        //
        // Register or unregister the admin extension DLL on this machine.
        //
        pfnRegUnregSvrProc = reinterpret_cast< PFREGISTERSERVER >(
                                GetProcAddress( hExtModuleHandle, pszRegUnregSvrProcName )
                                );

        if ( pfnRegUnregSvrProc == NULL )
        {
            sc = GetLastError();
            goto Cleanup;
        } // if: GetProcAddress failed

        sc = static_cast< DWORD >( pfnRegUnregSvrProc() );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: reg/unreg server failed

        if ( hExtModuleHandle != NULL )
        {
            FreeLibrary( hExtModuleHandle );
            hExtModuleHandle = NULL;
        } // if: the DLL was loaded successfully

    } // for: loop through all specified admin extensions

Cleanup:

    CloseCluster();

    if ( hExtModuleHandle != NULL )
    {
        FreeLibrary( hExtModuleHandle );
    }

    return sc;

} //*** CClusterCmd::ScRegUnregAdminExtensions

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::HrCreateCluster
//
//  Description:
//      Creates a new cluster.
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      S_OK if the cluster was created successfully.
//      Other HRESULTs otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrCreateCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException )
{
    HRESULT         hr = S_OK;
    CComBSTR        combstrClusterName;
    CComBSTR        combstrNode;
    CComBSTR        combstrUserAccount;
    CComBSTR        combstrUserDomain;
    CEncryptedBSTR  encbstrUserPassword;
    CString         strIPAddress;
    CString         strIPSubnet;
    CString         strNetwork;
    CCreateCluster  cc;
    BOOL            fVerbose    = FALSE;
    BOOL            fWizard     = FALSE;
    BOOL            fMinConfig  = FALSE;
    BOOL            fInteract   = FALSE;

    // No values are support with the option.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se;
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    } // if: this option was passed a value

    // Collect parameters from the command line.
    
    hr = HrCollectCreateClusterParameters(
              thisOption
            , &fVerbose
            , &fWizard
            , &fMinConfig
            , &fInteract
            , &combstrNode
            , &combstrUserAccount
            , &combstrUserDomain
            , &encbstrUserPassword
            , &strIPAddress
            , &strIPSubnet
            , &strNetwork
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Make the cluster name fully-qualified, if necessary.
    //
    if ( m_strClusterName.GetLength() != 0 )
    {
        if ( fWizard )
        {
            //
            //  Don't fully qualify the cluster name; let the wizard prompt the
            //  user for the domain if it's missing.
            //
            combstrClusterName = SysAllocString( m_strClusterName );
            if ( !combstrClusterName )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else
        {
            hr = HrMakeFQN( m_strClusterName, NULL, true, &combstrClusterName );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }
    } // if: a cluster name was specified

    // Create the cluster.
    if ( fWizard )
    {
        hr = cc.HrInvokeWizard(
                      combstrClusterName
                    , combstrNode
                    , combstrUserAccount
                    , combstrUserDomain
                    , encbstrUserPassword
                    , strIPAddress
                    , fMinConfig
                    );
    } // if: invoking the wizard
    else
    {
        hr = cc.HrCreateCluster(
                      fVerbose
                    , fMinConfig
                    , combstrClusterName
                    , combstrNode
                    , combstrUserAccount
                    , combstrUserDomain
                    , encbstrUserPassword
                    , strIPAddress
                    , strIPSubnet
                    , strNetwork
                    , fInteract
                    );
    } // else: not invoking the wizard

Cleanup:

    return hr;

} //*** CClusterCmd::HrCreateCluster

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::HrAddNodesToCluster
//
//  Description:
//      Adds nodes to an existing cluster.
//
//  Arguments:
//      thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      ERROR_SUCCESS if the specified nodes were added to the cluster successfully.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrAddNodesToCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException )
{
    HRESULT             hr = S_OK;
    CEncryptedBSTR      encbstrUserPassword;
    BSTR *              pbstrNodes = NULL;
    DWORD               cNodes;
    CAddNodesToCluster  antc;
    BOOL                fVerbose    = FALSE;
    BOOL                fWizard     = FALSE;
    BOOL                fMinConfig  = FALSE;
    BOOL                fInteract   = FALSE;

    // Collect parameters from the command line.
    hr = HrCollectAddNodesParameters(
              thisOption
            , &fVerbose
            , &fWizard
            , &fMinConfig
            , &fInteract
            , &pbstrNodes
            , &cNodes
            , &encbstrUserPassword
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Add the nodes to the cluster.
    if ( fWizard )
    {
        hr = antc.HrInvokeWizard(
                      m_strClusterName
                    , pbstrNodes
                    , cNodes
                    , encbstrUserPassword
                    , fMinConfig
                    );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: invoking the wizard
    else
    {
        hr = antc.HrAddNodesToCluster(
                      fVerbose
                    , fMinConfig
                    , m_strClusterName
                    , pbstrNodes
                    , cNodes
                    , encbstrUserPassword
                    , fInteract
                    );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // else: not invoking the wizard

Cleanup:

    if ( pbstrNodes != NULL )
    {
        DWORD   idxNode;

        for ( idxNode = 0 ; idxNode < cNodes ; idxNode++ )
        {
            SysFreeString( pbstrNodes[ idxNode ] );
        } // for: each node name in the array
        delete [] pbstrNodes;
    } // if: nodes array was allocated
    return hr;

} //*** CClusterCmd::HrAddNodesToCluster

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::HrCollectCreateClusterParameters
//
//  Description:
//      Collects the parameters from the command line for the /CREATE switch.
//
//  Arguments:
//      thisOptionIn
//      pfVerboseOut
//      pfWizardOut
//      pbstrNodeOut
//      pbstrUserAccountOut
//      pbstrUserDomainOut
//      pencbstrUserPasswordOut
//      pstrIPAddressOut
//      pstrIPSubnetOut
//      pstrNetworkOut
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      S_OK    - Operation was successful.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrCollectCreateClusterParameters(
      const CCmdLineOption &    thisOptionIn
    , BOOL *                    pfVerboseOut
    , BOOL *                    pfWizardOut
    , BOOL *                    pfMinConfigOut
    , BOOL *                    pfInteractOut
    , BSTR *                    pbstrNodeOut
    , BSTR *                    pbstrUserAccountOut
    , BSTR *                    pbstrUserDomainOut
    , CEncryptedBSTR *          pencbstrUserPasswordOut
    , CString *                 pstrIPAddressOut
    , CString *                 pstrIPSubnetOut
    , CString *                 pstrNetworkOut
    )
    throw( CSyntaxException )
{
    HRESULT hr              = S_OK;
    DWORD   sc;
    bool    fNodeFound      = false;
    bool    fUserFound      = false;
    bool    fPasswordFound  = false;
    bool    fIPFound        = false;
    bool    fVerboseFound   = false;
    bool    fUnattendedFound    = false;
    bool    fWizardFound    = false;
    bool    fMinConfig      = false;

    LPCWSTR pwszIpAddrParamName = NULL;

    const vector< CCmdLineParameter > &         vclpParamList = thisOptionIn.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam    = vclpParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLast        = vclpParamList.end();

    //  Make *pfInteractOut true unless the options contain the unattended switch. 
    *pfInteractOut = TRUE;    

    while( itCurParam != itLast )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch( itCurParam->GetType() )
        {
            case paramNodeName:
                // Exactly one value must be specified.
                if ( vstrValueList.size() != 1 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fNodeFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                // Save the value.
                *pbstrNodeOut = SysAllocString( vstrValueList[ 0 ] );
                if ( *pbstrNodeOut == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                fNodeFound = TRUE;
                break;

            case paramUser:
                // Exactly one value must be specified.
                if ( vstrValueList.size() != 1 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fUserFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                // Get the user domain and account.
                hr = HrParseUserInfo(
                          itCurParam->GetName()
                        , vstrValueList[ 0 ]
                        , pbstrUserDomainOut
                        , pbstrUserAccountOut
                        );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                fUserFound = TRUE;
                break;

            case paramPassword:
                // Exactly one value must be specified.
                if ( vstrValueList.size() != 1 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fPasswordFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                // Save the value.
                {
                    CString &   rcstrPassword = const_cast< CString & >( vstrValueList[ 0 ] );
                    size_t      cchPassword   = rcstrPassword.GetLength();

                    hr = pencbstrUserPasswordOut->HrSetWSTR( rcstrPassword, cchPassword );
                    SecureZeroMemory( const_cast< PWSTR >( static_cast< PCWSTR >( rcstrPassword ) ), cchPassword * sizeof( rcstrPassword[ 0 ] ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }
                    fPasswordFound = TRUE;
                }
                break;

            case paramIPAddress:
                // Exactly one or exactly three values must be specified
                if ( ( vstrValueList.size() != 1 ) && ( vstrValueList.size() != 3 ) )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_WITH_NAME, itCurParam->GetName() );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fIPFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                // Get the user domain and account.
                hr = HrParseIPAddressInfo(
                          itCurParam->GetName()
                        , &vstrValueList
                        , pstrIPAddressOut
                        , pstrIPSubnetOut
                        , pstrNetworkOut
                        );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }

                // Subnet mask/network connection name not compatible with /Wizard.
                if (    fWizardFound
                    &&  (   ( pstrIPSubnetOut->GetLength() > 0 )
                        ||  ( pstrNetworkOut->GetLength() > 0 )
                        )
                    )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_WITH_NAME, itCurParam->GetName() );
                    throw se;
                }

                pwszIpAddrParamName = itCurParam->GetName();
                fIPFound = TRUE;
                break;

            case paramVerbose:
                // No values may be specified
                if ( vstrValueList.size() != 0 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                    throw se;
                }

                // Not compatible with /Wizard
                if ( fWizardFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_VERBOSE_AND_WIZARD_NOT_COMPATIBLE );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fVerboseFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                fVerboseFound = TRUE;
                *pfVerboseOut = TRUE;
                break;

            case paramUnattend:
                // No values may be specified
                if ( vstrValueList.size() != 0 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                    throw se;
                }

                // Not compatible with /Wizard
                if ( fWizardFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_UNATTEND_AND_WIZARD_NOT_COMPATIBLE );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fUnattendedFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                fUnattendedFound = TRUE;
                *pfInteractOut = FALSE;
                break;

            case paramWizard:
                // No values may be specified
                if ( vstrValueList.size() != 0 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                    throw se;
                }

                // Not compatible with /Verbose
                if ( fVerboseFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_VERBOSE_AND_WIZARD_NOT_COMPATIBLE );
                    throw se;
                }

                // Not compatible with /Unattended
                if ( fUnattendedFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_UNATTEND_AND_WIZARD_NOT_COMPATIBLE );
                    throw se;
                }

                // Not compatible with subnet mask/network connection name.
                if (    ( pstrIPSubnetOut->GetLength() > 0 )
                    ||  ( pstrNetworkOut->GetLength() > 0 )
                    )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_WITH_NAME, pwszIpAddrParamName );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fWizardFound )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                fWizardFound = TRUE;
                *pfWizardOut = TRUE;
                break;

            case paramMinimal:
                // No values may be specified
                if ( vstrValueList.size() != 0 )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                    throw se;
                }

                // This parameter must not have been previously specified.
                if ( fMinConfig )
                {
                    CSyntaxException    se;
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                fMinConfig = TRUE;
                *pfMinConfigOut = TRUE;
                break;

            default:
            {
                CSyntaxException    se;
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }
        } // switch: type of parameter

        // Move to the next parameter.
        itCurParam++;

    } // while: more parameters

    //
    // Make sure required parameters were specified.
    //
    if ( ! *pfWizardOut )
    {
        // Make sure a cluster name has been specified.
        if ( m_strClusterName.GetLength() == 0 )
        {
            CSyntaxException    se;
            se.LoadMessage( IDS_NO_CLUSTER_NAME );
            throw se;
        } // if: not invoking the wizard and no cluster name specified

        if ( ( pstrIPAddressOut->GetLength() == 0 )
          || ( *pbstrUserAccountOut == NULL ) )
        {
            CSyntaxException se;
            se.LoadMessage( IDS_MISSING_PARAMETERS, NULL );
            throw se;
        } // if: required parameters were not specified

        //  Command-line must include service account password when running unattended.
        if ( fUnattendedFound && ( pencbstrUserPasswordOut->IsEmpty() ) )
        {
            CSyntaxException    se;
            se.LoadMessage( MSG_UNATTEND_REQUIRES_ACCOUNT_PASSWORD );
            throw se;
        }
        
        //
        // If no password was specified, prompt for it.
        //
        if ( pencbstrUserPasswordOut->IsEmpty() )
        {
            WCHAR   wszPassword[ 1024 ];
            CString strPasswordPrompt;

            strPasswordPrompt.LoadString( IDS_PASSWORD_PROMPT );

            // Get the password.
            wprintf( L"%ls: ", (LPCWSTR) strPasswordPrompt );
            sc = ScGetPassword( wszPassword, RTL_NUMBER_OF( wszPassword ) );
            if ( sc != ERROR_SUCCESS )
            {
                SecureZeroMemory( wszPassword, sizeof( wszPassword ) );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            }

            // Convert the password to a BSTR.
            hr = pencbstrUserPasswordOut->HrSetWSTR( wszPassword, wcslen( wszPassword ) );
            SecureZeroMemory( wszPassword, sizeof( wszPassword ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // if: no password was specified

        //
        // Default the node name if it wasn't specified.
        //
        if ( *pbstrNodeOut == NULL )
        {
            hr = HrGetLocalNodeFQDNName( pbstrNodeOut );
            if ( *pbstrNodeOut == NULL )
            {
                goto Cleanup;
            }
        } // if: no node was specified
    } // if: not invoking the wizard

Cleanup:

    return hr;

} //*** CClusterCmd::HrCollectCreateClusterParameters


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::HrCollectAddNodesParameters
//
//  Description:
//      Collects the parameters from the command line for the /ADDNODES
//      switch.
//
//  Arguments:
//      thisOptionIn
//      pfVerboseOut
//      pfWizardOut
//      pfMinConifgOut
//      pfInteractOut
//      ppbstrNodesOut
//      pcNodesOut
//      pencbstrUserPasswordOut
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      S_OK            - Operation was successful.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrCollectAddNodesParameters(
      const CCmdLineOption &    thisOptionIn
    , BOOL *                    pfVerboseOut
    , BOOL *                    pfWizardOut
    , BOOL *                    pfMinConfigOut
    , BOOL *                    pfInteractOut
    , BSTR **                   ppbstrNodesOut
    , DWORD *                   pcNodesOut
    , CEncryptedBSTR *          pencbstrUserPasswordOut
    )
    throw( CSyntaxException )
{
    HRESULT hr              = S_OK;
    DWORD   sc;
    DWORD   idxNode         = 0;
    DWORD   cNodes          = 0;
    bool    fPasswordFound  = false;
    bool    fVerboseFound   = false;
    bool    fWizardFound    = false;
    bool    fMinConfigFound = false;
    bool    fUnattendedFound    = false;
    bool    fThrowException = false;
    CSyntaxException    se;

    //  Make *pfInteractOut true unless the options contain the unattended switch. 
    *pfInteractOut = TRUE;

    //
    // Get parameter values.
    //
    {
        const vector< CCmdLineParameter > &         vecParamList = thisOptionIn.GetParameters();
        vector< CCmdLineParameter >::const_iterator itCurParam   = vecParamList.begin();
        vector< CCmdLineParameter >::const_iterator itLast       = vecParamList.end();

        while( itCurParam != itLast )
        {
            const vector< CString > & vstrValueList = itCurParam->GetValues();

            switch( itCurParam->GetType() )
            {
                case paramPassword:
                    // Exactly one value must be specified.
                    if ( vstrValueList.size() != 1 )
                    {
                        se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // This parameter must not have been previously specified.
                    if ( fPasswordFound )
                    {
                        se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // Save the value.
                    {
                        CString &   rcstrPassword = const_cast< CString & >( vstrValueList[ 0 ] );
                        size_t      cchPassword   = rcstrPassword.GetLength();

                        hr = pencbstrUserPasswordOut->HrSetWSTR( rcstrPassword, cchPassword );
                        SecureZeroMemory( const_cast< PWSTR >( static_cast< PCWSTR >( rcstrPassword ) ), cchPassword * sizeof( rcstrPassword[ 0 ] ) );
                        if ( FAILED( hr ) )
                        {
                            goto Error;
                        }
                        fPasswordFound = TRUE;
                    }
                    break;

                case paramVerbose:
                    // No values may be specified
                    if ( vstrValueList.size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // Not compatible with /Wizard
                    if ( fWizardFound )
                    {
                        se.LoadMessage( MSG_VERBOSE_AND_WIZARD_NOT_COMPATIBLE );
                        fThrowException = true;
                        goto Error;
                    }

                    // This parameter must not have been previously specified.
                    if ( fVerboseFound )
                    {
                        se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    fVerboseFound = TRUE;
                    *pfVerboseOut = TRUE;
                    break;

                case paramWizard:
                    // No values may be specified
                    if ( vstrValueList.size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // Not compatible with /Verbose
                    if ( fVerboseFound )
                    {
                        se.LoadMessage( MSG_VERBOSE_AND_WIZARD_NOT_COMPATIBLE );
                        fThrowException = true;
                        goto Error;
                    }

                    // Not compatible with /Unattended
                    if ( fUnattendedFound )
                    {
                        se.LoadMessage( MSG_UNATTEND_AND_WIZARD_NOT_COMPATIBLE );
                        fThrowException = true;
                        goto Error;
                    }

                    // This parameter must not have been previously specified.
                    if ( fWizardFound )
                    {
                        se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    fWizardFound = TRUE;
                    *pfWizardOut = TRUE;
                    break;

                case paramMinimal:
                    // No values may be specified
                    if ( vstrValueList.size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // This parameter must not have been previously specified.
                    if ( fMinConfigFound )
                    {
                        se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    fMinConfigFound = TRUE;
                    *pfMinConfigOut = TRUE;
                    break;

                case paramUnattend:
                    // No values may be specified
                    if ( vstrValueList.size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAMETER_NO_VALUES, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    // Not compatible with /Wizard
                    if ( fWizardFound )
                    {
                        se.LoadMessage( MSG_UNATTEND_AND_WIZARD_NOT_COMPATIBLE );
                        fThrowException = true;
                        goto Error;
                    }

                    // This parameter must not have been previously specified.
                    if ( fUnattendedFound )
                    {
                        se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                        fThrowException = true;
                        goto Error;
                    }

                    fUnattendedFound = TRUE;
                    *pfInteractOut = FALSE;
                    break;

                default:
                {
                    se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                    fThrowException = true;
                    goto Error;
                }
            } // switch: type of parameter

            // Move to the next parameter.
            itCurParam++;

        } // while: more parameters
    } // Get parameter values

    //
    // Parse the node names.
    //
    {
        const vector< CString > & vstrValues  = thisOptionIn.GetValues();

        //  If the user specified nodes, copy them to the array.
        cNodes = (DWORD) vstrValues.size();
        if ( cNodes > 0 )
        {
            // Allocate the node name array.
            *ppbstrNodesOut = new BSTR[ cNodes ];
            if ( *ppbstrNodesOut == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            ZeroMemory( *ppbstrNodesOut, sizeof( BSTR ) * cNodes );

            // Loop through the values and add each node name to the array.
            for ( idxNode = 0 ; idxNode < cNodes ; idxNode++ )
            {
                (*ppbstrNodesOut)[ idxNode ] = SysAllocString( vstrValues[ idxNode ] );
                if ( (*ppbstrNodesOut)[ idxNode ] == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto Error;
                }
            } // for: each node
        } // if user specified nodes
        else // User did not specify nodes.
        {
            if ( fWizardFound )
            {
                //  Don't default to local machine; leave array empty.
                *ppbstrNodesOut = NULL;
            }
            else // Not invoking wizard.
            {
                //  Put local machine in array.
                CComBSTR    combstrLocalNode;
                
                hr = HrGetLocalNodeFQDNName( &combstrLocalNode );
                if ( FAILED( hr ) )
                {
                    goto Error;
                } // if: FAILED( hr )

                *ppbstrNodesOut = new BSTR[ 1 ];
                if ( *ppbstrNodesOut == NULL )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                } // if: new returned null

                **ppbstrNodesOut = combstrLocalNode.Detach();
                cNodes = 1;
            } // else: not invoking wizard.
            
        } // else: user did not specify nodes

        *pcNodesOut = cNodes;
        
    } // Parse the node names

    
    if ( ! *pfWizardOut )
    {
        // Make sure a cluster name has been specified.
        if ( m_strClusterName.GetLength() == 0 )
        {
            se.LoadMessage( IDS_NO_CLUSTER_NAME );
            fThrowException = true;
            goto Error;
        } // if: not invoking the wizard and no cluster name specified

        //  Command-line must include service account password when running unattended.
        if ( fUnattendedFound && ( pencbstrUserPasswordOut->IsEmpty() ) )
        {
            se.LoadMessage( MSG_UNATTEND_REQUIRES_ACCOUNT_PASSWORD );
            fThrowException = true;
            goto Error;
        }

        //
        // If no password was specified, prompt for it.
        //
        if ( pencbstrUserPasswordOut->IsEmpty() )
        {
            WCHAR   wszPassword[ 1024 ];
            CString strPasswordPrompt;

            strPasswordPrompt.LoadString( IDS_PASSWORD_PROMPT );

            // Get the password.
            wprintf( L"%ls: ", (LPCWSTR) strPasswordPrompt );
            sc = ScGetPassword( wszPassword, RTL_NUMBER_OF( wszPassword ) );
            if ( sc != ERROR_SUCCESS )
            {
                SecureZeroMemory( wszPassword, sizeof( wszPassword ) );
                hr = HRESULT_FROM_WIN32( sc );
                goto Cleanup;
            }

            // Convert the password to a BSTR.
            hr = pencbstrUserPasswordOut->HrSetWSTR( wszPassword, wcslen( wszPassword ) );
            SecureZeroMemory( wszPassword, sizeof( wszPassword ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // if: no password was specified
    } // if: not invoking the wizard

Cleanup:

    return hr;

Error:

    //  Clean up array before throwing exception!
    for ( idxNode = 0 ; idxNode < cNodes ; idxNode++ )
    {
        if ( (*ppbstrNodesOut)[ idxNode ] != NULL )
        {
            SysFreeString( (*ppbstrNodesOut)[ idxNode ] );
        } // if: string is not null
    } // for: each node
    
    delete [] *ppbstrNodesOut;
    
    if ( fThrowException )
    {
        throw se;
    } // if: throw exception
    goto Cleanup;

} //*** CClusterCmd::HrCollectAddNodesParameters

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::HrParseUserInfo
//
//  Description:
//      Parse the user domain and account from a single string using the
//      domain\account syntax or the user@domain syntax.
//
//  Arguments:
//      pcwszParamNameIn
//      pcwszValueIn
//      pbstrUserDomainOut
//      pbstrUserAccountOut
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      S_OK            - Operation was successful.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other Win32 error codes otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrParseUserInfo(
      LPCWSTR   pcwszParamNameIn
    , LPCWSTR   pcwszValueIn
    , BSTR *    pbstrUserDomainOut
    , BSTR *    pbstrUserAccountOut
    )
    throw( CSyntaxException )
{
    HRESULT hr          = S_OK;
    LPWSTR  pwszUser    = NULL;
    LPWSTR  pwszSlash;
    LPWSTR  pwszAtSign;
    CString strValue;

    // If not in domain\user format check for user@domain format.
    // If none of these then use the currently-logged-on user's domain.
    strValue = pcwszValueIn;
    pwszUser = strValue.GetBuffer( 0 );
    pwszSlash = wcschr( pwszUser, L'\\' );
    if ( pwszSlash == NULL )
    {
        pwszAtSign = wcschr( pwszUser, L'@' );
        if ( pwszAtSign == NULL )
        {
            hr = HrGetLoggedInUserDomain( pbstrUserDomainOut );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
            *pbstrUserAccountOut = SysAllocString( pwszUser );
            if ( *pbstrUserAccountOut == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else
            {
            // An @ was specified.  Check to make sure that a domain
            // was specified after the @.
            if ( *(pwszAtSign + 1) == L'\0' )
            {
                CSyntaxException se;
                se.LoadMessage( MSG_INVALID_PARAMETER, pcwszParamNameIn );
                throw se;
            }

            // Truncate at the @ and create the user BSTR.
            *pwszAtSign = L'\0';
            *pbstrUserAccountOut = SysAllocString( pwszUser );
            if ( *pbstrUserAccountOut == NULL )
            {
                *pwszAtSign = L'@';
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // Create the domain BSTR.
            *pbstrUserDomainOut = SysAllocString( pwszAtSign + 1 );
            if ( *pbstrUserDomainOut == NULL )
            {
                *pwszAtSign = L'@';
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        } // else:
    } // if: no slash specified
    else
    {
        // A slash was specified.  Check to make sure that a user account
        // was specified after the slash.
        if ( *(pwszSlash + 1) == L'\0' )
        {
            CSyntaxException se;
            se.LoadMessage( MSG_INVALID_PARAMETER, pcwszParamNameIn );
            throw se;
        }

        // Truncate at the slash and create the domain BSTR.
        *pwszSlash = L'\0';
        *pbstrUserDomainOut = SysAllocString( pwszUser );
        if ( *pbstrUserDomainOut == NULL )
        {
            *pwszSlash = L'\\';
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // Create the account BSTR.
        *pbstrUserAccountOut = SysAllocString( pwszSlash + 1 );
        if ( *pbstrUserAccountOut == NULL )
        {
            *pwszSlash = L'\\';
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    } // else: slash specified

Cleanup:

    return hr;

} //*** CClusterCmd::HrParseUserInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterCmd::HrParseIPAddressInfo
//
//  Description:
//      Parse the IP address, subnet, and network from multiple values.
//
//  Arguments:
//      pcwszParamNameIn
//      pvstrValueListIn
//      pstrIPAddressOut
//      pstrIPSubnetOut
//      pstrNetworkOut
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Values:
//      S_OK    - Operation was successful.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CClusterCmd::HrParseIPAddressInfo(
      LPCWSTR                   pcwszParamNameIn
    , const vector< CString > * pvstrValueListIn
    , CString *                 pstrIPAddressOut
    , CString *                 pstrIPSubnetOut
    , CString *                 pstrNetworkOut
    )
    throw()
{
    HRESULT hr  = S_OK;

    UNREFERENCED_PARAMETER( pcwszParamNameIn );

    // Create the IP address BSTR.
    *pstrIPAddressOut = (*pvstrValueListIn)[ 0 ];

    // If a subnet was specified, create the BSTR for it.
    if ( pvstrValueListIn->size() >= 3 )
    {
        // Create the BSTR for the subnet.
        *pstrIPSubnetOut = (*pvstrValueListIn)[ 1 ];

        // Create the BSTR for the network.
        *pstrNetworkOut = (*pvstrValueListIn)[ 2 ];
    } // if: subnet and network were specified

    return hr;

} //*** CClusterCmd::HrParseIPAddressInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmmc\src\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      TraceTag.h
//
//  Abstract:
//      Definition of the CTraceTag class.
//
//  Implementation File:
//      TraceTag.cpp
//
//  Author:
//      David Potter (davidp)   May 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceTag;
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define TRACE_TAG_REG_SECTION       TEXT("Debug")
#define TRACE_TAG_REG_SECTION_FMT   TRACE_TAG_REG_SECTION TEXT("\\%s")
#define TRACE_TAG_REG_FILE          TEXT("Trace File")

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//  CTraceTag
//
//  Purpose:
//      Object containing a specific set of trace settings allowing trace
//      output to go to multiple outputs.
//
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceTag : public CString
{
    friend class CTraceDialog;
    friend void InitAllTraceTags(void);
    friend void CleanupAllTraceTags(void);

public:
    CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL);
    ~CTraceTag(void);

    enum    TraceFlags
    {
        tfCom2      = 1,
        tfFile      = 2,
        tfDebug     = 4,
        tfBreak     = 8
    };

// Attributes
protected:
    UINT        m_uiFlags;
    UINT        m_uiFlagsDialog;
    UINT        m_uiFlagsDefault;
    UINT        m_uiFlagsDialogStart;   // of Selection...

    LPCTSTR     m_pszSubsystem;
    LPCTSTR     m_pszName;

    LPCTSTR     PszSubsystem(void)                  { return m_pszSubsystem; }
    LPCTSTR     PszName(void)                       { return m_pszName; }

    void        ConstructRegState(OUT CString & rstr);

    void        SetFlags(IN UINT tf, IN BOOL bEnable);
    void        SetFlagsDialog(IN UINT tf, IN BOOL bEnable);

    void        SetBCom2(IN BOOL bEnable)           { SetFlags(tfCom2, bEnable); }
    void        SetBCom2Dialog(IN BOOL bEnable)     { SetFlagsDialog(tfCom2, bEnable); }
    BOOL        BCom2Dialog(void) const             { return m_uiFlagsDialog & tfCom2 ? TRUE : FALSE; }

    void        SetBFile(IN BOOL bEnable)           { SetFlags(tfFile, bEnable); }
    void        SetBFileDialog(IN BOOL bEnable)     { SetFlagsDialog(tfFile, bEnable); }
    BOOL        BFileDialog(void) const             { return m_uiFlagsDialog & tfFile ? TRUE : FALSE; }

    void        SetBDebug(IN BOOL bEnable)          { SetFlags(tfDebug, bEnable); }
    void        SetBDebugDialog(IN BOOL bEnable)    { SetFlagsDialog(tfDebug, bEnable); }
    BOOL        BDebugDialog(void) const            { return m_uiFlagsDialog & tfDebug ? TRUE : FALSE; }

    void        SetBBreak(IN BOOL bEnable)          { SetFlags(tfBreak, bEnable); }
    void        SetBBreakDialog(IN BOOL bEnable)    { SetFlagsDialog(tfBreak, bEnable); }
    BOOL        BBreakDialog(void) const            { return m_uiFlagsDialog & tfBreak ? TRUE : FALSE; }

public:
    BOOL        BCom2(void) const                   { return m_uiFlags & tfCom2 ? TRUE : FALSE; }
    BOOL        BFile(void) const                   { return m_uiFlags & tfFile ? TRUE : FALSE; }
    BOOL        BDebug(void) const                  { return m_uiFlags & tfDebug ? TRUE : FALSE; }
    BOOL        BBreak(void) const                  { return m_uiFlags & tfBreak ? TRUE : FALSE; }
    BOOL        BAny(void) const                    { return m_uiFlags != 0; }

// Operations
public:

// Implementation
public:
    void                TraceV(IN LPCTSTR pszFormat, va_list);

protected:
    void                Init(void);

    static LPCTSTR      s_pszCom2;
    static LPCTSTR      s_pszFile;
    static LPCTSTR      s_pszDebug;
    static LPCTSTR      s_pszBreak;

    static LPCTSTR      PszFile(void);

    static CTraceTag *  s_ptagFirst;
    static CTraceTag *  s_ptagLast;
    CTraceTag *         m_ptagNext;
//  static HANDLE           s_hfileCom2;

    static CRITICAL_SECTION s_critsec;
    static BOOL             s_bCritSecValid;

    static BOOL             BCritSecValid(void) { return s_bCritSecValid; }

};  //*** class CTraceTag

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

 extern     CTraceTag               g_tagAlways;
 extern     CTraceTag               g_tagError;
 void       Trace(IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ...);
 void       TraceError(IN OUT CException & rexcept);
 void       TraceError(IN LPCTSTR pszModule, IN SC sc);
 void       InitAllTraceTags(void);
 void       CleanupAllTraceTags(void);
 void       TraceMenu(IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix);

// extern       LPTSTR      g_pszTraceIniFile;
 extern     CString     g_strTraceFile;
 extern     BOOL        g_bBarfDebug;

#else // _DEBUG

 //         Expand to ";", <tab>, one "/" followed by another "/"
 //         (which is //).
 //         NOTE: This means the Trace statements have to be on ONE line.
 //         If you need multiple line Trace statements, enclose them in
 //         a #ifdef _DEBUG block.
 #define    Trace                   ;   /##/
 inline void TraceError(IN OUT CException & rexcept)
 {
    UNREFERENCED_PARAMETER( rexcept );
 }
 
inline void TraceError(IN LPCTSTR pszModule, IN SC sc)
{
    UNREFERENCED_PARAMETER( pszModule );
    UNREFERENCED_PARAMETER( sc );
}

 #define TraceMenu(_rtag, _pmenu, _pszPrefix)
 inline void InitAllTraceTags(void)                     { }
 inline void CleanupAllTraceTags(void)                  { }

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\cluster.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      cluster.cpp
//
//  Description:
//      Cluster.exe main source file.
//      Implements the first level of parsing and hands off execution
//      to appropriate modules.
//
//  Maintained By:
//      David Potter (DavidP                20-ARP-2001
//      Michael Burton (t-mburt)            04-Aug-1997
//      Charles Stacy Harris III (stacyh)   20-March-1997
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <atlimpl.cpp>

#include "cmdline.h"

#include "cluswrap.h"
#include "cluscmd.h"

#include "nodecmd.h"
#include "resgcmd.h"
#include "rescmd.h"

#include "restcmd.h"
#include "netcmd.h"
#include "neticmd.h"

#include "util.h"

CComModule _Module;

#include <atlcom.h>

#include <initguid.h>
#include "Guids.h"      // for minor TASK IDs

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()
    
//  Used by files from Mgmt\ClusCfg project.
HINSTANCE g_hInstance = GetModuleHandle( NULL );

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DispatchCommand
//
//  Routine Description:
//      Identifies the command type and instantiates a class of the
//      specified type to handle remaining options.
//
//  Arguments:
//      IN  CCommandLine & theCmdLine
//          This object contains the parsed command line.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DispatchCommand( CCommandLine & theCmdLine )
{
    DWORD dwReturnValue = ERROR_SUCCESS;
    CString strClusterName( theCmdLine.GetClusterName() );
    const vector<CString> & strvectorClusterNames( theCmdLine.GetClusterNames() ); 

    if ( strClusterName.GetLength() >= MAX_PATH )
    {
        //  Throw an exception so that wmain returns a nonzero value to the shell.
        CSyntaxException se;
        se.LoadMessage( MSG_NAMED_PARAMETER_TOO_LONG, strClusterName, MAX_PATH - 1 );
        throw se;
    }

    // Special case: If user enters "." as the name of the cluster, pass ""
    // as the name of the cluster.
    if ( strClusterName.CompareNoCase( L"." ) == 0 )
        strClusterName.Empty();

    switch( theCmdLine.GetObjectType() )
    {
        case objCluster:
            // Create new scope for command object...
            {   
                CClusterCmd c( strClusterName, theCmdLine, strvectorClusterNames);
                dwReturnValue = c.Execute();
            }
            break;

        case objNode:
            // Create new scope for command object...
            {
                CNodeCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
            break;

        case objGroup:
            // Create new scope for command object...
            {
                CResGroupCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
            break;

        case objResource:
            // Create new scope for command object...
            {
                CResourceCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
            break;

        case objResourceType:
            // Create new scope for command object...
            {
                CResTypeCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
            break;

        case objNetwork:
            // Create new scope for command object...
            {
                CNetworkCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }
           break;

        case objNetInterface:
            // Create new scope for command object...
            {
                CNetInterfaceCmd c( strClusterName, theCmdLine );
                dwReturnValue = c.Execute();
            }

            break;

        default:
        {
            const CString & strObjectName = theCmdLine.GetObjectName();
            CSyntaxException se;
            
            if ( strObjectName.IsEmpty() )
            {
                se.LoadMessage( IDS_NO_OBJECT_TYPE );
            }
            else
            {
                se.LoadMessage( IDS_INVALID_OBJECT_TYPE, strObjectName );
            }

            throw se;
        }
    }


    if ( dwReturnValue > 0 ) // usage errors are < ERROR_SUCCESS
    {
        if ( HRESULT_FACILITY( dwReturnValue ) == FACILITY_WIN32 )
        {
            dwReturnValue = HRESULT_CODE( dwReturnValue );
        }
        PrintSystemError( dwReturnValue );
    }

    return dwReturnValue;

} //*** DispatchCommand()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  wmain
//
//  Routine Description:
//      Gets the command line, calls functions to parse it and pass the control
//      to the appropriate command handlers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Same as DispatchCommand
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C" int __cdecl wmain()
{
    int             nReturnValue;
    CString         cmdLine = GetCommandLine();
    CCommandLine    cmd( cmdLine );
    HRESULT         hr = S_OK;
    BOOL            fComInitialized = FALSE;

    //
    //  Set the process up for tracing.
    //
    TraceInitializeProcess( NULL );

    _Module.Init( ObjectMap, GetModuleHandle( NULL ) );
    hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE );
    if ( FAILED( hr ) )
    {
        nReturnValue = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:
    fComInitialized = TRUE;

    hr = CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    );
    if ( FAILED( hr ) )
    {
        nReturnValue = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

    //
    // Set the proper thread UI
    //
    hr = RtlSetThreadUILanguage( 0 ); // Pass 0, this is a reserved input parameter
    if ( FAILED( hr ) ) 
    {
        nReturnValue = HRESULT_CODE( hr );
        goto Cleanup;
    }

    //
    // Set the proper codepage to use for CRT routines.
    //
    MatchCRTLocaleToConsole( ); // okay to proceed if this fails?
    
    try
    {
        cmd.ParseStageOne();
        nReturnValue = DispatchCommand( cmd );
    }
    catch( CSyntaxException & se )
    {
        PrintString( se.m_strErrorMsg );
        PrintMessage( se.SeeHelpID() );
        
        //  A script might want to know whether something went wrong;
        //  unfortunately, the exception classes don't carry error codes with them, so use -1.
        nReturnValue = -1;
    }
    catch( CException & e )
    {
        PrintString( e.m_strErrorMsg );
        nReturnValue = -1;
    }

Cleanup:

    if ( fComInitialized )
        CoUninitialize();

    TraceTerminateProcess();

    return nReturnValue;

} //*** wmain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\cmdline.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      cmdline.cpp
//
//  Description:
//      Implementation of the CCommandLine class.
//
//  Maintained By:
//      David Potter    (DavidP)    11-JUL-20001
//      Vijayendra Vasu (vvasu)     20-OCT-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Include files
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "cmdline.h"
#include "token.h"
#include "cmderror.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CParseState::CParseState
//
//  Routine Description:
//      Constructor of the CParseState class
//
//  Arguments:
//      IN  LPCWSTR pszCmdLine
//          The command line passed to cluster.exe
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
CParseState::CParseState( LPCWSTR pszCmdLine )  : m_pszCommandLine( pszCmdLine ),
                                                  m_pszCurrentPosition( pszCmdLine ),
                                                  m_ttNextTokenType( ttInvalid ),
                                                  m_bNextTokenReady( FALSE )
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CParseState::~CParseState
//
//  Routine Description:
//      Destructor of the CParseState class
//
//  Arguments:
//      None
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
CParseState::~CParseState( )
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CParseState::CParseState
//
//  Routine Description:
//      Copy constructor of the CParseState class
//
//  Arguments:
//      IN  const CParseState & ps
//          The source of the copy.
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
CParseState::CParseState( const CParseState & ps ) :
    m_bNextTokenReady( ps.m_bNextTokenReady ),
    m_ttNextTokenType( ps.m_ttNextTokenType ),
    m_strNextToken( ps.m_strNextToken ),    
    m_pszCommandLine( ps.m_pszCommandLine ),
    m_pszCurrentPosition( ps.m_pszCurrentPosition )
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CParseState::operator=
//
//  Routine Description:
//      Assignment operator of the CParseState class
//
//  Arguments:
//      IN  const CParseState & ps
//          The source of the assignment.
//
//  Return Value:
//      The assignee.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CParseState & CParseState::operator=( const CParseState & ps )
{
    m_bNextTokenReady = ps.m_bNextTokenReady;
    m_ttNextTokenType = ps.m_ttNextTokenType;
    m_strNextToken = ps.m_strNextToken; 
    m_pszCommandLine = ps.m_pszCommandLine;
    m_pszCurrentPosition = ps.m_pszCurrentPosition;

    return *this;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CParseState::ReadQuotedToken
//
//  Routine Description:
//      Reads the token till the end of the quote is found.
//
//  Arguments:
//      OUT CString & strNextToken
//          The string to which the quoted string is appended.
//
//  Return Value:
//      None
//
//  Exceptions:
//      CParseException
//          This exception is thrown when a matching '"' is not found.
//
//  Notes:
//      This function assumes that m_pszCurrentPosition points to the first
//      character after the opening quote (that is, the opening quote has
//      already been parsed.
//
//      Embedded quotes are allowed and are represented by two consecutive
//      '"' characters.
//      
//--
/////////////////////////////////////////////////////////////////////////////
void CParseState::ReadQuotedToken( CString & strToken ) 
    throw( CParseException )
{
    BOOL bInQuotes = TRUE;

    WCHAR wchCurChar = *m_pszCurrentPosition;

    while ( wchCurChar != L'\0' )
    {
        ++m_pszCurrentPosition;

        // Embedded quote (represented by two consecutive '"'s.
        // Or the end of this quoted token.
        if ( wchCurChar == L'"' )
        {
            if ( *m_pszCurrentPosition == L'"' )
            {
                strToken += wchCurChar;
                ++m_pszCurrentPosition;

            } // if: an embedded quote character.
            else
            {
                bInQuotes = FALSE;
                break;

            } // else: end of quoted token

        } // if: we have found another quote character
        else
        {
            strToken += wchCurChar;

        } // else: the current character is not a quote

        wchCurChar = *m_pszCurrentPosition;

    } // while: we are not at the end of the command line

    // Error: The end of the input was reached but the quoted token 
    // has not ended.
    if ( bInQuotes != FALSE )
    {
        m_bNextTokenReady = FALSE;

        CParseException pe; 
        pe.LoadMessage( MSG_MISSING_QUOTE, strToken );
        throw pe;
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CParseState::ReadToken
//
//  Routine Description:
//      Reads a token till a delimiter is found.
//      Assumes that the character pointed to by m_pszCurrentPosition is not
//      a delimiter.
//
//  Arguments:
//      OUT CString & strNextToken
//          The string to which the new token is appended.
//          This string is not cleared before the token is stored into it.
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CParseState::ReadToken( CString & strToken ) 
{
    WCHAR wchCurChar = *m_pszCurrentPosition;

    do
    {
        // The beginning of a quoted token.
        if ( wchCurChar == L'"' )
        {
            ++m_pszCurrentPosition;
            ReadQuotedToken( strToken );
            
            // There is no need to break out of the token reading loop here
            // because the end of a quoted token need not mean the end of the
            // token. A quoted token is appended to the preceding token as if
            // nothing had happened and the parsing continues.
            // For example: hel"lo wor"ld will equate to the token 'hello world'

        } // if: we have encountered a quoted token
        else
        {
            // This character is a whitespace or one of the delimiter characters.
            // We have reached the end of this token.
            if ( ( iswspace( wchCurChar ) != 0 ) ||
                 ( DELIMITERS.Find( wchCurChar ) != -1 ) )
            {
                break;
            }

            // This character is not a special character. Append it to the token.
            strToken += wchCurChar;
            ++m_pszCurrentPosition;

        } // else: the current character is not a quote

        wchCurChar = *m_pszCurrentPosition;

    }
    while ( wchCurChar != L'\0' );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CParseState::PreviewNextToken
//
//  Routine Description:
//      Gets the next token without changing the state of the parsing.
//
//  Arguments:
//      OUT CString & strNextToken
//          The next token in the command line.
//
//  Return Value:
//      The type of the retrieved token.
//
//  Exceptions:
//      CParseException
//          Passes on exception thrown by ReadQuotedToken
//
//  Notes:
//      This function "caches" the token that is previewed, so that the next
//      call to GetNextToken returns this token without any parsing.
//--
/////////////////////////////////////////////////////////////////////////////
TypeOfToken CParseState::PreviewNextToken( CString & strNextToken )
    throw( CParseException )
{
    // The next token has already been parsed. No need to parse again.
    if ( m_bNextTokenReady != FALSE )
    {
        strNextToken = m_strNextToken;
        return m_ttNextTokenType;
    }

    m_bNextTokenReady = TRUE;

    // Skip white spaces
    while ( ( *m_pszCurrentPosition != L'\0' ) && 
            ( iswspace( *m_pszCurrentPosition ) != 0 ) )
    {
        ++m_pszCurrentPosition;
    }

    strNextToken.Empty();


    WCHAR wchCurChar = *m_pszCurrentPosition;

    // The end of the command line has been reached.
    if ( wchCurChar == L'\0' )
    {
        m_ttNextTokenType = ttEndOfInput;
        strNextToken.Empty();
        goto Cleanup;
    }

    // The current character is a seperator between options
    if ( OPTION_SEPARATOR.Find( wchCurChar ) != -1 )
    {
        m_ttNextTokenType = ttOption;

        // Skip the seperator.
        ++m_pszCurrentPosition;
        wchCurChar = *m_pszCurrentPosition;

        if ( ( wchCurChar == L'\0' ) || ( iswspace( wchCurChar ) != 0 ) )
        {
            CParseException pe; 
            pe.LoadMessage( MSG_OPTION_NAME_EXPTECTED, 
                            CString( *( m_pszCurrentPosition - 1 ) ),
                            m_pszCurrentPosition - 
                            m_pszCommandLine + 1 );

            throw pe;
        }

        // The next character cannot be a whitespace, end of input,
        // another seperator or delimiter.
        if ( ( SEPERATORS.Find( wchCurChar ) != -1 ) ||
             ( DELIMITERS.Find( wchCurChar ) != -1 ) )
        {
            CParseException pe; 
            pe.LoadMessage( MSG_UNEXPECTED_TOKEN, CString( wchCurChar ), 
                            SEPERATORS,
                            m_pszCurrentPosition - 
                            m_pszCommandLine + 1 );

            throw pe;
        }

        ReadToken( strNextToken );
        goto Cleanup;

    } // if: the current character is an option seperator.

    // The current character is a seperator between the option name and the parameter
    if ( OPTION_VALUE_SEPARATOR.Find( wchCurChar ) != -1 )
    {
        m_ttNextTokenType = ttOptionValueSep;
        strNextToken = wchCurChar;
        ++m_pszCurrentPosition;
        goto Cleanup;
    }

    // The current character is a seperator between the parameter and its value(s).
    if ( PARAM_VALUE_SEPARATOR.Find( wchCurChar ) != -1 )
    {
        m_ttNextTokenType = ttParamValueSep;
        strNextToken = wchCurChar;
        ++m_pszCurrentPosition;
        goto Cleanup;
    }

    // The current character is a seperator between values.
    if ( VALUE_SEPARATOR.Find( wchCurChar ) != -1 )
    {
        m_ttNextTokenType = ttValueSep;
        strNextToken = wchCurChar;
        ++m_pszCurrentPosition;
        goto Cleanup;
    }

    m_ttNextTokenType = ttNormal;
    ReadToken( strNextToken );

Cleanup:

    m_strNextToken = strNextToken;
    return m_ttNextTokenType;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CParseState::GetNextToken
//
//  Routine Description:
//      Gets the next token from the command line
//
//  Arguments:
//      OUT CString & strNextToken
//          The next token in the command line.
//
//  Return Value:
//      The type of the retrieved token.
//
//  Exceptions:
//      CParseException
//          Passes on exception thrown by ReadQuotedToken
//
//
//--
/////////////////////////////////////////////////////////////////////////////
TypeOfToken CParseState::GetNextToken( CString & strNextToken )
    throw( CParseException )
{
    TypeOfToken ttReturnValue = PreviewNextToken( strNextToken );
    m_bNextTokenReady = FALSE;

    return ttReturnValue;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CException::LoadMessage
//
//  Routine Description:
//      Loads a formatted string into the exception object member variable.
//
//  Arguments:
//      IN  DWORD dwMessage
//          The message identifier
//
//  Return Value:
//      ERROR_SUCCESS is all is well.
//      A Win32 error code otherwise.
//
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CException::LoadMessage( DWORD dwMessage, ... )
{
    DWORD sc = ERROR_SUCCESS;

    va_list args;
    va_start( args, dwMessage );

    HMODULE hModule = GetModuleHandle(0);
    DWORD dwLength;
    LPWSTR lpMessage = NULL;

    dwLength = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        (LPCVOID) hModule,
        dwMessage,
        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),    // Default language,
        (LPWSTR) &lpMessage,
        0,
        &args );

    if( dwLength == 0 )
    {
        // Keep as local for debug
        sc = GetLastError();
        m_strErrorMsg.Empty();
        goto Cleanup;
    }

Cleanup:

    m_strErrorMsg = lpMessage;

    LocalFree( lpMessage );

    va_end( args );

    return sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//    CSyntaxException::CSyntaxException
//
//    Routine Description:
//        Make an object with a certain help reference ID.
//
//    Arguments:
//        IN  DWORD idSeeHelp
//            The message identifier
//
//--
/////////////////////////////////////////////////////////////////////////////
CSyntaxException::CSyntaxException( DWORD idSeeHelp ): m_idSeeHelp( idSeeHelp ) {}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CParser::ParseValues
//
//  Routine Description:
//      Parses a list of values from the command line.
//      For example: cluster myCluster group myGroup /setowners:owner1,owner2
//      This functions assumes that the first token that it gets is the 
//      seperator (':' in the example). This is extracted and discarded.
//      The list of values is then parsed.
//
//  Arguments:
//      IN  CParseState & parseState
//          Contains the command line string and related data
//
//      OUT vector<CString> & vstrValues
//          A vector containing the extracted values.
//
//  Return Value:
//      None.
//
//  Exceptions:
//      CParseException
//          Passes on exception thrown by ReadQuotedToken
//
//--
/////////////////////////////////////////////////////////////////////////////
void CParser::ParseValues( CParseState & parseState, vector<CString> & vstrValues )
{
    CString strToken;

    // This parameter has values associated with it.
    do
    {
        CString strSep;
        TypeOfToken ttTokenType;

        // Get and discard the seperator.
        parseState.GetNextToken( strSep );

        ttTokenType = parseState.PreviewNextToken( strToken );

        // If there is a separator, there has to be a value.
        if ( ttTokenType == ttEndOfInput )
        {
            CParseException pe; 
            pe.LoadMessage( MSG_VALUE_EXPECTED, strSep, 
                            parseState.m_pszCurrentPosition - 
                            parseState.m_pszCommandLine + 1 );

            throw pe;
        }

        if ( ttTokenType != ttNormal )
        {
            CParseException pe; 
            pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
                            SEPERATORS,
                            parseState.m_pszCurrentPosition - 
                            parseState.m_pszCommandLine + 1 );

            throw pe;
        }

        parseState.GetNextToken( strToken );
        vstrValues.push_back( strToken );

    }
    while ( parseState.PreviewNextToken( strToken ) == ttValueSep );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::CCmdLineParameter
//
//  Routine Description:
//      Constructor of the CCmdLineParameter class
//
//  Arguments:
//      None.
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCmdLineParameter::CCmdLineParameter()
{
    Reset();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::~CCmdLineParameter
//
//  Routine Description:
//      Destructor of the CCmdLineParameter class
//
//  Arguments:
//      None
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCmdLineParameter::~CCmdLineParameter()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::GetType
//
//  Routine Description:
//      Gets the type of this parameter.
//
//  Arguments:
//      None
//
//  Return Value:
//      The type of this parameter.
//
//--
/////////////////////////////////////////////////////////////////////////////
ParameterType CCmdLineParameter::GetType() const
{
    return m_paramType;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::GetValueFormat
//
//  Routine Description:
//      Gets the format of the values that this parameter can take.
//
//  Arguments:
//      None
//
//  Return Value:
//      The format of the values that this parameter can take.
//
//--
/////////////////////////////////////////////////////////////////////////////
ValueFormat CCmdLineParameter::GetValueFormat() const
{
    return m_valueFormat;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::GetValueFormatName
//
//  Routine Description:
//      Gets the string that specifies the format of the values that this 
//      parameter can take.
//
//  Arguments:
//      None
//
//  Return Value:
//      The value format specifier string.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCmdLineParameter::GetValueFormatName() const
{
    return m_strValueFormatName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::GetName
//
//  Routine Description:
//      Gets the name of this parameter.
//
//  Arguments:
//      None
//
//  Return Value:
//      The name of this parameter.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCmdLineParameter::GetName() const
{
    return m_strParamName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::GetValues
//
//  Routine Description:
//      Gets the values associated with this parameter.
//
//  Arguments:
//      None
//
//  Return Value:
//      A vector of strings which contain the values.
//
//--
/////////////////////////////////////////////////////////////////////////////
const vector<CString> & CCmdLineParameter::GetValues() const
{
    return m_vstrValues;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::GetValuesMultisz
//
//  Routine Description:
//      Get the values associated with this parameter as a MULTI_SZ string.
//
//  Arguments:
//      OUT CString &strReturnValue     
//          The string that contains the concatenation of the value strings
//          (including their NULL terminators) with an extra NULL 
//          character after the NULL of the last string.
//
//  Return Value:
//      None.
//
//  Remarks:
//      The result is not returned in a parameter (not as a return value)
//      because we do not know how the copy constructors of CString handle
//      strings with multiple null characters in them.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineParameter::GetValuesMultisz( CString & strReturnValue ) const
{
    size_t  nNumberOfValues;
    size_t  nTotalLength;
    size_t  idx;
    HRESULT hr;

    strReturnValue = "";
    
    nNumberOfValues = m_vstrValues.size();

    nTotalLength = 0;
    for ( idx = 0; idx < nNumberOfValues; ++idx )
    {
        nTotalLength += m_vstrValues[ idx ].GetLength();
    }

    // Add the space required for the nNumberOfValues '\0's and the 
    // extra '\0' at the end.
    nTotalLength += nNumberOfValues + 1;

    LPWSTR lpmultiszBuffer = strReturnValue.GetBuffer( (int)nTotalLength);

    for ( idx = 0; idx < nNumberOfValues; ++idx )
    {
        const CString & strCurString = m_vstrValues[ idx ];
        UINT nCurStrLen = strCurString.GetLength() + 1;

        hr = StringCchCopyW(lpmultiszBuffer, nCurStrLen, strCurString );
        ASSERT( SUCCEEDED( hr ) );
        lpmultiszBuffer += nCurStrLen;
    }

    *lpmultiszBuffer = L'\0';

    strReturnValue.ReleaseBuffer( (int)nTotalLength - 1);
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::ReadKnownParameter
//
//  Routine Description:
//      This function reads "known" parameters. Known parameters are those
//      which are specified in the ParameterType enumeration (and in the 
//      paramLookupTable). Their syntax is the same as those for options,
//      but they are treated as parameters to the previous option.
//
//  Arguments:
//      IN  CParseState & parseState
//          Contains the command line string and related data
//
//  Exceptions:
//      CParseException
//          Thrown for errors during parsing.
//
//  Return Value:
//      Returns TRUE if this token is a parameter.
//      Returns FALSE if it an option..
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCmdLineParameter::ReadKnownParameter( CParseState & parseState ) throw( CParseException )
{
    CString strToken;
    TypeOfToken ttTokenType;
    ParameterType ptCurType;

    Reset();

    ttTokenType = parseState.PreviewNextToken( strToken );

    if ( ttTokenType != ttOption )
    {
        CParseException pe; 
        pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
                        SEPERATORS,
                        parseState.m_pszCurrentPosition - 
                        parseState.m_pszCommandLine + 1 );
        throw pe;

    } // if: this token is not an option seperator

    ptCurType = LookupType( strToken, paramLookupTable, paramLookupTableSize );
    if ( ptCurType == paramUnknown )
    {
        // This is not a parameter.
        return FALSE;
    }

    // This is the name of the parameter.
    parseState.GetNextToken( m_strParamName );
    m_paramType = ptCurType;

    if ( parseState.PreviewNextToken( strToken ) == ttOptionValueSep )
    {
        // This parameter has values associated with it.
        ParseValues( parseState, m_vstrValues );

    } // if: this token is a option-value seperator.

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::Parse
//
//  Routine Description:
//      Parse the command line and extract one parameter.
//
//  Arguments:
//      IN  CParseState & parseState
//          Contains the command line string and related data
//
//  Exceptions:
//      CParseException
//          Thrown for errors during parsing.
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineParameter::Parse( CParseState & parseState ) throw( CParseException )
{
    CString strToken;
    TypeOfToken ttTokenType;

    Reset();

    ttTokenType = parseState.PreviewNextToken( strToken );

    if ( ttTokenType == ttEndOfInput )
    {
        // We are done parsing.
        return;
    }

    if ( ttTokenType != ttNormal )
    {
        CParseException pe; 
        pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
                        SEPERATORS,
                        parseState.m_pszCurrentPosition - 
                        parseState.m_pszCommandLine + 1 );

        throw pe;
    }

    // This is the name of the parameter.
    parseState.GetNextToken( m_strParamName );
    m_paramType = paramUnknown;

    if ( parseState.PreviewNextToken( strToken ) == ttParamValueSep )
    {
        // This parameter has values associated with it.
        ParseValues( parseState, m_vstrValues );

        // See if this parameter has a value format field associated with it.
        // For example: cluster myCluster res myResource /priv size=400:DWORD

        // We actually need to have a different token type for this. 
        // But since, in the current grammar, the option-value separator is 
        // the same as the value-format separator, we are reusing this 
        // token type.
        if ( parseState.PreviewNextToken( strToken ) == ttOptionValueSep )
        {
            // Get and discard the separator.
            parseState.GetNextToken( strToken );

            if ( parseState.PreviewNextToken( strToken ) != ttNormal )
            {
                CParseException pe; 
                pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
                                SEPERATORS,
                                parseState.m_pszCurrentPosition - 
                                parseState.m_pszCommandLine + 1 );

                throw pe;
            }

            parseState.GetNextToken( m_strValueFormatName );
            m_valueFormat = LookupType( strToken, formatLookupTable, 
                                        formatLookupTableSize );

        } // if: A value format has been specified.
        else
        {
            // A value format has not been specified.
            m_valueFormat = vfUnspecified;

        } // else: A value format has not been specified.

    } // if: this token is a param-value seperator.
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineParameter::Reset
//
//  Routine Description:
//      Resets all the member variables to their default states.
//
//  Arguments:
//      None
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineParameter::Reset()
{
    m_strParamName.Empty();
    m_paramType = paramUnknown;
    m_valueFormat = vfInvalid;
    m_strValueFormatName.Empty();
    m_vstrValues.clear();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineOption::CCmdLineOption
//
//  Routine Description:
//      Constructor of the CCmdLineOption class
//
//  Arguments:
//      None
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCmdLineOption::CCmdLineOption()
{
    Reset();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineOption::~CCmdLineOption
//
//  Routine Description:
//      Destructor of the CCmdLineOption class
//
//  Arguments:
//      None
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCmdLineOption::~CCmdLineOption()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineOption::GetName
//
//  Routine Description:
//      Gets the name of this option.
//
//  Arguments:
//      None
//
//  Return Value:
//      The name of this option.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCmdLineOption::GetName() const
{
    return m_strOptionName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineOption::GetType
//
//  Routine Description:
//      Gets the type of this option.
//
//  Arguments:
//      None
//
//  Return Value:
//      The type of this option.
//
//--
/////////////////////////////////////////////////////////////////////////////
OptionType CCmdLineOption::GetType() const
{
    return m_optionType;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineOption::GetValues
//
//  Routine Description:
//      Gets the values associated with this option.
//
//  Arguments:
//      None
//
//  Return Value:
//      A vector of CString.
//
//--
/////////////////////////////////////////////////////////////////////////////
const vector<CString> & CCmdLineOption::GetValues() const
{
    return m_vstrValues;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineOption::GetParameters
//
//  Routine Description:
//      Gets the parameters associated with this option.
//
//  Arguments:
//      None
//
//  Return Value:
//      A vector of CCmdLineParameter.
//
//--
/////////////////////////////////////////////////////////////////////////////
const vector<CCmdLineParameter> & CCmdLineOption::GetParameters() const
{
    return m_vparParameters;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineOption::Reset
//
//  Routine Description:
//      Resets all the member variables to their default states.
//
//  Arguments:
//      None
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineOption::Reset()
{
    m_optionType = optInvalid;
    m_strOptionName.Empty();
    m_vparParameters.clear();
    m_vstrValues.clear();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCmdLineOption::Parse
//
//  Routine Description:
//      Parse the command line and extract one option with all its parameters.
//
//  Arguments:
//      IN  CParseState & parseState
//          Contains the command line string and related data
//
//  Exceptions:
//      CParseException
//          Thrown for errors during parsing.
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCmdLineOption::Parse( CParseState & parseState ) throw( CParseException )
{
    CString strToken;
    TypeOfToken ttNextTokenType;

    Reset();

    switch ( parseState.PreviewNextToken( strToken ) )
    {
        case ttNormal:
        {
            // The type of this option is 'optDefault'. That is the name of
            // the option is not specified with the /optionName switch.
            // Only the parameters are specified.
            // For example: cluster myClusterName node myNodeName
            
            m_optionType = optDefault;

            break;
        }

        case ttOption:
        {
            // This is actually a parameter to the default option.
            if ( LookupType( strToken, paramLookupTable, paramLookupTableSize ) != paramUnknown )
            {
                m_optionType = optDefault;
                break;
            }

            // Get the name of the option.
            parseState.GetNextToken( m_strOptionName );
            m_optionType = LookupType( m_strOptionName, optionLookupTable, 
                                       optionLookupTableSize );

            // See if there is a option-parameter seperator.
            // For example: cluster myClusterName /rename:newClusterName
            if ( parseState.PreviewNextToken( strToken ) == ttOptionValueSep )
            {
                ParseValues( parseState, m_vstrValues );
            }
            break;

        } // case ttOption

        case ttEndOfInput:
        {
            // We are done parsing.
            return;
        }

        default:
        {
            CParseException pe; 
            pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strToken, 
                            SEPERATORS,
                            parseState.m_pszCurrentPosition - 
                            parseState.m_pszCommandLine + 1 );
            throw pe;
        }

    } // switch: based on the type of the retrieved token

    CCmdLineParameter oneParam;
    ttNextTokenType = parseState.PreviewNextToken( strToken );

    // While there are still tokens and we have not reached the next option,
    // read in the tokens as parameters to this option.
    while ( ttNextTokenType != ttEndOfInput )
    {
        // Many of the options in the previous version of cluster.exe
        // are actually treated as parameters and not as options.
        // For the sake of backwards comapatability, these parameters
        // can still be specified as if it were an option. Check for this.
        if ( ttNextTokenType == ttOption )
        {
            // This is really the next option, not a "known" parameter.
            if ( oneParam.ReadKnownParameter( parseState ) == FALSE )
            {
                break;
            }

        } // if: this token is an option separator
        else
        {
            oneParam.Parse( parseState );

        } // else: this token is not an option separator.

        m_vparParameters.push_back( oneParam );
        oneParam.Reset();

        ttNextTokenType =  parseState.PreviewNextToken( strToken );
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::CCommandLine
//
//  Routine Description:
//      Constructor of the CCommandLine class. The entire command line is parsed
//      in this function.
//
//  Arguments:
//      None
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCommandLine::CCommandLine( const CString & strCommandLine ) :
    m_objectType( objInvalid ),
    m_parseState( strCommandLine )
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::~CCommandLine
//
//  Routine Description:
//      Destructor of the CCommandLine class
//
//  Arguments:
//      None
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
CCommandLine::~CCommandLine()
{
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::GetClusterName
//
//  Routine Description:
//      Get the name of the cluster specified on the command line
//
//  Arguments:
//      None
//
//  Return Value:
//      The name of the cluster
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCommandLine::GetClusterName() const
{
    return m_strClusterName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::GetClusterNames
//
//  Routine Description:
//      Get the name vector of the clusters specified on the command line
//
//  Arguments:
//      None
//
//  Return Value:
//      The name vector of the clusters
//
//--
/////////////////////////////////////////////////////////////////////////////
const vector< CString > & CCommandLine::GetClusterNames() const
{
    return m_strvectorClusterNames;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::GetObjectName
//
//  Routine Description:
//      Get the name of the object specified on the cluster.exe command line.
//
//  Arguments:
//      None
//
//  Return Value:
//      The name of the object specfied.
//      An empty string if none is specified.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CString & CCommandLine::GetObjectName() const
{
    return m_strObjectName;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::GetObjectType
//
//  Routine Description:
//      Get the type of the object specified on the cluster.exe command line.
//
//  Arguments:
//      None
//
//  Return Value:
//      The type of the object specified.
//      objCluster is returned if no object name is specified.
//--
/////////////////////////////////////////////////////////////////////////////
ObjectType CCommandLine::GetObjectType() const
{
    return m_objectType;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::GetOptions
//
//  Routine Description:
//      Get the options specified on the cluster.exe command line.
//
//  Arguments:
//      None
//
//  Return Value:
//      A list of CCmdLineOption objects.
//
//--
/////////////////////////////////////////////////////////////////////////////
const vector<CCmdLineOption> & CCommandLine::GetOptions() const
{
    return m_voptOptionList;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::Reset
//
//  Routine Description:
//      Resets all the state variables to their default states.
//
//  Arguments:
//      None
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCommandLine::Reset()
{
    m_objectType = objInvalid;
    m_strObjectName.Empty();
    m_strClusterName.Empty();
    m_voptOptionList.clear();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::ParseStageOne
//
//  Routine Description:
//      Parse the command line till the name of the object is got.
//      For example: cluster myCluster res /status
//      This command parses upto and including the token 'res'
//
//  Arguments:
//      None
//
//  Exceptions:
//      CParseException
//          Thrown for errors during parsing.
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCommandLine::ParseStageOne() 
    throw( CParseException, CSyntaxException )
{
    // This is a big function :) 
    // The three main steps in this function are as follows 
    // (they are also labelled as such in the code below)
    //      1. Get the name of the executable from the command line and discard it.
    //      2. Get the name of the cluster to administer.
    //      3. Get the type of object (node, res, restype, etc.)


    /////////////////////////////////////////////////////////////////////////////
    //  Step 1. Get the name of the executable from the command line and discard it.
    /////////////////////////////////////////////////////////////////////////////

    Reset();

    // The first white space delimited token in the command line is the name 
    // of the executable. Discard it.

    WCHAR wchCurChar = *m_parseState.m_pszCurrentPosition;

    while ( wchCurChar != L'\0' ) 
    {
        if ( wchCurChar == L'"' ) 
        {
            // Skip the opening quote
            ++m_parseState.m_pszCurrentPosition;

            CString strJunkString;

            m_parseState.ReadQuotedToken( strJunkString );
            break;

        } // if:  found quote character
        else
        {
            if ( iswspace( wchCurChar ) != FALSE )
            {
                break;
            }
            else
            {
                ++m_parseState.m_pszCurrentPosition;
            }

        } // else: the current character is not a quote

        wchCurChar = *m_parseState.m_pszCurrentPosition;

    } // while: not at the end of the command line.


    /////////////////////////////////////////////////////////////////////////////
    //  Step 2. Get the name of the cluster to administer.
    /////////////////////////////////////////////////////////////////////////////

    CString strFirstToken;

    // Preview the next token and make decisions based on its type.
    switch ( m_parseState.PreviewNextToken( strFirstToken ) )
    {
        // This could be the name of the cluster or of an object.
        case ttNormal:
        {
            ObjectType firstObjType = LookupType( strFirstToken, objectLookupTable, 
                                                  objectLookupTableSize );

            if ( firstObjType == objInvalid )
            {
                // This token is not a valid object name.
                // For example: cluster myClusterName node /status
                // Assume that it is the name of the cluster.
                m_parseState.GetNextToken( m_strClusterName );

            } // if: the first token on the command line is not a known object name
            else
            {
                // This token is a valid object name.
                // Is it the name of a cluster? Or is it actually an object name?

                CString strSecondToken;
                ObjectType secondObjectType;

                // Get the token that we previewed and thus advance the parse state.
                m_parseState.GetNextToken( strFirstToken );

                if ( ( m_parseState.PreviewNextToken( strSecondToken ) == ttNormal ) &&
                     ( ( secondObjectType = LookupType( strSecondToken, objectLookupTable,
                                                        objectLookupTableSize ) ) != objInvalid ) )
                {
                    // We now have two consecutive valid object names.
                    // For example: cluster node node /status
                    // This command now means "get the status of all nodes on the
                    // cluster named 'node'"
                    // To see the status of a node called 'node' on the default cluster
                    // the command "cluster . node node /status" can be used.

                    // If we assume that the second 'node' is the node name, then there will
                    // be no way to see the status of all nodes on a cluster named
                    // 'node'

                    m_parseState.GetNextToken( strSecondToken );

                    m_strClusterName = strFirstToken;
                    m_objectType = secondObjectType;
                    m_strObjectName = strSecondToken;

                } // if: the second token is also a valid object name.
                else
                {
                    // The second token is not a valid object name.
                    // For example: cluster node Foo
                    // Therefore, no cluster name has been specified.

                    m_strClusterName.Empty();
                    m_objectType = firstObjType;
                    m_strObjectName = strFirstToken;

                } // else: the second token is not a valid object name.

            } // else: the second token on the command line is a known object name

            break;

        } // case: a normal token (not a seperator) was got.

        case ttOption:
        {
            
            // An option is found directly after the executable name.
            // For example: cluster /ver

            // Check if the name of the cluster is being specified
            CCmdLineParameter oneParam;
                        
            if ( oneParam.ReadKnownParameter( m_parseState ) == FALSE )
            {
                // This is really the next option, not the name of the cluster.
                m_objectType = objCluster;
            }
            else
            {
                // The cluster name is being specified.
                if ( oneParam.GetType() != paramCluster )
                {
                    CSyntaxException se; 
                    se.LoadMessage( MSG_INVALID_PARAMETER, oneParam.GetName() );  
                    throw se;
                }

                if ( oneParam.GetValues().size() < 1 )
                {
                    CSyntaxException se; 

                    se.LoadMessage( MSG_OPTION_AT_LEAST_ONE_VALUE, oneParam.GetName() );
                    throw se;
                }

                m_strClusterName = ( oneParam.GetValues() )[0];
                m_strvectorClusterNames = oneParam.GetValues();
                m_objectType = objInvalid;
            }

            break;

        } // case: an option was found.

        case ttEndOfInput:
        {
            
            // We are done parsing.
            return;
        }

        default:
        {
            
            CParseException pe; 
            pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strFirstToken, 
                            SEPERATORS,
                            m_parseState.m_pszCurrentPosition - 
                            m_parseState.m_pszCommandLine + 1 );
            throw pe;
        }

    } // switch: based on the type of the first retrieved token.


    // At this point, the name of the cluster and maybe the type of the 
    // object have been retrieved from the command line.

    // If the object type has not yet been retrieved from the command line,
    // get it now.
    if ( m_objectType == objInvalid )
    {
        /////////////////////////////////////////////////////////////////////////////
        //  Step 3. Get the type of object (node, res, restype, etc.)
        /////////////////////////////////////////////////////////////////////////////

        switch ( m_parseState.PreviewNextToken( strFirstToken ) )
        {
            case ttNormal:
            {
                // We have the cluster name and now another token which is not
                // an option. This has to be a known object type.
                // For example: cluster myClusterName node /status
                m_parseState.GetNextToken( m_strObjectName );
                m_objectType = LookupType( m_strObjectName, objectLookupTable,
                                           objectLookupTableSize );

                break;
            }

            case ttOption:
            {
                // We have hit the options already. No object type has been specified.
                // For example: cluster myClusterName /ver
                m_objectType = objCluster;

                break;
            }

            case ttEndOfInput:
            {
                // We are done parsing.
                return;
            }

            default:
            {
                CParseException pe; 
                pe.LoadMessage( MSG_UNEXPECTED_TOKEN, strFirstToken, 
                                SEPERATORS,
                                m_parseState.m_pszCurrentPosition - 
                                m_parseState.m_pszCommandLine + 1 );
                throw pe;
            }

        } // switch: based on the type of the retrieved token
        

    } // if: the object type has not yet been retrieved
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::ParseStageTwo
//
//  Routine Description:
//      Parse the command line to get the options, parameters and values.
//      For example: cluster myCluster res /status
//      This function assumes that the command line has been parsedupto and 
//      including the token 'res'. It then parses the rest of the command line.
//
//  Arguments:
//      None
//
//  Exceptions:
//      CParseException
//          Thrown for errors during parsing.
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCommandLine::ParseStageTwo() 
    throw( CParseException, CSyntaxException )
{
    /////////////////////////////////////////////////////////////////////////////
    //  Get the options for this object (/status, /ver, etc.)
    /////////////////////////////////////////////////////////////////////////////

    CCmdLineOption oneOption;
    CString strToken;

    while ( m_parseState.PreviewNextToken( strToken ) != ttEndOfInput )
    {
        oneOption.Parse( m_parseState );
        m_voptOptionList.push_back( oneOption );
        oneOption.Reset();
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommandLine::Parse
//
//  Routine Description:
//      Calls functions for both stages of parsing.
//
//  Arguments:
//      IN  CParseState & parseState
//          Contains the command line string and related data
//
//  Exceptions:
//      CParseException
//          Thrown for errors during parsing.
//
//  Return Value:
//      None
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCommandLine::Parse( CParseState & parseState ) 
    throw( CParseException, CSyntaxException )
{
    m_parseState = parseState;

    ParseStageOne();
    ParseStageTwo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\cluscmd.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995-2001 Microsoft Corporation
//
//  Module Name:
//      ClusCmd.h
//
//  Description:
//      Defines the interface available for functions implemented by the
//      cluster object.
//
//  Maintained By:
//      David Potter    (DavidP)    11-JUL-2001
//      Vij Vasu        (VVasu)     26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "cmdline.h"

class CClusterCmd
{
public:
    CClusterCmd(
          const CString &           strClusterName
        , CCommandLine &            cmdLine
        , const vector< CString > & vstrClusterNames
        );  
    ~CClusterCmd( void );

    // Parse and execute te command line
    DWORD Execute( void );

protected:

    enum PropertyType {
        PRIVATE,
        COMMON
    };

    DWORD ScOpenCluster( void );
    void CloseCluster( void );

    // Specifc Commands
    DWORD ScPrintHelp( void );
    DWORD ScPrintClusterVersion( const CCmdLineOption & thisOption ) 
        throw( CSyntaxException );

    DWORD ScListClusters( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD ScRenameCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD ScQuorumResource( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD ScPrintQuorumResource( void );
    DWORD ScSetQuorumResource(
          LPCWSTR                   pszResourceName
        , const CCmdLineOption &    thisOption
        )
        throw( CSyntaxException );

    DWORD ScChangePassword(
          const vector < CString > &    ClusterNames
        , const CCmdLineOption &        thisOption
        , int                           mcpfFlagsIn
        )
        throw( CSyntaxException );

    DWORD ScDoProperties(
          const CCmdLineOption &    thisOption
        , PropertyType              ePropType
        )
        throw( CSyntaxException );

    DWORD ScGetProperties(
          const CCmdLineOption &    thisOption
        , PropertyType              ePropType
        )
        throw( CSyntaxException );

    DWORD ScSetProperties(
          const CCmdLineOption &    thisOption
        , PropertyType              ePropType
        )
        throw( CSyntaxException );

    DWORD ScSetFailureActions( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD ScListNetPriority(
          const CCmdLineOption &    thisOption
        , BOOL                      fCheckCmdLineIn
        )
        throw( CSyntaxException );

    DWORD ScSetNetPriority( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    DWORD ScRegUnregAdminExtensions(
          const CCmdLineOption &    thisOption
        , BOOL                      fRegisterIn
        )
        throw( CSyntaxException );

    HRESULT HrCreateCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    HRESULT HrAddNodesToCluster( const CCmdLineOption & thisOption )
        throw( CSyntaxException );

    HRESULT HrCollectCreateClusterParameters(
          const CCmdLineOption &    thisOptionIn
        , BOOL *                    pfVerboseOut
        , BOOL *                    pfWizardOut
        , BOOL *                    pfMinConfigOut
        , BOOL *                    pfInteractOut
        , BSTR *                    pbstrNodeOut
        , BSTR *                    pbstrUserAccountOut
        , BSTR *                    pbstrUserDomainOut
        , CEncryptedBSTR *          pencbstrPasswordOut
        , CString *                 pstrIPAddressOut
        , CString *                 pstrIPSubnetOut
        , CString *                 pstrNetworkOut
        )
        throw( CSyntaxException );

    HRESULT HrCollectAddNodesParameters(
          const CCmdLineOption &    thisOptionIn
        , BOOL *                    pfVerboseOut
        , BOOL *                    pfWizardOut
        , BOOL *                    pfMinConfigOut
        , BOOL *                    pfInteractOut
        , BSTR **                   ppbstrNodesOut
        , DWORD *                   pcNodesOut
        , CEncryptedBSTR *          pencbstrPasswordOut
        )
        throw( CSyntaxException );

    HRESULT HrParseUserInfo(
          LPCWSTR   pcwszParamNameIn
        , LPCWSTR   pcwszValueIn
        , BSTR *    pbstrUserDomainOut
        , BSTR *    pbstrUserAccountOut
        )
        throw( CSyntaxException );

    HRESULT HrParseIPAddressInfo(
          LPCWSTR                   pcwszParamNameIn
        , const vector< CString > * pvstrValueListIn
        , CString *                 pstrIPAddressOut
        , CString *                 pstrIPSubnetOut
        , CString *                 pstrNetworkOut
        )
        throw();

    HCLUSTER                    m_hCluster;
    const CString &             m_strClusterName;
    const vector< CString > &   m_vstrClusterNames;
    CCommandLine &              m_theCommandLine;

}; //*** class CClusterCmd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\getcomputernamestub.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      GetComputerNameStub.cpp
//
//  Description:
//      File to enable use of GetComputerName from Mgmt project.
//
//  Maintained By:
//      John Franco (JFranco) 13-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "nolog.h"
#include <Common.h>

#include <GetComputerNameSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\intrfc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Intrfc.cpp
//
//  Description:
//      Commands for modules which have a Network Interface
//      (nodes and networks).  Implements the ListInterfaces command
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//      Michael Burton (t-mburt)              25-Aug-1997
//
//  Revicsion Historyt:
//      April 10, 2002              Updated for the security push.
//
//////////////////////////////////////////////////////////////////////////////
#include "intrfc.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CHasInterfaceModuleCmd::CHasInterfaceModuleCmd
//
//  Routine Description:
//      Default Constructor
//      Initializes all the DWORD parameters to UNDEFINED and
//      all the pointers to cluster functions to NULL.
//      *ALL* these variables must be defined in any derived class.
//
//  Arguments:
//      IN  CCommandLine & cmdLine              
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      m_dwMsgStatusListInterface      SET
//      m_dwClusterEnumModuleNetInt     SET
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CHasInterfaceModuleCmd::CHasInterfaceModuleCmd( CCommandLine & cmdLine ) :
    CGenericModuleCmd( cmdLine )
{
    m_dwMsgStatusListInterface   = UNDEFINED;
    m_dwClusterEnumModuleNetInt  = UNDEFINED;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CHasInterfaceModuleCmd::Execute
//
//  Routine Description:
//      Takes a command line option and determines which command to
//      execute.  If no command line option specified, gets the next one
//      automatically.  If the token is not identied as being handle-able
//      in this class, the token is passed up to CGenericModuleCmd::Execute
//      unless DONT_PASS_HIGHER is specified as the second parameter,
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  ExecuteOption eEOpt                         
//          OPTIONAL enum, either DONT_PASS_HIGHER or
//          PASS_HIGHER_ON_ERROR (default)
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CHasInterfaceModuleCmd::Execute( const CCmdLineOption & option, 
                                       ExecuteOption eEOpt )
    throw( CSyntaxException )
{
    DWORD sc;

    // Look up the command
    if ( option.GetType() == optListInterfaces )
    {
        sc = ListInterfaces( option );
        goto Cleanup;
    }

    if (eEOpt == PASS_HIGHER_ON_ERROR)
    {
        sc = CGenericModuleCmd::Execute( option );
        goto Cleanup;
    }
    else
    {
        sc = ERROR_NOT_HANDLED;
        goto Cleanup;
    }

Cleanup:

    return sc;

} //*** CHasInterfaceModuleCmd::Execute


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CHasInterfaceModuleCmd::ListInterfaces
//
//  Routine Description:
//      Lists the network interfaces attached to the device specified
//      by the instantiated derived class
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_strModuleName                 Name of the module
//      m_dwClusterEnumModuleNetInt     Command identifier for m_pfnClusterOpenEnum()
//      m_dwMsgStatusListInterface      Message identifier for PrintMessage()
//      m_pfnClusterOpenEnum()          Function to open an enumeration
//      m_pfnWrapClusterEnum()          Wrapper function to enumerate through netints
//      m_pfnClusterCloseEnum()         Function to close an enumeration
//      m_hCluster                      SET (by OpenCluster)
//      m_hModule                       SET (by OpenModule)
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CHasInterfaceModuleCmd::ListInterfaces( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD dwIndex = 0;
    DWORD dwType = 0;
    DWORD dwError = ERROR_SUCCESS;
    LPWSTR lpszName = 0;

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        CSyntaxException se( SeeHelpStringID() );
            se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
            throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se( SeeHelpStringID() );
            se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
            throw se;
    }

    // Open the network and cluster, in case this hasn't
    // been done yet
    dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    assert(m_pfnClusterOpenEnum);
    HCLUSENUM hEnum = m_pfnClusterOpenEnum( m_hModule, m_dwClusterEnumModuleNetInt );

    if( !hEnum )
        return GetLastError();

    assert(m_dwMsgStatusListInterface != UNDEFINED);
    PrintMessage( m_dwMsgStatusListInterface, (LPCWSTR) m_strModuleName);
    PrintMessage( MSG_NETINTERFACE_STATUS_HEADER );

    assert(m_pfnWrapClusterEnum);
    for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
    {

        dwError = m_pfnWrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );

        if( dwError == ERROR_SUCCESS )
            PrintStatusLineForNetInterface( lpszName );
        if( lpszName )
            LocalFree( lpszName );
    }


    if( dwError == ERROR_NO_MORE_ITEMS )
        dwError = ERROR_SUCCESS;

    assert(m_pfnClusterCloseEnum);
    m_pfnClusterCloseEnum( hEnum );

    return dwError;

} //*** CHasInterfaceModuleCmd::ListInterfaces


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CHasInterfaceModuleCmd::PrintStatusLineForNetInterface
//
//  Routine Description:
//      Prints out a line indicating the status of an individual
//      network interface
//
//  Arguments:
//      lpszNetInterfaceName            Name of network interface
//
//  Member variables used / set:
//      m_lpszNetworkName           (used by GetNetworkName)
//      m_lpszNodeName              (used by GetNodeName)
//
//  Return Value:
//      Same as PrintStatusNetInterface
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CHasInterfaceModuleCmd::PrintStatusLineForNetInterface( LPWSTR lpszNetInterfaceName )
{
    DWORD dwError = ERROR_SUCCESS;
    LPWSTR lpszNodeName;
    LPWSTR lpszNetworkName;

    // Open the Net Interface handle
    HNETINTERFACE hNetInterface = OpenClusterNetInterface( m_hCluster, lpszNetInterfaceName );
    if( !hNetInterface )
        return GetLastError();

    lpszNodeName = GetNodeName(lpszNetInterfaceName);
    lpszNetworkName = GetNetworkName(lpszNetInterfaceName);

    if (lpszNodeName && lpszNetworkName)
    {
        dwError = PrintStatusOfNetInterface( hNetInterface, lpszNodeName, lpszNetworkName );
        LocalFree(lpszNodeName);
        LocalFree(lpszNetworkName);
    }
    else
    {
        dwError = PrintStatusOfNetInterface( hNetInterface, L"", L"" );
        LocalFree(lpszNodeName);
        LocalFree(lpszNetworkName);
    }

    CloseClusterNetInterface( hNetInterface );

    return dwError;

} //*** CHasInterfaceModuleCmd::PrintStatusLineForNetInterface


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CHasInterfaceModuleCmd::PrintStatusOfNetInterface
//
//  Routine Description:
//      Prints out a the actual status of the specified network interface
//
//  Arguments:
//      hNetInterface                   The specified network interface
//      lpszNetworkName                 Name of network (for printing)
//      lpszNodeName                    Name of node    (for printing)
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CHasInterfaceModuleCmd::PrintStatusOfNetInterface( HNETINTERFACE hNetInterface, LPWSTR lpszNodeName, LPWSTR lpszNetworkName)
{
    DWORD dwError = ERROR_SUCCESS;

    CLUSTER_NETINTERFACE_STATE nState;

    nState = GetClusterNetInterfaceState( hNetInterface );

    if( nState == ClusterNetInterfaceStateUnknown )
        return GetLastError();

    LPWSTR lpszStatus = 0;

    switch( nState )
    {
        case ClusterNetInterfaceUnavailable:
            LoadMessage( MSG_STATUS_UNAVAILABLE, &lpszStatus );
            break;

        case ClusterNetInterfaceFailed:
            LoadMessage( MSG_STATUS_FAILED, &lpszStatus );
            break;

        case ClusterNetInterfaceUnreachable:
           LoadMessage( MSG_STATUS_UNREACHABLE, &lpszStatus );
           break;

        case ClusterNetInterfaceUp:
            LoadMessage( MSG_STATUS_UP, &lpszStatus );
            break;

        case ClusterNetInterfaceStateUnknown:
        default:
            LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
    }

    dwError = PrintMessage( MSG_NETINTERFACE_STATUS, lpszNodeName, lpszNetworkName, lpszStatus );

    // Since Load/FormatMessage uses LocalAlloc...
    LocalFree( lpszStatus );

    return dwError;

} //*** CHasInterfaceModuleCmd::PrintStatusOfNetInterface


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CHasInterfaceModuleCmd::GetNodeName
//
//  Routine Description:
//      Returns the name of the node for the specified network interface.
//      *Caller must LocalFree memory*
//
//  Arguments:
//      lpszInterfaceName           Name of the network interface
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//
//  Return Value:
//      Name of the node            on success
//      NULL                        on failure (does not currently SetLastError())
//
//--
/////////////////////////////////////////////////////////////////////////////
LPWSTR CHasInterfaceModuleCmd::GetNodeName (LPWSTR lpszInterfaceName)
{
    DWORD dwError;
    DWORD cLength = 0;
    LPWSTR lpszNodeName;
    HNETINTERFACE hNetInterface;

    // Open the cluster and netinterface if it hasn't been done
    dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return NULL;

    // Open an hNetInterface for the specified lpszInterfaceName
    hNetInterface = OpenClusterNetInterface( m_hCluster, lpszInterfaceName );
    if( hNetInterface == 0 )
        return NULL;

    // Find out how much memory to allocate
    dwError = ClusterNetInterfaceControl(
        hNetInterface,
        NULL, // hNode
        CLUSCTL_NETINTERFACE_GET_NODE,
        0,
        0,
        NULL,
        cLength,
        &cLength );

    if (dwError != ERROR_SUCCESS)
        return NULL;

    lpszNodeName = (LPWSTR) LocalAlloc( LMEM_FIXED, sizeof( WCHAR ) * (++cLength) );
    if (!lpszNodeName) return NULL;

    // Get the node name and store it in a temporary
    dwError = ClusterNetInterfaceControl(
        hNetInterface,
        NULL, // hNode
        CLUSCTL_NETINTERFACE_GET_NODE,
        0,
        0,
        (LPVOID) lpszNodeName,
        cLength,
        &cLength );

    if (dwError != ERROR_SUCCESS)
    {
        if (lpszNodeName) LocalFree (lpszNodeName);
        return NULL;
    }

    CloseClusterNetInterface( hNetInterface );

    return lpszNodeName;

} //*** CHasInterfaceModuleCmd::GetNodeName




/////////////////////////////////////////////////////////////////////////////
//++
//
//  CHasInterfaceModuleCmd::GetNetworkName
//
//  Routine Description:
//      Returns the name of the network for the specified network interface.
//      *Caller must LocalFree memory*
//
//  Arguments:
//      lpszInterfaceName           Name of the network interface
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//
//  Return Value:
//      Name of the network         on success
//      NULL                        on failure (does not currently SetLastError())
//
//--
/////////////////////////////////////////////////////////////////////////////
LPWSTR CHasInterfaceModuleCmd::GetNetworkName (LPWSTR lpszInterfaceName)
{
    DWORD dwError;
    DWORD cLength = 0;
    LPWSTR lpszNetworkName;
    HNETINTERFACE hNetInterface;

    // Open the cluster and netinterface if it hasn't been done
    dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return NULL;

    // Open an hNetInterface for the specified lpszInterfaceName (don't call
    // OpenNetInterface because that opens m_hNetInterface)
    hNetInterface = OpenClusterNetInterface( m_hCluster, lpszInterfaceName );
    if( hNetInterface == 0 )
        return NULL;

    // Find out how much memory to allocate
    dwError = ClusterNetInterfaceControl(
        hNetInterface,
        NULL, // hNode
        CLUSCTL_NETINTERFACE_GET_NETWORK,
        0,
        0,
        NULL,
        cLength,
        &cLength );

    if (dwError != ERROR_SUCCESS)
        return NULL;

    lpszNetworkName = (LPWSTR) LocalAlloc( LMEM_FIXED, sizeof( WCHAR ) * (++cLength) );
    if (!lpszNetworkName) return NULL;

    // Get the node name and store it in a temporary
    dwError = ClusterNetInterfaceControl(
        hNetInterface,
        NULL, // hNode
        CLUSCTL_NETINTERFACE_GET_NETWORK,
        0,
        0,
        (LPVOID) lpszNetworkName,
        cLength,
        &cLength );

    if (dwError != ERROR_SUCCESS)
    {
        if (lpszNetworkName) LocalFree (lpszNetworkName);
        return NULL;
    }

    CloseClusterNetInterface( hNetInterface );

    return lpszNetworkName;

} //*** CHasInterfaceModuleCmd::GetNetworkName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\encryptedbstrstub.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      EncryptedBSTRStub.cpp
//
//  Description:
//      File to enable use of EncryptedBSTR class from Mgmt\ClusCfg.
//
//  Maintained By:
//      John Franco (JFranco) 15-April-2002
//
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include <Common.h>
#include <EncryptedBSTRSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\intrfc.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995 - 2002 Microsoft Corporation
//
//  Module Name:
//      intrfc.h
//
//  Abstract:
//      Defines the interface available for modules which support the 
//      ListInterface command
//
//  Author:
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "modcmd.h"

class CHasInterfaceModuleCmd : virtual public CGenericModuleCmd
{
public:
	CHasInterfaceModuleCmd( CCommandLine & cmdLine );

protected:
	virtual DWORD  PrintStatusLineForNetInterface( LPWSTR lpszNetInterfaceName );
	virtual DWORD  PrintStatusOfNetInterface( HNETINTERFACE hNetInterface, LPWSTR lpszNodeName, LPWSTR lpszNetworkName);
	virtual LPWSTR GetNodeName (LPWSTR lpszInterfaceName);
	virtual LPWSTR GetNetworkName (LPWSTR lpszInterfaceName);

	// Additional Commands
	virtual DWORD Execute( const CCmdLineOption & option, 
						   ExecuteOption eEOpt = PASS_HIGHER_ON_ERROR  )
		throw( CSyntaxException );

	virtual DWORD ListInterfaces( const CCmdLineOption & thisOption )
		throw( CSyntaxException );

	DWORD     m_dwMsgStatusListInterface;
	DWORD     m_dwClusterEnumModuleNetInt;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\loadstringstub.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      LoadStringStub.cpp
//
//  Description:
//      File to enable use of LoadString functions from Mgmt project.
//
//  Maintained By:
//      John Franco (JFranco) 13-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Util.h"
#include <LoadString.h>

extern HINSTANCE g_hInstance; // Required by LoadString functions; defined in cluster.cpp.

#include <LoadStringSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\modcmd.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995 - 2002 Microsoft Corporation
//
//  Module Name:
//      modcmd.h
//
//  Abstract:
//      Interface for functions implemented by most every module.
//
//  Author:
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "precomp.h"

#include "token.h"
#include "cluswrap.h"
#include "cmderror.h"

#include "cmdline.h"
#include "util.h"



#ifdef UNDEFINED
#undef UNDEFINED
#endif

//
// number of bytes to allocate to hold average sized property list
//
#define DEFAULT_PROPLIST_BUFFER_SIZE    1024

// I hope that -1 is not a valid number for any of these constants,
// otherwise the asserts will fail
#define UNDEFINED ((ULONG)-1)

const DWORD ERROR_NOT_HANDLED = !ERROR_SUCCESS; // An error returned by
												// Execute.  Don't care what
												// the value is as long as it's
												// not ERROR_SUCCESS

// HCLUSMODULE will be the generic way we refer to
// HCLUSTER, HNETWORK, HNODE, HRESOURCE, etc (each is a pointer)
typedef void* HCLUSMODULE;


class CGenericModuleCmd
{
public:
	enum PropertyType {
		PRIVATE,
		COMMON
	};
	enum ExecuteOption {
		DONT_PASS_HIGHER,
		PASS_HIGHER_ON_ERROR
	};


	CGenericModuleCmd( CCommandLine & cmdLine );
	virtual ~CGenericModuleCmd();

protected:
	// Primary entry point into module
	virtual DWORD Execute( const CCmdLineOption & option )
		throw( CSyntaxException );

	// Help facilities
	virtual DWORD PrintHelp();
	virtual DWORD SeeHelpStringID() const;

	// Commands Available in all modules
	virtual DWORD Status( const CCmdLineOption * pOption )
		throw( CSyntaxException );

	virtual DWORD DoProperties( const CCmdLineOption & thisOption,
								PropertyType ePropertyType )
		throw( CSyntaxException );

	virtual DWORD GetProperties( const CCmdLineOption & thisOption,
								 PropertyType ePropType, LPCWSTR lpszModuleName );

	virtual DWORD SetProperties( const CCmdLineOption & thisOption,
								 PropertyType ePropType )
		throw( CSyntaxException );


	virtual DWORD AllProperties( const CCmdLineOption & thisOption,
								 PropertyType ePropType ) 
		throw( CSyntaxException );


	virtual DWORD OpenCluster();
	virtual void  CloseCluster();

	virtual DWORD OpenModule();
	virtual void  CloseModule();

	virtual DWORD PrintStatus( LPCWSTR lpszModuleName ) = 0;


	CString m_strClusterName;
	CString m_strModuleName;
	CCommandLine & m_theCommandLine;

	HCLUSTER	m_hCluster;
	HCLUSMODULE m_hModule;


	// Various constant parameters which must be different
	// for each derived class
	DWORD m_dwMsgStatusList;
	DWORD m_dwMsgStatusListAll;
	DWORD m_dwMsgStatusHeader;
	DWORD m_dwMsgPrivateListAll;
	DWORD m_dwMsgPropertyListAll;
	DWORD m_dwMsgPropertyHeaderAll;
	DWORD m_dwCtlGetPrivProperties;
	DWORD m_dwCtlGetCommProperties;
	DWORD m_dwCtlGetROPrivProperties;
	DWORD m_dwCtlGetROCommProperties;
	DWORD m_dwCtlSetPrivProperties;
	DWORD m_dwCtlSetCommProperties;
	DWORD m_dwClusterEnumModule;
	HCLUSMODULE (*m_pfnOpenClusterModule) (HCLUSTER, LPCWSTR);
	BOOL		(*m_pfnCloseClusterModule) (HCLUSMODULE);
	DWORD		(*m_pfnClusterModuleControl) (HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD);
	HCLUSENUM	(*m_pfnClusterOpenEnum) (HCLUSMODULE,DWORD);
	DWORD		(*m_pfnClusterCloseEnum) (HCLUSENUM);
	DWORD		(*m_pfnWrapClusterEnum) (HCLUSENUM,DWORD,LPDWORD,LPWSTR*);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\modcmd.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ModCmd.cpp
//
//  Description:
//      Generic commands for nearly all modules
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//      Michael Burton (t-mburt)              25-Aug-1997
//
//////////////////////////////////////////////////////////////////////////////
#include "modcmd.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::CGenericModuleCmd
//
//  Routine Description:
//      Default Constructor.
//      Initializes all the DWORD parameters to UNDEFINED and
//      all the pointers to cluster functions to NULL.
//      *ALL* these variables must be defined in any derived class.
//
//  Arguments:
//      IN  CCommandLine & cmdLine
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      A bunch.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericModuleCmd::CGenericModuleCmd( CCommandLine & cmdLine ) :
    m_theCommandLine( cmdLine )
{
    m_hCluster = NULL;
    m_hModule  = NULL;

    // These constant integers contain commands and enumerations
    // which must be defined for derived classes of CGenericModuleCmd
    m_dwMsgStatusList          = UNDEFINED;
    m_dwMsgStatusListAll       = UNDEFINED;
    m_dwMsgStatusHeader        = UNDEFINED;
    m_dwMsgPrivateListAll      = UNDEFINED;
    m_dwMsgPropertyListAll     = UNDEFINED;
    m_dwMsgPropertyHeaderAll   = UNDEFINED;
    m_dwCtlGetPrivProperties   = UNDEFINED;
    m_dwCtlGetCommProperties   = UNDEFINED;
    m_dwCtlGetROPrivProperties = UNDEFINED;
    m_dwCtlGetROCommProperties = UNDEFINED;
    m_dwCtlSetPrivProperties   = UNDEFINED;
    m_dwCtlSetCommProperties   = UNDEFINED;
    m_dwClusterEnumModule      = UNDEFINED;
    m_pfnOpenClusterModule     = NULL;
    m_pfnCloseClusterModule    = NULL;
    m_pfnClusterModuleControl  = NULL;
    m_pfnClusterOpenEnum       = NULL;
    m_pfnClusterCloseEnum      = NULL;
    m_pfnWrapClusterEnum       = NULL;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::~CGenericModuleCmd
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hModule               (used by CloseModule)
//      m_hCluster              (used by CloseCluster)
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericModuleCmd::~CGenericModuleCmd()
{
    CloseModule();
    CloseCluster();
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::OpenCluster
//
//  Routine Description:
//      Opens a handle to the cluster
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_strClusterName            The name of the cluster
//      m_hCluster                  The handle to the cluster
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::OpenCluster()
{
    DWORD sc = ERROR_SUCCESS;

    if( m_hCluster )
    {
        goto Cleanup;
    }

    m_hCluster = ::OpenCluster( m_strClusterName );
    if( m_hCluster == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

Cleanup:

    return sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::CloseCluster
//
//  Routine Description:
//      Closes the handle to the cluster
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hCluster                  The handle to the cluster
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericModuleCmd::CloseCluster()
{
    if( m_hCluster )
    {
        ::CloseCluster( m_hCluster );
        m_hCluster = NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::OpenModule
//
//  Routine Description:
//      Opens a handle to the module
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_strModuleName             The name of the module
//      m_hModule                   The handle to the module
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::OpenModule()
{
    DWORD sc = ERROR_SUCCESS;

    assert(m_pfnOpenClusterModule);

    if ( !m_strModuleName )
    {
        sc = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    m_hModule = m_pfnOpenClusterModule( m_hCluster, m_strModuleName );

    if ( m_hModule == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

Cleanup:

    return sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::CloseModule
//
//  Routine Description:
//      Closes the handle to the module
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hModule                   The handle to the module
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericModuleCmd::CloseModule()
{
    if( m_hModule != NULL )
    {
        assert(m_pfnCloseClusterModule);
        m_pfnCloseClusterModule( m_hModule );
        m_hModule = NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::Execute
//
//  Routine Description:
//      Takes a command line option and determines which command to
//      execute.  If no command line option specified, gets the next one
//      automatically.  If the token is not identied as being handle-able
//      in this class, the token is passed up to CGenericModuleCmd::Execute
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::Execute( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;

    // Look up the command
    switch( thisOption.GetType() )
    {
        case optHelp:
            sc = PrintHelp();
            break;

        case optProperties:
            sc = DoProperties( thisOption, COMMON );
            break;

        case optPrivateProperties:
            sc = DoProperties( thisOption, PRIVATE );
            break;

        case optStatus:
            sc = Status( &thisOption );
            break;

        default:
        {
            CSyntaxException se( SeeHelpStringID() );
            se.LoadMessage( IDS_INVALID_OPTION, thisOption.GetName() );
            throw se;
            break;
        }
    } // switch:

    return sc;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::PrintHelp
//
//  Routine Description:
//      Prints out the generic help message for the cluster.exe tool
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      Same as PrintMessage
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::PrintHelp()
{
    return PrintMessage( MSG_HELP_CLUSTER );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::SeeHelpStringID
//
//      Provide the message ID of the string that shows which command line to
//      use to see help specific to this command.  Defaults to that for the
//      command line that shows how to get the general help message.
//
//  Arguments:
//      None.
//
//  Exceptions:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      The appropriate message ID.  Overridden by classes that have their
//      own specific help string.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::SeeHelpStringID() const
{
    return MSG_SEE_CLUSTER_HELP;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::Status
//
//  Routine Description:
//      Prints out the status of the module.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_strModuleName             Name of module.  If non-NULL, Status() prints
//                                  out the status of the specified module.
//                                  Otherwise, prints status of all modules.
//      m_dwMsgStatusList           Field titles for listing status of module
//      m_dwMsgStatusHeader         Header for statuses
//      m_dwClusterEnumModule       Command for opening enumeration
//      m_dwMsgStatusListAll        Message for listing status of multiple modules
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::Status( const CCmdLineOption * pOption )
    throw( CSyntaxException )
{
    DWORD dwError = ERROR_SUCCESS;

    // pOption will be NULL if this function has been called as the
    // default action.
    if ( pOption != NULL )
    {
        // This option takes no values.
        if ( pOption->GetValues().size() != 0 )
        {
            CSyntaxException se( SeeHelpStringID() );
            se.LoadMessage( MSG_OPTION_NO_VALUES, pOption->GetName() );
            throw se;
        }

        // This option takes no parameters.
        if ( pOption->GetParameters().size() != 0 )
        {
            CSyntaxException se( SeeHelpStringID() );
            se.LoadMessage( MSG_OPTION_NO_PARAMETERS, pOption->GetName() );
            throw se;
        }
    }

    dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    // if m_strModuleName is non-empty, print out the status
    // of the current module and return.
    if( m_strModuleName.IsEmpty() == FALSE )
    {
        assert( m_dwMsgStatusList != UNDEFINED &&  m_dwMsgStatusHeader != UNDEFINED);
        PrintMessage( m_dwMsgStatusList, (LPCWSTR) m_strModuleName );
        PrintMessage( m_dwMsgStatusHeader );
        return PrintStatus( m_strModuleName );
    }


    // Otherwise, print out the status of all modules.

    assert( m_dwClusterEnumModule != UNDEFINED );
    HCLUSENUM hEnum = ClusterOpenEnum( m_hCluster, m_dwClusterEnumModule );

    if( !hEnum )
        return GetLastError();

    assert( m_dwMsgStatusListAll != UNDEFINED &&  m_dwMsgStatusHeader != UNDEFINED);
    PrintMessage( m_dwMsgStatusListAll );
    PrintMessage( m_dwMsgStatusHeader );

    DWORD dwIndex = 0;
    DWORD dwType = 0;
    LPWSTR lpszName = NULL;

    dwError = ERROR_SUCCESS;

    for( dwIndex = 0; dwError == ERROR_SUCCESS; dwIndex++ )
    {

        dwError = WrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );

        if( dwError == ERROR_SUCCESS )
        {
            dwError = PrintStatus( lpszName );
            if (dwError != ERROR_SUCCESS)
                PrintSystemError(dwError);
        }


        if( lpszName )
            LocalFree( lpszName );
    }


    if( dwError == ERROR_NO_MORE_ITEMS )
        dwError = ERROR_SUCCESS;

    ClusterCloseEnum( hEnum );

    return dwError;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::DoProperties
//
//  Routine Description:
//      Dispatches the property command to either Get or Set properties
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Name of module.  If non-NULL, prints
//                                  out properties for the specified module.
//                                  Otherwise, prints props for all modules.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::DoProperties( const CCmdLineOption & thisOption,
                                       PropertyType ePropertyType )
    throw( CSyntaxException )
{
    // If no module name was specified, assume we want
    // to list the properties for all modules of this type
    if ( m_strModuleName.IsEmpty() != FALSE )
        return AllProperties( thisOption, ePropertyType );

    DWORD dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    dwError = OpenModule();
    if( dwError != ERROR_SUCCESS )
        return dwError;


    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

    // If there are no property-value pairs on the command line,
    // then we print the properties otherwise we set them.
    if( paramList.size() == 0 )
    {
        PrintMessage( ePropertyType==PRIVATE ? MSG_PRIVATE_LISTING : MSG_PROPERTY_LISTING,
            (LPCWSTR) m_strModuleName );
        PrintMessage( m_dwMsgPropertyHeaderAll );

        return GetProperties( thisOption, ePropertyType, m_strModuleName );
    }
    else
    {
        return SetProperties( thisOption, ePropertyType );
    }
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::AllProperties
//
//  Routine Description:
//      Prints out properties for all modules
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_strModuleName             Name of module.  If non-NULL, prints
//                                  out properties for the specified module.
//                                  Otherwise, prints props for all modules.
//      m_dwClusterEnumModule       Command for opening enumeration
//      m_dwMsgPrivateListAll       Fields header for private prop listing of all modules
//      m_dwMsgPropertyListAll      Fields header for property listing of all modules
//      m_dwMsgPropertyHeaderAll    Header for prop listing of all modules
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::AllProperties( const CCmdLineOption & thisOption,
                                        PropertyType ePropType )
    throw( CSyntaxException )
{
    DWORD dwError;
    DWORD dwIndex;
    DWORD dwType;
    LPWSTR lpszName;

    dwError = OpenCluster();
    if( dwError != ERROR_SUCCESS )
        return dwError;

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se( SeeHelpStringID() );
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // Enumerate the resources
    assert( m_dwClusterEnumModule != UNDEFINED );
    HCLUSENUM hEnum = ClusterOpenEnum(m_hCluster, m_dwClusterEnumModule);
    if (!hEnum)
        return GetLastError();

    assert( m_dwMsgPrivateListAll != UNDEFINED &&
            m_dwMsgPropertyListAll != UNDEFINED &&
            m_dwMsgPropertyHeaderAll != UNDEFINED );

    // Print the header
    PrintMessage( ePropType==PRIVATE ? m_dwMsgPrivateListAll : m_dwMsgPropertyListAll );
    PrintMessage( m_dwMsgPropertyHeaderAll );

    // Print out status for all resources
    dwError = ERROR_SUCCESS;
    for (dwIndex=0; dwError != ERROR_NO_MORE_ITEMS; dwIndex++)
    {
        dwError = WrapClusterEnum( hEnum, dwIndex, &dwType, &lpszName );

        if( dwError == ERROR_SUCCESS )
        {
            dwError = GetProperties( thisOption, ePropType, lpszName );
            if (dwError != ERROR_SUCCESS)
                PrintSystemError(dwError);
        }

        if( lpszName )
            LocalFree( lpszName );
    }


    ClusterCloseEnum( hEnum );

    return ERROR_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::GetProperties
//
//  Routine Description:
//      Prints out properties for the specified module
//
//  Arguments:
//      IN  const vector<CCmdLineParameter> & paramList
//          Contains the list of property-value pairs to be set
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//      IN  LPCWSTR lpszModuleName
//          Name of the module
//
//  Member variables used / set:
//      m_hModule                   Module handle
//      m_dwCtlGetROPrivProperties  Control code for read only private properties
//      m_dwCtlGetROCommProperties  Control code for read only common properties
//      m_dwCtlGetPrivProperties    Control code for private properties
//      m_dwCtlGetCommProperties    Control code for common properties
//      m_pfnOpenClusterModule      Function to open a module
//      m_pfnClusterModuleControl   Function to conrol a module
//
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::GetProperties( const CCmdLineOption & thisOption,
                                        PropertyType ePropType, LPCWSTR lpszModuleName )
{
    DWORD dwError = ERROR_SUCCESS;
    HCLUSMODULE hModule;

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        CSyntaxException se( SeeHelpStringID() );
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // If no lpszModuleName specified, use current module,
    // otherwise open the specified module
    if (!lpszModuleName)
    {
        hModule = m_hModule;
    }
    else
    {
        assert(m_pfnOpenClusterModule);
        hModule = m_pfnOpenClusterModule( m_hCluster, lpszModuleName );
        if( !hModule )
            return GetLastError();
    }


    // Use the proplist helper class.
    CClusPropList PropList;

    // allocate a reasonably sized buffer
    dwError = PropList.ScAllocPropList( DEFAULT_PROPLIST_BUFFER_SIZE );
    if ( dwError != ERROR_SUCCESS )
        return dwError;

    DWORD nBytesReturned = 0;

    // Get R/O properties
    assert( m_dwCtlGetROPrivProperties != UNDEFINED && m_dwCtlGetROCommProperties != UNDEFINED );
    DWORD dwControlCode = ePropType==PRIVATE ? m_dwCtlGetROPrivProperties
                             : m_dwCtlGetROCommProperties;

    assert(m_pfnClusterModuleControl);
    dwError = m_pfnClusterModuleControl(
        hModule,
        NULL, // hNode
        dwControlCode,
        0, // &InBuffer,
        0, // nInBufferSize,
        PropList.Plist(),
        (DWORD) PropList.CbBufferSize(),
        &nBytesReturned );

    if(  dwError == ERROR_MORE_DATA ) {

        // our original size is not large enough; ask for more
        dwError = PropList.ScAllocPropList( nBytesReturned );
        if ( dwError != ERROR_SUCCESS )
            return dwError;

        dwError = m_pfnClusterModuleControl(
                      hModule,
                      NULL, // hNode
                      dwControlCode,
                      0, // &InBuffer,
                      0, // nInBufferSize,
                      PropList.Plist(),
                      (DWORD) PropList.CbBufferSize(),
                      &nBytesReturned );
    }

    if ( dwError != ERROR_SUCCESS ) {
        return dwError;
    }

    PropList.InitSize( nBytesReturned );
    dwError = ::PrintProperties( PropList, thisOption.GetValues(), READONLY, lpszModuleName );
    if (dwError != ERROR_SUCCESS)
        return dwError;


    // Get R/W properties
    PropList.ClearPropList();

    assert( m_dwCtlGetPrivProperties != UNDEFINED && m_dwCtlGetCommProperties != UNDEFINED );
    dwControlCode = ePropType==PRIVATE ? m_dwCtlGetPrivProperties
                               : m_dwCtlGetCommProperties;

    dwError = m_pfnClusterModuleControl(
        hModule,
        NULL, // hNode
        dwControlCode,
        0, // &InBuffer,
        0, // nInBufferSize,
        PropList.Plist(),
        (DWORD) PropList.CbBufferSize(),
        &nBytesReturned );

    if( dwError == ERROR_MORE_DATA ) {

        dwError = PropList.ScAllocPropList( nBytesReturned );
        if ( dwError != ERROR_SUCCESS )
            return dwError;

        dwError = m_pfnClusterModuleControl(
                      hModule,
                      NULL, // hNode
                      dwControlCode,
                      0, // &InBuffer,
                      0, // nInBufferSize,
                      PropList.Plist(),
                      (DWORD) PropList.CbBufferSize(),
                      &nBytesReturned );
    }

    if( dwError != ERROR_SUCCESS ) {
        return dwError;
    }

    PropList.InitSize( nBytesReturned );
    dwError = ::PrintProperties( PropList, thisOption.GetValues(), READWRITE, lpszModuleName );

    return dwError;

} //*** CGenericModuleCmd::GetProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGenericModuleCmd::SetProperties
//
//  Routine Description:
//      Set the properties for the specified module
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hModule                   Module handle
//      m_dwCtlGetPrivProperties    Control code for private properties
//      m_dwCtlGetCommProperties    Control code for common properties
//      m_dwCtlSetROPrivProperties  Control code for read only private properties
//      m_dwCtlSetROCommProperties  Control code for read only common properties
//      m_dwCtlSetPrivProperties    Control code for private properties
//      m_dwCtlSetCommProperties    Control code for common properties
//      m_pfnOpenClusterModule      Function to open a module
//      m_pfnClusterModuleControl   Function to conrol a module
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGenericModuleCmd::SetProperties( const CCmdLineOption & thisOption,
                                        PropertyType ePropType )
    throw( CSyntaxException )
{
    assert (m_hModule);

    DWORD dwError = ERROR_SUCCESS;
    DWORD dwControlCode;
    DWORD dwBytesReturned = 0;

    CClusPropList NewProps;
    CClusPropList CurrentProps;

    // First get the existing properties...
    assert( m_dwCtlGetPrivProperties != UNDEFINED && m_dwCtlGetCommProperties != UNDEFINED );
    dwControlCode = ePropType==PRIVATE ? m_dwCtlGetPrivProperties
                                       : m_dwCtlGetCommProperties;

    // Use the proplist helper class.
    dwError = CurrentProps.ScAllocPropList( DEFAULT_PROPLIST_BUFFER_SIZE );
    if ( dwError != ERROR_SUCCESS )
        return dwError;

    assert(m_pfnClusterModuleControl);
    dwError = m_pfnClusterModuleControl(
        m_hModule,
        NULL, // hNode
        dwControlCode,
        0, // &InBuffer,
        0, // nInBufferSize,
        CurrentProps.Plist(),
        (DWORD) CurrentProps.CbBufferSize(),
        &dwBytesReturned );

    if ( dwError == ERROR_MORE_DATA ) {
        dwError = CurrentProps.ScAllocPropList( dwBytesReturned );
        if ( dwError != ERROR_SUCCESS )
            return dwError;

        dwError = m_pfnClusterModuleControl(
                      m_hModule,
                      NULL, // hNode
                      dwControlCode,
                      0, // &InBuffer,
                      0, // nInBufferSize,
                      CurrentProps.Plist(),
                      (DWORD) CurrentProps.CbBufferSize(),
                      &dwBytesReturned );
    } 

    if ( dwError != ERROR_SUCCESS ) {
        return dwError;
    }

    CurrentProps.InitSize( dwBytesReturned );

    // If values have been specified with this option, then it means that we want
    // to set these properties to their default values. So, there has to be
    // exactly one parameter and it has to be /USEDEFAULT.
    if ( thisOption.GetValues().size() != 0 )
    {
        const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

        if ( paramList.size() != 1 )
        {
            CSyntaxException se( SeeHelpStringID() );

            se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_WITH_NAME, thisOption.GetName() );
            throw se;
        }

        if ( paramList[0].GetType() != paramUseDefault )
        {
            CSyntaxException se( SeeHelpStringID() );

            se.LoadMessage( MSG_INVALID_PARAMETER, paramList[0].GetName() );
            throw se;
        }

        // This parameter does not take any values.
        if ( paramList[0].GetValues().size() != 0 )
        {
            CSyntaxException se( SeeHelpStringID() );

            se.LoadMessage( MSG_PARAM_NO_VALUES, paramList[0].GetName() );
            throw se;
        }

        dwError = ConstructPropListWithDefaultValues( CurrentProps, NewProps, thisOption.GetValues() );
        if( dwError != ERROR_SUCCESS )
            return dwError;

    } // if: values have been specified with this option.
    else
    {
        dwError = NewProps.ScAllocPropList( DEFAULT_PROPLIST_BUFFER_SIZE );
        if ( dwError != ERROR_SUCCESS )
            return dwError;

        dwError = ConstructPropertyList( CurrentProps, NewProps, thisOption.GetParameters(), FALSE, SeeHelpStringID() );
        if (dwError != ERROR_SUCCESS)
            return dwError;

    } // else: no values have been specified with this option.

    // Call the set function...
    assert( m_dwCtlSetPrivProperties != UNDEFINED && m_dwCtlSetCommProperties != UNDEFINED );
    dwControlCode = ePropType==PRIVATE ? m_dwCtlSetPrivProperties
                             : m_dwCtlSetCommProperties;

    dwBytesReturned = 0;
    assert(m_pfnClusterModuleControl);
    dwError = m_pfnClusterModuleControl(
        m_hModule,
        NULL, // hNode
        dwControlCode,
        NewProps.Plist(),
        (DWORD) NewProps.CbBufferSize(),
        0,
        0,
        &dwBytesReturned );

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\cmdline.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      CmdLine.h
//
//  Implementation File:
//      CmdLine.cpp
//
//  Description:
//      Definition of the CCommandLine and related class.
//
//  Maintained By:
//      David Potter    (DavidP)    11-JUL-2001
//      Vijayendra Vasu (Vvasu)     20-OCT-1998
//
//  Revision History:
//      001. The class CCommandLine has been drastically changed from the previous
//      version. Previously, the function GetNextOption was being used to get the
//      next token from the command line and parsing was done by each of the command
//      handling classes (like CResourceCmd). Now GetNextOption gets the next option
//      along with all the parameters to the option. No parsing need be done by the
//      command handling classes.
//
//  Examples: 
//      cluster res "Cluster IP Address" /status
//      Here, the option "status" has no parameters and no values
//
//      cluster res /node:vvasu-node-1
//      Here, the option "node" has one value "vvasu-node-1". This value
//      is separated from the name of the option by a ":" 
//
//      cluster res "Cluster IP Address" /priv Network="Corporate Address" EnableNetBIOS=1
//      Here, the /priv option has two paramters, "Network" and "EnableNetBIOS"
//      The parameters are separated from each other by white spaces.
//      Each of these parameters take a value. The value is separated from
//      the parameter by a '='. If a parameter takes multiple values, these
//      values are separated from each other by ','.
//
//      cluster group myGroup /moveto:myNode /wait:10
//      In the previous example "Network" and "EnableNetBIOS" were unknown parameters.
//      Known parameters, such as "wait" are preceded by a '/' and separated from their
//      values by a ':'. They look like options, but they are actually treated as
//      parameters to the previous option.
//
//      The separator characters mentioned in the examples above are not 
//      hard coded.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
//  Include files
/////////////////////////////////////////////////////////////////////////////

#pragma warning( push )
#pragma warning( disable : 4100 )   // vector class instantiation error
#include <vector>

using namespace std;

#include "cmderror.h"

/////////////////////////////////////////////////////////////////////////////
//  External variable declarations
/////////////////////////////////////////////////////////////////////////////
extern const WORD ValueFormatToClusPropFormat[];


/////////////////////////////////////////////////////////////////////////////
//  Enumerations and type definitions
/////////////////////////////////////////////////////////////////////////////

// Types of objects that can be administered using cluster.exe
enum ObjectType
{
    objInvalid,
    objCluster,
    objNode,
    objGroup,
    objResource,
    objResourceType,
    objNetwork,
    objNetInterface

}; //*** enum ObjectType


// Options that are available for each of the above object types
enum OptionType
{
    optInvalid,
    optDefault,

    //   Common options
    optCluster,
    optCreate,
    optDelete,
    optHelp,
    optMove,
    optList,
    optListOwners,
    optOnline,
    optOffline,
    optProperties,
    optPrivateProperties,
    optRename,
    optStatus,

    // Cluster options
    optQuorumResource,
    optVersion,
    optSetFailureActions,
    optRegisterAdminExtensions,
    optUnregisterAdminExtensions,
    optAddNodes,
    optChangePassword,
    optListNetPriority,
    optSetNetPriority,

    // Node options
    optPause,
    optResume,
    optEvict,
    optForceCleanup,
    optStartService,
    optStopService,

    // Group options
    optSetOwners,

    // Resource options
    optAddCheckPoints,
    optAddCryptoCheckPoints,
    optAddDependency,
    optAddOwner,
    optFail,
    optGetCheckPoints,
    optGetCryptoCheckPoints,
    optListDependencies,
    optRemoveDependency,
    optRemoveOwner,
    optRemoveCheckPoints,
    optRemoveCryptoCheckPoints,

    // Network options
    optListInterfaces

}; //*** enum OptionType


// Parameters that can be passed with each of the above options
enum ParameterType
{
    paramUnknown,
    paramCluster,
    paramDisplayName,
    paramDLLName,
    paramGroupName,
    paramIsAlive,
    paramLooksAlive,
    paramMaxLogSize,
    paramNetworkName,
    paramNodeName,
    paramPath,
    paramResType,
    paramSeparate,
    paramUseDefault,
    paramWait,
    paramUser,
    paramPassword,
    paramIPAddress,
    paramVerbose,
    paramUnattend,
    paramWizard,
    paramSkipDC, // password change
    paramTest, // password change
    paramQuiet, // password change
    paramMinimal
}; //*** enum ParameterType


// Format of the values that can be passed to parameters
enum ValueFormat
{
    vfInvalid = -2,
    vfUnspecified = -1,
    vfBinary = 0,
    vfDWord,
    vfSZ,
    vfExpandSZ,
    vfMultiSZ,
    vfULargeInt,
    vfSecurity

}; //*** enum ValueFormat



// The types of token retrieved during parsing.
enum TypeOfToken
{
    ttInvalid,
    ttEndOfInput,
    ttNormal,
    ttOption,
    ttOptionValueSep,
    ttParamValueSep,
    ttValueSep

}; //*** enum TypeOfToken


/////////////////////////////////////////////////////////////////////////////
//  Forward declaration
/////////////////////////////////////////////////////////////////////////////
class CParseException;


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CParseState
//
//  Purpose:
//      Stores the current state of the parsing of the command line
//
/////////////////////////////////////////////////////////////////////////////
class CParseState
{
private:
    // If the next token has already been previewed, m_bNextTokenReady is set
    // to TRUE. The token and its type are cached.
    BOOL m_bNextTokenReady;             // Has the next token been viewed already?
    TypeOfToken m_ttNextTokenType;      // The type of the cached token
    CString m_strNextToken;             // The cached token

    void ReadToken( CString & strToken );

public:

    LPCWSTR m_pszCommandLine;           // The original command line
    LPCWSTR m_pszCurrentPosition;       // The position for parsing the next token

    CParseState( LPCWSTR pszCmdLine );
    CParseState( const CParseState & ps );
    ~CParseState( void );

    const CParseState & operator=( const CParseState & ps );

    TypeOfToken PreviewNextToken( CString & strNextToken ) throw( CParseException );
    TypeOfToken GetNextToken( CString & strNextToken ) throw( CParseException );

    void ReadQuotedToken( CString & strToken ) throw( CParseException );

}; //*** class CParseState


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CException
//
//  Purpose:
//      Exception base class.
//
/////////////////////////////////////////////////////////////////////////////
class CException
{
public:

    // Default constructor.
    CException( void ) {}

    // Copy constructor
    CException( const CException & srcException ) 
        : m_strErrorMsg( srcException.m_strErrorMsg ) {}

    // Destructor
    virtual ~CException( void ) { }

    DWORD LoadMessage( DWORD dwMessage, ... );

    CString m_strErrorMsg;

}; //*** class CException


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CParseException
//
//  Purpose:
//      This is the exception that is thrown if there is a parsing error.
//
/////////////////////////////////////////////////////////////////////////////
class CParseException : public CException
{
}; //*** class CParseException


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CSyntaxException
//
//  Purpose:
//      This exception is thrown if there is a syntax error.
//
/////////////////////////////////////////////////////////////////////////////
class CSyntaxException : public CException
{
public:

    CSyntaxException( DWORD idSeeHelp = MSG_SEE_CLUSTER_HELP );

    DWORD SeeHelpID() const;

private:

    DWORD   m_idSeeHelp;
}; //*** class CSyntaxException

inline DWORD CSyntaxException::SeeHelpID() const
{
    return m_idSeeHelp;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CParser
//
//  Purpose:
//      The base class of all classes capable of parsing the command line
//
/////////////////////////////////////////////////////////////////////////////
class CParser
{
protected:
    virtual void ParseValues( CParseState & parseState, vector<CString> & vstrValues );

public:
    CParser( void )
    {
    }

    virtual ~CParser( void )
    {
    }

    virtual void Parse( CParseState & parseState ) throw( CParseException ) = 0;
    virtual void Reset( void ) = 0;

}; //*** class CParser


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CCmdLineParameter
//
//  Purpose:
//      Parses and stores one command line parameter
//
/////////////////////////////////////////////////////////////////////////////
class CCmdLineParameter : public CParser
{
private:
    CString                 m_strParamName;
    ParameterType           m_paramType;
    ValueFormat             m_valueFormat;
    CString                 m_strValueFormatName;
    vector<CString>         m_vstrValues;

public:
    CCmdLineParameter( void );
    ~CCmdLineParameter( void );

    ParameterType               GetType( void ) const;
    ValueFormat                 GetValueFormat( void ) const;
    const CString &             GetValueFormatName( void ) const;
    const CString &             GetName( void ) const;
    const vector< CString > &   GetValues( void ) const;
    void                        GetValuesMultisz( CString & strReturnValue ) const;

    BOOL ReadKnownParameter( CParseState & parseState ) throw( CParseException );
    void Parse( CParseState & parseState ) throw( CParseException );
    void Reset( void );

}; //*** class CCmdLineParameter


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CCmdLineOption
//
//  Purpose:
//      Parses and stores one command line option and all its parameters
//
/////////////////////////////////////////////////////////////////////////////
class CCmdLineOption : public CParser
{
private:
    OptionType                  m_optionType;
    CString                     m_strOptionName;
    vector< CString >           m_vstrValues;
    vector< CCmdLineParameter > m_vparParameters;

public:
    CCmdLineOption( void );
    ~CCmdLineOption( void );

    OptionType                          GetType( void ) const;
    const CString &                     GetName( void ) const;
    const vector< CString > &           GetValues( void ) const;
    const vector< CCmdLineParameter > & GetParameters( void ) const;

    void Parse( CParseState & parseState ) throw( CParseException );
    void Reset( void );

}; //*** class CCmdLineOption


/////////////////////////////////////////////////////////////////////////////
//
//  Class Name:
//      CCommandLine
//
//  Purpose:
//      Handles all the parsing of the entire command line
//
/////////////////////////////////////////////////////////////////////////////
class CCommandLine : public CParser
{
private:
    CString                     m_strClusterName;
    vector< CString >           m_strvectorClusterNames;
    CString                     m_strObjectName;
    ObjectType                  m_objectType;
    vector< CCmdLineOption >    m_voptOptionList;
    CParseState                 m_parseState;

public:
    CCommandLine( const CString & strCommandLine );
    ~CCommandLine( void );

    const CString &                     GetClusterName( void ) const;
    const vector< CString > &           GetClusterNames( void ) const;
    ObjectType                          GetObjectType( void ) const;
    const CString &                     GetObjectName( void ) const;
    const vector< CCmdLineOption > &    GetOptions( void ) const;

    void ParseStageOne( void ) throw( CParseException, CSyntaxException );
    void ParseStageTwo( void ) throw( CParseException, CSyntaxException );
    void Parse( CParseState & parseState ) throw( CParseException, CSyntaxException );
    void Reset( void );

}; //*** class CCommandLine

#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\nameutilstub.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      NameUtilStub.cpp
//
//  Description:
//      File to enable use of NameUtil functions from Mgmt\ClusCfg.
//
//  Maintained By:
//      John Franco (JFranco) 13-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Util.h"
#include "Resource.h"

#include <NameUtil.h>
#include <LoadString.h>
#include <Common.h>

extern HINSTANCE g_hInstance; // Required by NameUtil functions; defined in cluster.cpp.

#include <NameUtilSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\netcmd.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      NetCmd.cpp
//
//  Description:
//      Implements commands which may be performed on networks.
//
//  Author:
//      Charles Stacy Harris III (stacyh)     20-March-1997
//      Michael Burton (t-mburt)              04-Aug-1997
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include "cluswrap.h"
#include "netcmd.h"

#include "cmdline.h"
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkCmd::CNetworkCmd
//
//	Routine Description:
//		Constructor
//		Initializes all the DWORD params used by CGenericModuleCmd and
//		CHasInterfaceModuleCmd to provide generic functionality.
//
//	Arguments:
//		IN	LPCWSTR lpszClusterName 			
//			Cluster name. If NULL, opens default cluster.
//
//		IN	CCommandLine & cmdLine				
//			CommandLine Object passed from DispatchCommand
//
//	Member variables used / set:
//		All.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkCmd::CNetworkCmd( LPCWSTR lpszClusterName, CCommandLine & cmdLine ) :
	CGenericModuleCmd( cmdLine ), CHasInterfaceModuleCmd( cmdLine ), 
	CRenamableModuleCmd( cmdLine )
{
	m_strClusterName = lpszClusterName;
	m_strModuleName.Empty();

	m_hCluster = NULL;
	m_hModule  = NULL;

	m_dwMsgStatusList		   = MSG_NETWORK_STATUS_LIST;
	m_dwMsgStatusListAll	   = MSG_NETWORK_STATUS_LIST_ALL;
	m_dwMsgStatusHeader 	   = MSG_NETWORK_STATUS_HEADER;
	m_dwMsgPrivateListAll	   = MSG_PRIVATE_LISTING_NETWORK_ALL;
	m_dwMsgPropertyListAll	   = MSG_PROPERTY_LISTING_NETWORK_ALL;
	m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_NETWORK_ALL;
	m_dwCtlGetPrivProperties   = CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES;
	m_dwCtlGetCommProperties   = CLUSCTL_NETWORK_GET_COMMON_PROPERTIES;
	m_dwCtlGetROPrivProperties = CLUSCTL_NETWORK_GET_RO_PRIVATE_PROPERTIES;
	m_dwCtlGetROCommProperties = CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES;
	m_dwCtlSetPrivProperties   = CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES;
	m_dwCtlSetCommProperties   = CLUSCTL_NETWORK_SET_COMMON_PROPERTIES;
	m_dwClusterEnumModule	   = CLUSTER_ENUM_NETWORK;
	m_pfnOpenClusterModule	   = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterNetwork;
	m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  CloseClusterNetwork;
	m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterNetworkControl;

	// ListInterface Parameters
	m_dwMsgStatusListInterface	 = MSG_NET_LIST_INTERFACE;
	m_dwClusterEnumModuleNetInt  = CLUSTER_NETWORK_ENUM_NETINTERFACES;
	m_pfnClusterOpenEnum		 = (HCLUSENUM(*)(HCLUSMODULE,DWORD)) ClusterNetworkOpenEnum;
	m_pfnClusterCloseEnum		 = (DWORD(*)(HCLUSENUM)) ClusterNetworkCloseEnum;
	m_pfnWrapClusterEnum		 = (DWORD(*)(HCLUSENUM,DWORD,LPDWORD,LPWSTR*)) WrapClusterNetworkEnum;

	// Renamable Properties
	m_dwMsgModuleRenameCmd	  = MSG_NETWORKCMD_RENAME;
	m_pfnSetClusterModuleName = (DWORD(*)(HCLUSMODULE,LPCWSTR)) SetClusterNetworkName;

}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkCmd::Execute
//
//	Routine Description:
//		Gets the next command line parameter and calls the appropriate
//		handler.  If the command is not recognized, calls Execute of
//		parent classes (first CRenamableModuleCmd, then CHasInterfaceModuleCmd)
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetworkCmd::Execute()
{
	m_theCommandLine.ParseStageTwo();

	DWORD dwReturnValue = ERROR_SUCCESS;

	const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

	vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
	vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

	CSyntaxException se( SeeHelpStringID() ); 
	
	if ( optionList.empty() )
		return Status( NULL );

	while ( ( curOption != lastOption ) && ( dwReturnValue == ERROR_SUCCESS ) )
	{
		switch ( curOption->GetType() )
		{
			case optHelp:
			{
				// If help is one of the options, process no more options.
				return PrintHelp();
			}

			case optDefault:
			{
				const vector<CCmdLineParameter> & paramList = curOption->GetParameters();

                //  Check number of parameters.
                if ( paramList.size() == 0 )
                {
                    se.LoadMessage( IDS_MISSING_PARAMETERS );
                    throw se;
                }
                else if ( paramList.size() > 1 )
                {
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_NO_NAME );
                    throw se;
                }
                else // just one parameter present
				{
					const CCmdLineParameter & param = paramList[0];

                    //  Check parameter type.
                    if ( param.GetType() != paramUnknown )
                    {
                        se.LoadMessage( MSG_INVALID_PARAMETER, param.GetName() );
                        throw se;
                    }

					// This parameter takes no values.
					if ( param.GetValues().size() != 0 )
					{
						se.LoadMessage( MSG_PARAM_NO_VALUES, param.GetName() );
						throw se;
					}

					m_strModuleName = param.GetName();

					// No more options are provided, just show status.
					// For example: cluster myCluster node myNode
					if ( ( curOption + 1 ) == lastOption )
					{
						dwReturnValue = Status( NULL );
					}

				} // else: this option has the right number of parameters

				break;

			} // case optDefault

			default:
			{
				dwReturnValue = CRenamableModuleCmd::Execute( *curOption, DONT_PASS_HIGHER );

				if (dwReturnValue == ERROR_NOT_HANDLED)
					dwReturnValue = CHasInterfaceModuleCmd::Execute( *curOption );
			}

		} // switch: based on the type of option

		PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
		++curOption;
	} // for each option in the list

	return dwReturnValue;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkCmd::PrintHelp
//
//	Routine Description:
//		Prints help for Networks
//
//	Arguments:
//		None.
//
//	Member variables used / set:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetworkCmd::PrintHelp()
{
	return PrintMessage( MSG_HELP_NETWORK );
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkCmd::SeeHelpStringID
//
//  Routine Description:
//      Provides the message ID of the string that shows what command line to
//      use to get help for this kind of command.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      The command-specific message ID.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetworkCmd::SeeHelpStringID() const
{
    return MSG_SEE_NETWORK_HELP;
}


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkCmd::PrintStatus
//
//	Routine Description:
//		Interprets the status of the module and prints out the status line
//		Required for any derived non-abstract class of CGenericModuleCmd
//
//	Arguments:
//		lpszNetworkName 			Name of the module
//
//	Member variables used / set:
//		m_hCluster					Cluster Handle
//
//	Return Value:
//		ERROR_SUCCESS				on success
//		Win32 Error code			on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetworkCmd::PrintStatus( LPCWSTR lpszNetworkName )
{
	DWORD dwError = ERROR_SUCCESS;

	CLUSTER_NETWORK_STATE nState;

	HNETWORK hNetwork = OpenClusterNetwork(m_hCluster, lpszNetworkName);
	if (!hNetwork)
		return GetLastError();

	nState = GetClusterNetworkState( hNetwork );

	if( nState == ClusterNetworkStateUnknown )
		return GetLastError();

	LPWSTR lpszStatus = NULL;

	switch( nState )
	{
		case ClusterNetworkUnavailable:
			LoadMessage( MSG_STATUS_UNAVAILABLE, &lpszStatus );
			break;

		case ClusterNetworkDown:
			LoadMessage( MSG_STATUS_DOWN, &lpszStatus );
			break;

		case ClusterNetworkPartitioned:
			LoadMessage( MSG_STATUS_PARTITIONED, &lpszStatus );
			break;

		case ClusterNetworkUp:
			LoadMessage( MSG_STATUS_UP, &lpszStatus );
			break;

		case ClusterNetworkStateUnknown:
		default:
			LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
	}

	dwError = PrintMessage( MSG_NETWORK_STATUS, lpszNetworkName, lpszStatus );

	// Since Load/FormatMessage uses LocalAlloc...
	if( lpszStatus )
		LocalFree( lpszStatus );

	CloseClusterNetwork(hNetwork);

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\netcmd.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995 - 2002 Microsoft Corporation
//
//  Module Name:
//      netcmd.h
//
//  Abstract:
//      Interface for functions which may be performed on a network object.
//
//  Author:
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "intrfc.h"
#include "rename.h"


class CCommandLine;

class CNetworkCmd : public CHasInterfaceModuleCmd,
                    public CRenamableModuleCmd
{
public:
    CNetworkCmd( LPCWSTR lpszClusterName, CCommandLine & cmdLine );
    DWORD Execute();

protected:

    DWORD PrintHelp();
    virtual DWORD SeeHelpStringID() const;
    DWORD PrintStatus( LPCWSTR lpszNetworkName );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\neticmd.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//
//      neticmd.cpp
//
//  Abstract:
//
//      Network Interface Commands
//      Implements commands which may be performed on network interfaces
//
//  Author:
//
//      Charles Stacy Harris III (stacyh)     20-March-1997
//      Michael Burton (t-mburt)              04-Aug-1997
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002  Updated for the security push.
//
//////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include "cluswrap.h"
#include "neticmd.h"

#include "cmdline.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::CNetInterfaceCmd
//
//  Routine Description:
//      Constructor
//      Because Network Interfaces do not fit into the CGenericModuleCmd
//      model very well (they don't have an m_strModuleName, but rather
//      they have a m_strNetworkName and m_strNodeName), almost all of
//      the functionality is implemented here instead of in CGenericModuleCmd.
//
//  Arguments:
//      IN  LPCWSTR pwszClusterName
//          Cluster name. If NULL, opens default cluster.
//
//      IN  CCommandLine & cmdLine
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaceCmd::CNetInterfaceCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
    CGenericModuleCmd( cmdLine )
{
    InitializeModuleControls();

    m_strClusterName = strClusterName;

    m_hCluster = NULL;
    m_hModule = NULL;

} //*** CNetInterfaceCmd::CNetInterfaceCmd


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::InitializeModuleControls
//
//  Routine Description:
//      Initializes all the DWORD commands used bye CGenericModuleCmd.
//      Usually these are found in the constructor, but it was easier to
//      put them all in one place in this particular case.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      All Module Controls.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterfaceCmd::InitializeModuleControls()
{
    m_dwMsgStatusList          = MSG_NETINT_STATUS_LIST;
    m_dwMsgStatusListAll       = MSG_NETINT_STATUS_LIST_ALL;
    m_dwMsgStatusHeader        = MSG_NETINTERFACE_STATUS_HEADER;
    m_dwMsgPrivateListAll      = MSG_PRIVATE_LISTING_NETINT_ALL;
    m_dwMsgPropertyListAll     = MSG_PROPERTY_LISTING_NETINT_ALL;
    m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_NETINT;
    m_dwCtlGetPrivProperties   = CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES;
    m_dwCtlGetCommProperties   = CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES;
    m_dwCtlGetROPrivProperties = CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES;
    m_dwCtlGetROCommProperties = CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES;
    m_dwCtlSetPrivProperties   = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;
    m_dwCtlSetCommProperties   = CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES;
    m_dwClusterEnumModule      = CLUSTER_ENUM_NETINTERFACE;
    m_pfnOpenClusterModule     = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterNetInterface;
    m_pfnCloseClusterModule    = (BOOL(*)(HCLUSMODULE))  CloseClusterNetInterface;
    m_pfnClusterModuleControl  = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterNetInterfaceControl;

} //*** CNetInterfaceCmd::InitializeModuleControls


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::~CNetInterfaceCmd
//
//  Routine Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_hModule                   Module Handle
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaceCmd::~CNetInterfaceCmd()
{
    CloseModule();
    CloseCluster();
} //*** CNetInterfaceCmd::~CNetInterfaceCmd()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::Execute
//
//  Routine Description:
//      Gets the next command line parameter and calls the appropriate
//      handler.  If the command is not recognized, calls Execute of
//      parent class (CGenericModuleCmd)
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::Execute()
{
    DWORD   sc = ERROR_SUCCESS;

    m_theCommandLine.ParseStageTwo();

    const vector<CCmdLineOption> & optionList = m_theCommandLine.GetOptions();

    vector<CCmdLineOption>::const_iterator curOption = optionList.begin();
    vector<CCmdLineOption>::const_iterator lastOption = optionList.end();

    CSyntaxException se( SeeHelpStringID() );

    // No options specified. Execute the default command.
    if ( optionList.empty() )
    {
        sc = Status( NULL );
        goto Cleanup;
    }

    // Process one option after another.
    while ( ( curOption != lastOption ) && ( sc == ERROR_SUCCESS ) )
    {
        // Look up the command
        switch( curOption->GetType() )
        {
            case optHelp:
            {
                // If help is one of the options, process no more options.
                sc = PrintHelp();
                break;
            }

            case optDefault:
            {
                // The node and network names can be specified in two ways.
                // Either as: cluster netint myNetName myNodeName /status
                // Or as: cluster netint /node:myNodeName /net:myNetName /status

                const vector<CCmdLineParameter> & paramList = curOption->GetParameters();
                const CCmdLineParameter *pParam1 = NULL;
                const CCmdLineParameter *pParam2 = NULL;

                //  Check number of parameters.
                if ( paramList.size() < 2 )
                {
                    se.LoadMessage( IDS_MISSING_PARAMETERS );
                    throw se;
                }
                else if ( paramList.size() > 2 )
                {
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_NO_NAME );
                    throw se;
                }

                pParam1 = &paramList[0];
                pParam2 = &paramList[1];

                // Swap the parameter pointers if necessary, so that the node
                // name parameter is pointed to by pParam1.
                if (    ( pParam1->GetType() == paramNetworkName )
                     || ( pParam2->GetType() == paramNodeName ) )
                {
                    const CCmdLineParameter * pParamTemp = pParam1;
                    pParam1 = pParam2;
                    pParam2 = pParamTemp;
                }

                // Get the node name.
                if ( pParam1->GetType() == paramUnknown )
                {
                    // No parameters are accepted if /node: is not specified.
                    if ( pParam1->GetValues().size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAM_NO_VALUES, pParam1->GetName() );
                        throw se;
                    }

                    m_strNodeName = pParam1->GetName();
                }
                else
                {
                    if ( pParam1->GetType() == paramNodeName )
                    {
                        const vector<CString> & values = pParam1->GetValues();

                        if ( values.size() != 1 )
                        {
                            se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, pParam1->GetName() );
                            throw se;
                        }

                        m_strNodeName = values[0];
                    }
                    else
                    {
                            se.LoadMessage( MSG_INVALID_PARAMETER, pParam1->GetName() );
                            throw se;

                        } // else: the type of this parameter is not paramNodeName

                    } // else: the type of this parameter is known

                    // Get the network name.
                    if ( pParam2->GetType() == paramUnknown )
                    {
                        // No parameters are accepted if /network: is not specified.
                        if ( pParam2->GetValues().size() != 0 )
                        {
                            se.LoadMessage( MSG_PARAM_NO_VALUES, pParam2->GetName() );
                            throw se;
                        }

                        m_strNetworkName = pParam2->GetName();
                    }
                    else
                    {
                        if ( pParam2->GetType() == paramNetworkName )
                        {
                            const vector<CString> & values = pParam2->GetValues();

                            if ( values.size() != 1 )
                            {
                                se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, pParam2->GetName() );
                                throw se;
                            }

                            m_strNetworkName = values[0];
                        }
                        else
                        {
                            se.LoadMessage( MSG_INVALID_PARAMETER, pParam2->GetName() );
                            throw se;

                        } // else: the type of this parameter is not paramNetworkName

                    } // else: the type of this parameter is known

                    // We have the node and the network names.
                    // Get the network interface name and store it in m_strModuleName.
                    SetNetInterfaceName();

                    // No more options are provided, just show status.
                    // For example: cluster myCluster node myNode
                    if ( ( curOption + 1 ) == lastOption )
                    {
                        sc = Status( NULL );
                    }

                    break;

                } // case optDefault

                default:
                {
                    sc = CGenericModuleCmd::Execute( *curOption );
                    break;
                }

            } // switch: based on the type of option

            PrintMessage( MSG_OPTION_FOOTER, curOption->GetName() );
            ++curOption;

        } // for each option in the list

Cleanup:

    return sc;

} //*** CNetInterfaceCmd::Execute


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::PrintHelp
//
//  Routine Description:
//      Prints help for Network Interfaces
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::PrintHelp()
{
    return PrintMessage( MSG_HELP_NETINTERFACE );
} //*** CNetInterfaceCmd::PrintHelp


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::SeeHelpStringID
//
//  Routine Description:
//      Provides the message ID of the string that shows what command line to
//      use to get help for this kind of command.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      The command-specific message ID.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::SeeHelpStringID() const
{
    return MSG_SEE_NETINT_HELP;
} //*** CNetInterfaceCmd::SeeHelpStringID


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::Status
//
//  Routine Description:
//      Prints out the status of the module.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_strModuleName             Name of module.  If non-NULL, Status() prints
//                                  out the status of the specified module.
//                                  Otherwise, prints status of all modules.
//      m_strNetworkName            Name of Network
//      m_strNodeName               Name of Node
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::Status( const CCmdLineOption * pOption )
    throw( CSyntaxException )
{
    DWORD       sc = ERROR_SUCCESS;
    size_t      idx = 0;
    DWORD       dwType = 0;
    LPWSTR      pwszName = NULL;
    LPWSTR      pwszTemp = NULL;
    HCLUSENUM   hEnum = NULL;
    CSyntaxException se( SeeHelpStringID() );

    // pOption will be NULL if this function has been called as the
    // default action.
    if ( pOption != NULL )
    {
        // This option takes no values.
        if ( pOption->GetValues().size() != 0 )
        {
            se.LoadMessage( MSG_OPTION_NO_VALUES, pOption->GetName() );
            throw se;
        }

        // This option takes no parameters.
        if ( pOption->GetParameters().size() != 0 )
        {
            se.LoadMessage( MSG_OPTION_NO_PARAMETERS, pOption->GetName() );
            throw se;
        }
    } // if:

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    if( m_strModuleName.IsEmpty() == FALSE )
    {
        if ( m_strNodeName.IsEmpty() != FALSE )
        {
            pwszTemp = GetNodeName( m_strModuleName );
            m_strNodeName = pwszTemp;
            delete [] pwszTemp;
            pwszTemp = NULL;
        }

        if ( m_strNetworkName.IsEmpty() != FALSE )
        {
            pwszTemp = GetNetworkName( m_strModuleName );
            m_strNetworkName = pwszTemp;
            delete [] pwszTemp;
            pwszTemp = NULL;
        }

        PrintMessage( MSG_NETINT_STATUS_LIST, m_strNodeName, m_strNetworkName );
        PrintMessage( MSG_NETINTERFACE_STATUS_HEADER );
        sc = PrintStatus( m_strModuleName );
        goto Cleanup;
    } // if:

    hEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_NETINTERFACE );

    if( hEnum == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    PrintMessage( MSG_NETINT_STATUS_LIST_ALL);
    PrintMessage( MSG_NETINTERFACE_STATUS_HEADER );

    sc = ERROR_SUCCESS;
    for( idx = 0; sc == ERROR_SUCCESS; idx++ )
    {
        sc = WrapClusterEnum( hEnum, (DWORD) idx, &dwType, &pwszName );
        if( sc == ERROR_SUCCESS )
        {
            PrintStatus( pwszName );
        }

        LocalFree( pwszName );
        pwszName = NULL;
    } // for:

    if( sc == ERROR_NO_MORE_ITEMS )
    {
        sc = ERROR_SUCCESS;
    }

Cleanup:

    delete [] pwszTemp;
    LocalFree( pwszName );

    if ( hEnum != NULL )
    {
        ClusterCloseEnum( hEnum );
    }

    return sc;

} //*** CNetInterfaceCmd::Status


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::PrintStatus
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      pwszNetInterfaceName         Name of the module
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      Same as PrintStatus(HNETINTERFACE,LPCWSTR,LPCWSTR)
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::PrintStatus( LPCWSTR pwszNetInterfaceName )
{
    DWORD           sc = ERROR_SUCCESS;
    LPWSTR          pwszNodeName = NULL;
    LPWSTR          pwszNetworkName = NULL;
    HNETINTERFACE   hNetInterface = NULL;

    // Open the Net Interface handle
    hNetInterface = OpenClusterNetInterface( m_hCluster, pwszNetInterfaceName );
    if( hNetInterface == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    pwszNodeName = GetNodeName( pwszNetInterfaceName );
    pwszNetworkName = GetNetworkName( pwszNetInterfaceName );

    if ( (pwszNodeName != NULL) && (pwszNetworkName != NULL) )
    {
        sc = PrintStatus( hNetInterface, pwszNodeName, pwszNetworkName );
    }
    else
    {
        sc = PrintStatus( hNetInterface, L"", L"" );
    }

    CloseClusterNetInterface( hNetInterface );

Cleanup:

    delete [] pwszNodeName;
    delete [] pwszNetworkName;

    return sc;
} //*** CNetInterfaceCmd::PrintStatus


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::PrintStatus
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      hNetInterface               Handle to network interface
//      pwszNodeName                Name of the node
//      pwszNetworkName             Name of network
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::PrintStatus( 
          HNETINTERFACE hNetInterface
        , LPCWSTR pwszNodeName
        , LPCWSTR pwszNetworkName )
{
    DWORD sc = ERROR_SUCCESS;

    CLUSTER_NETINTERFACE_STATE  nState;
    LPWSTR                      pwszStatus = 0;

    nState = GetClusterNetInterfaceState( hNetInterface );

    if( nState == ClusterNetInterfaceStateUnknown )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    switch( nState )
    {
        case ClusterNetInterfaceUnavailable:
            LoadMessage( MSG_STATUS_UNAVAILABLE, &pwszStatus );
            break;

        case ClusterNetInterfaceFailed:
            LoadMessage( MSG_STATUS_FAILED, &pwszStatus );
            break;

        case ClusterNetInterfaceUnreachable:
           LoadMessage( MSG_STATUS_UNREACHABLE, &pwszStatus );
           break;

        case ClusterNetInterfaceUp:
            LoadMessage( MSG_STATUS_UP, &pwszStatus );
            break;

        case ClusterNetInterfaceStateUnknown:
        default:
            LoadMessage( MSG_STATUS_UNKNOWN, &pwszStatus  );
            break;

    } // switch:

    sc = PrintMessage( MSG_NETINTERFACE_STATUS, pwszNodeName, pwszNetworkName, pwszStatus );

Cleanup:

    // Since Load/FormatMessage uses LocalAlloc...
    LocalFree( pwszStatus );

    return sc;

} //*** CNetInterfaceCmd::PrintStatus


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::DoProperties
//
//  Routine Description:
//      Dispatches the property command to either Get or Set properties
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::DoProperties( 
          const CCmdLineOption & thisOption
        , PropertyType ePropType )
            throw( CSyntaxException )
{
    DWORD sc = ERROR_SUCCESS;

    if (    ( m_strNodeName.IsEmpty() != FALSE )
         && ( m_strNetworkName.IsEmpty() != FALSE ) )
    {
        sc = AllProperties( thisOption, ePropType );
        goto Cleanup;
    }

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = OpenModule();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    const vector<CCmdLineParameter> & paramList = thisOption.GetParameters();

    // If there are no property-value pairs on the command line,
    // then we print the properties otherwise we set them.
    if( paramList.size() == 0 )
    {
        ASSERT( m_strNodeName.IsEmpty() == FALSE  );
        ASSERT( m_strNetworkName.IsEmpty() == FALSE );
        PrintMessage( MSG_PROPERTY_NETINT_LISTING, m_strNodeName, m_strNetworkName );
        PrintMessage( MSG_PROPERTY_HEADER_NETINT );
        sc = GetProperties( thisOption, ePropType );
        goto Cleanup;
    }
    else
    {
        sc = SetProperties( thisOption, ePropType );
        goto Cleanup;
    }

Cleanup:

    return sc;

} //*** CNetInterfaceCmd::DoProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::GetProperties
//
//  Routine Description:
//      Prints out properties for the specified module
//
//  Arguments:
//      IN  const vector<CCmdLineParameter> & paramList
//          Contains the list of property-value pairs to be set
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//      IN  LPCWSTR pwszNetIntName
//          Name of the module
//
//  Member variables used / set:
//      m_hModule                   Module handle
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::GetProperties( 
          const CCmdLineOption & thisOption
        , PropertyType ePropType
        , LPWSTR pwszNetIntName )
{
    LPWSTR  pwszNodeName = NULL;
    LPWSTR  pwszNetworkName = NULL;
    size_t  cchNodeName = 0;
    size_t  cchNetName  = 0;
    DWORD   sc = ERROR_SUCCESS;
    DWORD   dwControlCode;

    HNETINTERFACE   hNetInt;
    CClusPropList   cpl;
    HRESULT         hr = S_OK;

    // If no pwszNetIntName specified, use current network interface,
    // otherwise open the specified netint
    if ( pwszNetIntName == NULL )
    {
        hNetInt = (HNETINTERFACE) m_hModule;

        // These must be localalloced (they're localfreed later)
        cchNodeName = m_strNodeName.GetLength() + 1;
        pwszNodeName = new WCHAR[ cchNodeName ];
        if ( pwszNodeName == NULL ) 
        {
            sc = GetLastError();
            goto Cleanup;
        } // if:

        cchNetName = m_strNetworkName.GetLength() + 1;
        pwszNetworkName = new WCHAR[ cchNetName ];
        if ( pwszNetworkName == NULL )
        {
            sc = GetLastError();
            goto Cleanup;
        } // if:

        hr = THR( StringCchCopyW( pwszNodeName, cchNodeName, m_strNodeName ) );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        } // if:

        hr = THR( StringCchCopyW( pwszNetworkName, cchNetName, m_strNetworkName ) );
        if ( FAILED( hr ) )
        {
            sc = HRESULT_CODE( hr );
            goto Cleanup;
        } // if:
    } // if:
    else
    {
        hNetInt = OpenClusterNetInterface( m_hCluster, pwszNetIntName);
        if ( hNetInt == NULL )
        {
            sc = GetLastError();
            goto Cleanup;
        } // if:

        pwszNodeName = GetNodeName(pwszNetIntName);
        pwszNetworkName = GetNetworkName(pwszNetIntName);
        if ( (pwszNodeName == NULL) || (pwszNetworkName == NULL) )
        {
            sc = ERROR_INVALID_HANDLE;
            goto Cleanup;
        } // if:
    } // else:


    // Use the proplist helper class.
    sc = cpl.ScAllocPropList( 8192 );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    // Get R/O properties
    dwControlCode = ePropType == PRIVATE ? 
                            CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES
                          : CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES;

    sc = cpl.ScGetNetInterfaceProperties( hNetInt, dwControlCode );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    sc = PrintProperties( cpl, thisOption.GetValues(), READONLY,
                               pwszNodeName, pwszNetworkName );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    // Get R/W properties
    dwControlCode = ePropType == PRIVATE ? 
                            CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES
                          : CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES;

    sc = cpl.ScGetNetInterfaceProperties( hNetInt, dwControlCode );

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if:

    sc = PrintProperties( cpl, thisOption.GetValues(), READWRITE, pwszNodeName, pwszNetworkName );

Cleanup:

    delete [] pwszNodeName;
    delete [] pwszNetworkName;

    return sc;

} //*** CNetInterfaceCmd::GetProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::AllProperties
//
//  Routine Description:
//      Prints out properties for all modules
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//      IN  PropertyType ePropertyType
//          The type of property, PRIVATE or COMMON
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_strModuleName             Name of module.  If non-NULL, prints
//                                  out properties for the specified module.
//                                  Otherwise, prints props for all modules.
//
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::AllProperties( 
          const CCmdLineOption & thisOption
        , PropertyType ePropType )
            throw( CSyntaxException )
{
    DWORD       sc;
    DWORD       dwIndex;
    DWORD       dwType;
    LPWSTR      pwszName = NULL;
    HCLUSENUM   hNetIntEnum = NULL;
    CSyntaxException se( SeeHelpStringID() );

    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // Enumerate the resources
    hNetIntEnum = ClusterOpenEnum( m_hCluster, CLUSTER_ENUM_NETINTERFACE );
    if ( hNetIntEnum == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    // Print the header
    PrintMessage( ePropType == PRIVATE ? 
                            MSG_PRIVATE_LISTING_NETINT_ALL 
                          : MSG_PROPERTY_LISTING_NETINT_ALL 
                );

    PrintMessage( MSG_PROPERTY_HEADER_NETINT );

    // Print out status for all resources
    sc = ERROR_SUCCESS;
    for ( dwIndex = 0; sc != ERROR_NO_MORE_ITEMS; dwIndex++ )
    {
        sc = WrapClusterEnum( hNetIntEnum, dwIndex, &dwType, &pwszName );
        if( sc == ERROR_SUCCESS )
        {
            sc = GetProperties( thisOption, ePropType, pwszName );
            if ( sc != ERROR_SUCCESS )
            {
                PrintSystemError( sc );
            }
        }

        if( pwszName != NULL )
        {
            LocalFree( pwszName );
        }
    }

    sc = ERROR_SUCCESS;

Cleanup:

    if ( hNetIntEnum != NULL )
    {
        ClusterCloseEnum( hNetIntEnum );
    }

    return sc;

} //*** CNetInterfaceCmd::AllProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::GetNodeName
//
//  Routine Description:
//      Returns the name of the node for the specified network interface.
//      *Caller must LocalFree memory*
//
//  Arguments:
//      pwszInterfaceName           Name of the network interface
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//
//  Return Value:
//      Name of the node            on success
//      NULL                        on failure (does not currently SetLastError())
//
//--
/////////////////////////////////////////////////////////////////////////////
LPWSTR CNetInterfaceCmd::GetNodeName (LPCWSTR pwszInterfaceName)
{
    DWORD           sc;
    DWORD           cbLength = 0;
    LPWSTR          pwszNodeName = NULL;
    HNETINTERFACE   hNetInterface = NULL;

    // Open the cluster and netinterface if it hasn't been done
    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Open an hNetInterface for the specified pwszInterfaceName (don't call
    // OpenModule because that opens m_hModule)
    hNetInterface = OpenClusterNetInterface( m_hCluster, pwszInterfaceName );
    if( hNetInterface == 0 )
    {
        goto Cleanup;
    }

    // Find out how much memory to allocate
    sc = ClusterNetInterfaceControl(
                                          hNetInterface
                                        , NULL // hNode
                                        , CLUSCTL_NETINTERFACE_GET_NODE
                                        , 0
                                        , 0
                                        , NULL
                                        , cbLength
                                        , &cbLength 
                                  );

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    pwszNodeName = new WCHAR[ ++cbLength ];
    if ( pwszNodeName == NULL ) 
    {
        goto Cleanup;
    }

    // Get the node name and store it in a temporary
    sc = ClusterNetInterfaceControl(
                                          hNetInterface
                                        , NULL // hNode
                                        , CLUSCTL_NETINTERFACE_GET_NODE
                                        , 0
                                        , 0
                                        , (LPVOID) pwszNodeName
                                        , cbLength
                                        , &cbLength 
                                   );

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        delete [] pwszNodeName;
        pwszNodeName = NULL;
    }

    if ( hNetInterface != NULL )
    {
        CloseClusterNetInterface( hNetInterface );
    }

    return pwszNodeName;

} //*** CNetInterfaceCmd::GetNodeName


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::GetNetworkName
//
//  Routine Description:
//      Returns the name of the network for the specified network interface.
//      *Caller must LocalFree memory*
//
//  Arguments:
//      pwszInterfaceName           Name of the network interface
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//
//  Return Value:
//      Name of the node            on success
//      NULL                        on failure (does not currently SetLastError())
//
//--
/////////////////////////////////////////////////////////////////////////////
LPWSTR CNetInterfaceCmd::GetNetworkName (LPCWSTR pwszInterfaceName)
{
    DWORD           sc;
    DWORD           cbLength = 0;
    LPWSTR          pwszNetworkName = NULL;
    HNETINTERFACE   hNetInterface = NULL;

    // Open the cluster and netinterface if it hasn't been done
    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Open an hNetInterface for the specified pwszInterfaceName (don't call
    // OpenModule because that opens m_hModule)
    hNetInterface = OpenClusterNetInterface( m_hCluster, pwszInterfaceName );
    if( hNetInterface == NULL )
    {
        goto Cleanup;
    }

    // Find out how much memory to allocate
    sc = ClusterNetInterfaceControl(
                                          hNetInterface
                                        , NULL // hNode
                                        , CLUSCTL_NETINTERFACE_GET_NETWORK
                                        , 0
                                        , 0
                                        , NULL
                                        , cbLength
                                        , &cbLength 
                                   );

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    pwszNetworkName = new WCHAR[ ++cbLength ];
    if ( pwszNetworkName == NULL )
    {
        goto Cleanup;
    }

    // Get the node name and store it in a temporary
    sc = ClusterNetInterfaceControl(
                                          hNetInterface
                                        , NULL // hNode
                                        , CLUSCTL_NETINTERFACE_GET_NETWORK
                                        , 0
                                        , 0
                                        , (LPVOID) pwszNetworkName
                                        , cbLength
                                        , &cbLength 
                                   );

Cleanup:

    if ( sc != ERROR_SUCCESS )
    {
        delete [] pwszNetworkName;
        pwszNetworkName = NULL;
    }

    if ( hNetInterface != NULL )
    {
        CloseClusterNetInterface( hNetInterface );
    }

    return pwszNetworkName;

} //*** CNetInterfaceCmd::GetNetworkName


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetInterfaceCmd::SetNetInterfaceName
//
//  Routine Description:
//      Sets the network interface name by looking up the node
//      name and network name.  If either one is unknown, returns
//      ERROR_SUCCESS without doing anything.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      m_strNodeName               Node name
//      m_strNetworkName            Network name
//      m_strModuleName             SET
//
//  Return Value:
//      ERROR_SUCCESS               on success or when nothing done
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterfaceCmd::SetNetInterfaceName()
{
    DWORD   sc;
    DWORD   cbInterfaceName;
    LPWSTR  pwszInterfaceName = NULL;

    // Don't do anything if either netname or nodename don't exist
    if (    ( m_strNetworkName.IsEmpty() != FALSE )
         || ( m_strNodeName.IsEmpty() != FALSE ) )
    {
        sc = ERROR_SUCCESS;
        goto Cleanup;
    }

    // Open the cluster if necessary
    sc = OpenCluster();
    if( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // First get the size
    cbInterfaceName = 0;
    sc = GetClusterNetInterface(
                                    m_hCluster,
                                    m_strNodeName,
                                    m_strNetworkName,
                                    NULL,
                                    &cbInterfaceName
                               );

    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // Allocate the proper amount of memory
    pwszInterfaceName = new WCHAR[ ++cbInterfaceName ];
    if ( pwszInterfaceName == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    }

    // Get the InterfaceName
    sc = GetClusterNetInterface(
                                     m_hCluster,
                                     m_strNodeName,
                                     m_strNetworkName,
                                     pwszInterfaceName,
                                     &cbInterfaceName
                               );


    if ( sc == ERROR_SUCCESS )
    {
        m_strModuleName = pwszInterfaceName;
        goto Cleanup;
    }

Cleanup:

    delete [] pwszInterfaceName;

    return sc;
} //*** CNetInterfaceCmd::SetNetInterfaceName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\neticmd.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//
//      neticmd.h
//
//  Abstract:
//
//      Network Interface Commands
//      Interfaces for functions which may be performed on a network interface
//      object.
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002  Updated for the security push.
//
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include "modcmd.h"

class CCommandLine;

class CNetInterfaceCmd : public CGenericModuleCmd
{
public:
	CNetInterfaceCmd( const CString & strClusterName, CCommandLine & cmdLine );
	~CNetInterfaceCmd();

	// Parse and execute the command line
	DWORD Execute();

protected:
	CString m_strNodeName;
	CString m_strNetworkName;

	virtual DWORD SeeHelpStringID() const;
	
	// Specific Commands
	DWORD PrintHelp();

	DWORD Status( const CCmdLineOption * pOption )
		throw( CSyntaxException );

	DWORD DoProperties( const CCmdLineOption & thisOption,
						PropertyType ePropertyType )
		throw( CSyntaxException );

	DWORD PrintStatus ( LPCWSTR lpszNetInterfaceName );
	DWORD PrintStatus( HNETINTERFACE hNetInterface, LPCWSTR lpszNodeName, LPCWSTR lpszNetworkName);

	DWORD GetProperties( const CCmdLineOption & thisOption,
						 PropertyType ePropType, LPWSTR lpszNetIntName = NULL );

	DWORD AllProperties( const CCmdLineOption & thisOption,
						 PropertyType ePropType ) 
		throw( CSyntaxException );

	void   InitializeModuleControls();
	DWORD  SetNetInterfaceName();

	LPWSTR GetNodeName(LPCWSTR lpszNetInterfaceName);
	LPWSTR GetNetworkName(LPCWSTR lpszNetInterfaceName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\nodecmd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      NodeCmd.h
//
//  Description:
//      Node commands.
//      Implements commands which may be performed on network nodes.
//
//  Maintained By:
//      David Potter (davidp)               20-NOV-2000
//      Michael Burton (t-mburt)            04-Aug-1997
//      Charles Stacy Harris III (stacyh)   20-March-1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#include <stdio.h>
#include <clusudef.h>
#include <clusrtl.h>

#include "cluswrap.h"
#include "nodecmd.h"

#include "token.h"
#include "cmdline.h"
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::CNodeCmd
//
//  Routine Description:
//      Constructor
//      Initializes all the DWORD params used by CGenericModuleCmd and
//      CHasInterfaceModuleCmd to provide generic functionality.
//
//  Arguments:
//      IN  LPCWSTR lpszClusterName
//          Cluster name. If NULL, opens default cluster.
//
//      IN  CCommandLine & cmdLine
//          CommandLine Object passed from DispatchCommand
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodeCmd::CNodeCmd( const CString & strClusterName, CCommandLine & cmdLine ) :
    CGenericModuleCmd( cmdLine ), CHasInterfaceModuleCmd( cmdLine )
{
    m_strModuleName.Empty();
    m_strClusterName = strClusterName;

    m_hCluster = 0;
    m_hModule = 0;

    // Generic Parameters
    m_dwMsgStatusList          = MSG_NODE_STATUS_LIST;
    m_dwMsgStatusListAll       = MSG_NODE_STATUS_LIST_ALL;
    m_dwMsgStatusHeader        = MSG_NODE_STATUS_HEADER;
    m_dwMsgPrivateListAll      = MSG_PRIVATE_LISTING_NODE_ALL;
    m_dwMsgPropertyListAll     = MSG_PROPERTY_LISTING_NODE_ALL;
    m_dwMsgPropertyHeaderAll   = MSG_PROPERTY_HEADER_NODE_ALL;
    m_dwCtlGetPrivProperties   = CLUSCTL_NODE_GET_PRIVATE_PROPERTIES;
    m_dwCtlGetCommProperties   = CLUSCTL_NODE_GET_COMMON_PROPERTIES;
    m_dwCtlGetROPrivProperties = CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES;
    m_dwCtlGetROCommProperties = CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES;
    m_dwCtlSetPrivProperties   = CLUSCTL_NODE_SET_PRIVATE_PROPERTIES;
    m_dwCtlSetCommProperties   = CLUSCTL_NODE_SET_COMMON_PROPERTIES;
    m_dwClusterEnumModule      = CLUSTER_ENUM_NODE;
    m_pfnOpenClusterModule      = (HCLUSMODULE(*)(HCLUSTER,LPCWSTR)) OpenClusterNode;
    m_pfnCloseClusterModule     = (BOOL(*)(HCLUSMODULE))  CloseClusterNode;
    m_pfnClusterModuleControl   = (DWORD(*)(HCLUSMODULE,HNODE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD)) ClusterNodeControl;

    // ListInterface Parameters
    m_dwMsgStatusListInterface   = MSG_NODE_LIST_INTERFACE;
    m_dwClusterEnumModuleNetInt  = CLUSTER_ENUM_NODE;
    m_pfnClusterOpenEnum         = (HCLUSENUM(*)(HCLUSMODULE,DWORD)) ClusterNodeOpenEnum;
    m_pfnClusterCloseEnum        = (DWORD(*)(HCLUSENUM)) ClusterNodeCloseEnum;
    m_pfnWrapClusterEnum         = (DWORD(*)(HCLUSENUM,DWORD,LPDWORD,LPWSTR*)) WrapClusterNodeEnum;

} //*** CNodeCmd::CNodeCmd()



/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::Execute
//
//  Routine Description:
//      Gets the next command line parameter and calls the appropriate
//      handler.  If the command is not recognized, calls Execute of
//      parent classes (first CRenamableModuleCmd, then CHasInterfaceModuleCmd)
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      All.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::Execute( void )
{
    DWORD   sc          = ERROR_SUCCESS;

    m_theCommandLine.ParseStageTwo();

    const vector< CCmdLineOption > & rvcoOptionList = m_theCommandLine.GetOptions();

    vector< CCmdLineOption >::const_iterator itCurOption  = rvcoOptionList.begin();
    vector< CCmdLineOption >::const_iterator itLastOption = rvcoOptionList.end();

    CSyntaxException se( SeeHelpStringID() ); 

    if ( rvcoOptionList.empty() )
    {
        sc = Status( NULL );
        goto Cleanup;
    }

    // Process one option after another.
    while ( ( itCurOption != itLastOption ) && ( sc == ERROR_SUCCESS ) )
    {
        // Look up the command
        switch ( itCurOption->GetType() )
        {
            case optHelp:
            {
                // If help is one of the options, process no more options.
                sc = PrintHelp();
                goto Cleanup;
            }

            case optPause:
            {
                sc = PauseNode( *itCurOption );
                break;
            }

            case optResume:
            {
                sc = ResumeNode( *itCurOption );
                break;
            }

            case optEvict:
            {
                sc = EvictNode( *itCurOption );
                break;
            }

            case optForceCleanup:
            {
                sc = ForceCleanup( *itCurOption );
                break;
            }


            case optStartService:
            {
                sc = StartService( *itCurOption );
                break;
            }

            case optStopService:
            {
                sc = StopService( *itCurOption );
                break;
            }

            case optDefault:
            {
                const vector< CCmdLineParameter > & rvclpParamList = itCurOption->GetParameters();

                //  Check number of parameters.
                if ( rvclpParamList.size() == 0 )
                {
                    se.LoadMessage( IDS_MISSING_PARAMETERS );
                    throw se;
                }
                else if ( rvclpParamList.size() > 1 )
                {
                    se.LoadMessage( MSG_EXTRA_PARAMETERS_ERROR_NO_NAME );
                    throw se;
                }
                else // just one parameter present
                {
                    const CCmdLineParameter & rclpParam = rvclpParamList[ 0 ];

                    //  Check parameter type.
                    if ( rclpParam.GetType() != paramUnknown )
                    {
                        se.LoadMessage( MSG_INVALID_PARAMETER, rclpParam.GetName() );
                        throw se;
                    }

                    // This parameter takes no values.
                    if ( rclpParam.GetValues().size() != 0 )
                    {
                        se.LoadMessage( MSG_PARAM_NO_VALUES, rclpParam.GetName() );
                        throw se;
                    }

                    m_strModuleName = rclpParam.GetName();

                    // No more options are provided, just show status.
                    // For example: cluster myCluster node myNode
                    if ( ( itCurOption + 1 ) == itLastOption )
                    {
                        sc = Status( NULL );
                    }

                } // else: this option has the right number of parameters

                break;

            } // case optDefault

            default:
            {
                sc = CHasInterfaceModuleCmd::Execute( *itCurOption );
            }

        } // switch: based on the type of option

        PrintMessage( MSG_OPTION_FOOTER, itCurOption->GetName() );
        ++itCurOption;
    } // for each option in the list

Cleanup:

    return sc;

} //*** CNodeCmd::Execute()




/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::PrintHelp
//
//  Routine Description:
//      Prints help for Nodes
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::PrintHelp( void )
{
    return PrintMessage( MSG_HELP_NODE );

} //*** CNodeCmd::PrintHelp()



/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::SeeHelpStringID
//
//  Routine Description:
//      Provides the message ID of the string that shows what command line to
//      use to get help for this kind of command.
//
//  Arguments:
//      None.
//
//  Member variables used / set:
//      None.
//
//  Return Value:
//      The command-specific message ID.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::SeeHelpStringID() const
{
    return MSG_SEE_NODE_HELP;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::PrintStatus
//
//  Routine Description:
//      Interprets the status of the module and prints out the status line
//      Required for any derived non-abstract class of CGenericModuleCmd
//
//  Arguments:
//      lpszNodeName                Name of the module
//
//  Member variables used / set:
//      m_hCluster                  Cluster Handle
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::PrintStatus( LPCWSTR lpszNodeName )
{
    DWORD   sc          = ERROR_SUCCESS;
    HNODE   hNode       = NULL;
    LPWSTR  lpszNodeId  = NULL;
    LPWSTR  lpszStatus  = NULL;

    hNode = OpenClusterNode(m_hCluster, lpszNodeName);
    if ( hNode == NULL )
    {
        goto Win32Error;
    }

    CLUSTER_NODE_STATE nState = GetClusterNodeState( hNode );

    if ( nState == ClusterNodeStateUnknown )
    {
        goto Win32Error;
    }

    sc = WrapGetClusterNodeId( hNode, &lpszNodeId );
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    switch ( nState )
    {
        case ClusterNodeUp:
            LoadMessage( MSG_STATUS_UP, &lpszStatus );
            break;

        case ClusterNodeDown:
            LoadMessage( MSG_STATUS_DOWN, &lpszStatus );
            break;

        case ClusterNodePaused:
            LoadMessage( MSG_STATUS_PAUSED, &lpszStatus  );
            break;

        case ClusterNodeJoining:
            LoadMessage( MSG_STATUS_JOINING, &lpszStatus  );
            break;

        default:
            LoadMessage( MSG_STATUS_UNKNOWN, &lpszStatus  );
    } // switch: node state


    sc = PrintMessage( MSG_NODE_STATUS, lpszNodeName, lpszNodeId, lpszStatus );

    goto Cleanup;

Win32Error:

    sc = GetLastError();

Cleanup:

    // Since Load/FormatMessage uses LocalAlloc...
    LocalFree( lpszStatus );
    LocalFree( lpszNodeId );

    if ( hNode != NULL )
    {
        CloseClusterNode( hNode );
    }

    return sc;

} //*** CNodeCmd::PrintStatus()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::PauseNode
//
//  Routine Description:
//      Pauses the cluster node
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Node Name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::PauseNode( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;
    CSyntaxException se( SeeHelpStringID() );

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // If a node was not specified, use the name of the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer
    }  // if: no node name was specified

    sc = OpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = OpenModule();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    PrintMessage( MSG_NODECMD_PAUSE, (LPCWSTR) m_strModuleName );

    sc = PauseClusterNode( (HNODE) m_hModule );

    PrintMessage( MSG_NODE_STATUS_HEADER );
    PrintStatus( m_strModuleName );

Cleanup:

    return sc;

} //*** CNodeCmd::PauseNode()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::ResumeNode
//
//  Routine Description:
//      Resume the paused cluster node
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Node Name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::ResumeNode( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD   sc = ERROR_SUCCESS;
    CSyntaxException se( SeeHelpStringID() );

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // This option takes no parameters.
    if ( thisOption.GetParameters().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_PARAMETERS, thisOption.GetName() );
        throw se;
    }

    // If a node was not specified, use the name of the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer
    }  // if: no node name was specified

    sc = OpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = OpenModule();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    PrintMessage( MSG_NODECMD_RESUME, (LPCWSTR) m_strModuleName );

    sc = ResumeClusterNode( (HNODE) m_hModule );

    PrintMessage( MSG_NODE_STATUS_HEADER );
    PrintStatus( m_strModuleName );

Cleanup:

    return sc;

} //*** CNodeCmd::ResumeNode()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::EvictNode
//
//  Routine Description:
//      Evict the cluster node
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Member variables used / set:
//      m_hCluster                  SET (by OpenCluster)
//      m_hModule                   SET (by OpenModule)
//      m_strModuleName             Node Name
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNodeCmd::EvictNode( const CCmdLineOption & thisOption )
    throw( CSyntaxException )
{
    DWORD                                       sc           = ERROR_SUCCESS;
    HRESULT                                     hrCleanupStatus;
    DWORD                                       dwWait       = INFINITE;
    const vector< CCmdLineParameter > &         vecParamList = thisOption.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam   = vecParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLast       = vecParamList.end();
    bool                                        fWaitFound   = false;
    CSyntaxException se( SeeHelpStringID() );

    while ( itCurParam != itLast )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch ( itCurParam->GetType() )
        {
            case paramWait:
            {
                if ( fWaitFound != false )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                size_t nValueCount = vstrValueList.size();

                // This parameter must have zero or one value.
                if ( nValueCount > 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount != 0 )
                    {
                        dwWait = _wtoi( vstrValueList[ 0 ] ) * 1000;
                    }
                    else
                    {
                        dwWait = INFINITE;
                    }
                }

                fWaitFound = true;
                break;
            } // case: paramWait

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++itCurParam;

    } // while: more parameters

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // If a node was not specified, use the name of the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer
    }  // if: no node name was specified

    sc = OpenCluster();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    sc = OpenModule();
    if ( sc != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    PrintMessage( MSG_NODECMD_EVICT, (LPCWSTR) m_strModuleName );

    sc = EvictClusterNodeEx( (HNODE) m_hModule, dwWait, &hrCleanupStatus );
    if ( sc == ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP )
    {
        sc = HRESULT_CODE( hrCleanupStatus );
    } // if: evict was successful

Cleanup:

    return sc;

} //*** CNodeCmd::EvictNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::ForceCleanup
//
//  Routine Description:
//      Forcibly "unconfigure" a node that has been evicted.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CNodeCmd::ForceCleanup(
    const CCmdLineOption & thisOption
    ) throw( CSyntaxException )
{
    DWORD                                       sc = ERROR_SUCCESS;
    DWORD                                       dwWait = INFINITE;
    const vector< CCmdLineParameter > &         vecParamList = thisOption.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam   = vecParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLast       = vecParamList.end();
    bool                                        fWaitFound   = false;
    CSyntaxException se( SeeHelpStringID() );

    while ( itCurParam != itLast )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch ( itCurParam->GetType() )
        {
            case paramWait:
            {
                if ( fWaitFound != false )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                size_t nValueCount = vstrValueList.size();

                // This parameter must have zero or one value.
                if ( nValueCount > 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount != 0 )
                    {
                        dwWait = _wtoi( vstrValueList[ 0 ] ) * 1000;
                    }
                    else
                    {
                        dwWait = INFINITE;
                    }
                }

                fWaitFound = true;
                break;
            } // case: paramWait

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++itCurParam;

    } // while: more parameters

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    // If a node was not specified, use the name of the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer
    }  // if: no node name was specified

    // Cleanup the node.
    PrintMessage( MSG_NODECMD_CLEANUP, (LPCWSTR) m_strModuleName );
    sc = ClRtlAsyncCleanupNode( m_strModuleName, 0, dwWait );

    if ( sc == RPC_S_CALLPENDING )
    {
        if ( dwWait > 0 )
        {
            PrintMessage( MSG_NODECMD_CLEANUP_TIMEDOUT );
        } // if: waiting was required
        else
        {
            // No need to wait for the call to complete
            PrintMessage( MSG_NODECMD_CLEANUP_INITIATED );
        } // else: no wait was required

        sc = ERROR_SUCCESS;
        goto Cleanup;
    } // if: we timed out before the call completed

    // The status code could be an HRESULT, so see if it is an error.
    if ( FAILED( sc ) )
    {
        goto Cleanup;
    } // if: something went wrong cleaning up the node

    PrintMessage( MSG_NODECMD_CLEANUP_COMPLETED );

Cleanup:

    return sc;

} //*** CNodeCmd::ForceCleanup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::StartService
//
//  Routine Description:
//      Start the cluster service on a node.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CNodeCmd::StartService(
    const CCmdLineOption & thisOption
    ) throw( CSyntaxException )
{
    DWORD       sc          = ERROR_SUCCESS;
    SC_HANDLE   schSCM      = NULL;
    SC_HANDLE   schClusSvc  = NULL;
    bool        fWaitFound  = false;
    UINT        uiWait      = INFINITE;
    CString     strNodeName;
    bool        fStarted    = false;
    DWORD       cQueryCount = 0;
    UINT        uiQueryInterval = 1000; // milliseconds, arbitrarily chosen

    const vector< CCmdLineParameter > &         vecParamList = thisOption.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam   = vecParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLastParam  = vecParamList.end();
    CSyntaxException se( SeeHelpStringID() );

    //////////////////////////////////////////////////////////////////////////
    //
    //  Parse the parameters on the command line.
    //
    //////////////////////////////////////////////////////////////////////////

    while ( itCurParam != itLastParam )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch ( itCurParam->GetType() )
        {
            case paramWait:
            {
                if ( fWaitFound != false )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                size_t nValueCount = vstrValueList.size();

                // This parameter must have zero or one value.
                if ( nValueCount > 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount != 0 )
                    {
                        uiWait = _wtoi( vstrValueList[ 0 ] ) * 1000;
                    }
                    else
                    {
                        uiWait = INFINITE;
                    }
                }

                fWaitFound = true;
                break;
            } // case: paramWait

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++itCurParam;

    } // while: more parameters

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    //  Start the service.
    //
    //////////////////////////////////////////////////////////////////////////

    // If a node was not specified, use the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        // Get the local computer name so that we can print out the message.
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer

        PrintMessage( MSG_NODECMD_STARTING_SERVICE, (LPCWSTR) m_strModuleName );

        // No need to do anything else with m_strModuleName.
        // The call to OpenSCManager below will use an empty string in this
        // case, which instructs it to connect to the local machine.

    }  // if: no node name was specified
    else
    {
        PrintMessage( MSG_NODECMD_STARTING_SERVICE, (LPCWSTR) m_strModuleName );

        // SCM needs the node name to be prefixed with two backslashes.
        strNodeName = L"\\\\" + m_strModuleName;
    } // else: a node name is specified

    // Open a handle to the service control manager.
    // This string will be empty if no node name was specified.
    schSCM = OpenSCManager(
                  strNodeName
                , SERVICES_ACTIVE_DATABASE
                , SC_MANAGER_ALL_ACCESS
                );
    if ( schSCM == NULL )
    {
        goto Win32Error;
    } // if: we could not open a handle to the service control manager on the target node

    // Open a handle to the cluster service.
    schClusSvc = OpenService( schSCM, CLUSTER_SERVICE_NAME, SERVICE_START | SERVICE_QUERY_STATUS );
    if ( schClusSvc == NULL )
    {
        goto Win32Error;
    } // if: we could not open a handle to the cluster service

    // Try and start the service.
    if ( ::StartService( schClusSvc, 0, NULL ) == 0 )
    {
        sc = GetLastError();
        if ( sc == ERROR_SERVICE_ALREADY_RUNNING )
        {
            // The service is already running. Change the error code to success.
            sc = ERROR_SUCCESS;
            PrintMessage( MSG_NODECMD_SEVICE_ALREADY_RUNNING );
        } // if: the service is already running.

        // There is nothing else to do.
        goto Cleanup;
    } // if: an error occurred trying to start the service.

    //////////////////////////////////////////////////////////////////////////
    //
    //  Wait for the service to start.
    //
    //////////////////////////////////////////////////////////////////////////

    // If we are here, then the service may not have started yet.

    // Divide our wait interval into cQueryCount slots.
    cQueryCount = ( ( DWORD ) uiWait ) / uiQueryInterval;

    // Has the user requested that we wait for the service to start?
    if ( cQueryCount == 0 )
    {
        PrintMessage( MSG_NODECMD_SEVICE_START_ISSUED );
        goto Cleanup;
    } // if: no waiting is required.

    // Loop for querying the service status cQueryCount times.
    for ( ;; ) 
    {
        SERVICE_STATUS  ssStatus;

        ZeroMemory( &ssStatus, sizeof( ssStatus ) );

        // Query the service for its status.
         if ( QueryServiceStatus( schClusSvc, &ssStatus ) == 0 )
        {
            sc = GetLastError();
            break;
        } // if: we could not query the service for its status.

        // Check if the service has posted an error.
        if ( ssStatus.dwWin32ExitCode != ERROR_SUCCESS )
        {
            sc = ssStatus.dwWin32ExitCode;
            break;
        } // if: the service itself has posted an error.

        if ( ssStatus.dwCurrentState == SERVICE_RUNNING )
        {
            fStarted = true;
            break;
        } // if: the service is running.

        // Check if the timeout has expired
        if ( cQueryCount <= 0 )
        {
            sc = ERROR_IO_PENDING;
            break;
        } // if: number of queries has exceeded the maximum specified

        --cQueryCount;

        putwchar( L'.' );

        // Wait for the specified time.
        Sleep( uiQueryInterval );
    } // for: ever until service started or timed out

    //////////////////////////////////////////////////////////////////////////
    //
    //  Handle errors.
    //
    //////////////////////////////////////////////////////////////////////////

    if ( cQueryCount == 0 )
    {
        sc = ERROR_IO_PENDING;
    }

    if ( sc != ERROR_SUCCESS )
    {
        _putws( L"\r\n" );
        goto Cleanup;
    } // if: something went wrong.

    if ( ! fStarted )
    {
        PrintMessage( MSG_NODECMD_SEVICE_START_ISSUED );
    } // if: the maximum number of queries have been made and the service is not running.
    else
    {
        PrintMessage( MSG_NODECMD_SEVICE_STARTED );
    } // else: the service has started

    goto Cleanup;

Win32Error:

    sc = GetLastError();

Cleanup:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if: we had opened a handle to the SCM

    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if: we had opened a handle to the cluster service

    return sc;

} //*** CNodeCmd::StartService


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::StopService
//
//  Routine Description:
//      Stop the cluster service on a node.
//
//  Arguments:
//      IN  const CCmdLineOption & thisOption
//          Contains the type, values and arguments of this option.
//
//  Exceptions:
//      CSyntaxException
//          Thrown for incorrect command line syntax.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CNodeCmd::StopService(
    const CCmdLineOption & thisOption
    ) throw( CSyntaxException )
{
    DWORD           sc          = ERROR_SUCCESS;
    SC_HANDLE       schSCM      = NULL;
    SC_HANDLE       schClusSvc  = NULL;
    bool            fWaitFound  = false;
    UINT            uiWait      = INFINITE;
    CString         strNodeName;
    SERVICE_STATUS  ssStatus;
    bool            fStopped    = false;
    DWORD           cQueryCount = 0;
    UINT            uiQueryInterval = 1000; // milliseconds, arbitrarily chosen

    const vector< CCmdLineParameter > &         vecParamList    = thisOption.GetParameters();
    vector< CCmdLineParameter >::const_iterator itCurParam      = vecParamList.begin();
    vector< CCmdLineParameter >::const_iterator itLastParam     = vecParamList.end();
    CSyntaxException se( SeeHelpStringID() );

    //////////////////////////////////////////////////////////////////////////
    //
    //  Parse the parameters on the command line.
    //
    //////////////////////////////////////////////////////////////////////////

    while ( itCurParam != itLastParam )
    {
        const vector< CString > & vstrValueList = itCurParam->GetValues();

        switch ( itCurParam->GetType() )
        {
            case paramWait:
            {
                if ( fWaitFound != false )
                {
                    se.LoadMessage( MSG_PARAM_REPEATS, itCurParam->GetName() );
                    throw se;
                }

                size_t nValueCount = vstrValueList.size();

                // This parameter must have zero or one value.
                if ( nValueCount > 1 )
                {
                    se.LoadMessage( MSG_PARAM_ONLY_ONE_VALUE, itCurParam->GetName() );
                    throw se;
                }
                else
                {
                    if ( nValueCount != 0 )
                    {
                        uiWait = _wtoi( vstrValueList[ 0 ] ) * 1000;
                    }
                    else
                    {
                        uiWait = INFINITE;
                    }
                }

                fWaitFound = true;
                break;
            } // case: paramWait

            default:
            {
                se.LoadMessage( MSG_INVALID_PARAMETER, itCurParam->GetName() );
                throw se;
            }

        } // switch: based on the type of the parameter.

        ++itCurParam;

    } // while: more parameters

    // This option takes no values.
    if ( thisOption.GetValues().size() != 0 )
    {
        se.LoadMessage( MSG_OPTION_NO_VALUES, thisOption.GetName() );
        throw se;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    //  Stop the service.
    //
    //////////////////////////////////////////////////////////////////////////

    // If a node was not specified, use the local computer.
    if ( m_strModuleName.IsEmpty() )
    {
        // Get the local computer name so that we can print out the message.
        sc = DwGetLocalComputerName( m_strModuleName );
        if ( sc != ERROR_SUCCESS )
        {
            goto Cleanup;
        } // if: we could not get the name of the local computer

        PrintMessage( MSG_NODECMD_STOPPING_SERVICE, (LPCWSTR) m_strModuleName );

        // No need to do anything else with m_strModuleName.
        // The call to OpenSCManager below will use an empty string in this
        // case, which instructs it to connect to the local machine.

    } // if: no node name is specified
    else
    {
        PrintMessage( MSG_NODECMD_STOPPING_SERVICE, (LPCWSTR) m_strModuleName );

        // SCM needs the node name to be prefixed with two backslashes.
        strNodeName = L"\\\\" + m_strModuleName;
    } // else: a node name is specified

    // Open a handle to the service control mananger.
    schSCM = OpenSCManager(
                  strNodeName
                , SERVICES_ACTIVE_DATABASE
                , SC_MANAGER_ALL_ACCESS
                );
    if ( schSCM == NULL )
    {
        goto Win32Error;
    } // if: we could not open a handle to the service control manager on the target node

    // Open a handle to the cluster service.
    schClusSvc = OpenService(
          schSCM
        , CLUSTER_SERVICE_NAME
        , SERVICE_STOP | SERVICE_QUERY_STATUS
        );
    if ( schClusSvc == NULL )
    {
        goto Win32Error;
    } // if: the handle to the service could not be opened.

    // Query the service for its initial state.
    ZeroMemory( &ssStatus, sizeof( ssStatus ) );
    if ( QueryServiceStatus( schClusSvc, &ssStatus ) == 0 )
    {
        goto Win32Error;
    } // if: we could not query the service for its status.

    // If the service has stopped, we have nothing more to do.
    if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
    {
        // The service is already stopped. Change the error code to success.
        PrintMessage( MSG_NODECMD_SEVICE_ALREADY_STOPPED );
        sc = ERROR_SUCCESS;
        goto Cleanup;
    } // if: the service has stopped.

    // If the service is stopping on its own.
    // No need to send the stop control code.
    if ( ssStatus.dwCurrentState != SERVICE_STOP_PENDING )
    {
        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( ControlService( schClusSvc, SERVICE_CONTROL_STOP, &ssStatus ) == 0 )
        {
            sc = GetLastError();
            if ( sc == ERROR_SERVICE_NOT_ACTIVE )
            {
                // The service is not running. Change the error code to success.
                PrintMessage( MSG_NODECMD_SEVICE_ALREADY_STOPPED );
                sc = ERROR_SUCCESS;
            } // if: the service is not running.

            // There is nothing else to do.
            goto Cleanup;
        } // if: an error occurred trying to stop the service.
    } // if: the service has to be instructed to stop

    //////////////////////////////////////////////////////////////////////////
    //
    //  Wait for the service to stop.
    //
    //////////////////////////////////////////////////////////////////////////

    // Divide our wait interval into cQueryCount slots.
    cQueryCount = ( ( DWORD ) uiWait ) / uiQueryInterval;

    // Has the user requested that we wait for the service to stop?
    if ( cQueryCount == 0 )
    {
        PrintMessage( MSG_NODECMD_SEVICE_STOP_ISSUED );
        goto Cleanup;
    } // if: no waiting is required.

    // Query the service for its state now and wait till the timeout expires
    for ( ;; )
    {
        // Query the service for its status.
        ZeroMemory( &ssStatus, sizeof( ssStatus ) );
        if ( QueryServiceStatus( schClusSvc, &ssStatus ) == 0 )
        {
            sc = GetLastError();
            break;
        } // if: we could not query the service for its status.

        // If the service has stopped, we have nothing more to do.
        if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
        {
            // Nothing needs to be done here.
            fStopped = true;
            sc = ERROR_SUCCESS;
            break;
        } // if: the service has stopped.

        // Check if the timeout has expired
        if ( cQueryCount <= 0 )
        {
            sc = ERROR_IO_PENDING;
            break;
        } // if: number of queries has exceeded the maximum specified

        --cQueryCount;

        putwchar( L'.' );

        // Wait for the specified time.
        Sleep( uiQueryInterval );
    } // for: ever until service stopped or timed out

    //////////////////////////////////////////////////////////////////////////
    //
    //  Handle errors.
    //
    //////////////////////////////////////////////////////////////////////////

    if ( sc != ERROR_SUCCESS )
    {
        _putws( L"\r\n" );
        goto Cleanup;
    } // if: something went wrong.

    if ( ! fStopped )
    {
        PrintMessage( MSG_NODECMD_SEVICE_STOP_ISSUED );
    } // if: the maximum number of queries have been made and the service is still running.
    else
    {
        PrintMessage( MSG_NODECMD_SEVICE_STOPPED );
    } // else: the service has stopped

    goto Cleanup;

Win32Error:

    sc = GetLastError();

Cleanup:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if: we had opened a handle to the SCM

    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if: we had opened a handle to the cluster service

    return sc;

} //*** CNodeCmd::StopService


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodeCmd::DwGetLocalComputerName()
//
//  Routine Description:
//      Get the name of the local computer.
//
//  Arguments:
//      OUT CString & rstrComputerNameOut
//          Reference to the string that will contain the name of this
//          computer.
//
//  Exceptions:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS               on success
//      Win32 Error code            on failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CNodeCmd::DwGetLocalComputerName( CString & rstrComputerNameOut )
{
    DWORD       sc;
    DWORD       cchBufferSize = 256;        // arbitrary starting buffer size
    CString     strOutput;
    DWORD       cchRequiredSize = cchBufferSize;

    do
    {
        sc = ERROR_SUCCESS;

        if (    GetComputerNameEx(
                      ComputerNameDnsHostname
                    , strOutput.GetBuffer( cchBufferSize )
                    , &cchRequiredSize
                    )
             == FALSE
           )
        {
            sc = GetLastError();
            if ( sc == ERROR_MORE_DATA )
            {
                cchBufferSize = cchRequiredSize;
            } // if: the input buffer is not big enough

        } // if: GetComputerNameEx() failed

        strOutput.ReleaseBuffer();
    }
    while( sc == ERROR_MORE_DATA ); // loop while the buffer is not big enough

    if ( sc == ERROR_SUCCESS )
    {
        rstrComputerNameOut = strOutput;
    } // if: everything went well
    else
    {
        rstrComputerNameOut.Empty();
    } // else: something went wrong

    return sc;

} //*** CNodeCmd::DwGetLocalComputerName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\nolog.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      NoLog.h
//
//  Description:
//      Enable use of files from Mgmt project by stubbing out log functions.
//
//  Maintained By:
//      John Franco (JFranco) 13-SEP-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

inline void LogMsg( const char * text, ... )
{
    UNREFERENCED_PARAMETER( text );
    return;
}

//  Add more stubs as necessary.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\nodecmd.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1995 - 2002 Microsoft Corporation
//
//  Module Name:
//      nodecmd.h
//
//  Abstract:
//      Interface for functions which may be performed on a network node object.
//
//  Author:
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//
//  Revision History:
//      April 10, 2002              Updated for the security push.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "intrfc.h"

class CCommandLine;

class CNodeCmd : virtual public CHasInterfaceModuleCmd
{
public:
	CNodeCmd( const CString & strClusterName, CCommandLine & cmdLine );

	DWORD Execute();

protected:
	
	DWORD PrintStatus( LPCWSTR lpszNodeName );
	DWORD PrintHelp();
	virtual DWORD SeeHelpStringID() const;

	DWORD PauseNode( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD ResumeNode( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD EvictNode( const CCmdLineOption & thisOption ) throw( CSyntaxException );
	DWORD ForceCleanup( const CCmdLineOption & thisOption ) throw( CSyntaxException );
    DWORD StartService( const CCmdLineOption & thisOption ) throw( CSyntaxException );
    DWORD StopService( const CCmdLineOption & thisOption ) throw( CSyntaxException );

    DWORD DwGetLocalComputerName( CString & rstrComputerNameOut );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluster\passwordcmd.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 - 2002 Microsoft Corporation
//
//  Module Name:
//      PasswordCmd.cpp
//
//  Description:
//      Change cluster service account password.
//
//  Maintained By:
//      George Potts (GPotts)                 11-Apr-2002
//      Rui Hu (ruihu),                       01-Jun-2001.
//
//  Revision History:
//      April 10, 2002     Updated code for compliance with the security push.
//
//////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "PasswordCmd.h"

#include <cluswrap.h>
#include "Resource.h"
#include "cluscmd.h"

#include "cmdline.h"
#include "util.h"
#include "ClusCfg.h"

//////////////////////////////////////////////////////////////////////////////
//  Global Variables
//////////////////////////////////////////////////////////////////////////////

PCLUSTER_DATA                   g_rgcdClusters;
size_t                          g_cNumClusters = 0;
PCLUSTER_SET_PASSWORD_STATUS    g_pcspsStatusBuffer = NULL;
PCLUSTER_NODE_DATA              g_FirstNodeWithNonNullClusterServiceAccountName = NULL;
                                // The first node with non-null pszClusterServiceAccountName
size_t                          g_FirstNonNullNodeClusterIndex = (size_t) -1;
                                // The cluster index of the first node with non-null pszClusterServiceAccountName
PCLUSTER_NODE_DATA              g_FirstNodeWithNonNullSCMClusterServiceAccountName = NULL;
                                // The first node with non-null pszSCMClusterServiceAccountName

//////////////////////////////////////////////////////////////////////////////
//  Function declarations
//////////////////////////////////////////////////////////////////////////////

LPWSTR
PszNodeName(
      PCLUSTER_NODE_DATA    pcndNodeDataIn
    , DWORD                 nNodeIdIn
    );



//////////////////////////////////////////////////////////////////////////////
//++
//
//  GetNodeStateString
//
//  Description:
//       Retrieve the node state.
//
//  Arguments:
//       pcndNodeData: 
//
//       pwszNodeState
//
//  Return Values:
//      ERROR_SUCCESS
//      Other Win32 error codes.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
GetNodeStateString( PCLUSTER_NODE_DATA pcndNodeData, LPWSTR * ppwszNodeState )
{
    ASSERT( pcndNodeData != NULL );
    ASSERT( ppwszNodeState != NULL );

    switch ( pcndNodeData->cnsNodeState )
    {
        case ClusterNodeUp:
            LoadMessage( MSG_STATUS_UP, ppwszNodeState );
            break;
        case ClusterNodeDown:
            LoadMessage( MSG_STATUS_DOWN, ppwszNodeState );
            break;
        case ClusterNodePaused:
            LoadMessage( MSG_STATUS_PAUSED, ppwszNodeState  );
            break;
        case ClusterNodeJoining:
            LoadMessage( MSG_STATUS_JOINING, ppwszNodeState  );
            break;
        default:
            LoadMessage( MSG_STATUS_UNKNOWN, ppwszNodeState  ); 
            break;
    } // switch: node state

} //*** GetNodeStateString

//////////////////////////////////////////////////////////////////////////////
//++
//
//  GetClusterServiceAccountName
//
//  Description:
//       Get the account which cluster service is using on a particular node.
//
//  Arguments:
//       pcndNodeData: pcndNodeData->pszClusterServiceAccountName will store
//                     the cluster service account name.
//       hNode: node handle.
//       pszClusterName: cluster name.
//
//  Return Values:
//      ERROR_SUCCESS
//      Other Win32 error codes.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
GetClusterServiceAccountName(PCLUSTER_NODE_DATA pcndNodeData, 
                             HNODE              hNode,
                             LPCWSTR            pszClusterName
                             )
{

    DWORD               dwServiceAccountNameLen;
    DWORD               dwServiceAccountNameReturnLen;
    DWORD               sc;


    //
    // Get cluster service account principal name
    //
    pcndNodeData->pszClusterServiceAccountName = NULL;

    sc = ClusterNodeControl(
                          hNode, // node handle
                          hNode, 
                          CLUSCTL_NODE_GET_CLUSTER_SERVICE_ACCOUNT_NAME,
                          NULL, // not used 
                          0, // not used
                          NULL, // output buffer
                          0, // output buffer size (bytes)
                          &dwServiceAccountNameLen // resulting data size (bytes)
                          );

    if ( sc != ERROR_SUCCESS ) 
    {  
        goto Cleanup;
    }

    pcndNodeData->pszClusterServiceAccountName = 
                              (LPWSTR) HeapAlloc(
                                                  GetProcessHeap()
                                                , HEAP_ZERO_MEMORY
                                                , dwServiceAccountNameLen
                                                );
    if ( pcndNodeData->pszClusterServiceAccountName == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_QUERY_FAILED, pszClusterName );
        goto Cleanup;
    }


    sc = ClusterNodeControl( 
                         hNode, // node handle
                         hNode, 
                         CLUSCTL_NODE_GET_CLUSTER_SERVICE_ACCOUNT_NAME,
                         NULL, // not used
                         0, // not used
                         pcndNodeData->pszClusterServiceAccountName,                                    
                         dwServiceAccountNameLen, // output buffer size (bytes)
                         &dwServiceAccountNameReturnLen // resulting data size (bytes)                                                                     
                         );
    

    if ( sc != ERROR_SUCCESS ) 
    {
        PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_QUERY_FAILED, pszClusterName );
        goto Cleanup;
    }

    _wcslwr(pcndNodeData->pszClusterServiceAccountName); 

Cleanup:
    if ( sc != ERROR_SUCCESS ) 
    {
        // release pcndNodeData->pszClusterServiceAccountName
        if ( pcndNodeData->pszClusterServiceAccountName != NULL ) 
        {
            HeapFree( GetProcessHeap(), 0, pcndNodeData->pszClusterServiceAccountName );
            pcndNodeData->pszClusterServiceAccountName = NULL;
        }
    }

    return sc;
}  // GetClusterServiceAccountName()



//////////////////////////////////////////////////////////////////////////////
//++
//
//  GetSCMClusterServiceAccountName
//
//  Description:
//      Get the cluster service account name stored in SCM on a particular node.
//
//  Arguments:
//      pszNodeIn
//      pcdClusterNodeDataIn
//      pszClusterName
//
//  Return Values:
//      ERROR_SUCCESS
//      Other Win32 error code
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
GetSCMClusterServiceAccountName(
      LPCWSTR       pszNodeIn
    , PCLUSTER_NODE_DATA pcndNodeData
    , LPCWSTR            pszClusterName
    )
{
    DWORD                   sc = ERROR_SUCCESS;
    BOOL                    fSuccess = TRUE;
    SC_HANDLE               schSCManager = NULL;
    SC_HANDLE               schClusSvc = NULL;
    LPQUERY_SERVICE_CONFIG  pServiceConfig = NULL;
    DWORD                   rgcbBytesNeeded[ 2 ];
    size_t                  cbSCMServiceAccountNameLen;
    HRESULT                 hr = S_OK;

    //
    // Open the Service Control Manager.
    //
    schSCManager = OpenSCManager( pszNodeIn, NULL, GENERIC_READ );
    if ( schSCManager == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    } // if:

    //
    // Open the Cluster Service.
    //
    schClusSvc = OpenService( schSCManager, L"clussvc", GENERIC_READ );
    if ( schClusSvc == NULL )
    {
        sc = GetLastError();
        goto Cleanup;
    } // if:

    //
    // Get service configuration information for the cluster service.
    //

    //
    // Get the number of bytes to allocate for the Service Config structure.
    //
    fSuccess = QueryServiceConfig(
                      schClusSvc
                    , NULL    // pointer to buffer
                    , 0    // size of buffer
                    , &rgcbBytesNeeded[ 0 ]    // bytes needed
                    );
    if ( fSuccess )
    {
        sc =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } // if:

    sc = GetLastError();
    if ( sc != ERROR_INSUFFICIENT_BUFFER )
    {
        goto Cleanup;
    } // if:

    //
    // Allocate the Service Config structure.
    //
    pServiceConfig = (LPQUERY_SERVICE_CONFIG) HeapAlloc( GetProcessHeap(), 
                                                         HEAP_ZERO_MEMORY, 
                                                         rgcbBytesNeeded[ 0 ] 
                                                         );
    if ( pServiceConfig == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    } // if:

    //
    // Get the service configuraiton information.
    //
    fSuccess = QueryServiceConfig(
                      schClusSvc
                    , pServiceConfig   // pointer to buffer
                    , rgcbBytesNeeded[ 0 ]    // size of buffer 
                    , &rgcbBytesNeeded[ 1 ]    // bytes needed
                    );
    if ( ! fSuccess )
    {
        sc = GetLastError();
        goto Cleanup;
    } // if:

    cbSCMServiceAccountNameLen = (wcslen(pServiceConfig->lpServiceStartName)+1) * sizeof(WCHAR);
    pcndNodeData->pszSCMClusterServiceAccountName = NULL;
    pcndNodeData->pszSCMClusterServiceAccountName = 
                              (LPWSTR) HeapAlloc(
                                                  GetProcessHeap()
                                                , HEAP_ZERO_MEMORY
                                                , cbSCMServiceAccountNameLen
                                                );
    if ( pcndNodeData->pszSCMClusterServiceAccountName == NULL )
    {
        sc = ERROR_NOT_ENOUGH_MEMORY;
        PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_QUERY_FAILED, pszClusterName );
        goto Cleanup;
    } // if:
    hr = THR( StringCchCopyW(
                          pcndNodeData->pszSCMClusterServiceAccountName
                        , cbSCMServiceAccountNameLen
                        , pServiceConfig->lpServiceStartName
                        ) );
    if ( FAILED( hr ) )
    {
        sc = HRESULT_CODE( hr );
        goto Cleanup;
    } // if:

    _wcslwr(pcndNodeData->pszSCMClusterServiceAccountName);

    sc = ERROR_SUCCESS;

Cleanup:

    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if:

    if ( schSCManager != NULL )
    {
        CloseServiceHandle( schSCManager );
    } // if:

    if ( pServiceConfig != NULL )
    {
        HeapFree( GetProcessHeap(), 0, pServiceConfig );
    } // if:

    if ( sc != ERROR_SUCCESS ) 
    {
        // release pcndNodeData->pszSCMClusterServiceAccountName
        if ( pcndNodeData->pszSCMClusterServiceAccountName != NULL ) 
        {
            HeapFree( GetProcessHeap(), 0, pcndNodeData->pszSCMClusterServiceAccountName );
            pcndNodeData->pszSCMClusterServiceAccountName = NULL;
        } // if:
    } // if:

    return sc;

} //*** GetSCMClusterServiceAccountName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ScBuildNodeList
//
//  Description:
//      Build the list of nodes in each cluster.
//
//      FOR each cluster entered
//          Open connection to the cluster 
//
//          Check if contains NT4/Win2K node
//
//          FOR each node in this cluster
//              Get node name, node id, node state, service account which 
//              cluster service is using, and cluster service account stored 
//              in SCM database.
//          ENDFOR
//      ENDFOR
//
//  Arguments:
//      None.
//
//  Return Values:
//      ERROR_SUCCESS
//      Other Win32 error codes.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
ScBuildNodeList( void )
{
    DWORD               sc = ERROR_SUCCESS;
    DWORD               cNumNodes = 0;
    BOOL                fAllNodesDown;
    HCLUSENUM           hClusEnum = NULL;
    HNODE               hNode = NULL;
    size_t              idxClusters;
    DWORD               idxNodes = 0;
    WCHAR               szNodeName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD               cchNodeName = 0;
    DWORD               nObjType = 0;
    PCLUSTER_NODE_DATA  pcndNodeData = NULL;
    DWORD               cchNodeStrId;
    DWORD               lpcchClusterName;
    CLUSTERVERSIONINFO  cviClusterInfo;
    HRESULT             hr = S_OK;

    for ( idxClusters = 0 ; idxClusters < g_cNumClusters ; idxClusters++ )
    { /* 0 */

        cNumNodes = 0;
        fAllNodesDown = TRUE;

        //
        // Open the cluster.
        //
        g_rgcdClusters[ idxClusters ].hCluster = OpenCluster( g_rgcdClusters[ idxClusters ].pszClusterName );
        if ( g_rgcdClusters[ idxClusters ].hCluster == NULL )
        {
            sc = GetLastError();
            PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_QUERY_FAILED, g_rgcdClusters[ idxClusters ].pszClusterName );
            goto Cleanup;
        }

        //
        // check if cluster contains NT4/Win2K node(s)
        //
        lpcchClusterName = 0;
        cviClusterInfo.dwVersionInfoSize = sizeof(CLUSTERVERSIONINFO);
        sc = GetClusterInformation( g_rgcdClusters[ idxClusters ].hCluster,
                                        NULL, // pointer to cluster name
                                        &lpcchClusterName,
                                        &cviClusterInfo // pointer to CLUSTERVERSIONINFO 
                                        );
        if ( sc != ERROR_SUCCESS ) 
        {
            PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_QUERY_FAILED, g_rgcdClusters[ idxClusters ].pszClusterName );
            goto Cleanup;
        }  
        g_rgcdClusters[ idxClusters ].dwMixedMode = 
            ( CLUSTER_GET_MAJOR_VERSION(cviClusterInfo.dwClusterHighestVersion) <= 3 );


        //
        // Open an enumeration of nodes on that cluster.
        //
        hClusEnum = ClusterOpenEnum( g_rgcdClusters[ idxClusters ].hCluster, CLUSTER_ENUM_NODE );
        if ( hClusEnum == NULL )
        {
            sc = GetLastError();
            PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_QUERY_FAILED, g_rgcdClusters[ idxClusters ].pszClusterName );
            goto Cleanup;
        }   

        //
        // Query each node of the cluster
        //
        for ( idxNodes = 0 ; ; idxNodes++ )
        {  /* 1 */

            //
            // Get the next node.
            //
            cchNodeName = RTL_NUMBER_OF( szNodeName );
            sc = ClusterEnum( hClusEnum, idxNodes, &nObjType, szNodeName, &cchNodeName );
            if ( sc == ERROR_SUCCESS )
            {  /* 2 */
                cNumNodes++;

                pcndNodeData = (PCLUSTER_NODE_DATA) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof( CLUSTER_NODE_DATA ) );
                if ( pcndNodeData == NULL )
                {
                    sc = ERROR_NOT_ENOUGH_MEMORY;
                    PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_NODE_QUERY_FAILED, szNodeName, g_rgcdClusters[ idxClusters ].pszClusterName );
                    goto Cleanup;
                }

                pcndNodeData->pcndNodeNext = g_rgcdClusters[ idxClusters ].pcndNodeList;
                g_rgcdClusters[ idxClusters ].pcndNodeList = pcndNodeData;

                //
                // Get node name
                //
                hr = THR( StringCchCopyW( pcndNodeData->szNodeName, RTL_NUMBER_OF( pcndNodeData->szNodeName ), szNodeName ) );
                if ( FAILED( hr ) )
                {
                    sc = HRESULT_CODE( hr );
                    goto Cleanup;
                } // if:

                //
                // Get node id
                //
                hNode = OpenClusterNode( g_rgcdClusters[ idxClusters ].hCluster, szNodeName );
                if ( hNode == NULL )
                {
                    sc = GetLastError();
                    PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_NODE_QUERY_FAILED, szNodeName, g_rgcdClusters[ idxClusters ].pszClusterName );
                    goto Cleanup;
                }
                cchNodeStrId = sizeof( pcndNodeData->szNodeStrId ) / sizeof( pcndNodeData->szNodeStrId[ 0 ] );
                sc = GetClusterNodeId( hNode, (LPWSTR) pcndNodeData->szNodeStrId, &cchNodeStrId );
                if ( sc != ERROR_SUCCESS )
                {
                    PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_NODE_QUERY_FAILED, szNodeName, g_rgcdClusters[ idxClusters ].pszClusterName );
                    goto Cleanup;
                }
                pcndNodeData->nNodeId = wcstol( pcndNodeData->szNodeStrId, (WCHAR **) NULL, 10 );
                if ((pcndNodeData->nNodeId == LONG_MAX)  ||  (pcndNodeData->nNodeId == LONG_MIN))
                {
                    sc = ERROR_INSUFFICIENT_BUFFER;
                    PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_NODE_QUERY_FAILED, szNodeName, g_rgcdClusters[ idxClusters ].pszClusterName );
                    goto Cleanup;
                }
                
                //
                // Get node state
                //
                pcndNodeData->cnsNodeState = GetClusterNodeState( hNode );


                if ( (pcndNodeData->cnsNodeState == ClusterNodeUp) ||
                     (pcndNodeData->cnsNodeState == ClusterNodePaused)
                     ) 
                {
                    //
                    // Get account which cluster service is using
                    //
                    sc = GetClusterServiceAccountName(pcndNodeData,
                                                      hNode,
                                                      g_rgcdClusters[ idxClusters ].pszClusterName
                                                      );
                    

                    //
                    // if ((sc == ERROR_INVALID_FUNCTION) or (sc == RPC_S_PROCNUM_OUT_OF_RANGE )), 
                    // it means we try to talk to a NT4/Win2K node. In this case, 
                    // pcndNodeData->pszClusterServiceAccountName is set to null.
                    //

                    if (( sc != ERROR_SUCCESS ) && 
                        ( sc != ERROR_INVALID_FUNCTION ) && 
                        ( sc != RPC_S_PROCNUM_OUT_OF_RANGE ))
                    {
                        PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_NODE_QUERY_FAILED, szNodeName, g_rgcdClusters[ idxClusters ].pszClusterName );
                        goto Cleanup;
                    }

                    if ( (sc == ERROR_SUCCESS) && (g_FirstNodeWithNonNullClusterServiceAccountName==NULL) ) 
                    {
                        g_FirstNodeWithNonNullClusterServiceAccountName = pcndNodeData;
                        g_FirstNonNullNodeClusterIndex = idxClusters;
                    }

                    //
                    // Get cluster service account name stored in SCM
                    //
                    sc = GetSCMClusterServiceAccountName( szNodeName, pcndNodeData, g_rgcdClusters[ idxClusters ].pszClusterName );

                    if ( sc != ERROR_SUCCESS ) 
                    {
                        PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_NODE_QUERY_FAILED, szNodeName, g_rgcdClusters[ idxClusters ].pszClusterName );
                        goto Cleanup;
                    }

                    if (g_FirstNodeWithNonNullSCMClusterServiceAccountName==NULL)  
                    {
                        g_FirstNodeWithNonNullSCMClusterServiceAccountName = pcndNodeData;
                    }

                    fAllNodesDown = FALSE;
                }
                                
                
                CloseClusterNode( hNode );
                hNode = NULL;
            } /* 2 */ // if: ClusterEnum succeeded
            else
            {  /* 2 */
                if ( sc == ERROR_NO_MORE_ITEMS )
                {
                    g_rgcdClusters[ idxClusters ].cNumNodes = cNumNodes;
                    break;
                }
                else
                {
                    PrintMessage( MSG_CHANGE_PASSWORD_CLUSTER_QUERY_FAILED, g_rgcdClusters[ idxClusters ].pszClusterName );
                    goto Cleanup;
                }
            } /* 2 */ // else: error from ClusterEnum
        } /* 1 */ // for: each node in the cluster


        if ( fAllNodesDown ) 
        {
            // With OpenCluster succeeded, there should be at least one Up/Paused
            // node in the cluster.
            sc = ERROR_NODE_NOT_AVAILABLE;
            goto Cleanup;
        }

        ClusterCloseEnum( hClusEnum );
        hClusEnum = NULL;
    } /* 0 */ // for: each cluster

    sc = ERROR_SUCCESS;

Cleanup:

    if ( hNode != NULL )
    {
        CloseClusterNode( hNode );
    }

    if ( hClusEnum != NULL )
    {
        ClusterCloseEnum( hClusEnum );
    }


    return sc;

} //*** ScBuildNodeList

//////////////////////////////////////////////////////////////////////////////
//++
//
//  PrintClusters
//
//  Description:
//      Print information about each cluster.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None
//
//--
//////////////////////////////////////////////////////////////////////////////
VOID 
PrintClusters( void )
{
    size_t              idxClusters;
    PCLUSTER_NODE_DATA  pcndNodeData;


    PrintMessage( MSG_BLANKLINE_SEPARATOR );


    for ( idxClusters = 0 ; idxClusters < g_cNumClusters ; idxClusters++ )
    {
        PrintMessage(
              MSG_DISPLAYING_CLUSTER_HEADER
            , g_rgcdClusters[ idxClusters ].pszClusterName
            , g_rgcdClusters[ idxClusters ].cNumNodes
            );


        pcndNodeData = g_rgcdClusters[ idxClusters ].pcndNodeList;
        while ( pcndNodeData != NULL )
        {
            LPWSTR pwszNodeState = NULL;

            GetNodeStateString( pcndNodeData, &pwszNodeState );

            PrintMessage(
                  MSG_DISPLAYING_CLUSTER_NODE_NAME_ID_STATE
                , pcndNodeData->szNodeName
                , pcndNodeData->nNodeId
                , pwszNodeState
                , pcndNodeData->pszClusterServiceAccountName
                , pcndNodeData->pszSCMClusterServiceAccountName
                );

            pcndNodeData = pcndNodeData->pcndNodeNext;
            LocalFree( pwszNodeState );

        } // while: more nodes in the cluster
    } // for: each cluster
    

    PrintMessage( MSG_BLANKLINE_SEPARATOR );
    
    return;
        
} //*** PrintClusters


//////////////////////////////////////////////////////////////////////////////
//++
//
//  FAllNodesUpOrPaused
//
//  Description:
//      Returns a boolean value indicating whether all nodes are in an UP
//      or PAUSED state or not.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE    All nodes are either in an UP or PAUSED state.
//      FALSE   At least one node is not in an UP or PAUSED state.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
FAllNodesUpOrPaused( int mcpfFlags )
{
    size_t              idxClusters;
    BOOL                fAllNodesUp = TRUE;
    PCLUSTER_NODE_DATA  pcndNodeData;

    UNREFERENCED_PARAMETER( mcpfFlags );

    for ( idxClusters = 0 ; idxClusters < g_cNumClusters ; idxClusters++ )
    {
        pcndNodeData = g_rgcdClusters[ idxClusters ].pcndNodeList;
        while ( pcndNodeData != NULL )
        {
            if (    ( pcndNodeData->cnsNodeState != ClusterNodeUp )
                &&  ( pcndNodeData->cnsNodeState != ClusterNodePaused )
                )
            {
                LPWSTR pwszNodeState = NULL;

                GetNodeStateString( pcndNodeData, &pwszNodeState );

                PrintMessage(MSG_NODE_NOT_AVAILABLE,
                                 pcndNodeData->szNodeName,
                                 g_rgcdClusters[ idxClusters ].pszClusterName,
                                 pwszNodeState
                                 );

                LocalFree( pwszNodeState );
                fAllNodesUp = FALSE;
   