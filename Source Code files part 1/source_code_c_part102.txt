atus = ClusterRegQueryValue(
                    hkey,
                    pwszValueName,
                    &dwType,
                    NULL,
                    &cbSize
                    );
    if (    (dwStatus != ERROR_SUCCESS)
        &&  (dwStatus != ERROR_MORE_DATA) )
    {
        if ( dwStatus  == ERROR_FILE_NOT_FOUND )
        {
            dwStatus = ERROR_SUCCESS;
        } // if:  value not found
        return dwStatus;
    } // if:  error occurred

    if ( cbSize > 0 )
    {
        // Allocate a value string.
        pwszValue = new WCHAR[ cbSize / sizeof( *pwszValue ) ];
        if ( pwszValue == NULL )
        {
            dwStatus = GetLastError();
            return dwStatus;
        } // if:  error allocating memory

        // Read the the value.
        dwStatus = ClusterRegQueryValue(
                        hkey,
                        pwszValueName,
                        &dwType,
                        reinterpret_cast< LPBYTE >( pwszValue ),
                        &cbSize
                        );
        if ( dwStatus != ERROR_SUCCESS )
        {
            delete [] pwszValue;
            pwszValue = NULL;
            cbSize = 0;
        } // if:  error occurred

        *ppwszValue = pwszValue;
        *pcbSize = cbSize;
    } // if:  value is not empty

    return dwStatus;

} //*** ReadValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\regext.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		RegExt.h
//
//	Implementation File:
//		RegExt.cpp
//
//	Description:
//		Definitions of routines for extension registration.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __REGEXT_H__
#define __REGEXT_H__

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

// Registration routines.

STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

// Unregistration routines.

STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

/////////////////////////////////////////////////////////////////////////////

#endif // __REGEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\wins.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Wins.cpp
//
//  Description:
//      Implementation of the WINS Service resource extension property page classes.
//
//  Author:
//      David Potter (DavidP)   March 24, 1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClNetResEx.h"
#include "Wins.h"
#include "BasePage.inl"
#include "ExtObj.h"
#include "DDxDDv.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWinsParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CWinsParamsPage, CBasePropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CWinsParamsPage, CBasePropertyPage )
    //{{AFX_MSG_MAP(CWinsParamsPage)
    ON_EN_CHANGE( IDC_PP_WINS_DATABASEPATH, OnChangeRequiredField )
    ON_EN_CHANGE( IDC_PP_WINS_BACKUPPATH, OnChangeRequiredField )
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWinsParamsPage::CWinsParamsPage
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWinsParamsPage::CWinsParamsPage( void )
    : CBasePropertyPage(
            CWinsParamsPage::IDD,
            g_aHelpIDs_IDD_PP_WINS_PARAMETERS,
            g_aHelpIDs_IDD_WIZ_WINS_PARAMETERS
            )
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CWinsParamsPage)
    m_strDatabasePath = _T("");
    m_strBackupPath = _T("");
    //}}AFX_DATA_INIT

    // Setup the property array.
    {
        m_rgProps[ epropDatabasePath ].Set( REGPARAM_WINS_DATABASEPATH, m_strDatabasePath, m_strPrevDatabasePath, m_strDatabaseExpandedPath );
        m_rgProps[ epropBackupPath ].Set( REGPARAM_WINS_BACKUPPATH, m_strBackupPath, m_strPrevBackupPath, m_strBackupExpandedPath );
    } // Setup the property array

    m_iddPropertyPage = IDD_PP_WINS_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_WINS_PARAMETERS;

} //*** CWinsParamsPage::CWinsParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWinsParamsPage::DoDataExchange
//
//  Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWinsParamsPage::DoDataExchange( CDataExchange * pDX )
{
    if ( ! pDX->m_bSaveAndValidate || ! BSaved() )
    {
        AFX_MANAGE_STATE( AfxGetStaticModuleState() );

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CWinsParamsPage)
        DDX_Control( pDX, IDC_PP_WINS_DATABASEPATH, m_editDatabasePath );
        DDX_Control( pDX, IDC_PP_WINS_BACKUPPATH, m_editBackupPath );
        DDX_Text( pDX, IDC_PP_WINS_DATABASEPATH, m_strDatabasePath );
        DDX_Text( pDX, IDC_PP_WINS_BACKUPPATH, m_strBackupPath );
        //}}AFX_DATA_MAP

        // Handle numeric parameters.
        if ( ! BBackPressed() )
        {
        } // if: back button not pressed

        if ( pDX->m_bSaveAndValidate )
        {
            // Make sure all required fields are present.
            if ( ! BBackPressed() )
            {
                DDV_RequiredText( pDX, IDC_PP_WINS_DATABASEPATH, IDC_PP_WINS_DATABASEPATH_LABEL, m_strDatabasePath );
                DDV_RequiredText( pDX, IDC_PP_WINS_BACKUPPATH, IDC_PP_WINS_BACKUPPATH_LABEL, m_strBackupPath );

            } // if: back button not pressed
        } // if: saving data from dialog
    } // if: not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange( pDX );

} //*** CWinsParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWinsParamsPage::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWinsParamsPage::OnInitDialog( void )
{
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CBasePropertyPage::OnInitDialog();

    // Limit the size of the text that can be entered in edit controls.
    m_editDatabasePath.SetLimitText( _MAX_PATH );
    m_editBackupPath.SetLimitText( _MAX_PATH );

    // If this is a wizard, make sure the default values are something legal.
    if ( BWizard( ) )
    {
        DWORD    status;
        WCHAR    szValidDevice[ 3 ]; // "X:" + NULL
        DWORD    dwSize = sizeof(szValidDevice) / sizeof(szValidDevice[0]);

        szValidDevice[ 0 ] = L'\0';
        
        status = ResUtilFindDependentDiskResourceDriveLetter( Peo( )->Hcluster( ), 
                                                              Peo( )->PrdResData( )->m_hresource, 
                                                              szValidDevice, 
                                                              &dwSize 
                                                              );
        szValidDevice[ 2 ] = L'\0';

        // Did we find a disk resource in the the dependency list?
        if ( status == ERROR_SUCCESS
          && szValidDevice[ 0 ] != L'\0' )
        {
            WCHAR szFilePath[ MAX_PATH ];


            // If the default is "%SystemRoot%\<something>" then change it to match the
            // dependent resource
            if ( m_editDatabasePath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
              && ClRtlStrNICmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
            {
                // Start with the new drive letter
                hr = StringCchCopyNW( szFilePath, RTL_NUMBER_OF( szFilePath ), szValidDevice, 3 );
                if ( hr != S_OK )
                {
                    goto Cleanup;
                } // if:

                // Is the expanded string really expanded?
                if ( m_strDatabaseExpandedPath[0] != L'%'  )
                {   // yes, then just copy the expanded string minus the drive letter.
                    LPCWSTR psz = m_strDatabaseExpandedPath;
                    psz = wcschr( psz, L':' );
                    if ( psz )
                    {
                        psz++;  // move to next character
                    }
                    else // if: psz
                    {
                        psz = m_strDatabaseExpandedPath;
                    } // else: just cat the whole thing, let the user figure it out.
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( hr != S_OK )
                    {
                        goto Cleanup;
                    } // if:
                }
                else
                {   // no, then strip the %SystemRoot%
                    // find the ending '%'... this must be there because of the strcmp above!
                    LPCWSTR psz = m_strBackupExpandedPath;
                    psz = wcschr( psz + 1, L'%' );
                    ASSERT( psz );
                    psz++; // move past the '%'
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( hr != S_OK )
                    {
                        goto Cleanup;
                    } // if:
                }

                m_editDatabasePath.SetWindowText( szFilePath );
            } // if: m_editDatabasePath == %SystemRoot%

            // If the default is "%SystemRoot%\<something>" then change it to match the
            // dependent resource
            if ( m_editBackupPath.GetWindowText( szFilePath, MAX_PATH ) >= sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1
              && ClRtlStrNICmp( szFilePath, L"%SystemRoot%", sizeof(L"%SystemRoot%")/sizeof(WCHAR) - 1 ) == 0 )
            {
                // Start with the new drive letter
                hr = StringCchCopyNW( szFilePath, RTL_NUMBER_OF( szFilePath ), szValidDevice, 3 );
                if ( hr != S_OK )
                {
                    goto Cleanup;
                } // if:

                // Is the expanded string really expanded?
                if ( m_strBackupExpandedPath[0] != L'%'  )
                {   // yes, then just copy the expanded string minus the drive letter. minus the drive letter.
                    LPCWSTR psz = m_strBackupExpandedPath;
                    psz = wcschr( psz, L':' );
                    if ( psz )
                    {
                        psz++;  // move to next character
                    }
                    else // if: psz
                    {
                        psz = m_strBackupExpandedPath;
                    } // else: just cat the whole thing, let the user figure it out.
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( hr != S_OK )
                    {
                        goto Cleanup;
                    } // if:
                }
                else
                {   // no, then strip the %SystemRoot%
                    // find the ending '%'... this must be there because of the strcmp above!
                    LPCWSTR psz = m_strBackupExpandedPath;
                    psz = wcschr( psz + 1, L'%' );
                    ASSERT( psz );
                    psz++; // move past the '%'
                    hr = StringCchCatW( szFilePath, RTL_NUMBER_OF( szFilePath ), psz );
                    if ( hr != S_OK )
                    {
                        goto Cleanup;
                    } // if:
                }

                m_editBackupPath.SetWindowText( szFilePath );
            } // if: m_editBackupPath == %SystemRoot%

        } // if: found a disk resource


    } // if: in a wizard

Cleanup:

    return TRUE;        // return TRUE unless you set the focus to a control
                        // EXCEPTION: OCX Property Pages should return FALSE

} //*** CWinsParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWinsParamsPage::OnSetActive
//
//  Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWinsParamsPage::OnSetActive( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Enable/disable the Next/Finish button.
    if ( BWizard() )
    {
        EnableNext( BAllRequiredFieldsPresent() );
    } // if: displaying a wizard

    return CBasePropertyPage::OnSetActive();

} //*** CWinsParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWinsParamsPage::OnChangeRequiredField
//
//  Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWinsParamsPage::OnChangeRequiredField( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    OnChangeCtrl();

    if ( BWizard() )
    {
        EnableNext( BAllRequiredFieldsPresent() );
    } // if: displaying a wizard

} //*** CWinsParamsPage::OnChangeRequiredField()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWinsParamsPage::BAllRequiredFieldsPresent
//
//  Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWinsParamsPage::BAllRequiredFieldsPresent( void ) const
{
    BOOL    _bPresent;

    if ( 0
        || (m_editDatabasePath.GetWindowTextLength() == 0)
        || (m_editBackupPath.GetWindowTextLength() == 0)
        )
    {
        _bPresent = FALSE;
    } // if: required field not present
    else
    {
        _bPresent = TRUE;
    } // else: all required fields are present

    return _bPresent;

} //*** CWinsParamsPage::BAllRequiredFieldsPresent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clnetres\clnetresex\wins.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Wins.h
//
//	Implementation File:
//		Wins.cpp
//
//	Description:
//		Definition of the WINS Service resource extension property page classes.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WINS_H__
#define __WINS_H__

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectPropert
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWinsParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CWinsParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CWinsParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE( CWinsParamsPage )

// Construction
public:
	CWinsParamsPage( void );

// Dialog Data
	//{{AFX_DATA(CWinsParamsPage)
	enum { IDD = IDD_PP_WINS_PARAMETERS };
	CEdit	m_editDatabasePath;
	CEdit	m_editBackupPath;
	CString	m_strDatabasePath;
	CString	m_strBackupPath;
	//}}AFX_DATA
	CString	m_strPrevDatabasePath;
	CString	m_strPrevBackupPath;
	CString m_strDatabaseExpandedPath;
	CString m_strBackupExpandedPath;

protected:
	enum
	{
		epropDatabasePath,
		epropBackupPath,
		epropMAX
	};
	CObjectProperty		m_rgProps[ epropMAX ];

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWinsParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops( void ) const	{ return m_rgProps; }
	virtual DWORD					Cprops( void ) const	{ return sizeof( m_rgProps ) / sizeof( CObjectProperty ); }

// Implementation
protected:
	BOOL	BAllRequiredFieldsPresent( void ) const;

	// Generated message map functions
	//{{AFX_MSG(CWinsParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeRequiredField();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CWinsParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // __WINS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\common\svc.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    svc.h

Abstract:

    Header file for definitions and structure for the NT Cluster
    Special generic services.

Author:

    John Vert (jvert) 14-June-1997

Revision History:

--*/

#ifndef _COMMONSVC_INCLUDED_
#define _COMMONSVC_INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif


typedef struct _COMMON_DEPEND_SETUP {
    DWORD               Offset;
    CLUSPROP_SYNTAX     Syntax;
    DWORD               Length;
    PVOID               Value;
} COMMON_DEPEND_SETUP, * PCOMMON_DEPEND_SETUP;

// Localsvc.h must define CommonDependSetup using this structure.
// Localsvc.h must define COMMON_CONTROL to generate control functions

#ifdef _cplusplus
}
#endif


#endif // ifndef _COMMONSVC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clusres\clusres.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    clusres.c

Abstract:

    Common Resource DLL Startup

Author:

    John Vert (jvert) 12/15/1996

Revision History:
    Sivaprasad Padisetty (sivapad) 04/22/1996  Added the local quorum

--*/
#include "clusres.h"
#include "clusrtl.h"
#include "clusudef.h"

PSET_RESOURCE_STATUS_ROUTINE ClusResSetResourceStatus = NULL;
PLOG_EVENT_ROUTINE ClusResLogEvent = NULL;
DWORD g_dwDebugLogLevel;

BOOLEAN
WINAPI
ClusResDllEntry(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
/*++

Routine Description:

    Main DLL entrypoint for combined resource DLL.

Arguments:

    DllHandle - Supplies the DLL handle.

    Reason - Supplies the call reason

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        LPWSTR lpszDebugLogLevel;

        DisableThreadLibraryCalls(DllHandle);

        lpszDebugLogLevel = _wgetenv(L"ClusterLogLevel");

        g_dwDebugLogLevel = 0;
        if (lpszDebugLogLevel != NULL) {
            int nFields;

            nFields = swscanf(lpszDebugLogLevel, L"%u", &g_dwDebugLogLevel);
            if ( nFields != 1 ) {
                g_dwDebugLogLevel = 0;
            }
        }

        ClRtlInitialize( TRUE, &g_dwDebugLogLevel );
        ClRtlInitWmi(NULL);
    }

    //
    // Let everybody else have their shot at it.
    //
    if (!GenAppDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!GenSvcDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

#if 0
    if (!FtSetDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }
#endif

    if (!DisksDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!NetNameDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!IpAddrDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!SmbShareDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!SplSvcDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!LkQuorumDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

#if 0
    if (!TimeSvcDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }
#endif

    if (!GenScriptDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!MsMQDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (!MajorityNodeSetDllEntryPoint(DllHandle, Reason, Reserved)) {
        return(FALSE);
    }

    if (Reason == DLL_PROCESS_DETACH) {
        ClRtlCleanup();
    }

    return(TRUE);
}

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup a particular resource type. This means verifying the version
    requested, and returning the function table for this resource type.

Arguments:

    ResourceType - Supplies the type of resource.

    MinVersionSupported - The minimum version number supported by the cluster
                    service on this system.

    MaxVersionSupported - The maximum version number supported by the cluster
                    service on this system.

    SetResourceStatus - xxx

    LogEvent - xxx

    FunctionTable - Returns the Function Table for this resource type.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( !ClusResLogEvent ) {
        ClusResLogEvent = LogEvent;
        ClusResSetResourceStatus = SetResourceStatus;
    }

    if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_GENSVC ) == 0 ) {
        *FunctionTable = &GenSvcFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_GENAPP ) == 0 ) {
        *FunctionTable = &GenAppFunctionTable;
        return(ERROR_SUCCESS);
#if 0
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_FTSET ) == 0 ) {
        *FunctionTable = &FtSetFunctionTable;
        return(ERROR_SUCCESS);
#endif
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_PHYS_DISK ) == 0 ) {
        *FunctionTable = &DisksFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_FILESHR ) == 0 ) {
        *FunctionTable = &SmbShareFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_NETNAME ) == 0 ) {
        *FunctionTable = &NetNameFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_IPADDR ) == 0 ) {
        *FunctionTable = &IpAddrFunctionTable;
        return(ERROR_SUCCESS);
#if 0
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_TIMESVC ) == 0 ) {
        *FunctionTable = &TimeSvcFunctionTable;
        return(ERROR_SUCCESS);
#endif
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_PRTSPLR ) == 0 ) {
        *FunctionTable = &SplSvcFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_LKQUORUM ) == 0 ) {
        *FunctionTable = &LkQuorumFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_MSMQ ) == 0 ) {
        *FunctionTable = &MsMQFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_GENSCRIPT ) == 0 ) {
        *FunctionTable = &GenScriptFunctionTable;
        return(ERROR_SUCCESS);
    } else if ( lstrcmpiW( ResourceType, CLUS_RESTYPE_NAME_MAJORITYNODESET) == 0 ) {
        *FunctionTable = &MajorityNodeSetFunctionTable;
        return(ERROR_SUCCESS);
    } else {
        return(ERROR_CLUSTER_RESNAME_NOT_FOUND);
    }
} // Startup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\arbitrat.h ===
/*++

Copyright (c) 1998

Module Name:

    arbitrate.h

Abstract:

    These are the structures and defines that are used in the
    arbitration code.

Authors:

   Gor Nishanov    (t-gorn)       5-Jun-1998

Revision History:

--*/
#ifndef ARBITRATE_H
#define ARBITRATE_H

#define DEFAULT_SECTOR_SIZE   512 // must be a power of two //
#define BLOCK_X               11
#define BLOCK_Y               12

DWORD
DiskArbitration(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN HANDLE FileHandle
    );

DWORD
StartPersistentReservations(
      IN OUT PDISK_RESOURCE ResourceEntry,
      IN HANDLE FileHandle
      );

VOID
StopPersistentReservations(
      IN OUT PDISK_RESOURCE ResourceEntry
      );

VOID
ArbitrationInitialize(
      VOID
      );

VOID
ArbitrationCleanup(
      VOID
      );

DWORD
ArbitrationInfoInit(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

VOID
ArbitrationInfoCleanup(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

VOID
DestroyArbWorkQueue(
    VOID
    );

DWORD
CreateArbWorkQueue(
      IN RESOURCE_HANDLE ResourceHandle
      );


#define ReservationInProgress(ResEntry) ( (ResEntry)->ArbitrationInfo.ControlHandle )

#endif // ARBITRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\clusres\utils.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Common utility routines for clusters resources

Author:

    John Vert (jvert) 12/15/1996

Revision History:

--*/
#include "clusres.h"
#include "clusrtl.h"
#include "clusudef.h"



DWORD
ClusResOpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    )
/*++

Routine Description:

    This function opens a specified IO drivers.

Arguments:

    Handle - pointer to location where the opened drivers handle is
        returned.

    DriverName - name of the driver to be opened.

Return Value:

    Windows Error Code.

--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      nameString;
    NTSTATUS            status;

    *Handle = NULL;

    //
    // Open a Handle to the IP driver.
    //

    RtlInitUnicodeString(&nameString, DriverName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile(
        Handle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        NULL,
        0
        );

    return( RtlNtStatusToDosError( status ) );

} // ClusResOpenDriver



NTSTATUS
ClusResDoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    )
/*++

Routine Description:

    Utility routine used to issue a filtering ioctl to the tcpip driver.

Arguments:

    Handle - An open file handle on which to issue the request.

    IoctlCode - The IOCTL opcode.

    Request - A pointer to the input buffer.

    RequestSize - Size of the input buffer.

    Response - A pointer to the output buffer.

    ResponseSize - On input, the size in bytes of the output buffer.
                   On output, the number of bytes returned in the output buffer.

Return Value:

    NT Status Code.

--*/
{
    IO_STATUS_BLOCK    ioStatusBlock;
    NTSTATUS           status;


    ioStatusBlock.Information = 0;

    status = NtDeviceIoControlFile(
                 Handle,                          // Driver handle
                 NULL,                            // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IoctlCode,                       // Control code
                 Request,                         // Input buffer
                 RequestSize,                     // Input buffer size
                 Response,                        // Output buffer
                 *ResponseSize                    // Output buffer size
                 );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                     Handle,
                     TRUE,
                     NULL
                     );
    }

    if (status == STATUS_SUCCESS) {
        status = ioStatusBlock.Status;
        *ResponseSize = (DWORD)ioStatusBlock.Information;
    }
    else {
        *ResponseSize = 0;
    }

    return(status);

} // ClusResDoIoctl

LPWSTR
ClusResLoadMessage(
    DWORD   MessageID
    )

/*++

Routine Description:

    Look up the specified string resource as stored in this DLL's resource
    area. Caller is responsible for freeing the buffer with LocalFree().

Arguments:

    MessageID - message number as stored in inc\clusstrs.h

Return Value:

    pointer to string, otherwise NULL with GLE set

--*/

{
    DWORD   charsCopied;
    DWORD   charsAllocated = 0;
    LPWSTR  messageBuffer;
    HMODULE clusresHandle;
    DWORD   returnStatus = ERROR_SUCCESS;

    //
    // get a handle to clusres
    //
    clusresHandle = LoadLibraryEx( CLUSRES_MODULE_NAME, NULL, LOAD_LIBRARY_AS_DATAFILE );
    if ( clusresHandle == NULL ) {
        return NULL;
    }

    //
    // start with 128 char buffer and double until we fail or we get all of the
    // string.
    //
    charsAllocated = 128;

realloc:
    charsCopied = 0;
    messageBuffer = LocalAlloc( LMEM_FIXED, charsAllocated * sizeof( WCHAR ));
    if ( messageBuffer ) {

        charsCopied = LoadString(clusresHandle,
                                 MessageID,
                                 messageBuffer,
                                 charsAllocated);

        if ( charsCopied != 0 ) {
            if ( charsCopied == ( charsAllocated - 1 )) {
                LocalFree( messageBuffer );
                charsAllocated *= 2;
                goto realloc;
            }
        } else {
            returnStatus = GetLastError();
            LocalFree( messageBuffer );
            messageBuffer = NULL;
        }
    } else {
        returnStatus = ERROR_NOT_ENOUGH_MEMORY;
    }   

    FreeLibrary( clusresHandle );

    //
    // if LoadString failed, set last error to its error status and not
    // FreeLibrary's
    //
    if ( returnStatus != ERROR_SUCCESS ) {
        SetLastError( returnStatus );
    }

    return messageBuffer;

} // ClusResLoadMessage

VOID
ClusResLogEventWithName0(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    PWCHAR resName = ResourceName;
    DWORD   dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof( ResourceName );

again:
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)resName,
                                   &BufSize );

    if ( Status == ERROR_MORE_DATA ) {
        resName = LocalAlloc( LMEM_FIXED, BufSize );
        if ( resName != NULL ) {
            goto again;
        }

        resName = ResourceName;
        ResourceName[0] = UNICODE_NULL;
    } else if ( Status != ERROR_SUCCESS ) {
        ResourceName[0] = '\0';
    }

    ClusterLogEvent1(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     resName);

    if ( resName != ResourceName ) {
        LocalFree( resName );
    }

    return;

} // ClusResLogEventWithName0


VOID
ClusResLogEventWithName1(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    PWCHAR resName = ResourceName;
    DWORD   dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof( ResourceName );

again:
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)resName,
                                   &BufSize );

    if ( Status == ERROR_MORE_DATA ) {
        resName = LocalAlloc( LMEM_FIXED, BufSize );
        if ( resName != NULL ) {
            goto again;
        }

        resName = ResourceName;
        ResourceName[0] = UNICODE_NULL;
    } else if ( Status != ERROR_SUCCESS ) {
        ResourceName[0] = '\0';
    }

    ClusterLogEvent2(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     resName,
                     Arg1);

    if ( resName != ResourceName ) {
        LocalFree( resName );
    }

    return;
} // ClusResLogEventWithName1

VOID
ClusResLogEventWithName2(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

    Arg2 - Supplies the second insertion string

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    PWCHAR resName = ResourceName;
    DWORD   dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof( ResourceName );

again:
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)resName,
                                   &BufSize );

    if ( Status == ERROR_MORE_DATA ) {
        resName = LocalAlloc( LMEM_FIXED, BufSize );
        if ( resName != NULL ) {
            goto again;
        }

        resName = ResourceName;
        ResourceName[0] = UNICODE_NULL;
    } else if ( Status != ERROR_SUCCESS ) {
        ResourceName[0] = '\0';
    }

    ClusterLogEvent3(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     resName,
                     Arg1,
                     Arg2);

    if ( resName != ResourceName ) {
        LocalFree( resName );
    }

    return;
} // ClusResLogEventWithName2

VOID
ClusResLogEventWithName3(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    )
/*++

Routine Description:

    Logs an event to the eventlog. The display name of the resource is retrieved
    and passed as the first insertion string.

Arguments:

    hResourceKey - Supplies the cluster resource key.

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

    Arg2 - Supplies the second insertion string

    Arg3 - Supplies the third insertion string

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD BufSize;
    DWORD Status;
    WCHAR ResourceName[80];
    PWCHAR resName = ResourceName;
    DWORD   dwType;

    //
    // Get the display name for this resource.
    //
    BufSize = sizeof( ResourceName );

again:
    Status = ClusterRegQueryValue( hResourceKey,
                                   CLUSREG_NAME_RES_NAME,
                                   &dwType,
                                   (LPBYTE)resName,
                                   &BufSize );

    if ( Status == ERROR_MORE_DATA ) {
        resName = LocalAlloc( LMEM_FIXED, BufSize );
        if ( resName != NULL ) {
            goto again;
        }

        resName = ResourceName;
        ResourceName[0] = UNICODE_NULL;
    } else if ( Status != ERROR_SUCCESS ) {
        ResourceName[0] = '\0';
    }

    ClusterLogEvent4(LogLevel,
                     LogModule,
                     FileName,
                     LineNumber,
                     MessageId,
                     dwByteCount,
                     lpBytes,
                     resName,
                     Arg1,
                     Arg2,
                     Arg3);

    if ( resName != ResourceName ) {
        LocalFree( resName );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\diskinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    diskinfo.h

Abstract:

    Interface for routines that query and manipulate the
    disk configuration of the current system.

Author:

    John Vert (jvert) 10/10/1996

Revision History:

--*/

#ifndef _CLUSRTL_DISK_H_
#define _CLUSRTL_DISK_H_

#ifdef __cplusplus
extern "C" {
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#ifndef __AFX_H__
#undef ASSERT               // make afx.h happy
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls

#include "afxtempl.h"

#include "winioctl.h"
#include "ntddscsi.h"
#include "ntdskreg.h"
#include "ntddft.h"
#include "ntddstor.h"

//
// classes representing info stored in Machine\System\Disk\Information
// registry key
//
class CFtInfoPartition {
public:
    // initialize from registry data
    CFtInfoPartition(class CFtInfoDisk *Disk, DISK_PARTITION UNALIGNED *Description);

    // initialize from data on disk
    CFtInfoPartition(class CFtInfoDisk *Disk, class CPhysicalPartition *Partition);
    CFtInfoPartition(class CFtInfoDisk *Disk, PARTITION_INFORMATION *PartitionInfo);

    ~CFtInfoPartition();

    VOID GetData(PDISK_PARTITION pDest);

    DWORD GetOffset();
    VOID SetOffset(DWORD NewOffset) {m_RelativeOffset = NewOffset;};
    VOID MakeSticky(UCHAR DriveLetter);

    BOOL IsFtPartition() { return(m_PartitionInfo->FtType != NotAnFtMember);};

    DISK_PARTITION UNALIGNED *m_PartitionInfo;
    class CFtInfoDisk *m_ParentDisk;

private:
    DWORD m_RelativeOffset;         // relative offset from parent DISK_DESCRIPTION
    BOOL m_Modified;
};

class CFtInfoDisk {
public:
    // initialize from registry data
    CFtInfoDisk(DISK_DESCRIPTION UNALIGNED *Description);

    // initialize from data on disk
    CFtInfoDisk(class CPhysicalDisk *Disk);
    CFtInfoDisk(DRIVE_LAYOUT_INFORMATION *DriveLayoutData);

    // ?
    CFtInfoDisk(CFtInfoDisk *DiskInfo);

    ~CFtInfoDisk();

    //
    // Overloaded operators
    //
    BOOL operator==(const CFtInfoDisk& Disk1);

    CFtInfoPartition *GetPartition(LARGE_INTEGER StartingOffset,
                                   LARGE_INTEGER Length);
    CFtInfoPartition *GetPartitionByOffset(DWORD Offset);
    CFtInfoPartition *GetPartitionByIndex(DWORD Index);
    DWORD FtPartitionCount();

    DWORD GetSize();
    VOID GetData(PBYTE pDest);

    DWORD GetOffset() {return m_Offset;};
    VOID SetOffset(DWORD NewOffset) {m_Offset = NewOffset;};

    DWORD m_PartitionCount;
    DWORD m_Signature;
private:
    DWORD m_Offset;
    CTypedPtrList<CPtrList, CFtInfoPartition*> m_PartitionInfo;
};

//
// class representing FTDISK registry information. Currently not used
//
class CFtInfoFtSet {
public:
    CFtInfoFtSet() { m_FtDescription = NULL; }
    ~CFtInfoFtSet();

    //
    // Initialization
    //
    BOOL Initialize(USHORT Type, FT_STATE FtVolumeState);
    BOOL Initialize(class CFtInfo *FtInfo, PFT_DESCRIPTION Description);

    //
    // Overloaded operators
    //
    BOOL operator==(const CFtInfoFtSet& FtSet1);

    DWORD GetSize() const;
    VOID GetData(PBYTE pDest);
    DWORD GetMemberCount() const { return((DWORD)m_Members.GetSize()); };

    BOOL IsAlone();

    DWORD AddMember(CFtInfoPartition *Partition, PFT_MEMBER_DESCRIPTION Description, USHORT FtGroup);

    CFtInfoPartition *GetMemberBySignature (DWORD Signature) const;
    CFtInfoPartition *GetMemberByIndex (DWORD Index) const;
    PFT_MEMBER_DESCRIPTION GetMemberDescription(DWORD Index) {
        return(&m_FtDescription->FtMemberDescription[Index]);
    };

    USHORT GetType() const {return(m_FtDescription->Type);};
    FT_STATE GetState() const {return(m_FtDescription->FtVolumeState);};

private:
    BOOL m_Modified;
    PFT_DESCRIPTION m_FtDescription;
    CTypedPtrArray<CPtrArray, CFtInfoPartition*> m_Members;
};

//
// main registry info class. holds lists of disk and ftset registry info along
// with methods for extracting info from lists
//
class CFtInfo {
public:
    CFtInfo();
    CFtInfo(HKEY hKey, LPWSTR lpszValueName);
    CFtInfo(PDISK_CONFIG_HEADER Header);
    CFtInfo(CFtInfoFtSet *FtSet);
    ~CFtInfo();

    //
    // commit changes to FtInfo database to the registry
    //

    DWORD CommitRegistryData();

    DWORD GetSize();
    VOID GetData(PDISK_CONFIG_HEADER pDest);

    CFtInfoPartition *FindPartition(DWORD Signature,
                                    LARGE_INTEGER StartingOffset,
                                    LARGE_INTEGER Length);
    CFtInfoPartition *FindPartition(UCHAR DriveLetter);

    CFtInfoDisk *FindDiskInfo(DWORD Signature);
    CFtInfoDisk *EnumDiskInfo(DWORD Index);

    VOID AddDiskInfo(CFtInfoDisk *NewDisk) { m_DiskInfo.AddTail( NewDisk ); }

    VOID SetDiskInfo(CFtInfoDisk *NewDisk);
    BOOL DeleteDiskInfo(DWORD Signature);

    CFtInfoFtSet *EnumFtSetInfo(DWORD Index);
    CFtInfoFtSet *FindFtSetInfo(DWORD Signature);
    BOOL DeleteFtSetInfo(CFtInfoFtSet *FtSet);
    VOID AddFtSetInfo(CFtInfoFtSet *FtSet, CFtInfoFtSet *OldFtSet = NULL);

private:
    CTypedPtrList<CPtrList, CFtInfoDisk*> m_DiskInfo;
    CTypedPtrList<CPtrList, CFtInfoFtSet*> m_FtSetInfo;
    VOID Initialize(HKEY hKey, LPWSTR lpszValueName);
    VOID Initialize(PDISK_CONFIG_HEADER Header, DWORD Length);
    VOID Initialize();

public:
    LPBYTE m_buffer;
    DWORD m_bufferLength;

};

//
// disk and related partition classes built from actual probing of disks via
// IOCTLs and other disk APIs. This info is built "bottom up" in that the disk
// config is discovered via the SetupDi APIs
//
class CPhysicalDisk  {
public:
    CPhysicalDisk() { m_FtInfo = NULL; }
    DWORD Initialize(CFtInfo *FtInfo, LPWSTR DeviceName);

    BOOL IsSticky();
    DWORD MakeSticky(CFtInfo *FtInfo);
    BOOL IsNTFS();
    DWORD FtPartitionCount() {
        if (m_FtInfo == NULL) {
            return(0);
        } else {
            return(m_FtInfo->FtPartitionCount());
        }
    };

    DWORD m_PartitionCount;
    DWORD m_Signature;
    DWORD m_DiskNumber;
    BOOL m_IsSCSI;
    BOOL m_IsRemovable;
    CTypedPtrList<CPtrList, class CPhysicalPartition*> m_PartitionList;
    CTypedPtrList<CPtrList, class CLogicalDrive*> m_LogicalDriveList;
    BOOL ShareBus(CPhysicalDisk *OtherDisk);
    SCSI_ADDRESS m_ScsiAddress;
    CString m_Identifier;
    CFtInfoDisk *m_FtInfo;


private:
    HANDLE GetPhysicalDriveHandle(DWORD Access);
    HANDLE GetPhysicalDriveHandle(DWORD Access, LPWSTR DeviceName);
};


class CPhysicalPartition {
public:
    CPhysicalPartition(CPhysicalDisk *Disk, PPARTITION_INFORMATION Info);

    CPhysicalDisk *m_PhysicalDisk;
    PARTITION_INFORMATION m_Info;
    CFtInfoPartition *m_FtPartitionInfo;
};

//
// class representing a drive as represented by a drive letter. built in a
// "top down" fashion in that each drive letter is examined to determine the
// physical partition to which the letter is mapped. This structure only
// exists if the logical drive is a real disk, i.e., not built for CDROMs,
// etc.
//
class CLogicalDrive  {

public:
    CLogicalDrive() {
        m_Partition = NULL;
        m_ContainerSet = NULL;
    }
    BOOL Initialize(CPhysicalPartition *Partition);
    BOOL IsSCSI(VOID);
    BOOL ShareBus(CLogicalDrive *OtherDrive);

    DWORD MakeSticky();

    WCHAR m_DriveLetter;
    CString m_VolumeLabel;
    CString m_Identifier;
    BOOL m_IsNTFS;
    BOOL m_IsSticky;
    CPhysicalPartition *m_Partition;
    class CFtSet *m_ContainerSet;
};

//
// logical class for FT sets. not used
//
class CFtSet {
public:
    CFtSet() { m_FtInfo = NULL; }
    BOOL Initialize(class CDiskConfig *Config, CFtInfoFtSet *FtInfo);
    CFtInfoFtSet *m_FtInfo;
    DWORD MakeSticky();
    BOOL IsSticky(VOID);
    BOOL IsNTFS(VOID);
    BOOL IsSCSI(VOID);
    BOOL ShareBus(CLogicalDrive *OtherDrive);
    CTypedPtrList<CPtrList, CLogicalDrive*> m_OtherVolumes;
    CLogicalDrive Volume;
    CTypedPtrList<CPtrList, CPhysicalPartition*> m_Member;
};

//
// main disk configuration class.
//
class CDiskConfig {

public:
    CDiskConfig() { m_SystemVolume = NULL; }
    ~CDiskConfig();
    BOOL Initialize(VOID);

    CTypedPtrList<CPtrList, CFtSet*> m_FtSetList;

    // database of physical drives indexed by drive number.
    CMap<int, int, CPhysicalDisk*, CPhysicalDisk*&> m_PhysicalDisks;

    // database of logical drives indexed by drive letter
    CMap<WCHAR, WCHAR, CLogicalDrive*, CLogicalDrive*&> m_LogicalDrives;

    VOID RemoveAllFtInfoData();
    VOID RemoveDisk(CPhysicalDisk *Disk);
    DWORD MakeSticky(CPhysicalDisk *Disk);
    DWORD MakeSticky(CFtSet *FtSet);
    VOID SetDiskInfo(CFtInfoDisk *NewDisk) {
        m_FTInfo.DeleteDiskInfo(NewDisk->m_Signature);
        m_FTInfo.SetDiskInfo(NewDisk);
        m_FTInfo.CommitRegistryData();
    };

    CPhysicalPartition *FindPartition(CFtInfoPartition *FtPartition);
    BOOL OnSystemBus(CPhysicalDisk *Disk);
    BOOL OnSystemBus(CFtSet *FtSet);
    DWORD MakeSystemDriveSticky() {
        if (m_SystemVolume) {
            return(MakeSticky(m_SystemVolume->m_Partition->m_PhysicalDisk));
        } else {
            return(ERROR_SUCCESS);
        }
    };

    CLogicalDrive *m_SystemVolume;

private:
    CFtInfo m_FTInfo;

};

typedef  struct _DRIVE_LETTER_INFO {
    UINT DriveType;
    STORAGE_DEVICE_NUMBER DeviceNumber;
} DRIVE_LETTER_INFO, *PDRIVE_LETTER_INFO;

extern DRIVE_LETTER_INFO DriveLetterMap[];

#endif


// Some handy C wrappers for the C++ stuff.
//
#ifdef __cplusplus
extern "C" {
#endif

typedef struct _FT_INFO *PFT_INFO;
typedef struct _FULL_FTSET_INFO *PFULL_FTSET_INFO;

typedef struct _FT_DISK_INFO *PFT_DISK_INFO;

typedef struct _DISK_INFO *PDISK_INFO;
typedef struct _FULL_DISK_INFO *PFULL_DISK_INFO;

PFT_INFO
DiskGetFtInfo(
    VOID
    );

VOID
DiskFreeFtInfo(
    PFT_INFO FtInfo
    );

DWORD
DiskEnumFtSetSignature(
    IN PFULL_FTSET_INFO FtSet,
    IN DWORD MemberIndex,
    OUT LPDWORD MemberSignature
    );

DWORD
DiskSetFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN PFULL_FTSET_INFO FtSet
    );

PFULL_FTSET_INFO
DiskGetFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN LPCWSTR lpszMemberList,
    OUT LPDWORD pSize
    );

PFULL_FTSET_INFO
DiskGetFullFtSetInfoByIndex(
    IN PFT_INFO FtInfo,
    IN DWORD Index,
    OUT LPDWORD pSize
    );

VOID
DiskMarkFullFtSetDirty(
    IN PFULL_FTSET_INFO FtSet
    );

DWORD
DiskDeleteFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN LPCWSTR lpszMemberList
    );

BOOL
DiskFtInfoEqual(
    IN PFULL_FTSET_INFO Info1,
    IN PFULL_FTSET_INFO Info2
    );

FT_TYPE
DiskFtInfoGetType(
    IN PFULL_FTSET_INFO Info
    );

BOOL
DiskCheckFtSetLetters(
    IN PFT_INFO FtInfo,
    IN PFULL_FTSET_INFO Bytes,
    OUT WCHAR *Letter
    );

DWORD
DiskSetFullDiskInfo(
    IN PFT_INFO FtInfo,
    IN PFULL_DISK_INFO Bytes
    );

PFULL_DISK_INFO
DiskGetFullDiskInfo(
    IN PFT_INFO FtInfo,
    IN DWORD Signature,
    OUT LPDWORD pSize
    );

enum {
   DISKRTL_REPLACE_IF_EXISTS = 0x1,
   DISKRTL_COMMIT            = 0x2,
};

DWORD
DiskAddDiskInfoEx(
    IN PFT_INFO DiskInfo,
    IN DWORD DiskIndex,
    IN DWORD Signature,
    IN DWORD Options
    );


DWORD
DiskAddDriveLetterEx(
    IN PFT_INFO DiskInfo,
    IN DWORD Signature,
    IN LARGE_INTEGER StartingOffset,
    IN LARGE_INTEGER PartitionLength,
    IN UCHAR DriveLetter,
    IN DWORD Options
    );

DWORD
DiskCommitFtInfo(
    IN PFT_INFO FtInfo
    );

PFT_INFO
DiskGetFtInfoFromFullDiskinfo(
    IN PFULL_DISK_INFO Bytes
    );

PFT_DISK_INFO
FtInfo_GetFtDiskInfoBySignature(
    IN PFT_INFO FtInfo,
    IN DWORD Signature
    );

DISK_PARTITION UNALIGNED *
FtDiskInfo_GetPartitionInfoByIndex(
    IN PFT_DISK_INFO DiskInfo,
    IN DWORD         Index
    );

DWORD
FtDiskInfo_GetPartitionCount(
    IN PFT_DISK_INFO DiskInfo
    );

//
// Error handlers to be defined by the user of this library
//
VOID
DiskErrorFatal(
    INT MessageId,
    DWORD Error,
    LPSTR File,
    DWORD Line
    );

VOID
DiskErrorLogInfo(
    LPSTR String,
    ...
    );

#ifdef __cplusplus
}
#endif

#endif // _CLUSRTL_DISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\common\svc.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    gensvc.c

Abstract:

    Resource DLL to control and monitor NT services.

Author:


    Robs 3/28/96, based on RodGa's generic resource dll

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "svc.h"
#include "localsvc.h"
#include "wincrypt.h"
#include <strsafe.h>

#define DBG_PRINT printf

typedef struct _COMMON_RESOURCE {
#ifdef COMMON_PARAMS_DEFINED
    COMMON_PARAMS   Params;
#endif
    HRESOURCE       hResource;
    HANDLE          ServiceHandle;
    RESOURCE_HANDLE ResourceHandle;
    HKEY            ResourceKey;
    HKEY            ParametersKey;
    CLUS_WORKER     PendingThread;
    BOOL            Online;
    DWORD           dwServicePid;
} COMMON_RESOURCE, * PCOMMON_RESOURCE;

//
// Global Data
//

// Handle to service controller,  set by the first create resource call.

static SC_HANDLE g_ScHandle = NULL;

// Log Event Routine

#define g_LogEvent ClusResLogEvent
#define g_SetResourceStatus ClusResSetResourceStatus

#ifdef COMMON_SEMAPHORE
static HANDLE CommonSemaphore;
static PCOMMON_RESOURCE CommonResource;
#endif

#ifndef CRYPTO_VALUE_COUNT
static DWORD  CryptoSyncCount = 0;
static LPWSTR CryptoSync[1] = {NULL};
#endif

#ifndef DOMESTIC_CRYPTO_VALUE_COUNT
static DWORD  DomesticCryptoSyncCount = 0;
static LPWSTR DomesticCryptoSync[1] = {NULL};
#endif

//
// Forward routines
//

static
DWORD
CommonOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    );

DWORD
CommonOfflineThread(
    PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    );

static
BOOL
CommonVerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag
    );


static
DWORD
SvcpTerminateServiceProcess(
    IN PCOMMON_RESOURCE pResourceEntry,
    IN BOOL     bOffline,
    OUT PDWORD  pdwResourceState
    );


#ifdef COMMON_ONLINE_THREAD
#define COMMON_ONLINE_THREAD_ROUTINE COMMON_ONLINE_THREAD
#else
#define COMMON_ONLINE_THREAD_ROUTINE CommonOnlineThread
#endif

//
// Local Routines
//


#ifndef COMMON_ONLINE_THREAD
static
DWORD
CommonOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the worker structure

    ResourceEntry - A pointer to the resource entry for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    SERVICE_STATUS_PROCESS      ServiceStatus;
    DWORD                       status = ERROR_SUCCESS;
    RESOURCE_STATUS             resourceStatus;
    DWORD                       valueSize;
    PVOID                       pvEnvironment = NULL;
    HKEY                        hkeyServicesKey;
    HKEY                        hkeyServiceName;
    DWORD                       cbBytesNeeded;
    DWORD                       prevCheckPoint = 0;
    DWORD                       idx;
    LPSERVICE_FAILURE_ACTIONS   pSvcFailureActions = NULL;
    LPQUERY_SERVICE_CONFIG      lpquerysvcconfig=NULL;
    RESOURCE_EXIT_STATE         exitState;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    if ( ResourceEntry != CommonResource ) {
        return(ERROR_SUCCESS);
    }

    //set it to NULL, when it is brought online and if the
    //service is not running in the system or lsa process
    //then store the process id for forced termination
    ResourceEntry->dwServicePid = 0;

#if ENVIRONMENT

    //
    // Create the new environment with the simulated net name when the
    // services queries GetComputerName.
    //
    pvEnvironment = ResUtilGetEnvironmentWithNetName( ResourceEntry->hResource );
    if ( pvEnvironment != NULL ) {

        WCHAR *         pszEnvString;

        //
        // Compute the size of the environment. We are looking for
        // the double NULL terminator that ends the environment block.
        //
        pszEnvString = (WCHAR *)pvEnvironment;
        while (*pszEnvString) {
            while (*pszEnvString++) {
            }
        }
        valueSize = (DWORD)((PUCHAR)pszEnvString - (PUCHAR)pvEnvironment) + sizeof(WCHAR);
    }

    //
    // Set the environment value in the service's registry key.
    //

    status = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                            LOCAL_SERVICES,
                            0,
                            KEY_READ,
                            &hkeyServicesKey );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open services key, error = %1!u!.\n",
            status );
        goto error_exit;
    }
    status = RegOpenKeyExW( hkeyServicesKey,
                            SERVICE_NAME,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hkeyServiceName );
    RegCloseKey( hkeyServicesKey );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open service key, error = %1!u!.\n",
            status );
        goto error_exit;
    }
    status = RegSetValueExW( hkeyServiceName,
                             L"Environment",
                             0,
                             REG_MULTI_SZ,
                             pvEnvironment,
                             valueSize );

    RegCloseKey( hkeyServiceName );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to set service environment value, error = %1!u!.\n",
            status );
        goto error_exit;
    }

#endif //ENVIRONMENT

    //
    // Now open the requested service
    //
    ResourceEntry->ServiceHandle = OpenService( g_ScHandle,
                                                SERVICE_NAME,
                                                SERVICE_ALL_ACCESS );

    if ( ResourceEntry->ServiceHandle == NULL ) {
        status = GetLastError();

        ClusResLogSystemEventByKeyData( ResourceEntry->ResourceKey,
                                  LOG_CRITICAL,
                                  RES_GENSVC_OPEN_FAILED,
                                  sizeof(status),
                                  &status );
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open service, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    valueSize = sizeof(QUERY_SERVICE_CONFIG);
AllocSvcConfig:
    // Query the service to make sure it is not disabled
    lpquerysvcconfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc( LMEM_FIXED, valueSize );
    if ( lpquerysvcconfig == NULL ){
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[Svc] Failed to allocate memory for query_service_config, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    
    if ( ! QueryServiceConfig(
                    ResourceEntry->ServiceHandle,
                    lpquerysvcconfig,
                    valueSize,
                    &cbBytesNeeded ) )
    {
        status=GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER){
            (g_LogEvent)(
                 ResourceEntry->ResourceHandle,
                 LOG_ERROR,
                 L"svc: Failed to query service configuration, error= %1!u!.\n",
                 status );
            goto error_exit;
         }
        
        status=ERROR_SUCCESS; 
        LocalFree( lpquerysvcconfig );
        lpquerysvcconfig=NULL;
        valueSize = cbBytesNeeded;
        goto AllocSvcConfig;
    }
        
    if ( lpquerysvcconfig->dwStartType == SERVICE_DISABLED )
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"svc:The service is DISABLED\n");
        status=ERROR_SERVICE_DISABLED;
        goto error_exit;
    }

    //
    // Make sure service is set to manual start.
    //
    ChangeServiceConfig( ResourceEntry->ServiceHandle,
                         SERVICE_NO_CHANGE,
                         SERVICE_DEMAND_START, // Manual start
                         SERVICE_NO_CHANGE,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL );


    // Use valuesize as the dummy buffer since the queryserviceconfig2
    // api is not that friendly.
    // If any of the service action is set to service restart, set it to
    // none
    if ( ! (QueryServiceConfig2(
                    ResourceEntry->ServiceHandle,
                    SERVICE_CONFIG_FAILURE_ACTIONS,
                    (LPBYTE)&valueSize,
                    sizeof(DWORD),
                    &cbBytesNeeded )) )
    {
        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER )
        {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"svc: Failed to query service configuration for size, error= %1!u!.\n",
                status );
            goto error_exit;
        }
        else
            status = ERROR_SUCCESS;
    }

    pSvcFailureActions = (LPSERVICE_FAILURE_ACTIONS)LocalAlloc( LMEM_FIXED, cbBytesNeeded );

    if ( pSvcFailureActions == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate memory of size %1!u!, error = %2!u!.\n",
            cbBytesNeeded,
            status );
        goto error_exit;
    }

    if ( ! (QueryServiceConfig2(
                    ResourceEntry->ServiceHandle,
                    SERVICE_CONFIG_FAILURE_ACTIONS,
                    (LPBYTE)pSvcFailureActions,
                    cbBytesNeeded,
                    &cbBytesNeeded )) )
    {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"svc:Failed to query service configuration, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    for ( idx=0; idx < pSvcFailureActions->cActions; idx++ )
    {
        if ( pSvcFailureActions->lpsaActions[idx].Type == SC_ACTION_RESTART ) {
            pSvcFailureActions->lpsaActions[idx].Type = SC_ACTION_NONE;
        }
    }
    ChangeServiceConfig2(
            ResourceEntry->ServiceHandle,
            SERVICE_CONFIG_FAILURE_ACTIONS,
            pSvcFailureActions );

#ifdef COMMON_ONLINE_THREAD_CALLBACK
    //
    // Allow the resource DLL to perform some operations before the service
    // is started, such as setting registry keys, etc.
    //
    status = CommonOnlineThreadCallback( ResourceEntry );
    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }
#endif // COMMON_ONLINE_THREAD_CALLBACK

    if ( ! StartServiceW(
                    ResourceEntry->ServiceHandle,
                    0,
                    NULL ) ) {

        status = GetLastError();

        if (status != ERROR_SERVICE_ALREADY_RUNNING) {

            ClusResLogSystemEventByKeyData( ResourceEntry->ResourceKey,
                                      LOG_CRITICAL,
                                      RES_GENSVC_START_FAILED,
                                      sizeof(status),
                                      &status );
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Failed to start %1!ws! service. Error: %2!u!.\n",
                         SERVICE_NAME,
                         status );
            goto error_exit;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    resourceStatus.ResourceState = ClusterResourceOnlinePending;
    while ( ! ClusWorkerCheckTerminate( &ResourceEntry->PendingThread ) )  {
        if ( ! QueryServiceStatusEx(
                    ResourceEntry->ServiceHandle,
                    SC_STATUS_PROCESS_INFO,
                    (LPBYTE)&ServiceStatus, 
                    sizeof(SERVICE_STATUS_PROCESS),
                    &cbBytesNeeded ) ) {
            
            status = GetLastError();

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Query Service Status failed %1!u!.\n",
                status );
            resourceStatus.ResourceState = ClusterResourceFailed;
            goto error_exit;
        }

        if ( ServiceStatus.dwCurrentState != SERVICE_START_PENDING ) {
            break;
        }
        if ( prevCheckPoint != ServiceStatus.dwCheckPoint ) {
            prevCheckPoint = ServiceStatus.dwCheckPoint;
            ++resourceStatus.CheckPoint;
        }
        exitState = (g_SetResourceStatus)(
                            ResourceEntry->ResourceHandle,
                            &resourceStatus );
        if ( exitState == ResourceExitStateTerminate ) {
            break;
        }

        Sleep( 500 );     // Sleep for 1/2 second
    }

    //
    // Assume that we failed.
    //
    resourceStatus.ResourceState = ClusterResourceFailed;

    //
    // If we exited the loop before setting ServiceStatus, then return now.
    //
    if ( ClusWorkerCheckTerminate( &ResourceEntry->PendingThread ) )  {
        goto error_exit;
    }

    if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING ) {
        
        if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
            status = ServiceStatus.dwServiceSpecificExitCode;
        } else {
            status = ServiceStatus.dwWin32ExitCode;
        }

        ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                 LOG_CRITICAL,
                                 RES_GENSVC_FAILED_AFTER_START,
                                 sizeof(status),
                                 &status);
        (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Service failed during initialization. Error: %1!u!.\n",
                status );

        goto error_exit;
    }

    resourceStatus.ResourceState = ClusterResourceOnline;
    if ( ! (ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS) ) {
        ResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
    }

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Service is now on line.\n" );

error_exit:

    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }

    if(lpquerysvcconfig)
        LocalFree(lpquerysvcconfig);
    if (pSvcFailureActions) 
        LocalFree(pSvcFailureActions);

#if ENVIRONMENT

    if ( pvEnvironment != NULL ) {
        RtlDestroyEnvironment( pvEnvironment );
    }

#endif

    return(status);

} // CommonOnlineThread
#endif


static
RESID
WINAPI
CommonOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for generic service resource.
    This routine gets a handle to the service controller, if we don't already have one,
    and then gets a handle to the specified service.  The service handle is saved
    in the COMMON structure.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    RESID   svcResid = 0;
    DWORD   status;
    HKEY    parametersKey = NULL;
    HKEY    resKey = NULL;
    PCOMMON_RESOURCE resourceEntry = NULL;
    DWORD   paramNameSize = 0;
    DWORD   paramNameMaxSize = 0;
    HCLUSTER hCluster;
    DWORD   returnSize;
    DWORD   idx;

    //
    // Open registry parameters key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                L"Parameters",
                                KEY_READ,
                                &parametersKey );

    if ( status != NO_ERROR ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key. Error: %1!u!.\n",
            status);
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey );
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // First get a handle to the service controller.
    //

    if ( g_ScHandle == NULL ) {

        g_ScHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS);

        if ( g_ScHandle == NULL ) {
            status = GetLastError();
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to open service control manager, error = %1!u!.\n",
                status);
            goto error_exit;
        }
    }

    resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(COMMON_RESOURCE) );

    if ( resourceEntry == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a service info structure.\n");
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( resourceEntry, sizeof(COMMON_RESOURCE) );

    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;

    hCluster = OpenCluster(NULL);
    if ( hCluster == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open cluster, error %1!u!.\n",
            status );
        goto error_exit;
    }
    resourceEntry->hResource = OpenClusterResource( hCluster, ResourceName );
    status = GetLastError();
    CloseCluster( hCluster );
    if ( resourceEntry->hResource == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open resource, error %1!u!.\n",
            status );
        goto error_exit;
    }

    //
    // Set any registry checkpoints that we need.
    //
    if ( RegSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < RegSyncCount; idx++ ) {
            status = ClusterResourceControl( resourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                                             RegSync[idx],
                                             (lstrlenW( RegSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if ( status == ERROR_ALREADY_EXISTS ){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to set registry checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set any crypto checkpoints that we need.
    //
    if ( CryptoSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < CryptoSyncCount; idx++ ) {
            status = ClusterResourceControl( resourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                             CryptoSync[idx],
                                             (lstrlenW( CryptoSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if (status == ERROR_ALREADY_EXISTS){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to set crypto checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set any domestic crypto checkpoints that we need.
    //
    if ( DomesticCryptoSyncCount != 0 ) {
        HCRYPTPROV hProv = 0;
        //
        // check if domestic crypto is available
        //
        if (CryptAcquireContextA( &hProv,
                                  NULL,
                                  MS_ENHANCED_PROV_A,
                                  PROV_RSA_FULL,
                                  CRYPT_VERIFYCONTEXT)) {
            CryptReleaseContext( hProv, 0 );
            returnSize = 0;
            //
            // Set registry sync keys if we need them.
            //
            for ( idx = 0; idx < DomesticCryptoSyncCount; idx++ ) {
                status = ClusterResourceControl( resourceEntry->hResource,
                                                 NULL,
                                                 CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                                 DomesticCryptoSync[idx],
                                                 (lstrlenW( DomesticCryptoSync[idx] ) + 1) * sizeof(WCHAR),
                                                 NULL,
                                                 0,
                                                 &returnSize );
                if ( status != ERROR_SUCCESS ){
                    if (status == ERROR_ALREADY_EXISTS){
                        status = ERROR_SUCCESS;
                    }
                    else{
                        (g_LogEvent)(
                            resourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"Failed to set domestic crypto checkpoint, status %1!u!.\n",
                            status );
                        goto error_exit;
                    }
                }
            }
        }
    }
#ifdef COMMON_PARAMS_DEFINED
    //
    // Get any parameters... so we can handle the GET_DEPENDENCIES request.
    //
    CommonReadParameters( resourceEntry );
    // ignore status return
#endif // COMMON_PARAMS_DEFINED

#ifdef COMMON_SEMAPHORE
    //
    // Check if more than one resource of this type.
    //
    if ( WaitForSingleObject( CommonSemaphore, 0 ) == WAIT_TIMEOUT ) {
        //
        // A version of this service is already running
        //
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Service is already running.\n");
        status = ERROR_SERVICE_ALREADY_RUNNING;
        goto error_exit;
    }

    if ( CommonResource ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Service resource info non-null!\n");
        status = ERROR_DUPLICATE_SERVICE_NAME;
        goto error_exit;
    }

    CommonResource = resourceEntry;

#endif // COMMON_SEMAPHORE

    svcResid = (RESID)resourceEntry;
    return(svcResid);

error_exit:

    LocalFree( resourceEntry );

    if ( parametersKey != NULL ) {
        ClusterRegCloseKey( parametersKey );
    }
    if ( resKey != NULL) {
        ClusterRegCloseKey( resKey );
    }

    SetLastError( status );

    return((RESID)NULL);

} // CommonOpen


static
DWORD
WINAPI
CommonOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Common Service resource.

Arguments:

    ResourceId - Supplies resource id to be brought online

    EventHandle - Supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    DWORD   status;
    PCOMMON_RESOURCE resourceEntry;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry != CommonResource ) {
        DBG_PRINT( "Common: Online request for wrong resource, 0x%p.\n",
                    ResourceId );
    }

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Online request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               COMMON_ONLINE_THREAD_ROUTINE,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // CommonOnline


static
VOID
WINAPI
CommonTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for Common Service resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    SERVICE_STATUS      ServiceStatus;
    PCOMMON_RESOURCE    resourceEntry;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry != CommonResource ) {
        DBG_PRINT( "Common: Offline request for wrong resource, 0x%p.\n",
                    ResourceId );
        return;
    }

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Offline request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
       resourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"Offline request.\n" );

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    if ( resourceEntry->ServiceHandle != NULL ) {

        DWORD retryTime = 30*1000;  // wait 30 secs for shutdown
        DWORD retryTick = 300;      // 300 msec at a time
        DWORD status;
        BOOL  didStop = FALSE;

        for (;;) {

            status = (ControlService(
                            resourceEntry->ServiceHandle,
                            (didStop
                             ? SERVICE_CONTROL_INTERROGATE
                             : SERVICE_CONTROL_STOP),
                            &ServiceStatus )
                      ? NO_ERROR
                      : GetLastError());

            if (status == NO_ERROR) {

                didStop = TRUE;

                if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"Service stopped.\n" );
                    //set the status                                    
                    resourceEntry->Online = FALSE;
                    resourceEntry->dwServicePid = 0;
                    break;
                }
            }

            //
            // Chittur Subbaraman (chitturs) - 2/21/2000
            //
            // Since SCM doesn't accept any control requests during
            // windows shutdown, don't send any more control
            // requests. Just exit from this loop and terminate
            // the process brute force.
            //
            if (status == ERROR_SHUTDOWN_IN_PROGRESS)
			{
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"System shutdown in progress. Will try to terminate the process...\n");
                break;
            }

            if (status == ERROR_EXCEPTION_IN_SERVICE ||
                status == ERROR_PROCESS_ABORTED ||
                status == ERROR_SERVICE_NOT_ACTIVE) {

                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service died; status = %1!u!.\n",
                    status);
                //set the status                                    
                resourceEntry->Online = FALSE;
                resourceEntry->dwServicePid = 0;
                break;

            }

            if ((retryTime -= retryTick) <= 0) {

                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Service did not stop; giving up.\n" );

                break;
            }

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Offline: retrying...\n" );

            Sleep(retryTick);
        }

        //if there is a pid for this, try and terminate that process
        //note that terminating a process doesnt terminate all
        //the child processes
        if (resourceEntry->dwServicePid)
        {
            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"SvcTerminate: terminating processid =%1!u!\n",
                resourceEntry->dwServicePid);
            SvcpTerminateServiceProcess( resourceEntry,
                                         FALSE,
                                         NULL );
        }                
        CloseServiceHandle( resourceEntry->ServiceHandle );
        resourceEntry->ServiceHandle = NULL;
        resourceEntry->dwServicePid = 0;
    }

    resourceEntry->Online = FALSE;

} // CommonTerminate

static
DWORD
WINAPI
CommonOffline(
    IN RESID ResourceId
    )
/*++

Routine Description:

    Offline routine for Common Service resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/
{
    PCOMMON_RESOURCE resourceEntry;
    DWORD            status;


    resourceEntry = (PCOMMON_RESOURCE)ResourceId;
    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Offline request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry != CommonResource ) {
        DBG_PRINT( "Common: Offline request for wrong resource, 0x%p.\n",
                    ResourceId );
        return(ERROR_INVALID_PARAMETER);
    }

    (g_LogEvent)(
       resourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"Offline request.\n" );

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               CommonOfflineThread,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);
}



static
DWORD
CommonOfflineThread(
    PCLUS_WORKER pWorker,
    IN PCOMMON_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Offline routine for Common Service resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/
{
    RESOURCE_STATUS resourceStatus;
    DWORD           retryTick = 300;      // 300 msec at a time
    DWORD           status = ERROR_SUCCESS;
    BOOL            didStop = FALSE;
    SERVICE_STATUS  ServiceStatus;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    //check if the service has gone offline or was never brought online
    if ( ResourceEntry->ServiceHandle == NULL )
    {
        resourceStatus.ResourceState = ClusterResourceOffline;
        goto FnExit;
    }

    //try to stop the cluster service, wait for it to be terminated
    //as long as we are not asked to terminate
    while (!ClusWorkerCheckTerminate(pWorker)) {


        status = (ControlService(
                        ResourceEntry->ServiceHandle,
                        (didStop
                         ? SERVICE_CONTROL_INTERROGATE
                         : SERVICE_CONTROL_STOP),
                        &ServiceStatus )
                  ? NO_ERROR
                  : GetLastError());

        if (status == NO_ERROR) {

            didStop = TRUE;

            if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service stopped.\n" );

                //set the status                                    
                ResourceEntry->Online = FALSE;
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service is now offline.\n" );
                break;
            }
        }

        //
        // Chittur Subbaraman (chitturs) - 2/21/2000
        //
        // Since SCM doesn't accept any control requests during
        // windows shutdown, don't send any more control
        // requests. Just exit from this loop and terminate
        // the process brute force.
        //
        if (status == ERROR_SHUTDOWN_IN_PROGRESS)
        {
            DWORD   dwResourceState;
 
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: System shutting down. Attempt to terminate service process %1!u!...\n",
                ResourceEntry->dwServicePid );

            status = SvcpTerminateServiceProcess( ResourceEntry,
                                                  TRUE,
                                                  &dwResourceState );

            if ( status == ERROR_SUCCESS )
            {
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                ResourceEntry->Online = FALSE;
            }
            resourceStatus.ResourceState = dwResourceState;
            break;
        }

        if (status == ERROR_EXCEPTION_IN_SERVICE ||
            status == ERROR_PROCESS_ABORTED ||
            status == ERROR_SERVICE_NOT_ACTIVE) {

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service died or not active any more; status = %1!u!.\n",
                status);
                
            //set the status                                    
            ResourceEntry->Online = FALSE;
            resourceStatus.ResourceState = ClusterResourceOffline;
            CloseServiceHandle( ResourceEntry->ServiceHandle );
            ResourceEntry->ServiceHandle = NULL;
            ResourceEntry->dwServicePid = 0;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service is now offline.\n" );
            break;

        }

        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Offline: retrying...\n" );

        Sleep(retryTick);
    }


FnExit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return(status);

}
// CommonOfflineThread


static
BOOL
WINAPI
CommonIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Common service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - if service is running

    FALSE - if service is in any other state

--*/
{

    return( CommonVerifyService( ResourceId, TRUE ) );

} // CommonIsAlive



static
BOOL
CommonVerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag)

/*++

Routine Description:

        Verify that a specified service is running

Arguments:

        ResourceId - Supplies the resource id
        IsAliveFlag - Says this is an IsAlive call - used only for debug print

Return Value:

        TRUE - if service is running or starting

        FALSE - service is in any other state

--*/
{
    SERVICE_STATUS ServiceStatus;
    PCOMMON_RESOURCE resourceEntry;
    DWORD   status = TRUE;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry != CommonResource ) {
        DBG_PRINT( "Common: IsAlive request for wrong resource 0x%p.\n",
                   ResourceId );
        return(FALSE);
    }

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: IsAlive request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(FALSE);
    }

    if ( !QueryServiceStatus( resourceEntry->ServiceHandle,
                              &ServiceStatus ) ) {

         (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Query Service Status failed %1!u!.\n",
            GetLastError() );
         return(FALSE);
    }

//
//  Now check the status of the service
//

  if ((ServiceStatus.dwCurrentState != SERVICE_RUNNING)&&(ServiceStatus.dwCurrentState != SERVICE_START_PENDING)){
      status = FALSE;
   }
   if (!status) {
       (g_LogEvent)(
          resourceEntry->ResourceHandle,
          LOG_ERROR,
          L"Failed the IsAlive test. Current State is %1!u!.\n",
          ServiceStatus.dwCurrentState );
   }
    return(status);

} // Verify Service


static
BOOL
WINAPI
CommonLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Common Service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    return( CommonVerifyService( ResourceId, FALSE ) );

} // CommonLooksAlive



static
VOID
WINAPI
CommonClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Common Services resource.
    This routine will stop the service, and delete the cluster
    information regarding that service.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PCOMMON_RESOURCE resourceEntry;
    DWORD   errorCode;

    resourceEntry = (PCOMMON_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "Common: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );

    //
    // Shut it down if it's on line
    //

    CommonTerminate( ResourceId );
    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );

#ifdef COMMON_SEMAPHORE
    if ( resourceEntry == CommonResource ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Setting Semaphore %1!ws!.\n",
            COMMON_SEMAPHORE );
        CommonResource = NULL;
        ReleaseSemaphore( CommonSemaphore, 1 , NULL );
    }
#endif

    LocalFree( resourceEntry );

} // CommonClose



static
DWORD
SvcpTerminateServiceProcess(
    IN PCOMMON_RESOURCE pResourceEntry,
    IN BOOL     bOffline,
    OUT PDWORD  pdwResourceState
    )

/*++

Routine Description:

    Attempts to terminate a service process.

Arguments:

    pResourceEntry - Gensvc resource structure.

    bOffline - Called from the offline thread or not.

    pdwResourceState - State of the gensvc resource.

Return Value:

    ERROR_SUCCESS - The termination was successful.

    Win32 error - Otherwise.

--*/

{
    HANDLE  hSvcProcess = NULL;
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOLEAN bWasEnabled;
    DWORD   dwResourceState = ClusterResourceFailed;

    //
    //  Chittur Subbaraman (chitturs) - 2/23/2000
    //
    (g_LogEvent)(
        pResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SvcpTerminateServiceProcess: Process with id=%1!u! might be terminated...\n",
        pResourceEntry->dwServicePid );

    //
    //  Adjust the privilege to allow debug. This is to allow
    //  termination of a service process which runs in a local 
    //  system account from a different service process which runs in a 
    //  domain user account.
    //
    dwStatus = ClRtlEnableThreadPrivilege( SE_DEBUG_PRIVILEGE,
                                           &bWasEnabled );

    if ( dwStatus != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SvcpTerminateServiceProcess: Unable to set debug privilege for process with id=%1!u!, status=%2!u!...\n",
            pResourceEntry->dwServicePid,
            dwStatus );
        goto FnExit;
    }
                
    hSvcProcess = OpenProcess( PROCESS_TERMINATE, 
                               FALSE, 
                               pResourceEntry->dwServicePid );
				                           
    if ( !hSvcProcess ) 
    {
        //
        //  Did this happen because the process terminated
        //  too quickly after we sent out one control request ?
        //
        dwStatus = GetLastError();
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SvcpTerminateServiceProcess: Unable to open pid=%1!u! for termination, status=%2!u!...\n",
            pResourceEntry->dwServicePid,
            dwStatus );
        goto FnRestoreAndExit;
    }

    if ( !bOffline )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SvcpTerminateServiceProcess: Pid=%1!u! will be terminated brute force...\n",
            pResourceEntry->dwServicePid );
        goto skip_waiting;
    }
    
    if ( WaitForSingleObject( hSvcProcess, 3000 ) 
               == WAIT_OBJECT_0 )
    {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"SvcpTerminateServiceProcess: Process with id=%1!u! shutdown gracefully...\n",
            pResourceEntry->dwServicePid );
        dwResourceState = ClusterResourceOffline;
        dwStatus = ERROR_SUCCESS;
        goto FnRestoreAndExit;
    }

skip_waiting:
    if ( !TerminateProcess( hSvcProcess, 0 ) ) 
    {
        dwStatus = GetLastError();
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SvcpTerminateServiceProcess: Unable to terminate process with id=%1!u!, status=%2!u!...\n",
            pResourceEntry->dwServicePid,
            dwStatus );
        goto FnRestoreAndExit;
    } 

    dwResourceState = ClusterResourceOffline;

FnRestoreAndExit:
    ClRtlRestoreThreadPrivilege( SE_DEBUG_PRIVILEGE,
                                 bWasEnabled );

FnExit:
    if ( hSvcProcess )
    {
        CloseHandle( hSvcProcess );
    }
       
    if ( ARGUMENT_PRESENT( pdwResourceState ) )
    {
        *pdwResourceState = dwResourceState;
    }

    (g_LogEvent)(
        pResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SvcpTerminateServiceProcess: Process id=%1!u!, status=%2!u!, state=%3!u!...\n",
        pResourceEntry->dwServicePid,
        dwStatus,
        dwResourceState );
    
    return( dwStatus );
} // SvcpTerminateServiceProcess


#ifdef COMMON_CONTROL

static
DWORD
CommonGetRequiredDependencies(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control function
    for common service resources.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    PCOMMON_DEPEND_SETUP pdepsetup = CommonDependSetup;
    PCOMMON_DEPEND_DATA pdepdata = (PCOMMON_DEPEND_DATA)OutBuffer;
    CLUSPROP_BUFFER_HELPER value;
    DWORD       status;
    
    *BytesReturned = sizeof(COMMON_DEPEND_DATA);
    if ( OutBufferSize < sizeof(COMMON_DEPEND_DATA) ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        ZeroMemory( OutBuffer, sizeof(COMMON_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 ) {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat ) {

            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_ULARGE_INTEGER:
                value.pULargeIntegerValue->li.LowPart = 
                    (DWORD)((DWORD_PTR)pdepsetup->Value);
                break;

            case CLUSPROP_FORMAT_SZ:
            case CLUSPROP_FORMAT_EXPAND_SZ:
            case CLUSPROP_FORMAT_MULTI_SZ:
            case CLUSPROP_FORMAT_BINARY:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
        status = ERROR_SUCCESS;
    }

    return(status);

} // CommonGetRequiredDependencies



static
DWORD
CommonGetRegistryCheckpoints(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS control function
    for common service resources.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       i;
    DWORD       totalBufferLength = 0;
    LPWSTR      psz = OutBuffer;
    DWORD       remainSize;

    // Build a Multi-sz string.

    //
    // Calculate total buffer length needed.
    //
    for ( i = 0; i < RegSyncCount; i++ ) {
        totalBufferLength += (lstrlenW( RegSync[i] ) + 1) * sizeof(WCHAR);
    }

    if ( !totalBufferLength ) {
        *BytesReturned = 0;
        return(ERROR_SUCCESS);
    }

    totalBufferLength += sizeof(UNICODE_NULL);

    *BytesReturned = totalBufferLength;

    if ( OutBufferSize < totalBufferLength ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        //ZeroMemory( OutBuffer, totalBufferLength );

        remainSize = (OutBufferSize / sizeof(WCHAR));
        for ( i = 0; i < RegSyncCount; i++ ) {
            status = StringCchCopyW( psz, remainSize, RegSync[i] );
            if ( status != S_OK ) {
                return(HRESULT_CODE(status)); // should never get here!
            }
            psz += (lstrlenW( RegSync[i] ) + 1);
            remainSize -= (lstrlenW( RegSync[i] ) + 1);
        }

        *psz = L'\0';
        status = ERROR_SUCCESS;
    }

    return(status);

} // CommonGetRegistryCheckpoints



static
DWORD
CommonGetCryptoCheckpoints(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS control function
    for common service resources.

Arguments:

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_MORE_DATA - The output buffer is too small to return the data.
        BytesReturned contains the required size.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;
    DWORD       i;
    DWORD       totalBufferLength = 0;
    LPWSTR      psz = OutBuffer;
    DWORD       remainSize;

    // Build a Multi-sz string.

    //
    // Calculate total buffer length needed.
    //
    for ( i = 0; i < CryptoSyncCount; i++ ) {
        totalBufferLength += (lstrlenW( CryptoSync[i] ) + 1) * sizeof(WCHAR);
    }

    if ( !totalBufferLength ) {
        *BytesReturned = 0;
        return(ERROR_SUCCESS);
    }

    totalBufferLength += sizeof(UNICODE_NULL);

    *BytesReturned = totalBufferLength;

    if ( OutBufferSize < totalBufferLength ) {
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        //ZeroMemory( OutBuffer, totalBufferLength );

        remainSize = (OutBufferSize / sizeof(WCHAR));
        for ( i = 0; i < CryptoSyncCount; i++ ) {
            status = StringCchCopyW( psz, remainSize, CryptoSync[i] );
            if ( status != S_OK ) {
                return(HRESULT_CODE(status)); // should never get here!
            }
            psz += (lstrlenW( CryptoSync[i] ) + 1);
            remainSize -= (lstrlenW( CryptoSync[i] ) + 1);
        }

        *psz = L'\0';
        status = ERROR_SUCCESS;
    }

    return(status);

} // CommonGetCryptoCheckpoints



static
DWORD
WINAPI
CommonResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Common Virtual Root resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    PCOMMON_RESOURCE  resourceEntry = NULL;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = CommonGetRequiredDependencies( OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned
                                                    );
            break;

        case CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS:
            status = CommonGetRegistryCheckpoints( OutBuffer,
                                                   OutBufferSize,
                                                   BytesReturned
                                                   );
            break;

        case CLUSCTL_RESOURCE_GET_CRYPTO_CHECKPOINTS:
            status = CommonGetCryptoCheckpoints( OutBuffer,
                                                 OutBufferSize,
                                                 BytesReturned
                                                 );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // CommonResourceControl



static
DWORD
WINAPI
CommonResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Common Virtual Root resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD       status;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = CommonGetRequiredDependencies( OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned
                                                    );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REGISTRY_CHECKPOINTS:
            status = CommonGetRegistryCheckpoints( OutBuffer,
                                                   OutBufferSize,
                                                   BytesReturned
                                                   );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CRYPTO_CHECKPOINTS:
            status = CommonGetCryptoCheckpoints( OutBuffer,
                                                   OutBufferSize,
                                                   BytesReturned
                                                   );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // CommonResourceTypeControl

#endif // COMMON_CONTROL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\diskinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    diskinfo.cpp

Abstract:

    Routines that query and manipulate the
    disk configuration of the current system.

Author:

    John Vert (jvert) 10/10/1996

Revision History:

--*/
#include "diskinfo.h"
#include <ntddvol.h>
#include <devguid.h>
#include <setupapi.h>
#include "clusrtl.h"
#include <strsafe.h>    // Should be included last.

/*

NT5 porting notes - Charlie Wickham (2/10/98)

I tried to touch as little of this as possible since there is alot of code
here. Two major differences on NT5 are: 1) the System\Disk key is no longer
used as the central "database" of disk configuration information and 2) all
drive letters are sticky on NT5.

NT5 Clusters still needs a central point of information (such as DISK key)
since the joining node cannot determine anything about the disk configuration
when the disks are reserved by the sponsor.

Later... (3/29/99)

Much has changed since I wrote the first blurb above a year ago. This code has
been patched to keep up with the changes with slight improvements made due to
the ever changing NT5 landscape with regard to supported storage types.

*/

#if 1
#define DISKERR(_MsgId_, _Err_) (DiskErrorFatal((0),(_Err_),__FILE__, __LINE__))
#define DISKLOG(_x_) DiskErrorLogInfo _x_
#define DISKASSERT(_x_) if (!(_x_)) DISKERR(IDS_GENERAL_FAILURE,ERROR_INVALID_PARAMETER)
#else
#define DISKERR(x,y)
#define DISKLOG(_x_)
#define DISKASSERT(_x_)
#endif

//
// array that maps disk and partition numbers to drive letters. This
// facilitates figuring out which drive letters are associated with a drive
// and reduces the amount of calls to CreateFile dramatically. The array is
// indexed by drive letter.
//
DRIVE_LETTER_INFO DriveLetterMap[26];

//
// Some handy registry utility routines
//
BOOL
GetRegValue(
    IN HKEY hKey,
    IN LPCWSTR Name,
    OUT LPBYTE *Value,
    OUT LPDWORD Length
    )
{
    LPBYTE Data = NULL;
    DWORD cbData=0;
    LONG Status;

    //
    // Call once to find the required size.
    //
    Status = RegQueryValueExW(hKey,
                              Name,
                              NULL,
                              NULL,
                              NULL,
                              &cbData);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(FALSE);
    }

    //
    // Allocate the buffer and call again to get the data.
    //
retry:
    Data = (LPBYTE)LocalAlloc(LMEM_FIXED, cbData);;
    if (!Data) {
        Status = GetLastError();
        DISKERR(IDS_MEMORY_FAILURE, Status);
        return FALSE;
    }
    Status = RegQueryValueExW(hKey,
                              Name,
                              NULL,
                              NULL,
                              Data,
                              &cbData);
    if (Status == ERROR_MORE_DATA) {
        LocalFree(Data);
        goto retry;
    }
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        DISKERR(IDS_REGISTRY_FAILURE, Status);
        return FALSE;
    }
    *Value = Data;
    *Length = cbData;
    return(TRUE);
}

BOOL
MapDosVolumeToPhysicalPartition(
    CString DosVolume,
    PDRIVE_LETTER_INFO DriveInfo
    )

/*++

Routine Description:

    For a given dos volume (with the object space cruft in front of
    it), build a string that reflects the drive and partition numbers
    to which it is mapped.

Arguments:

    DosVolume - pointer to "\??\C:" style name

    DeviceInfo - pointer to buffer to receive device info data

Return Value:

    TRUE if completed successfully

--*/

{
    BOOL success = TRUE;
    HANDLE hVol;
    DWORD dwSize;
    DWORD Status;
    UINT driveType;

    DriveInfo->DriveType = GetDriveType( DosVolume );
    DISKLOG(("%ws drive type = %u\n", DosVolume, DriveInfo->DriveType ));

    if ( DriveInfo->DriveType == DRIVE_FIXED ) {
        WCHAR ntDosVolume[7] = L"\\\\.\\A:";

        ntDosVolume[4] = DosVolume[0];

        //
        // get handle to partition
        //
        hVol = CreateFile(ntDosVolume,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

        if (hVol == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        //
        // issue storage class ioctl to get drive and partition numbers
        // for this device
        //
        success = DeviceIoControl(hVol,
                                  IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                  NULL,
                                  0,
                                  &DriveInfo->DeviceNumber,
                                  sizeof( DriveInfo->DeviceNumber ),
                                  &dwSize,
                                  NULL);

        if ( !success ) {
            DISK_EXTENT diskExtent;

            success = DeviceIoControl(hVol,
                                      IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                      NULL,
                                      0,
                                      &diskExtent,
                                      sizeof( diskExtent ),
                                      &dwSize,
                                      NULL);

            if ( success ) {
                DriveInfo->DeviceNumber.DeviceType = FILE_DEVICE_DISK;
                DriveInfo->DeviceNumber.DeviceNumber = diskExtent.DiskNumber;
                DriveInfo->DeviceNumber.PartitionNumber = 0;
            }
        }

        CloseHandle( hVol );
    }

    return success;
}

CDiskConfig::~CDiskConfig()

/*++

Description:

    Destructor for CDiskConfig. Run down the list of disks selected for
    cluster control and remove them from the DiskConfig database

Arguments:

    None
Return Value:

    None

--*/

{
    CPhysicalDisk *PhysicalDisk;
    int   diskIndex;
	POSITION pos;
	for(pos = m_PhysicalDisks.GetStartPosition(); pos;){
	    m_PhysicalDisks.GetNextAssoc(pos, diskIndex, PhysicalDisk);
		RemoveDisk(PhysicalDisk);
	}
}



BOOL
CDiskConfig::Initialize(
    VOID
    )
/*++

Routine Description:

    Build up a disk config database by poking all available disks
    on the system.

Arguments:

    None

Return Value:

    True if everything worked ok

--*/

{
    WCHAR System[3];
    DWORD Status;
    POSITION DiskPos;
    DWORD index;
    CFtInfoFtSet *FtSet;
    HDEVINFO setupDiskInfo;
    GUID diskDriveGuid = DiskClassGuid;
    CPhysicalDisk * PhysicalDisk;

    //
    // enum the disks through the SetupDi APIs and create physical disk
    // objects for them
    //
    setupDiskInfo = SetupDiGetClassDevs(&diskDriveGuid,
                                        NULL,
                                        NULL,
                                        DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (setupDiskInfo != INVALID_HANDLE_VALUE ) {
        SP_DEVICE_INTERFACE_DATA interfaceData;
        GUID classGuid = DiskClassGuid;
        BOOL success;
        PSP_DEVICE_INTERFACE_DETAIL_DATA detailData;
        DWORD detailDataSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + MAX_PATH * sizeof(WCHAR);
        DWORD requiredSize;

        detailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LMEM_FIXED,
                                                                  detailDataSize);

        if ( detailData != NULL ) {
            detailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
            interfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

            for (index = 0; ; ++index ) {
                success = SetupDiEnumDeviceInterfaces(
                              setupDiskInfo,
                              NULL,
                              &diskDriveGuid,
                              index,
                              &interfaceData);

                if ( success ) {
                    success = SetupDiGetDeviceInterfaceDetail(
                                  setupDiskInfo,
                                  &interfaceData,
                                  detailData,
                                  detailDataSize,
                                  &requiredSize,
                                  NULL);

                    if ( success ) {
                        PhysicalDisk = new CPhysicalDisk;
                        if (PhysicalDisk == NULL) {
                            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                            break;
                        }

                        DISKLOG(("Initializing disk %ws\n", detailData->DevicePath));
                        Status = PhysicalDisk->Initialize(&m_FTInfo, detailData->DevicePath);
                        if (Status != ERROR_SUCCESS) {
                            DISKLOG(("Problem init'ing disk, status = %u\n", Status));
                            delete PhysicalDisk;
                            break;
                        }

                        //
                        // Ignore disks with no partitions.
                        //
                        if (PhysicalDisk->m_PartitionCount == 0) {
                            DISKLOG(("Partition count is zero on disk %ws\n",
                                     detailData->DevicePath));
                            delete PhysicalDisk;
                        } else {
                            DISKLOG(("Drive number = %u\n", PhysicalDisk->m_DiskNumber));
                            m_PhysicalDisks[PhysicalDisk->m_DiskNumber] = PhysicalDisk;
                        }
                    } else {
                        Status = GetLastError();
                        DISKLOG(("Couldn't get detail data, status %u\n",
                                 GetLastError()));
                    }
                } else {
                    Status = GetLastError();
                    if ( Status != ERROR_NO_MORE_ITEMS ) {
                        DISKLOG(("Couldn't enum dev IF #%u - %u\n",
                                 index, Status ));
                    }
                    break;
                }
            }
            LocalFree( detailData );
        } else {
            DISKLOG(("Couldn't get memory for detail data\n"));
            SetupDiDestroyDeviceInfoList( setupDiskInfo );
            return FALSE;
        }

        SetupDiDestroyDeviceInfoList( setupDiskInfo );
    } else {
        DISKLOG(("Couldn't get ptr to device info - %u\n", GetLastError()));
        return FALSE;
    }

    //
    // Enumerate all the FT sets in the DISK registry. Add each FT set
    // that does not share a disk with any other FT set to our list.
    //
    for (index=0; ; index++) {
        CFtSet *NewSet;
        FtSet = m_FTInfo.EnumFtSetInfo(index);
        if (FtSet == NULL) {
            break;
        }
        if (FtSet->IsAlone()) {
            NewSet = new CFtSet;
            if (NewSet == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }

            DISKLOG(("Initializing FTSet %u\n", index));
            if (NewSet->Initialize(this, FtSet)) {
                m_FtSetList.AddTail(NewSet);
            } else {
                DISKLOG(("Error initializing FTSet %u\n", index));
                delete NewSet;
            }
        }
    }

    //
    // get the disk/parition numbers for all defined drive letters
    //

    DWORD DriveMap = GetLogicalDrives();
    DWORD Letter = 0;
    WCHAR DosVolume[4] = L"A:\\";

    DISKLOG(("Getting Drive Letter mappings\n"));
    while (DriveMap) {
        if ( DriveMap & 1 ) {
            DosVolume[0] = (WCHAR)(Letter + L'A');
            DISKLOG(("Mapping %ws\n", DosVolume));

            if (MapDosVolumeToPhysicalPartition(DosVolume,
                                                &DriveLetterMap[ Letter ]))
            {
                if ( DriveLetterMap[ Letter ].DriveType != DRIVE_FIXED ) {
                    DISKLOG(("%ws is not a fixed disk\n", DosVolume));
                    DriveLetterMap[ Letter ].DeviceNumber.PartitionNumber = 0;
                }
            } else {
                DISKLOG(("Can't map %ws: %u\n", DosVolume, GetLastError()));
            }
        }
        DriveMap >>= 1;
        Letter += 1;
    }

    //
    // Go through all the physical partitions and create logical
    // disk objects for each one.
    //
    int diskIndex;

    DISKLOG(("Creating Logical disk objects\n"));

    DiskPos = m_PhysicalDisks.GetStartPosition();
    while (DiskPos != NULL) {
        m_PhysicalDisks.GetNextAssoc(DiskPos, diskIndex, PhysicalDisk);

        //
        // If there are no FT partitions on this disk, create the logical
        // volumes on this disk.
        //
        if (PhysicalDisk->FtPartitionCount() == 0) {
            //
            // Go through all the partitions on this disk.
            //
            POSITION PartitionPos = PhysicalDisk->m_PartitionList.GetHeadPosition();
            CPhysicalPartition *Partition;
            while (PartitionPos != NULL) {
                Partition = PhysicalDisk->m_PartitionList.GetNext(PartitionPos);

                //
                // If the partition type is recognized, create a volume object
                // for this partition.
                //
                if ( !IsFTPartition( Partition->m_Info.PartitionType ) &&
                    (IsRecognizedPartition(Partition->m_Info.PartitionType))) {
                    CLogicalDrive *Volume = new CLogicalDrive;
                    if (Volume == NULL) {
                        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return FALSE;
                    }

                    DISKLOG(("Init'ing logical vol for disk %u, part %u\n",
                             Partition->m_PhysicalDisk->m_DiskNumber,
                             Partition->m_Info.PartitionNumber));

                    if (Volume->Initialize(Partition)) {
                        //
                        // Add this volume to our list.
                        //
                        m_LogicalDrives[Volume->m_DriveLetter] = Volume;
                    } else {
                        DISKLOG(("Failed init logical vol\n"));
                        delete(Volume);
                    }
                }

            }
        }
    }

    //
    // Now find the volume for the system drive
    //

    DISKLOG(("Getting system drive info\n"));
    if (GetEnvironmentVariable(L"SystemDrive",
                               System,
                               sizeof(System)/sizeof(WCHAR)) == 0) {
        DISKERR(IDS_ERR_DRIVE_CONFIG, ERROR_PATH_NOT_FOUND);
        // Need to handle this failure
    }

    if (!m_LogicalDrives.Lookup(System[0], m_SystemVolume)) {
        //
        // There are some weird cases that cause us to not find the system
        // volume. For example, the system volume is on an FT set that shares
        // a member with another FT set. So we just leave m_SystemVolume==NULL
        // and assume that no other disks in our list will be on the same bus.
        //
        m_SystemVolume = NULL;
    }

    DISKLOG(("Finished gathering disk config info\n"));
    return(TRUE);
}

VOID
CDiskConfig::RemoveAllFtInfoData(
    VOID
    )

/*++

Routine Description:

    clear out all FtInfo related data associated with each
    physical disk and physical partition instance.

Arguments:

    None

Return Value:

    None.

--*/

{
    POSITION diskPos;
    POSITION partitionPos;
    CPhysicalDisk *disk;
    CPhysicalPartition *partition;
    int Index;

    //
    // run through our list of physical disks, deleting any
    // associated FtInfo data. We enum the PhysicalDisks since
    // the back pointers to the FtInfoDisk and FtInfoPartition members
    // need to be cleared and this is the only (easy) to do that
    //

    for( diskPos = m_PhysicalDisks.GetStartPosition(); diskPos; ) {

        m_PhysicalDisks.GetNextAssoc(diskPos, Index, disk);

        if ( disk->m_FtInfo != NULL ) {

            DISKLOG(("Removing %08X from FtInfo DB\n", disk->m_Signature));
            m_FTInfo.DeleteDiskInfo( disk->m_Signature );
            disk->m_FtInfo = NULL;

            partitionPos = disk->m_PartitionList.GetHeadPosition();

            while (partitionPos) {
                partition = disk->m_PartitionList.GetNext( partitionPos );
                partition->m_FtPartitionInfo = NULL;
            }
        }
    }
}

VOID
CDiskConfig::RemoveDisk(
    IN CPhysicalDisk *Disk
    )

/*++

Description:

    walk the logical drive and physical partition lists, removing all
    structures

Arguments:

    Disk - pointer to physical disk that is being removed

Return Value:

    None

--*/

{
    CLogicalDrive *Volume;

    //
    // Remove all the logical drives on this disk.
    //
    while (!Disk->m_LogicalDriveList.IsEmpty()) {
        Volume = Disk->m_LogicalDriveList.RemoveHead();
        m_LogicalDrives.RemoveKey(Volume->m_DriveLetter);

        delete(Volume);
    }

    //
    // Remove all the physical partitions on this disk.
    //
    CPhysicalPartition *Partition;
    while (!Disk->m_PartitionList.IsEmpty()) {
        Partition = Disk->m_PartitionList.RemoveHead();
        delete(Partition);
    }

    //
    // Remove this disk
    //
    m_PhysicalDisks.RemoveKey(Disk->m_DiskNumber);

    delete(Disk);
}


CPhysicalPartition *
CDiskConfig::FindPartition(
    IN CFtInfoPartition *FtPartition
    )

/*++

Routine Description:

    Given the FtInfo description of a partition, attempts to find
    the corresponding CPhysicalPartition

Arguments:

    FtPartition - Supplies an FT partition description

Return Value:

    A pointer to the CPhysicalPartition if successful

    NULL otherwise

--*/

{
    POSITION pos;
    CPhysicalDisk *Disk;
    CPhysicalPartition *Partition;
    int DiskIndex;
    BOOL Found = FALSE;

    //
    // First find the appropriate CPhysicalDisk
    //
    pos = m_PhysicalDisks.GetStartPosition();
    while (pos) {
        m_PhysicalDisks.GetNextAssoc(pos, DiskIndex, Disk);
        if (Disk->m_FtInfo) {
            if (Disk->m_FtInfo->m_Signature == FtPartition->m_ParentDisk->m_Signature) {
                Found = TRUE;
                break;
            }
        }
    }
    if (!Found) {
        return(FALSE);
    }

    //
    // Now find the appropriate CPhysicalPartition in this disk.
    //
    pos = Disk->m_PartitionList.GetHeadPosition();
    while (pos) {
        Partition = Disk->m_PartitionList.GetNext(pos);
        if (Partition->m_FtPartitionInfo == FtPartition) {
            //
            // Found a match!
            //
            return(Partition);
        }
    }

    return(FALSE);
}

DWORD
CDiskConfig::MakeSticky(
    IN CPhysicalDisk *Disk
    )
{
    DWORD Status;

    Status = Disk->MakeSticky(&m_FTInfo);
    if (Status == ERROR_SUCCESS) {
        Status = m_FTInfo.CommitRegistryData();
    }
    return(Status);
}

DWORD
CDiskConfig::MakeSticky(
    IN CFtSet *FtSet
    )
{
    DWORD Status;

    Status = FtSet->MakeSticky();
    if (Status == ERROR_SUCCESS) {
        Status = m_FTInfo.CommitRegistryData();
    }
    return(Status);
}

BOOL
CDiskConfig::OnSystemBus(
    IN CPhysicalDisk *Disk
    )
{
    CPhysicalDisk *SystemDisk;

    if (m_SystemVolume == NULL) {
        return(FALSE);
    }
    SystemDisk = m_SystemVolume->m_Partition->m_PhysicalDisk;
    if (Disk == SystemDisk) {
        return(TRUE);
    }
    if (SystemDisk->ShareBus(Disk)) {
        return(TRUE);
    }
    return(FALSE);
}

BOOL
CDiskConfig::OnSystemBus(
    IN CFtSet *FtSet
    )
{

    POSITION pos = FtSet->m_Member.GetHeadPosition();
    CPhysicalPartition *Partition;

    while (pos) {
        Partition = FtSet->m_Member.GetNext(pos);
        if (OnSystemBus(Partition->m_PhysicalDisk)) {
            return(TRUE);
        }
    }

    return(FALSE);

}


//
// Functions for the logical disk object
//

BOOL
CLogicalDrive::Initialize(
    IN CPhysicalPartition *Partition
    )
/*++

Routine Description:

    Initializes a new logical disk object.

Arguments:

    Partition - Supplies the physical partition.

Return Value:

--*/

{
    CString DosVolume;
    WCHAR DriveLabel[32];
    WCHAR FsName[16];
    DWORD MaxLength;
    DWORD Flags;
    WCHAR Buff[128];
    DISK_PARTITION UNALIGNED *FtInfo;

    //
    // See if this drive has a "sticky" drive letter in the registry.
    //
    m_Partition = Partition;
    if (Partition->m_FtPartitionInfo != NULL) {
        FtInfo = Partition->m_FtPartitionInfo->m_PartitionInfo;
    } else {
        FtInfo = NULL;
    }

    if ((FtInfo) &&
        (FtInfo->AssignDriveLetter) &&
        (FtInfo->DriveLetter != 0))
    {
        m_IsSticky = TRUE;
        m_DriveLetter = (WCHAR)FtInfo->DriveLetter;
    } else {
        m_IsSticky = FALSE;

        //
        // There is no sticky drive letter for this device.  Scan through the
        // Partition/Drive Letter map looking for a matching drive letter.
        //
        DWORD letter;

        for ( letter = 0; letter < 26; ++letter ) {
            if (DriveLetterMap[ letter ].DriveType == DRIVE_FIXED
                &&
                Partition->m_PhysicalDisk->m_DiskNumber == DriveLetterMap[ letter ].DeviceNumber.DeviceNumber
                &&
                Partition->m_Info.PartitionNumber == DriveLetterMap[ letter ].DeviceNumber.PartitionNumber)
            {
                break;
            }
        }

        if ( letter == 26 ) {
            //
            // There is no drive letter for this partition.  Just ignore it.
            //
            return(FALSE);
        }
        m_DriveLetter = (WCHAR)(letter + L'A');
    }

    DosVolume = m_DriveLetter;
    DosVolume += L":\\";
    if (GetVolumeInformation(DosVolume,
                             DriveLabel,
                             sizeof(DriveLabel)/sizeof(WCHAR),
                             NULL,
                             &MaxLength,
                             &Flags,
                             FsName,
                             sizeof(FsName)/sizeof(WCHAR))) {
        if ( CompareString( LOCALE_INVARIANT,
                            NORM_IGNORECASE,
                            FsName,
                            -1,
                            L"NTFS",
                            -1 ) == CSTR_EQUAL ) {
            m_IsNTFS = TRUE;
        } else {
            m_IsNTFS = FALSE;
        }
        m_VolumeLabel = DriveLabel;
        (VOID) StringCchPrintf( Buff,
                                RTL_NUMBER_OF(Buff),
                                L"%c: (%ws)",
                                m_DriveLetter,
                                (LPCTSTR)m_VolumeLabel );
    } else {
        m_IsNTFS = TRUE; // Lie and say it is NTFS

        (VOID) StringCchPrintf( Buff,
                                RTL_NUMBER_OF(Buff),
                                L"%c: (RAW)",
                                m_DriveLetter );
    }
    m_Identifier = Buff;

    m_Partition->m_PhysicalDisk->m_LogicalDriveList.AddTail(this);
    m_ContainerSet = NULL;
    return(TRUE);
}


BOOL
CLogicalDrive::IsSCSI(
    VOID
    )
/*++

Routine Description:

    Returns whether or not a logical drive is SCSI. A logical
    drive is SCSI if all of its partitions are on SCSI drives.

Arguments:

    None.

Return Value:

    TRUE if the drive is entirely SCSI

    FALSE otherwise.

--*/

{
    return(m_Partition->m_PhysicalDisk->m_IsSCSI);
}


DWORD
CLogicalDrive::MakeSticky(
    VOID
    )
/*++

Routine Description:

    Attempts to assign a sticky drive letter to the specified volume.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if the drive was made sticky.

    Win32 error code otherwise.

--*/

{
    m_Partition->m_FtPartitionInfo->MakeSticky((UCHAR)m_DriveLetter);
    m_IsSticky = TRUE;
    return(ERROR_SUCCESS);
}


BOOL
CLogicalDrive::ShareBus(
    IN CLogicalDrive *OtherDrive
    )
/*++

Routine Description:

    Returns whether or not this drive shares a bus with another
    drive.

Arguments:

    OtherDrive - Supplies the other drive

Return Value:

    TRUE - if the drives have any of their partitions on the same bus.

    FALSE - if the drives do not hae any of their partitiosn on the same bus.

--*/

{
    PSCSI_ADDRESS MyAddress;
    PSCSI_ADDRESS OtherAddress;

    MyAddress = &m_Partition->m_PhysicalDisk->m_ScsiAddress;
    OtherAddress = &OtherDrive->m_Partition->m_PhysicalDisk->m_ScsiAddress;

    if ( (MyAddress->PortNumber == OtherAddress->PortNumber) &&
         (MyAddress->PathId == OtherAddress->PathId) ) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


//
// Functions for the physical disk object
//

DWORD
CPhysicalDisk::Initialize(
    CFtInfo *FtInfo,
    IN LPWSTR DeviceName
    )
/*++

Routine Description:

    Initializes a physical disk object

Arguments:

    FtInfo - pointer to object's FtInfo data

    DeviceName - pointer to string of device to initialize

Return Value:

    ERROR_SUCCESS if successful

--*/

{
    HKEY DiskKey;
    WCHAR Buff[100];
    DWORD BuffSize;
    DWORD dwType;
    HANDLE hDisk;
    DWORD Status;
    DWORD dwSize;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    WCHAR KeyName[256];
    DISK_GEOMETRY Geometry;
    STORAGE_DEVICE_NUMBER deviceNumber;

    //
    // Open the physical drive and start probing it to find disk number and
    // other attributes
    //
    hDisk = GetPhysicalDriveHandle(GENERIC_READ, DeviceName);
    if (hDisk == NULL) {
        return(GetLastError());
    }

    if (!DeviceIoControl(hDisk,
                         IOCTL_STORAGE_GET_DEVICE_NUMBER,
                         NULL,
                         0,
                         &deviceNumber,
                         sizeof(deviceNumber),
                         &dwSize,
                         NULL))
    {
        Status = GetLastError();
        DISKLOG(("get device number failed for drive %ws. status = %u\n",
                 DeviceName,
                 Status));
        return Status;
    } else {
        m_DiskNumber = deviceNumber.DeviceNumber;
    }

    if (!DeviceIoControl(hDisk,
                         IOCTL_SCSI_GET_ADDRESS,
                         NULL,
                         0,
                         &m_ScsiAddress,
                         sizeof(SCSI_ADDRESS),
                         &dwSize,
                         NULL))
    {
        //
        // If the IOCTL was invalid, the drive is not a SCSI drive.
        //
        DISKLOG(("IOCTL_SCSI_GET_ADDRESS failed for drive %u. status = %u\n",
                 m_DiskNumber,
                 GetLastError()));
        m_IsSCSI = FALSE;

    } else {

        //
        // [THINKTHINK] John Vert (jvert) 10/12/1996
        //      Need some way to make sure this is really SCSI and
        //      not ATAPI?
        //
        m_IsSCSI = TRUE;

        //
        // Get the description of the disk from the registry.
        //

        (VOID) StringCchPrintf( KeyName,
                                RTL_NUMBER_OF(KeyName),
                                TEXT("HARDWARE\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target Id %d\\Logical Unit Id %d"),
                                m_ScsiAddress.PortNumber,
                                m_ScsiAddress.PathId,
                                m_ScsiAddress.TargetId,
                                m_ScsiAddress.Lun );

        Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                               KeyName,
                               0,
                               KEY_READ,
                               &DiskKey);
        if (Status != ERROR_SUCCESS) {
            DISKERR(IDS_ERR_DRIVE_CONFIG, Status);
            // [REENGINEER] Need to handle this failure //
        }
        BuffSize = sizeof(Buff);
        Status = RegQueryValueExW(DiskKey,
                                  L"Identifier",
                                  NULL,
                                  &dwType,
                                  (LPBYTE)Buff,
                                  &BuffSize);
        RegCloseKey(DiskKey);
        if (Status != ERROR_SUCCESS) {
            DISKERR(IDS_ERR_DRIVE_CONFIG, Status);
            // [REENGINEER] Need to handle this failure //
        }
        m_Identifier = Buff;

    }

    //
    // Get the drive layout.
    //
    m_PartitionCount = 0;
    if (!ClRtlGetDriveLayoutTable( hDisk, &DriveLayout, NULL )) {
        DISKLOG(("Couldn't get partition table for drive %u. status = %u\n",
                 m_DiskNumber,
                 GetLastError()));
        m_Signature = 0;
        m_FtInfo = NULL;
    } else {
        m_Signature = DriveLayout->Signature;
        //
        // Get the FT information
        //
        m_FtInfo = FtInfo->FindDiskInfo(m_Signature);

        //
        // build the partition objects.
        //
        DWORD i;
        CPhysicalPartition *Partition;
        for (i=0; i<DriveLayout->PartitionCount; i++) {
            if (DriveLayout->PartitionEntry[i].RecognizedPartition) {
                m_PartitionCount++;
                Partition = new CPhysicalPartition(this, &DriveLayout->PartitionEntry[i]);
                if (Partition != NULL) {
                    //
                    // If we have FT information for the disk, make sure we
                    // found it for each partition.  If we didn't find it for
                    // the partition, the registry is stale and doesn't match
                    // the drive layout.
                    //
                    if ((m_FtInfo != NULL) &&
                        (Partition->m_FtPartitionInfo == NULL)) {

                        //
                        // Stale registry info.  Make up some new stuff.
                        //
                        CFtInfoPartition *FtInfoPartition;
                        FtInfoPartition = new CFtInfoPartition(m_FtInfo, Partition);
                        if (FtInfoPartition == NULL) {
                            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                            LocalFree( DriveLayout );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        Partition->m_FtPartitionInfo = FtInfoPartition;
                    }
                    m_PartitionList.AddTail(Partition);
                } else {
                    DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                    LocalFree( DriveLayout );
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
        LocalFree( DriveLayout );
    }


    //
    // Check whether it is removable or not.
    //
    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_GET_DRIVE_GEOMETRY,
                         NULL,
                         0,
                         &Geometry,
                         sizeof(Geometry),
                         &dwSize,
                         NULL)) {
        Status = GetLastError();
        if (Status == ERROR_NOT_READY) {
            //
            // Guess this must be removable!
            //
            m_IsRemovable = TRUE;
        } else {
            //
            // [FUTURE] John Vert (jvert) 10/18/1996
            //      Remove this when we require the new SCSI driver.
            //      The disk is reserved on the other system, so we can't
            //      get the geometry.
            //
            m_IsRemovable = FALSE;
        }
    } else {
        if (Geometry.MediaType == RemovableMedia) {
            m_IsRemovable = TRUE;
        } else {
            m_IsRemovable = FALSE;
        }
    }
    CloseHandle(hDisk);

    return(ERROR_SUCCESS);
}

HANDLE
CPhysicalDisk::GetPhysicalDriveHandle(DWORD Access)
{
    WCHAR Buff[100];
    HANDLE hDisk;

    (VOID) StringCchPrintf( Buff,
                            RTL_NUMBER_OF(Buff),
                            TEXT("\\\\.\\PhysicalDrive%d"),
                            m_DiskNumber );
    hDisk = CreateFile(Buff,
                       Access,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hDisk == INVALID_HANDLE_VALUE) {
        DISKLOG(("Failed to get handle for drive %u. status = %u\n",
                 m_DiskNumber,
                 GetLastError()));
        return(NULL);
    }
    return(hDisk);
}

HANDLE
CPhysicalDisk::GetPhysicalDriveHandle(DWORD Access, LPWSTR DeviceName)
{
    HANDLE hDisk;

    hDisk = CreateFile(DeviceName,
                       Access,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hDisk == INVALID_HANDLE_VALUE) {
        DISKLOG(("Failed to get handle for drive %u. status = %u\n",
                 m_DiskNumber,
                 GetLastError()));
        return(NULL);
    }
    return(hDisk);
}


BOOL
CPhysicalDisk::ShareBus(
    IN CPhysicalDisk *OtherDisk
    )
/*++

Routine Description:

    Returns whether or not this disk shares a bus with another
    disk.

Arguments:

    OtherDisk - Supplies the other disk

Return Value:

    TRUE - if the disks share the same bus.

    FALSE - if the disks do not share the same bus.

--*/

{
    //
    // Make sure they are either both SCSI or both not SCSI.
    //
    if (m_IsSCSI != OtherDisk->m_IsSCSI) {
        return(FALSE);
    }
    if ( (m_ScsiAddress.PortNumber == OtherDisk->m_ScsiAddress.PortNumber) &&
         (m_ScsiAddress.PathId == OtherDisk->m_ScsiAddress.PathId) ) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOL
CPhysicalDisk::IsSticky(
    VOID
    )
/*++

Routine Description:

    Returns whether or not this disk has a signature and all the partitions
    on it have sticky drive letters.

Arguments:

    None.

Return Value:

    TRUE - if the disk is sticky

    FALSE - if the disk is not sticky and needs to have some FT information
            applied before it is suitable for clustering.

--*/

{
    //
    // If the signature is 0, return FALSE.
    //
    if ((m_FtInfo == NULL) ||
        (m_FtInfo->m_Signature == 0)) {
        return(FALSE);
    }

    //
    // Check each volume to see if it has a sticky drive letter.
    //
    CLogicalDrive *Drive;
    POSITION pos = m_LogicalDriveList.GetHeadPosition();
    while (pos) {
        Drive = m_LogicalDriveList.GetNext(pos);
        if (!Drive->m_IsSticky) {
            return(FALSE);
        }
    }
    return(TRUE);
}


BOOL
CPhysicalDisk::IsNTFS(
    VOID
    )
/*++

Routine Description:

    Returns whether or not all the partitions on this drive are NTFS.

Arguments:

    None.

Return Value:

    TRUE - if the disk is entirely NTFS

    FALSE - if the disk is not entirely NTFS

--*/

{
    //
    // if no logical volumes were created for this drive, then it must not
    // have any NTFS partitions
    //
    if ( m_LogicalDriveList.IsEmpty()) {
        return FALSE;
    }

    //
    // Check each volume to see if it has a sticky drive letter.
    //
    CLogicalDrive *Drive;
    POSITION pos = m_LogicalDriveList.GetHeadPosition();
    while (pos) {
        Drive = m_LogicalDriveList.GetNext(pos);
        if (!Drive->m_IsNTFS) {
            return(FALSE);
        }
    }
    return(TRUE);
}


DWORD
CPhysicalDisk::MakeSticky(
    CFtInfo *FtInfo
    )
/*++

Routine Description:

    Attempts to make a disk and all of its partitions have
    sticky drive letters.

Arguments:

    FtInfo - Supplies the FT information that will be updated.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    if (m_Signature == 0) {

        //
        // Better not be any information in the registry for a disk
        // with no signature.
        //
        if (m_FtInfo != NULL) {
            DISKERR(IDS_GENERAL_FAILURE, ERROR_FILE_NOT_FOUND);
        }

        //
        // There is no signature on this drive. Think one up and
        // stamp the drive.
        //
        HANDLE hDisk = GetPhysicalDriveHandle(GENERIC_READ | GENERIC_WRITE);
        PDRIVE_LAYOUT_INFORMATION DriveLayout;
        DWORD dwSize;
        DWORD NewSignature;
        FILETIME CurrentTime;
        BOOL success;

        if (hDisk == NULL) {
            return(GetLastError());
        }

        //
        // Get the current drive layout, change the signature field, and
        // set the new drive layout. The new drive layout will be identical
        // except for the new signature.
        //
        if (!ClRtlGetDriveLayoutTable( hDisk, &DriveLayout, &dwSize )) {
            Status = GetLastError();
            DISKERR(IDS_GENERAL_FAILURE, Status);
            CloseHandle(hDisk);
            return(Status);
        }

        GetSystemTimeAsFileTime(&CurrentTime);
        NewSignature = CurrentTime.dwLowDateTime;

        //
        // Make sure this signature is unique.
        //
        while (FtInfo->FindDiskInfo(NewSignature) != NULL) {
            NewSignature++;
        }

        //
        // Finally set the new signature information.
        //
        DriveLayout->Signature = NewSignature;
        success = DeviceIoControl(hDisk,
                                  IOCTL_DISK_SET_DRIVE_LAYOUT,
                                  DriveLayout,
                                  dwSize,
                                  NULL,
                                  0,
                                  &dwSize,
                                  NULL);
        LocalFree( DriveLayout );

        if ( !success ) {
            Status = GetLastError();
            DISKERR(IDS_GENERAL_FAILURE, Status);
            CloseHandle(hDisk);
            return(Status);
        }

        m_Signature = NewSignature;
    }

    if (m_FtInfo == NULL) {
        //
        // There is no existing FT information for this drive.
        // Create some FT information based on the drive.
        //
        m_FtInfo = new CFtInfoDisk(this);
        if (m_FtInfo == NULL) {
            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        FtInfo->SetDiskInfo(m_FtInfo);

        //
        // Go through all our partitions and set their FT info.
        //
        POSITION pos = m_PartitionList.GetHeadPosition();
        CPhysicalPartition *Partition;
        while (pos) {
            Partition = m_PartitionList.GetNext(pos);
            Partition->m_FtPartitionInfo = m_FtInfo->GetPartition(Partition->m_Info.StartingOffset,
                                                                  Partition->m_Info.PartitionLength);
        }
    }

    //
    // Go through all the volumes on this drive and make each one
    // sticky.
    //
    CLogicalDrive *Drive;

    POSITION pos = m_LogicalDriveList.GetHeadPosition();
    while (pos) {
        Drive = m_LogicalDriveList.GetNext(pos);
        Status = Drive->MakeSticky();
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }
    return(ERROR_SUCCESS);
}


//
// Functions for the physical disk partition
//
CPhysicalPartition::CPhysicalPartition(
    CPhysicalDisk *Disk,
    PPARTITION_INFORMATION Info
    )
{
    m_PhysicalDisk = Disk;
    m_Info = *Info;
    if (Disk->m_FtInfo) {
        m_FtPartitionInfo = Disk->m_FtInfo->GetPartition(m_Info.StartingOffset,
                                                         m_Info.PartitionLength);
    } else {
        m_FtPartitionInfo = NULL;
    }
}

//
// Functions for the FT set object
//
BOOL
CFtSet::Initialize(
    CDiskConfig *Config,
    CFtInfoFtSet *FtInfo
    )
{
    DWORD MemberCount;
    DWORD FoundCount=0;
    DWORD Index;
    CFtInfoPartition *Partition;
    CPhysicalPartition *FoundPartition;

    m_FtInfo = FtInfo;

    //
    // Find the CPhysicalPartition that corresponds to each member of the
    // FT set.
    //
    MemberCount = FtInfo->GetMemberCount();
    for (Index=0; Index<MemberCount; Index++) {
        Partition = FtInfo->GetMemberByIndex(Index);
        if (Partition == NULL) {
            break;
        }
        FoundPartition = Config->FindPartition(Partition);
        if (FoundPartition != NULL) {
            ++FoundCount;
            m_Member.AddTail(FoundPartition);
        }
    }

    //
    // If we did not find all the required members, fail.
    //
    switch (FtInfo->GetType()) {
        case Stripe:
        case VolumeSet:
            if (FoundCount != MemberCount) {
                return(FALSE);
            }
            break;

        case Mirror:
            if (FoundCount == 0) {
                return(FALSE);
            }
            break;

        case StripeWithParity:
            if (FoundCount < (MemberCount-1)) {
                return(FALSE);
            }
            break;

        default:
            //
            // Don't know what the heck this is supposed to be.
            // Ignore it.
            //
            return(FALSE);
    }

    //
    // If there are any other partitions on any of the drives, create logical
    // volumes for them.
    //
    POSITION MemberPos;
    POSITION PartitionPos;
    CPhysicalPartition *PhysPartition;
    CPhysicalDisk *Disk;
    MemberPos = m_Member.GetHeadPosition();
    while (MemberPos) {
        Disk = m_Member.GetNext(MemberPos)->m_PhysicalDisk;

        PartitionPos = Disk->m_PartitionList.GetHeadPosition();
        while (PartitionPos) {
            PhysPartition = Disk->m_PartitionList.GetNext(PartitionPos);
            if ((!(PhysPartition->m_Info.PartitionType & PARTITION_NTFT)) &&
                (IsRecognizedPartition(PhysPartition->m_Info.PartitionType))) {
                CLogicalDrive *Vol = new CLogicalDrive;
                if (Vol == NULL) {
                    DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
                if (Vol->Initialize(PhysPartition)) {
                    //
                    // Add this volume to our list.
                    //
                    m_OtherVolumes.AddTail(Vol);
                    Vol->m_ContainerSet = this;

                    //
                    // Update the disk config.
                    //
                    Config->m_LogicalDrives[Vol->m_DriveLetter] = Vol;
                } else {
                    delete(Vol);
                }
            }
        }
    }

    if (Volume.Initialize(m_Member.GetHead())) {
        Volume.m_ContainerSet = this;
        return(TRUE);
    } else {
        return(FALSE);
    }
}

BOOL
CFtSet::IsSticky()
{
    //
    // FT sets are, by definition, sticky. Make sure any other volumes on the
    // same drive are sticky as well.
    //
    POSITION pos = m_OtherVolumes.GetHeadPosition();
    CLogicalDrive *Volume;
    while (pos) {
        Volume = m_OtherVolumes.GetNext(pos);
        if (!Volume->m_IsSticky) {
            return(FALSE);
        }
    }
    return(TRUE);
}

DWORD
CFtSet::MakeSticky()
{
    DWORD Status;

    //
    // FT sets are, by definition, sticky. Make sure any other volumes on the
    // same drive are sticky as well.
    //
    POSITION pos = m_OtherVolumes.GetHeadPosition();
    CLogicalDrive *Volume;
    while (pos) {
        Volume = m_OtherVolumes.GetNext(pos);
        Status = Volume->MakeSticky();
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }
    return(ERROR_SUCCESS);
}

BOOL
CFtSet::IsNTFS()
{
    if (!Volume.m_IsNTFS) {
        return(FALSE);
    }
    //
    // Check the other volumes to make sure they are NTFS as well.
    //
    POSITION pos = m_OtherVolumes.GetHeadPosition();
    CLogicalDrive *Volume;
    while (pos) {
        Volume = m_OtherVolumes.GetNext(pos);
        if (!Volume->m_IsNTFS) {
            return(FALSE);
        }
    }
    return(TRUE);
}

BOOL
CFtSet::IsSCSI()
{
    //
    // Check the other volumes to make sure they are NTFS as well.
    //
    POSITION pos = m_Member.GetHeadPosition();
    CPhysicalPartition *Partition;
    while (pos) {
        Partition = m_Member.GetNext(pos);
        if (!Partition->m_PhysicalDisk->m_IsSCSI) {
            return(FALSE);
        }
    }
    return(TRUE);
}

//
// Functions for the FT disk information
//

CFtInfo::CFtInfo()
{
    HKEY hKey;
    LONG Status;

    //
    // for NT5, the DISK info key is no longer maintained by the disk
    // system. Clusters still needs a centrally located key such that
    // the other members of the cluster can query for the disk config
    // of the sponsor's node.
    //

    Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           L"System\\Disk",
                           0,
                           KEY_READ | KEY_WRITE,
                           &hKey);
    if (Status == ERROR_SUCCESS) {
        Initialize(hKey, _T("Information"));
        RegCloseKey(hKey);
    } else {
        Initialize();
    }
}

CFtInfo::CFtInfo(
    HKEY hKey,
    LPWSTR lpszValueName
    )
{
    Initialize(hKey, lpszValueName);
}

CFtInfo::CFtInfo(
    PDISK_CONFIG_HEADER Header
    )
{
    DWORD Length;

    Length = Header->FtInformationOffset +
             Header->FtInformationSize;
    Initialize(Header, Length);
}

CFtInfo::CFtInfo(
    CFtInfoFtSet *FtSet
    )
/*++

Routine Description:

    Constructor for generating a CFtInfo that contains only a
    single FT set.

Arguments:

    FtSet - Supplies the FT set

Return Value:

    None

--*/

{
    //
    // Initialize an empty FT information.
    //
    Initialize();

    //
    // Add the FT set
    //
    if (FtSet != NULL) {
        AddFtSetInfo(FtSet);
    }

}

VOID
CFtInfo::Initialize(
    HKEY hKey,
    LPWSTR lpszValueName
    )
{
    PDISK_CONFIG_HEADER          regHeader;
    DWORD Length;

    if (GetRegValue(hKey,
                    lpszValueName,
                    (LPBYTE *)&regHeader,
                    &Length)) {
        Initialize(regHeader, Length);
        LocalFree(regHeader);
    } else {
        DWORD Status = GetLastError();

        if (Status == ERROR_FILE_NOT_FOUND) {

            //
            // There is no FT information on this machine.
            //
            Initialize();
        } else {
            DISKERR(IDS_GENERAL_FAILURE, Status);
        }
    }
}

VOID
CFtInfo::Initialize(
    PDISK_CONFIG_HEADER Header,
    DWORD Length
    )
{
    DWORD i;
    DISK_REGISTRY UNALIGNED *    diskRegistry;
    DISK_DESCRIPTION UNALIGNED * diskDescription;
    CFtInfoDisk *DiskInfo;

    m_buffer = new BYTE[Length];
    if (m_buffer == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return; // [REENGINEER] we avoided an AV, but the caller wouldn't know
    }
    CopyMemory(m_buffer, Header, Length);
    m_bufferLength = Length;

    //
    // Iterate through all the disks and add each one to our list.
    //

    diskRegistry = (DISK_REGISTRY UNALIGNED *)
                         (m_buffer + ((PDISK_CONFIG_HEADER)m_buffer)->DiskInformationOffset);
    diskDescription = &diskRegistry->Disks[0];
    for (i = 0; i < diskRegistry->NumberOfDisks; i++) {
        DiskInfo = new CFtInfoDisk(diskDescription);
        if (DiskInfo) {
            //
            // Add this disk information to our list.
            //
            DiskInfo->SetOffset((DWORD)((PUCHAR)diskDescription - m_buffer));
            m_DiskInfo.AddTail(DiskInfo);
        } else {
            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
            // [REENGINEER] do we need to exit here?
        }

        //
        // Look at the next disk
        //
        diskDescription = (DISK_DESCRIPTION UNALIGNED *)
            &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    if (((PDISK_CONFIG_HEADER)m_buffer)->FtInformationSize != 0) {
        //
        // Iterate through all the FT sets and add each one to our list.
        //
        PFT_REGISTRY        ftRegistry;
        PFT_DESCRIPTION     ftDescription;
        CFtInfoFtSet *FtSetInfo;
        ftRegistry = (PFT_REGISTRY)
                         (m_buffer + ((PDISK_CONFIG_HEADER)m_buffer)->FtInformationOffset);
        ftDescription = &ftRegistry->FtDescription[0];
        for (i=0; i < ftRegistry->NumberOfComponents; i++) {
            FtSetInfo = new CFtInfoFtSet;
            if (FtSetInfo) {
                if (!FtSetInfo->Initialize(this, ftDescription)) {
                    delete FtSetInfo;
                } else {
                    //
                    // Add this FT set information to the list.
                    //
                    m_FtSetInfo.AddTail(FtSetInfo);
                }
            } else {
                DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                // [REENGINEER] do we need to exit here?
            }
            ftDescription = (PFT_DESCRIPTION)(&ftDescription->FtMemberDescription[ftDescription->NumberOfMembers]);
        }
    }

}

VOID
CFtInfo::Initialize(VOID)
{
    PDISK_CONFIG_HEADER          regHeader;
    DISK_REGISTRY UNALIGNED *    diskRegistry;

    //
    // There is no FT information on this machine.
    //
    m_bufferLength = sizeof(DISK_CONFIG_HEADER) + sizeof(DISK_REGISTRY);
    m_buffer = new BYTE[m_bufferLength];
    if (m_buffer == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return; // [REENGINEER], we avoided an AV, but the caller wouldn't know
    }
    regHeader = (PDISK_CONFIG_HEADER)m_buffer;
    regHeader->Version = DISK_INFORMATION_VERSION;
    regHeader->CheckSum = 0;
    regHeader->DirtyShutdown = FALSE;
    regHeader->DiskInformationOffset = sizeof(DISK_CONFIG_HEADER);
    regHeader->DiskInformationSize = sizeof(DISK_REGISTRY)-sizeof(DISK_DESCRIPTION);
    regHeader->FtInformationOffset = regHeader->DiskInformationOffset +
                                     regHeader->DiskInformationSize;
    regHeader->FtInformationSize = 0;
    regHeader->FtStripeWidth = 0;
    regHeader->FtPoolSize = 0;
    regHeader->NameOffset = 0;
    regHeader->NameSize = 0;
    diskRegistry = (DISK_REGISTRY UNALIGNED *)
                         ((PUCHAR)regHeader + regHeader->DiskInformationOffset);
    diskRegistry->NumberOfDisks = 0;
    diskRegistry->ReservedShort = 0;
}

CFtInfo::~CFtInfo()
{
    CFtInfoDisk *DiskInfo;
    CFtInfoFtSet *FtSetInfo;

    POSITION pos = m_DiskInfo.GetHeadPosition();
    while (pos) {
        DiskInfo = m_DiskInfo.GetNext(pos);
        delete(DiskInfo);
    }

    pos = m_FtSetInfo.GetHeadPosition();
    while (pos) {
        FtSetInfo = m_FtSetInfo.GetNext(pos);
        delete FtSetInfo;
    }
    delete [] m_buffer;
}

DWORD
CFtInfo::CommitRegistryData()
{
    HKEY hKey;
    PDISK_CONFIG_HEADER Buffer;
    DWORD Size;
    DWORD Status = ERROR_SUCCESS;

    Status = RegCreateKeyW(HKEY_LOCAL_MACHINE, L"System\\Disk", &hKey);
    if (Status != ERROR_SUCCESS) {
        DISKERR(IDS_REGISTRY_FAILURE, Status);
        return Status;
    }
    Size = GetSize();
    Buffer = (PDISK_CONFIG_HEADER)LocalAlloc(LMEM_FIXED, Size);
    if (Buffer == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        GetData(Buffer);

        Status = RegSetValueExW(hKey,
                                L"Information",
                                0,
                                REG_BINARY,
                                (PBYTE)Buffer,
                                Size);
        if (Status != ERROR_SUCCESS) {
            DISKERR(IDS_REGISTRY_FAILURE, Status);
        }
        LocalFree(Buffer);
    }
    RegCloseKey(hKey);

    return(Status);
}

VOID
CFtInfo::SetDiskInfo(
    CFtInfoDisk *NewDisk
    )
{
    CFtInfoDisk *OldDisk;
    //
    // See if we already have disk information for this signature
    //
    OldDisk = FindDiskInfo(NewDisk->m_Signature);
    if (OldDisk == NULL) {

        DISKLOG(("CFtInfo::SetDiskInfo adding new disk information for %08X\n",NewDisk->m_Signature));
        //
        // Just add the new disk to our list.
        //
        m_DiskInfo.AddTail(NewDisk);
    } else {

        //
        // We already have some disk information. If they are the same,
        // don't do anything.
        //
        if (*OldDisk == *NewDisk) {
            DISKLOG(("CFtInfo::SetDiskInfo found identical disk information for %08X\n",OldDisk->m_Signature));
            delete (NewDisk);
            return;
        }

        //
        // We need to replace the old information with the new information.
        //
        POSITION pos = m_DiskInfo.Find(OldDisk);
        if (pos == NULL) {
            DISKLOG(("CFtInfo::SetDiskInfo did not find OldDisk %08X\n",OldDisk->m_Signature));
            DISKERR(IDS_GENERAL_FAILURE, ERROR_FILE_NOT_FOUND);
            m_DiskInfo.AddTail(NewDisk);
        } else {
            m_DiskInfo.SetAt(pos, NewDisk);
            delete(OldDisk);
        }
    }
}

CFtInfoDisk *
CFtInfo::FindDiskInfo(
    IN DWORD Signature
    )
{
    CFtInfoDisk *RetInfo;
    POSITION pos = m_DiskInfo.GetHeadPosition();
    while (pos) {
        RetInfo = m_DiskInfo.GetNext(pos);
        if (RetInfo->m_Signature == Signature) {
            return(RetInfo);
        }
    }
    return(NULL);
}

CFtInfoDisk *
CFtInfo::EnumDiskInfo(
    IN DWORD Index
    )
{
    DWORD i=0;
    CFtInfoDisk *RetInfo;
    POSITION pos = m_DiskInfo.GetHeadPosition();
    while (pos) {
        RetInfo = m_DiskInfo.GetNext(pos);
        if (Index == i) {
            return(RetInfo);
        }
        ++i;
    }
    return(NULL);
}

BOOL
CFtInfo::DeleteDiskInfo(
    IN DWORD Signature
    )
{
    CFtInfoDisk *Info = FindDiskInfo(Signature);
    CFtInfoFtSet *OldFtSet=NULL;

    if (Info == NULL) {
        DISKLOG(("CFtInfo::DeleteDiskInfo: Disk with signature %08X was not found\n",Signature));
        return(FALSE);
    }

    //
    // Remove any FT set containing this signature.
    //
    OldFtSet = FindFtSetInfo(Info->m_Signature);
    if (OldFtSet != NULL) {
        DeleteFtSetInfo(OldFtSet);
    }

    POSITION pos = m_DiskInfo.Find(Info);
    if (pos == NULL) {
        DISKLOG(("CFtInfo::DeleteDiskInfo did not find Info %08X\n",Signature));
        DISKERR(IDS_GENERAL_FAILURE, ERROR_FILE_NOT_FOUND);
        return(FALSE);
    } else {
        m_DiskInfo.RemoveAt(pos);
        delete(Info);
    }
    return(TRUE);
}

VOID
CFtInfo::AddFtSetInfo(
    CFtInfoFtSet *FtSet,
    CFtInfoFtSet *OldFtSet
    )
{
    DWORD MemberCount;
    DWORD i;
    CFtInfoPartition *Partition;
    CFtInfoPartition *NewPartition;
    CFtInfoDisk *Disk;
    CFtInfoFtSet *NewFtSet;
    USHORT FtGroup;
    POSITION pos;
    BOOL Success;

    if (OldFtSet != NULL) {
        CFtInfoFtSet *pSet;
        pos = m_FtSetInfo.GetHeadPosition();
        for (FtGroup = 1; ; FtGroup++) {
            pSet = m_FtSetInfo.GetNext(pos);
            if (pSet == NULL) {
                OldFtSet = NULL;
                break;
            }
            if (pSet == OldFtSet) {
                //
                // Reset our position back to point at the OldFtSet
                //
                pos = m_FtSetInfo.Find(OldFtSet);
                break;
            }
        }
    }
    if (OldFtSet == NULL) {
        FtGroup = (USHORT)m_FtSetInfo.GetCount()+1;
    }
    //
    // Add each disk in the FT set.
    //
    MemberCount = FtSet->GetMemberCount();
    for (i=0; i<MemberCount; i++) {
        Partition = FtSet->GetMemberByIndex(i);
        DISKASSERT(Partition != NULL);

        Disk = new CFtInfoDisk(Partition->m_ParentDisk);
        if (Disk == NULL) {
            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
            return; // [REENGINEER], caller doesn't know about the problem
        }

        SetDiskInfo(Disk);
    }

    //
    // Create the empty FT set.
    //
    NewFtSet = new CFtInfoFtSet;
    if (NewFtSet == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return; // [REENGINEER], caller doesn't know about the problem
    }
    Success = NewFtSet->Initialize(FtSet->GetType(), FtSet->GetState());
    DISKASSERT(Success);

    //
    // Add each member to the empty FT set
    //
    for (i=0; i<MemberCount; i++) {
        //
        // Find each partition object in our FT information.
        //
        Partition = FtSet->GetMemberByIndex(i);
        NewPartition = FindPartition(Partition->m_ParentDisk->m_Signature,
                                     Partition->m_PartitionInfo->StartingOffset,
                                     Partition->m_PartitionInfo->Length);
        DISKASSERT(NewPartition != NULL);
        NewFtSet->AddMember(NewPartition,
                            FtSet->GetMemberDescription(i),
                            FtGroup);
    }

    if (OldFtSet != NULL) {
        //
        // Replace the old FT set information
        //
        m_FtSetInfo.SetAt(pos, NewFtSet);
        delete(OldFtSet);
    } else {
        //
        // Add the new FT set to the FT information
        //
        m_FtSetInfo.AddTail(NewFtSet);
    }

}

CFtInfoFtSet *
CFtInfo::FindFtSetInfo(
    IN DWORD Signature
    )
{
    CFtInfoFtSet *RetInfo;
    POSITION pos = m_FtSetInfo.GetHeadPosition();
    while (pos) {
        RetInfo = m_FtSetInfo.GetNext(pos);
        if (RetInfo->GetMemberBySignature(Signature) != NULL) {
            return(RetInfo);
        }
    }
    return(NULL);
}

CFtInfoFtSet *
CFtInfo::EnumFtSetInfo(
    IN DWORD Index
    )
{
    DWORD i=0;
    CFtInfoFtSet *RetInfo;
    POSITION pos = m_FtSetInfo.GetHeadPosition();
    while (pos) {
        RetInfo = m_FtSetInfo.GetNext(pos);
        if (i == Index) {
            return(RetInfo);
        }
        ++i;
    }
    return(NULL);
}

BOOL
CFtInfo::DeleteFtSetInfo(
    IN CFtInfoFtSet *FtSet
    )
{

    POSITION pos = m_FtSetInfo.Find(FtSet);
    if (pos == NULL) {
        DISKLOG(("CFtInfo::DeleteFtSetInfo did not find Info %08X\n",FtSet));
        DISKERR(IDS_GENERAL_FAILURE, ERROR_FILE_NOT_FOUND);
        return(FALSE);
    } else {
        DWORD i;
        CFtInfoPartition *FtPartition;

        //
        // Set the FT group of all this set's members to -1
        //
        for (i=0; ; i++) {
            FtPartition = FtSet->GetMemberByIndex(i);
            if (FtPartition == NULL) {
                break;
            }
            FtPartition->m_PartitionInfo->FtGroup = (USHORT)-1;
            FtPartition->m_PartitionInfo->FtMember = 0;
            FtPartition->m_PartitionInfo->FtType = NotAnFtMember;
        }
        m_FtSetInfo.RemoveAt(pos);
        delete(FtSet);
    }
    return(TRUE);
}


CFtInfoPartition *
CFtInfo::FindPartition(
    DWORD Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length
    )
{
    CFtInfoDisk *Disk;

    Disk = FindDiskInfo(Signature);
    if (Disk == NULL) {
        return(NULL);
    }

    return(Disk->GetPartition(StartingOffset, Length));
}

CFtInfoPartition *
CFtInfo::FindPartition(
    UCHAR DriveLetter
    )
{
    CFtInfoDisk *Disk;
    CFtInfoPartition *Partition;
    DWORD DiskIndex;
    DWORD PartitionIndex;

    for (DiskIndex = 0; ; DiskIndex++) {
        Disk = EnumDiskInfo(DiskIndex);
        if (Disk == NULL) {
            break;
        }

        for (PartitionIndex = 0; ; PartitionIndex++) {
            Partition = Disk->GetPartitionByIndex(PartitionIndex);
            if (Partition == NULL) {
                break;
            }
            if (Partition->m_PartitionInfo->AssignDriveLetter &&
                (Partition->m_PartitionInfo->DriveLetter == DriveLetter)) {
                //
                // Found a match.
                //
                return(Partition);
            }
        }
    }

    return(NULL);
}

DWORD
CFtInfo::GetSize()
{
    CFtInfoDisk *DiskInfo;
    CFtInfoFtSet *FtSetInfo;
    DWORD Delta;

    //
    // Start off with the fixed size header
    //
    DWORD Size = sizeof(DISK_CONFIG_HEADER);
    DISKLOG(("CFtInfo::GetSize headersize = %x\n",Size));

    //
    // Add in the size of the DISK_REGISTRY header
    //
    Delta = sizeof(DISK_REGISTRY) - sizeof(DISK_DESCRIPTION);
    Size += Delta;
    DISKLOG(("CFtInfo::GetSize += DISK_REGISTRY(%x) = %x\n",Delta, Size));

    if (!m_DiskInfo.IsEmpty()) {

        //
        // Add the sizes of each disks partition information
        //
        POSITION pos = m_DiskInfo.GetHeadPosition();
        while (pos) {
            DiskInfo = m_DiskInfo.GetNext(pos);
            Delta = DiskInfo->GetSize();
            Size += Delta;
            DISKLOG(("CFtInfo::GetSize += DiskInfo(%x) = %x\n",Delta, Size));
        }

        if (!m_FtSetInfo.IsEmpty()) {

            //
            // Add in the size of the FT_REGISTRY header
            //
            Delta = sizeof(FT_REGISTRY) - sizeof(FT_DESCRIPTION);
            Size += Delta;
            DISKLOG(("CFtInfo::GetSize += FT_REGISTRY(%x) = %x\n",Delta, Size));

            //
            // Add the sizes of each FT sets information
            //
            pos = m_FtSetInfo.GetHeadPosition();
            while (pos) {
                FtSetInfo = m_FtSetInfo.GetNext(pos);
                Delta = FtSetInfo->GetSize();
                Size += Delta;
                DISKLOG(("CFtInfo::GetSize +=FtSetInfo(%x) = %x\n",Delta, Size));
            }
        }
    }


    return(Size);
}

VOID
CFtInfo::GetData(
    PDISK_CONFIG_HEADER pDest
    )
{
    PDISK_CONFIG_HEADER DiskConfigHeader;
    PDISK_REGISTRY DiskRegistry;
    PDISK_DESCRIPTION DiskDescription;
    PFT_REGISTRY FtRegistry;
    PFT_DESCRIPTION FtDescription;
    DWORD Count;
    POSITION pos;
    CFtInfoDisk *DiskInfo;
    CFtInfoFtSet *FtSetInfo;

    //
    // Initialize the fixed size header.
    //
    // Copy the original header, then zero out the fields we might
    // change.
    //
    DiskConfigHeader = pDest;
    CopyMemory(DiskConfigHeader, m_buffer, sizeof(DISK_CONFIG_HEADER));
    DiskConfigHeader->DiskInformationOffset = sizeof(DISK_CONFIG_HEADER);
    DiskConfigHeader->FtInformationOffset = 0;
    DiskConfigHeader->FtInformationSize = 0;

    //
    // Initialize the fixed size DISK_REGISTRY header
    //
    DiskRegistry = (PDISK_REGISTRY)(DiskConfigHeader + 1);
    DiskRegistry->NumberOfDisks = (USHORT)m_DiskInfo.GetCount();
    DiskRegistry->ReservedShort = 0;
    DiskConfigHeader->DiskInformationSize = sizeof(DISK_REGISTRY) - sizeof(DISK_DESCRIPTION);

    if (!m_DiskInfo.IsEmpty()) {
        //
        // Get each disk's information
        //
        DiskDescription = &DiskRegistry->Disks[0];
        pos = m_DiskInfo.GetHeadPosition();
        while (pos) {
            DWORD Size;
            DiskInfo = m_DiskInfo.GetNext(pos);
            DiskInfo->SetOffset((DWORD)((PUCHAR)DiskDescription - (PUCHAR)DiskConfigHeader));
            DiskInfo->GetData((PBYTE)DiskDescription);
            Size = DiskInfo->GetSize();
            DiskConfigHeader->DiskInformationSize += Size;

            DiskDescription = (PDISK_DESCRIPTION)((PUCHAR)DiskDescription + Size);
        }

        //
        // Now set the FT information
        //
        FtRegistry = (PFT_REGISTRY)DiskDescription;
        DiskConfigHeader->FtInformationOffset =(DWORD)((PBYTE)FtRegistry - (PBYTE)DiskConfigHeader);
        if (!m_FtSetInfo.IsEmpty()) {

            //
            // Initialize the fixed size FT_REGISTRY header
            //
            FtRegistry->NumberOfComponents = (USHORT)m_FtSetInfo.GetCount();
            FtRegistry->ReservedShort = 0;
            DiskConfigHeader->FtInformationSize = sizeof(FT_REGISTRY) - sizeof(FT_DESCRIPTION);
            FtDescription = &FtRegistry->FtDescription[0];
            pos = m_FtSetInfo.GetHeadPosition();
            while (pos) {
                DWORD Size;

                FtSetInfo = m_FtSetInfo.GetNext(pos);
                FtSetInfo->GetData((PBYTE)FtDescription);
                Size = FtSetInfo->GetSize();
                DiskConfigHeader->FtInformationSize += Size;

                FtDescription = (PFT_DESCRIPTION)((PUCHAR)FtDescription + Size);
            }

        }

    }

}


//********************
//
// Implementation of standard partition information
//
//********************
CFtInfoPartition::CFtInfoPartition(
    CFtInfoDisk *Disk,
    DISK_PARTITION UNALIGNED *Description
    )
{
    m_ParentDisk = Disk;
    m_Modified = TRUE;

    m_PartitionInfo = (PDISK_PARTITION)LocalAlloc(LMEM_FIXED, sizeof(DISK_PARTITION));
    if (m_PartitionInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        // [REENGINEER], will AV in a second
    }
    CopyMemory(m_PartitionInfo, Description, sizeof(DISK_PARTITION));

}

CFtInfoPartition::CFtInfoPartition(
    CFtInfoDisk *Disk,
    CPhysicalPartition *Partition
    )
{
    m_ParentDisk = Disk;
    m_Modified = TRUE;

    m_PartitionInfo = (PDISK_PARTITION)LocalAlloc(LMEM_FIXED, sizeof(DISK_PARTITION));
    if (m_PartitionInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        // [REENGINEER], will AV in a second
    }
    m_PartitionInfo->FtType = NotAnFtMember;
    m_PartitionInfo->FtState = Healthy;
    m_PartitionInfo->StartingOffset = Partition->m_Info.StartingOffset;
    m_PartitionInfo->Length = Partition->m_Info.PartitionLength;
    m_PartitionInfo->FtLength.QuadPart = 0;
    m_PartitionInfo->DriveLetter = 0;
    m_PartitionInfo->AssignDriveLetter = FALSE;
    m_PartitionInfo->LogicalNumber = 0;
    m_PartitionInfo->FtGroup = (USHORT)-1;
    m_PartitionInfo->FtMember = 0;
    m_PartitionInfo->Modified = FALSE;
}

CFtInfoPartition::CFtInfoPartition(
    CFtInfoDisk *Disk,
    PARTITION_INFORMATION * PartitionInfo
    )
{
    m_ParentDisk = Disk;
    m_Modified = TRUE;

    m_PartitionInfo = (PDISK_PARTITION)LocalAlloc(LMEM_FIXED, sizeof(DISK_PARTITION));
    if (m_PartitionInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        // [REENGINEER], will AV in a second
    }
    m_PartitionInfo->FtType = NotAnFtMember;
    m_PartitionInfo->FtState = Healthy;
    m_PartitionInfo->StartingOffset = PartitionInfo->StartingOffset;
    m_PartitionInfo->Length = PartitionInfo->PartitionLength;
    m_PartitionInfo->FtLength.QuadPart = 0;
    m_PartitionInfo->DriveLetter = 0;
    m_PartitionInfo->AssignDriveLetter = FALSE;
    m_PartitionInfo->LogicalNumber = 0;
    m_PartitionInfo->FtGroup = (USHORT)-1;
    m_PartitionInfo->FtMember = 0;
    m_PartitionInfo->Modified = FALSE;
}

CFtInfoPartition::~CFtInfoPartition()
{
    if (m_Modified) {
        LocalFree(m_PartitionInfo);
    }
}

VOID
CFtInfoPartition::GetData(
    PDISK_PARTITION pDest
    )
{
    DISKLOG(("CFtInfoPartition::GetData %12I64X - %12I64X\n",
             m_PartitionInfo->StartingOffset.QuadPart,
             m_PartitionInfo->Length.QuadPart));

    DISKLOG(("                          %c (%s) %x %x %x\n",
             m_PartitionInfo->DriveLetter,
             m_PartitionInfo->AssignDriveLetter ? "Sticky" : "Not Sticky",
             m_PartitionInfo->LogicalNumber,
             m_PartitionInfo->FtGroup,
             m_PartitionInfo->FtMember));
    CopyMemory(pDest, m_PartitionInfo, sizeof(DISK_PARTITION));
}


DWORD
CFtInfoPartition::GetOffset(
    VOID
    )
{
    DWORD ParentOffset;

    ParentOffset = m_ParentDisk->GetOffset();

    return(ParentOffset + m_RelativeOffset);
}

VOID
CFtInfoPartition::MakeSticky(
    UCHAR DriveLetter
    )
{
    m_PartitionInfo->DriveLetter = DriveLetter;

    //
    // if drive letter is being removed, clear the sticky bit
    //
    m_PartitionInfo->AssignDriveLetter = ( DriveLetter != 0 );
}


//********************
//
// Implementation of standard disk information
//
//********************

CFtInfoDisk::CFtInfoDisk(
    DISK_DESCRIPTION UNALIGNED *Description
    )
{
    DWORD i;
    DWORD Offset;
    CFtInfoPartition *Partition;

    //
    // windisk sometimes puts in disk information
    // for disks with no partitions. Seems a bit pointless.
    //
    // DISKASSERT(Description->NumberOfPartitions > 0);
    m_PartitionCount = Description->NumberOfPartitions;
    m_Signature = Description->Signature;
    for (i=0; i<m_PartitionCount; i++) {
        Partition = new CFtInfoPartition(this, &Description->Partitions[i]);
        if (Partition != NULL) {
            Offset = sizeof(DISK_DESCRIPTION) + i*sizeof(DISK_PARTITION) - sizeof(DISK_PARTITION);
            Partition->SetOffset(Offset);
            m_PartitionInfo.AddTail(Partition);
        }
    }
}

CFtInfoDisk::CFtInfoDisk(
    CPhysicalDisk *Disk
    )
{
    DISKASSERT(Disk->m_PartitionCount > 0);
    m_PartitionCount = Disk->m_PartitionCount;
    m_Signature = Disk->m_Signature;

    //
    // Build up the partition objects
    //

    CFtInfoPartition *PartitionInfo;
    CPhysicalPartition *Partition;
    DWORD Offset;
    DWORD i=0;

    POSITION pos = Disk->m_PartitionList.GetHeadPosition();
    while (pos) {
        Partition = Disk->m_PartitionList.GetNext(pos);
        PartitionInfo = new CFtInfoPartition(this, Partition);
        if (PartitionInfo != NULL) {
            Offset = sizeof(DISK_DESCRIPTION) + i*sizeof(DISK_PARTITION) - sizeof(DISK_PARTITION);
            PartitionInfo->SetOffset(Offset);
            m_PartitionInfo.AddTail(PartitionInfo);
            ++i;
        }
    }
}

CFtInfoDisk::CFtInfoDisk(
    CFtInfoDisk *DiskInfo
    )
{
    DISKASSERT(DiskInfo->m_PartitionCount > 0);
    m_PartitionCount = DiskInfo->m_PartitionCount;
    m_Signature = DiskInfo->m_Signature;

    //
    // Build up the partition objects
    //

    CFtInfoPartition *PartitionInfo;
    CFtInfoPartition *SourcePartitionInfo;
    DWORD Offset;
    DWORD i=0;

    POSITION pos = DiskInfo->m_PartitionInfo.GetHeadPosition();
    while (pos) {
        SourcePartitionInfo = DiskInfo->m_PartitionInfo.GetNext(pos);
        PartitionInfo = new CFtInfoPartition(this, SourcePartitionInfo->m_PartitionInfo);
        if (PartitionInfo != NULL) {
            Offset = sizeof(DISK_DESCRIPTION) + i*sizeof(DISK_PARTITION) - sizeof(DISK_PARTITION);
            PartitionInfo->SetOffset(Offset);
            m_PartitionInfo.AddTail(PartitionInfo);
            ++i;
        }
    }
}

CFtInfoDisk::CFtInfoDisk(
    DRIVE_LAYOUT_INFORMATION *DriveLayout
    )
{
    DWORD i;
    CFtInfoPartition *ftInfoPartition;

    m_PartitionCount = 0; // [GN] Bugfix #278913
    m_Signature = DriveLayout->Signature;

    for (i=0; i < DriveLayout->PartitionCount; i++) {
        if (DriveLayout->PartitionEntry[i].RecognizedPartition) {
            m_PartitionCount++;

            ftInfoPartition = new CFtInfoPartition(this, &DriveLayout->PartitionEntry[i]);
            if (ftInfoPartition == NULL) {
                DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                // [REENGINEER], we will add a 0 pointer into m_PartitionInfo ... bad
            }
            m_PartitionInfo.AddTail(ftInfoPartition);
        }
    }
}

CFtInfoDisk::~CFtInfoDisk()
{
    CFtInfoPartition *Partition;
    while (!m_PartitionInfo.IsEmpty()) {
        Partition = m_PartitionInfo.RemoveHead();
        delete(Partition);
    }
}

BOOL
CFtInfoDisk::operator==(
    const CFtInfoDisk& Disk
    )
{
    if (m_PartitionCount != Disk.m_PartitionCount) {
        DISKLOG(("CFtInfoDisk::operator== partition count %d != %d\n",
                 m_PartitionCount,
                 Disk.m_PartitionCount));
        return(FALSE);
    }
    if (m_Signature != Disk.m_Signature) {
        DISKLOG(("CFtInfoDisk::operator== signature %08lx != %08lx\n",
                 m_Signature,
                 Disk.m_Signature));
        return(FALSE);
    }

    POSITION MyPos, OtherPos;
    CFtInfoPartition *MyPartition, *OtherPartition;
    MyPos = m_PartitionInfo.GetHeadPosition();
    OtherPos = Disk.m_PartitionInfo.GetHeadPosition();
    while (MyPos || OtherPos) {
        if (!MyPos) {
            DISKLOG(("CFtInfoDisk::operator== MyPos is NULL\n"));
            return(FALSE);
        }
        if (!OtherPos) {
            DISKLOG(("CFtInfoDisk::operator== OtherPos is NULL\n"));
            return(FALSE);
        }

        MyPartition = m_PartitionInfo.GetNext(MyPos);
        OtherPartition = Disk.m_PartitionInfo.GetNext(OtherPos);
        if (memcmp(MyPartition->m_PartitionInfo,
                   OtherPartition->m_PartitionInfo,
                   sizeof(DISK_PARTITION)) != 0) {
            DISKLOG(("CFtInfoDisk::operator== DISK_PARTITIONs don't match\n"));
            return(FALSE);
        }
    }
    DISKLOG(("CFtInfoDisk::operator== disk information matches\n"));
    return(TRUE);
}


CFtInfoPartition *
CFtInfoDisk::GetPartition(
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length
    )
{
    DWORD i;
    CFtInfoPartition *Partition;
    POSITION pos;

    pos = m_PartitionInfo.GetHeadPosition();
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        if ((Partition->m_PartitionInfo->StartingOffset.QuadPart == StartingOffset.QuadPart) &&
            (Partition->m_PartitionInfo->Length.QuadPart == Length.QuadPart)) {
            return(Partition);
        }
    }
    return(NULL);
}

CFtInfoPartition *
CFtInfoDisk::GetPartitionByOffset(
    DWORD Offset
    )
{
    CFtInfoPartition *Partition;
    POSITION pos;

    pos = m_PartitionInfo.GetHeadPosition();
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        if (Partition->GetOffset() == Offset) {
            return(Partition);
        }
    }
    return(NULL);
}

CFtInfoPartition *
CFtInfoDisk::GetPartitionByIndex(
    DWORD Index
    )
{
    DWORD i = 0;
    CFtInfoPartition *Partition;
    POSITION pos;

    pos = m_PartitionInfo.GetHeadPosition();
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        if (i == Index) {
            return(Partition);
        }
        ++i;
    }
    return(NULL);
}


DWORD
CFtInfoDisk::FtPartitionCount(
    VOID
    )
/*++

Routine Description:

    Returns the number of FT partitions on this disk. This is useful
    for determining whether a given FT set shares this disk with another
    FT set.

Arguments:

    None

Return Value:

    The number of FT partitions on this disk

--*/

{
    POSITION pos;
    CFtInfoPartition *Partition;
    DWORD Count = 0;

    pos = m_PartitionInfo.GetHeadPosition();
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        if (Partition->IsFtPartition()) {
            ++Count;
        }
    }

    return(Count);
}

DWORD
CFtInfoDisk::GetSize(
    VOID
    )
{
    return(sizeof(DISK_DESCRIPTION) +
           (m_PartitionCount-1) * sizeof(DISK_PARTITION));
}

VOID
CFtInfoDisk::GetData(
    PBYTE pDest
    )
{
    PDISK_DESCRIPTION Description = (PDISK_DESCRIPTION)pDest;
    DWORD i;
    CFtInfoPartition *Partition;

    DISKLOG(("CFtInfoDisk::GetData signature %08lx has %d partitions\n",m_Signature, m_PartitionCount));

    Description->NumberOfPartitions = (USHORT)m_PartitionCount;
    Description->ReservedShort = 0;
    Description->Signature = m_Signature;

    POSITION pos = m_PartitionInfo.GetHeadPosition();
    i=0;
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        Partition->GetData(&Description->Partitions[i]);
        ++i;
    }
}


//********************
//
// Implementation of FT registry information
//
//********************

BOOL
CFtInfoFtSet::Initialize(USHORT Type, FT_STATE FtVolumeState)
{
    m_Modified = TRUE;
    m_FtDescription = (PFT_DESCRIPTION)LocalAlloc(LMEM_FIXED, sizeof(FT_DESCRIPTION));
    DISKASSERT(m_FtDescription);

    m_FtDescription->NumberOfMembers = 0;
    m_FtDescription->Type = Type;
    m_FtDescription->Reserved = 0;
    m_FtDescription->FtVolumeState = FtVolumeState;
    return(TRUE);
}

BOOL
CFtInfoFtSet::Initialize(
    CFtInfo *FtInfo,
    PFT_DESCRIPTION Description
    )
{
    m_FtDescription = Description;
    m_Modified = FALSE;

    //
    // Create the list of members.
    //
    CFtInfoDisk *Disk;
    CFtInfoPartition *Partition;
    PFT_MEMBER_DESCRIPTION Member;
    DWORD i;

    if (Description->NumberOfMembers == 0) {
        //
        // WINDISK will sometimes put FT sets with zero members in
        // the registry after breaking a mirror set. Throw them out,
        // seems pretty pointless...
        //
        DISKLOG(("CFtInfoFtSet::Initialize - FT Set with zero members ignored\n"));
        return(FALSE);
    }

    m_Members.SetSize(Description->NumberOfMembers);
    for (i=0; i<Description->NumberOfMembers; i++) {
        Member = &Description->FtMemberDescription[i];

        //
        // Find the disk by its signature
        //
        Disk = FtInfo->FindDiskInfo(Member->Signature);
        if (Disk == NULL) {
            DISKLOG(("CFtInfoFtSet::Initialize - Disk signature %08lx not found\n",
                    Member->Signature));
            return(FALSE);
        }

        //
        // Find the partition by its offset.
        //
        Partition = Disk->GetPartitionByOffset(Member->OffsetToPartitionInfo);
        if (Partition == NULL) {
            DISKLOG(("CFtInfoFtSet::Initialize - Partition on disk %08lx at offset %08lx not found\n",
                     Member->Signature,
                     Member->OffsetToPartitionInfo));
            return(FALSE);
        }

        //
        // Add this partition to our list.
        //
        if (Partition->m_PartitionInfo->FtMember >= Description->NumberOfMembers) {
            DISKLOG(("CFtInfoFtSet::Initialize - member %d out of range\n",
                      Partition->m_PartitionInfo->FtMember));
            return(FALSE);
        }
        if (m_Members[Partition->m_PartitionInfo->FtMember] != NULL) {
            DISKLOG(("CFtInfoFtSet::Initialize - Duplicate member %d\n",
                      Partition->m_PartitionInfo->FtMember));
            return(FALSE);
        }
        m_Members.SetAt(Partition->m_PartitionInfo->FtMember, Partition);
    }
    return(TRUE);
}

CFtInfoFtSet::~CFtInfoFtSet()
{
    if (m_Modified) {
        LocalFree(m_FtDescription);
    }
}

BOOL
CFtInfoFtSet::operator==(
    const CFtInfoFtSet& FtSet1
    )
{
    DWORD MemberCount;
    DWORD i;
    CFtInfoDisk *Disk1;
    CFtInfoDisk *Disk2;

    if (GetType() != FtSet1.GetType()) {
        return(FALSE);
    }
    if (GetState() != FtSet1.GetState()) {
        return(FALSE);
    }
    MemberCount = GetMemberCount();
    if (MemberCount != FtSet1.GetMemberCount()) {
        return(FALSE);
    }
    for (i=0; i<MemberCount; i++) {
        Disk1 = GetMemberByIndex(i)->m_ParentDisk;
        Disk2 = FtSet1.GetMemberByIndex(i)->m_ParentDisk;
        if (!(*Disk1 == *Disk2)) {
            return(FALSE);
        }
    }
    DISKLOG(("CFtInfoFtSet::operator== FT information matches\n"));

    return(TRUE);
}

DWORD
CFtInfoFtSet::GetSize(
    VOID
    ) const
{
    return(sizeof(FT_DESCRIPTION) +
           (m_FtDescription->NumberOfMembers-1) * sizeof(FT_MEMBER_DESCRIPTION));
}

VOID
CFtInfoFtSet::GetData(
    PBYTE pDest
    )
{
    PFT_DESCRIPTION Description = (PFT_DESCRIPTION)pDest;

    DWORD Size = GetSize();
    CopyMemory(Description, m_FtDescription, Size);

    //
    // Now go through the partitions and update the offsets.
    //
    DWORD i;
    CFtInfoPartition *Partition;
    for (i=0; i<GetMemberCount(); i++) {
        Partition = m_Members[i];
        Description->FtMemberDescription[i].OffsetToPartitionInfo = Partition->GetOffset();
    }
}


BOOL
CFtInfoFtSet::IsAlone(
    VOID
    )
/*++

Routine Description:

    Returns whether or not this FT set has a disk in common with
    any other FT set.

Arguments:

    None

Return Value:

    TRUE if this FT set does not share any physical disk with any other
         FT set

    FALSE if there is another FT set sharing a disk as this one.

--*/

{
    //
    // Go through each member of the FT set and see if any disk has
    // more than one partition that is marked as an FT partition.
    //

    POSITION pos;
    CFtInfoPartition *Partition;
    CFtInfoDisk *Disk;
    DWORD i;

    for (i=0; i<GetMemberCount(); i++) {
        Partition = m_Members[i];
        Disk = Partition->m_ParentDisk;

        if (Disk->FtPartitionCount() > 1) {
            //
            // This disk has more than one FT partition, so there must be
            // another set sharing it.
            //
            return(FALSE);
        }

    }
    return(TRUE);

}

CFtInfoPartition *
CFtInfoFtSet::GetMemberBySignature(
    IN DWORD Signature
    ) const
{
    CFtInfoPartition *Partition;
    DWORD i;

    for (i=0; i<GetMemberCount(); i++) {
        Partition = m_Members[i];
        if (Partition->m_ParentDisk->m_Signature == Signature) {
            return(Partition);
        }
    }

    return(NULL);
}

CFtInfoPartition *
CFtInfoFtSet::GetMemberByIndex(
    IN DWORD Index
    ) const
{
    CFtInfoPartition *Partition;

    if (Index >= GetMemberCount()) {
        return(NULL);
    }
    return(m_Members[Index]);
}

DWORD
CFtInfoFtSet::AddMember(
    CFtInfoPartition *Partition,
    PFT_MEMBER_DESCRIPTION Description,
    USHORT FtGroup
    )
{
    DWORD MemberCount;
    PFT_DESCRIPTION NewBuff;
    PFT_MEMBER_DESCRIPTION NewMember;

    MemberCount = GetMemberCount();

    if (MemberCount > 0) {
        //
        // Grow the size of our structure.
        //
        if (m_Modified) {
            NewBuff = (PFT_DESCRIPTION)LocalReAlloc(m_FtDescription,
                                       sizeof(FT_DESCRIPTION) + MemberCount*sizeof(FT_MEMBER_DESCRIPTION),
                                       LMEM_MOVEABLE);
            if (NewBuff == NULL) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            m_FtDescription = NewBuff;
        } else {
            m_Modified = TRUE;
            NewBuff = (PFT_DESCRIPTION)LocalAlloc(LMEM_FIXED,
                                                  sizeof(FT_DESCRIPTION) + MemberCount*sizeof(FT_MEMBER_DESCRIPTION));
            if (NewBuff == NULL) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            CopyMemory(NewBuff,
                       m_FtDescription,
                       sizeof(FT_DESCRIPTION) + (MemberCount-1)*sizeof(FT_MEMBER_DESCRIPTION));
            m_FtDescription = NewBuff;
        }
    }
    NewMember = &m_FtDescription->FtMemberDescription[MemberCount];

    //
    // Initialize the member description. Note that the OffsetToPartitionInfo
    // will be updated when the user does a GetData.
    //
    NewMember->State = Description->State;
    NewMember->ReservedShort = Description->ReservedShort;
    NewMember->Signature = Description->Signature;
    NewMember->LogicalNumber = Description->LogicalNumber;

    //
    // Add the partition to our list.
    //
    Partition->m_PartitionInfo->FtGroup = FtGroup;
    Partition->m_PartitionInfo->FtMember = (USHORT)MemberCount;
    m_Members.SetAtGrow(Partition->m_PartitionInfo->FtMember, Partition);
    m_FtDescription->NumberOfMembers = (USHORT)GetMemberCount();

    return(ERROR_SUCCESS);
}

//
// Some C wrappers used by the FT Set resource DLL
//
extern "C" {

PFT_INFO
DiskGetFtInfo(
    VOID
    )
{
    PFT_INFO FtInfo;

    FtInfo = (PFT_INFO)new CFtInfo;

    return(FtInfo);
}

VOID
DiskFreeFtInfo(
    PFT_INFO FtInfo
    )
{
    CFtInfo *Info;

    Info = (CFtInfo *)FtInfo;
    delete Info;
}


DWORD
DiskEnumFtSetSignature(
    IN PFULL_FTSET_INFO FtSet,
    IN DWORD MemberIndex,
    OUT LPDWORD MemberSignature
    )
/*++

Routine Description:

    Returns the signature of the N'th member of the FT set.

Arguments:

    FtSet - Supplies the FT information returned by DiskGetFullFtSetInfo

    MemberIndex - Supplies the 0-based index of the member to return.

    MemberSignature - Returns the signature of the MemberIndex'th member.

Return Value:

    ERROR_SUCCESS if successful

    ERROR_NO_MORE_ITEMS if the index is greather than the number of members

--*/

{
    CFtInfo *Info;
    CFtInfoFtSet *FtSetInfo;
    CFtInfoPartition *Partition;

    Info = new CFtInfo((PDISK_CONFIG_HEADER)FtSet);
    if (Info == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    FtSetInfo = Info->EnumFtSetInfo(0);
    if (FtSetInfo == NULL) {
        //
        // There is no FT set information, so just return the signature of the n'th member
        //
        CFtInfoDisk *Disk;

        Disk = Info->EnumDiskInfo(MemberIndex);
        if (Disk == NULL) {
            return(ERROR_NO_MORE_ITEMS);
        } else {
            *MemberSignature = Disk->m_Signature;
            return(ERROR_SUCCESS);
        }
    }

    Partition = FtSetInfo->GetMemberByIndex(MemberIndex);
    if (Partition == NULL) {
        return(ERROR_NO_MORE_ITEMS);
    }

    *MemberSignature = Partition->m_ParentDisk->m_Signature;
    delete Info;
    return(ERROR_SUCCESS);

}


PFULL_FTSET_INFO
DiskGetFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN LPCWSTR lpszMemberList,
    OUT LPDWORD pSize
    )
/*++

Routine Description:

    Serializes the complete information from an FT set in a form
    suitable for saving to a file or the registry. These bits can
    be restored with DiskSetFullFtSetInfo.

Arguments:

    FtInfo - supplies the FT information

    lpszMemberList - Supplies a list of signatures. The list is in the
        REG_MULTI_SZ format.

    pSize - Returns the size of the FT information bytes.

Return Value:

    A pointer to the serializable FT information if successful.

    NULL on error

--*/

{
    PDISK_CONFIG_HEADER DiskConfig;
    DWORD Length;
    CFtInfo *OriginalInfo;
    CFtInfo *NewInfo;
    CFtInfoFtSet *FtSetInfo;
    CFtInfoPartition *FtPartitionInfo;
    PDISK_PARTITION Member;
    DWORD MemberCount;
    DWORD i;
    DWORD Index;
    DWORD Signature;
    LPCWSTR lpszSignature;
    DWORD MultiSzLength;
    WCHAR SignatureString[9];

    OriginalInfo = (CFtInfo *)FtInfo;
    MultiSzLength = ClRtlMultiSzLength(lpszMemberList);

    //
    // First, try to find an FT set that has the "identity" of at least one of the
    // supplied members. This is tricky because we need to make sure that if multiple
    // FT sets are broken and reformed with different members, only one FT resource
    // picks up each FT set. We will find a matching FT set if:
    //   - One of the supplied members is the first member of a mirror or volume set.
    //   - The supplied members make up N-1 members of an N member SWP.
    //   - The supplied members make up all the members of a stripe.
    //
    for (i=0; ; i++) {
        lpszSignature = ClRtlMultiSzEnum(lpszMemberList,
                                         MultiSzLength,
                                         i);
        if (lpszSignature == NULL) {
            DISKLOG(("DiskGetFullFtSetInfo: no FTSET containing members found\n"));
            FtSetInfo = NULL;
            break;
        }
        Signature = wcstoul(lpszSignature, NULL, 16);
        DISKLOG(("DiskGetFullFtSetInfo: looking for member %08lx\n", Signature));

        FtSetInfo = OriginalInfo->FindFtSetInfo(Signature);
        if (FtSetInfo == NULL) {
            DISKLOG(("DiskGetFullFtSetInfo: member %08lx is not in any FT set\n", Signature));
        } else {
            //
            // Check to see if this is the first member of a volume set or mirror
            //
            if ((FtSetInfo->GetType() == Mirror) ||
                (FtSetInfo->GetType() == VolumeSet)) {
                //
                // Now check to see if this member is the first member of the set.
                //
                if (FtSetInfo->GetMemberByIndex(0)->m_ParentDisk->m_Signature == Signature) {
                    //
                    // We have found a matching FT set.
                    //
                    DISKLOG(("DiskGetFullFtSetInfo: member %08lx found in FT set.\n", Signature));
                    break;
                }
            } else if ((FtSetInfo->GetType() == StripeWithParity) ||
                       (FtSetInfo->GetType() == Stripe)) {
                DWORD MaxMissing;

                //
                // Check to see if the supplied member list makes up N-1 of the members
                // of a stripe with parity or all the members of a stripe.
                //
                if (FtSetInfo->GetType() == StripeWithParity) {
                    MaxMissing = 1;
                } else {
                    MaxMissing = 0;
                }
                for (Index = 0; ; Index++) {
                    FtPartitionInfo = FtSetInfo->GetMemberByIndex(Index);
                    if (FtPartitionInfo == NULL) {
                        break;
                    }

                    //
                    // Try to find this signature in the passed in member list.
                    //

                    (VOID) StringCchPrintf( SignatureString,
                                            RTL_NUMBER_OF(SignatureString),
                                            TEXT("%08lX"),
                                            FtPartitionInfo->m_ParentDisk->m_Signature );

                    if (ClRtlMultiSzScan(lpszMemberList,SignatureString) == NULL) {
                        //
                        // This FT set member is not in the supplied list.
                        //
                        DISKLOG(("DiskGetFullFtSetInfo: member %08lx missing from old member list\n",
                                 FtPartitionInfo->m_ParentDisk->m_Signature));
                        if (MaxMissing == 0) {
                            FtSetInfo = NULL;
                            break;
                        }
                        --MaxMissing;
                    }
                }
                if (FtSetInfo != NULL) {
                    //
                    // We have found a matching FT set
                    //
                    break;
                }
            }
        }
    }

    if (FtSetInfo != NULL) {
        //
        // An FT Set exists that contains one of the supplied members.
        // Create a new CFtInfo that contains nothing but the FT set and
        // its members.
        //
        NewInfo = new CFtInfo(FtSetInfo);
        if (NewInfo == NULL) {
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
        }

    } else {
        //
        // No FT Set contains any of the supplied members. Create a new CFtInfo
        // that contains disk entries for each of the supplied members, but no
        // FT set information. Any members which are members of an FT set will
        // be excluded, since they have been assimilated into another set.
        //
        NewInfo = new CFtInfo((CFtInfoFtSet *)NULL);
        if (NewInfo == NULL) {
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
        }

        //
        // Find each member in the original FT info and add it to the new
        // FT info.
        //
        for (i=0; ; i++) {
            CFtInfoDisk *DiskInfo;

            lpszSignature = ClRtlMultiSzEnum(lpszMemberList,
                                             MultiSzLength,
                                             i);
            if (lpszSignature == NULL) {
                break;
            }
            Signature = wcstoul(lpszSignature, NULL, 16);
            if (OriginalInfo->FindFtSetInfo(Signature) != NULL) {
                DISKLOG(("DiskGetFullFtSetInfo: removing member %08lx as it is already a member of another set.\n",Signature));
            } else {
                DiskInfo = OriginalInfo->FindDiskInfo(Signature);
                if (DiskInfo != NULL) {
                    CFtInfoDisk *NewDisk;
                    NewDisk = new CFtInfoDisk(DiskInfo);
                    if ( NewDisk == NULL ) {
                        SetLastError(ERROR_INVALID_DATA);
                        return(NULL);
                    }
                    DISKLOG(("DiskGetFullFtSetInfo: adding member %08lx to new FT info\n",Signature));
                    NewInfo->SetDiskInfo(NewDisk);
                } else {
                    DISKLOG(("DiskGetFullFtSetInfo: member %08lx not found in original FT info\n",Signature));
                }
            }
        }
    }

    //
    // Get the FT data
    //
    *pSize = NewInfo->GetSize();

    DiskConfig = (PDISK_CONFIG_HEADER)LocalAlloc(LMEM_FIXED, *pSize);
    if (DiskConfig == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    NewInfo->GetData(DiskConfig);
    delete NewInfo;
    return((PFULL_FTSET_INFO)DiskConfig);
}


PFULL_FTSET_INFO
DiskGetFullFtSetInfoByIndex(
    IN PFT_INFO FtInfo,
    IN DWORD Index,
    OUT LPDWORD pSize
    )
/*++

Routine Description:

    Serializes the complete information from an FT set in a form
    suitable for saving to a file or the registry. These bits can
    be restored with DiskSetFullFtSetInfo.

Arguments:

    FtInfo - supplies the FT information

    Index - Supplies the index

    pSize - Returns the size of the FT information bytes.

Return Value:

    A pointer to the serializable FT information if successful.

    NULL on error

--*/

{
    PDISK_CONFIG_HEADER DiskConfig;
    DWORD Length;
    CFtInfo *OriginalInfo;
    CFtInfo *NewInfo;
    CFtInfoFtSet *FtSetInfo;

    OriginalInfo = (CFtInfo *)FtInfo;
    FtSetInfo = OriginalInfo->EnumFtSetInfo(Index);
    if (FtSetInfo == NULL) {
        return(NULL);
    }
    //
    // Create a new CFtInfo that contains nothing but the FT set and
    // its members.
    //
    NewInfo = new CFtInfo(FtSetInfo);
    if (NewInfo == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // Get the FT data
    //
    *pSize = NewInfo->GetSize();
    DiskConfig = (PDISK_CONFIG_HEADER)LocalAlloc(LMEM_FIXED, *pSize);
    if (DiskConfig == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    NewInfo->GetData(DiskConfig);
    delete NewInfo;
    return((PFULL_FTSET_INFO)DiskConfig);
}


BOOL
DiskCheckFtSetLetters(
    IN PFT_INFO FtInfo,
    IN PFULL_FTSET_INFO Bytes,
    OUT WCHAR *Letter
    )
/*++

Routine Description:

    This routine checks to see if the FT set info conflicts with
    any already-defined sticky drive letters on the current system.
    If a conflict is found, the conflicting drive letter is returned.

Arguments:

    FtInfo - Supplies the FT information

    Bytes - Supplies the information returned from DiskGetFullFtSetInfo

Return Value:

    TRUE if no conflicts were detected

    FALSE if a conflict was detected. If it returns FALSE, *Letter will be
          set to the conflicting drive letter.

--*/

{
    CFtInfo *RegistryInfo;
    CFtInfo *NewInfo;
    CFtInfoDisk *Disk;
    CFtInfoFtSet *FtSet;
    DWORD i;

    RegistryInfo = (CFtInfo *)FtInfo;
    NewInfo = new CFtInfo((PDISK_CONFIG_HEADER)Bytes);
    if (NewInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Go through each physical disk in the FT set. For each one, see if
    // there is a physical disk in the registry information with a different
    // signature and the same drive letter. If so, we have a conflict.
    //
    FtSet = NewInfo->EnumFtSetInfo(0);
    DISKASSERT(FtSet != NULL);
    for (i=0; ; i++) {
        Disk = NewInfo->EnumDiskInfo(i);
        if (Disk == NULL) {
            break;
        }

        //
        // Go through each partition on this disk and look up the drive letter
        // in the registry information.
        //
        CFtInfoPartition *Partition;
        DWORD Index;
        for (Index = 0; ; Index++) {
            Partition = Disk->GetPartitionByIndex(Index);
            if (Partition == NULL) {
                break;
            }
            //
            // If this partition has an assigned drive letter,
            // check it out.
            //
            if (Partition->m_PartitionInfo->AssignDriveLetter) {

                //
                // See if there is an existing partition with this drive
                // letter already in the registry information
                //
                CFtInfoPartition *Existing;

                Existing = RegistryInfo->FindPartition(Partition->m_PartitionInfo->DriveLetter);
                if (Existing != NULL) {
                    //
                    // If the existing partition has a different signature than
                    // the new partition, we have found a conflict.
                    //
                    if (Existing->m_ParentDisk->m_Signature !=
                        Partition->m_ParentDisk->m_Signature) {
                        *Letter = (WCHAR)Partition->m_PartitionInfo->DriveLetter;
                        delete NewInfo;
                        return(FALSE);
                    }
                }
            }
        }
    }

    delete NewInfo;
    return(TRUE);

}


DWORD
DiskSetFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN PFULL_FTSET_INFO Bytes
    )
/*++

Routine Description:

    Restores the complete information from an FT set to the DISK
    key in the registry. The FT set information must have been
    returned from DiskGetFullFtSetInfo.

Arguments:

    FtInfo - supplies the FT information

    Bytes - Supplies the information returned from DiskGetFullFtSetInfo.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise

--*/

{
    CFtInfo *RegistryInfo;
    CFtInfo *NewInfo;
    CFtInfoFtSet *OldFtSet=NULL;
    CFtInfoFtSet *NewFtSet=NULL;
    CFtInfoDisk *Disk;
    DWORD i;
    BOOL Modified = FALSE;
    DWORD Status;

    RegistryInfo = (CFtInfo *)FtInfo;
    NewInfo = new CFtInfo((PDISK_CONFIG_HEADER)Bytes);
    if (NewInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // If the new information contains an FT set, merge that into the
    // current registry.
    //
    if (NewInfo->EnumFtSetInfo(0) != NULL) {
        //
        // Find an FT set in the registry that has a signature
        // that is the same as one of those in the restored FT set.
        //
        NewFtSet = NewInfo->EnumFtSetInfo(0);
        DISKASSERT(NewFtSet != NULL);

        for (i=0; ; i++) {
            Disk = NewInfo->EnumDiskInfo(i);
            if (Disk == NULL) {
                break;
            }

            //
            // Try and find an existing FT set containing this signature
            //
            OldFtSet = RegistryInfo->FindFtSetInfo(Disk->m_Signature);
            if (OldFtSet != NULL) {
                break;
            }
        }
        if (Disk == NULL) {
            //
            // No matching FT set was found. We can just add this one directly.
            //
            Modified = TRUE;
            RegistryInfo->AddFtSetInfo(NewFtSet);
        } else {
            if (!(*OldFtSet == *NewFtSet)) {
                Modified = TRUE;
                RegistryInfo->AddFtSetInfo(NewFtSet, OldFtSet);
            }
        }
    } else {
        //
        // There is no FT set in the new registry. This will happen if a mirror
        // set gets broken. For each member in the new information, delete any
        // FT sets that it is a part of and merge it into the registry.
        //
        for (i=0; ; i++) {
            Disk = NewInfo->EnumDiskInfo(i);
            if (Disk == NULL) {
                break;
            }
            Modified = TRUE;

            //
            // Remove any FT sets containing this signature
            //
            OldFtSet = RegistryInfo->FindFtSetInfo(Disk->m_Signature);
            if (OldFtSet != NULL) {
                RegistryInfo->DeleteFtSetInfo(OldFtSet);
            }

            //
            // Set the FT information for this member into the registry.
            //
            CFtInfoDisk *NewDisk;
            NewDisk = new CFtInfoDisk(Disk);
            if (NewDisk == NULL) {
                DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            RegistryInfo->SetDiskInfo(NewDisk);
        }
    }

    delete NewInfo;

    if (Modified) {
        //
        // Commit these changes to the Disk key
        //
        DISKLOG(("DiskSetFullFtSetInfo: committing changes to registry\n"));
        Status = RegistryInfo->CommitRegistryData();
    } else {
        DISKLOG(("DiskSetFullFtSetInfo: no changes detected\n"));
        Status = ERROR_SUCCESS;
    }

    return(Status);
}


DWORD
DiskDeleteFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN LPCWSTR lpszMemberList
    )
/*++

Routine Description:

    Deletes any FT set information for the specified members. This is
    used when a mirror set is broken.

Arguments:

    FtInfo - supplies the FT information

    lpszMemberList - Supplies the list of members whose FT information is to
        be deleted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CFtInfo *OriginalInfo;
    DWORD Signature;
    LPCWSTR lpszSignature;
    DWORD MultiSzLength;
    CFtInfoFtSet *FtSetInfo;
    DWORD i;
    BOOL Modified = FALSE;
    DWORD Status;

    OriginalInfo = (CFtInfo *)FtInfo;
    MultiSzLength = ClRtlMultiSzLength(lpszMemberList);

    //
    // Go through each disk in the MultiSzLength and remove any FT information
    // for it.
    //
    for (i=0; ; i++) {
        lpszSignature = ClRtlMultiSzEnum(lpszMemberList,
                                         MultiSzLength,
                                         i);
        if (lpszSignature == NULL) {
            break;
        }
        Signature = wcstoul(lpszSignature, NULL, 16);
        DISKLOG(("DiskDeleteFullFtSetInfo: deleting member %1!08lx!\n", Signature));

        FtSetInfo = OriginalInfo->FindFtSetInfo(Signature);
        if (FtSetInfo == NULL) {
            DISKLOG(("DiskDeleteFullFtSetInfo: member %08lx is not in any FT set\n", Signature));
        } else {
            DISKLOG(("DiskDeleteFullFtSetInfo: member %08lx found. \n", Signature));
            Modified = TRUE;
            OriginalInfo->DeleteFtSetInfo(FtSetInfo);
        }
    }

    if (Modified) {
        //
        // Commit these changes to the Disk key
        //
        DISKLOG(("DiskDeleteFullFtSetInfo: committing changes to registry\n"));
        Status = OriginalInfo->CommitRegistryData();
    } else {
        DISKLOG(("DiskDeleteFullFtSetInfo: no changes detected\n"));
        Status = ERROR_SUCCESS;
    }

    return(Status);
}


VOID
DiskMarkFullFtSetDirty(
    IN PFULL_FTSET_INFO FtSet
    )
/*++

Routine Description:

    Changes the FT set information so that when it is mounted by FTDISK
    the redundant information will be regenerated. This is necessary because
    FTDISK only looks at the FT_REGISTRY dirty bit at boot time. By doing
    this, we simulate a per-FT Set dirty bit that FT will respect when
    sets are brought online after boot.

    Magic algorithm from norbertk:
        If (and only if) the entire FT set is healthy
            If the set is a mirror
                set state of second member to SyncRedundantCopy
            If the set is a SWP
                set state of first member to SyncRedundantCopy

Arguments:

    FtSet - Supplies the FT set information returned from DiskGetFullFtSetInfo

Return Value:

    None.

--*/

{
    DWORD i;
    CFtInfo *Info;
    CFtInfoFtSet *FtSetInfo;
    CFtInfoPartition *Partition;
    USHORT FtType;

    Info = new CFtInfo((PDISK_CONFIG_HEADER)FtSet);
    if (Info == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return; // [REENGINEER] we avoided an AV but the caller won't know
    }

    FtSetInfo = Info->EnumFtSetInfo(0);
    if (FtSetInfo != NULL) {
        //
        // Check all the members to see if they are all healthy.
        //
        for (i=0; ; i++) {
            Partition = FtSetInfo->GetMemberByIndex(i);
            if (Partition == NULL) {
                break;
            } else {
                if (Partition->m_PartitionInfo->FtState != Healthy) {
                    break;
                }
            }
        }
        if (Partition == NULL) {
            //
            // All the members are marked healthy. Set one of them to
            // SyncRedundantCopy to force a regen.
            //
            FtType = FtSetInfo->GetType();
            if ((FtType == Mirror) || (FtType == StripeWithParity)) {
                if (FtType == Mirror) {
                    Partition = FtSetInfo->GetMemberByIndex(1);
                } else {
                    Partition = FtSetInfo->GetMemberByIndex(0);
                }
                if ( Partition != NULL ) {
                    Partition->m_PartitionInfo->FtState = SyncRedundantCopy;
                }

                //
                // Get the modified FT data
                //
                Info->GetData((PDISK_CONFIG_HEADER)FtSet);
            }
        }
    }

    delete Info;
}


PFULL_DISK_INFO
DiskGetFullDiskInfo(
    IN PFT_INFO DiskInfo,
    IN DWORD Signature,
    OUT LPDWORD pSize
    )
/*++

Routine Description:

    Serializes the complete information from a disk in a form
    suitable for saving to a file or the registry. These bits can
    be restored with DiskSetFullDiskInfo.

Arguments:

    DiskInfo - supplies the disk information.

    Signature - Supplies the signature.

    pSize - Returns the size of the disk information in bytes.

Return Value:

    A pointer to the serializable disk information if successful.

    NULL on error

--*/

{
    PDISK_CONFIG_HEADER DiskConfig;
    DWORD Length;
    CFtInfo *OriginalInfo;
    CFtInfo *NewInfo;
    CFtInfoDisk *FtDiskInfo;
    CFtInfoDisk *NewDiskInfo;

    OriginalInfo = (CFtInfo *)DiskInfo;

    //
    // First, try to find a disk that matches the supplied signature.
    //
    DISKLOG(("DiskGetFullDiskInfo: looking for signature %08lx\n", Signature));

    FtDiskInfo = OriginalInfo->FindDiskInfo(Signature);
    if (FtDiskInfo == NULL) {
        DISKLOG(("DiskGetFullDiskInfo: signature %08lx not found\n", Signature));
        SetLastError(ERROR_INVALID_DATA);
        return(NULL);
    }

    //
    // Create a new CFtInfo that contains no disk information.
    //
    NewInfo = new CFtInfo((CFtInfoFtSet *)NULL);
    if (NewInfo == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    NewDiskInfo = new CFtInfoDisk(FtDiskInfo);
    if (NewDiskInfo == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // Disk info already exists. Use that data.
    //
    NewInfo->SetDiskInfo(NewDiskInfo);

    //
    // Get the disk data
    //
    *pSize = NewInfo->GetSize();

    DiskConfig = (PDISK_CONFIG_HEADER)LocalAlloc(LMEM_FIXED, *pSize);
    if (DiskConfig == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    NewInfo->GetData(DiskConfig);
    delete NewInfo;
    return((PFULL_DISK_INFO)DiskConfig);

} // DiskGetFullDiskInfo



DWORD
DiskSetFullDiskInfo(
    IN PFT_INFO DiskInfo,
    IN PFULL_DISK_INFO Bytes
    )

/*++

Routine Description:

    Restores the complete information from a disk to the DISK
    key in the registry. The disk information must have been
    returned from DiskGetFullDiskInfo.

Arguments:

    DiskInfo - supplies the disk information

    Bytes - Supplies the information returned from DiskGetFullDiskInfo.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise

--*/

{
    CFtInfo *RegistryInfo;
    CFtInfo *NewInfo;
    CFtInfoDisk *OldDisk=NULL;
    CFtInfoDisk *NewDisk=NULL;
    CFtInfoDisk *Disk;
    DWORD Status;

    RegistryInfo = (CFtInfo *)DiskInfo;
    NewInfo = new CFtInfo((PDISK_CONFIG_HEADER)Bytes);
    if (NewInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    DISKASSERT(NewInfo->EnumFtSetInfo(0) == NULL); // No FT sets
    DISKASSERT(NewInfo->EnumDiskInfo(1) == NULL);  // No more than 1 disk

    //
    // There is no FT set in the new registry. This will happen if a mirror
    // set gets broken. For each member in the new information, delete any
    // FT sets that it is a part of and merge it into the registry.
    //
    Disk = NewInfo->EnumDiskInfo(0);
    if ( Disk == NULL ) {
        DISKLOG(("DiskSetFullDiskInfo: no disks detected\n"));
        return(ERROR_SUCCESS);
    }

    //
    // Remove old data containing this signature
    //
    OldDisk = RegistryInfo->FindDiskInfo(Disk->m_Signature);
    if (OldDisk != NULL) {
        RegistryInfo->DeleteDiskInfo(Disk->m_Signature);
    }

    //
    // Set the disk information for this disk into the registry.
    //
    NewDisk = new CFtInfoDisk(Disk);
    if (NewDisk == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RegistryInfo->SetDiskInfo(NewDisk);

    delete NewInfo;

    //
    // Commit these changes to the Disk key
    //
    DISKLOG(("DiskSetFullDiskInfo: committing changes to registry\n"));
    Status = RegistryInfo->CommitRegistryData();

    return(Status);

} // DiskSetFullDiskInfo

PFT_INFO
DiskGetFtInfoFromFullDiskinfo(
    IN PFULL_DISK_INFO Bytes
    )
{
   CFtInfo* DiskInfo = new CFtInfo((PDISK_CONFIG_HEADER)Bytes);
   if (DiskInfo) {
      SetLastError(ERROR_SUCCESS);
   } else {
      SetLastError(ERROR_OUTOFMEMORY);
   }

   return reinterpret_cast<PFT_INFO>(DiskInfo);
} // DiskGetFtInfoFromFullDiskinfo //


DWORD
DiskAddDiskInfoEx(
    IN PFT_INFO DiskInfo,
    IN DWORD DiskIndex,
    IN DWORD Signature,
    IN DWORD Options
    )

/*++

Routine Description:

    Adds an NT4 style DISK registry entry for the specified
    disk. Used to handle new disks being added to the system
    after the cluster service has started. On NT4, windisk would
    have been run to configure the disk and generate an entry
    in the DISK key. On NT5, the DISK is no longer maintained by
    the disk stack; most of the code in this module depends on
    windisk maintaining this key. For NT5,

Arguments:

    DiskIndex - the physical drive number for the new drive

    Signature - the signature of the drive; used for sanity checking

    Options - 0 or combination of the following:

        DISKRTL_REPLACE_IF_EXISTS: Replace the information for the
                                   disk if it is already exists

        DISKRTL_COMMIT: If this flag is set then registry key System\DISK
                        is updated with a new information
Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise

--*/

{
    DWORD status = ERROR_SUCCESS;
    CFtInfo * diskInfo;
    CFtInfoDisk * newDisk, * oldDisk;
    WCHAR physDriveBuff[100];
    HANDLE hDisk;
    PDRIVE_LAYOUT_INFORMATION driveLayout;

    diskInfo = (CFtInfo *)DiskInfo;

    //
    // read in the drive layout data for this new drive
    //

    (VOID) StringCchPrintf( physDriveBuff,
                            RTL_NUMBER_OF(physDriveBuff),
                            TEXT("\\\\.\\PhysicalDrive%d"),
                            DiskIndex );

    hDisk = CreateFile(physDriveBuff,
                       GENERIC_READ,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hDisk == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    if (ClRtlGetDriveLayoutTable( hDisk, &driveLayout, NULL )) {
        //
        // make sure signatures line up and that a
        // description for this disk doesn't already exist
        //
        if ( Signature == driveLayout->Signature ) {

            oldDisk = diskInfo->FindDiskInfo(Signature);

            if (oldDisk != NULL) {
               if (Options & DISKRTL_REPLACE_IF_EXISTS) {
                  diskInfo->DeleteDiskInfo(Signature);
                  oldDisk = NULL;
               }
            }
            if ( oldDisk == NULL ) {

                //
                // Pull in a copy of the existing data in the registry
                // and initialize a new disk and its associated partitions.
                //

                newDisk = new CFtInfoDisk( driveLayout );

                if ( newDisk != NULL ) {

                    //
                    // add the disk to the current database and
                    // commit the updated database to the registry
                    //
                    diskInfo->AddDiskInfo( newDisk );
                    if (Options & DISKRTL_COMMIT) {
                       status = diskInfo->CommitRegistryData();
                    } else {
                       status = ERROR_SUCCESS;
                    }
                } else {
                    status = ERROR_OUTOFMEMORY;
                }
            } else {
                status = ERROR_ALREADY_EXISTS;
            }
        } else {
            status = ERROR_INVALID_PARAMETER;
        }
        LocalFree( driveLayout );
    } else {
       status = GetLastError();
    }

    CloseHandle( hDisk );

    return status;

} // DiskAddDiskEx

DWORD
DiskAddDriveLetterEx(
    IN PFT_INFO DiskInfo,
    IN DWORD Signature,
    IN LARGE_INTEGER StartingOffset,
    IN LARGE_INTEGER PartitionLength,
    IN UCHAR DriveLetter,
    IN DWORD Options
    )

/*++

Routine Description:

    Add a drive letter to the specified partition

Arguments:

    Signature - the signature of the drive; used for sanity checking

    StartingOffset
    PartitionLength - describes which partition

    DriveLetter - letter to be associated with this partition

    Options - if DISKRTL_COMMIT flag is set then registry System\DISK
              is immedately updated with a new information

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise

--*/

{
    DWORD status;
    CFtInfo * diskInfo;
    CFtInfoPartition * partInfo;

    diskInfo = (CFtInfo *)DiskInfo;

    partInfo = diskInfo->FindPartition( Signature, StartingOffset, PartitionLength );

    if ( partInfo != NULL ) {
        partInfo->MakeSticky( DriveLetter );
        if (Options & DISKRTL_COMMIT) {
           status = diskInfo->CommitRegistryData();
        } else {
           status = ERROR_SUCCESS;
        }
    } else {
        status = ERROR_INVALID_PARAMETER;
    }

    return status;
}

DWORD
DiskCommitFtInfo(
    IN PFT_INFO FtInfo
    )
{
    CFtInfo * info = reinterpret_cast<CFtInfo*>( FtInfo );
    DWORD     status = info->CommitRegistryData();

    return status;
}

PFT_DISK_INFO
FtInfo_GetFtDiskInfoBySignature(
    IN PFT_INFO FtInfo,
    IN DWORD Signature
    )
/*++

Routine Description:

    Finds an information for a particular drive

Arguments:

    DiskInfo - supplies the disk information

    Signature - describes which drive

Return Value:

    NULL - if not found
    CFtInfoDisk - otherwise

--*/
{
   CFtInfo* Info = reinterpret_cast<CFtInfo *>(FtInfo);
   PFT_DISK_INFO result = reinterpret_cast<PFT_DISK_INFO>(Info->FindDiskInfo(Signature));

   if (result == 0) {
      SetLastError(ERROR_FILE_NOT_FOUND);
   }

   return result;
} // FtInfo_GetFtDiskInfoBySignature //


DISK_PARTITION UNALIGNED *
FtDiskInfo_GetPartitionInfoByIndex(
    IN PFT_DISK_INFO DiskInfo,
    IN DWORD         Index
    )

/*++

Routine Description:

    Get Drive Letter for a partition specified by an offset

Arguments:

    DiskInfo - supplies the disk information

    index - describes which partition (0 based)

Return Value:

    PDISK_PARTITION stucture or NULL

    if return value is NULL, SetLastError value is set as follows:

    ERROR_FILE_NOT_FOUND: if partition cannot be found

    ERROR_INVALID_HANDLE: if partition is found, but m_PartitionInfo is unassigned

--*/
{
   CFtInfoDisk* Info = reinterpret_cast<CFtInfoDisk*>(DiskInfo);
   CFtInfoPartition* Partition = Info->GetPartitionByIndex( Index );

   if (Partition == 0) {
      SetLastError(ERROR_FILE_NOT_FOUND);
      return NULL;
   }

   if (Partition->m_PartitionInfo == 0) {
      SetLastError(ERROR_INVALID_HANDLE);
      return 0;
   }

   return Partition->m_PartitionInfo;

} // FtDiskInfo_GetDriveLetterByIndex //

DWORD
FtDiskInfo_GetPartitionCount(
    IN PFT_DISK_INFO DiskInfo
    )
{
   CFtInfoDisk* Info = reinterpret_cast<CFtInfoDisk*>(DiskInfo);
   return Info->m_PartitionCount;
} // FtDiskInfo_GetPartitionCount //

} // extern C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\arbitrat.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    arbitrat.c

Abstract:

    DiskArbitration, DiskReservationThread

Author:

    Gor Nishanov    (gorn)    5-Jun-1998

Revision History:

   gorn: different arbitration algorithm implemented

--*/

//
// Cannot use DoReserve/Release/BreakReserve from
// filter.c . Because of hold io we won't be
// able to open \Device\HarddiskX\ParitionY device
//

#define DoReserve DoReserve_don_t_use
#define DoRelease DoRelease_don_t_use
#define DoBreakReserve DoBreakReserve_don_t_use

#include "disksp.h"

#include "diskarbp.h"
#include "arbitrat.h"
#include "newmount.h"
#include <strsafe.h>    // Should be included last.

#undef DoReserve
#undef DoRelease
#undef DoBreakReserve

#define LOG_CURRENT_MODULE LOG_MODULE_DISK

#define DISKARB_MAX_WORK_THREADS      1
#define DISKARB_WORK_THREAD_PRIORITY  THREAD_PRIORITY_ABOVE_NORMAL

#define ARBITRATION_ATTEMPTS_SZ L"ArbitrationAttempts"
#define ARBITRATION_SLEEP_SZ    L"ArbitrationSleepBeforeRetry"

#define RESERVATION_TIMER  (1000*RESERVE_TIMER) // Reservation timer in milliseconds      //
                                                // RESERVE_TIMER is defined in diskarbp.h //

#define WAIT_FOR_RESERVATION_TO_BE_RESTORED      (RESERVATION_TIMER + 2000)
#define BUS_SETTLE_TIME                          (2000)
#define FAST_MUTEX_DELAY                         (1000)

#define DEFAULT_SLEEP_BEFORE_RETRY               (500)
#define MIN_SLEEP_BEFORE_RETRY                   (0)
#define MAX_SLEEP_BEFORE_RETRY                   (30000)

#define DEFAULT_ARBITRATION_ATTEMPTS             (5)
#define MIN_ARBITRATION_ATTEMPTS                 (1)
#define MAX_ARBITRATION_ATTEMPTS                 (9)

//
// Variables Local To Arbitration Module
//

static DWORD             ArbitrationAttempts           = DEFAULT_ARBITRATION_ATTEMPTS;
static DWORD             ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;
static CRITICAL_SECTION  ArbitrationLock;
static PCLRTL_WORK_QUEUE WorkQueue = 0;
static BOOLEAN           AllGlobalsInitialized = FALSE;
static UCHAR             NodeName[MAX_COMPUTERNAME_LENGTH + 1];

enum { NAME_LENGTH = min(MAX_COMPUTERNAME_LENGTH,
                         sizeof ( ((PARBITRATION_ID)0)->NodeSignature ) ) };

DWORD
ArbitrateOnce(
    IN PDISK_RESOURCE ResourceEntry,
    IN HANDLE         FileHandle,
    LPVOID            buf
    );

DWORD
VerifySectorSize(
      IN OUT PDISK_RESOURCE ResourceEntry,
      IN HANDLE             FileHandle
      );

DWORD
DoReadWrite(
      IN PDISK_RESOURCE ResourceEntry,
      IN ULONG Operation,
      IN HANDLE FileHandle,
      IN DWORD BlockNumber,
      IN PVOID Buffer
      );

DWORD
DiskReservationThread(
    IN PDISK_RESOURCE ResourceEntry
    );

VOID
ReadArbitrationParameters(
    VOID
    );

DWORD
AsyncCheckReserve(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

DWORD
DoArbEscape(
    IN PDISK_RESOURCE  ResourceEntry,
    IN HANDLE FileHandle,
    IN ULONG Operation,
    IN PWCHAR OperationName,
    IN PVOID OutBuffer,
    IN ULONG OutBufferSize
    );


#define DoBlockRead(RE,FH,BN,BUF)  DoReadWrite(RE, AE_READ, FH, BN, BUF)
#define DoBlockWrite(RE,FH,BN,BUF) DoReadWrite(RE, AE_WRITE, FH, BN, BUF)
#define DoReserve(FH,RE)         DoArbEscape(RE,FH,AE_RESERVE,L"Reserve",NULL,0)
#define DoRelease(FH,RE)         DoArbEscape(RE,FH,AE_RELEASE,L"Release",NULL,0)
#define DoBreakReserve(FH,RE)    DoArbEscape(RE,FH,AE_RESET,L"BusReset",NULL,0)
#define GetSectorSize(RE,FH,buf) DoArbEscape(RE,FH,AE_SECTORSIZE,L"GetSectorSize",buf,sizeof(ULONG) )
#define PokeDiskStack(RE,FH)     DoArbEscape(RE,FH,AE_POKE,L"GetPartInfo",NULL,0)


#define OldFashionedRIP(ResEntry) \
  ( ( (ResEntry)->StopTimerHandle != NULL) || ( (ResEntry)->DiskInfo.ControlHandle != NULL) )

/**************************************************************************************/

VOID
ArbitrationInitialize(
      VOID
      )
/*++
Routine Description:
  To be called from DllProcessAttach
Arguments:
Return Value:
--*/

{
   InitializeCriticalSection( &ArbitrationLock );

   //
   // Read ArbitrationAttempts and ArbitratationSleepBeforeRetry from the registry
   //
   ReadArbitrationParameters();
}

VOID
ArbitrationCleanup(
      VOID
      )
/*++
Routine Description:
  To be called from DllProcessDetach
Arguments:
Return Value:
--*/
{
   DeleteCriticalSection( &ArbitrationLock );
}


VOID
DestroyArbWorkQueue(
    VOID
    )
/*++
Routine Description:
  To be called from DllProcessDetach
Arguments:
Return Value:
--*/
{
   if (WorkQueue) {
      ClRtlDestroyWorkQueue(WorkQueue);
      WorkQueue = NULL;
   }
}

DWORD
CreateArbWorkQueue(
      IN RESOURCE_HANDLE ResourceHandle
      )
/*++
Routine Description:
Arguments:
Return Value:
--*/
{
   if (WorkQueue) {
      return ERROR_SUCCESS;
   }
   //
   // Create a work queue to process overlapped I/O completions
   //
   WorkQueue = ClRtlCreateWorkQueue(
                            DISKARB_MAX_WORK_THREADS,
                            DISKARB_WORK_THREAD_PRIORITY
                   );

   if (WorkQueue == NULL) {
       DWORD status = GetLastError();
       (DiskpLogEvent)(
           ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] Unable to create work queue. Error: %1!u!.\n",
           status );
       return status;
   }
   return ERROR_SUCCESS;
}

DWORD ArbitrationInitializeGlobals(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++
Routine Description:
   Additional initialization of global variables.
   The ones that might fail and we want to
   to log the failure.

   Otherwise we could have just added the stuff we are doing here
   to ArbitrationInitialize which is called from DllEntryPoint.

   Currently we are using it only to initialize ArbitrationWork queue.

   Called with ArbitrationLock held
Arguments:
Return Value:
--*/
{
   DWORD status;
   DWORD NameSize;

   NameSize = sizeof(NodeName);
   RtlZeroMemory(NodeName, NameSize);
   if( !GetComputerNameA( NodeName, &NameSize ) ) {
      status = GetLastError();
      (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_ERROR,
          L"[DiskArb] GetComputerName failed, error %1!u!.\n", status);
      return status;
   }

   AllGlobalsInitialized = TRUE;
   return ERROR_SUCCESS;
}

DWORD
ArbitrationInfoInit(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
{
   DWORD status = ERROR_SUCCESS;
   EnterCriticalSection( &ArbitrationLock );
    if (!AllGlobalsInitialized) {
       status = ArbitrationInitializeGlobals(ResourceEntry);
    }
   LeaveCriticalSection( &ArbitrationLock );
   if(status != ERROR_SUCCESS) {
      return status;
   }

   InitializeCriticalSection( &(ResourceEntry->ArbitrationInfo.DiskLock) );
   return ERROR_SUCCESS;
}

VOID
ArbitrationInfoCleanup(
   IN OUT PDISK_RESOURCE ResourceEntry
   )
{
   (DiskpLogEvent)(
       ResourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"[DiskArb] ArbitrationInfoCleanup.\n");
   DeleteCriticalSection( &(ResourceEntry->ArbitrationInfo.DiskLock) );
   return;
}

#if 0
BOOL
DoesNotNeedExpensiveReservations(
    IN  PDISK_RESOURCE ResourceEntry)
{
    return (ResourceEntry->LostQuorum) == NULL;
}
#endif

void
ComputeArbitrationId(
      IN  PDISK_RESOURCE ResourceEntry,
      OUT PARBITRATION_ID UniqueId
      )
/*++

Routine Description:
Arguments:
Return Value:

--*/
{
      RtlZeroMemory(UniqueId, sizeof(ARBITRATION_ID));
      GetSystemTimeAsFileTime( (LPFILETIME) &(UniqueId->SystemTime) );
      RtlCopyMemory(UniqueId->NodeSignature, NodeName, NAME_LENGTH );
} // ComputeArbitrationId //



DWORD
ArbitrateOnce(
    IN PDISK_RESOURCE ResourceEntry,
    IN HANDLE         FileHandle,
    LPVOID            buf
    )

/*++

Routine Description:

    Perform full arbitration for a disk. Once arbitration has succeeded,
    a thread is started that will keep reservations on the disk.

Arguments:

    ResourceEntry - the disk info structure for the disk.

    FileHandle - the file handle to use for arbitration.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   status;
    ARBITRATION_ID  id, old_y, empty;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] Read the partition info to insure the disk is accessible.\n");
    PokeDiskStack(ResourceEntry, FileHandle);

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] Arbitrate for ownership of the disk by reading/writing various disk sectors.\n");

    ComputeArbitrationId(ResourceEntry, &id);
    RtlZeroMemory( &empty, sizeof(empty) );
    RtlZeroMemory( &old_y, sizeof(old_y) );
    status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);

    if (  (status == ERROR_SUCCESS)
       && ( (0 == memcmp(&empty, buf, sizeof(empty)) ) // clean release
            ||(0 == memcmp(&id.NodeSignature,
                         &(((PARBITRATION_ID)buf)->NodeSignature),
                         sizeof(id.NodeSignature) ) ) // we dropped this disk
          )
       )
    {
        // Disk was voluntary released
        // or we are picking up the disk that was dropped by us
        // and nobody was using it while we were away
        //
        // => Fast Arbitration
        CopyMemory( &old_y ,buf, sizeof(old_y) );
        goto FastMutex;
    }

    if (status != ERROR_SUCCESS) {
        // Breaker //
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"[DiskArb] We are about to break reserve.\n");
        status = DoBreakReserve( FileHandle, ResourceEntry );
        if( ERROR_SUCCESS != status ) {
            (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                           LOG_ERROR,
                           L"[DiskArb] Failed to break reservation, error %1!u!.\n",
                           status
                           );
            return status;
        }
        Sleep( BUS_SETTLE_TIME );
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"[DiskArb] Read the partition info from the disk to insure disk is accessible.\n");
        PokeDiskStack(ResourceEntry, FileHandle);
#if 0
        status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
#else
        CopyMemory(buf, &id, sizeof(id)); id.SeqNo.QuadPart ++;
        status = DoBlockWrite(ResourceEntry, FileHandle, BLOCK_Y, buf);
#endif
        if(status != ERROR_SUCCESS) { return status; }
    } else {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"[DiskArb] No reservation found. Read'n'wait.\n");
        Sleep( BUS_SETTLE_TIME ); // so that reader would not get an advantages
    }
    CopyMemory(&old_y, buf, sizeof(ARBITRATION_ID));

    Sleep( WAIT_FOR_RESERVATION_TO_BE_RESTORED );
    status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
    if(status != ERROR_SUCCESS) { return status; }
    if( 0 == memcmp(&empty, buf, sizeof(ARBITRATION_ID)) ) {;} else
    if( 0 != memcmp(&old_y, buf, sizeof(ARBITRATION_ID)) ) { return ERROR_QUORUM_OWNER_ALIVE; }
    // Fast Mutex Code //

FastMutex:
    //  write(x, id) //
    CopyMemory(buf, &id, sizeof(id));
    status = DoBlockWrite(ResourceEntry, FileHandle, BLOCK_X, buf);
    if(status != ERROR_SUCCESS) { return status; }

    //  if(y != old_y && y != empty) return FALSE; //
    status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
    if(status != ERROR_SUCCESS) { return status; }

    if( 0 == memcmp(&empty, buf, sizeof(ARBITRATION_ID)) ) {;} else
    if( 0 != memcmp(&old_y, buf, sizeof(ARBITRATION_ID)) ) { return ERROR_QUORUM_OWNER_ALIVE; }

    // write(y, id) //
    CopyMemory(buf, &id, sizeof(id));
    status = DoBlockWrite(ResourceEntry, FileHandle, BLOCK_Y, buf);
    if(status != ERROR_SUCCESS) { return status; }

    // if(x != id) ...
    status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_X, buf);
    if(status != ERROR_SUCCESS) { return status; }

    if( 0 != memcmp(&id, buf, sizeof(ARBITRATION_ID)) ) {
        Sleep(FAST_MUTEX_DELAY);

        // if(y == 0) goto FastMutex //
        // if(y != id) return FALSE //
        status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
        if(status != ERROR_SUCCESS) { return status; }
        if( 0 == memcmp(&empty, buf, sizeof(ARBITRATION_ID)) ) {
            RtlZeroMemory( &old_y, sizeof(old_y) );
            goto FastMutex;
        }
        if( 0 != memcmp(&id, buf, sizeof(ARBITRATION_ID)) ) { return ERROR_QUORUM_OWNER_ALIVE; }
    }

    status = StartPersistentReservations(ResourceEntry, FileHandle);
    return(status);

} // ArbitrateOnce //


DWORD
DiskArbitration(
    IN PDISK_RESOURCE ResourceEntry,
    IN HANDLE     FileHandle
    )

/*++

Routine Description:

    Perform arbitration for a disk. Once arbitration has succeeded,
    a thread is started that will keep reservations on the disk.
    If arbitration fails, the routine will retry to arbitrate in ArbitratationSleepBeforeRetry
    milliseconds. A number of arbitration attempts is controlled by ArbitrationAttempts variable.

    ArbitrationAttempts and ArbitratationSleepBeforeRetry are read from the registry on
    start up.

Arguments:

    ResourceEntry - the disk info structure for the disk.

    FileHandle - the file handle to use for arbitration.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   status;
    int     repeat;
    LPVOID  unalignedBuf = 0;
    LPVOID  buf = 0;

    __try {
        (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"[DiskArb] Arbitration Parameters: ArbAttempts %1!u!,  SleepBeforeRetry %2!u! ms.\n",
                        ArbitrationAttempts, ArbitratationSleepBeforeRetry);
        EnterCriticalSection( &(ResourceEntry->ArbitrationInfo.DiskLock) );

        //
        // If we already are performing reservations, then just leave now.
        //
        if ( ReservationInProgress(ResourceEntry) ) {
            status = ERROR_SUCCESS;
            __leave;
        }
        status = VerifySectorSize(ResourceEntry, FileHandle);
        if ( status != ERROR_SUCCESS ) {
            // VerifySectorSize logs an error //
            __leave;
        }

        unalignedBuf = LocalAlloc(LPTR, ResourceEntry->ArbitrationInfo.SectorSize * 2);
        if( unalignedBuf == 0 ) {
            status = GetLastError();
            (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                           LOG_ERROR,
                           L"[DiskArb] Failed to allocate arbitration buffer X, error %1!u!.\n", status );
            __leave;
        }
        // Alignment code assumes that ResourceEntry->ArbitrationInfo.SectorSize is the power of two //
        buf = (LPVOID)( ((ULONG_PTR)unalignedBuf + ResourceEntry->ArbitrationInfo.SectorSize
                       ) & ~((ULONG_PTR)(ResourceEntry->ArbitrationInfo.SectorSize - 1))
                     );

        repeat = ArbitrationAttempts;
        for(;;) {
            status = ArbitrateOnce(ResourceEntry, FileHandle, buf);
            if(status == ERROR_SUCCESS) {
                break;
            }
            if(--repeat <= 0) {
                break;
            }
            Sleep(ArbitratationSleepBeforeRetry);

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_WARNING,
                L"[DiskArb] Retry arbitration, %1!u! attempts left \n", repeat );

        }
        if(status != ERROR_SUCCESS) {
            __leave;
        }

        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"[DiskArb] Assume ownership of the device.\n");

    } __finally {
        LeaveCriticalSection( &(ResourceEntry->ArbitrationInfo.DiskLock) );
        if(unalignedBuf) {
            LocalFree(unalignedBuf);
        }
    }

    return(status);

} // DiskArbitration //


DWORD
DoArbEscape(
    IN PDISK_RESOURCE ResourceEntry,
    IN HANDLE FileHandle,
    IN ULONG Operation,
    IN PWCHAR OperationName,
    IN PVOID OutBuffer,
    IN ULONG OutBufferSize
    )
{
    DWORD bytesReturned;
    DWORD status;
    DWORD LogLevel = LOG_INFORMATION;
    ARBITRATION_READ_WRITE_PARAMS params;

    params.Operation  = Operation;
    params.SectorSize = 0;
    params.SectorNo   = 0;
    params.Buffer     = 0;
    params.Signature  = ResourceEntry->DiskInfo.Params.Signature;

    (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                     LOG_INFORMATION,
                     L"[DiskArb] Issuing %1!ws! on signature %2!x!.\n",
                     OperationName,
                     params.Signature );

    status = DeviceIoControl( FileHandle,
                              IOCTL_DISK_CLUSTER_ARBITRATION_ESCAPE,
                              &params,
                              sizeof(params),
                              OutBuffer,
                              OutBufferSize,
                              &bytesReturned,
                              FALSE );

    if( status == FALSE) {
        status = GetLastError();
        LogLevel = LOG_ERROR;
    } else {
        status = ERROR_SUCCESS;
    }
    (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                     LogLevel,
                     L"[DiskArb] %1!ws! completed, status %2!u!.\n",
                     OperationName, status );
    return status;
}

DWORD
DoReadWrite(
      IN PDISK_RESOURCE ResourceEntry,
      IN ULONG Operation,
      IN HANDLE FileHandle,
      IN DWORD BlockNumber,
      IN PVOID Buffer
      )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   DWORD bytesReturned;
   DWORD status;
   PWCHAR opname = (Operation == AE_READ)?L"read ":L"write";
   ARBITRATION_READ_WRITE_PARAMS params;

   params.Operation = Operation;
   params.SectorSize = ResourceEntry->ArbitrationInfo.SectorSize;
   params.SectorNo = BlockNumber;
   params.Buffer = Buffer;
   params.Signature = ResourceEntry->DiskInfo.Params.Signature;

   status = DeviceIoControl( FileHandle,
                             IOCTL_DISK_CLUSTER_ARBITRATION_ESCAPE,
                             &params,
                             sizeof(params),
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE );

   if( status == 0) {
      status = GetLastError();
      (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"[DiskArb] Failed to %1!ws! (sector %2!u!), error %3!u!.\n",
                      opname,
                      BlockNumber,
                      status );
      return status;
   } else {
#if 0
      (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                       LOG_INFORMATION,
                       L"[DiskArb] Successful %1!ws! (sector %2!u!).\n",
                       opname,
                       BlockNumber,
#else
      WCHAR buf[64];
      mbstowcs(buf, ((PARBITRATION_ID)Buffer)->NodeSignature, sizeof(((PARBITRATION_ID)Buffer)->NodeSignature));
      (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                       LOG_INFORMATION,
                       L"[DiskArb] Successful %1!ws! (sector %2!u!) [%3!ws!:%4!u!] (%5!x!,%6!08x!:%7!08x!).\n",
                       opname,
                       BlockNumber,
                       buf,
                       ((PARBITRATION_ID)Buffer)->SeqNo.LowPart,
                       ((PARBITRATION_ID)Buffer)->SeqNo.HighPart,
                       ((PARBITRATION_ID)Buffer)->SystemTime.LowPart,
                       ((PARBITRATION_ID)Buffer)->SystemTime.HighPart
                     );
#endif
   }
   return ERROR_SUCCESS;
} // DoReadWrite //


DWORD
VerifySectorSize(
      IN OUT PDISK_RESOURCE ResourceEntry,
      IN HANDLE             FileHandle
      )

/*++

Routine Description:

    The routine checks whether
    a ResourceEntry->ArbitrationInfo.SectorSize has a value assigned to it.
    If ResourceEntry->ArbitrationInfo.SectorSize is 0 then the routine tries
    to obtain a correct sector size using GetDriveGeometry IOCTL.

Arguments:

Return Value:

    ERROR_SUCCESS
      or
    Error Code returned by IOCTL_DISK_GET_DRIVE_GEOMETRY

Comment:

    The routine always succeeds. If it cannot obtain
    disk geometry it will use a default sector size.

--*/

{
    DWORD status;
    DWORD sectorSize;

    if (ResourceEntry->ArbitrationInfo.SectorSize)
    {
        return ERROR_SUCCESS;
    }

    (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                     LOG_INFORMATION,
                     L"[DiskArb] Read disk geometry to get the sector size.\n" );
    status = GetSectorSize(ResourceEntry, FileHandle, &sectorSize);
    if (status == ERROR_SUCCESS) {
        ResourceEntry->ArbitrationInfo.SectorSize = sectorSize;
    } else {
        ResourceEntry->ArbitrationInfo.SectorSize = DEFAULT_SECTOR_SIZE;
        // GetDiskGeometry logs an error //
        return status;
    }

    // ArbitrationInfo.SectorSize should be at least 64 bytes //
    if( ResourceEntry->ArbitrationInfo.SectorSize < sizeof(ARBITRATION_ID) ) {
        (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] ArbitrationInfo.SectorSize is too small %1!u!\n", ResourceEntry->ResourceHandle);
        ResourceEntry->ArbitrationInfo.SectorSize = DEFAULT_SECTOR_SIZE;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // ArbitrationInfo.SectorSize should be a power of two //
    if( (ResourceEntry->ArbitrationInfo.SectorSize & (ResourceEntry->ArbitrationInfo.SectorSize - 1)) != 0 ) {
        (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] ArbitrationInfo.SectorSize is not a power of two %1!u!\n", ResourceEntry->ResourceHandle);
        ResourceEntry->ArbitrationInfo.SectorSize = DEFAULT_SECTOR_SIZE;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] ArbitrationInfo.SectorSize is %1!u!\n", ResourceEntry->ArbitrationInfo.SectorSize);
    return ERROR_SUCCESS;
} // VerifySectorSize //


VOID
ReadArbitrationParameters(
    VOID
    )
/*++

Routine Description:

   Reads

      DWORD ArbitrationAttempts           = DEFAULT_ARBITRATION_ATTEMPTS;
      DWORD ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;

   from the registry

Arguments:

   NONE

Return Value:

   NONE

--*/
{
    DWORD status;
    HKEY  key;
    DWORD size;

    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           L"Cluster",
                           0,
                           KEY_READ,
                           &key );

    if ( status != ERROR_SUCCESS ) {
        ArbitrationAttempts           = DEFAULT_ARBITRATION_ATTEMPTS;
        ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;
        return;
    }
    size = sizeof(ArbitrationAttempts);
    status = RegQueryValueEx(key,
                             ARBITRATION_ATTEMPTS_SZ,
                             0,
                             NULL,
                             (LPBYTE)&ArbitrationAttempts,
                             &size);

    if(status != ERROR_SUCCESS) {
       ArbitrationAttempts = DEFAULT_ARBITRATION_ATTEMPTS;
    }
    if(ArbitrationAttempts < MIN_ARBITRATION_ATTEMPTS
    || ArbitrationAttempts > MAX_ARBITRATION_ATTEMPTS)
    {
       ArbitrationAttempts = DEFAULT_ARBITRATION_ATTEMPTS;
    }

    size = sizeof(ArbitratationSleepBeforeRetry);
    status = RegQueryValueEx(key,
                             ARBITRATION_SLEEP_SZ,
                             0,
                             NULL,
                             (LPBYTE)&ArbitratationSleepBeforeRetry,
                             &size);

    if(status != ERROR_SUCCESS) {
       ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;
    }
    //
    // Removed this part of the check:
    //      ArbitratationSleepBeforeRetry < MIN_SLEEP_BEFORE_RETRY
    // as DWORD/ULONG cannot be less than zero and it always evaluated
    // to FALSE.
    //
    if(ArbitratationSleepBeforeRetry > MAX_SLEEP_BEFORE_RETRY)
    {
       ArbitratationSleepBeforeRetry = DEFAULT_SLEEP_BEFORE_RETRY;
    }
    RegCloseKey(key);
} // ReadArbitrationParameters //



VOID
CompletionRoutine(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++
Routine Description:
Arguments:
Return Value:
--*/
{
    PDISK_RESOURCE    ResourceEntry;

    if( IoContext ) {
       ResourceEntry = (PDISK_RESOURCE)IoContext;

       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_INFORMATION,
           L"[DiskArb] CompletionRoutine, status %1!u!.\n", Status);

    } else {
       PARBITRATION_INFO info =  CONTAINING_RECORD(
                                   WorkItem,  // Expr //
                                   ARBITRATION_INFO,
                                   WorkItem); // FieldName //

       ResourceEntry = CONTAINING_RECORD(
                          info,
                          DISK_RESOURCE,
                          ArbitrationInfo);

       (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"[DiskArb] CompletionRoutine starts.\n", Status);
    }

    if (Status == ERROR_SUCCESS) {

        if (ResourceEntry->ArbitrationInfo.StopReserveInProgress) {
           return;
        }
        //
        // Repost the request
        //
        Status = AsyncCheckReserve(ResourceEntry);
        if (Status == ERROR_SUCCESS) {
           return;
        }
    }

    //
    // Some kind of error occurred,
    // but if we are in the middle of StopReserve
    // then everything is fine.
    //
    if (ResourceEntry->ArbitrationInfo.StopReserveInProgress) {
       return;
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        Status == ERROR_OPERATION_ABORTED ? LOG_WARNING : LOG_ERROR,
        L"[DiskArb] CompletionRoutine: reservation lost!  Status %1!u! \n", Status );

    if ( ERROR_OPERATION_ABORTED != Status ) {
        ClusResLogSystemEventByKey(ResourceEntry->ResourceKey,
                                   LOG_CRITICAL,
                                   RES_DISK_RESERVATION_LOST);
    }

    //
    // Callout to cluster service to indicate that quorum has
    // been lost.
    //

    if (ResourceEntry->LostQuorum != NULL) {
        (ResourceEntry->LostQuorum)(ResourceEntry->ResourceHandle);
    }
    ResourceEntry->DiskInfo.FailStatus = Status;
    ResourceEntry->Reserved = FALSE;

    return;

}  // CompletionRoutine //

DWORD
AsyncCheckReserve(
    IN OUT PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to check reserve.
    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    PARBITRATION_INFO Info = &ResourceEntry->ArbitrationInfo;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] Posting request to check reserve progress.\n");

    ClRtlInitializeWorkItem(
        &(Info->WorkItem),
        CompletionRoutine,
        ResourceEntry
        );

    success = DeviceIoControl( Info->ControlHandle,
                               IOCTL_DISK_CLUSTER_ALIVE_CHECK,
                               &Info->InputData,
                               sizeof(Info->InputData),
                               &Info->OutputData,
                               sizeof(Info->OutputData),
                               &bytesReturned,
                               &Info->WorkItem.Overlapped);

    if ( !success ) {
        errorCode = GetLastError();

        if( errorCode == ERROR_IO_PENDING ) {
           (DiskpLogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_INFORMATION,
               L"[DiskArb] ********* IO_PENDING ********** - Request to insure reserves working is now posted.\n");
           return ERROR_SUCCESS;
        }

        if ( ERROR_OPERATION_ABORTED == errorCode ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_WARNING,
                L"[DiskArb] disk reservation thread canceled, status %1!u!.\n",
                errorCode);
        } else {
           (DiskpLogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_ERROR,
               L"[DiskArb] error checking disk reservation thread, error %1!u!.\n",
               errorCode);
        }
        return(errorCode);
    }
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_ERROR,
        L"[DiskArb] Premature completion of check reserve I/O.\n");

    return(ERROR_CAN_NOT_COMPLETE);

} // AsyncCheckReserve


DWORD
StartPersistentReservations(
      IN OUT PDISK_RESOURCE ResourceEntry,
      IN HANDLE             FileHandle
      )
/*++

Routine Description:

    Starts driver level persistent reservations.
    Also starts a user-mode thread to keep an eye on driver level reservations.

Arguments:

    ResourceEntry - the disk info structure for the disk.

    FileHandle - the file handle to use for arbitration.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // If we already are performing reservations, then just leave now.
    //
    if ( ReservationInProgress(ResourceEntry) ) {
        return(ERROR_SUCCESS);
    }

    CL_ASSERT(WorkQueue != NULL);
    VerifySectorSize(ResourceEntry, FileHandle);

    status = DoReserve( FileHandle, ResourceEntry );
    if(status != ERROR_SUCCESS) {
       return status;
    }

    {
         START_RESERVE_DATA params;
         DWORD              paramsSize;

         // Preparing parameters to call StartReserveEx //
         params.DiskSignature     = ResourceEntry->DiskInfo.Params.Signature;
         params.Version           = START_RESERVE_DATA_V1_SIG;
         params.ArbitrationSector = BLOCK_Y;
         params.SectorSize        = ResourceEntry->ArbitrationInfo.SectorSize;
         params.NodeSignatureSize = sizeof(params.NodeSignature);
         RtlZeroMemory(params.NodeSignature, sizeof(params.NodeSignature) );
         RtlCopyMemory(params.NodeSignature, NodeName, NAME_LENGTH );

#if 0
         // When we have a reliable way of determining
         // whether this disk resource is a quorum
         // this code can be enabled
         if ( DoesNotNeedExpensiveReservations(ResourceEntry) ) {
            paramsSize = sizeof( params.DiskSignature );
         } else {
            paramsSize = sizeof( params );
         }
#else
            paramsSize = sizeof( params );
#endif

         status = StartReserveEx( &ResourceEntry->ArbitrationInfo.ControlHandle,
                                  &params,
                                  paramsSize,
                                  ResourceEntry->ResourceHandle );
    }

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[DiskArb] Failed to start driver reservation thread, error %1!u!.\n",
            status );
        DoRelease( FileHandle, ResourceEntry );
        return(status);
    }

    ResourceEntry->ArbitrationInfo.StopReserveInProgress = FALSE;
    status = ClRtlAssociateIoHandleWorkQueue(
                 WorkQueue,
                 ResourceEntry->ArbitrationInfo.ControlHandle,
                 (ULONG_PTR)ResourceEntry
                 );

    if ( status != ERROR_SUCCESS ) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] ClRtlAssociateIoHandleWorkQueue failed, error %1!u!.\n",
           status );
        StopPersistentReservations( ResourceEntry );
        DoRelease( FileHandle, ResourceEntry );
        return(status);
    }

    ClRtlInitializeWorkItem(
        &(ResourceEntry->ArbitrationInfo.WorkItem),
        CompletionRoutine,
        0
        );

    status = ClRtlPostItemWorkQueue(
                 WorkQueue,
                 &ResourceEntry->ArbitrationInfo.WorkItem,
                 0,0);

    if ( status != ERROR_SUCCESS ) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"[DiskArb] ClRtlPostItemWorkQueue failed, error %1!u!.\n",
           status );
        StopPersistentReservations( ResourceEntry );
        DoRelease( FileHandle, ResourceEntry );
        return(status);
    }
    ResourceEntry->Reserved = TRUE;

    return ERROR_SUCCESS;
} // StartPersistentReservations //

DWORD
CleanupArbitrationSector(
    IN PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

Arguments:

    ResourceEntry - the disk info structure for the disk.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    HANDLE  FileHandle = DiskspClusDiskZero;
    DWORD   status;
    LPVOID  unalignedBuf = 0;
    PARBITRATION_ID buf = 0;
    try {
       (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"[ArbCleanup] Verifying sector size. \n" );
       VerifySectorSize(ResourceEntry, FileHandle);

       unalignedBuf = LocalAlloc(LMEM_FIXED, ResourceEntry->ArbitrationInfo.SectorSize * 2);
       if( unalignedBuf == 0 ) {
          status = GetLastError();
          (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                           LOG_ERROR,
                           L"[ArbCleanup] Failed to allocate buffer, error %1!u!.\n", status );
          leave;
       }
       // Alignment code assumes that ResourceEntry->ArbitrationInfo.SectorSize is the power of two //
       buf = (PARBITRATION_ID)
               (
                   ( (ULONG_PTR)unalignedBuf + ResourceEntry->ArbitrationInfo.SectorSize )
                & ~((ULONG_PTR)(ResourceEntry->ArbitrationInfo.SectorSize - 1))
               );
       ZeroMemory(buf, ResourceEntry->ArbitrationInfo.SectorSize);

       (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"[ArbCleanup] Reading arbitration block. \n" );
       status = DoBlockRead(ResourceEntry, FileHandle, BLOCK_Y, buf);
       if (status != ERROR_SUCCESS) { leave; }
       if( 0 != memcmp(buf->NodeSignature, NodeName, NAME_LENGTH) ) {
          //
          // Somebody is challenging us. No need to clean up the sector
          //
          status = ERROR_OPERATION_ABORTED;
          leave;
       }

       ZeroMemory(buf, ResourceEntry->ArbitrationInfo.SectorSize);
       (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"[ArbCleanup] Writing arbitration block. \n" );
       status = DoBlockWrite(ResourceEntry, FileHandle, BLOCK_Y, buf);
       if(status != ERROR_SUCCESS) {
          leave;
       }

    } finally {
       if(unalignedBuf) {
          LocalFree(unalignedBuf);
       }
    }

    (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                     LOG_INFORMATION,
                     L"[ArbCleanup] Returning status %1!u!. \n", status );

    return(status);

} // CleanupArbitrationSector //


VOID
StopPersistentReservations(
      IN OUT PDISK_RESOURCE ResourceEntry
      )
/*++
Routine Description:
Arguments:
Return Value:
--*/
{
    HANDLE localHandle;
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] StopPersistentReservations is called.\n");

    //
    // ReservationInProgress returns current contents of
    // ResourceEntry->ArbitrationInfo.ControlHandle
    //
    localHandle = ReservationInProgress(ResourceEntry);
    if ( localHandle ) {
        DWORD  status;
        HANDLE ExchangeResult;

        ExchangeResult = InterlockedCompareExchangePointer(
            &ResourceEntry->ArbitrationInfo.ControlHandle,
            0,
            localHandle);
        if (ExchangeResult == localHandle) {
            //
            // Only one thread is allowed in here
            //

            ResourceEntry->ArbitrationInfo.StopReserveInProgress = TRUE;

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"[DiskArb] Stopping reservation thread.\n");

            //
            // Close the Control Handle, which stops the reservation thread and
            // dismounts the volume, releases the disk, and marks it offline.
            //
            status = StopReserve( localHandle,
                                  ResourceEntry->ResourceHandle );
            if ( status != ERROR_SUCCESS ) {
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"[DiskArb] Error stopping reservation thread, error %1!u!.\n",
                    status);
            }

            status = CleanupArbitrationSector( ResourceEntry );
            if (status != ERROR_SUCCESS) {
               (DiskpLogEvent)(
                   ResourceEntry->ResourceHandle,
                   LOG_ERROR,
                   L"[DiskArb] Error cleaning arbitration sector, error %1!u!.\n",
                   status);
            }
        }
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] StopPersistentReservations is complete.\n");

    ResourceEntry->ArbitrationInfo.ControlHandle = NULL;
    ResourceEntry->Reserved = FALSE;
    ResourceEntry->LostQuorum = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\disksp.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    disksp.h

Abstract:

    Disks Resource DLL private definitions.

Author:

    Rod Gamache (rodga) 29-Mar-1996

Revision History:

--*/

#include "clusres.h"
#include "ntddscsi.h"
#include "ntddft.h"
#include "clusdisk.h"
#include "clusrtl.h"
#include "diskinfo.h"
#include "clusstor.h"

#define DiskpLogEvent ClusResLogEvent
#define DiskpSetResourceStatus ClusResSetResourceStatus

#define DISKS_PRINT printf
#define FTSET_PRINT printf

#define CLUSDISK_REGISTRY_AVAILABLE_DISKS \
    TEXT("System\\CurrentControlSet\\Services\\ClusDisk\\Parameters\\AvailableDisks")

#define CLUSDISK_REGISTRY_SIGNATURES \
    TEXT("System\\CurrentControlSet\\Services\\ClusDisk\\Parameters\\Signatures")

#define CLUSREG_VALUENAME_MANAGEDISKSONSYSTEMBUSES TEXT("ManageDisksOnSystemBuses")

#define DEVICE_CLUSDISK0    TEXT("\\Device\\ClusDisk0")

#define DISKS_REG_CLUSTER_QUORUM    TEXT("Cluster\\Quorum")
#define DISKS_REG_QUORUM_PATH CLUSREG_NAME_QUORUM_PATH

#define DEVICE_HARDDISK                 TEXT("\\Device\\Harddisk%u")
#define DEVICE_HARDDISK_PARTITION_FMT   TEXT("\\Device\\Harddisk%u\\Partition%u")

//
// This string is needed to convert the \Device\HarddiskX\PartitionY name to
// the Vol{GUID} name.  Note that the trailing backslash is required!
//

#define GLOBALROOT_HARDDISK_PARTITION_FMT   TEXT("\\\\\?\\GLOBALROOT\\Device\\Harddisk%u\\Partition%u\\")


#define UNINITIALIZED_UCHAR     (UCHAR)-1

#define MIN_USABLE_QUORUM_PARTITION_LENGTH  50 * 1000 * 1000    //  50 MB

extern PLOG_EVENT_ROUTINE DiskpLogEvent;
extern HANDLE DiskspClusDiskZero;
//extern PSTR PartitionName;
//extern PSTR DiskName;

typedef struct _ARBITRATION_INFO {
   CLRTL_WORK_ITEM  WorkItem;
   DWORD            SectorSize;
   CRITICAL_SECTION DiskLock;

   DWORD            InputData;
   DWORD            OutputData;

   HANDLE           ControlHandle;    // Moved here from DISK_INFO //
   BOOL             ReservationError; // Moved here from DISK_INFO //
   BOOL             StopReserveInProgress;

   LONG             CheckReserveInProgress;
   DWORD            ArbitrateCount;

} ARBITRATION_INFO, *PARBITRATION_INFO;

typedef struct _MOUNTIE_VOLUME *PMOUNTIE_VOLUME;

typedef struct _MOUNTIE_INFO {
   DWORD           HarddiskNo;
   DWORD           DriveLetters;
   DWORD           NeedsUpdate;
   DWORD           VolumeStructSize;
   PMOUNTIE_VOLUME Volume;
   DWORD           UpdateThreadIsActive;
} MOUNTIE_INFO, *PMOUNTIE_INFO;

typedef struct _DISK_PARAMS {
    DWORD   Signature;
    LPWSTR  SerialNumber;
    LPWSTR  Drive;
    DWORD   SkipChkdsk;
    DWORD   ConditionalMount;
    LPWSTR  MPVolGuids;         // REG_MULTI_SZ string of Volume{GUIDS}
    DWORD   MPVolGuidsSize;     // Number of bytes, not number of WCHARs!
    DWORD   UseMountPoints;
    LPWSTR  VolGuid;
} DISK_PARAMS, *PDISK_PARAMS;

//
// DISK_INFO structures are common to both the physical disk resource
// and the FT set resource. The underlying SCSI/filter driver interfaces
// deal with DISK_INFO structures. Each one represents a physical disk.
//

typedef struct _DISK_INFO {
    LIST_ENTRY ListEntry;
    DISK_PARAMS Params;
    DWORD PhysicalDrive;
    HANDLE  FileHandle;
    DWORD   FailStatus;
} DISK_INFO, *PDISK_INFO;

typedef struct _MOUNTPOINT_INFO {
    DWORD   MPUpdateThreadIsActive;
    CRITICAL_SECTION MPLock;
    BOOL    Initialized;
    DWORD   MPListCreateInProcess;
} MOUNTPOINT_INFO, *PMOUNTPOINT_INFO;

//
// DISK_RESOURCE structures are used by the physical disk resource.
// It encapsulates a DISK_INFO structure that represents the physical
// disk. Each DISK_RESOURCE may contain multiple partitions.
//
typedef struct _DISK_RESOURCE {
    LIST_ENTRY ListEntry;           // Linkage onto list of online disks
    LIST_ENTRY PnpWatchedListEntry; // Lingage onto list of PNP watched disks
    DISK_INFO DiskInfo;
    RESOURCE_HANDLE ResourceHandle;
    HKEY    ResourceKey;
    HKEY    ResourceParametersKey;
    HKEY    ClusDiskParametersKey;
//    HANDLE  StopTimerHandle;
    BOOL    Reserved;
    BOOL    Valid;
    BOOL    Inserted;
    BOOL    Attached;
    CLUS_WORKER  OnlineThread;
    CLUS_WORKER  OfflineThread;
    PQUORUM_RESOURCE_LOST LostQuorum;
    PFULL_DISK_INFO DiskCpInfo;          // returned from DiskGetFullDiskInfo
    DWORD   DiskCpSize;
    MOUNTPOINT_INFO  MPInfo;
    ARBITRATION_INFO ArbitrationInfo;
    MOUNTIE_INFO     MountieInfo;
    BOOL    IgnoreMPNotifications;
} DISK_RESOURCE, *PDISK_RESOURCE;


//
// FTSET_RESOURCE structures are used by the FT set resource.
// It encapsulates a list of DISK_INFO structures that represent
// the physical members of the FT set.
//
typedef struct _FTSET_RESOURCE {
    LIST_ENTRY ListEntry;               // Linkage onto list of online FT sets
    LIST_ENTRY MemberList;
    HANDLE  FtSetHandle;
    HKEY    ResourceKey;
    HKEY    ResourceParametersKey;
    HKEY    ClusDiskParametersKey;
    HANDLE  StopTimerHandle;
    HANDLE  ReservationThread;
    BOOL    Valid;
    BOOL    Attached;
    BOOL    Inserted;
    CLUS_WORKER OnlineThread;
    RESOURCE_HANDLE ResourceHandle;
    DWORD SignatureLength;
    LPWSTR  SignatureList;
    PFULL_FTSET_INFO FtSetInfo;          // returned from DiskGetFullFtSetInfo
    DWORD   FtSetSize;
    PQUORUM_RESOURCE_LOST LostQuorum;
} FTSET_RESOURCE, *PFTSET_RESOURCE;

#define FtRoot(_res_) CONTAINING_RECORD((_res_)->MemberList.Flink,   \
                                        DISK_INFO,                   \
                                        ListEntry)


typedef struct _SCSI_ADDRESS_ENTRY {
    SCSI_ADDRESS        ScsiAddress;
    struct _SCSI_ADDRESS_ENTRY  *Next;
} SCSI_ADDRESS_ENTRY, *PSCSI_ADDRESS_ENTRY;


BOOL
IsVolumeDirty(
    IN UCHAR DriveLetter
    );

#if 0
DWORD
GetSymbolicLink(
    IN PCHAR RootName,
    IN OUT PCHAR ObjectName      // Assumes this points at a MAX_PATH length buffer
    );
#endif
LPWSTR
GetRegParameter(
    IN HKEY RegKey,
    IN LPCWSTR ValueName
    );
#if 0
HANDLE
OpenObject(
    PCHAR   Directory,
    PCHAR   Name
    );
#endif

DWORD
AssignDriveLetters(
    HANDLE  FileHandle,
    PDISK_INFO DiskInfo
    );

DWORD
RemoveDriveLetters(
    HANDLE  FileHandle,
    PDISK_INFO DiskInfo
    );


DWORD
SetDiskState(
    PDISK_RESOURCE ResourceEntry,
    UCHAR NewDiskState
    );

#define GoOnline( ResEntry )    SetDiskState( ResEntry, DiskOnline )
#define GoOffline( ResEntry )   SetDiskState( ResEntry, DiskOffline )

DWORD
DoAttach(
    DWORD Signature,
    RESOURCE_HANDLE ResourceHandle,
    BOOLEAN InstallMode
    );

DWORD
DoDetach(
    DWORD Signature,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
StartReserveEx(
    OUT HANDLE *FileHandle,
    LPVOID InputData,
    DWORD  InputDataSize,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
StopReserve(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    );

DWORD
DiskpSetThreadPriority(
    VOID
    );

DWORD
GetRegDwordValue(
    IN LPWSTR RegKeyName,
    IN LPWSTR ValueName,
    OUT LPDWORD ValueBuffer
    );


//
// Common registry routines.
//

BOOLEAN
GetAssignedDriveLetter(
    ULONG       Signature,
    ULONG       PartitionNumber,
    PUCHAR      DriveLetter,
    PUSHORT     FtGroup,
    PBOOL       AssignDriveLetter
    );

//
// Common SCSI routines.
//

DWORD
GetScsiAddress(
    IN DWORD Signature,
    OUT LPDWORD ScsiAddress,
    OUT LPDWORD DiskNumber
    );

DWORD
ClusDiskGetAvailableDisks(
    OUT PVOID OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
GetDiskInfo(
    IN DWORD Signature,
    OUT PVOID *OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

VOID
CleanupScsiAddressList(
    PSCSI_ADDRESS_ENTRY AddressList
    );

BOOL
IsBusInList(
    PSCSI_ADDRESS DiskAddr,
    PSCSI_ADDRESS_ENTRY AddressList
    );

BOOL
IsDiskInList(
    PSCSI_ADDRESS DiskAddr,
    PSCSI_ADDRESS_ENTRY AddressList
    );

DWORD
GetCriticalDisks(
    PSCSI_ADDRESS_ENTRY *AddressList
    );

DWORD
GetPagefileDisks(
    PSCSI_ADDRESS_ENTRY *AddressList
    );

DWORD
GetCrashdumpDisks(
    PSCSI_ADDRESS_ENTRY *AddressList
    );

DWORD
GetSerialNumber(
    IN DWORD Signature,
    OUT LPWSTR *SerialNumber
    );

DWORD
GetSignatureFromSerialNumber(
    IN LPWSTR SerialNumber,
    OUT LPDWORD Signature
    );

DWORD
RetrieveSerialNumber(
    HANDLE DevHandle,
    LPWSTR *SerialNumber
    );

//
// Common routines for handling logical volumes
//
DWORD
DisksDriveIsAlive(
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL Online
    );

DWORD
DisksMountDrives(
    IN PDISK_INFO DiskInfo,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Signature
    );

DWORD
DisksDismountDrive(
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Signature
    );

//
// PnP stuff
//
DWORD
DiskspGetQuorumPath(
     OUT LPWSTR* lpQuorumLogPath
     );

DWORD
DiskspSetQuorumPath(
     IN LPWSTR QuorumLogPath
     );

DWORD
WaitForDriveLetters(
    IN DWORD DriveLetters,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  TimeOutInSeconds
    );

//
// [HACKHACK] Currently, there is not polically correct way
//  for the resource to learn whether it is a quorum resource or not
//
DWORD
GetQuorumSignature(
    OUT PDWORD QuorumSignature
    );

DWORD
StartNotificationWatcherThread(
    VOID
    );

VOID
StopNotificationWatcher(
    VOID
    );

VOID
WatchDisk(
    IN PDISK_RESOURCE ResourceEntry
    );

VOID
StopWatchingDisk(
    IN PDISK_RESOURCE ResourceEntry
    );

BOOL
IsDiskInPnpVolumeList(
    PDISK_RESOURCE ResourceEntry,
    BOOL UpdateVolumeList
    );

DWORD
QueueWaitForVolumeEvent(
    HANDLE Event,
    PDISK_RESOURCE ResourceEntry
    );

DWORD
RemoveWaitForVolumeEvent(
    PDISK_RESOURCE ResourceEntry
    );

//
// Mount point list processing.
//

VOID
DisksMountPointCleanup(
    PDISK_RESOURCE ResourceEntry
    );

VOID
DisksMountPointInitialize(
    PDISK_RESOURCE ResourceEntry
    );

DWORD
DisksProcessMountPointInfo(
    PDISK_RESOURCE ResourceEntry
    );

DWORD
DisksProcessMPControlCode(
    PDISK_RESOURCE ResourceEntry,
    DWORD ControlCode
    );

DWORD
DisksUpdateMPList(
    PDISK_RESOURCE ResourceEntry
    );

DWORD
PostMPInfoIntoRegistry(
    PDISK_RESOURCE ResourceEntry
    );

DWORD
UpdateCachedDriveLayout(
    IN HANDLE DiskHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\filter.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    filter.c

Abstract:

    ClusDisk Filter Driver interfaces for Disk Resource DLL in NT Clusters.

Author:

    Rod Gamache (rodga) 20-Dec-1995

Revision History:

   gorn: 18-June-1998 -- StartReserveEx function added

--*/

#include "disksp.h"
#include <strsafe.h>    // Should be included last.

extern  PWCHAR g_DiskResource;                      // L"rtPhysical Disk"
#define RESOURCE_TYPE ((RESOURCE_HANDLE)g_DiskResource)



DWORD
SetDiskState(
    PDISK_RESOURCE ResourceEntry,
    UCHAR NewDiskState
    )

/*++

Routine Description:

    Description

Arguments:

    ResourceEntry - Pointer to disk resource structure.

Return Value:

    Error Status - zero if success.

--*/

{
    PWCHAR      wcNewState;

    NTSTATUS    ntStatus;

    DWORD       errorCode;
    DWORD       bytesReturned;

    HANDLE      fileHandle;

    UNICODE_STRING  unicodeName;

    OBJECT_ATTRIBUTES       objAttributes;
    IO_STATUS_BLOCK         ioStatusBlock;
    SET_DISK_STATE_PARAMS   params;

    BOOL        success;

    UCHAR       oldState;

    if ( DiskOffline == NewDiskState ) {
        wcNewState = L"Offline";
    } else if ( DiskOnline == NewDiskState ) {
        wcNewState = L"Online";
    } else {
        wcNewState = L"<unknown state>";
    }

    RtlInitUnicodeString( &unicodeName, DEVICE_CLUSDISK0 );
    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &fileHandle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SCSI: %1!ws!, error opening ClusDisk0, error 0x%2!lx!.\n",
            wcNewState,
            ntStatus );
        return(RtlNtStatusToDosError(ntStatus));
    }

    params.Signature = ResourceEntry->DiskInfo.Params.Signature;
    params.NewState = NewDiskState;
    params.OldState = DiskStateInvalid;

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_SET_STATE,
                               &params,
                               sizeof(params),
                               &oldState,
                               sizeof(oldState),
                               &bytesReturned,
                               FALSE);
    NtClose( fileHandle );

    if ( !success ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SCSI: %1!ws!, error performing state change. Error: %2!u!.\n",
            wcNewState,
            errorCode = GetLastError());
        return(errorCode);
    }

    return(ERROR_SUCCESS);

}  // SetDiskState



DWORD
DoAttach(
    DWORD   Signature,
    RESOURCE_HANDLE ResourceHandle,
    BOOLEAN InstallMode
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to bring online.

    ResourceHandle - The resource handle for reporting errors

    InstallMode - Indicates whether the disk resource is being installed.
                  If TRUE, dismount then offline the disk.
                  If FALSE, offline then dismount the disk.

Return Value:

    Error Status - zero if success.

--*/

{
    NTSTATUS        ntStatus;
    DWORD           status;
    HANDLE          fileHandle;
    UNICODE_STRING  unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOL            success;
    DWORD           signature = Signature;
    DWORD           bytesReturned;

    RtlInitUnicodeString( &unicodeName, DEVICE_CLUSDISK0 );
    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &fileHandle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: Attach, error opening ClusDisk0, error 0x%1!lx!.\n",
            ntStatus );
        return(RtlNtStatusToDosError(ntStatus));
    }

    success = DeviceIoControl( fileHandle,
                               ( InstallMode ? IOCTL_DISK_CLUSTER_ATTACH : IOCTL_DISK_CLUSTER_ATTACH_OFFLINE ),
                               &signature,
                               sizeof(DWORD),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    NtClose( fileHandle );
    if ( !success) {
        status = GetLastError();
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: Attach, error attaching to signature %1!lx!, error %2!u!.\n",
            Signature,
            status );
        return(status);
    }

    return(ERROR_SUCCESS);

} // DoAttach


DWORD
DoDetach(
    DWORD   Signature,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Handle for device to bring online.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    NTSTATUS        ntStatus;
    DWORD           status;
    HANDLE          fileHandle;
    UNICODE_STRING  unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOL            success;
    DWORD           signature = Signature;
    DWORD           bytesReturned;

    RtlInitUnicodeString( &unicodeName, DEVICE_CLUSDISK0 );
    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &fileHandle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: Detach, error opening ClusDisk0, error 0x%1!lx!.\n",
            ntStatus );
        return(RtlNtStatusToDosError(ntStatus));
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_DETACH,
                               &signature,
                               sizeof(DWORD),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    NtClose( fileHandle );
    if ( !success) {
        status = GetLastError();
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: Detach, error detaching from signature %1!lx!, error %2!u!.\n",
            Signature,
            status );
        return(status);
    }

    return(ERROR_SUCCESS);

} // DoDetach



DWORD
StartReserveEx(
    OUT HANDLE *FileHandle,
    LPVOID InputData,
    DWORD  InputDataSize,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    This routine is used to start periodic reservations on the disk.

Arguments:

    FileHandle - Returns control handle for this device.

    InputData - Data to be passed to DeviceIoControl

    InputDataSize - The size of InputData buffer

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD status;
    UNICODE_STRING unicodeName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    RtlInitUnicodeString( &unicodeName, DEVICE_CLUSDISK0 );
    InitializeObjectAttributes( &objectAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    //
    // Open a file handle to the control device
    //
    status = NtCreateFile( FileHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &objectAttributes,
                           &ioStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           0,
                           NULL,
                           0 );
    if ( !NT_SUCCESS(status) ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: Reserve, error opening ClusDisk0, error %1!lx!.\n",
            status );
        return(status);
    }

    success = DeviceIoControl( *FileHandle,
                               IOCTL_DISK_CLUSTER_START_RESERVE,
                               InputData,
                               InputDataSize,
                               &status,
                               sizeof(status),
                               &bytesReturned,
                               FALSE);

    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: Reserve, error starting disk reservation thread, error %1!u!.\n",
            errorCode = GetLastError());
        return(errorCode);
    }

    return(ERROR_SUCCESS);

} // StartReserveEx


DWORD
StopReserve(
    HANDLE FileHandle,
    RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Description

Arguments:

    FileHandle - Supplies the control handle for device where reservations
            should be stopped.   This is the handle returned by StartReserveEx.
            This handle will be closed.

    ResourceHandle - The resource handle for reporting errors

Return Value:

    Error Status - zero if success.

--*/

{
    BOOL  success;
    DWORD bytesReturned;

    success = DeviceIoControl( FileHandle,
                               IOCTL_DISK_CLUSTER_STOP_RESERVE,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE);

    if ( !success ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"SCSI: error stopping disk reservations, error %1!u!.\n",
            GetLastError());
    }
    CloseHandle(FileHandle);

    return(ERROR_SUCCESS);

} // StopReserve
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\disks.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    disks.c

Abstract:

    Resource DLL for disks.

Author:

    John Vert (jvert) 5-Dec-1995
    Rod Gamache (rodga) 18-Dec-1995

Revision History:

--*/

#include "disksp.h"
#include "lm.h"

#include "arbitrat.h"
#include "newdisks.h"
#include "newmount.h"
#include <strsafe.h>    // Should be included last.

#define UNICODE 1

#define LOG_CURRENT_MODULE LOG_MODULE_DISK

#define MAX_HANDLES 10

extern  PWCHAR g_DiskResource;                      // L"rtPhysical Disk"
#define RESOURCE_TYPE ((RESOURCE_HANDLE)g_DiskResource)

#define ONLINE_CHK_FILE_NAME    L"zClusterOnlineChk.tmp"

LONG           DiskCount = 0;

CRITICAL_SECTION DisksLock;

LIST_ENTRY DisksListHead;

HANDLE DisksRegistryThread = NULL;
HANDLE DisksTerminateEvent = NULL;
HANDLE DiskspClusDiskZero  = NULL;

extern CLRES_FUNCTION_TABLE DisksFunctionTable;

extern RTL_RESOURCE PnpVolumeLock;
extern RTL_RESOURCE PnpWaitingListLock;     // Disks waiting for pnp volume arrival (online)

//
// Disk resource property names
//
#define DISKS_SIGNATURE         CLUSREG_NAME_PHYSDISK_SIGNATURE
#define DISKS_DRIVE             CLUSREG_NAME_PHYSDISK_DRIVE   // pseudonym for signature
#define DISKS_SKIPCHKDSK        CLUSREG_NAME_PHYSDISK_SKIPCHKDSK
#define DISKS_CONDITIONAL_MOUNT CLUSREG_NAME_PHYSDISK_CONDITIONAL_MOUNT
#define DISKS_MPVOLGUIDS        CLUSREG_NAME_PHYSDISK_MPVOLGUIDS
#define DISKS_VOLGUID           CLUSREG_NAME_PHYSDISK_VOLGUID       // Not saved in cluster DB
#define DISKS_SERIALNUMBER      CLUSREG_NAME_PHYSDISK_SERIALNUMBER

//
// Disk resource private read-write properties.
// Allow for a pseudonym for Signature (Drive), but don't allow both
// drive and signature to be passed.
//
RESUTIL_PROPERTY_ITEM
DiskResourcePrivateProperties[] = {
    { DISKS_SIGNATURE, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0xFFFFFFFF, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(DISK_PARAMS,Signature) },
    { DISKS_SKIPCHKDSK, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS,SkipChkdsk) },
    { DISKS_CONDITIONAL_MOUNT, NULL, CLUSPROP_FORMAT_DWORD, 1, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS,ConditionalMount) },
    { DISKS_MPVOLGUIDS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS, MPVolGuids) },
    { DISKS_SERIALNUMBER, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS,SerialNumber) },
    { 0 }
};

RESUTIL_PROPERTY_ITEM
DiskResourcePrivatePropertiesAlt[] = {
    { DISKS_SIGNATURE, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0xFFFFFFFF, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(DISK_PARAMS,Signature) },
    { DISKS_SKIPCHKDSK, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS,SkipChkdsk) },
    { DISKS_DRIVE, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(DISK_PARAMS,Drive) },
    { DISKS_CONDITIONAL_MOUNT, NULL, CLUSPROP_FORMAT_DWORD, 1, 0, 1, 0, FIELD_OFFSET(DISK_PARAMS,ConditionalMount) },
    { DISKS_MPVOLGUIDS, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS, MPVolGuids) },
    { DISKS_VOLGUID, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS, VolGuid) },
    { DISKS_SERIALNUMBER, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(DISK_PARAMS,SerialNumber) },
    { 0 }
};

#define CLUSTERLOG_ENV_VARIABLE     L"ClusterLog"

//
// Local functions.
//

DWORD
DisksValidatePrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PDISK_PARAMS Params
    );

DWORD
DisksSetPrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
DisksGetPrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
ProcessDllExtension(
    IN PDISK_RESOURCE ResourceEntry,
    IN PVOID    InBuffer,
    IN DWORD    InBufferSize,
    OUT PVOID   OutBuffer,
    IN DWORD    OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
DisksOpenChkdskLogFile(
    IN PDISK_RESOURCE ResourceEntry,
    IN OUT PHANDLE ChkdskLogFile,
    IN OUT LPWSTR *ChkdskLogFileName
    );

BOOL
DiskIsDynamic(
    IN DWORD DiskNumber
    );

//
// Error callbacks from disk library
//

VOID
DiskErrorFatal(
    INT MessageId,
    DWORD Error,
    LPSTR File,
    DWORD Line
    )
{
    DWORD Data[3];

    Data[0] = MessageId;
    Data[1] = Error;
    Data[2] = Line;
    ClusResLogSystemEventData(LOG_CRITICAL,
                              RES_FTSET_DISK_ERROR,
                              sizeof(Data),
                              Data);
}

VOID
DiskErrorLogInfo(
    LPSTR Format,
    ...
    )
{
}



BOOLEAN
WINAPI
DisksDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch ( Reason ) {

        case DLL_PROCESS_ATTACH:
            InitializeCriticalSection( &DisksLock );
            InitializeListHead( &DisksListHead );
            RtlInitializeResource( &PnpVolumeLock );
            RtlInitializeResource( &PnpWaitingListLock );
            ArbitrationInitialize();

            break;

        case DLL_PROCESS_DETACH:
            //
            // only do clean up if we're not exiting the process.
            // ClRtlDestroyWorkQueue waits on an event to be set and it is
            // possible at this point that there are no threads to do that.
            // This causes resmon to linger and generally be a pest.
            //
            if (DiskspClusDiskZero) {
                DevfileClose(DiskspClusDiskZero);
            }
            ArbitrationCleanup();
            DeleteCriticalSection( &DisksLock );
            RtlDeleteResource( &PnpVolumeLock );
            RtlDeleteResource( &PnpWaitingListLock );
            break;

        default:
            break;
    }

    return(TRUE);

} // DisksDllEntryPoint



VOID
WINAPI
DisksTerminate(
    IN RESID Resource
    )
{
   PDISK_RESOURCE resourceEntry = (PDISK_RESOURCE)Resource;

   if ( resourceEntry == NULL ) {
       DISKS_PRINT("Terminate, bad resource value \n");
       return;
   }
   // Wait for offline thread to complete, if there is one //
   ClusWorkerTerminate(&(resourceEntry->OfflineThread));
   DisksOfflineOrTerminate(resourceEntry, TERMINATE);
}


DWORD
WINAPI
DisksArbitrate(
    IN RESID Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    )

/*++

Routine Description:

    Arbitrate for a device by performing a reservation on the device.

Arguments:

    Resource - supplies resource id to be brought online.

    LostQuorumResource - routine to call when quorum resource is lost.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code if other failure.

--*/

{
    PDISK_RESOURCE  resourceEntry = (PDISK_RESOURCE)Resource;
    DWORD status;

    //
    // Make sure the RESID is okay.
    //
    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Arbitrate, bad resource value \n");
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    // [HACKHACK]
    // [GorN] 10/28/1999. If Offline thread detects that
    //   it is being terminated, it will not set the resource status to
    //   offline. ArbitrateCount != 0 will give it a hint on whether
    //   to set the resource status or not

    InterlockedIncrement(&resourceEntry->ArbitrationInfo.ArbitrateCount);

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] Wait for offline thread to complete...\n"
        );
    ClusWorkerTerminate(&(resourceEntry->OfflineThread));

    //
    // Perform DoAttach only. Do not open.
    //
    status = DisksOpenResourceFileHandle(resourceEntry, L"Arbitrate",0);
    if (status != ERROR_SUCCESS) {
       goto error_exit;
    }

    status = DiskArbitration( resourceEntry, DiskspClusDiskZero );

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] Arbitrate returned status %1!u!.\n",
        status );

    if (status == ERROR_SUCCESS) {
       resourceEntry->LostQuorum = LostQuorumResource;
    }
error_exit:
    InterlockedDecrement(&resourceEntry->ArbitrationInfo.ArbitrateCount);

    return status;
} // DisksArbitrate //



RESID
WINAPI
DisksOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for Disk resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies handle to this resource's cluster
        registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    DWORD       status;
    HKEY        clusDiskParametersKey = NULL;
    HKEY        resourceParametersKey = NULL;
    HKEY        resKey = NULL;
    PDISK_RESOURCE  resourceEntry;
    LPWSTR      nameOfPropInError;
    DWORD       previousDiskCount;

    //
    // Open registry parameters key for ClusDisk.
    //
    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           CLUSDISK_REGISTRY_SIGNATURES,
                           0,
                           KEY_READ,
                           &clusDiskParametersKey );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open ClusDisk parameters key. Error: %1!u!.\n",
            status );
        return(0);
    }

    //
    // Open the resource's parameters key.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                CLUSREG_KEYNAME_PARAMETERS,
                                KEY_READ | KEY_WRITE,
                                &resourceParametersKey );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open resource parameters key. Error: %1!u!.\n",
            status );
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey);
    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(ResourceHandle,
                        LOG_ERROR,
                        L"Unable to open resource key. Error: %1!u!.\n",
                        status );
        goto error_exit;
    }

    //
    // Allocate and zero disk info structure.
    //
    resourceEntry = LocalAlloc(LMEM_FIXED, sizeof(DISK_RESOURCE));
    if (!resourceEntry) {
        status = GetLastError();
        (DiskpLogEvent)(ResourceHandle,
                        LOG_ERROR,
                        L"Unable to allocate disk resource data. Error: %1!u!.\n",
                        status );
        goto error_exit;
    }
    ZeroMemory( resourceEntry, sizeof(DISK_RESOURCE));
    resourceEntry->ResourceParametersKey = resourceParametersKey;
    resourceEntry->ClusDiskParametersKey = clusDiskParametersKey;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ResourceHandle = ResourceHandle;
    //resourceEntry->Inserted = FALSE;
    //resourceEntry->Attached = FALSE;
    //resourceEntry->DiskInfo.Params.Signature = 0;

    status = ArbitrationInfoInit(resourceEntry);
    if ( status != ERROR_SUCCESS ) {
       LocalFree( resourceEntry );
       goto error_exit;
    }
    status = CreateArbWorkQueue(ResourceHandle);
    if ( status != ERROR_SUCCESS ) {
       LocalFree( resourceEntry );
       goto error_exit;
    }

#if 0
    //
    // GN: It seems that there is no point doing this here
    //     If we are on the join path, we cannot get
    //     any information about the disk and the call will fail
    //
    //     If we are forming the cluster we will update the information
    //     when we bring the disk online
    //
    status = DiskspSsyncDiskInfo( L"Open", resourceEntry , 0 );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(ResourceHandle,
                        LOG_ERROR,
                        L"Unable to ssync DiskInfo. Error: %1!u!.\n",
                        status );
    }
#endif

    //
    // Save disk info structure.
    //

    EnterCriticalSection( &DisksLock );

    if (DiskspClusDiskZero == NULL) {
        status = DevfileOpen(&DiskspClusDiskZero, DEVICE_CLUSDISK0);
        if (!NT_SUCCESS(status) ) {
            MountieCleanup ( &resourceEntry -> MountieInfo );
            ArbitrationInfoCleanup( resourceEntry );
            LocalFree( resourceEntry );
            LeaveCriticalSection( &DisksLock );
            (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Cannot open a handle to clusdisk driver, %1!x!.\n",
                status);
            goto error_exit;
        }
    }

    previousDiskCount = InterlockedExchangeAdd(&DiskCount, 1);

    LeaveCriticalSection( &DisksLock );

    if (previousDiskCount == 0) {
        StartNotificationWatcherThread();
    }

    DisksMountPointInitialize( resourceEntry );

    //
    // Read our disk signature from the resource parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( resourceEntry->ResourceParametersKey,
                                                   DiskResourcePrivateProperties,
                                                   (LPBYTE) &resourceEntry->DiskInfo.Params,
                                                   FALSE, //CheckForRequiredProperties
                                                   &nameOfPropInError );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
    }

    return( (RESID)( resourceEntry ) );

error_exit:

    if ( clusDiskParametersKey != NULL ) {
        RegCloseKey( clusDiskParametersKey );
    }

    if ( resourceParametersKey != NULL ) {
        ClusterRegCloseKey( resourceParametersKey );
    }

    if ( resKey != NULL ) {
        ClusterRegCloseKey( resKey );
    }

    SetLastError( status );
    return((RESID)0);

} // DisksOpen



DWORD
WINAPI
DisksRelease(
    IN RESID Resource
    )

/*++

Routine Description:

    Release arbitration for a device by stopping the reservation thread.

Arguments:

    Resource - supplies resource id to be brought online

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_HOST_NODE_NOT_OWNER if the resource is not owned.
    A Win32 error code if other failure.

--*/

{
    PDISK_RESOURCE  resourceEntry = (PDISK_RESOURCE)Resource;

    //
    // Make sure the Resource is okay.
    //

    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Release, bad resource value \n");
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    (DiskpLogEvent)(
       resourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"DisksRelease started, Inserted = %1!u! \n",
       resourceEntry->Inserted );

    if (resourceEntry->Inserted) { // [GN] #209018 //
       (DiskpLogEvent)(
           resourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Cannot release, Disk is online.\n");
    } else {
       StopPersistentReservations(resourceEntry);
    }
    resourceEntry->LostQuorum = NULL;

    return(ERROR_SUCCESS);

} // DisksRelease



DWORD
WINAPI
DisksOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Disk resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PDISK_RESOURCE  resourceEntry = (PDISK_RESOURCE)Resource;
    DWORD  Status;

    //
    // Make sure the Resource is okay.
    //

    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Online, bad resource value \n");
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Shutdown the online thread if it's running.
    //
    ClusWorkerTerminate(&resourceEntry->OnlineThread);

    Status = ClusWorkerCreate(&resourceEntry->OnlineThread,
                              DisksOnlineThread,
                              resourceEntry);
    if (Status == ERROR_SUCCESS) {
        Status = ERROR_IO_PENDING;
    }
    return(Status);

} // DisksOnline

DWORD
DisksOfflineThread(
    IN PCLUS_WORKER Worker,
    IN PDISK_RESOURCE ResourceEntry
    )
{
    RESOURCE_STATUS resourceStatus;
    DWORD status;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;
    ClusWorkerTerminate( &ResourceEntry->OnlineThread );
    status = DisksOfflineOrTerminate(ResourceEntry, OFFLINE);

    if (status == ERROR_SUCCESS) {
        resourceStatus.ResourceState = ClusterResourceOffline;
    }

    //
    // [HACKHACK] [GorN 10/04/1999]
    //    If Terminate is called when the offline is in progress,
    //    the terminate blocks waiting for OfflineThread to complete.
    //    However, offline thread is stuck trying
    //    to set ResourceStatus, since event list lock in the resmon
    //    is taken out by Terminate thread.
    //
    //    The following code doesn't fix this deadlock completely.
    //    It just reduces the window during which the problem can occur.
    //    [Resmon times out SetResourceStatus in 3 minutes, this breaks the deadlock]
    //
    // [HACKHACK] [GorN 10/28/1999]
    //    Arbitrate is also trying to terminate the offline thread
    //    We need some way to distinguish between these two cases
    //
    //    The order of setting is
    //       ArbitrateCount
    //       ClusWorkerTerminate
    //
    //    Order of checking is ClusWorkerTerminate then ArbitrateCount.
    //    (Won't work with aggressive memory access reordering, but who cares <grin>)
    //
    if ( !ClusWorkerCheckTerminate( Worker ) ||
          ResourceEntry->ArbitrationInfo.ArbitrateCount)
    {
        (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                 &resourceStatus );
    }
    return status;
}

DWORD
WINAPI DisksOffline(
	IN RESID ResourceId
	)
{
	PDISK_RESOURCE	ResourceEntry = (PDISK_RESOURCE)ResourceId;
	DWORD			status = ERROR_SUCCESS;

    //
    // Make sure the Resource is okay.
    //

    if ( ResourceEntry == NULL ) {
        DISKS_PRINT("Offline, bad resource value \n");
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    status = ClusWorkerCreate( &ResourceEntry->OfflineThread,
                               (PWORKER_START_ROUTINE)DisksOfflineThread,
                               ResourceEntry );
    if ( status	!= ERROR_SUCCESS )
    {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline: Unable to start thread, status %1!u!.\n",
            status
            );
    }
    else
    {
        status = ERROR_IO_PENDING;
    }

    return status;

} // DisksOffline


BOOL
WINAPI
DisksIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for Disk resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    DWORD  status;
    PDISK_RESOURCE resourceEntry = (PDISK_RESOURCE)Resource;

    //
    // Make sure the Resource is okay.
    //

    if ( resourceEntry == NULL ) {
        DISKS_PRINT("IsAlive, bad resource value \n");
        return(FALSE);
    }

    if ( resourceEntry->DiskInfo.FailStatus != 0 ) {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive, error checking device, error %1!u!.\n",
            resourceEntry->DiskInfo.FailStatus );
        ClusResLogSystemEventByKey(resourceEntry->ResourceKey,
                                   LOG_CRITICAL,
                                   RES_DISK_FAILED_SCSI_CHECK);
        resourceEntry->DiskInfo.FailStatus = 0;
        return(FALSE);
    }

    //
    // Check out the interesting partitions.
    //

#if 0
    (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"About to call DriveIsAlive!\n" );
#endif

    status = DisksDriveIsAlive( resourceEntry,
                                FALSE);

    if (status == ERROR_SUCCESS) {
        return(TRUE);
    } else {
        ClusResLogSystemEventByKeyData(resourceEntry->ResourceKey,
                                       LOG_CRITICAL,
                                       RES_DISK_FILESYSTEM_FAILED,
                                       sizeof(status),
                                       &status);
        return(FALSE);
    }

} // DisksIsAlive


BOOL
WINAPI
DisksLooksAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    LooksAlive routine for Disk resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PDISK_RESOURCE resourceEntry = (PDISK_RESOURCE)Resource;

    //
    // Make sure the Resource is okay.
    //

    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Online, bad resource value \n");
        return(FALSE);
    }

    if ( resourceEntry->DiskInfo.FailStatus != 0 ) {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive, error checking device, error %1!u!.\n",
            resourceEntry->DiskInfo.FailStatus );
        return FALSE;
    }

    return(TRUE);

} // DisksLooksAlive


VOID
WINAPI
DisksClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for Disk resource.

Arguments:

    Resource - supplies resource id to be closed.

Return Value:

    None.

--*/

{
    PDISK_RESOURCE resourceEntry = (PDISK_RESOURCE)Resource;

    //
    // Make sure the Resource is okay.
    //

    if ( resourceEntry == NULL ) {
        DISKS_PRINT("Close, bad resource value \n");
        return;
    }

    //
    // Wait for the online thread to finish.
    //
    DisksTerminate( Resource );

    DisksMountPointCleanup( resourceEntry );

    if ( resourceEntry->DiskInfo.Params.SerialNumber ) {
        LocalFree( resourceEntry->DiskInfo.Params.SerialNumber );
        resourceEntry->DiskInfo.Params.SerialNumber = NULL;
    }

    if ( InterlockedExchangeAdd(&DiskCount, -1) == 1 ) {
        // This is the last disk //
        StopNotificationWatcher();
        DestroyArbWorkQueue();
    }

    ClusterRegCloseKey( resourceEntry->ResourceParametersKey);
    ClusterRegCloseKey( resourceEntry->ResourceKey);
    RegCloseKey(resourceEntry->ClusDiskParametersKey);
    ArbitrationInfoCleanup(resourceEntry);
    MountieCleanup( &resourceEntry->MountieInfo );
    LocalFree(resourceEntry);

    return;

} // DisksClose



DWORD
DisksCheckCorruption(
    IN PWCHAR DeviceName,
    IN PWCHAR VolumeName,
    IN PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Checks for disk corruption problems.

Arguments:

    DeviceName - Supplies name of the form:
                \Device\HarddiskX\PartitionY    [Note: no trailing backslash]

    VolumeName - Supplies the device name of the form:
                 \\?\Volume{GUID}\    [Note trailing backslash!]

    ResourceEntry - Supplies a pointer to the resource structure

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    BOOL dirty;
    DWORD status = ERROR_SUCCESS;

    if ( ResourceEntry->DiskInfo.Params.SkipChkdsk ) {
        status = ERROR_SUCCESS;
        goto FnExit;
    }

    status = DisksIsVolumeDirty( DeviceName, ResourceEntry, &dirty );
    if (status == ERROR_SUCCESS && dirty) {

        status = ERROR_DISK_CORRUPT;
    }

FnExit:

    return status;

} // DisksCheckCorruption


DWORD
DisksFixCorruption(
    IN PWCHAR VolumeName,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD CorruptStatus
    )

/*++

Routine Description:

    Fix file or disk corrupt problems.

Arguments:

    VolumeName - Supplies the device name of the form:
                 \\?\Volume{GUID}\    [Note trailing backslash!]

    ResourceEntry - Supplies a pointer to the disk resource entry

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

Notes:

    We'll need to lock the volume exclusive while we do this...
    So threads that call this routine should ensure there are no
    open files!

--*/

{
    LPWSTR  chkdskLogFileName = NULL;

    PWCHAR  sysDir = NULL;
    PWCHAR  checkDiskInfo = NULL;

    const DWORD sysDirChars = MAX_PATH * 2;
    const DWORD checkDiskInfoChars = MAX_PATH * 2;

    DWORD   status;
    DWORD   len;

    HANDLE  chkdskLogFile = INVALID_HANDLE_VALUE;

    STARTUPINFOW        startupInfo;
    PROCESS_INFORMATION processInfo;
    RESOURCE_STATUS     resourceStatus;
    RESOURCE_EXIT_STATE     exit;

    BOOL    replaceBackslash;

    BOOL    bInheritHandles;
    UINT    previousMode;

    previousMode = SetErrorMode( SEM_FAILCRITICALERRORS|SEM_NOGPFAULTERRORBOX|SEM_NOOPENFILEERRORBOX );

    sysDir = LocalAlloc( LPTR, ( sysDirChars * sizeof(WCHAR) ) );

    if ( !sysDir ) {
        status = GetLastError();
        goto FnExit;
    }

    //
    // Get system directory path for CreateProcess.
    //

    len = GetSystemDirectoryW( sysDir,
                               sysDirChars - 1 );

    if ( !len ) {
        status = GetLastError();
        goto FnExit;
    }

    if ( len > sysDirChars - 1 ) {
        status = ERROR_BAD_PATHNAME;
        goto FnExit;
    }

    if ( FAILED( StringCchCat( sysDir, sysDirChars, TEXT("\\chkdsk.exe") ) ) ) {
        status = ERROR_INSUFFICIENT_BUFFER;
        goto FnExit;
    }

    //
    // We need to strip the trailing backslash off so chkdsk will work.
    //

    len = wcslen( VolumeName );

    if ( len > MAX_PATH ) {
        status = ERROR_ALLOTTED_SPACE_EXCEEDED;
        goto FnExit;
    }

    if ( VolumeName[len-1] == L'\\') {
        VolumeName[len-1] = UNICODE_NULL;
        replaceBackslash = TRUE;
    } else {
        replaceBackslash = FALSE;
    }

    checkDiskInfo = LocalAlloc( LPTR, checkDiskInfoChars * sizeof(WCHAR) );

    if ( !checkDiskInfo ) {
        status = GetLastError();
        goto FnExit;
    }

    //
    // Now handle the corruption problem by running CHKDSK.
    //

    if ( FAILED( StringCchPrintf( checkDiskInfo,
                                  checkDiskInfoChars,
                                  TEXT("chkdsk.exe /x /f %ws"),
                                  VolumeName ) ) ) {
        status = ERROR_INSUFFICIENT_BUFFER;
        goto FnExit;
    }

    //
    // Restore the backslash.
    //

    if ( replaceBackslash ) {
        VolumeName[len-1] = L'\\';
    }

    ZeroMemory( &startupInfo, sizeof(STARTUPINFOW) );
    startupInfo.cb = sizeof(STARTUPINFO);
    startupInfo.lpDesktop = L"WinSta0\\Default";

    bInheritHandles = FALSE;

    status = DisksOpenChkdskLogFile( ResourceEntry,
                                     &chkdskLogFile,
                                     &chkdskLogFileName );

    if ( NO_ERROR == status && INVALID_HANDLE_VALUE != chkdskLogFile ) {

        //
        // When the output is redirected, we don't want to show the console window because it
        // will be blank with simply a title in it.  The event log message will let the user
        // know to look in the chkdsk file.
        //

        startupInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
        startupInfo.wShowWindow = SW_HIDE;

        // Someone watching the console won't know what is happening, so show
        // the window anyway...
        // StartupInfo.dwFlags = STARTF_USESTDHANDLES;

        startupInfo.hStdInput = GetStdHandle(STD_INPUT_HANDLE);

        //
        // [169631] Chkdsk now verifies that hStdInput is not NULL.
        // Since the resmon process was started with InheritHandles set to FALSE,
        // GetStdHandle(STD_INPUT_HANDLE) will return NULL.  When we run chkdsk with
        // the options "/f /x", chkdsk should not be prompting the user and the
        // input handle wouldn't be used.  However, ulibs.dll was changed to always
        // insure a nonzero input handle was supplied.  So we have to supply some type
        // of input handle.  We could put INVALID_HANDLE_VALUE here, but the checks
        // may change and it will fail later.  For now, point input to the temporary
        // output file we created.
        //

        if ( NULL == startupInfo.hStdInput ) {
            startupInfo.hStdInput = chkdskLogFile;
        }

        startupInfo.hStdOutput = chkdskLogFile;
        startupInfo.hStdError = chkdskLogFile;

        bInheritHandles = TRUE;
    }

    //
    // Log an event
    //
    if ( CorruptStatus == ERROR_DISK_CORRUPT ) {
        // Must be corrupt disk
        ClusResLogSystemEventByKey2(ResourceEntry->ResourceKey,
                                    LOG_CRITICAL,
                                    RES_DISK_CORRUPT_DISK,
                                    VolumeName,
                                    chkdskLogFileName);
    } else {
        // Must be corrupt file.
        ClusResLogSystemEventByKey2(ResourceEntry->ResourceKey,
                                    LOG_CRITICAL,
                                    RES_DISK_CORRUPT_FILE,
                                    VolumeName,
                                    chkdskLogFileName);
    }

    if ( chkdskLogFileName ) {
        LocalFree( chkdskLogFileName );
        chkdskLogFileName = NULL;
    }

    if ( !CreateProcessW( sysDir,
                          checkDiskInfo,
                          NULL,
                          NULL,
                          bInheritHandles,
                          NORMAL_PRIORITY_CLASS,
                          NULL,
                          NULL,
                          &startupInfo,
                          &processInfo ) ) {
        status = GetLastError();

        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
                        L"DisksFixCorruption: CreateProcessW for chkdsk.exe failed %1!u! \n",
                        status );

        goto FnExit;
    }

    CloseHandle( processInfo.hThread );

    //
    // Wait for CHKDSK to finish.
    //
    //
    // Don't wait "forever"... things could get ugly if we dismount the file
    // system while ChkDsk is running! But KeithKa says its okay to kill
    // ChkDsk while it is running - it has to handle powerfails, crashes, etc.
    //
    resourceStatus.ResourceState = ClusterResourceOnlinePending;
    while ( !ResourceEntry->OnlineThread.Terminate ) {
        (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                 &resourceStatus );
        status = WaitForSingleObject( processInfo.hProcess, 2000 );
        if ( status != WAIT_TIMEOUT ) {
            break;
        }
    }

    if ( ResourceEntry->OnlineThread.Terminate ) {
        // If we were asked to terminate, make sure ChkNtfs is killed
        TerminateProcess( processInfo.hProcess, 999 );
        CloseHandle( processInfo.hProcess );

        status = ERROR_SHUTDOWN_CLUSTER;
        goto FnExit;
    }

    //
    // Update our checkpoint state.
    //
    ++resourceStatus.CheckPoint;
    exit = (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                    &resourceStatus );
    if ( exit == ResourceExitStateTerminate ) {
        TerminateProcess( processInfo.hProcess, 998 );
        CloseHandle( processInfo.hProcess );

        status = ERROR_SHUTDOWN_CLUSTER;
        goto FnExit;
    }

    if ( (status == 0) &&
        GetExitCodeProcess( processInfo.hProcess, &status ) ) {

// [From supera.hxx]
//
// These symbols are used by Chkdsk functions to return an appropriate
// exit status to the chkdsk program.
// In order of most important first, the error level order are as follows:
//   3 > 1 > 2 > 0
// An error level of 3 will overwrite an error level of 1, 2, or 0.

// #define CHKDSK_EXIT_SUCCESS         0
// #define CHKDSK_EXIT_ERRS_FIXED      1
// #define CHKDSK_EXIT_MINOR_ERRS      2       // whether or not "/f"
// #define CHKDSK_EXIT_CLEANUP_WORK    2       // whether or not "/f"
// #define CHKDSK_EXIT_COULD_NOT_CHK   3
// #define CHKDSK_EXIT_ERRS_NOT_FIXED  3
// #define CHKDSK_EXIT_COULD_NOT_FIX   3

        if ( status >= 3 ) {

            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"FixCorruption: chkdsk.exe returned status of %1!u! -  Could not fix errors.\n",
                            status );

            status = ERROR_DISK_CORRUPT;
        } else {

            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_WARNING,
                            L"FixCorruption: chkdsk.exe returned status of %1!u! - No errors or minor errors fixed.\n",
                            status );

            status = ERROR_SUCCESS;
        }
    }

    CloseHandle( processInfo.hProcess );

FnExit:

    if ( sysDir ) {
        LocalFree( sysDir );
    }

    if ( checkDiskInfo ) {
        LocalFree( checkDiskInfo );
    }

    if ( chkdskLogFileName ) {
        LocalFree( chkdskLogFileName );
    }

    if ( INVALID_HANDLE_VALUE != chkdskLogFile ) {
        CloseHandle( chkdskLogFile );
    }

    SetErrorMode( previousMode );

    return status;

} // DisksFixCorruption

DWORD
DiskspGetQuorumPath(
     OUT LPWSTR* lpQuorumLogPath
     )
/*++

Routine Description:

    Reads QuorumPath value from the registry.


Arguments:

    lpQuorumLogPath - receives the poiner to a buffer containing QuorumLogPath
                      the buffer needs to be deallocated later via LocalFree

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD Status;
    LPWSTR QuorumLogPath = NULL;
    DWORD QuorumLogSize = 0;
    DWORD Type;
    HKEY  QuorumKey;

    Status = RegOpenKey( HKEY_LOCAL_MACHINE,
                         DISKS_REG_CLUSTER_QUORUM,
                         &QuorumKey );
    if ( Status == ERROR_SUCCESS ) {
        Status = RegQueryValueExW(QuorumKey,
                                  DISKS_REG_QUORUM_PATH,
                                  0,
                                  &Type,
                                  NULL,
                                  &QuorumLogSize );
        if ( Status != ERROR_SUCCESS ) {
            RegCloseKey(QuorumKey);
            return( Status );
        }

        if ( (Type != REG_SZ) ||
             (QuorumLogSize > (MAX_PATH - 2)) ) {
            RegCloseKey(QuorumKey);
            return(ERROR_INVALID_DATA);
        }
        if ( (Status == ERROR_SUCCESS) ||
             (Status == ERROR_MORE_DATA) ) {
            QuorumLogPath = LocalAlloc( LMEM_FIXED,
                                        (QuorumLogSize + 1) * sizeof(WCHAR) );
            if ( QuorumLogPath == NULL ) {
                RegCloseKey( QuorumKey );
                return(ERROR_NOT_ENOUGH_MEMORY); // Mostly catastrophic
            }

            Status = RegQueryValueExW(QuorumKey,
                                      DISKS_REG_QUORUM_PATH,
                                      0,
                                      &Type,
                                      (LPBYTE)QuorumLogPath,
                                      &QuorumLogSize );
            if (Status == ERROR_SUCCESS) {
                *lpQuorumLogPath = QuorumLogPath;
            } else {
                LocalFree(QuorumLogPath);
                *lpQuorumLogPath = 0;
            }
        }
        RegCloseKey( QuorumKey );
    }
    return Status;
}

DWORD
DiskspSetQuorumPath(
     IN LPWSTR QuorumLogPath
     )
/*++

Routine Description:

    Reads QuorumPath value from the registry.


Arguments:

    lpQuorumLogPath - receives the poiner to a buffer containing QuorumLogPath
                      the buffer needs to be deallocated later via LocalFree

    ResourceEntry - receives a drive letter of the quorum

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    DWORD status;
    HKEY  QuorumKey;
    HKEY  ClusterKey;

    HCLUSTER hCluster;

    hCluster = OpenCluster(NULL);
    if (!hCluster) {
        status = GetLastError();
        return status;
    }

    ClusterKey = GetClusterKey(hCluster, KEY_READ | KEY_WRITE);
    if (!ClusterKey) {
        status = GetLastError();
        CloseCluster(hCluster);
        return status;
    }

    status = ClusterRegOpenKey( ClusterKey,
                                CLUSREG_KEYNAME_QUORUM,
                                KEY_READ | KEY_WRITE,
                                &QuorumKey );
    if (status != ERROR_SUCCESS) {
        ClusterRegCloseKey(ClusterKey);
        CloseCluster(hCluster);
        return status;
    }

    status = ResUtilSetSzValue(
                QuorumKey,
                CLUSREG_NAME_QUORUM_PATH,
                QuorumLogPath,
                0);

    ClusterRegCloseKey(QuorumKey);
    ClusterRegCloseKey(ClusterKey);
    CloseCluster(hCluster);
    return status;
}


DWORD
DisksDriveIsAlive(
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL Online
    )

/*++

Routine Description:

    Checks out a drive partition to see if the filesystem has mounted
    it and it's working. We will also run CHKDSK if the partition/certain
    files are Corrupt and the Online flag is TRUE.

Arguments:

    ResourceEntry - Supplies a pointer to the resource entry for this disk

    Online - TRUE if the disk was just brought online.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PMOUNTIE_PARTITION entry;

    DWORD Status = ERROR_SUCCESS;
    DWORD nPartitions = MountiePartitionCount( &ResourceEntry->MountieInfo );
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;
    DWORD i;

    LPWSTR QuorumLogPath = NULL;
    BOOL  QuorumResource = FALSE;

    WCHAR szDiskPartName[MAX_PATH];
    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];
    WCHAR szQuorumVolumeName[MAX_PATH];
    WCHAR szQuorumDriveLetter[16];

    szQuorumVolumeName[0] = L'\0';

    //
    // Find the quorum path... this is a hack!
    //
    if ( Online ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"DriveIsAlive called for Online check\n" );

        {
            DWORD QuorumSignature;
            Status = GetQuorumSignature( &QuorumSignature );
            if (Status == ERROR_SUCCESS) {
                QuorumResource =
                    (QuorumSignature == ResourceEntry->DiskInfo.Params.Signature);

                //
                // Only get the quorum path if this is quorum disk.
                //

                Status = DiskspGetQuorumPath( &QuorumLogPath );
                if (Status != ERROR_SUCCESS) {
                    (DiskpLogEvent)(
                          ResourceEntry->ResourceHandle,
                          LOG_INFORMATION,
                          L"DiskspGetQuorumPath returned %1!u!\n", Status );

                } else {

                    //
                    // For now, quorum path will have a drive letter.  Get the corresponding volume name.
                    //

                    (VOID) StringCchPrintf( szQuorumDriveLetter,
                                            RTL_NUMBER_OF( szQuorumDriveLetter ),
                                            TEXT("%wc:\\"),
                                            QuorumLogPath[0] );

                    if ( !GetVolumeNameForVolumeMountPointW( szQuorumDriveLetter,
                                                             szQuorumVolumeName,
                                                             RTL_NUMBER_OF(szQuorumVolumeName) )) {

                            Status = GetLastError();

                            (DiskpLogEvent)(
                                  ResourceEntry->ResourceHandle,
                                  LOG_INFORMATION,
                                  L"DriveIsAlive: GetVolumeNameForVolumeMountPoint (quorum) returned %1!u!\n", Status );

                    }

                }

            } else {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_INFORMATION,
                      L"GetQuorumSignature returned %1!u!\n", Status );
            }
        }


    }

#if 0
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DriveIsAlive is now checking each partition\n" );
#endif

    //
    // Now check out each interesting partition.  Since only "valid" partitions are
    // saved in the MountieInfo structure, we will only look at those (ignoring those
    // partitions that are not NTFS).
    //

    for ( i = 0; i < nPartitions; ++i ) {

        entry = MountiePartition( &ResourceEntry->MountieInfo, i );

        if ( !entry ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"DriveIsAlive: No partition entry for partition %1!u! \n", i );

            //
            // Something bad happened to our data structures.  We have to indicate that the
            // drive is not alive.
            //

            Status = ERROR_INVALID_DATA;

            goto FnExit;
        }

        //
        // Create device name of form \Device\HarddiskX\PartitionY (no trailing backslash).
        //

        (VOID) StringCchPrintf( szDiskPartName,
                                RTL_NUMBER_OF( szDiskPartName ),
                                DEVICE_HARDDISK_PARTITION_FMT,
                                physicalDrive,
                                entry->PartitionNumber );
        //
        // Given the DiskPartName, get the VolGuid name.  This name must have a trailing
        // backslash to work correctly.
        //

        (VOID) StringCchPrintf( szGlobalDiskPartName,
                                RTL_NUMBER_OF( szGlobalDiskPartName ),
                                GLOBALROOT_HARDDISK_PARTITION_FMT,
                                physicalDrive,
                                entry->PartitionNumber );

        szVolumeName[0] = L'\0';

        if ( !GetVolumeNameForVolumeMountPointW( szGlobalDiskPartName,
                                                 szVolumeName,
                                                 RTL_NUMBER_OF(szVolumeName) )) {

            Status = GetLastError();

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"DriveIsAlive: GetVolumeNameForVolumeMountPoint for %1!ws! returned %2!u!\n",
                  szGlobalDiskPartName,
                  Status );

            //
            // If disk is not corrupt, exit.  If disk is corrupt, fall through so chkdsk runs.
            //

            if ( ERROR_DISK_CORRUPT != Status && ERROR_FILE_CORRUPT != Status ) {

                //
                // Something bad happened.  We have to stop checking this disk.  Return the
                // error status we received.
                //

                goto FnExit;
            }

        }

        //
        // Simple algorithm used here is to do a FindFirstFile on X:\* and see
        // if it works. Then we open each file for read access. This is the
        // cluster directory, and all files in it are subject to our opening.
        //

        Status = DiskspCheckPath( szVolumeName,
                                  ResourceEntry,
                                  FALSE,
                                  Online );

        //
        // [HACKHACK] Ignore error 21 during periodic IsAlive/LooksAlive
        //
        if ( !Online && (Status == ERROR_NOT_READY) ) {
            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_WARNING,
                            L"DiskpCheckPath for %1!ws!: returned status = %2!u! (chkdsk.exe running?)\n",
                            szVolumeName,
                            Status );
            Status = ERROR_SUCCESS;
        }

        // if we haven't chkdsk'd yet, keep looking.
        if ( Status != ERROR_SUCCESS ) {
            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskpCheckPath for %1!ws!: returned status = %2!u!\n",
                            szVolumeName,
                            Status );
        }

        if ( (Status == ERROR_SUCCESS) && Online &&
             QuorumLogPath && QuorumResource &&
             ( wcslen( szVolumeName ) == wcslen( szQuorumVolumeName ) ) &&
             ( !wcsncmp( szVolumeName, szQuorumVolumeName, wcslen( szQuorumVolumeName ) ))) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"DriveIsAlive checking quorum drive to insure cluster directory accessible. \n" );

            //
            // Everything looks fine... if this is the quorum device, then
            // we should check the quorum log path if given
            //

            Status = DiskspCheckPath( QuorumLogPath,
                                      ResourceEntry,
                                      TRUE,
                                      Online );
        }

        if ( (Status == ERROR_SUCCESS) &&
             Online ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"DriveIsAlive checking that file system is not corrupt.  If so, chkdsk may run. \n" );

            //
            // Check if the volume dirty bit is on
            //
            Status = DisksCheckCorruption( szDiskPartName,
                                           szVolumeName,
                                           ResourceEntry );

#if CLUSRES_FORCE_CHKDSK    // For debugging...
            if ( Online ) {
                Status = ERROR_DISK_CORRUPT;
            }
#endif

            //
            // If we're requested to shutdown, then do that immediately
            if ( ResourceEntry->OnlineThread.Terminate ) {
                Status = ERROR_SHUTDOWN_CLUSTER;
                goto FnExit;
            }
        }


        if ( (Status != ERROR_SUCCESS) && Online) {
            if ( ResourceEntry->DiskInfo.Params.ConditionalMount ) {

                Status = DisksFixCorruption( szVolumeName,
                                             ResourceEntry,
                                             ERROR_DISK_CORRUPT );

                //
                // Since ConditionalMount is set, if we couldn't fix the corruption
                // on the disk, we don't want to continue checking the other
                // partitions - we want to return an error.  So we fall through
                // and check the status.  If status wasn't successful, we break out
                // of the loop to return the error.
                //

            } else {

                //
                // Disk is corrupt, but we didn't run chkdsk.  Return error
                // to caller.
                //

                goto FnExit;
            }
        }
        if ( Status != ERROR_SUCCESS ) {
            goto FnExit;
        }

    }

    //
    // Now check that the drive letters are accessible.  The previous code
    // ran chkdsk on volumes as necessary, so we just need to make sure
    // drive letters are accessible.
    //

    Status = WaitForDriveLetters( DisksGetLettersForSignature( ResourceEntry ),
                                  ResourceEntry,
                                  0 );              // Don't wait for the drive letter.

    if ( ERROR_SUCCESS != Status ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"DriveIsAlive failed checking drive letters \n" );
    }

FnExit:

    if ( QuorumLogPath ) {
        LocalFree( QuorumLogPath );
    }

    return(Status);

}  // DisksDriveIsAlive



DWORD
DisksMountDrives(
    IN PDISK_INFO DiskInfo,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Signature
    )
/*++

Routine Description:

    For each drive letter on the supplied disk, this mounts the filesystem
    and checks it out.

Arguments:

    DiskInfo - Supplies the disk information

    ResourceEntry - Supplies a pointer to the disk resource

    Signature - the signature for the disk.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    WCHAR wDeviceName[4];
    WCHAR wShareName[4];
    DWORD letterMask;
    UCHAR index;
    UCHAR driveLetter;
    SHARE_INFO_2 shareInfo;

    DWORD autoShareServer;

    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"DisksMountDrives: calling IsAlive function.\n" );

    //
    // Call the IsAlive to see if the filesystem checks out ok.
    //
    Status = DisksDriveIsAlive( ResourceEntry,
                                TRUE);

    if ( (Status != ERROR_SUCCESS) ||
         (ResourceEntry->OnlineThread.Terminate) ) {
        return(Status);
    }

    //
    // Now create the drive$ share name for each drive letter;
    //
    letterMask = DisksGetLettersForSignature(
                            ResourceEntry);

    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"DisksMountDrives: letter mask is %1!08x!.\n",
                    letterMask);

    //
    // Check if admin shares should be created.
    // Assume we have to create shares, so default value is "1".
    //
    // If the value entry exists and the value is zero, admin shares should not be created.
    // If the value entry does not exist, or the value is non-zero, admin shares should be created.
    //

    autoShareServer = 1;
    Status = GetRegDwordValue( TEXT("SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters"),
                               TEXT("AutoShareServer"),
                               &autoShareServer );

    //
    // If value is now zero, we don't create admin shares.
    //

    if ( !autoShareServer ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"DisksMountDrives: Not creating admin shares based on LanmanServer AutoShareServer setting \n" );
        return ERROR_SUCCESS;
    }

    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"DisksMountDrives: creating admin share names.\n" );

    index = 0;
    while ( letterMask ) {
        while ( !(letterMask & 1) ) {
            letterMask = letterMask >> 1;
            index++;
        }
        driveLetter = 'A' + index;
        letterMask = letterMask >> 1;
        index++;
        if ( isalpha(driveLetter) ) {
            (VOID) StringCchPrintf( wDeviceName,
                                    RTL_NUMBER_OF(wDeviceName),
                                    TEXT("%c:\\"),
                                    driveLetter );
            (VOID) StringCchPrintf( wShareName,
                                    RTL_NUMBER_OF(wShareName),
                                    TEXT("%c$"),
                                    driveLetter );
            shareInfo.shi2_netname = wShareName;
            shareInfo.shi2_type = STYPE_DISKTREE;
            shareInfo.shi2_remark = NULL;
            shareInfo.shi2_permissions = 0;
            shareInfo.shi2_max_uses = (DWORD)-1;
            shareInfo.shi2_current_uses = 0;
            shareInfo.shi2_path = wDeviceName;
            shareInfo.shi2_passwd = NULL;

            Status = NetShareAdd( NULL, 2, (PBYTE)&shareInfo, NULL );
            if ( Status != ERROR_SUCCESS && Status != NERR_DuplicateShare ) {
                (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                                LOG_ERROR,
                                L"DisksMountDrives: error creating default share %1!ws!. Error: %2!u!.\n",
                                wShareName,
                                Status);
            }
        }
    }

    return(ERROR_SUCCESS);

}  // DisksMountDrives


DWORD
DisksDismountDrive(
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Signature
    )

/*++

Routine Desccription:

    Delete the default device share names for a given disk.

Arguments:

    ResourceHandle - the resource handle for logging events

    Signature - the disk's signature

Return Value:

    WIN32 error code.

--*/

{
    WCHAR   shareName[8];
    DWORD   letterMask;
    UCHAR   index;
    UCHAR   driveLetter;

    letterMask = DisksGetLettersForSignature(
                            ResourceEntry);

    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"DisksDismountDrives: letter mask is %1!08x!.\n",
                    letterMask);

    index = 0;
    while ( letterMask ) {
        while ( !(letterMask & 1) ) {
            letterMask = letterMask >> 1;
            index++;
        }
        driveLetter = 'A' + index;
        letterMask = letterMask >> 1;
        index++;
        if ( isalpha(driveLetter) ) {
            shareName[0] = (WCHAR)driveLetter;
            shareName[1] = (WCHAR)'$';
            shareName[2] = (WCHAR)0;

            NetShareDel( NULL,
                         shareName,
                         0 );

        }
    }

    return (ERROR_SUCCESS);

} // DisksDismountDrive



LPWSTR
GetRegParameter(
    IN HKEY RegKey,
    IN LPCWSTR ValueName
    )

/*++

Routine Description:

    Queries a parameter out of the registry and allocates the
    necessary storage for it.

Arguments:

    RegKey - Supplies the cluster key where the parameter is stored

    ValueName - Supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter if successful.

    NULL if unsuccessful.

--*/

{
    LPWSTR Value;
    LPWSTR expValue;
    DWORD ValueLength;
    DWORD expLength;
    DWORD ValueType;
    DWORD Status;

    ValueLength = 0;
    Status = RegQueryValueEx(RegKey,
                             ValueName,
                             NULL,
                             &ValueType,
                             NULL,
                             &ValueLength);
    if ( (Status != ERROR_SUCCESS) &&
         (Status != ERROR_MORE_DATA) ) {
        return(NULL);
    }

    // Make the buffer slightly larger in case the string
    // was not stored with proper null-termination.

    if ( REG_SZ == ValueType ||
         REG_MULTI_SZ == ValueType ||
         REG_EXPAND_SZ == ValueType ) {
        ValueLength++;
    }

    Value = LocalAlloc(LPTR, ValueLength );
    if (Value == NULL) {
        return(NULL);
    }
    Status = RegQueryValueEx(RegKey,
                             ValueName,
                             NULL,
                             &ValueType,
                             (LPBYTE)Value,
                             &ValueLength);
    if (Status != ERROR_SUCCESS) {
        LocalFree(Value);
        Value = NULL;
        goto FnExit;
    }

    //
    // Expand strings if required.
    //

    if ( REG_EXPAND_SZ == ValueType ) {

        //
        // Find length of expanded buffer.
        //

        expLength = 0;
        expLength = ExpandEnvironmentStrings( Value,
                                              NULL,
                                              0 );

        //
        // If we can't get length of the required expanded buffer,
        // don't return the unexpanded string.
        //

        if ( !expLength ) {
            LocalFree( Value );
            Value = NULL;
            goto FnExit;
        }

        ValueLength = expLength;
        expValue = LocalAlloc( LPTR, ValueLength * sizeof(WCHAR) );

        if ( !expValue ) {
            LocalFree( Value );
            Value = NULL;
            goto FnExit;
        }

        expLength = ExpandEnvironmentStrings( Value,
                                              expValue,
                                              ValueLength );

        //
        // If string couldn't be expanded, free both buffers and
        // return NULL.  If string was expanded, free unexpanded
        // buffer and return expanded buffer.
        //

        if ( !expLength || expLength > ValueLength ) {
            LocalFree( Value );
            Value = NULL;
            LocalFree( expValue );
        } else {
            LocalFree( Value );
            Value = expValue;
        }
    }

FnExit:

    return(Value);

}  // GetRegParameter


DWORD
DisksResourceControl(
    IN RESID Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD           status = ERROR_SUCCESS;
    PDISK_RESOURCE  resourceEntry = (PDISK_RESOURCE)Resource;
    DWORD           required;

    *BytesReturned = 0;

    //
    // Make sure the Resource is okay.
    //

    if ( resourceEntry == NULL ) {
        DISKS_PRINT("ResourceControl, bad resource value \n");
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( DiskResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_STORAGE;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
            }
            break;

        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
            status = GetDiskInfo( resourceEntry->DiskInfo.Params.Signature,
                                  &OutBuffer,
                                  OutBufferSize,
                                  BytesReturned );

            // Add the endmark.
            if ( OutBufferSize > *BytesReturned ) {
                OutBufferSize -= *BytesReturned;
            } else {
                OutBufferSize = 0;
            }
            *BytesReturned += sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize >= sizeof(CLUSPROP_SYNTAX) ) {
                PCLUSPROP_SYNTAX ptrSyntax = OutBuffer;
                ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            }
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( DiskResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = DisksGetPrivateResProperties( resourceEntry,
                                                   OutBuffer,
                                                   OutBufferSize,
                                                   BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = DisksValidatePrivateResProperties( resourceEntry,
                                                        InBuffer,
                                                        InBufferSize,
                                                        NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = DisksSetPrivateResProperties( resourceEntry,
                                                   InBuffer,
                                                   InBufferSize );

            DiskspSsyncDiskInfo(L"ResourceControl", resourceEntry, 0);

            break;

        case CLUSCTL_RESOURCE_DELETE:
            if ( resourceEntry->DiskInfo.Params.Signature ) {
                (DiskpLogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Delete disk resource %1!lx!\n",
                    resourceEntry->DiskInfo.Params.Signature );
                status = DoDetach( resourceEntry->DiskInfo.Params.Signature,
                                   resourceEntry->ResourceHandle );
            }
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_DELETE_REQUIRES_ALL_NODES;
            }
            break;

        case CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION:

            status = ProcessDllExtension( resourceEntry,
                                          InBuffer,
                                          InBufferSize,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned );
            break;

        case CLUSCTL_RESOURCE_REMOVE_DEPENDENCY:
        case CLUSCTL_RESOURCE_ADD_DEPENDENCY:

            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Add/Remove dependency:  source signature %1!lx!  target name (%2!ws!) \n",
                resourceEntry->DiskInfo.Params.Signature,
                InBuffer );

            status = DisksProcessMPControlCode( resourceEntry,
                                                ControlCode );

            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // DisksResourceControl



DWORD
DisksResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Process control requests for this resource type.

Arguments:

    ResourceTypeName - the name of the resource type - not very useful!

    ControlCode - the control request

    InBuffer - pointer to the input buffer

    InBufferSize - the size of the input buffer

    OutBuffer - pointer to the output buffer

    OutBufferSize - the size of the output buffer

    BytesReturned - the number of bytes returned (or needed if larger than
                OutBufferSize and ERROR_MORE_DATA is returned

Return Value:

    ERROR_SUCCESS if successful

    A WIN32 error on failure

--*/

{
    DWORD   status = ERROR_SUCCESS;
    DWORD   required;

    *BytesReturned = 0;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( DiskResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( DiskResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_STORAGE;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS:
            status = ClusDiskGetAvailableDisks( OutBuffer,
                                                OutBufferSize,
                                                BytesReturned );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_DELETE_REQUIRES_ALL_NODES;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // DisksResourceTypeControl



DWORD
DisksGetPrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type Physical Disk.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties(
                                    ResourceEntry->ResourceParametersKey,
                                    DiskResourcePrivateProperties,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned,
                                    &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // DisksGetPrivateResProperties



DWORD
DisksConvertDriveToSignature(
    IN OUT PDISK_PARAMS Params,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Change the drive letter or VolGuid to the associated disk signature.

Arguments:

    Params - Supplies the parameter block that contains the drive letter
            (or VolGuid) to convert to a signature.

            VolGuid syntax is returned from mountvol.exe and in the form:
                \\?\Volume{e6de97f1-6f97-11d3-bb7f-806d6172696f}\

    ResourceHandle -

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly or is invalid.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    PWCHAR  deviceName = NULL;
    DWORD   deviceNameBytes;
    DWORD   lenChar;
    DWORD   status = ERROR_SUCCESS;
    LPWSTR  drive = Params->Drive;
    LPWSTR  volGuid = Params->VolGuid;
    HANDLE  fileHandle;
    BOOL    success;
    PDRIVE_LAYOUT_INFORMATION driveLayout = NULL;

    //
    // Build device string for CreateFile
    //

    if ( drive ) {

        deviceNameBytes = (( wcslen( drive ) + wcslen( L"\\\\.\\" ) ) * sizeof(WCHAR) ) +
                            sizeof( UNICODE_NULL );

        deviceName = LocalAlloc( LPTR, deviceNameBytes );

        if ( !deviceName ) {
            status = GetLastError();
            goto FnExit;
        }

        if ( FAILED( StringCchPrintf( deviceName,
                                      deviceNameBytes/sizeof(WCHAR),
                                      TEXT("\\\\.\\%ws"),
                                      drive ) ) ) {
            status = ERROR_INSUFFICIENT_BUFFER;
            goto FnExit;
        }

    } else if ( volGuid ) {

        deviceNameBytes = ( wcslen( volGuid ) * sizeof( WCHAR ) ) + sizeof( UNICODE_NULL );

        deviceName = LocalAlloc( LPTR, deviceNameBytes );

        if ( !deviceName ) {
            status = GetLastError();
            goto FnExit;
        }

        CopyMemory( deviceName,
                    volGuid,
                    deviceNameBytes );

        //
        // If user specified \\?\Volume{guid}\ with trailing backslash, we need to get
        // rid of the backslash.
        //

        lenChar = wcslen( deviceName );

        if ( lenChar > 1 && L'\\' == deviceName[lenChar-1] ) {
            deviceName[lenChar-1] = L'\0';
        }


    } else {
        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    fileHandle = CreateFileW( deviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL );
    if ( (fileHandle == INVALID_HANDLE_VALUE) ||
         (fileHandle == NULL) ) {
        status = GetLastError();
        (DiskpLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"ConvertDriveToSignature, error opening device '%1!ws!'. Error: %2!u!\n",
            deviceName,
            status );
        goto FnExit;
    }

    //
    // Get drive layout - in order to get disk signature.
    //
    success = ClRtlGetDriveLayoutTable( fileHandle, &driveLayout, NULL );

    if ( success &&
         driveLayout->Signature ) {
        Params->Signature = driveLayout->Signature;

        if ( Params->Drive ) {
            LocalFree( Params->Drive );
            Params->Drive = NULL;
        }

        if ( Params->VolGuid ) {
            LocalFree( Params->VolGuid );
            Params->VolGuid = NULL;
        }

    } else {
        status = ERROR_FILE_NOT_FOUND;
    }

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }
    CloseHandle( fileHandle );

FnExit:

    if ( deviceName ) {
        LocalFree( deviceName );
    }

    return(status);

} // DisksConvertDriveToSignature


DWORD
DisksValidatePrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PDISK_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Physical Disk.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly or is invalid.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           enableSanBoot;
    DWORD           diskNumber;
    DWORD           oldSerNumLen = 0;
    DWORD           newSerNumLen = 0;
    DISK_PARAMS     params;
    PDISK_PARAMS    pParams;
    PDISK_PARAMS    currentParams = &ResourceEntry->DiskInfo.Params;
    PSCSI_ADDRESS_ENTRY criticalDiskList = NULL;

    SCSI_ADDRESS            scsiAddress;
    CLUSPROP_SCSI_ADDRESS   clusScsiAddress;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &params;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(DISK_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) currentParams,
                                       DiskResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties. Accept the alternate name here.
    //
    status = ResUtilVerifyPropertyTable( DiskResourcePrivatePropertiesAlt,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );
    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //
    // First make sure there are no bogus properties - i.e. we don't allow
    // specifying both the signature and the drive in the same request.
    // We also don't allow specifying the VolGuid and signature in the same
    // request.
    //
    if ( (pParams->Drive || pParams->VolGuid) && pParams->Signature ) {
        status = ERROR_INVALID_PARAMETER;
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DisksValidatePrivateResProperties: Can't specify Drive and Signature (or VolGuid and Signature) \n" );
        goto FnExit;
    }

    if ( pParams->Drive || pParams->VolGuid ) {
        //
        // Convert from drive to signature.
        //
        status = DisksConvertDriveToSignature( pParams,
                                               ResourceEntry->ResourceHandle );
    }

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DisksValidatePrivateResProperties: Can't convert Drive (or VolGuid) to Signature \n" );
        goto FnExit;
    }

    //
    // Verify the new serial number is valid and not overwriting an existing
    // serial number.
    //

    if ( pParams->SerialNumber ) {
        newSerNumLen = wcslen( pParams->SerialNumber );
    }

    if ( currentParams->SerialNumber ) {
        oldSerNumLen = wcslen( currentParams->SerialNumber );
    }

    //
    // If there was an old serial number, make sure the new serial number is
    // the same.
    //

    if ( oldSerNumLen &&
            ( oldSerNumLen != newSerNumLen ||
              0 != wcsncmp( currentParams->SerialNumber, pParams->SerialNumber, newSerNumLen ) ) ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DisksValidatePrivateResProperties: New serial number does not match existing serial number \n" );
        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    // Check serial number and signature.
    //

    if ( 0 == oldSerNumLen &&
         pParams->SerialNumber &&
         0 == currentParams->Signature ) {

        //
        // New serial number specified and no current signature.
        //

        if ( 0 == pParams->Signature ) {

            //
            // No new signature specified, use the new serial number to
            // find the new signature.
            //

            status = GetSignatureFromSerialNumber( pParams->SerialNumber,
                                                   &pParams->Signature );

            if ( status != ERROR_SUCCESS ) {

                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"DisksValidatePrivateResProperties: Unable to get signature for serial number \n" );

                goto FnExit;
            }

        } else {

            //
            // New signature and new serial number specified.  Fail the request.
            //

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"DisksValidatePrivateResProperties: Can't specify both signature and serial number \n" );

            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }
    }

    //
    // Validate the parameter values.
    //
    // Make sure the disk signature is not zero.
    //

    if ( 0 == pParams->Signature ) {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DisksValidatePrivateResProperties: Signature not set or zero specified \n" );

        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    // At this point, we have a valid disk signature.

    //
    // If we have no serial number, get it.  If we can't get the serial number,
    // continue processing.  Some disks don't return serial numbers.
    //

    if ( !pParams->SerialNumber || newSerNumLen <= 1 ) {

        GetSerialNumber( pParams->Signature,
                         &pParams->SerialNumber );
    }

    //
    // Check if disk is on system bus.  If we can't get the SCSI address,
    // assume the disk is not on system bus.
    //

    ZeroMemory( &clusScsiAddress, sizeof(clusScsiAddress) );
    status = GetScsiAddress( pParams->Signature, &clusScsiAddress.dw, &diskNumber );

    if ( ERROR_SUCCESS != status ) {

        // Reset return value to success.

        status = ERROR_SUCCESS;

        // Don't fail with error here - fall through...

    } else {

        //
        // Make sure we don't have a dynamic disk.
        //

        if ( DiskIsDynamic( diskNumber ) ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"DisksValidatePrivateResProperties: Disk signature %1!08x! is dynamic \n",
                  pParams->Signature );
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

        scsiAddress.Length      = sizeof(SCSI_ADDRESS);
        scsiAddress.PortNumber  = clusScsiAddress.PortNumber;
        scsiAddress.PathId      = clusScsiAddress.PathId;
        scsiAddress.TargetId    = clusScsiAddress.TargetId;
        scsiAddress.Lun         = clusScsiAddress.Lun;

        GetCriticalDisks( &criticalDiskList );

        //
        // Make sure the SCSI address is not system disk.
        //

        enableSanBoot = 0;
        GetRegDwordValue( CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                          CLUSREG_VALUENAME_MANAGEDISKSONSYSTEMBUSES,
                          &enableSanBoot );


        if ( !enableSanBoot ) {

            //
            // Signature is valid if:
            //  - the signature is for a disk not on system bus
            //  - the signature is for a disk not on same bus as paging disk
            //

            if ( IsBusInList( &scsiAddress, criticalDiskList ) ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"DisksValidatePrivateResProperties: Disk signature %1!08x! is on critical bus \n",
                      pParams->Signature );
                status = ERROR_INVALID_PARAMETER;
                goto FnExit;
            }

        } else {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"DisksValidatePrivateResProperties: Enable SAN boot key set \n" );

            // Allow disks on system bus to be added to cluster.

            //
            // Signature is valid if:
            //  - the signature is not for the system disk
            //  - the signature is not a pagefile disk

            if ( IsDiskInList( &scsiAddress, criticalDiskList ) ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"DisksValidatePrivateResProperties: Disk signature %1!08x! is critical disk \n",
                      pParams->Signature );
                status = ERROR_INVALID_PARAMETER;
                goto FnExit;
            }

        }

    }

    //
    // For now, we don't allow setting mount point volume GUIDs this way.
    // This is a multi SZ string, so use memcmp to skip past each string's
    // terminating NULL.
    //

    if ( ( currentParams->MPVolGuidsSize != pParams->MPVolGuidsSize ) ||
         ( 0 != memcmp( currentParams->MPVolGuids, pParams->MPVolGuids, currentParams->MPVolGuidsSize ) ) ) {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DisksValidatePrivateResProperties: Can't set MP Volume GUIDs \n" );

        status = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

FnExit:

    //
    // Cleanup our parameter block.
    //
    if ( pParams == &params ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                   DiskResourcePrivateProperties );
    }

    if ( criticalDiskList ) {
        CleanupScsiAddressList( criticalDiskList );
    }

    return(status);

} // DisksValidatePrivateResProperties



DWORD
DisksSetPrivateResProperties(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Physical Disk.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DISK_PARAMS     params;

    ZeroMemory( &params, sizeof(DISK_PARAMS) );

    //
    // Parse and validate the properties.
    //
    status = DisksValidatePrivateResProperties( ResourceEntry,
                                                InBuffer,
                                                InBufferSize,
                                                &params );
    if ( status != ERROR_SUCCESS ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                   DiskResourcePrivateProperties );
        return(status);
    }

    //
    // We cannot allow changing the Signature 'on the fly'...
    //
    if ( (ResourceEntry->DiskInfo.Params.Signature != 0) &&
         (params.Signature != ResourceEntry->DiskInfo.Params.Signature) ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                   DiskResourcePrivateProperties );
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties doesn't allow changing signature, old %1!lx!, new %2!lx!\n",
            ResourceEntry->DiskInfo.Params.Signature,
            params.Signature );
        return(ERROR_INVALID_STATE);
    }

    //
    // Save the parameter values.
    //
    // NB: Unknown, or non-property table values are dealt with farther below.  That is why InBuffer and
    // InBufferSize are not used in this call.  Only the propertys in the parameter block are handled here.
    //
    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ResourceParametersKey,
                                               DiskResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               NULL,
                                               0,
                                               (LPBYTE) &ResourceEntry->DiskInfo.Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->DiskInfo.Params,
                               DiskResourcePrivateProperties );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error %1!d! saving properties\n",
            status );
        return(status);
    }

    //
    // Save any unknown properties.
    //
    status = ResUtilSetUnknownProperties(
                ResourceEntry->ResourceParametersKey,
                DiskResourcePrivatePropertiesAlt,
                InBuffer,
                InBufferSize );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"SetPrivateResProperties: Error %1!d! saving unknown properties\n",
            status );
    }

    //
    // Try to attach to this device if we have a signature.
    //
    if ( ResourceEntry->DiskInfo.Params.Signature ) {
#if 0
        DiskspVerifyState(  ResourceEntry );
#endif
        DoAttach( ResourceEntry->DiskInfo.Params.Signature,
                  ResourceEntry->ResourceHandle,
                  TRUE );                           // Dismount, then offline
        // ignore status return
    }

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( ResourceEntry->Valid ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // DisksSetPrivateResProperties


#define ASRP_GET_LOCAL_DISK_INFO    "AsrpGetLocalDiskInfo"
#define ASRP_GET_LOCAL_VOLUME_INFO  "AsrpGetLocalVolumeInfo"



DWORD
ProcessDllExtension(
    IN PDISK_RESOURCE ResourceEntry,
    IN PVOID    InBuffer,
    IN DWORD    InBufferSize,
    OUT PVOID   OutBuffer,
    IN DWORD    OutBufferSize,
    OUT LPDWORD BytesReturned
    )
/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION control function
    for resources of type Physical Disk.  This routine calls a specific
    DLL and DLL entry point, as required by ASR.  This routine will call
    into that entry point with the disk device name represented by the
    Signature parameter.

Arguments:

    ResourceEntry -

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to a buffer containing output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - the number of bytes returned (or needed if larger than
                OutBufferSize and ERROR_MORE_DATA is returned

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The input data is formatted incorrectly.

    ERROR_REVISION_MISMATCH - The input buffer did not have the correct
        revision information.

    ERROR_MORE_DATA - The output buffer is not large enough to hold all
        the requested data.

    Win32 error code - The function failed.

--*/
{
    lpPassThruFunc  passThruFunc = NULL;

    PCHAR           contextStr;
    PCHAR           deviceName = NULL;
    PCHAR           dllProcName;

    PDISK_DLL_EXTENSION_INFO    passThru = InBuffer;

    HINSTANCE       dllModule = NULL;
    DWORD           scsiAddress;
    DWORD           diskNumber;
    DWORD           dwStatus;
    DWORD           signature = ResourceEntry->DiskInfo.Params.Signature;
    const DWORD     deviceNameChars = MAX_PATH;

    if ( !InBuffer || !OutBuffer || !OutBufferSize ) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    if ( InBufferSize < sizeof(DISK_DLL_EXTENSION_INFO) ) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    try {

        if ( passThru->MajorVersion != NT5_MAJOR_VERSION ||
             passThru->MinorVersion != 0 ) {

            dwStatus = ERROR_REVISION_MISMATCH;
            leave;
        }

        //
        // Get the DLL entry point name from the Input buffer.
        //

        dllProcName = passThru->DllProcName;

        if ( CSTR_EQUAL != CompareStringA( LOCALE_INVARIANT,
                                           NORM_IGNORECASE,
                                           dllProcName,
                                           strlen(dllProcName),
                                           ASRP_GET_LOCAL_DISK_INFO,
                                           strlen(ASRP_GET_LOCAL_DISK_INFO) ) &&
             CSTR_EQUAL != CompareStringA( LOCALE_INVARIANT,
                                           NORM_IGNORECASE,
                                           dllProcName,
                                           strlen(dllProcName),
                                           ASRP_GET_LOCAL_VOLUME_INFO,
                                           strlen(ASRP_GET_LOCAL_VOLUME_INFO) ) ) {

            dwStatus = ERROR_INVALID_PARAMETER;
            leave;
        }
        //
        // No check on the ContextStr.
        //

        contextStr = passThru->ContextStr;

        //
        // Get the SCSI address to build the device name.
        //

        dwStatus = GetScsiAddress( signature, &scsiAddress, &diskNumber );

        if ( NO_ERROR != dwStatus ) {
            leave;
        }

        deviceName = LocalAlloc( LPTR, deviceNameChars );

        if ( !deviceName ) {
            dwStatus = GetLastError();
            leave;
        }

        //
        // Called routine is expecting device name to be an ANSI string.
        //

        (VOID) StringCchPrintfA( deviceName,
                                 deviceNameChars,
                                 "\\\\.\\PhysicalDrive%d",
                                 diskNumber );

        //
        // Assume the DLL has not yet been loaded into the address space.
        //
        // Security team says not to use the full path name for DLLs shipped with
        // the OS in the system32 directory.  This DLL is shipped with the OS.
        // This call expects a wide string.
        //

        dllModule = LoadLibrary( L"syssetup.dll" );

        if ( NULL == dllModule ) {
            dwStatus = GetLastError();
            leave;
        }

        //
        // The function name MUST be as defined (i.e. with exactly the same type
        // and number of parameters) or we will have stack problems.
        // This call expects an ANSI string.
        //

        passThruFunc = (lpPassThruFunc)GetProcAddress( dllModule, dllProcName );

        if ( NULL == passThruFunc ) {

            //
            // The specified function is not available in the DLL, exit now.
            //

            dwStatus = GetLastError();
            leave;
        }

        //
        // Call into the specified DLL.
        //

        dwStatus = (passThruFunc)( deviceName,
                                   contextStr,
                                   OutBuffer,
                                   OutBufferSize,
                                   BytesReturned );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        dwStatus = GetExceptionCode();

        (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"ProcessDllExtension: Exception occurred %1!u! \n",
                         dwStatus );
    }

FnExit:

    if ( dllModule ) {
        FreeLibrary( dllModule );
    }

    if ( deviceName ) {
        LocalFree( deviceName );
    }

    return dwStatus;

}   // ProcessDllExtension


DWORD
DisksOpenChkdskLogFile(
    IN PDISK_RESOURCE ResourceEntry,
    IN OUT PHANDLE ChkdskLogFile,
    IN OUT LPWSTR *ChkdskLogFileName
    )
/*++

Routine Description:

    Creates a file to log chkdsk output and returns the handle to the caller.
    The file will not be deleted on close.

Arguments:

    ResourceEntry - Supplies a pointer to the resource structure

    ChkdskLogFile - Returned handled of newly opened log file.

    ChkdskLogFileName - String pointer to the name of the newly
                        opened log file.  Caller is responsible
                        for freeing storage.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD status = NO_ERROR;
    HANDLE retHandle = INVALID_HANDLE_VALUE;

    PWCHAR last;
    PWCHAR current;

    LPWSTR clusterDir = NULL;
    LPWSTR fileName = NULL;
    LPWSTR finalFileName = NULL;

    DWORD clusterDirLength;             // This value can change.
    DWORD fileNameLength = MAX_PATH;
    DWORD finalFileNameLength;

    SECURITY_ATTRIBUTES sa;

    if ( !ChkdskLogFile || !ChkdskLogFileName ) {
        return ERROR_INVALID_PARAMETER;
    }

    *ChkdskLogFile = INVALID_HANDLE_VALUE;
    *ChkdskLogFileName = NULL;

    _try {

        //
        // Get the environment variable "ClusterLog".  Embedded in this string
        // is the cluster directory.
        //

        clusterDir = LocalAlloc( LMEM_FIXED, MAX_PATH * sizeof(WCHAR) );
        if ( !clusterDir ) {
            status = GetLastError();
            _leave;
        }

        clusterDirLength = GetEnvironmentVariableW( CLUSTERLOG_ENV_VARIABLE,
                                                    clusterDir,
                                                    MAX_PATH );

        if ( !clusterDirLength ) {
            status = GetLastError();
            _leave;
        }

        if ( clusterDirLength > MAX_PATH ) {

            LocalFree( clusterDir );
            clusterDir = LocalAlloc( LMEM_FIXED, clusterDirLength * sizeof( WCHAR ) );
            if ( NULL == clusterDir ) {
                status = GetLastError();
                _leave;
            }

            clusterDirLength = GetEnvironmentVariableW( CLUSTERLOG_ENV_VARIABLE,
                                                        clusterDir,
                                                        clusterDirLength );

            if ( !clusterDirLength ) {
                status = GetLastError();
                LocalFree( clusterDir );
                clusterDir = NULL;
                _leave;
            }
        }

        //
        // We have the log file path and name.  Find the last backslash and strip off the
        // log file name.  This will be used as our temporary file path.
        //

        last = NULL;
        current = (PWCHAR) clusterDir;

        while ( *current != L'\0' ) {

            if ( L'\\' == *current ) {
                last = current;
            }
            current++;
        }

        if ( !last ) {
            status = ERROR_BAD_FORMAT;
            _leave;
        }

        //
        // Change the last backslash to the end of string mark.
        //

        *last = L'\0';

        //
        // Now create a file name based on the disk signature.
        //

        fileName = LocalAlloc( LPTR, fileNameLength * sizeof(WCHAR) );
        if ( !fileName ) {
            status = GetLastError();
            _leave;
        }

        if ( FAILED( StringCchPrintf( fileName,
                                      fileNameLength,
                                      TEXT("\\ChkDsk_Disk%d_Sig%08X.log"),
                                      ResourceEntry->DiskInfo.PhysicalDrive,
                                      ResourceEntry->DiskInfo.Params.Signature ) ) ) {
            status = ERROR_INSUFFICIENT_BUFFER;
            _leave;
        }

        //
        // Put it all together for the final name.
        //

        finalFileNameLength = fileNameLength + clusterDirLength + MAX_PATH;

        finalFileName = LocalAlloc( LPTR, finalFileNameLength * sizeof(WCHAR));
        if ( !finalFileName ) {
            status = GetLastError();
            _leave;
        }

        (VOID) StringCchCopy( finalFileName,
                              finalFileNameLength,
                              clusterDir );
        (VOID) StringCchCat( finalFileName,
                             finalFileNameLength,
                             fileName );

        //
        // Now open up the file name to log the chkdsk info.
        //

        ZeroMemory( &sa, sizeof(sa) );
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle = TRUE;

        retHandle = CreateFileW( finalFileName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 &sa,
                                 CREATE_ALWAYS,             // Create a new file or overwrite existing file
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL );

        if ( INVALID_HANDLE_VALUE == retHandle ) {
            status = GetLastError();
            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DisksOpenChkdskLogFile: CreateFile returned status of %1!u! \n",
                            status );
            _leave;
        }

        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"DisksOpenChkdskLogFile: chkdsk.exe output is in file: %1!s! \n",
                        finalFileName );

    } _finally {

        *ChkdskLogFile = retHandle;

        if ( clusterDir ) {
            LocalFree( clusterDir );
        }

        if ( fileName ) {
            LocalFree( fileName );
        }

        if ( finalFileName ) {
            *ChkdskLogFileName = finalFileName;
        }
    }

    return status;

}   // DisksOpenChkdskLogFile


DWORD
GetRegDwordValue(
    IN LPWSTR RegKeyName,
    IN LPWSTR ValueName,
    OUT LPDWORD ValueBuffer
    )
{
    DWORD   dwValue;
    DWORD   dwValueType;
    DWORD   dwDataBufferSize = sizeof( DWORD );
    DWORD   dwError;

    HKEY    hKey = NULL;

    if ( !ValueBuffer ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    // Don't set the default value in case the caller has already done so.
    // *ValueBuffer = 0;

    //
    // Open the specified registry key.
    //

    dwError = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                             RegKeyName,
                             0,
                             KEY_READ,
                             &hKey );

    if ( ERROR_SUCCESS != dwError ) {
        goto FnExit;
    }

    //
    // Get the DWORD value.
    //

    dwError = RegQueryValueExW( hKey,
                                ValueName,
                                NULL,
                                &dwValueType,
                                (LPBYTE) &dwValue,
                                &dwDataBufferSize );

    if ( ERROR_SUCCESS == dwError ) {

        // Insure that a DWORD value was returned.  If not, return an error.

        if ( REG_DWORD == dwValueType && sizeof(DWORD) == dwDataBufferSize ) {

            *ValueBuffer = dwValue;

        } else {

            dwError = ERROR_BAD_FORMAT;

        }
    }

FnExit:

    if ( hKey ) {
        RegCloseKey( hKey );
    }


    return dwError;

}   // GetRegDwordValue


BOOL
DiskIsDynamic(
    IN DWORD DiskNumber
    )
/*
Routine Description:

    Determine if the disk has any dynamic partitions.

Arguments:

    DiskNumber - physical disk number

Return Value:

    TRUE - if the disk has dynamic partitions or any other type of
           error occurred (can't open disk, can't read drive layout)

    FALSE - disk has no dynamic partitions

*/
{
    PDRIVE_LAYOUT_INFORMATION   driveLayout = NULL;
    PPARTITION_INFORMATION      partitionInfo;
    PWCHAR                      deviceName = NULL;

    HANDLE  deviceHandle = INVALID_HANDLE_VALUE;

    DWORD   deviceNameChars = MAX_PATH;
    DWORD   idx;

    BOOL    success;
    BOOL    retVal = FALSE;

    deviceName = LocalAlloc( LPTR, deviceNameChars * sizeof(WCHAR) );

    if ( !deviceName ) {
        (DiskpLogEvent)(
              RESOURCE_TYPE,
              LOG_WARNING,
              L"DiskIsDynamic: allocating buffer for disk %1!u! failed %2!u! \n",
              DiskNumber,
              GetLastError() );
        retVal = TRUE;
        goto FnExit;
    }

    (VOID) StringCchPrintf( deviceName,
                            deviceNameChars,
                            TEXT("\\\\.\\\\PhysicalDrive%d"),
                            DiskNumber );

    deviceHandle = CreateFile( deviceName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

    if ( INVALID_HANDLE_VALUE == deviceHandle ) {
        (DiskpLogEvent)(
              RESOURCE_TYPE,
              LOG_WARNING,
              L"DiskIsDynamic: opening disk %1!u! failed %2!u! \n",
              DiskNumber,
              GetLastError() );
        retVal = TRUE;
        goto FnExit;
    }

    UpdateCachedDriveLayout( deviceHandle );
    success = ClRtlGetDriveLayoutTable( deviceHandle,
                                        &driveLayout,
                                        NULL );

    if ( !success || !driveLayout || 0 == driveLayout->Signature ) {
        retVal = TRUE;
        goto FnExit;
    }

    //
    // Walk through partitions and make sure none are dynamic.  If any
    // partition is dynamic, ignore the disk.
    //

    for ( idx = 0; idx < driveLayout->PartitionCount; idx++ ) {
        partitionInfo = &driveLayout->PartitionEntry[idx];

        if ( 0 == partitionInfo->PartitionNumber ) {
            continue;
        }

        //
        // If any partition on the disk is dynamic, skip the disk.
        //

        if ( PARTITION_LDM == partitionInfo->PartitionType ) {

            (DiskpLogEvent)(
                  RESOURCE_TYPE,
                  LOG_WARNING,
                  L"DiskIsDynamic: skipping dynamic disk with signature %1!08x! \n",
                  driveLayout->Signature );

            retVal = TRUE;

            goto FnExit;
        }
    }

FnExit:

    if ( deviceName ) {
        LocalFree( deviceName );
    }

    if ( driveLayout ) {
        LocalFree( driveLayout);
    }

    if ( INVALID_HANDLE_VALUE != deviceHandle ) {
        CloseHandle( deviceHandle );
    }

    return retVal;

}   // DiskIsDynamic



//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( DisksFunctionTable,
                         CLRES_VERSION_V1_00,
                         Disks,
                         DisksArbitrate,
                         DisksRelease,
                         DisksResourceControl,
                         DisksResourceTypeControl );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\newdisks.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    newdisks.h

Abstract:

    Definitions exported by newdisks.c
    and used by disks.c

Author:

    Gor Nishanov (GorN) 31-July-1998

Revision History:

--*/

DWORD
DisksOnlineThread(
    IN PCLUS_WORKER Worker,
    IN PDISK_RESOURCE ResourceEntry
    );
/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the cluster worker context

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

DWORD
DisksOpenResourceFileHandle(
    IN PDISK_RESOURCE ResourceEntry,
    IN PWCHAR         InfoString,
    OUT PHANDLE       fileHandle OPTIONAL
    );
/*++

Routine Description:

    Open a file handle for the resource.
    It performs the following steps:
      1. Read Disk signature from cluster registry
      2. Attaches clusdisk driver to a disk with this signature
      3. Gets Harddrive no from ClusDisk driver registry
      4. Opens \\.\PhysicalDrive%d device and returns open handle

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

    InfoString - Supplies a label to be printed with error messages

    fileHandle - receives file handle


Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

enum {
  OFFLINE   = FALSE,
  TERMINATE = TRUE
};

DWORD
DisksOfflineOrTerminate(
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL Terminate
    );
/*++

Routine Description:

    Used by DisksOffline and DisksTerminate.

    Routine performs the following steps:

      1. ClusWorkerTerminate (Terminate only)

      2. Then For all of the partitions on the drive...

         a. Flush the file buffers.                                        (Offline only)
         b. Lock the volume to purge all in memory contents of the volume. (Offline only)
         c. Dismount the volume

      3. Removes default network shares (C$, F$, etc)


Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

    Terminate     - Set it to TRUE to cause Termination Behavior


Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/


enum {
   MOUNTIE_VALID  = 0x1,
   MOUNTIE_THREAD = 0x2,
   MOUNTIE_QUIET  = 0x4,
};

DWORD
DiskspSsyncDiskInfo(
    IN PWCHAR InfoLabel,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD Options
    );
/*++

Routine Description:

    Restores the disk registry information
    if necessary.

Arguments:

    InfoLabel - Supplies a label to be printed with error messages

    ResourceEntry - Supplies the disk resource structure.

    Options - 0 or combination of the following:

        MOUNTIE_VALID: ResourceEntry contains up to date MountieInfo.
                       If this flag is not set, MountieInfo will be recomputed

        MOUNTIE_THREAD: If ERROR_SHARING_PAUSED prevents updating cluster registry,
                        launch a thread to do it later

        MOUNTIE_QUIET: Quiet mode. Less noise in logs.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

DWORD
DisksIsVolumeDirty(
    IN PWCHAR         DeviceName,
    IN PDISK_RESOURCE ResourceEntry,
    OUT PBOOL         Dirty
    );

DWORD
DiskspCheckPath(
    IN LPWSTR VolumeName,
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL OpenFiles,
    IN BOOL LogFileNotFound
    );


/////////////////////////////////////////////////////////////////

//
// Import the following from disks.c
//
extern CRITICAL_SECTION DisksLock;
extern RESUTIL_PROPERTY_ITEM DiskResourcePrivateProperties[];
extern HANDLE DisksTerminateEvent;
extern LIST_ENTRY DisksListHead;

DWORD
DisksFixCorruption(
    IN PWCHAR VolumeName,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD CorruptStatus
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\newmount.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    newmount.h

Abstract:

    Replacement for mountie.h

Author:

    Gor Nishanov (GorN) 31-July-1998

Environment:

    User Mode

Revision History:


--*/

typedef struct _MOUNTIE_PARTITION {
    LARGE_INTEGER   StartingOffset;
    LARGE_INTEGER   PartitionLength;
    DWORD           PartitionNumber;
    UCHAR           PartitionType;
    UCHAR           DriveLetter;
    USHORT          Reserved; // must be 0 //
} MOUNTIE_PARTITION, *PMOUNTIE_PARTITION;

// PARTITION_INFORMATION

typedef struct _MOUNTIE_VOLUME {
    DWORD         Signature;
    DWORD         PartitionCount;
    MOUNTIE_PARTITION Partition[1];
} MOUNTIE_VOLUME, *PMOUNTIE_VOLUME;


#define NICE_DRIVE_LETTER(x) ((x)?(x):'?')

NTSTATUS
GetAssignedLetter (
    PWCHAR deviceName,
    PCHAR driveLetter
    );

PVOID
DoIoctlAndAllocate(
    IN HANDLE FileHandle,
    IN DWORD  IoControlCode,
    IN PVOID  InBuf,
    IN ULONG  InBufSize,
    OUT LPDWORD BytesReturned
    );

NTSTATUS
DevfileOpen(
    OUT HANDLE *Handle,
    IN wchar_t *pathname
    );

NTSTATUS
DevfileOpenEx(
    OUT HANDLE *Handle,
    IN wchar_t *pathname,
    IN ACCESS_MASK Access
    );

VOID
DevfileClose(
    IN HANDLE Handle
    );


DWORD
MountieRecreateVolumeInfoFromHandle(
   IN  HANDLE FileHandle,
   IN  DWORD  HarddiskNo,
   IN  HANDLE ResourceHandle,
   IN OUT PMOUNTIE_INFO Info
   );

VOID
MountieCleanup(
   IN OUT PMOUNTIE_INFO Info
   );

DWORD
VolumesReady(
   IN PMOUNTIE_INFO Info,
   IN PDISK_RESOURCE ResourceEntry
   );

DWORD
VolumesReadyLoop(
   IN PMOUNTIE_INFO Info,
   IN PDISK_RESOURCE ResourceEntry
   );

DWORD
MountieFindPartitionsForDisk(
    IN DWORD HarddiskNo,
    OUT PMOUNTIE_INFO MountieInfo
    );

DWORD
DisksGetLettersForSignature(
    IN PDISK_RESOURCE ResourceEntry
    );

DWORD
MountieUpdate(
   PMOUNTIE_INFO Info,
   PDISK_RESOURCE ResourceEntry
   );

DWORD
MountieVerify(
   PMOUNTIE_INFO info,
   PDISK_RESOURCE ResourceEntry,
   BOOL UseMountMgr
   );

DWORD
MountiePartitionCount(
   IN PMOUNTIE_INFO Info
   );

PMOUNTIE_PARTITION
MountiePartition(
   IN PMOUNTIE_INFO Info,
   IN DWORD Index
   );

VOID
MountiePrint(
   IN PMOUNTIE_INFO Info,
   IN HANDLE ResourceHandle
   );

NTSTATUS
DevfileIoctl(
    IN HANDLE Handle,
    IN DWORD Ioctl,
    IN PVOID InBuf,
    IN ULONG InBufSize,
    IN OUT PVOID OutBuf,
    IN DWORD OutBufSize,
    OUT LPDWORD returnLength
    );

DWORD
SetDiskInfoThread(
    LPVOID lpThreadParameter
    );

DWORD
MountieVerifyMsdosDrives(
    IN PMOUNTIE_INFO Info,
    IN PDISK_RESOURCE ResourceEntry
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\mountpoints.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mountpoints.c

Abstract:

    This module processes mount point information for the disk resource DLL.

Author:

    Steve Dziok (stevedz) 15-May-2000

Environment:

    User Mode

Revision History:

--*/

#define UNICODE 1

#include "disksp.h"

#include "arbitrat.h"
#include "newdisks.h"
#include "newmount.h"
#include <mountmgr.h>
#include <strsafe.h>    // Should be included last.

#define SPACE_CHAR  L' '

#define MAX_OFFSET_CHARS    80      // Maximum number of chars allowed in offset string
#define MP_ALLOC_SIZE       1024

#define LOG_CURRENT_MODULE LOG_MODULE_DISK

extern  PWCHAR g_DiskResource;                      // L"rtPhysical Disk"
#define RESOURCE_TYPE ((RESOURCE_HANDLE)g_DiskResource)

#ifndef ClusterHashGuid

//
// Hash a GUID to a ULONG value.
//

#define ClusterHashGuid(_guid) ( ((PULONG) &(_guid))[0] ^ ((PULONG) &(_guid))[1] ^ \
                                 ((PULONG) &(_guid))[2] ^ ((PULONG) &(_guid))[3] )

#endif

#define MPS_ENABLED                         0x00000001
#define MPS_DELETE_INVALID_MPS              0x00000002  // Not currently used
#define MPS_NONCLUSTERED_TO_CLUSTERED_MPS   0x00000010  // Not currently used
#define MPS_KEEP_EXISTING_MPS               0x00000020  // Not currently used
#define MPS_IGNORE_MAX_VOLGUIDS             0x00000100

#define MAX_ALLOWED_VOLGUID_ENTRIES_PER_DISK    100

#define STOP_CLUSTER_ENUMERATIONS   ERROR_INVALID_PRINTER_COMMAND
#define PHYSICAL_DISK_WSTR  L"Physical Disk"
#define CREATE_FILE_PREFIX  L"\\\\.\\"

#define MAX_GROUP_NAME_LENGTH   MAX_PATH * 2

#define VOL_GUID_STRING_LEN 48

#define MOUNTDEV_WSZ_VOLUME_GUID_PREFIX         L"\\??\\Volume{"        // Forms: \??\Volume{
#define MOUNTDEV_CWCHAR_VOLUME_GUID_PREFIX      11
#define MOUNTDEV_CB_VOLUME_GUID_PREFIX          MOUNTDEV_CWCHAR_VOLUME_GUID_PREFIX * sizeof(WCHAR)

#define MOUNTDEV_LOOKS_LIKE_VOLUME_GUID( name, charCount )                  \
              ( ( charCount > MOUNTDEV_CWCHAR_VOLUME_GUID_PREFIX ) &&       \
                ( !memcmp( name, MOUNTDEV_WSZ_VOLUME_GUID_PREFIX, MOUNTDEV_CB_VOLUME_GUID_PREFIX ) ) )

#define MOUNTDEV_WSZ_ALT_VOLUME_GUID_PREFIX     L"\\\\?\\Volume{"       // Forms: \\?\Volume{
#define MOUNTDEV_CWCHAR_ALT_VOLUME_GUID_PREFIX  11
#define MOUNTDEV_CB_ALT_VOLUME_GUID_PREFIX      MOUNTDEV_CWCHAR_ALT_VOLUME_GUID_PREFIX * sizeof(WCHAR)

#define MOUNTDEV_LOOKS_LIKE_ALT_VOLUME_GUID( name, charCount )              \
              ( ( charCount > MOUNTDEV_CWCHAR_ALT_VOLUME_GUID_PREFIX ) &&   \
                ( !memcmp( name, MOUNTDEV_WSZ_ALT_VOLUME_GUID_PREFIX, MOUNTDEV_CB_ALT_VOLUME_GUID_PREFIX ) ) )

#define MOUNTDEV_CWCHAR_DISK_PATH_PREFIX        3
#define MOUNTDEV_CB_DISK_PATH_PREFIX            MOUNTDEV_CWCHAR_DISK_PATH_PREFIX * sizeof(WCHAR)

#define MOUNTDEV_LOOKS_LIKE_DISK_PATH( name, charCount )                \
              ( ( charCount > MOUNTDEV_CWCHAR_DISK_PATH_PREFIX ) &&     \
                ( (WCHAR)*( name + 1 ) == L':' ) &&                     \
                ( (WCHAR)*( name + 2 ) == L'\\' ) )


#define INPUT_BUFFER_LEN    2048
#define OUTPUT_BUFFER_LEN   2048


typedef struct _SIG_INFO {
    PDISK_RESOURCE ResourceEntry;
    DWORD Signature;
    BOOL Clustered;
    PWSTR GroupName;
} SIG_INFO, *PSIG_INFO;

typedef struct _DEPENDENCY_INFO {
    PDISK_RESOURCE ResourceEntry;
    DWORD   SrcSignature;
    DWORD   TargetSignature;
    BOOL    DependencyCorrect;
} DEPENDENCY_INFO, *PDEPENDENCY_INFO;


typedef struct _STR_LIST {
    LPWSTR  MultiSzList;        // REG_MULTI_SZ string
    DWORD   ListBytes;          // Number of bytes, not number of WCHARs!
}   STR_LIST, *PSTR_LIST;

typedef struct _OFFSET_LIST {
    LARGE_INTEGER       Offset;
    struct _OFFSET_LIST *Next;
} OFFSET_LIST, *POFFSET_LIST;


DWORD
AddStrToList(
    IN PDISK_RESOURCE ResourceEntry,
    IN PWSTR NewStr,
    IN DWORD PartitionNumber,
    IN OUT PSTR_LIST StrList
    );

DWORD
AssignDevice(
    HANDLE MountMgrHandle,
    PWCHAR MountName,
    PWCHAR VolumeDevName
    );

DWORD
CheckDependencies(
    PDISK_RESOURCE ResourceEntry,
    DWORD SrcSignature,
    DWORD TargetSignature,
    PBOOL DependencyCorrect
    );

VOID
CheckMPsForVolume(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR VolumeName
    );

DWORD
CheckMPsOnVolume(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR SrcVolName
    );

DWORD
CheckSignatureClustered(
    PDISK_RESOURCE ResourceEntry,
    DWORD Signature,
    PBOOL IsClustered,
    PWSTR *GroupName
    );

DWORD
CreateVolGuidList(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

DWORD
DeleteVolGuidList(
    PDISK_RESOURCE ResourceEntry
    );

DWORD
DependencyCallback(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    );

#if DBG
VOID
DumpDiskInfoParams(
    PDISK_RESOURCE ResourceEntry
    );
#endif

DWORD
EnumSigDependencies(
    PDISK_RESOURCE ResourceEntry,
    RESOURCE_HANDLE DependentResource,
    DWORD DependsOnSignature,
    PBOOL DependencyCorrect
    );

DWORD
GetBestVolGuid(
    PDISK_RESOURCE ResourceEntry,
    PWSTR GlobalDiskPartName,
    PWSTR VolumeName,
    DWORD VolumeNameChars
    );

DWORD
GetMountPoints(
    PWSTR   VolumeName,
    PWSTR   *VolumePaths
    );

BOOL
GetOffsetFromPartNo(
    DWORD PartitionNo,
    PMOUNTIE_INFO Info,
    PLARGE_INTEGER Offset
    );

BOOL
GetPartNoFromOffset(
    PLARGE_INTEGER Offset,
    PMOUNTIE_INFO Info,
    PDWORD PartitionNumber
    );

DWORD
GetSignatureForVolume(
    PDISK_RESOURCE ResourceEntry,
    PWSTR Volume,
    PDWORD Signature
    );

DWORD
GetSignatureFromRegistry(
    PDISK_RESOURCE ResourceEntry,
    RESOURCE_HANDLE hResource,
    DWORD *dwSignature
    );

BOOL
IsMountPointAllowed(
    PWSTR MpName,
    PWSTR SourceVol,
    PWSTR TargetVol,
    PDISK_RESOURCE ResourceEntry
    );

BOOL
MPIsDriveLetter(
    IN PWSTR MountPoint
    );

DWORD
OffsetListAdd(
    POFFSET_LIST *OffsetList,
    PLARGE_INTEGER Offset
    );

DWORD
OffsetListCleanup(
    POFFSET_LIST OffsetList
    );

VOID
PrintStrList(
    PDISK_RESOURCE ResourceEntry,
    LPWSTR MultiSzList,
    DWORD ListBytes
    );

DWORD
ProcessVolGuidList(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

DWORD
RemoveExcessVolGuids(
    HANDLE MountMgrHandle,
    PWCHAR MountName,
    PWCHAR VolumeDevName
    );

DWORD
RemoveVolGuid(
    HANDLE MountMgrHandle,
    PWCHAR VolGuid,
    USHORT VolGuidSize
    );

static
DWORD
SetMPListThread(
    LPVOID lpThreadParameter
    );

DWORD
SetupVolGuids(
    IN OUT PDISK_RESOURCE ResourceEntry
    );

DWORD
SigInfoCallback(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    );

DWORD
ValidateListOffsets(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR MasterList
    );

DWORD
ValidateMountPoints(
    IN OUT PDISK_RESOURCE ResourceEntry
    );



DWORD
DisksProcessMountPointInfo(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    During online processing, find all mount points directed towards this volume
    (identified by the ResourceEntry), and process the VolGuid list for this
    volume.

    If the VolGuid list exists in the cluster database, use it.  Otherwise,
    get the current VolGuid and add it to the VolGuid list.  Each sector offset
    can only be listed once as the VolGuid will be the same on each node.

    VolGuid list is of the form:

        SectorOffset1 VolGuid1
        SectorOffset2 VolGuid2
        SectorOffset3 VolGuid3
        ...           ...

    There are three possible mount point configurations involving clustered disks (we
    are not concerned about nonshared disks pointing to nonshared disks):

            Source            -->   Target
            -----------------       -----------------
        1.  clustered disk          clustered disk
        2.  nonclustered disk       clustered disk
        3.  clustered disk          nonclustered disk

    Only configuration (1) is supported.  Configurations (2) and (3) are not supported.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    ERROR_NOT_READY - MPInfo structure not yet initialized.

    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;

    //
    // Mount point structures not initialized (i.e. critical section).  Don't continue.
    //

    if ( !ResourceEntry->MPInfo.Initialized ) {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DisksProcessMountPointInfo: Mount point information not initialized. \n" );

        return ERROR_NOT_READY;

    }

#if USEMOUNTPOINTS_KEY
    //
    // Mount point support disabled, don't do anything.
    //

    if ( !( ResourceEntry->DiskInfo.Params.UseMountPoints & MPS_ENABLED ) ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"DisksProcessMountPointInfo: Mount point processing disabled via registry \n" );

        //
        // Delete the VolGuid list if it exists and remove this info
        // from the cluster database.
        //

        dwError = DeleteVolGuidList( ResourceEntry );

        if ( ERROR_SHARING_PAUSED == dwError ) {
            PostMPInfoIntoRegistry( ResourceEntry );
        }

        dwError = NO_ERROR;
        return dwError;
    }
#endif

    //
    // Check if we are currently processing mount point info.  If so, exit with an error.
    //

    if ( InterlockedCompareExchange(
            &ResourceEntry->MPInfo.MPListCreateInProcess,
            1, 0 ) )  {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DisksProcessMountPointInfo: MPList creation in process, bypassing request \n" );
        return ERROR_BUSY;
    }

    __try {

        dwError = ProcessVolGuidList( ResourceEntry );

        ValidateMountPoints( ResourceEntry );

        // Fall through...

#if 0

        // Add code similar to this when MPs from nonclustered to clustered disks is supported.

        if ( ( ResourceEntry->DiskInfo.Params.UseMountPoints & MPS_ENABLED ) &&
             ( ResourceEntry->DiskInfo.Params.UseMountPoints & MPS_NONCLUSTERED_TO_CLUSTERED_MPS ) ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"DisksProcessMountPointInfo: ProcessMPList \n" );

            dwError = ProcessMPListConfig2( ResourceEntry );
#endif

    } __finally {

        InterlockedExchange( &ResourceEntry->MPInfo.MPListCreateInProcess, 0 );
    }

    return dwError;

}   // DisksProcessMountPointInfo


DWORD
ProcessVolGuidList(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Main routine to create a new VolGuid list or to process an existing VolGuid list.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;

    __try {

        //
        // If the list is empty, create it.
        //

        if ( !ResourceEntry->DiskInfo.Params.MPVolGuids ||
             0 == ResourceEntry->DiskInfo.Params.MPVolGuidsSize ) {

            dwError = CreateVolGuidList( ResourceEntry );
            if ( NO_ERROR != dwError ) {
                 (DiskpLogEvent)(
                       ResourceEntry->ResourceHandle,
                       LOG_WARNING,
                       L"ProcessVolGuidList: Stop processing VolGuid list, Create failed %1!u! \n",
                       dwError );
                __leave;
            }
        }

        //
        // If the list is still empty (it shouldn't be), then exit with an error.
        //

        if ( !ResourceEntry->DiskInfo.Params.MPVolGuids ||
             0 == ResourceEntry->DiskInfo.Params.MPVolGuidsSize ) {

            dwError = ERROR_INVALID_DATA;
            __leave;
        }

        PrintStrList( ResourceEntry,
                      ResourceEntry->DiskInfo.Params.MPVolGuids,
                      ResourceEntry->DiskInfo.Params.MPVolGuidsSize );

        //
        // Make sure the offsets are correct in the VolGuid list.
        // Note that it is possible for the list to be deleted and
        // recreated after this validation, but that is not a problem (because
        // when they are recreated they will have the correct offsets).
        //

        dwError = ValidateListOffsets( ResourceEntry,
                                       ResourceEntry->DiskInfo.Params.MPVolGuids );

        if ( ERROR_INVALID_DATA == dwError ) {

            //
            // At least one of the offsets is invalid.  Possibly, the partition
            // layout on the disk has been changed.  Delete the existing
            // list, and create a new one.
            //
            // This code should run infrequently...
            //
            // The partition layout might change if ASR runs and creates new partitions
            // that don't match the previous system exactly.  Since NTBACKUP saves the
            // cluster DB information, the mount point list will be restored but won't
            // match the actual "new" partition layout.  ASR will insure that all the
            // mount points and VolGuids on the system are created, so we should be able
            // to simply delete and recreate the mount point list.
            //

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"ProcessVolGuidList: Problem with existing VolGuid list.  Deleting and recreating. \n" );

            DeleteVolGuidList( ResourceEntry );

            dwError = CreateVolGuidList( ResourceEntry );

            if ( NO_ERROR != dwError ) {
                __leave;
            }

            // Fall through and call SetupVolGuids...

        } else if ( ERROR_INSUFFICIENT_BUFFER == dwError ) {
            //
            // The Volguid list is too large and likely corrupt.  We cannot
            // proceed.
            //

            __leave;
        }

        //
        // For every VolGuid in the list, make sure they are assigned to the correct
        // volumes on this system.
        //

        dwError = SetupVolGuids( ResourceEntry );

    } __finally {

    }

    return dwError;

}   // ProcessVolGuidList


DWORD
CreateVolGuidList(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Create the VolGuid list.  The list must be empty when this routine runs.

    For each partition on this disk (identified by the ResourceEntry), get the byte
    offset of that partition.  Get the best VolGuid for that partition, and add
    it to the list.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    ERROR_INVALID_DATA - partition info in disk resource is invalid

    Win32 error code.

--*/
{
    PMOUNTIE_PARTITION entry;

    HANDLE  mountMgrHandle = INVALID_HANDLE_VALUE;

    DWORD dwError = ERROR_SUCCESS;
    DWORD nPartitions = MountiePartitionCount( &ResourceEntry->MountieInfo );
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;
    DWORD idx;
    DWORD volumeNameLenChars;   // Number of characters
    DWORD newStrListLenBytes;   // Number of bytes

    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];

    STR_LIST    newStrList;

    __try {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"CreateVolGuidList: Creating new VolGuid list \n" );

        EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

        if ( ResourceEntry->DiskInfo.Params.MPVolGuids ||
             0 != ResourceEntry->DiskInfo.Params.MPVolGuidsSize ) {

            LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

            dwError = ERROR_INVALID_PARAMETER;
            __leave;
        }

        LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

        ZeroMemory( &newStrList, sizeof(STR_LIST) );

        dwError = DevfileOpen( &mountMgrHandle, MOUNTMGR_DEVICE_NAME );

        if ( dwError != NO_ERROR ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"CreateVolGuidList: Failed to open MountMgr %1!u! \n",
                  dwError );
            __leave;
        }

        //
        // Check each interesting partition.  Since only "valid" partitions are
        // saved in the MountieInfo structure, we will only look at those (ignoring those
        // partitions that are not NTFS).
        //

        for ( idx = 0; idx < nPartitions; ++idx ) {

            entry = MountiePartition( &ResourceEntry->MountieInfo, idx );

#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"CreateVolGuidList: index %1!u!   entry %2!x! \n", idx, entry );
#endif

            if ( !entry ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"CreateVolGuidList: no partition entry for index %1!u! \n", idx );

                //
                // Something bad happened to our data structures.
                //

                dwError = ERROR_INVALID_DATA;
                __leave;
            }

            //
            // Create the device name of the form:
            //  \\?\GLOBALROOT\Device\HarddiskX\PartitionY\  (uses trailing backslash)
            //

            (VOID) StringCchPrintf( szGlobalDiskPartName,
                                    RTL_NUMBER_OF( szGlobalDiskPartName ),
                                    GLOBALROOT_HARDDISK_PARTITION_FMT,
                                    physicalDrive,
                                    entry->PartitionNumber );

#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"CreateVolGuidList: Using name (%1!ws!) \n",
                  szGlobalDiskPartName );
#endif

            dwError = GetBestVolGuid( ResourceEntry,
                                      szGlobalDiskPartName,
                                      szVolumeName,
                                      RTL_NUMBER_OF(szVolumeName) );

            if ( NO_ERROR != dwError ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"CreateVolGuidList: Unable to get valid VolGuid for (%1!ws!), error %2!u!\n ",
                      szGlobalDiskPartName,
                      dwError );

                // Try next partition.

                continue;
            }

            //
            // Fix current VolGuid name.
            //
            // GetVolumeNameForVolumeMountPoint returns name of the form:
            //      \\?\Volume{-GUID-}\
            //
            // But we need the name to be in the form:
            //      \??\Volume{-GUID-}
            //

            volumeNameLenChars = wcslen( szVolumeName );
            if ( !(MOUNTDEV_LOOKS_LIKE_ALT_VOLUME_GUID( szVolumeName, volumeNameLenChars ) ) ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"CreateVolGuidList: Improper volume name format (%1!ws!) \n",
                      szVolumeName );

                // Try next partition.

                continue;
            }

            szVolumeName[1] = L'?';

            if ( L'\\' == szVolumeName[volumeNameLenChars-1]) {
                szVolumeName[volumeNameLenChars-1] = L'\0';
            }

#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"CreateVolGuidList: Fixed volume name    (%1!ws!) \n",
                  szVolumeName );
#endif

            //
            // Add the new string to the list.  If the new string is already in the list, this
            // routine won't do anything and will return NO_ERROR.
            //

            dwError = AddStrToList( ResourceEntry,
                                    szVolumeName,
                                    entry->PartitionNumber,
                                    &newStrList );

            if ( NO_ERROR != dwError ) {
                __leave;
            }

        }

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"CreateVolGuidList: Saving new VolGuid list \n" );

        //
        // Update the ResourceEntry with the new list information,
        // and update the cluster database.
        //

        EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

        if ( 0 == ResourceEntry->DiskInfo.Params.MPVolGuids &&
             0 == ResourceEntry->DiskInfo.Params.MPVolGuidsSize ) {

            ResourceEntry->DiskInfo.Params.MPVolGuids = newStrList.MultiSzList;
            ResourceEntry->DiskInfo.Params.MPVolGuidsSize = newStrList.ListBytes;
        } else {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"CreateVolGuidList: VolGuid list is not empty - not saving... \n" );

            LocalFree( newStrList.MultiSzList );
        }

        LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

        PrintStrList( ResourceEntry,
                      ResourceEntry->DiskInfo.Params.MPVolGuids,
                      ResourceEntry->DiskInfo.Params.MPVolGuidsSize );

        dwError = PostMPInfoIntoRegistry( ResourceEntry );

    } __finally {

        if ( INVALID_HANDLE_VALUE != mountMgrHandle ) {
            CloseHandle( mountMgrHandle );
        }

    }

    return dwError;

}   // CreateVolGuidList


DWORD
GetBestVolGuid(
    PDISK_RESOURCE ResourceEntry,
    PWSTR GlobalDiskPartName,
    PWSTR VolumeName,
    DWORD VolumeNameChars
    )
/*++

Routine Description:

    Get the best VolGuid for the specified device.

    If the disk has no mountpoints, then just save the current VolGuid.

    If the disk has mountpoints on it, then save the VolGuid
    from the disk.  All the mountpoints on the disk should have
    the same VolGuid.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    GlobalDiskPartName - device to get the VolGuid from.

        \\?\GLOBALROOT\Device\HarddiskX\PartitionY\  (uses trailing backslash)

    VolumeName - buffer to return the VolGuid.

    VolumeNameChars - number of CHARS in VolumeName buffer.

Return Value:

    NO_ERROR - valid VolGuid is returned.

    Win32 error code - VolGuid could not be retrieved.

--*/
{
    PWCHAR  fullName = NULL;
    PWCHAR  mpOnDisk = NULL;
    PWCHAR  mpVolGuid = NULL;

    HANDLE  hVol;

    DWORD   dwError = NO_ERROR;
    DWORD   fullNameChars;
    DWORD   mpOnDiskChars;
    DWORD   mpVolGuidChars;

    mpOnDiskChars = MAX_PATH * sizeof(WCHAR);
    mpOnDisk = LocalAlloc( LPTR, mpOnDiskChars );

    if ( !mpOnDisk ) {
        dwError = GetLastError();
        goto FnExit;
    }

    fullNameChars = MAX_PATH * sizeof(WCHAR) * 2;
    fullName = LocalAlloc( LPTR, fullNameChars );

    if ( !fullName ) {
        dwError = GetLastError();
        goto FnExit;
    }

    mpVolGuidChars = MAX_PATH * sizeof(WCHAR);
    mpVolGuid = LocalAlloc( LPTR, mpVolGuidChars );

    if ( !mpVolGuid ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Get the current VolGuid for this partition.
    //

    if ( !GetVolumeNameForVolumeMountPointW( GlobalDiskPartName,
                                             VolumeName,
                                             VolumeNameChars )) {

        dwError = GetLastError();

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"GetBestVolGuid: GetVolumeNameForVolumeMountPoint for (%1!ws!) returned %2!u!\n",
              GlobalDiskPartName,
              dwError );

        goto FnExit;
    }

    //
    // See if there are mountpoints on the disk.  Note
    // we use the volume name we just received for this
    // device.
    //

    hVol = FindFirstVolumeMountPoint( VolumeName,
                                      mpOnDisk,
                                      mpOnDiskChars );

    if ( INVALID_HANDLE_VALUE == hVol ) {

        //
        // No mountpoints, just use the standard VolGuid.
        //

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"GetBestVolGuid: Using standard volguid (%1!ws!)  \n",
              VolumeName );

        goto FnExit;
    }

    //
    // Disk has mountpoints on it.  Now get the VolGuid from this
    // mountpoint.
    //

    (VOID) StringCchCopy( fullName, fullNameChars, VolumeName );
    (VOID) StringCchCat( fullName, fullNameChars, mpOnDisk );

    if ( !GetVolumeNameForVolumeMountPointW( GlobalDiskPartName,
                                             mpVolGuid,
                                             mpVolGuidChars )) {


        dwError = GetLastError();

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"CreateVolGuidList: Can't get volguid for (%1!ws!), error %2!u! \n",
              fullName,
              dwError );

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"GetBestVolGuid: Using standard volguid (%1!ws!)  \n",
              VolumeName );

        //
        // We couldn't get the VolGuid for the mountpoint, return success
        // and use the standard VolGuid we got earlier.
        //

        dwError = ERROR_SUCCESS;
        goto FnExit;
    }

    FindVolumeMountPointClose( hVol );

    //
    // Use the VolGuid based on the mountpoint.
    //

    (VOID) StringCchCopy( VolumeName, VolumeNameChars, mpVolGuid );

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"GetBestVolGuid: Using mountpoint volguid (%1!ws!)  \n",
          VolumeName );

FnExit:

    LocalFree( fullName );
    LocalFree( mpOnDisk );
    LocalFree( mpVolGuid );

    return dwError;


}   // GetBestVolGuid


DWORD
AddStrToList(
    IN PDISK_RESOURCE ResourceEntry,
    IN PWSTR NewStr,
    IN DWORD PartitionNumber,
    IN OUT PSTR_LIST StrList
    )
/*++

Routine Description:

    Add the string to the MULTI_SZ list.  Convert the partition number to a byte offset
    so we don't rely on partition numbers.

    List format will be:

      ByteOffset1 Str1
      ByteOffset1 Str2
      ByteOffset1 Str3
      ByteOffset2 Str1
      ByteOffset2 Str2
      ByteOffset3 Str1
      ...         ...

Arguments:


Return Value:


--*/
{
    PWCHAR  listEntry = NULL;

    DWORD   listEntrySizeChars;

    DWORD   lenChars;
    DWORD   newStrLenChars;
    DWORD   listChars;
    DWORD   remainingLen;
    DWORD   dwError = ERROR_INVALID_DATA;

    LARGE_INTEGER   offset;

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"AddStrToList: Adding str (%1!ws!) \n", NewStr );
#endif

    newStrLenChars = wcslen( NewStr );

    if ( 0 == newStrLenChars ) {

        //
        // Something wrong with the string length.
        //

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"AddStrToList: Invalid length: NewStrLen = %1!u! \n",
              newStrLenChars );

        goto FnExit;
    }

    //
    // Indicate an error unless we can allocate and copy the info
    // into the list.  Calculate the minimum size needed, then get
    // larger buffer.  This buffer is temporary and freed later.
    //

    listEntrySizeChars = ( newStrLenChars +     // Char length of parameter string
                           MAX_OFFSET_CHARS +   // Char length of offset string
                           1 +                  // Room to change end of offset string to space and extend it
                           1 )                  // Unicode NULL
                           * 2;                 // Make sure buffer is large enough

    listEntry = LocalAlloc( LPTR, listEntrySizeChars * sizeof(WCHAR) );

    if ( !listEntry ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Get the offset for the specified partition.
    //

    if ( !GetOffsetFromPartNo( PartitionNumber,
                               &ResourceEntry->MountieInfo,
                               &offset ) ) {

        //
        // Can't get the offset for the specified partition.
        //

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"AddStrToList: GetOffsetFromPartNo failed \n" );

        goto FnExit;

    }

    //
    // Convert the offset into a string.  Put the offset into listEntry.
    //

    _ui64tow( offset.QuadPart, listEntry, 16 );
    lenChars = wcslen( listEntry );

    if ( 0 == lenChars || lenChars >= MAX_OFFSET_CHARS ) {

        //
        // The length of the offset string is invalid.
        //

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"AddStrToList: Invalid offset string length = %1!u! \n",
              lenChars );

        goto FnExit;

    }

    // Format will be:
    //  ByteOffset1 Str1
    //  ByteOffset1 Str2
    //  ByteOffset1 Str3
    //  ByteOffset2 Str1
    //  ByteOffset2 Str2
    //  ByteOffset3 Str1
    //  ...         ...

    //
    // Change the end of the offset string to another character.  Move the end of string
    // out one character.  This extra space was included when we allocated the buffer.
    //

    listEntry[lenChars+1] = UNICODE_NULL;
    listEntry[lenChars] = SPACE_CHAR;

    //
    // One more check.  Make sure enough space remaining for adding string.
    //

    remainingLen = listEntrySizeChars - wcslen( listEntry ) - 1;

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"AddStrToList: New string length %1!u!   Remaining list entry length %2!u! \n",
          newStrLenChars,
          remainingLen );
#endif

    if ( newStrLenChars >= remainingLen ) {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"AddStrToList: New string length %1!u! larger than remaining list entry length %2!u! \n",
              newStrLenChars,
              remainingLen );
        goto FnExit;
    }

    //
    // Put the rest of the string in list entry.
    //

    wcsncat( listEntry, NewStr, remainingLen );

    //
    // If the string is already in the list, skip it.
    //

    if ( ClRtlMultiSzScan( ResourceEntry->DiskInfo.Params.MPVolGuids, listEntry ) ) {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"AddStrToList: Skipping duplicate entry (%1!ws!) \n",
              listEntry );
        dwError = NO_ERROR;
        goto FnExit;
    }

    //
    // Note that ClRtlMultiSzAppend updates the number of CHARACTERS, but we
    // need to have the number of BYTES in the property table.  We will adjust
    // this value later.
    //

    listChars = StrList->ListBytes / sizeof(WCHAR);

#if DBG

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"AddStrToList: StrList->MultiSzList at %1!p!,  numBytes %2!u!  \n",
          StrList->MultiSzList,
          StrList->ListBytes );

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"AddStrToList: Adding str entry: (%1!ws!) numChars %2!u!  \n",
          listEntry,
          listChars );
#endif

    dwError = ClRtlMultiSzAppend( &(StrList->MultiSzList),
                                  &listChars,
                                  listEntry );

    //
    // Convert the number of CHARACTERS back to bytes.
    //

    StrList->ListBytes = listChars * sizeof(WCHAR);

    if ( ERROR_SUCCESS == dwError) {
#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"AddStrToList: Added str, numBytes %1!u!  numChars %2!u!  \n",
              StrList->ListBytes,
              listChars );
#endif

    } else {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"AddStrToList: Unable to append MultiSz string for (%1!ws!), failed %x \n",
              NewStr,
              dwError );
    }

FnExit:

    if ( listEntry ) {
        LocalFree( listEntry );
    }

    return dwError;

}   // AddStrToList


DWORD
SetupVolGuids(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Add every VolGuid in the existing MULTI_SZ VolGuid list to the system.
    Each volume will only have one VolGuid, and the VolGuid will be the
    same for all nodes.

    Remove any other VolGuids currently assigned to the volumes.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    Win32 error code.

--*/
{
    PWCHAR currentStr;
    PWCHAR volGuid;

    HANDLE  mountMgrHandle = INVALID_HANDLE_VALUE;

    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;
    DWORD currentStrLenChars = 0;
    DWORD dwError = NO_ERROR;
    DWORD partitionNo;
    DWORD count;

    LARGE_INTEGER offset;

    WCHAR szDiskPartName[MAX_PATH];

    __try {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"SetupVolGuids: Processing VolGuid list \n" );

        EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

        dwError = DevfileOpen( &mountMgrHandle, MOUNTMGR_DEVICE_NAME );

        if ( dwError != NO_ERROR ) {
            __leave;
        }

        //
        // Parse through the list.
        //

        for ( currentStr = (PWCHAR)ResourceEntry->DiskInfo.Params.MPVolGuids,
              currentStrLenChars = wcslen( currentStr ) ;
                currentStrLenChars ;
                    currentStr += currentStrLenChars + 1,
                    currentStrLenChars = wcslen( currentStr ) ) {

            offset.QuadPart = 0;

#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"SetupVolGuids: CurrentStr (%1!ws!), numChars %2!u! \n",
                  currentStr,
                  currentStrLenChars );
#endif

            //
            // Convert the offset from a string to a large integer value.
            //

            count = swscanf( currentStr, L"%I64x ", &offset.QuadPart );

            if ( 0 == count ) {
                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"SetupVolGuids: Unable to parse offset from currentStr (%1!ws!) \n",
                      currentStr );
                continue;
            }

            //
            // Convert the offset to a partition number.
            //

            if ( !GetPartNoFromOffset( &offset, &ResourceEntry->MountieInfo, &partitionNo ) ) {

                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"SetupVolGuids: Unable to convert offset ( %1!08X!%2!08X! ) to partition number \n",
                      offset.HighPart,
                      offset.LowPart );                // couldn't get !I64X! to work...

                continue;
            }

            //
            // Get a pointer to the VolGuid data, just after the byte offset.
            //

            volGuid = wcsstr( currentStr, MOUNTDEV_WSZ_VOLUME_GUID_PREFIX );

            if ( !volGuid ) {

                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"SetupVolGuids: Unable to find volume string in current list entry (%1!ws) \n",
                      currentStr );

                continue;
            }

#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"SetupVolGuids: Using VolGuid (%1!ws!) \n",
                  volGuid );
#endif

            //
            // Create the device name of the form:
            //  \Device\HarddiskX\PartitionY  (no trailing backslash)
            //

            (VOID) StringCchPrintf( szDiskPartName,
                                    RTL_NUMBER_OF( szDiskPartName ),
                                    DEVICE_HARDDISK_PARTITION_FMT,
                                    physicalDrive,
                                    partitionNo );

#if DBG
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"SetupVolGuids: Using device name (%1!ws!) \n",
                  szDiskPartName );
#endif

            dwError = AssignDevice( mountMgrHandle, volGuid, szDiskPartName );

            if ( NO_ERROR != dwError &&
                 STATUS_OBJECT_NAME_COLLISION != dwError ) {

                // Assign device will return: 0xC0000035 STATUS_OBJECT_NAME_COLLISION
                // if we are setting a VolGuid that was previously set.  This is not
                // a problem.

                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"SetupVolGuids: Unable to assign VolGuid to device, error %1!u! \n",
                      dwError );

                // Continue processing with error...

            } else {

                //
                // Only remove the other VolGuids if this assignment worked.
                //

                RemoveExcessVolGuids( mountMgrHandle, volGuid, szDiskPartName );
            }

            dwError = STATUS_SUCCESS;

        }


    } __finally {

        if ( INVALID_HANDLE_VALUE != mountMgrHandle ) {
            CloseHandle( mountMgrHandle );
        }

        LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

    }

    return dwError;

}   // SetupVolGuids


DWORD
AssignDevice(
    HANDLE MountMgrHandle,
    PWCHAR MountName,
    PWCHAR VolumeDevName
    )
/*++

Routine Description:

    Put the specified MountName (i.e. mount point name) into the mount manager's internal table
    of mount points.

Inputs:

    MountMgrHandle - Handle to the mount manager.  The caller is responsible for
                     opening and closing this handle.

    MountName - Mountpoint name of the form:

                \??\Volume{-GUID-}  - note prefix "\??\" and no trailing backslash.
                \DosDevices\X:      - works if a drive letter is not already assigned

    VolumeDevName - Volume device name.  Can be one of the following forms (note that case is
                    important).  The "#" is a zero-based device number (and partition number
                    as appropriate).

                    \Device\CdRom#
                    \Device\Floppy#
                    \Device\HarddiskVolume#
                    \Device\Harddisk#\Partition#

Return value:

    A Win32 error code.

--*/
{
    PMOUNTMGR_CREATE_POINT_INPUT input;

    DWORD   status;

    USHORT  mountNameLenBytes;
    USHORT  volumeDevNameLenBytes;

    USHORT  inputlengthBytes;

    if ( INVALID_HANDLE_VALUE == MountMgrHandle ) {
        return ERROR_INVALID_PARAMETER;
    }

    mountNameLenBytes       = wcslen( MountName ) * sizeof(WCHAR);
    volumeDevNameLenBytes   = wcslen( VolumeDevName ) * sizeof(WCHAR);

    inputlengthBytes = sizeof(MOUNTMGR_CREATE_POINT_INPUT) + mountNameLenBytes + volumeDevNameLenBytes;

    input = (PMOUNTMGR_CREATE_POINT_INPUT)LocalAlloc( LPTR, inputlengthBytes );

    if ( !input ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    input->SymbolicLinkNameLength = mountNameLenBytes;
    input->DeviceNameOffset = input->SymbolicLinkNameOffset +
                              input->SymbolicLinkNameLength;
    input->DeviceNameLength = volumeDevNameLenBytes;

    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  MountName, mountNameLenBytes);
    RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                  VolumeDevName, volumeDevNameLenBytes);

    status = DevfileIoctl( MountMgrHandle,
                           IOCTL_MOUNTMGR_CREATE_POINT,
                           input,
                           inputlengthBytes,
                           NULL,
                           0,
                           NULL );

    LocalFree( input );

    return status;

} // AssignDevice


DWORD
RemoveExcessVolGuids(
    HANDLE MountMgrHandle,
    PWCHAR MountName,
    PWCHAR VolumeDevName
    )
/*++

Routine Description:

    Remove all VolGuids except the specified MountName (VolGuid) from the
    mount manager's internal table of mount points.

Inputs:

    MountMgrHandle - Handle to the mount manager.  The caller is responsible for
                     opening and closing this handle.

    MountName - VolGuid to keep.  Format:

                \??\Volume{-GUID-}  - note prefix "\??\" and no trailing backslash.

    VolumeDevName - Volume device name.  Can be one of the following forms (note that case is
                    important).  The "#" is a zero-based device number (and partition number
                    as appropriate).

                    \Device\CdRom#
                    \Device\Floppy#
                    \Device\HarddiskVolume#
                    \Device\Harddisk#\Partition#

Return value:

    A Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;

    PMOUNTMGR_MOUNT_POINT   input  = NULL;
    PMOUNTMGR_MOUNT_POINTS  mountPoints = NULL;
    PMOUNTMGR_MOUNT_POINT   point;

    DWORD len = wcslen( VolumeDevName ) * sizeof(WCHAR);
    DWORD bytesReturned;
    DWORD idx;

    DWORD outputLen;
    DWORD inputLen;
    DWORD pointLen;

    inputLen = INPUT_BUFFER_LEN + len;
    input = LocalAlloc( LPTR, inputLen );

    if ( !input ) {
        dwError = GetLastError();
        goto FnExit;
    }

    input->SymbolicLinkNameOffset = 0;
    input->SymbolicLinkNameLength = 0;
    input->UniqueIdOffset = 0;
    input->UniqueIdLength = 0;
    input->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    input->DeviceNameLength = (USHORT) len;

    CopyMemory((PCHAR)input + input->DeviceNameOffset, VolumeDevName, len );

    if ( VolumeDevName[1] == L'\\' ) {
        // convert Dos name to NT name
        ((PWCHAR)(input + input->DeviceNameOffset))[1] = L'?';
    }

    outputLen = OUTPUT_BUFFER_LEN;
    mountPoints = LocalAlloc( LPTR, outputLen );

    if ( !mountPoints ) {
        dwError = GetLastError();
        goto FnExit;
    }

    if ( !DeviceIoControl( MountMgrHandle,
                           IOCTL_MOUNTMGR_QUERY_POINTS,
                           input,
                           inputLen,
                           mountPoints,
                           outputLen,
                           &bytesReturned,
                           NULL ) ) {

        dwError = GetLastError();

        if ( STATUS_BUFFER_OVERFLOW != dwError ) {
            goto FnExit;
        }

        dwError = NO_ERROR;
        outputLen = mountPoints->Size;
        LocalFree( mountPoints );

        mountPoints = LocalAlloc( LPTR, outputLen );

        if ( !mountPoints ) {
            dwError = GetLastError();
            goto FnExit;
        }

        if ( !DeviceIoControl( MountMgrHandle,
                               IOCTL_MOUNTMGR_QUERY_POINTS,
                               input,
                               inputLen,
                               mountPoints,
                               outputLen,
                               &bytesReturned,
                               NULL ) ) {
            dwError = GetLastError();
        }
    }

    if ( NO_ERROR != dwError ) {
        (DiskpLogEvent)(
              RESOURCE_TYPE,
              LOG_WARNING,
              L"RemoveExcessVolGuids: mountmgr query returns error %1!u! \n",
              dwError );
        goto FnExit;
    }

    for ( idx = 0; idx < mountPoints->NumberOfMountPoints; ++idx ) {
        point = &mountPoints->MountPoints[idx];

        //
        // Delete any VolGuids that mountmgr has that don't match the
        // MountName (VolGuid) parameter.
        //

        if ( VOL_GUID_STRING_LEN * sizeof(WCHAR) == point->SymbolicLinkNameLength &&
             0 != memcmp( (PCHAR)mountPoints + point->SymbolicLinkNameOffset,
                          MountName,
                          point->SymbolicLinkNameLength ) ) {

            RemoveVolGuid( MountMgrHandle,
                           (PWCHAR)((PCHAR)mountPoints + point->SymbolicLinkNameOffset),
                           point->SymbolicLinkNameLength );

        }
    }

FnExit:

    LocalFree( mountPoints );
    LocalFree( input );

    return dwError;

} // RemoveExcessVolGuids


DWORD
RemoveVolGuid(
    HANDLE MountMgrHandle,
    PWCHAR VolGuid,
    USHORT VolGuidSize
    )
/*++

Routine Description:

    Delete the specified VolGuid from mount manager's internal
    table of mount points.

Inputs:

    MountMgrHandle - Handle to the mount manager.  The caller is responsible for
                     opening and closing this handle.

    VolGuid - volume GUID to be deleted.  Not NULL terminated.

              \??\Volume{-GUID-}  - note prefix "\??\" and no trailing backslash.

    VolGuidSize - size (in bytes) of volume GUID.

Return value:

    A Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;

    PMOUNTMGR_MOUNT_POINT   input  = NULL;
    PMOUNTMGR_MOUNT_POINTS  output = NULL;

    DWORD bytesReturned;

    DWORD inputLen;
    DWORD outputLen;

    //
    // Allocate extra space so the VolGuid string will be null
    // terminated in the input structure.  This will allow us
    // to display the VolGuid in the cluster log.  We don't have
    // to explictly null terminate the string because the input
    // buffer is zeroed at allocation time.
    //

    inputLen = INPUT_BUFFER_LEN + VolGuidSize + sizeof(WCHAR);
    input = LocalAlloc( LPTR, inputLen );

    if ( !input ) {
        dwError = GetLastError();
        goto FnExit;
    }

    outputLen = sizeof(MOUNTMGR_MOUNT_POINTS) + 3*MAX_PATH*sizeof(WCHAR);
    output = LocalAlloc( LPTR, outputLen );

    input->UniqueIdOffset = 0;
    input->UniqueIdLength = 0;
    input->DeviceNameOffset = 0;
    input->DeviceNameLength = 0;
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    input->SymbolicLinkNameLength = VolGuidSize;

    CopyMemory((PCHAR)input + input->SymbolicLinkNameOffset, VolGuid, VolGuidSize );

    if ( !DeviceIoControl( MountMgrHandle,
                           IOCTL_MOUNTMGR_DELETE_POINTS,
                           input,
                           inputLen,
                           output,
                           outputLen,
                           &bytesReturned,
                           NULL ) ) {

        dwError = GetLastError();

        (DiskpLogEvent)(
              RESOURCE_TYPE,
              LOG_WARNING,
              L"RemoveVolGuid: deleting VolGuid %1!ws! returns error %2!u! \n",
              (PWCHAR)((PCHAR)input + input->SymbolicLinkNameOffset),
              dwError );

    } else {

        (DiskpLogEvent)(
              RESOURCE_TYPE,
              LOG_INFORMATION,
              L"RemoveVolGuid: deleted VolGuid %1!ws! \n",
              (PWCHAR)((PCHAR)input + input->SymbolicLinkNameOffset) );

    }

FnExit:

    LocalFree( input );
    LocalFree( output );

    return dwError;

}   // RemoveVolGuid


DWORD
DeleteVolGuidList(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Delete the list from the DISK_RESOURCE structure, if it exists (free the
    memmory).  Also deletes the information from the cluster database.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    NO_ERROR - The list was deleted.

    ERROR_NOT_READY - The mount point information was not yet initialized.

    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;

    //
    // Mount point structures not initialized (i.e. critical section).  Don't continue.
    //

    if ( !ResourceEntry->MPInfo.Initialized ) {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DeleteVolGuidList: Mount point info not initialized.  List not deleted. \n" );

        dwError = ERROR_NOT_READY;
        goto FnExit;
    }

    EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

    //
    // If existing list, free it.
    //

    if ( ResourceEntry->DiskInfo.Params.MPVolGuids ) {
        LocalFree( ResourceEntry->DiskInfo.Params.MPVolGuids );
        ResourceEntry->DiskInfo.Params.MPVolGuidsSize = 0;
        ResourceEntry->DiskInfo.Params.MPVolGuids = NULL;

        dwError = ClusterRegDeleteValue( ResourceEntry->ResourceParametersKey,
                                         CLUSREG_NAME_PHYSDISK_MPVOLGUIDS );

        //
        // If the update failed and the disk is not yet online, it will fail with
        // ERROR_SHARING_PAUSED.  Just return the error.  If the caller really,
        // really, really wants the cluster database cleaned up, they can
        // use the PostMPInfoIntoRegistry call to create a thread to do this
        // work.

        if ( NO_ERROR != dwError ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"DeleteVolGuidList: Unable to delete VolGuid from cluster database %1!u! \n",
                  dwError );
        }
    }

    LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

FnExit:

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DeleteVolGuidList: returns %1!u! \n",
          dwError );
#endif

    return dwError;

}   // DeleteVolGuidList


BOOL
IsMountPointAllowed(
    PWSTR MpName,
    PWSTR SourceVol,
    PWSTR TargetVol,
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Verify that the mount point is allowed.  There are several reasons why the mount
    point would not be allowed.

    At this point, the source volume will be accessible.  If the source were offline,
    we wouldn't even know about it, and we wouldn't even get to this routine.  The
    fact that the source is accessible allows us to do some things differently (i.e. we
    can talk to the disk if needed).


    Dependencies:

        If source disk S has a mount point to target disk T ( S:\tdir --> T: ), then
        target T is dependent on source S and source S must be brought online before
        target T is online.

    Quorum drive restrictions:

        Generally, the quorum drive can have a mount point to target disk T as long as
        target disk T is in same group as the quorum disk.

        A mount point from clustered source S to quorum target Q is not allowed because
        the quorum drive Q cannot be dependent on another resource.

        A mount point from quorum source Q to a nonclustered target C is invalid.

    Mount points to non-clustered disks:

        These types of mountpoints should not be used.

    Configurations supported:

        C is a non-clustered disk.
        X, Y are clustered disks, not quorum disks.
        Q is quorum disk.

        Source      Target                      Status
        ------      ------      ------------------------------------------------------------
          C    -->    Q           Not supported.  Log error to system event log.
          C    -->    X           Not supported.  Log error to system event log.
          X    -->    C           Not supported.  We never process non-clustered target C.
          X    -->    Q           Invalid.  Quorum drive cannot be dependent on another resource.
          X    -->    Y           Valid if drive Y is dependent on drive X (X online first).
          Q    -->    X           Valid if drive X is dependent on drive Q (Q online first).
          Q    -->    C           Not supported.  We never process target C.

Arguments:

    MpName - Possible mount point.  This will either be a mount point or a drive letter
             (which is actually a mount point).  Format can be:

             x:\                                [Note trailing backslash!]
             x:\some-mp-name\                   [Note trailing backslash!]
             x:\some-dir\some-mp-name\          [Note trailing backslash!]
             \\?\Volume{GUID}\some-mp-name\     [Note trailing backslash!]

    SourceVol - Mount point target volume name.  Optional.
                Format:
                    \\?\Volume{GUID}\       [Note trailing backslash!]

    TargetVol - Mount point target volume name.  Must always be specified.
                Format:
                    \\?\Volume{GUID}\       [Note trailing backslash!]

    ResourceEntry - Pointer to the DISK_RESOURCE structure for either the
                    source or target volume.  If SourceVol is specified,
                    will be source structure.  If SourceVol is not specified,
                    will be target structure.

Return Value:

    TRUE if the mount point is allowed.

--*/
{
    PWSTR srcGroup          = NULL;
    PWSTR targetGroup       = NULL;

    DWORD srcSignature      = 0;
    DWORD targetSignature   = 0;
    DWORD quorumSignature;

    DWORD dwError = NO_ERROR;
    DWORD messageId = 0;
    DWORD srcGroupChars;
    DWORD targetGroupChars;

    BOOL mpAllowed = TRUE;
    BOOL sigIsClustered;
    BOOL dependencyCorrect;
    BOOL sameGroup;

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"IsMountPointAllowed: MP Name (%1!ws!) \n",
          MpName  );
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"IsMountPointAllowed: SourceVolume (%1!ws!) \n",
          SourceVol  );
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"IsMountPointAllowed: TargetVolume (%1!ws!) \n",
          TargetVol  );
#endif

    //
    // Since the drive letter is also a mountpoint, a drive letter is valid.
    //

    if ( MPIsDriveLetter( MpName ) ) {
#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"IsMountPointAllowed: Valid MP: MP is a drive letter \n" );
#endif
        mpAllowed = TRUE;
        goto FnExit;
    }

    if ( SourceVol ) {

        srcSignature = ResourceEntry->DiskInfo.Params.Signature;

        //
        // Get the signature of the target drive.
        // If this fails, we can't use the mountpoint.
        //

        dwError = GetSignatureForVolume( ResourceEntry, TargetVol, &targetSignature );

    } else {

        targetSignature = ResourceEntry->DiskInfo.Params.Signature;

        //
        // Get the signature of the source drive.  This drive is accessible (or
        // we wouldn't even have the mount point info yet) but we cannot assume it
        // is a clustered drive.  If this fails, we can't use the mountpoint.
        //

        dwError = GetSignatureForVolume( ResourceEntry, MpName, &srcSignature );
    }


    if ( NO_ERROR != dwError || !srcSignature || !targetSignature ) {
        //
        // If we are checking source mount points and target is not online (i.e. the
        // dependency might be correct), we don't log an error if we can't get the
        // signature.  In this case, when we bring the target online, we'll check
        // the dependencies at that time.
        //

        if ( SourceVol ) {
            mpAllowed = TRUE;
        } else {
            mpAllowed = FALSE;
            messageId = RES_DISK_INVALID_MP_SIG_UNAVAILABLE;
        }

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              (mpAllowed ? LOG_INFORMATION : LOG_WARNING),
              L"IsMountPointAllowed: Unable to get signature from volume, error %1!u! \n",
              dwError );

        goto FnExit;
    }

    //
    // If source points back to target, this mount point is not allowed.  Even though
    // the mount point code seems to allow this, there are some strange circular
    // dependencies that show up.
    //

    if ( srcSignature == targetSignature ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Invalid MP: Source and target volumes are the same device \n" );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_SOURCE_EQUAL_TARGET;
        goto FnExit;
    }

    //
    // Get quorum signature.  If this fails, assume the mount point is not allowed.
    //

    dwError = GetQuorumSignature( &quorumSignature );

    if ( NO_ERROR != dwError ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Unable to get quorum signature, error %1!u! \n",
              dwError );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_QUORUM_SIG_UNAVAILABLE;
        goto FnExit;
    }

    //
    // If we can't enumerate the cluster disk signatures, assume that this mount
    // point is not allowed.  If SourceVol was specified, then we need to check if
    // the target is clustered.  If SourceVol was not specified, then we are
    // processing the clustered target and need to insure the source is clustered.
    //

    if ( SourceVol ) {
        dwError = CheckSignatureClustered( ResourceEntry,
                                           targetSignature,
                                           &sigIsClustered,
                                           &targetGroup );

    } else{
        dwError = CheckSignatureClustered( ResourceEntry,
                                           srcSignature,
                                           &sigIsClustered,
                                           &srcGroup );
    }

    if ( NO_ERROR != dwError ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Unable to enumerate disk signatures, error %1!u! \n",
              dwError );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_SIG_ENUMERATION_FAILED;
        goto FnExit;
    }

    //
    // Insure that neither the source or target of the mount point is non-clustered.
    // This check eliminates these configurations:
    //      C --> X
    //      C --> Q
    //      X --> C
    //      Q --> C
    //

    if ( !sigIsClustered ) {

        if ( SourceVol ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"IsMountPointAllowed: Invalid MP: Target volume is non-clustered \n" );
            messageId = RES_DISK_INVALID_MP_TARGET_NOT_CLUSTERED;

        } else {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"IsMountPointAllowed: Invalid MP: Source volume is non-clustered \n" );
            messageId = RES_DISK_INVALID_MP_SOURCE_NOT_CLUSTERED;
        }
        mpAllowed = FALSE;
        goto FnExit;
     }

    //
    // Have to check whether we retrieved the group names after checking
    // whether signatures are clustered.
    //

    if ( (!targetGroup && !srcGroup) ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Unable to enumerate disk signatures, error %1!u! \n",
              dwError );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_SIG_ENUMERATION_FAILED;
        goto FnExit;
    }

    //
    // If the target is the quorum drive, the mount point is not allowed because
    // the quorum cannot be dependent on another disk resource.  We already know
    // that the source and target are different devices from an ealier check.
    //

    if ( quorumSignature == targetSignature ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Invalid MP: target sig %1!x! is quorum disk, source sig %2!x! is clustered \n",
              targetSignature,
              srcSignature );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_TARGET_IS_QUORUM;
        goto FnExit;
    }

    //
    // Check that the source and target are in the same group.  If not, then we don't
    // need to check the dependencies.  If source/target is quorum, we can't go through
    // the dependency check code because a deadlock can occur during quorum online.
    //
    // Similar to what we did previously, but note that if SourceVol was passed in,
    // we specify srcSignature to CheckSignatureClustered.  This will return the group
    // name for the source volume.  We do similar call for target volume.
    //

    if ( SourceVol ) {
        dwError = CheckSignatureClustered( ResourceEntry,
                                           srcSignature,
                                           &sigIsClustered,
                                           &srcGroup );

    } else{
        dwError = CheckSignatureClustered( ResourceEntry,
                                           targetSignature,
                                           &sigIsClustered,
                                           &targetGroup );
    }

    if ( NO_ERROR != dwError || !targetGroup || !srcGroup ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Unable to enumerate disk signatures, error %1!u! \n",
              dwError );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_SIG_ENUMERATION_FAILED;
        goto FnExit;
    }

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"IsMountPointAllowed: Source group: %1!ws! \n",
          srcGroup );
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"IsMountPointAllowed: Target group: %1!ws! \n",
          targetGroup );
#endif

    //
    // If source and target in different groups, we are done.
    //

    srcGroupChars = wcslen( srcGroup );
    targetGroupChars = wcslen( targetGroup );

    if ( srcGroupChars == targetGroupChars &&
         0 == wcsncmp( srcGroup, targetGroup, srcGroupChars ) ) {

        sameGroup = TRUE;
    } else {
        sameGroup = FALSE;
    }

    //
    // If source and target are not in the same group, just display
    // the invalid dependency message and exit.
    //

    if ( !sameGroup ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Invalid MP: Source and target are in different groups \n",
              dwError );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_INVALID_DEPENDENCIES;
        goto FnExit;
    }

    //
    // If source and target are in the same group and source is quorum disk,
    // then the mount point is allowed since the quorum disk always comes
    // online first.  So even though dependencies might not be correct for
    // quorum source pointed to clustered target (Q --> X) case, we won't
    // display an error message.
    //

    if ( quorumSignature == srcSignature && sameGroup ) {
#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"IsMountPointAllowed: Valid MP: source sig %1!x! is quorum, target sig %2!x! is clustered \n",
              srcSignature,
              targetSignature );
#endif
        mpAllowed = TRUE;
        goto FnExit;
    }

    //
    // We have one possibility left:
    //      X --> Y
    //
    // This is valid only if the dependencies are set up correctly.
    //

    dependencyCorrect = FALSE;
    dwError = CheckDependencies( ResourceEntry,
                                 srcSignature,
                                 targetSignature,
                                 &dependencyCorrect );

    if ( NO_ERROR != dwError ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"IsMountPointAllowed: Unable to enumerate disk dependencies, error %1!u! \n",
              dwError );
        mpAllowed = FALSE;
        messageId = RES_DISK_INVALID_MP_ENUM_DISK_DEP_FAILED;
        goto FnExit;
    }

    if ( dependencyCorrect ) {
#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"IsMountPointAllowed: Valid MP: Dependencies are correct \n" );
#endif
        mpAllowed = TRUE;
        goto FnExit;
    }

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_WARNING,
          L"IsMountPointAllowed: Invalid MP: Dependencies are incorrect \n",
          MpName  );

    //
    // If we get here, the mount point is not allowed.
    //

    mpAllowed = FALSE;
    messageId = RES_DISK_INVALID_MP_INVALID_DEPENDENCIES;

FnExit:

    if ( !mpAllowed && messageId ) {

        // Log event...

        ClusResLogSystemEventByKey2(ResourceEntry->ResourceKey,
                                    LOG_UNUSUAL,
                                    messageId,
                                    MpName,
                                    TargetVol);
    }

    if ( srcGroup ) {
        LocalFree( srcGroup );
    }

    if ( targetGroup ) {
        LocalFree( targetGroup );
    }

    return mpAllowed;


}   // IsMountPointAllowed


DWORD
CheckDependencies(
    PDISK_RESOURCE ResourceEntry,
    DWORD SrcSignature,
    DWORD TargetSignature,
    PBOOL DependencyCorrect
    )
/*++

Routine Description:

    Determine if the dependency between the source volume and target volume is set up
    correctly.  Since we are using the cluster APIs, they should insure that the
    resources are in the same group and have dependencies set.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    SrcSignature - Disk signature of the source volume.

    TargetSignature - Disk signature of the targe volume.

    DependencyCorrect - Indicates whether the dependency is set up correctly between the
                        source and target.  If set up correctly, this will be returned
                        as TRUE.

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;

    DEPENDENCY_INFO dependInfo;

    ZeroMemory( &dependInfo, sizeof(DEPENDENCY_INFO) );

    //
    // We need to find the source's resources first.
    //

    dependInfo.ResourceEntry = ResourceEntry;
    dependInfo.SrcSignature = SrcSignature;
    dependInfo.TargetSignature = TargetSignature;
    dependInfo.DependencyCorrect = FALSE;

    //
    // Worst case assume that the dependency is invalid.
    //

    *DependencyCorrect = FALSE;

    dwError = ResUtilEnumResources( NULL,
                                    PHYSICAL_DISK_WSTR,
                                    DependencyCallback,
                                    &dependInfo
                                    );

    //
    // STOP_CLUSTER_ENUMERATIONS is our way to indicate that the
    // enumerations stopped (possibly early).  Check for this return
    // value and also if the DependencyCorrect flag was set to indicate
    // status to the caller.
    //

    if ( STOP_CLUSTER_ENUMERATIONS == dwError ) {
        dwError = NO_ERROR;

        if ( dependInfo.DependencyCorrect ) {
            *DependencyCorrect = TRUE;
        }
    }


    return dwError;

}   // CheckDependencies


DWORD
DependencyCallback(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    )
/*++

Routine Description:

    For each enumerated disk resource, get the signature and see if it matches the
    mount point target signature (passed in the DEPENDENCY_INFO structure).  If it
    does not match, return success so that the disk enumeration continues.

    If the enumerated resource signature matches the mount point target signature,
    then check the cluster dependencies and make sure they are correct.  Once we
    have had a match on the signatures, we need to return an error to stop the
    disk enumeration, so we use STOP_CLUSTER_ENUMERATIONS as that special error
    value.

    If the cluster dependencies are acceptable, the DependencyCorrect flag will be
    set to TRUE in the DEPENDENCY_INFO structure.

Arguments:

    hOriginal - Handle to the original resource.  Not used.

    hResource - Handle to a cluster resource of type PHYSICAL_DISK.

    lpParams - Pointer to DEPENDENCY_INFO structure.

Return Value:

    STOP_CLUSTER_ENUMERATIONS - Special flag to stop the enumeration process.

    Win32 error code.

--*/
{
    PDEPENDENCY_INFO dependInfo = lpParams;

    DWORD dwSignature;
    DWORD dwError = NO_ERROR;

    //
    // Get the disk info and parse the signature from it.
    //

    dwError = GetSignatureFromRegistry( dependInfo->ResourceEntry,
                                        hResource,
                                        &dwSignature );


    if ( NO_ERROR != dwError ) {
        return dwError;
    }

    //
    // This code checks that the mount point SOURCE is online before
    // the mount point TARGET.
    //
    // Check if we have a resource handle to the target disk or to
    // a different disk.  If the resource is the target disk,
    // enumerate the dependencies and make sure they are correct.
    //

    if ( dwSignature == dependInfo->TargetSignature ) {

        dwError = EnumSigDependencies( dependInfo->ResourceEntry,
                                       hResource,
                                       dependInfo->SrcSignature,
                                       &dependInfo->DependencyCorrect );

        //
        // If the dependency check did not get an error, set a fake
        // error to make the disk enumeration stop.
        //

        if ( NO_ERROR == dwError ) {
            dwError = STOP_CLUSTER_ENUMERATIONS;
        }
    }

    return dwError;

} // DependencyCallback


DWORD
EnumSigDependencies(
    PDISK_RESOURCE ResourceEntry,
    RESOURCE_HANDLE DependentResource,
    DWORD DependsOnSignature,
    PBOOL DependencyCorrect
    )
/*++

Routine Description:

    Check that the cluster disk dependencies are correct between the source and
    target of the mount point.

    To do this, we open the dependent resource and use the cluster APIs to enumerate
    all the disk resources dependencies.  For each dependency found, check for a
    match of the DependsOnSignature.  If the signatures match, the dependency is
    correct and we are done.  Otherwise, keep checking all the dependencies until
    we exhaust the list or find a match.

    Note: Dependency is brought online before the DependentResource.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    DependentResource - Resource Handle to check all the dependencies.

    DependsOnSignature - Signature of a possibly dependent disk.  This disk must be
                         brought online before the DependentResource.

    DependencyCorrect - Flag set to TRUE when the cluster dependencies between
                       the DependentResource and it's dependency (identified by the
                       DependsOnSignature) are correct.

Return Value:

    Win32 error code.

--*/
{
    HRESENUM resEnum = NULL;
    HCLUSTER hCluster = NULL;
    HRESOURCE dependsOnResource = NULL;

    DWORD idx;
    DWORD dwError = NO_ERROR;
    DWORD enumType;
    DWORD nameLen;
    DWORD signature;

    WCHAR enumNameW[MAX_PATH * 2];

    __try {

        hCluster = OpenCluster( NULL );

        if ( NULL == hCluster ) {
            dwError = GetLastError();
            __leave;
        }

        //
        // Open an enumerator for iterating through the resources.
        //

        resEnum = ClusterResourceOpenEnum( DependentResource,
                                           CLUSTER_RESOURCE_ENUM_DEPENDS );

        if ( !resEnum ) {
            dwError = GetLastError();
            __leave;
        }

        //
        // Iterate through the dependencies.
        //

        idx = 0;
        while ( TRUE ) {

            nameLen = MAX_PATH;
            ZeroMemory( enumNameW, sizeof(enumNameW) );

            dwError = ClusterResourceEnum( resEnum,
                                           idx,
                                           &enumType,
                                           enumNameW,
                                           &nameLen );

            if ( ERROR_NO_MORE_ITEMS == dwError ) {

                //
                // The list is exhausted.  Indicate no error and leave.  This
                // just means we checked all the dependencies and we didn't find
                // a match.
                //

                dwError = NO_ERROR;
                __leave;
            }

            if ( ERROR_SUCCESS != dwError ) {

                //
                // Some type of error, we have to stop processing.
                //
                __leave;
            }

            //
            // Now we have the name (in the form of a string) of a resource we are
            // dependent on.  We need to get the signature and compare to the
            // signature passed in.
            //

            dependsOnResource = OpenClusterResource( hCluster,
                                                     enumNameW );

            if ( NULL == dependsOnResource ) {
                dwError = GetLastError();
                __leave;

            }

            //
            // Get the disk signature from the resources disk info.
            //

            dwError = GetSignatureFromRegistry( ResourceEntry,
                                                dependsOnResource,
                                                &signature );

            //
            // If the signature passed in matches the signature we are dependent on,
            // then the dependency is correct.  Otherwise, we have to keep looking.
            //

            if ( NO_ERROR == dwError && signature == DependsOnSignature ) {
                *DependencyCorrect = TRUE;
                dwError = NO_ERROR;
                __leave;
            }

            //
            // Look at the next enumeration resource.
            //

            CloseClusterResource( dependsOnResource );
            dependsOnResource = NULL;
            idx++;
        }

    } __finally {

        if ( dependsOnResource ) {
            CloseClusterResource( dependsOnResource );
        }

        if ( resEnum ) {
            ClusterResourceCloseEnum( resEnum );
        }

        if ( hCluster ) {
            CloseCluster( hCluster );
        }
    }

    return dwError;


}   // EnumSigDependencies


DWORD
CheckSignatureClustered(
    PDISK_RESOURCE ResourceEntry,
    DWORD Signature,
    PBOOL IsClustered,
    PWSTR *GroupName
    )
/*++

Routine Description:

    Determine if the specified disk signature belongs to a clustered disk.
    Enumerates the cluster physical disks and tries to find a signature
    match.

    The enumeration returns STOP_CLUSTER_ENUMERATIONS when it has found
    a matching signature.  This special error code is to stop the disk
    enumeration.

    If the disk is clustered, the disk name will be returned in the
    GroupName parameter.  The caller is responsible for freeing this
    storage.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    Signature - Disk signature to be checked.

    IsClustered - Flag indicating disk is clustered.  If TRUE, disk is a
                  clustered disk.

    GroupName - If signature represents a clustered disk, this parameter
                will point to the group name (NULL terminated Unicode string).
                The caller is responsible for freeing this buffer.

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;

    SIG_INFO sigInfo;

    ZeroMemory( &sigInfo, sizeof(SIG_INFO) );

    sigInfo.ResourceEntry = ResourceEntry;
    sigInfo.Signature = Signature;
    sigInfo.Clustered = FALSE;
    sigInfo.GroupName = NULL;

    *IsClustered = FALSE;
    *GroupName = NULL;

    dwError = ResUtilEnumResources( NULL,
                                    PHYSICAL_DISK_WSTR,
                                    SigInfoCallback,
                                    &sigInfo
                                    );

    if ( STOP_CLUSTER_ENUMERATIONS == dwError && sigInfo.Clustered ) {
        dwError = NO_ERROR;
        *IsClustered = TRUE;
        *GroupName = sigInfo.GroupName;
    }

    return dwError;

}   // CheckSignatureClustered


DWORD
SigInfoCallback(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    )
/*++

Routine Description:

    For each enumerated disk resource, get the signature and see if it matches the
    specified disk signature (passed in the SIG_INFO structure).  If it does not
    match, return success so that the disk enumeration continues.

    If the enumerated resource signature matches the mount point source signature,
    sets the Clustered flag in the SIG_INFO structure to TRUE.

    Return the resource group name information.

Arguments:

    hOriginal - Handle to the original resource.  Not used.

    hResource - Handle to a cluster resource of type PHYSICAL_DISK.

    lpParams - Pointer to SIGN_INFO structure.

Return Value:

    STOP_CLUSTER_ENUMERATIONS - Special flag to stop the enumeration process.

    Win32 error code.

--*/
{
    PSIG_INFO sigInfo = lpParams;
    PWSTR groupName;

    DWORD dwSignature;
    DWORD dwError = NO_ERROR;
    DWORD groupNameChars;

    CLUSTER_RESOURCE_STATE resState;


    //
    // Get the disk info and parse the signature from it.
    //

    dwError = GetSignatureFromRegistry( sigInfo->ResourceEntry,
                                        hResource,
                                        &dwSignature );


    if ( NO_ERROR != dwError ) {
        return dwError;
    }

    if ( dwSignature == sigInfo->Signature ) {
        sigInfo->Clustered = TRUE;

        groupNameChars = MAX_GROUP_NAME_LENGTH;
        groupName = LocalAlloc( LPTR, groupNameChars * sizeof(WCHAR) );

        if ( groupName ) {

            //
            // Get the group name for this resource.
            //

            resState = GetClusterResourceState( hResource,
                                                NULL,
                                                0,
                                                groupName,
                                                &groupNameChars );

            //
            // If we can't get the group name, we don't need to report
            // an error.  For error case, just free the group name
            // buffer.
            //

            if ( ClusterResourceStateUnknown == resState ) {
                LocalFree( groupName );
                sigInfo->GroupName = NULL;
            } else {
                sigInfo->GroupName = groupName;
            }

        }

        //
        // Return an error to stop the enumeration.
        //

        dwError = STOP_CLUSTER_ENUMERATIONS;

    }

    return dwError;

} // SigInfoCallback


DWORD
GetSignatureFromRegistry(
    PDISK_RESOURCE ResourceEntry,
    RESOURCE_HANDLE hResource,
    DWORD *dwSignature
    )
/*++

Routine Description:

    Get the signature for the given volume from the cluster from the registry.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    hResource - Handle to a cluster resource of type PHYSICAL_DISK.

    Signature - On success, the signature is returned into this pointer.

Return Value:

    Win32 error code.

--*/
{

    DWORD dwError   = NO_ERROR;
    DWORD signature = 0;

    HKEY hKey       = NULL;
    HKEY hParamKey  = NULL;

    *dwSignature = 0;

    hKey = GetClusterResourceKey( hResource, KEY_READ );

    if ( !hKey ) {
        dwError = GetLastError();
        goto FnExit;
    }

    dwError = ClusterRegOpenKey( hKey,
                                 CLUSREG_KEYNAME_PARAMETERS,
                                 KEY_READ,
                                 &hParamKey );

    if ( NO_ERROR != dwError ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"GetSignatureFromRegistry: DiskRes %1!p!  ClusterRegOpenKey failed %2!u! \n",
              ResourceEntry,
              dwError  );
        goto FnExit;
    }

    dwError = ResUtilGetDwordValue( hParamKey,
                                    CLUSREG_NAME_PHYSDISK_SIGNATURE,
                                    &signature,
                                    0 );

    if ( NO_ERROR != dwError ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"GetSignatureFromRegistry: DiskRes %1!p!  ResUtilGetDwordValue failed %2!u! \n",
              ResourceEntry,
              dwError  );
        goto FnExit;
    }

    *dwSignature = signature;

FnExit:

    if ( hParamKey ) {
        ClusterRegCloseKey( hParamKey );
    }

    if ( hKey ) {
        ClusterRegCloseKey( hKey );
    }

    return dwError;

}   // GetSignatureFromRegistry



DWORD
GetSignatureForVolume(
    PDISK_RESOURCE ResourceEntry,
    PWSTR MpName,
    PDWORD Signature
    )
/*++

Routine Description:

    Get the signature for the given volume.  The signature is found by issuing
    IOCTL_DISK_GET_DRIVE_LAYOUT_EX or IOCTL_DISK_GET_DRIVE_LAYOUT.

    The volume must be online for this to work and not reserved by another node.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    MpName - Possible mount point.  This will either be a mount point or a drive letter
             (which is actually a mount point).  Can also be a simple VolGUID.
             Format can be:

             x:\                                [Note trailing backslash!]
             x:\some-mp-name\                   [Note trailing backslash!]
             x:\some-dir\some-mp-name\          [Note trailing backslash!]
             \\?\Volume{GUID}\some-mp-name\     [Note trailing backslash!]
             \\?\Volume{GUID}\                  [Note trailing backslash!]

    Signature - On success, the signature is returned into this pointer.

Return Value:

    Win32 error code.

--*/
{
    PDRIVE_LAYOUT_INFORMATION_EX layoutEx = NULL;
    PDRIVE_LAYOUT_INFORMATION layout = NULL;

    PWCHAR deviceName = NULL;

    HANDLE handle = NULL;
    DWORD bytesReturned;
    DWORD dwError = NO_ERROR;
    DWORD deviceNameChars = 0;

    if ( !MpName || !Signature ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    *Signature = 0;

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"GetSignatureForVolume: Checking mount point (%1!ws!) \n",
          MpName );

#endif

    //
    // Make copy of mount point for passing to CreateFile.
    //

    deviceNameChars = MAX_PATH;
    deviceName = LocalAlloc( LPTR, deviceNameChars * sizeof(WCHAR) );

    if ( !deviceName ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Create device name according to the mount point type.
    //

    if ( MOUNTDEV_LOOKS_LIKE_VOLUME_GUID( MpName, wcslen( MpName ) ) ) {

        //
        // Need to change the \??\Volume{ to \\?\Volume{ and truncate everything
        // after the VolGUID.  No trailing backslash.
        //

        wcsncpy( deviceName, MpName, VOL_GUID_STRING_LEN );
        (WCHAR)*( deviceName + 1 ) = L'\\';

    } else if ( MOUNTDEV_LOOKS_LIKE_ALT_VOLUME_GUID( MpName, wcslen( MpName ) ) ) {

        //
        // Form is acceptable as-is.  Just truncate everything after the VolGUID.
        // No trailing backslash.
        //

        wcsncpy( deviceName, MpName, VOL_GUID_STRING_LEN );

    } else if ( MOUNTDEV_LOOKS_LIKE_DISK_PATH( MpName, wcslen( MpName ) ) ) {

        //
        // Make the name into the form:  \\?\x:     [Note: no trailing backslash!]
        //

        wcsncpy( deviceName, CREATE_FILE_PREFIX, wcslen( CREATE_FILE_PREFIX ) );
        wcsncat( deviceName, MpName, 2 );

    } else {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"GetSignatureForVolume: Invalid mount point specified (%1!ws!) \n",
              MpName );
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"GetSignatureForVolume: CreateFile using %1!ws! \n",
          deviceName );

#endif

    handle = CreateFileW( deviceName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );

    if ( INVALID_HANDLE_VALUE == handle ) {
        dwError = GetLastError();

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"GetSignatureForVolume: CreateFile for device (%1!ws!) failed, error %2!u! \n",
              deviceName,
              dwError );

        goto FnExit;
    }

    //
    // Try IOCTL_DISK_GET_DRIVE_LAYOUT_EX first.  If it fails, try with
    // IOCTL_DISK_GET_DRIVE_LAYOUT.
    //

    layoutEx = DoIoctlAndAllocate( handle,
                                   IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                   0,
                                   0,
                                   &bytesReturned );

    if ( layoutEx ) {

        //
        // Get the signature from the returned structure and return it to
        // the caller.
        //

        if ( PARTITION_STYLE_MBR == layoutEx->PartitionStyle ) {
            *Signature = layoutEx->Mbr.Signature;

        } else if ( PARTITION_STYLE_GPT == layoutEx->PartitionStyle ) {

            //
            // Since our signatures won't handle the GPT GUID, we have to
            // simulate a signature.
            //

            *Signature = ClusterHashGuid(layoutEx->Gpt.DiskId);
        }

        goto FnExit;
    }

    //
    // Fall through and try the old IOCTL.
    //

    dwError = GetLastError();

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_WARNING,
          L"GetSignatureForVolume: IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed, error %1!u! \n",
          dwError );

    dwError = NO_ERROR;

    layout = DoIoctlAndAllocate( handle,
                                 IOCTL_DISK_GET_DRIVE_LAYOUT,
                                 0,
                                 0,
                                 &bytesReturned );

    if ( !layout ) {

        dwError = GetLastError();
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"GetSignatureForVolume: IOCTL_DISK_GET_DRIVE_LAYOUT failed, error %1!u! \n",
              dwError );

        goto FnExit;
    }

    //
    // Get the signature from the returned structure and return it to
    // the caller.
    //

    *Signature = layout->Signature;

FnExit:

    if ( layoutEx ) {
        free( layoutEx );
    }

    if ( layout ) {
        free( layout );
    }

    if ( deviceName ) {
        LocalFree( deviceName );
    }

    if ( handle ) {
        CloseHandle( handle );
    }

#if DBG
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"GetSignatureForVolume: Returning signature %1!x! for mount point (%2!ws!) \n",
          *Signature,
          MpName );
#endif

    return dwError;

}   // GetSignatureForVolume


BOOL
GetOffsetFromPartNo(
    DWORD PartitionNo,
    PMOUNTIE_INFO Info,
    PLARGE_INTEGER Offset
    )
/*++

Routine Description:

    Given the partition number and the drive layout, return the byte offset for the
    specified partition.

Arguments:

    PartitionNo - Supplies the partition number.  Zero is invalid since partition zero
                  represents the entire disk.

    Info - Pointer to MOUNTIE_INFO based on drive layout information.

    Offset - Pointer to hold the returned byte offset for the partition.  Space is
             allocated by the caller.

Return Value:

    TRUE if successful.

--*/
{
    PMOUNTIE_PARTITION entry;
    DWORD idx;
    DWORD partitionCount;
    BOOL retVal = FALSE;

    if ( !PartitionNo || !Info || !Offset ) {
        goto FnExit;
    }

    if ( 0 == Info->Volume ) {
        goto FnExit;
    }

#if DBG
    (DiskpLogEvent)(
          RESOURCE_TYPE,
          LOG_INFORMATION,
          L"GetOffsetFromPartNo: partition %1!u! \n",
          PartitionNo );
#endif

    Offset->QuadPart = 0;   // Offset of zero is invalid.  This will indicate an error.

    partitionCount = Info->Volume->PartitionCount;
    entry = Info->Volume->Partition;

    for ( idx = 0; idx < partitionCount; ++idx, ++entry) {

#if DBG
        (DiskpLogEvent)(
              RESOURCE_TYPE,
              LOG_INFORMATION,
              L"GetOffsetFromPartNo: index %1!u! offset %2!x! \n",
              idx,
              entry->StartingOffset.LowPart );
#endif

        if ( entry->PartitionNumber == PartitionNo ) {

            Offset->QuadPart = entry->StartingOffset.QuadPart;
            retVal = TRUE;
            break;
        }
    }

FnExit:

    return retVal;

}   // GetOffsetFromPartNo



BOOL
GetPartNoFromOffset(
    PLARGE_INTEGER Offset,
    PMOUNTIE_INFO Info,
    PDWORD PartitionNumber
    )
/*++

Routine Description:

    Given the offset and the drive layout, return the partition number for the specified offset.

Arguments:

    Offset - Pointer to the byte offset.

    Info - Pointer to MOUNTIE_INFO based on drive layout information.

    PartitionNo - Pointer to hold the returned partition number.  Space is allocated by the
                  caller.


Return Value:

    TRUE if successful.

--*/
{
    PMOUNTIE_PARTITION entry;
    DWORD idx;
    DWORD partitionCount;
    BOOL retVal = FALSE;

    if ( !Offset->QuadPart || !Info || !PartitionNumber) {
        goto FnExit;
    }

    if ( 0 == Info->Volume ) {
        goto FnExit;
    }

    *PartitionNumber = 0;   // Partition zero is invalid.  This will indicate an error.

    partitionCount = Info->Volume->PartitionCount;
    entry = Info->Volume->Partition;

    for ( idx = 0; idx < partitionCount; ++idx, ++entry ) {

        if ( entry->StartingOffset.QuadPart == Offset->QuadPart ) {
            *PartitionNumber = entry->PartitionNumber;
            retVal = TRUE;
            break;
        }
    }

FnExit:

    return retVal;

}   // GetPartNoFromOffset


VOID
PrintStrList(
    PDISK_RESOURCE ResourceEntry,
    LPWSTR MultiSzList,
    DWORD ListBytes
    )
/*++

Routine Description:

    Display the list in the cluster log.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    MultiSzList - REG_MULTI_SZ string

    ListBytes - Number of bytes in MultiSzList, not number of WCHARs!

Return Value:

    None.

--*/
{
    PWSTR currentStr;
    PWCHAR data;

    LARGE_INTEGER offset;

    DWORD currentStrLenChars = 0;
    DWORD count;

    if ( !ResourceEntry || !MultiSzList || 0 == ListBytes ) {
        return;
    }

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"     Offset                      String \n" );


    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"================  ====================================== \n" );


    EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

    currentStr = (PWCHAR)MultiSzList;
    currentStrLenChars = wcslen( currentStr );

    while ( currentStrLenChars ) {

        data = NULL;
        offset.QuadPart = 0;

        //
        // Convert the offset from a string to a large integer value.
        //

        count = swscanf( currentStr, L"%I64x ", &offset.QuadPart );

        if ( 0 == count ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"Error: Unable to parse offset from currentStr (%1!ws!) \n",
                  currentStr );

            // Stop processing the list...
            break;
        }

        //
        // Data starts just after the first space.
        //

        data = wcschr( currentStr, SPACE_CHAR );

        if ( !data || wcslen(data) < 3 ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_INFORMATION,
                  L"Error: Unable to get mount point str from currentStr %1!ws! \n",
                  currentStr );

            // Stop processing the list...
            break;
        }

        //
        // Skip past the space character.  Note that the length was previously validated.
        //

        if ( SPACE_CHAR == *data ) {
            data++;
        }

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"%1!08X!%2!08X!  %3!ws! \n",         // couldn't get !I64X! to work...
              offset.HighPart,
              offset.LowPart,
              data );

        currentStr += currentStrLenChars + 1;
        currentStrLenChars = wcslen( currentStr );
    }

    LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"*** End of list *** \n" );

}   // PrintStrList


static
DWORD
SetMPListThread(
    LPVOID lpThreadParameter
    )
/*++

Routine Description:

    Mount point list update thread.  Updates the cluster data base.

Arguments:

    lpThreadParameter - stores ResourceEntry.

Return Value:

    None

--*/

{
    DWORD dwError;
    PDISK_RESOURCE ResourceEntry = lpThreadParameter;
    DWORD idx;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: started.\n");

    //
    // Will die in 10 minutes if unsuccessful
    //

    for ( idx = 0; idx < 300; ++idx ) {

        //
        // Wait for either the terminate event or the timeout
        //

        dwError = WaitForSingleObject( DisksTerminateEvent, 2000 );

        if ( WAIT_TIMEOUT == dwError ) {

            EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

#if DBG
            DumpDiskInfoParams( ResourceEntry );
#endif

            //
            // Bug in ResUtilSetPropertyParameterBlock.  It will update the cluster
            // database with updated MULTI_SZ data, but it doesn't clear the values
            // appropriately.  Use ClusterRegDeleteValue to make sure the lists are
            // cleared if they have been deleted.
            //

            if ( !ResourceEntry->DiskInfo.Params.MPVolGuids &&
                 0 == ResourceEntry->DiskInfo.Params.MPVolGuidsSize ) {

                dwError = ClusterRegDeleteValue( ResourceEntry->ResourceParametersKey,
                                                 CLUSREG_NAME_PHYSDISK_MPVOLGUIDS );
            }

            //
            // Timer expired.  Update the cluster database.
            //

            dwError = ResUtilSetPropertyParameterBlock( ResourceEntry->ResourceParametersKey,
                                                        DiskResourcePrivateProperties,
                                                        NULL,
                                                        (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                                        NULL,
                                                        0,
                                                        NULL );

            LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

            if ( ERROR_SUCCESS == dwError ) {

                //
                // We're done.
                //

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"SetMPListThread: mount point info updated in cluster data base \n" );

                break;

            } else if ( ERROR_SHARING_PAUSED != dwError ) {

                //
                // If the drive is not yet online, we should have seen ERROR_SHARING_PAUSED.  If
                // we see any other error, something bad happened.
                //

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"SetMPListThread: Failed to update cluster data base, error = %1!u! \n",
                    dwError );
                break;
            }

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"SetMPListThread: Wait again for event or timeout, count %1!u! \n",
                idx );

        } else {

            //
            // The terminate event is possibly set.
            //

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_WARNING,
                L"SetMPListThread: WaitForSingleObject returned error = %1!u! \n",
                dwError );
            break;
        }
    }

    //
    // Thread ending, clear the flag.
    //

    InterlockedExchange( &ResourceEntry->MPInfo.MPUpdateThreadIsActive, 0 );

    return(ERROR_SUCCESS);

}   // SetMPListThread


DWORD
PostMPInfoIntoRegistry(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Set the DiskResourcePrivateProperties in the cluster database.  If the disk
    is not yet online, create a thread to update the cluster database.  The disk
    might not be fully online if we are in the process of bringing the quorum disk
    online and trying to update the mount point information.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    Win32 error code.

--*/
{
    DWORD dwError;

    //
    // Update the cluster database.
    //

    EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

#if DBG
    DumpDiskInfoParams( ResourceEntry );
#endif

    //
    // Bug in ResUtilSetPropertyParameterBlock.  It will update the cluster
    // database with updated MULTI_SZ data, but it doesn't clear the values
    // appropriately.  Use ClusterRegDeleteValue to make sure the lists are
    // cleared if they have been deleted.
    //

    if ( !ResourceEntry->DiskInfo.Params.MPVolGuids &&
         0 == ResourceEntry->DiskInfo.Params.MPVolGuidsSize ) {

        dwError = ClusterRegDeleteValue( ResourceEntry->ResourceParametersKey,
                                         CLUSREG_NAME_PHYSDISK_MPVOLGUIDS );
    }

    dwError = ResUtilSetPropertyParameterBlock( ResourceEntry->ResourceParametersKey,
                                                DiskResourcePrivateProperties,
                                                NULL,
                                                (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                                NULL,
                                                0,
                                                NULL );

    LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

    //
    // If the update failed and the disk is not yet online, it will fail with
    // ERROR_SHARING_PAUSED.  In this case, create a thread to update the cluster
    // data base.  Any other error or success should simply continue.
    //

    if ( ERROR_SHARING_PAUSED == dwError ) {

        //
        // Check if the thread is already active.  If it is, exit with an error.
        //

        if ( InterlockedCompareExchange(
                &ResourceEntry->MPInfo.MPUpdateThreadIsActive,
                1, 0 ) )  {

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_WARNING,
                L"PostMPInfoIntoRegistry: MountPoint thread is already running \n" );

                dwError = ERROR_ALREADY_EXISTS;

        } else {
            HANDLE thread;
            DWORD threadId;

            thread = CreateThread( NULL,
                                   0,
                                   SetMPListThread,
                                   ResourceEntry,
                                   0,
                                   &threadId );

            if ( NULL == thread ) {

                //
                // Thread creation failed.  Log error, clear thread active flag,
                // and return.
                //

                dwError = GetLastError();

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"PostMPInfoIntoRegistry: CreateThread failed, error %1!u!\n",
                    dwError );

                InterlockedExchange( &ResourceEntry->MPInfo.MPUpdateThreadIsActive, 0 );

            } else {

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"PostMPInfoIntoRegistry: Thread created \n" );

                //
                // Thread created.  Indicate no error.
                //

                CloseHandle( thread );
                dwError = ERROR_SUCCESS;
            }
        }

    } else {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              ( NO_ERROR == dwError ? LOG_INFORMATION : LOG_WARNING ),
              L"PostMPInfoIntoRegistry: ResUtilSetPropertyParameterBlock returned %1!u! \n",
              dwError );
    }

    return dwError;

}   // PostMpInfoIntoRegistry


VOID
DisksMountPointCleanup(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Cleanup everything the mount point code used.
    This routine should be called in DisksClose.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    None.

--*/
{
    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DisksMountPointCleanup: Cleanup mount point information \n" );

    //
    // If existing MPVolGuids list, free it.
    //

    if ( ResourceEntry->DiskInfo.Params.MPVolGuids ) {
        LocalFree( ResourceEntry->DiskInfo.Params.MPVolGuids );
        ResourceEntry->DiskInfo.Params.MPVolGuidsSize = 0;
        ResourceEntry->DiskInfo.Params.MPVolGuids = NULL;
    }

    ResourceEntry->MPInfo.Initialized = FALSE;

    DeleteCriticalSection( &ResourceEntry->MPInfo.MPLock );

}   // DisksMountPointCleanup


VOID
DisksMountPointInitialize(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Prepare the mount point structures in the ResourceEntry for use.
    This routine should be called in DisksOpen.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    None.

--*/
{
    InitializeCriticalSection( &ResourceEntry->MPInfo.MPLock );

    ResourceEntry->MPInfo.Initialized = TRUE;

    InterlockedExchange( &ResourceEntry->MPInfo.MPUpdateThreadIsActive, 0 );
    InterlockedExchange( &ResourceEntry->MPInfo.MPListCreateInProcess, 0 );

}   // DisksMountPointInitialize



DWORD
DisksUpdateMPList(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Validate the mount points.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    Win32 error code.

--*/
{
    DWORD   dwError = NO_ERROR;

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DisksUpdateMPList: Processing PNP mountpoint notification \n" );

    //
    // Check if the MPList is in process of being updated.  If it is, exit with an error.
    //

    if ( InterlockedCompareExchange(
            &ResourceEntry->MPInfo.MPListCreateInProcess,
            1, 0 ) )  {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"DisksUpdateMPList: Update in process, bypassing PNP notification \n" );
        return ERROR_BUSY;
    }

    dwError = ValidateMountPoints( ResourceEntry );

    InterlockedExchange( &ResourceEntry->MPInfo.MPListCreateInProcess, 0 );

    return dwError;

}   // DisksUpdateMPList


DWORD
DisksProcessMPControlCode(
    PDISK_RESOURCE ResourceEntry,
    DWORD ControlCode
    )
/*++

Routine Description:

    Process the disk mount point control code.  Since we are in the thread
    that handed us the control code (DisksResourceControl), we can't do
    much except a separate thread to do the bulk of the mount point
    processing.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    ControlCode - Cluster resource control for mount point processing.

Return Value:

--*/
{
    HANDLE thread;
    DWORD threadId;
    DWORD dwError = NO_ERROR;

    __try {

        //
        // Create a thread to update the mount point list.  We don't need to
        // copy the ResourceEntry as this pointer will be valid when the thread
        // runs.
        //

        thread = CreateThread( NULL,
                               0,
                               DisksUpdateMPList,
                               ResourceEntry,
                               0,
                               &threadId );

        if ( NULL == thread ) {
            dwError = GetLastError();
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"DisksProcessMPControlCode: CreateThread failed %1!u! \n",
                  dwError );
            __leave;
        }

        //
        // Thread created.  Indicate no error.
        //

        CloseHandle( thread );
        dwError = NO_ERROR;

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"DisksProcessMPControlCode: Created thread to process control code \n" );
#endif

    } __finally {

    }

    return dwError;

}   // DisksProcessMPControlCode


DWORD
ValidateMountPoints(
    IN OUT PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    For each partition on this disk, get the mountpoints directed toward this
    partition.  Check each mountpoint to make sure it is allowed.  For those
    mountpoints not allowed, write a message to system event log indicating
    why it is an invalid mountpoint.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    ERROR_INVALID_DATA - Partition info stored in MountieInfo is invalid.

    Win32 error code.

--*/
{
    PMOUNTIE_PARTITION entry;

    DWORD dwError = ERROR_SUCCESS;
    DWORD nPartitions = MountiePartitionCount( &ResourceEntry->MountieInfo );
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;
    DWORD idx;

    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];

    //
    // Check each interesting partition.  Since only "valid" partitions are
    // saved in the MountieInfo structure, we will only look at those (ignoring those
    // partitions that are not NTFS).
    //

    for ( idx = 0; idx < nPartitions; ++idx ) {

        entry = MountiePartition( &ResourceEntry->MountieInfo, idx );

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"ValidateMountPoints: index %1!u!   entry %2!x! \n", idx, entry );
#endif

        if ( !entry ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"ValidateMountPoints: no partition entry for index %1!u! \n", idx );

            //
            // Something bad happened to our data structures.
            //

            dwError = ERROR_INVALID_DATA;

            break;
        }

        //
        // Create the device name of the form:
        //  \\?\GLOBALROOT\Device\HarddiskX\PartitionY\  (uses trailing backslash)
        //

        (VOID) StringCchPrintf( szGlobalDiskPartName,
                                RTL_NUMBER_OF( szGlobalDiskPartName ),
                                GLOBALROOT_HARDDISK_PARTITION_FMT,
                                physicalDrive,
                                entry->PartitionNumber );

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"ValidateMountPoints: Using name (%1!ws!) \n",
              szGlobalDiskPartName );
#endif

        if ( !GetVolumeNameForVolumeMountPointW( szGlobalDiskPartName,
                                                 szVolumeName,
                                                 RTL_NUMBER_OF(szVolumeName) )) {

            dwError = GetLastError();

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"ValidateMountPoints: GetVolumeNameForVolumeMountPoint for (%1!ws!) returned %2!u!\n",
                  szGlobalDiskPartName,
                  dwError );

            break;
        }

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"ValidateMountPoints: Returned volume name (%1!ws!) \n",
              szVolumeName );
#endif

        CheckMPsForVolume( ResourceEntry,
                           szVolumeName );

        CheckMPsOnVolume( ResourceEntry,
                          szVolumeName );

    }

    return dwError;

}   // ValidateMountPoints


DWORD
CheckMPsOnVolume(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR SrcVolName
    )
/*++

Routine Description:

    For each the specified source volume, find all mount points hosted by this
    volume.  Find the target of each mount point, then make sure the depenedencies
    are correct between the source and target volumes.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    SrcVolName - Volume GUID name with trailing backslash.
                 \\?\Volume{GUID}\       [Note trailing backslash!]

Return Value:

    Win32 error code.

--*/
{
    PWSTR mpBuffer      = NULL;
    PWSTR targetVolName = NULL;
    PWSTR mpFullPath    = NULL;

    HANDLE hMP = INVALID_HANDLE_VALUE;

    DWORD dwError               = NO_ERROR;
    DWORD mpBufferChars         = MP_ALLOC_SIZE;
    DWORD targetVolNameChars    = MAX_PATH;
    DWORD mpFullPathChars       = MAX_PATH;
    DWORD srcSignature          = ResourceEntry->DiskInfo.Params.Signature;

    //
    // Buffer to hold mount points hosted on this volume.
    //

    mpBuffer = LocalAlloc( LPTR, mpBufferChars * sizeof(WCHAR) );
    if ( !mpBuffer ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"CheckMPsOnVolume: Unable to allocate MP buffer for (%1!ws!), error %2!u!\n",
              SrcVolName,
              dwError );
        goto FnExit;
    }

    hMP = FindFirstVolumeMountPoint( SrcVolName,
                                     mpBuffer,
                                     mpBufferChars );

    if ( INVALID_HANDLE_VALUE == hMP ) {

        //
        // There might be no mount points on this volume, which is acceptable.
        // Only log other types of errors.
        //

        dwError = GetLastError();

        if ( ERROR_NO_MORE_FILES != dwError ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"CheckMPsOnVolume: FindFirstVolumeMountPoint for (%1!ws!), error %2!u!\n",
                  SrcVolName,
                  dwError );
        }

        goto FnExit;
    }

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"CheckMPsOnVolume: Checking volume (%1!ws!) source signature %2!08X! \n",
          SrcVolName,
          srcSignature );

    //
    // Buffer to hold the mount point target volume.
    //

    targetVolName = LocalAlloc( LPTR, targetVolNameChars * sizeof(WCHAR) );
    if ( !targetVolName ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"CheckMPsOnVolume: Unable to allocate Volume Name buffer for (%1!ws!), error %2!u!\n",
              SrcVolName,
              dwError );
        goto FnExit;
    }

    //
    // Buffer to hold the full mount point name.  This will be the source
    // volume with the mount point appended to it.
    //  \\?\Volume{GUID}\some-mount-point\          [Note trailing backslash!]
    //

    mpFullPath = LocalAlloc( LPTR, mpFullPathChars * sizeof(WCHAR) );
    if ( !mpFullPath ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"CheckMPsOnVolume: Unable to allocate Volume Name buffer for (%1!ws!), error %2!u!\n",
              SrcVolName,
              dwError );
        goto FnExit;
    }

    while ( TRUE ) {

        (VOID) StringCchCopy( mpFullPath, mpFullPathChars, SrcVolName );
        (VOID) StringCchCat( mpFullPath, mpFullPathChars, mpBuffer );

        //
        // Given the source volume and mount point on the source volume,
        // find the target of the mount point.
        //

        if ( !GetVolumeNameForVolumeMountPoint( mpFullPath,
                                                targetVolName,
                                                targetVolNameChars ) ) {
            dwError = GetLastError();
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"CheckMPsOnVolume: GetVolumeNameForVolumeMountPoint failed for (%1!ws!), error %2!u!\n",
                  mpBuffer,
                  dwError );

            //
            // Fall through to get next mount point...
            //

        } else {

            //
            // Check dependencies between source and target volumes.
            //

            IsMountPointAllowed( mpFullPath,
                                 SrcVolName,            // Source VolGUID
                                 targetVolName,         // Target VolGUID
                                 ResourceEntry );

        }

        //
        // Keep looking for mount points on the source volume until there
        // are no more.
        //

        if ( !FindNextVolumeMountPoint( hMP,
                                        mpBuffer,
                                        mpBufferChars ) ) {

            dwError = GetLastError();

            if ( ERROR_NO_MORE_FILES == dwError ) {
                dwError = NO_ERROR;
            } else {

                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_WARNING,
                      L"CheckMPsOnVolume: FindNextVolumeMountPoint failed for (%1!ws!), error %2!u!\n",
                      SrcVolName,
                      dwError );

            }

            break;
        }
    }

FnExit:

    if ( mpBuffer ) {
        LocalFree( mpBuffer );
    }

    if ( targetVolName ) {
        LocalFree( targetVolName );
    }

    if ( mpFullPath ) {
        LocalFree( mpFullPath );
    }

    if ( INVALID_HANDLE_VALUE != hMP ) {
        FindVolumeMountPointClose( hMP );
    }

    return dwError;

}   // CheckMPsOnVolume


VOID
CheckMPsForVolume(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR VolumeName
    )
/*++

Routine Description:

    For the specified volume, find all mount points directed towards this volume.
    For each mountpoint, make sure it is allowed.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    VolumeName - Target volume for the mount point.  Format is:
                 \\?\Volume{GUID}\       [Note trailing backslash!]

Return Value:

    None.

--*/
{
    PWSTR volumePaths = NULL;
    PWSTR currentMP;

    DWORD dwError;

    __try {

        //
        // GetMountPoints will allocate a MultiSz buffer with
        // all the mount points for this target volume.
        //

        dwError = GetMountPoints( VolumeName, &volumePaths );

        if ( NO_ERROR != dwError || !volumePaths ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"CheckMPsForVolume: GetMountPoints returns %1!u! \n", dwError );

            __leave;
        }

        //
        // Loop through each mount point in the list.
        //
        // Each mount point will either be a mount point or a drive letter
        // (which is actually a mount point).  Format can be:
        //
        //         x:\                                [Note trailing backslash!]
        //         x:\some-mp-name\                   [Note trailing backslash!]
        //         x:\some-dir\some-mp-name\          [Note trailing backslash!]
        //

        currentMP = volumePaths;

        for (;;) {

            IsMountPointAllowed( currentMP,
                                 NULL,              // Source VolGUID
                                 VolumeName,        // Target VolGUID
                                 ResourceEntry );

            //
            // Skip through current mount point to end of string.
            //

            while (*currentMP++);

            //
            // If next mount point is empty, the list is exhausted.
            //

            if (!*currentMP) {
                break;
            }
        }

    } __finally {

        if ( volumePaths ) {
            LocalFree( volumePaths );
        }
    }

}   // CheckMPsForVolume


DWORD
GetMountPoints(
    PWSTR   VolumeName,
    PWSTR   *VolumePaths
    )
/*++

Routine Description:

    For the specified volume, find all mount points directed towards this volume.

    The mount point buffer will be allocated by this routine and must be freed by
    the caller.

Arguments:

    VolumeName - Target volume for the mount point.  Format is:
                 \\?\Volume{GUID}\       [Note trailing backslash!]

    VolumePaths - Pointer to a MultiSz string containing all mount points directed
                  toward this volume.  If there are no mount points, this pointer will
                  be set to NULL.  The caller is responsible for freeing this buffer.

Return Value:

    Win32 error code.

--*/
{
    DWORD   lenChars;
    PWSTR   paths = NULL;

    DWORD   dwError;

    if ( !VolumeName || !VolumePaths ) {
        return ERROR_INVALID_PARAMETER;
    }

    *VolumePaths = NULL;

    //
    // Determine the size of the buffer we need.
    //

    if ( !GetVolumePathNamesForVolumeName( VolumeName, NULL, 0, &lenChars ) ) {
        dwError = GetLastError();
        if ( ERROR_MORE_DATA != dwError ) {
            return dwError;
        }
    }

    //
    // Allocate the mount point buffer.
    //

    paths = LocalAlloc( 0, lenChars * sizeof(WCHAR) );
    if ( !paths ) {
        dwError = GetLastError();
        return dwError;
    }

    //
    // Get the mount points.
    //

    if ( !GetVolumePathNamesForVolumeName( VolumeName, paths, lenChars, NULL ) ) {
        dwError = GetLastError();
        LocalFree( paths );
        return dwError;
    }

    //
    // If no mount points, free the buffer and return to the caller.
    //

    if ( !paths[0] ) {
        LocalFree(paths);

        //
        // If no mount points for this volume, return no error and a NULL
        // pointer to the mount point list.
        //

        return NO_ERROR;
    }

    *VolumePaths = paths;

    return NO_ERROR;

}   // GetMountPoints


DWORD
ValidateListOffsets(
    IN OUT PDISK_RESOURCE ResourceEntry,
    IN PWSTR MasterList
    )
/*++

Routine Description:

    Verify each entry in the list to make sure the byte offset
    is valid.  Also, count the number of entries to make sure
    there are not too many entries saved (there should be one
    VolGuid per node times the number of volumes on the disk).

    Finally, make sure each offset is listed only once in the
    list.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

    MasterList - REG_MULTI_SZ list to be checked.

Return Value:

    ERROR_INVALID_DATA - List contains at least one invalid byte offset
                         value, possibly more.

    ERROR_INSUFFICIENT_BUFFER - List possibly corrupt as it contains too
                                many entries.

    Win32 error code.

--*/
{
    PWCHAR          currentStr;
    POFFSET_LIST    offsetList = NULL;

    DWORD currentStrLenChars = 0;
    DWORD dwError = NO_ERROR;
    DWORD partitionNo;
    DWORD numberOfEntries = 0;
    DWORD count;

    LARGE_INTEGER offset;

    BOOL invalidOffset = FALSE;

    EnterCriticalSection( &ResourceEntry->MPInfo.MPLock );

    //
    // Parse through the list.
    //

    for ( currentStr = (PWCHAR)MasterList,
          currentStrLenChars = wcslen( currentStr ) ;
            currentStrLenChars ;
                currentStr += currentStrLenChars + 1,
                currentStrLenChars = wcslen( currentStr ) ) {

        offset.QuadPart = 0;

#if DBG
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"ValidateListOffsets: CurrentStr (%1!ws!), numChars %2!u! \n",
              currentStr,
              currentStrLenChars );
#endif

        //
        // Convert the offset from a string to a large integer value.
        //

        count = swscanf( currentStr, L"%I64x ", &offset.QuadPart );

        if ( 0 == count ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"ValidateListOffsets: Unable to parse offset from currentStr (%1!ws!) \n",
                  currentStr );
            numberOfEntries++;
            continue;
        }

        //
        // Check if offset was already seen.  If seen, exit with error.
        // If not seen, add it.
        //

        dwError = OffsetListAdd( &offsetList, &offset );

        if ( ERROR_INVALID_DATA == dwError ) {
            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"ValidateListOffsets: Offset ( %1!08X!%2!08X! ) in list multiple times \n",
                  offset.HighPart,
                  offset.LowPart );                // couldn't get !I64X! to work...

            invalidOffset = TRUE;

            // As soon as we find a duplicate offset, we are done.

            break;
        }

        //
        // Convert the offset to a partition number.
        //

        if ( !GetPartNoFromOffset( &offset, &ResourceEntry->MountieInfo, &partitionNo ) ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"ValidateListOffsets: Unable to convert offset ( %1!08X!%2!08X! ) to partition number \n",
                  offset.HighPart,
                  offset.LowPart );                // couldn't get !I64X! to work...

            invalidOffset = TRUE;

            // As soon as we find an invalid partition number, we are done.

            break;
        }

        numberOfEntries++;
    }

    if ( invalidOffset ) {
        dwError = ERROR_INVALID_DATA;

    } else if ( numberOfEntries > MAX_ALLOWED_VOLGUID_ENTRIES_PER_DISK ) {

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"ValidateListOffset: VolGuid list too large, %1!u! entries \n",
              numberOfEntries );

        //
        // Return an error so the list is deleted and recreated.
        //

        dwError = ERROR_INVALID_DATA;

#if USEMOUNTPOINTS_KEY
        //
        // See if the user wants to ignore the number of entries in VolGuid list.
        //

        if ( !(ResourceEntry->DiskInfo.Params.UseMountPoints & MPS_IGNORE_MAX_VOLGUIDS) ) {

            //
            // Log an error to system event log.
            //

            ClusResLogSystemEventByKey(ResourceEntry->ResourceKey,
                                        LOG_UNUSUAL,
                                        RES_DISK_MP_VOLGUID_LIST_EXCESSIVE );

            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
#endif

    }

    LeaveCriticalSection( &ResourceEntry->MPInfo.MPLock );

    OffsetListCleanup( offsetList );

    return dwError;

}   // ValidateListOffsets


DWORD
OffsetListAdd(
    POFFSET_LIST *OffsetList,
    PLARGE_INTEGER Offset
    )
/*++

Routine Description:

    Add specified offset to the offset list.

Arguments:

    OffsetList - pointer to offset list.

    Offset - pointer to partition offset value.

Return Value:

    NO_ERROR - Offset was not in list and was successfully added.

    ERROR_INVALID_DATA  - Offset was in the list previously.

    Win32 error code - failed to add offset to the list.

--*/
{
    POFFSET_LIST    next = NULL;
    POFFSET_LIST    entry = *OffsetList;

    DWORD   dwError = NO_ERROR;

    while ( entry ) {

        next = entry->Next;

        if ( Offset->LowPart == entry->Offset.LowPart &&
             Offset->HighPart == entry->Offset.HighPart ) {

            //
            // Offset is already in the list.  Return a
            // unique error value.
            //

            dwError = ERROR_INVALID_DATA;
            goto FnExit;
        }

        entry = next;
    }

    //
    // If we got to this point, either the offset list was
    // empty or we walked the entire list and the offset
    // was not in the list.  Add it now.
    //

    entry = LocalAlloc( LPTR, sizeof(OFFSET_LIST) );

    if ( !entry ) {
        dwError = GetLastError();
        goto FnExit;
    }

    entry->Offset.LowPart = Offset->LowPart;
    entry->Offset.HighPart = Offset->HighPart;

    if ( *OffsetList ) {
        entry->Next = *OffsetList;
    }

    *OffsetList = entry;

FnExit:

    return dwError;

}   // OffsetListAdd


DWORD
OffsetListCleanup(
    POFFSET_LIST OffsetList
    )
/*++

Routine Description:

    Cleanup any storage allocated in the offset list.

Arguments:

    OffsetList - pointer to offset list.

Return Value:

    NO_ERROR

--*/
{
    POFFSET_LIST    next = NULL;
    POFFSET_LIST    entry = OffsetList;

    while ( entry ) {
        next = entry->Next;
        LocalFree( entry );
        entry = next;
    }

    return NO_ERROR;

}   // OffsetListCleanup


BOOL
MPIsDriveLetter(
    IN PWSTR MountPoint
    )
/*++

Routine Description:

    Determine if the mount point string is a drive letter.  A drive letter will be
    represented by a string of the form "x:\" with a length of 3.

Arguments:

    MountPoint - Mount point string to be verified.

Return Value:

    TRUE if the mount point string represents a drive letter.

--*/
{
    DWORD lenChars;

    lenChars = wcslen( MountPoint );

    if ( 3 == lenChars &&
         L':' == MountPoint[1] &&
         L'\\' == MountPoint[2] &&
         iswalpha( MountPoint[0] ) ) {

                return TRUE;
    }

    return FALSE;

}   // MPIsDriveLetter


#if DBG

//
// Debug helper routine
//

VOID
DumpDiskInfoParams(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Display in the cluster log interesting mountpoint information.

Arguments:

    ResourceEntry - Pointer to the DISK_RESOURCE structure.

Return Value:

    None.


--*/
{
#if 0   // Drive is not currently stored
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: Signature %1!x!  Drive (%2!ws!) \n",
        ResourceEntry->DiskInfo.Params.Signature,
        ResourceEntry->DiskInfo.Params.Drive );
#endif

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: Signature %1!x! \n",
        ResourceEntry->DiskInfo.Params.Signature );


#if USEMOUNTPOINTS_KEY
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: SkipChkdsk %1!x!  ConditionalMount %2!x!  UseMountPoints %3!x! \n",
        ResourceEntry->DiskInfo.Params.SkipChkdsk,
        ResourceEntry->DiskInfo.Params.ConditionalMount,
        ResourceEntry->DiskInfo.Params.UseMountPoints );
#else
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: SkipChkdsk %1!x!  ConditionalMount %2!x! \n",
        ResourceEntry->DiskInfo.Params.SkipChkdsk,
        ResourceEntry->DiskInfo.Params.ConditionalMount );
#endif

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetMPListThread: VolGuid list %1!x!     VolGuid size %2!u! \n",
        ResourceEntry->DiskInfo.Params.MPVolGuids,
        ResourceEntry->DiskInfo.Params.MPVolGuidsSize );

}   // DumpDiskInfoParams

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\newmount.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    newmount.c

Abstract:

    Replacement for mountie.c

Author:

    Gor Nishanov (GorN) 31-July-1998

Environment:

    User Mode

Revision History:


--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <devioctl.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <mountdev.h>   // This includes mountmgr.h
#include <winioctl.h>

#include <ntddscsi.h>
#include "clusdisk.h"
#include "disksp.h"
#include "newmount.h"
#include <strsafe.h>    // Should be included last.

#define LOG_CURRENT_MODULE LOG_MODULE_DISK

#define MOUNTIE_VOLUME_INFO   L"MountVolumeInfo"
#define DISKS_DISK_INFO       L"DiskInfo"

#define BOGUS_BUFFER_LENGTH 512

#define FIRST_SHOT_SIZE 512

extern HANDLE DisksTerminateEvent;

DWORD DiskInfoUpdateThreadIsActive = 0;

//
//  LETTER_ASSIGNMENT structure is used to store letter assignment
//  information from various information providers
//

typedef USHORT PARTITION_NUMBER_TYPE;

typedef struct _LETTER_ASSIGNMENT {
  DWORD  MatchCount;
  DWORD  MismatchCount;
  DWORD  DriveLetters;
  PARTITION_NUMBER_TYPE PartNumber[26];
} LETTER_ASSIGNMENT, *PLETTER_ASSIGNMENT;


DWORD
MountMgr_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result);

/*
 * DoIoctlAndAllocate - allocates a result buffer and
 *   tries to perform DeviceIoControl, it it fails due to insufficient buffer,
 *   it tries again with a bigger buffer.
 *
 * FIRST_SHOT_SIZE is a constant that regulates the size of the buffer
 *   for the first attempt to do DeviceIoControl.
 *
 * Return a non-zero code for error.
 */


PVOID
DoIoctlAndAllocate(
    IN HANDLE FileHandle,
    IN DWORD  IoControlCode,
    IN PVOID  InBuf,
    IN ULONG  InBufSize,
    OUT LPDWORD BytesReturned
    )
{
   UCHAR firstShot[ FIRST_SHOT_SIZE ];

   DWORD status = ERROR_SUCCESS;
   BOOL  success;

   DWORD outBufSize;
   PVOID outBuf = 0;
   DWORD bytesReturned;

   success = DeviceIoControl( FileHandle,
                      IoControlCode,
                      InBuf,
                      InBufSize,
                      firstShot,
                      sizeof(firstShot),
                      &bytesReturned,
                      (LPOVERLAPPED) NULL );

   if ( success ) {
      outBufSize = bytesReturned;
      outBuf     = malloc( outBufSize );
      if (!outBuf) {
         status = ERROR_OUTOFMEMORY;
      } else {
         RtlCopyMemory(outBuf, firstShot, outBufSize);
         status = ERROR_SUCCESS;
      }
   } else {
      outBufSize = sizeof(firstShot);
      for(;;) {
         status = GetLastError();
         //
         // If it is not a buffer size related error, then we cannot do much
         //
         if ( status != ERROR_INSUFFICIENT_BUFFER
           && status != ERROR_MORE_DATA
           && status != ERROR_BAD_LENGTH
            ) {
            break;
         }
         //
         // Otherwise, try an outbut buffer twice the previous size
         //
         outBufSize *= 2;
         outBuf = malloc( outBufSize );
         if ( !outBuf ) {
            status = ERROR_OUTOFMEMORY;
            break;
         }

         success = DeviceIoControl( FileHandle,
                                    IoControlCode,
                                    InBuf,
                                    InBufSize,
                                    outBuf,
                                    outBufSize,
                                    &bytesReturned,
                                    (LPOVERLAPPED) NULL );
         if (success) {
            status = ERROR_SUCCESS;
            break;
         }
         free( outBuf );
      }
   }

   if (status != ERROR_SUCCESS) {
      free( outBuf ); // free( 0 ) is legal //
      outBuf = 0;
      bytesReturned = 0;
   }

   SetLastError( status );
   *BytesReturned = bytesReturned;
   return outBuf;
}

/*
 * DevfileOpen - open a device file given a pathname
 *
 * Return a non-zero code for error.
 */
NTSTATUS
DevfileOpen(
    OUT HANDLE *Handle,
    IN wchar_t *pathname
    )
{
    return DevfileOpenEx( Handle,
                          pathname,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA );
}

NTSTATUS
DevfileOpenEx(
    OUT HANDLE *Handle,
    IN wchar_t *pathname,
    IN ACCESS_MASK Access
    )
{
    HANDLE      fh;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;

    RtlInitUnicodeString(&cwspath, pathname);
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               NULL, NULL);
    fh = NULL;
    status = NtOpenFile(&fh,
                        Access,
                        &objattrs, &iostatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (status != STATUS_SUCCESS) {
        return status;
    }

    if ( !NT_SUCCESS(iostatus.Status) ) {
        if (fh) {
            NtClose(fh);
        }
        return iostatus.Status;
    }

    *Handle = fh;
    return STATUS_SUCCESS;

} // DevfileOpen


/*
 * DevfileClose - close a file
 */
VOID
DevfileClose(
    IN HANDLE Handle
    )
{

    NtClose(Handle);

} // DevFileClose

/*
 * DevfileIoctl - issue an ioctl to a device
 */
NTSTATUS
DevfileIoctl(
    IN HANDLE Handle,
    IN DWORD Ioctl,
    IN PVOID InBuf,
    IN ULONG InBufSize,
    IN OUT PVOID OutBuf,
    IN DWORD OutBufSize,
    OUT LPDWORD returnLength
    )
{
    NTSTATUS        status;
    IO_STATUS_BLOCK ioStatus;

    status = NtDeviceIoControlFile(Handle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) NULL,
                                   NULL,
                                   &ioStatus,
                                   Ioctl,
                                   InBuf, InBufSize,
                                   OutBuf, OutBufSize);
    if ( status == STATUS_PENDING ) {
        status = NtWaitForSingleObject( Handle, FALSE, NULL );
    }

    if ( NT_SUCCESS(status) ) {
        status = ioStatus.Status;
    }

    if ( ARGUMENT_PRESENT(returnLength) ) {
        *returnLength = (ULONG)ioStatus.Information;
    }

    return status;

} // DevfileIoctl


#define OUTPUT_BUFFER_LEN (1024)
#define INPUT_BUFFER_LEN  (sizeof(MOUNTMGR_MOUNT_POINT) + 2 * MAX_PATH * sizeof(WCHAR))

DWORD
DisksAssignDosDeviceM(
    HANDLE  MountManager,
    PCHAR   MountName,
    PWCHAR  VolumeDevName
    )

/*++

Routine Description:

Inputs:
    MountManager - Handle to MountMgr
    MountName -
    VolumeDevName -

Return value:

    A Win32 error code.

--*/

{
    WCHAR mount_device[MAX_PATH];
    USHORT mount_point_len;
    USHORT dev_name_len;
    DWORD   status;
    USHORT inputlength;
    PMOUNTMGR_CREATE_POINT_INPUT input;

    if ( FAILED( StringCchPrintf( mount_device,
                                  RTL_NUMBER_OF(mount_device),
                                  TEXT("\\DosDevices\\%S\0"),
                                  MountName ) ) ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    mount_point_len = wcslen(mount_device) * sizeof(WCHAR);
    dev_name_len = wcslen(VolumeDevName) * sizeof(WCHAR);
    inputlength = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
                  mount_point_len + dev_name_len;

    input = (PMOUNTMGR_CREATE_POINT_INPUT)malloc(inputlength);
    if (!input) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    input->SymbolicLinkNameLength = mount_point_len;
    input->DeviceNameOffset = input->SymbolicLinkNameOffset +
                              input->SymbolicLinkNameLength;
    input->DeviceNameLength = dev_name_len;
    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  mount_device, mount_point_len);
    RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                  VolumeDevName, dev_name_len);
    status = DevfileIoctl(MountManager, IOCTL_MOUNTMGR_CREATE_POINT,
                          input, inputlength, NULL, 0, NULL);
    free(input);
    return status;

} // DisksAssignDosDevice



DWORD
DisksRemoveDosDeviceM(
    HANDLE MountManager,
    PCHAR   MountName
    )

/*++

Routine Description:

Inputs:
    MountManager - Handle to MountMgr
    MountName -

Return value:


--*/

{
    WCHAR mount_device[MAX_PATH];
    USHORT mount_point_len;
    DWORD  status;
    USHORT inputlength;
    PMOUNTMGR_MOUNT_POINT input;

    PUCHAR  bogusBuffer;    // this buffer should NOT be required!
    DWORD   bogusBufferLength = BOGUS_BUFFER_LENGTH;

    //
    // Remove old mount points for this mount name.
    //
    if ( FAILED( StringCchPrintf( mount_device,
                                  RTL_NUMBER_OF(mount_device),
                                  TEXT("\\DosDevices\\%S"),
                                  MountName) ) ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    mount_point_len = wcslen(mount_device) * sizeof(WCHAR);
    inputlength = sizeof(MOUNTMGR_MOUNT_POINT) + mount_point_len;

    input = (PMOUNTMGR_MOUNT_POINT)malloc(inputlength);
    if (!input) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    bogusBuffer = malloc(bogusBufferLength);
    if (!bogusBuffer) {
        free(input);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    input->UniqueIdOffset = 0;
    input->UniqueIdLength = 0;
    input->DeviceNameOffset = 0;
    input->DeviceNameLength = 0;
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    input->SymbolicLinkNameLength = mount_point_len;
    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  mount_device, mount_point_len);
    do {
        status = DevfileIoctl(MountManager, IOCTL_MOUNTMGR_DELETE_POINTS,
                          input, inputlength, bogusBuffer, bogusBufferLength, NULL);
        free( bogusBuffer );
        if ( status == ERROR_MORE_DATA ) {
            bogusBufferLength += BOGUS_BUFFER_LENGTH;
            bogusBuffer = malloc(bogusBufferLength);
            if (!bogusBuffer) {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } while ( status == ERROR_MORE_DATA );

    free(input);

    //
    // Use the 'old-style' name on error in case we got a 'half-built' stack.
    //
    if ( status != ERROR_SUCCESS ) {
        DefineDosDeviceA( DDD_REMOVE_DEFINITION | DDD_NO_BROADCAST_SYSTEM,
                          MountName,
                          NULL );
    }

    return status;

} // DisksRemoveDosDevice


static
NTSTATUS
GetAssignedLetterM (
    IN HANDLE MountMgrHandle,
    IN PWCHAR deviceName,
    OUT PCHAR driveLetter )
/*++

Routine Description:

    Get an assigned drive letter from MountMgr, if any

Inputs:
    MountMgrHandle -
    deviceName -
    driveLetter - receives drive letter

Return value:

    STATUS_SUCCESS - on success
    NTSTATUS code  - on failure

--*/

{
   DWORD status = STATUS_SUCCESS;

   PMOUNTMGR_MOUNT_POINT  input  = NULL;
   PMOUNTMGR_MOUNT_POINTS output = NULL;
   PMOUNTMGR_MOUNT_POINT out;

   DWORD len = wcslen( deviceName ) * sizeof(WCHAR);
   DWORD bytesReturned;
   DWORD idx;

   DWORD outputLen;
   DWORD inputLen;

   WCHAR wc;


   // Input length has to include the MOUNTMGR_MOUNT_POINT
   // structure and the input device name string.

   inputLen = INPUT_BUFFER_LEN + len * 2;
   input = LocalAlloc( LPTR, inputLen );

   if ( !input ) {
       status = STATUS_INSUFFICIENT_RESOURCES;
       goto FnExit;
   }

   input->SymbolicLinkNameOffset = 0;
   input->SymbolicLinkNameLength = 0;
   input->UniqueIdOffset = 0;
   input->UniqueIdLength = 0;
   input->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
   input->DeviceNameLength = (USHORT) len;
   RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                 deviceName, len );
   if (len > sizeof(WCHAR) && deviceName[1] == L'\\') {
       // convert Dos name to NT name
       ((PWCHAR)(input + input->DeviceNameOffset))[1] = L'?';
   }

   outputLen = OUTPUT_BUFFER_LEN;
   output = LocalAlloc( LPTR, outputLen );

   if ( !output ) {
       status = STATUS_INSUFFICIENT_RESOURCES;
       goto FnExit;
   }

   status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                input, inputLen, output, outputLen, &bytesReturned);

   if ( STATUS_BUFFER_OVERFLOW == status ) {

       outputLen = output->Size;
       LocalFree( output );

       output = LocalAlloc( LPTR, outputLen );

       if ( !output ) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           goto FnExit;
       }

       status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                    input, inputLen, output, outputLen, &bytesReturned);
   }

   if ( !NT_SUCCESS(status) ) {
       goto FnExit;
   }

   if (driveLetter) {
       *driveLetter = 0;
   }
   for ( idx = 0; idx < output->NumberOfMountPoints; ++idx ) {
       out = &output->MountPoints[idx];
       if (out->SymbolicLinkNameLength/sizeof(WCHAR) == 14 &&
           (ClRtlStrNICmp((PWCHAR)((PCHAR)output + out->SymbolicLinkNameOffset), L"\\DosDevices\\", 12) == 0) &&
           L':' == *((PCHAR)output + out->SymbolicLinkNameOffset + 13*sizeof(WCHAR)) )
       {
           wc = *((PCHAR)output + out->SymbolicLinkNameOffset + 12*sizeof(WCHAR));
           if (driveLetter && out->UniqueIdLength) {
              *driveLetter = (CHAR)toupper((UCHAR)wc);
              break;
           }
       }
   }

FnExit:

   if ( output ) {
       LocalFree( output );
   }

   if ( input ) {
       LocalFree( input );
   }

   return status;
}



BOOL
InterestingPartition(
   PPARTITION_INFORMATION info
   )
/*++

Routine Description:
    Quick check whether a partition is "interesting" for us

Inputs:
    info - GetDriveLayout's partition information

Return value:
    TRUE or FALSE

--*/

{
   return ( (info->RecognizedPartition)
       && ((info->PartitionType == PARTITION_IFS) ||
           IsContainerPartition(info->PartitionType)) );
}


PMOUNTIE_VOLUME
CreateMountieVolumeFromDriveLayoutInfo (
   IN PDRIVE_LAYOUT_INFORMATION info,
   IN HANDLE ResourceHandle
   )
/*++

Routine Description:
    Collects all interesing partition from DriveLayoutInformation
    then it allocates and fills MountieVolume structure

Inputs:
    info - GetDriveLayout's information
    ResourceHandle - for error logging - not used (may be NULL!)

Return value:
    TRUE or FALSE

--*/
{
   DWORD           i;
   DWORD           nPartitions = 0;
   PMOUNTIE_VOLUME vol;
   PMOUNTIE_PARTITION mountie;
   DWORD           size;

   //
   // Count Partitions
   //
   for (i = 0; i < info->PartitionCount; ++i) {
      if ( InterestingPartition( info->PartitionEntry + i ) ) {
         ++nPartitions;
      }
   }

   if (!nPartitions) {
      SetLastError(ERROR_INVALID_DATA);
      return 0;
   }

   //
   // Allocate memory for Mountie structure
   //

   size = sizeof(MOUNTIE_VOLUME) + sizeof(MOUNTIE_PARTITION) * (nPartitions - 1);
   vol = malloc( size );
   if (!vol) {
      SetLastError(ERROR_OUTOFMEMORY);
      return 0;
   }
   RtlZeroMemory(vol, size);
   vol->PartitionCount = nPartitions;
   vol->Signature      = info->Signature;

   //
   // Copy all relevant Information from DriveLayout info
   //

   mountie = vol->Partition;

   for (i = 0; i < info->PartitionCount; ++i) {
      PPARTITION_INFORMATION entry = info->PartitionEntry + i;

      if ( InterestingPartition(entry) ) {

         mountie->StartingOffset  = entry->StartingOffset;
         mountie->PartitionLength = entry->PartitionLength;
         mountie->PartitionNumber = entry->PartitionNumber;
         mountie->PartitionType   = entry->PartitionType;

         ++mountie;
      }
   }

   return vol;
}


VOID
MountieUpdateDriveLetters(
    IN OUT PMOUNTIE_INFO info
    )
/*++

Routine Description:
    Updates DriveLetter bitmap.
    This routine needs to be called every time
    drive letter information is changed in MountieInfo

Inputs:
    info - MountieInfo

--*/
{
   DWORD i;
   DWORD driveLetters = 0;
   PMOUNTIE_VOLUME vol = info->Volume;

   if (vol) {
      for (i = 0; i < vol->PartitionCount; ++i) {
         UCHAR ch = vol->Partition[i].DriveLetter;
         if (ch) {
            driveLetters |= 1 << (ch - 'A');
         }
      }
   }

   info->DriveLetters = driveLetters;
}


PMOUNTIE_PARTITION
MountiePartitionByOffsetAndLength(
    IN PMOUNTIE_INFO Info,
    LARGE_INTEGER Offset, LARGE_INTEGER Len)
{
    DWORD     PartitionCount;
    PMOUNTIE_PARTITION entry;

    if (!Info->Volume) {
        return 0;
    }

    PartitionCount = Info->Volume->PartitionCount;
    entry          = Info->Volume->Partition;

    while ( PartitionCount-- ) {

       if (entry->StartingOffset.QuadPart == Offset.QuadPart
        && entry->PartitionLength.QuadPart == Len.QuadPart) {
          return entry;
       }

       ++entry;
    }
    return 0;
}


DWORD
MountiePartitionCount(
   IN PMOUNTIE_INFO Info)
{
   if (Info->Volume) {
      return Info->Volume->PartitionCount;
   } else {
      return 0;
   }
}


PMOUNTIE_PARTITION
MountiePartition(
   IN PMOUNTIE_INFO Info,
   IN DWORD Index)
{
   return Info->Volume->Partition + Index;
}


PMOUNTIE_PARTITION
MountiePartitionByPartitionNo(
   IN PMOUNTIE_INFO Info,
   IN DWORD PartitionNumber
   )
{
   DWORD i, n;
   PMOUNTIE_PARTITION entry;
   if (Info->Volume == 0) {
      return 0;
   }
   n = Info->Volume->PartitionCount;
   entry = Info->Volume->Partition;
   for (i = 0; i < n; ++i, ++entry) {
      if (entry->PartitionNumber == PartitionNumber)
      {
         return entry;
      }
   }
   return 0;
}


VOID
MountiePrint(
   IN PMOUNTIE_INFO Info,
   IN HANDLE ResourceHandle
   )
{
   DWORD i, n;
   PMOUNTIE_PARTITION entry;
   if (Info->Volume == 0) {
      return;
   }
   n = Info->Volume->PartitionCount;
   entry = Info->Volume->Partition;
   for (i = 0; i < n; ++i, ++entry) {
      (DiskpLogEvent)(
          ResourceHandle,
          LOG_INFORMATION,
          L"Mountie[%1!u!]: %2!u!, let=%3!c!, start=%4!X!, len=%5!X!.\n",
          i,
          entry->PartitionNumber,
          NICE_DRIVE_LETTER(entry->DriveLetter),
          entry->StartingOffset.LowPart,
          entry->PartitionLength.LowPart );
   }
}


DWORD
DisksGetLettersForSignature(
    IN PDISK_RESOURCE ResourceEntry
    )
{
   return ResourceEntry->MountieInfo.DriveLetters;
}


DWORD
MountieRecreateVolumeInfoFromHandle(
    IN  HANDLE FileHandle,
    IN  DWORD  HarddiskNo,
    IN  HANDLE ResourceHandle,
    IN OUT PMOUNTIE_INFO Info
    )

/*++

Routine Description:
    Recreate a MountieInfo that has no
    DriveLetter assignments.

    IMPORTANT!!! The code assumes that Info->Volume
    either contains a valid pointer or NULL

Inputs:
    ResourceHandle - may be NULL.

Outputs:
    Info - MountieInfo

--*/
{
   PDRIVE_LAYOUT_INFORMATION layout;
   DWORD status;
   DWORD bytesReturned;

   free( Info->Volume ); // free(0) is OK //
   Info->HarddiskNo = HarddiskNo;
   Info->DriveLetters = 0;
   Info->Volume = 0;
   Info->VolumeStructSize = 0;

   //
   // Tell storage drivers to refresh their cached partition information.
   // Ignore the returned status.  This IOCTL can only go to the physical
   // disk (partition0), not any of the partitions.
   //

   DeviceIoControl( FileHandle,
                    IOCTL_DISK_UPDATE_PROPERTIES,
                    NULL,
                    0,
                    NULL,
                    0,
                    &bytesReturned,
                    NULL );

   layout = DoIoctlAndAllocate(
      FileHandle, IOCTL_DISK_GET_DRIVE_LAYOUT, 0,0, &bytesReturned);
   if (!layout) {
      return GetLastError();
   }

   status = ERROR_SUCCESS;
   try {

      Info->Volume = CreateMountieVolumeFromDriveLayoutInfo( layout , ResourceHandle );
      if (!Info->Volume) {
         status = GetLastError();
         leave;
      }
      Info->VolumeStructSize = sizeof(MOUNTIE_VOLUME) +
         sizeof(MOUNTIE_PARTITION) * (Info->Volume->PartitionCount - 1);

   } finally {
      free( layout );
   }
   if ( ResourceHandle ) MountiePrint(Info, ResourceHandle);
   return status;
}


DWORD
MountieFindPartitionsForDisk(
    IN DWORD HarddiskNo,
    OUT PMOUNTIE_INFO MountieInfo
    )
/*++

  Note that Caller of this routine is responsible for freeing Volume Information
  via call to MountieCleanup().

--*/
{
    WCHAR   deviceName[MAX_PATH];
    HANDLE  fileHandle;
    DWORD   status;

    if ( FAILED( StringCchPrintf( deviceName,
                                  RTL_NUMBER_OF( deviceName ),
                                  TEXT("\\\\.\\PhysicalDrive%u"),
                                  HarddiskNo ) ) ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    fileHandle = CreateFile( deviceName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL );
    if ( (fileHandle == NULL) ||
         (fileHandle == INVALID_HANDLE_VALUE) ) {
        status = GetLastError();
        return status;
    }

    RtlZeroMemory( MountieInfo, sizeof(MOUNTIE_INFO) );
    status = MountieRecreateVolumeInfoFromHandle(
                        fileHandle,
                        HarddiskNo,
                        NULL,
                        MountieInfo );
    if ( status != ERROR_SUCCESS ) {
        CloseHandle( fileHandle );

        return status;
    }

    CloseHandle( fileHandle );

    return(ERROR_SUCCESS);

} // MountieFindPartitionsForDisk



VOID
MountieCleanup(
    IN OUT PMOUNTIE_INFO Info
    )
/*++

Routine Description:
    Deallocates Volume information

Inputs:
    Info - MountieInfo

--*/
{
    PVOID volume;

    Info->VolumeStructSize = 0;
    volume = InterlockedExchangePointer(&(Info->Volume), 0);
    free(volume);
}


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

//
//  Disk information is specified in different formats in various places
//
//  The following code is an attempt to provide some common denominator
//  to simplify verification of all disk information and keeping it in sync.
//

UCHAR
AssignedLetterByPartitionNumber (
   PLETTER_ASSIGNMENT Assignment,
   DWORD PartitionNo)
/*++

Routine Description:
    Returns a drive letter assigned to a partition

Inputs:
    Assignment - drive letter assignment info
    PartitionNo - partition number (As in Harddisk0\PartitionX)

--*/
{
   UCHAR  i;
   for( i = 0; i < 26; ++i ) {
      if (Assignment->PartNumber[i] == PartitionNo) {
         return ('A' + i);
      }
   }
   return 0;
}


//  For every different way to describe a disk information
//  there should be two functions defined GetInfo and SetInfo
//  which will read/write the information into/from LETTER_ASSIGNMENT structure

typedef DWORD (*GetInfoFunc) (PMOUNTIE_INFO, PDISK_RESOURCE ResourceEntry, PLETTER_ASSIGNMENT Result);
typedef DWORD (*SetInfoFunc) (PMOUNTIE_INFO, PDISK_RESOURCE ResourceEntry);

//
// The following structure is a description of disk information provider.
//
// It is used to bind a provider name (Used as a label in error logging)
// and information access routines
//

typedef struct _INFO_PROVIDER {
   PWCHAR Name;
   GetInfoFunc GetInfo;
   SetInfoFunc SetInfo;
} INFO_PROVIDER, *PINFO_PROVIDER;

////////////////////////////////////////////////////////////////////
//
// The following routine gets FtInfo, by reading existing one or
//   creating an empty one if there is no System\DISK in the registry)
//
// Then it adds/updates drive letter assignment for the specified drive,
//   using the information supplied in MOUNTIE_INFO structure.
//

PFT_INFO
FtInfo_CreateFromMountie(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry)
{
   PFT_INFO ftInfo = 0;
   DWORD i, n;
   DWORD Status = ERROR_SUCCESS;
   PMOUNTIE_PARTITION entry;

   try {
      ftInfo = DiskGetFtInfo();
      if ( !ftInfo ) {
          (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"Failed to get FtInfo.\n");
          Status = ERROR_NOT_ENOUGH_MEMORY;
          ftInfo = 0;
          leave;
      }

      Status = DiskAddDiskInfoEx( ftInfo,
                       ResourceEntry->DiskInfo.PhysicalDrive,
                       ResourceEntry->DiskInfo.Params.Signature,
                       DISKRTL_REPLACE_IF_EXISTS );

      if ( Status != ERROR_SUCCESS ) {
          (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"Error %1!d! adding DiskInfo.\n",
                  Status);
          ftInfo = 0;
          leave;
      }

      n = Info->Volume->PartitionCount;
      entry = Info->Volume->Partition;
      //
      // Now add the partition info for each partition
      //
      for ( i = 0; i < n; ++i,++entry ) {

          Status = DiskAddDriveLetterEx( ftInfo,
                                       ResourceEntry->DiskInfo.Params.Signature,
                                       entry->StartingOffset,
                                       entry->PartitionLength,
                                       entry->DriveLetter, 0);
          if ( Status != ERROR_SUCCESS ) {
              (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                      LOG_ERROR,
                      L"Error %1!d! adding partition %2!x!:%3!x! letter %4!X! sig %5!x!.\n",
                      Status, entry->StartingOffset.LowPart,
                              entry->PartitionLength.LowPart,
                              entry->DriveLetter,
                              Info->Volume->Signature);
              break;
          }
      }
   } finally {
      if (Status != ERROR_SUCCESS) {
         SetLastError(Status);
         if (ftInfo) {
            DiskFreeFtInfo(ftInfo);
            ftInfo = 0;
         }
      }
   }
   return ftInfo;
}



DWORD FtInfo_GetFromFtInfo(
   IN PMOUNTIE_INFO  Info,
   IN PDISK_RESOURCE ResourceEntry,
   IN PFT_INFO       FtInfo,
   IN OUT PLETTER_ASSIGNMENT Result)
{
   DWORD i, n;
   PFT_DISK_INFO FtDisk;

   FtDisk = FtInfo_GetFtDiskInfoBySignature(
               FtInfo, ResourceEntry->DiskInfo.Params.Signature);

   if ( !FtDisk ) {
      (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"FtInfo_GetFromFtInfo: GetFtDiskInfoBySignature failed.\n");
      ++Result->MismatchCount;
      return ERROR_NOT_FOUND;
   }

   n = FtDiskInfo_GetPartitionCount(FtDisk);
   if (n == 0) {
      (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"FtInfo_GetFromFtInfo: DiskInfo has no partitions.\n");
      ++Result->MismatchCount;
      return ERROR_NOT_FOUND;
   }
   // sanity check                      //
   // number 10 is completely arbitrary //
   if (n > Info->Volume->PartitionCount * 10) {
      (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"FtInfo_GetFromFtInfo: DiskInfo has %1!u! partitions!\n", n);
      n = Info->Volume->PartitionCount * 10;
   }
   for(i = 0; i < n; ++i) {
      DISK_PARTITION UNALIGNED *entry;
      PMOUNTIE_PARTITION mountie;

      entry = FtDiskInfo_GetPartitionInfoByIndex(FtDisk, i);
      if (entry == NULL) {
         ++Result->MismatchCount;
         (DiskpLogEvent)(
                 ResourceEntry->ResourceHandle,
                 LOG_WARNING,
                 L"FtDiskInfo_GetPartitionInfoByIndex(%1!d!) return NULL\n",
                 i );
         continue;
      }

      mountie = MountiePartitionByOffsetAndLength(
                   Info,
                   entry->StartingOffset,
                   entry->Length);
      if (mountie) {
         UCHAR ch = (UCHAR)toupper( entry->DriveLetter );
         // Match count no longer requires a drive letter.
         ++Result->MatchCount;
         if ( isalpha(ch) ) {
            ch -= 'A';
            Result->DriveLetters |= ( 1 << ch );
            Result->PartNumber[ch] = (PARTITION_NUMBER_TYPE) mountie->PartitionNumber;
         }
      } else {
         //
         //  Chittur Subbaraman (chitturs) - 11/5/98
         //
         //  Added the following 4 statements for event logging in MountieVerify
         //
         UCHAR uch = (UCHAR)toupper( entry->DriveLetter );
         if ( isalpha(uch) ) {
            uch -= 'A';
            Result->DriveLetters |= ( 1 << uch );
         }
         ++Result->MismatchCount;
         (DiskpLogEvent)(
                 ResourceEntry->ResourceHandle,
                 LOG_WARNING,
                 L"Strange partition: %1!X!, %2!X!, Type=%3!u!, letter=%4!c!.\n",
                 entry->StartingOffset.LowPart, entry->Length.LowPart,
                 entry->FtType, NICE_DRIVE_LETTER(entry->DriveLetter) );
      }
   }
   return ERROR_SUCCESS;
}



/////////////////////////////////////////////////////////////////
//
//  NT4 style System\DISK and ClusReg\DiskInfo
//  accessing routines
//
//    ClusDiskInfo_Get
//    ClusDiskInfo_Set
//    FtInfo_Get
//    FtInfo_Set
//

DWORD
CluDiskInfo_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result)
/*++

Routine Description:

    This routine does nothing now that we are no longer using the
    Cluster DiskInfo key.

--*/
{
#if USE_CLUSTERDB_DISKINFO

   DWORD Length;
   DWORD Status;
   DWORD errorLevel;
   PFULL_DISK_INFO DiskInfo = 0;

   try {
   //
   // Read out the diskinfo parameter from our resource.
   //
      Status = ClusterRegQueryValue(ResourceEntry->ResourceParametersKey,
                                    DISKS_DISK_INFO,
                                    NULL,
                                    NULL,
                                    &Length);

      if (Status == ERROR_SUCCESS ) {



        DiskInfo = malloc(Length);
        if (!DiskInfo) {
           Status = ERROR_OUTOFMEMORY;
        } else {
           Status = ClusterRegQueryValue(ResourceEntry->ResourceParametersKey,
                                         DISKS_DISK_INFO,
                                         NULL,
                                         (LPBYTE)DiskInfo,
                                         &Length);

           if (Status == ERROR_SUCCESS) {
              PFT_INFO ftInfo = DiskGetFtInfoFromFullDiskinfo(DiskInfo);
              if (ftInfo) {
                 Status = FtInfo_GetFromFtInfo(Info,
                                               ResourceEntry,
                                               ftInfo,
                                               Result);
                 DiskFreeFtInfo(ftInfo);
              } else {
                 Status = GetLastError();
              }
           }
        }
      }

   } finally {
      if (Status != ERROR_SUCCESS) {

         if ( !DisksGetLettersForSignature( ResourceEntry ) ) {
            // No drive letters, we are using mount points and this is not an error.
            errorLevel = LOG_WARNING;
         } else {
            // Drive letters exist, this is likely an error.
            errorLevel = LOG_ERROR;
         }

         (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            errorLevel,
            L"CluDiskInfo_Get: Status=%1!u!.\n", Status);
            ++Result->MismatchCount;

      }
      free(DiskInfo);
   }
#endif

   return ERROR_SUCCESS;
}



DWORD
FtInfo_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result)
{
   PFT_INFO FtInfo;
   DWORD Status;

   //
   // Get registry info.
   //
   FtInfo = DiskGetFtInfo();
   if ( !FtInfo ) {
      return ERROR_OUTOFMEMORY;
   }

   Status = FtInfo_GetFromFtInfo(Info, ResourceEntry, FtInfo, Result);
   DiskFreeFtInfo(FtInfo);

   if (Status != ERROR_SUCCESS) {
      ++Result->MismatchCount;
   }

   return ERROR_SUCCESS;
}

DWORD
FtInfo_Set(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry)
{
   PFT_INFO ftInfo = FtInfo_CreateFromMountie(Info, ResourceEntry);
   if (ftInfo) {
      DWORD status = DiskCommitFtInfo(ftInfo);
      if (status != ERROR_SUCCESS) {
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"FtInfo_Set: CommitFtInfo status = %1!u!.\n", status);
      } else {
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"FtInfo_Set: Update successful.\n");
      }
      DiskFreeFtInfo(ftInfo);
      return status;
   } else {
       DWORD status = GetLastError();
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"FtInfoSet: CreateFromMountie failed, status = %1!u!.\n", status);
      return status;
   }
}


DWORD
CluDiskInfo_Set(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry)
/*++

Routine Description:

    Delete the Cluster DiskInfo key.  If this is the quorum disk online
    thread, we may have to create another thread to actually delete the
    value from the cluster DB.

--*/
{
#if USE_CLUSTERDB_DISKINFO

   PFT_INFO ftInfo = FtInfo_CreateFromMountie(Info, ResourceEntry);
   if (ftInfo) {
      PFULL_DISK_INFO DiskInfo;
      DWORD Length;
      DWORD Status;
      DiskInfo = DiskGetFullDiskInfo( ftInfo,
                                      ResourceEntry->DiskInfo.Params.Signature,
                                      &Length );
      if ( DiskInfo ) {
          Status = ClusterRegSetValue(ResourceEntry->ResourceParametersKey,
                                      DISKS_DISK_INFO,
                                      REG_BINARY,
                                      (CONST BYTE *)DiskInfo,
                                      Length);
          if (Status != ERROR_SUCCESS && Status != ERROR_SHARING_PAUSED) {
             (DiskpLogEvent)(
                 ResourceEntry->ResourceHandle,
                 LOG_ERROR,
                 L"CluDiskInfo_Set: Data Length = %1!u!.\n", Length);
          }
          LocalFree( DiskInfo );
      } else {
         (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_ERROR,
             L"CluDiskInfo_Set: Disk with signature %1!x! is not found. Error=%2!u!\n", ResourceEntry->DiskInfo.Params.Signature, GetLastError());
         Status = ERROR_FILE_NOT_FOUND;
      }

      DiskFreeFtInfo(ftInfo);
      return Status;
   } else {
      (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_ERROR,
          L"CluDiskInfo_Set: Failed to create FtInfo.\n");
      return GetLastError();
   }

#else

    HANDLE thread;
    DWORD threadId;
    DWORD dwError;
    DWORD length;

    //
    // Try opening the key first.  If it doesn't exist, we don't need to
    // delete it.
    //

    dwError = ClusterRegQueryValue( ResourceEntry->ResourceParametersKey,
                                    DISKS_DISK_INFO,
                                    NULL,
                                    NULL,
                                    &length );

    if ( ERROR_FILE_NOT_FOUND == dwError ||
         ( ERROR_SUCCESS == dwError && 0 == length ) ) {
        goto FnExit;
    }

    dwError = ClusterRegDeleteValue( ResourceEntry->ResourceParametersKey,
                                     DISKS_DISK_INFO );

    //
    // If we successfully deleted the value or if the value is already
    // deleted, we are done.
    //

    if ( ERROR_SUCCESS == dwError || ERROR_FILE_NOT_FOUND == dwError ) {
        goto FnExit;
    }

    if ( ERROR_SHARING_PAUSED != dwError ) {
        (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                         LOG_WARNING,
                         L"CluDiskInfo_Set: Delete registry value failed, %1!u!.\n", dwError );

        goto FnExit;
    }

    //
    // Quorum disk will return error until online completes.
    //

    //
    // Check if the thread is already active.  If it is, don't do anything.
    //

    if ( InterlockedCompareExchange( &DiskInfoUpdateThreadIsActive,
                                     1,
                                     0 ) )  {

        (DiskpLogEvent)( ResourceEntry->ResourceHandle,
                         LOG_WARNING,
                         L"CluDiskInfo_Set: DiskInfo update thread is already running \n" );

        goto FnExit;
    }

    thread = CreateThread( NULL,
                           0,
                           SetDiskInfoThread,
                           ResourceEntry,
                           0,
                           &threadId );

    if ( NULL == thread ) {

        //
        // Thread creation failed.  Log error, clear thread active flag,
        // and return.
        //

        dwError = GetLastError();

        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"CluDiskInfo_Set: CreateThread failed, error %1!u!\n",
            dwError );

        InterlockedExchange( &DiskInfoUpdateThreadIsActive, 0 );

        goto FnExit;
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"CluDiskInfo_Set: Thread created \n" );

    //
    // Thread created.  Close the handle and return.
    //

    CloseHandle( thread );

FnExit:

    return ERROR_SUCCESS;

#endif

}



////////////////////////////////////////////////////////
//
// New NT5 clusreg volume information access routines
//
//    Mountie_Get
//    Mountie_Set
//
//////////

DWORD
Mountie_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result)
{
   DWORD Length = 0;        // Prefix bug 56153: initialize variable.
   DWORD Status;
   PMOUNTIE_VOLUME Volume = NULL;
   DWORD i, n;
   PMOUNTIE_PARTITION entry;

   try {
      //
      // Read out the diskinfo parameter from our resource.
      //
      Status = ClusterRegQueryValue(ResourceEntry->ResourceParametersKey,
                                    MOUNTIE_VOLUME_INFO,
                                    NULL,
                                    NULL,
                                    &Length);
      if (Status == ERROR_FILE_NOT_FOUND ) {
         ++Result->MismatchCount;
         Status = ERROR_SUCCESS;
         leave;
      }

      //
      // Prefix bug 56153: Make sure the length is valid before allocating
      // memory.
      //
      if ( !Length ) {
          Status = ERROR_BAD_LENGTH;
          leave;
      }

      Volume = malloc(Length);
      if (!Volume) {
         Status = ERROR_OUTOFMEMORY;
         leave;
      }

      Status = ClusterRegQueryValue(ResourceEntry->ResourceParametersKey,
                                    MOUNTIE_VOLUME_INFO,
                                    NULL,
                                    (LPBYTE)Volume,
                                    &Length);
      if (Status != ERROR_SUCCESS) {
         leave;
      }

      if (Length < sizeof(MOUNTIE_VOLUME) ) {
          ++Result->MismatchCount;
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"Get: MountVolumeInfo key is truncated. Cannot read header, length %1!d!.\n", Length);
          Status = ERROR_SUCCESS;
          leave;
      }

      n = Volume->PartitionCount;
      entry = Volume->Partition;

      if (n == 0) {
         ++Result->MismatchCount;
         (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_ERROR,
             L"Get: MountVolumeInfo key is corrupted. No partitions.\n");
         Status = ERROR_SUCCESS;
         leave;
      }
      if ( Length < (sizeof(MOUNTIE_VOLUME) + (n-1) * sizeof(MOUNTIE_PARTITION)) ) {
          DWORD delta = sizeof(MOUNTIE_VOLUME) + (n-1) * sizeof(MOUNTIE_PARTITION) - Length;
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"Get: MountVolumeInfo key is corrupted. "
              L"Length %1!d!, PartitionCount %2!d!, delta %3!d!.\n", Length, n, delta);
          ++Result->MismatchCount;
          Status = ERROR_SUCCESS;
          leave;
      }


      for (i = 0; i < n; ++i, ++entry) {
         PMOUNTIE_PARTITION mountie;

         mountie = MountiePartitionByOffsetAndLength(
                      Info,
                      entry->StartingOffset,
                      entry->PartitionLength);
         if (mountie) {
            UCHAR ch = (UCHAR)toupper( entry->DriveLetter );
            // Match count no longer requires a drive letter.
            ++Result->MatchCount;
            if ( isalpha(ch) ) {
               ch -= 'A';
               Result->DriveLetters |= ( 1 << ch );
               Result->PartNumber[ch] = (PARTITION_NUMBER_TYPE) mountie->PartitionNumber;
            }
         } else {
            ++Result->MismatchCount;
         }

      }

   } finally {
      if (Status != ERROR_SUCCESS) {
         ++Result->MismatchCount;
      }
      free(Volume);
   }
   return ERROR_SUCCESS;
}


DWORD
Mountie_Set(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry)
{
   DWORD Status = ClusterRegSetValue(ResourceEntry->ResourceParametersKey,
                               MOUNTIE_VOLUME_INFO,
                               REG_BINARY,
                               (LPBYTE)Info->Volume,
                               Info->VolumeStructSize);
   return Status;
}


///////////////////////////////////////////////////////////
//
// NT5 MountManager's volume information access routines
//
//   MountMgr_Get
//   MountMgr_Set
//
//////////

DWORD
MountMgr_Get(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry,
    PLETTER_ASSIGNMENT Result)
{
   DWORD PartitionCount = Info->Volume->PartitionCount;
   DWORD i;
   DWORD error;
   NTSTATUS ntStatus;
   HANDLE MountManager;

   ntStatus = DevfileOpen(&MountManager, MOUNTMGR_DEVICE_NAME);
   if (!NT_SUCCESS(ntStatus)) {
      if ( ResourceEntry ) {
          (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_ERROR,
              L"Get: MountMgr open failed, status %1!X!.\n", ntStatus);
       }
       return RtlNtStatusToDosError(ntStatus);
   }

   error = ERROR_SUCCESS;
   try {

      for (i = 0; i < PartitionCount; ++i) {
         PMOUNTIE_PARTITION entry = Info->Volume->Partition + i;
         WCHAR DeviceName[MAX_PATH];
         UCHAR ch;

         (VOID) StringCchPrintf( DeviceName,
                                 RTL_NUMBER_OF( DeviceName ),
                                 DEVICE_HARDDISK_PARTITION_FMT,
                                 Info->HarddiskNo,
                                 entry->PartitionNumber );

         ntStatus = GetAssignedLetterM(MountManager, DeviceName, &ch);

         if ( NT_SUCCESS(ntStatus) ) {
            if ( Result ) {
               // Match count no longer requres a drive letter.
               ++Result->MatchCount;
            }
            if (Result && ch) {
               ch -= 'A';
               Result->DriveLetters |= ( 1 << ch );
               Result->PartNumber[ch] = (PARTITION_NUMBER_TYPE) entry->PartitionNumber;
            }
         } else {
            if ( ResourceEntry ) {
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Get Assigned Letter for %1!ws! returned status %2!X!.\n", DeviceName, ntStatus);
            }
            error = RtlNtStatusToDosError(ntStatus);
            leave;
         }
      }

   } finally {
      DevfileClose(MountManager);
   }

   return error;
}


DWORD
MountMgr_Set(
    PMOUNTIE_INFO Info,
    PDISK_RESOURCE ResourceEntry
    )
{
   HANDLE MountManager;
   DWORD PartitionCount = Info->Volume->PartitionCount;
   DWORD i, status;
   UCHAR dosName[3];
   NTSTATUS ntStatus;

  (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"MountMgr_Set: Entry\n");

   ntStatus = DevfileOpen(&MountManager, MOUNTMGR_DEVICE_NAME);
   if (!NT_SUCCESS(ntStatus)) {
      (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_ERROR,
          L"Set: MountMgr open failed, status %1!X!.\n", ntStatus);
       return RtlNtStatusToDosError(ntStatus);
   }

   try {
      dosName[1] = ':';
      dosName[2] = '\0';

      //
      // Remove old assignment of letters we are going to use
      //

      for (i = 0; i < 26; ++i) {
        if ( (1 << i) & Info->DriveLetters ) {
           dosName[0] = (UCHAR)('A' + i);
           status = DisksRemoveDosDeviceM(MountManager, dosName);
           (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountMgr_Set: Remove Dos Device, letter=%1!c!, status=%2!u!\n",
                NICE_DRIVE_LETTER(dosName[0]), status);
        }
      }

      for (i = 0; i < PartitionCount; ++i) {
         PMOUNTIE_PARTITION entry = Info->Volume->Partition + i;
         WCHAR DeviceName[MAX_PATH];
         UCHAR ch;

         (VOID) StringCchPrintf( DeviceName,
                                 RTL_NUMBER_OF( DeviceName ),
                                 DEVICE_HARDDISK_PARTITION_FMT,
                                 Info->HarddiskNo,
                                 entry->PartitionNumber );

         ntStatus = GetAssignedLetterM(MountManager, DeviceName, &ch);
         if ( NT_SUCCESS(ntStatus) && ch) {
            dosName[0] = ch;
            status = DisksRemoveDosDeviceM(MountManager, dosName);
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountMgr_Set: Remove Dos Device 2, letter=%1!c!, status=%2!u!\n",
                NICE_DRIVE_LETTER(dosName[0]), status);
         }
         if (entry->DriveLetter) {
            dosName[0] = entry->DriveLetter;
            status = DisksAssignDosDeviceM(MountManager, dosName, DeviceName);
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountMgr_Set: Assign Dos Device, letter=%1!c!, status=%2!u!\n",
                NICE_DRIVE_LETTER(dosName[0]), status);
         }
      }
   } finally {
      DevfileClose( MountManager );
   }

    return ERROR_SUCCESS;

}


/////////////////////////////////////////////////////////////////////////
//
// information providers table
//
//  Disk\Information has to be the last entry of the table
//
//  Order of the entries is important
//
/////////////////////////////////////////////////////////////////

INFO_PROVIDER Providers[] = {
   {L"ClusReg-DiskInfo",      CluDiskInfo_Get, CluDiskInfo_Set},
   {L"ClusReg-Mountie",       Mountie_Get, Mountie_Set},
   {L"MountMgr",              MountMgr_Get, MountMgr_Set},
   {L"Registry-System\\DISK", FtInfo_Get, FtInfo_Set}, // Disk\Information must be the last (Why?)
};

enum {
   PROVIDER_COUNT = sizeof(Providers)/sizeof(Providers[0]),
   MOUNT_MANAGER = PROVIDER_COUNT - 2,
};

DWORD
MountieUpdate(
    PMOUNTIE_INFO info,
    PDISK_RESOURCE ResourceEntry)
/*++

Routine Description:
    Update disk information for all providers
    marked in NeedsUpdate bitmask

Inputs:
    Info - MountieInfo

--*/
{
    DWORD NeedsUpdate = info->NeedsUpdate;
    BOOLEAN SharingPausedError = FALSE;
    DWORD   LastError = ERROR_SUCCESS;
    INT   i;

    if (!NeedsUpdate) {
       return ERROR_SUCCESS;
    }

    for (i = 0; i < PROVIDER_COUNT; ++i) {
       if ( (1 << i) & NeedsUpdate ) {
          DWORD status;
          status = Providers[i].SetInfo(info, ResourceEntry);
          if (status != ERROR_SUCCESS) {
             (DiskpLogEvent)(
                 ResourceEntry->ResourceHandle,
                 LOG_INFORMATION,
                 L"MountieUpdate: %1!ws!.SetInfo failed, error %2!u!.\n", Providers[i].Name, status);
             if (status == ERROR_SHARING_PAUSED) {
                SharingPausedError = TRUE;
             } else {
                LastError = status;
             }
          } else {
             NeedsUpdate &= ~(1 << i);
          }
       }
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"MountieUpdate: Update needed for %1!02x!.\n", NeedsUpdate);
    info->NeedsUpdate = NeedsUpdate;
    if (NeedsUpdate) {
       if (SharingPausedError) {
          return ERROR_SHARING_PAUSED;
       }
       return LastError;
    }
    return ERROR_SUCCESS;
}


DWORD
MountieVerify(
    PMOUNTIE_INFO info,
    PDISK_RESOURCE ResourceEntry,
    BOOL UseMountMgr
    )
/*++

Routine Description:

    1. Compares information from all
       providers and select one of them as source of
       drive letter assignment.

    2. Update MountieInfo with this drive letter assignment

    3. Set NeedsUpdate for every provider whose information
       differ from the MountieInfo

Inputs:
    Info - MountieInfo

--*/
{
    LETTER_ASSIGNMENT results[PROVIDER_COUNT + 1];
    INT i;
    INT GoodProvider = -1;
    INT BestProvider = -1;
    DWORD BestMatch  = 0;
    INT PartitionCount;
    BOOLEAN UnassignedPartitions = FALSE;
    DWORD NeedsUpdate = 0;
    DWORD errorLevel;

    if (!info->Volume || info->Volume->PartitionCount == 0) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"FatalError: Bad Mountie Info.\n");
        return  ERROR_INVALID_HANDLE;
    }

    PartitionCount = info->Volume->PartitionCount;

    //
    // Clear old DriveLetters in MOUNTIE_INFO
    //
    for (i = 0; i < PartitionCount; ++i) {
        info->Volume->Partition[i].DriveLetter = 0;
    }

    //
    // Collect Letter Assignments from Providers
    //

    RtlZeroMemory( results, sizeof(results) );

    for (i = PROVIDER_COUNT; --i >= 0;) {
        DWORD status;
        status = Providers[i].GetInfo(info, ResourceEntry, results + i);
        if (status != ERROR_SUCCESS) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountieVerify: %1!ws!.GetInfo returned %2!u! [%3!u!:%4!u!].\n",
                Providers[i].Name, status, results[i].MatchCount, results[i].MismatchCount);
            return status;
        }
        if (results[i].MatchCount && !results[i].MismatchCount) {
            GoodProvider = i;
            if (results[i].MatchCount >= BestMatch) {
                BestProvider = i;
                BestMatch    = results[i].MatchCount;
            }
        } else {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"MountieVerify: %1!ws!.GetInfo returned %2!u! [%3!u!:%4!u!].\n",
                Providers[i].Name, status, results[i].MatchCount, results[i].MismatchCount);
        }
    }

    if (GoodProvider < 0 || GoodProvider >= PROVIDER_COUNT) {

        if ( !DisksGetLettersForSignature( ResourceEntry ) ) {
            // No drive letters, we are using mount points and this is not an error.
            errorLevel = LOG_WARNING;
        } else {
            // Drive letters exist, this is likely an error.
            errorLevel = LOG_ERROR;
        }

        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            errorLevel,
            L"MountieVerify: No good providers: %1!d!. \n", GoodProvider);
        return  ERROR_INVALID_HANDLE;
    }

    if (UseMountMgr) {
        GoodProvider = MOUNT_MANAGER;
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"MountieVerify: %1!ws! selected.\n",
        Providers[GoodProvider].Name);

    if (GoodProvider != BestProvider) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"MountieVerify: %1!ws! is better.\n",
            Providers[BestProvider].Name);
    }

    //
    // Now GoodProvider now holds an index of the highest
    // provider with non stale information.
    //
    // Copy its letter assignment to a MOUNTIE_INFO
    //

    for (i = 0; i < PartitionCount; ++i) {
        UCHAR ch = AssignedLetterByPartitionNumber(
                   results + GoodProvider,
                   info->Volume->Partition[i].PartitionNumber);
        info->Volume->Partition[i].DriveLetter = ch;
        if (!ch) {
            UnassignedPartitions = TRUE;
        }
    }

#if 0
    // No need to assign drive letters, since now we understand
    // PnP
    if (UnassignedPartitions) {
      //
      // Now give some arbitrary letter assignment to all
      // partitions without a drive letter
      //

      DriveLetters = GetLogicalDrives();
      if (!DriveLetters) {
         (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_ERROR,
             L"GetLogicalDrivers failed, error %u.\n", GetLastError() );
      } else {
         DWORD Letter = 0;

         DriveLetters &= ~results[MOUNT_MANAGER].DriveLetters;
         DriveLetters |=  results[GoodProvider].DriveLetters;
         DriveLetters |=  3; // Consider A and B drive letters busy //

         for (i = 0; i < PartitionCount; ++i) {
            PUCHAR pch = &info->Volume->Partition[i].DriveLetter;
            if (!*pch) {
               while( (1 << Letter) & DriveLetters ){
                  if (++Letter == 26) {
                     goto no_more_letters;
                  }
               }
               *pch = (UCHAR) ('A' + Letter);
               if (++Letter == 26) {
                  break;
               }
            }
         }
         no_more_letters:;
      }
    }
#endif

    // Update Drive Letters Mask //
    MountieUpdateDriveLetters(info);
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"MountieVerify: DriveLetters mask is now %1!08x!.\n", info->DriveLetters );

    //
    // Verify that the MS-DOS namespace drive letters are OK.
    //

    MountieVerifyMsdosDrives( info, ResourceEntry );

    //
    // At this point MOUNTIE_INFO has a complete letter assignment
    // for all partitions
    //
    // Now let's find which Providers needs to be updated
    //

    for (i = 0; i < PartitionCount; ++i) {
        PMOUNTIE_PARTITION entry = info->Volume->Partition + i;
        if (entry->DriveLetter) {
            results[PROVIDER_COUNT].PartNumber[ entry->DriveLetter - 'A' ] =
                (PARTITION_NUMBER_TYPE) entry->PartitionNumber;
        }
    }
    results[PROVIDER_COUNT].DriveLetters = info->DriveLetters;

    //
    // All provides whose entries are different from results[PROVIDER_COUNT]
    // need to be updated
    //

    for (i = 0; i < PROVIDER_COUNT; ++i) {
        if (results[i].DriveLetters != results[PROVIDER_COUNT].DriveLetters
          || results[i].MismatchCount
          || 0 != memcmp(results[i].PartNumber,
                         results[PROVIDER_COUNT].PartNumber, sizeof(results[i].PartNumber) )
         )
        {
            NeedsUpdate |= (1 << i);
        }
    }

    info->NeedsUpdate = NeedsUpdate;

    if (NeedsUpdate) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"MountieVerify: Update needed for %1!02x!.\n", NeedsUpdate);
        //
        //  Chittur Subbaraman (chitturs) - 11/5/98
        //
        //  If you plan to update the cluster registry values with info
        //  from the other providers, then log a warning to the event log.
        //
        if ( ( NeedsUpdate & 0x0003 ) && (GoodProvider == 2) && !UseMountMgr )
        {
            WCHAR  szNewDriveLetterList[55];
            WCHAR  szOriginalDriveLetterList[55];
            DWORD  j = 0, k = 0;

            for (i = 0; i < 26; ++i) {
                if ( (1 << i) & results[PROVIDER_COUNT].DriveLetters ) {
                    szNewDriveLetterList[j] = (WCHAR)(L'A' + i);
                    szNewDriveLetterList[j+1] = L' ';
                    j += 2;
                }
                if ( (1 << i) & results[0].DriveLetters ) {
                    szOriginalDriveLetterList[k] = (WCHAR)(L'A' + i);
                    szOriginalDriveLetterList[k+1] = L' ';
                    k += 2;
                }
            }
            szNewDriveLetterList[j] = L'\0';
            szOriginalDriveLetterList[k] = L'\0';

            //
            // GorN. 8/25/99.
            //
            // Log the event only if OriginalDriveLetterList is empty.
            //
            if ( results[PROVIDER_COUNT].DriveLetters ) {
                ClusResLogSystemEventByKey2( ResourceEntry->ResourceKey,
                                             LOG_NOISE,
                                             RES_DISK_WRITING_TO_CLUSREG,
                                             szOriginalDriveLetterList,
                                             szNewDriveLetterList
                                             );
            }
        }
    }

    return ERROR_SUCCESS;
}


DWORD
MountieVerifyMsdosDrives(
    IN PMOUNTIE_INFO Info,
    IN PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Checks whether each drive letter has a drive letter set in the
    MSDOS namespace.  When someone deletes a drive letter via
    DefineDosDevice, mountmgr does not update its internal tables.
    So a drive letter will not be accessible until the drive letter is
    recreated with a new call to DefineDosDevice.

Arguments:

    Info - pointer to filled in MOUNTIE_INFO structure.

    ResourceEntry - physical disk resource.


Return Value:

    Win32 error value

--*/
{
    HANDLE  devHandle = INVALID_HANDLE_VALUE;

    DWORD   dwError = NO_ERROR;
    DWORD   msdosDrives;
    DWORD   driveBitmap;
    DWORD   idx;
    DWORD   partitionCount;

    int     result;

    WCHAR   szGlobalDiskPartName[MAX_PATH];
    WCHAR   szVolumeName[MAX_PATH];
    WCHAR   szDriveLetterW[6];

    UCHAR   szDriveLetterA[6];
    UCHAR   ch;

    BOOL    boolVal;

    if ( !Info || !Info->Volume ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    // If this disk is not supposed to have drive letters, there is nothing to do.
    //

    if ( 0 == Info->DriveLetters ) {
        goto FnExit;
    }

    msdosDrives = GetLogicalDrives();

    if ( !msdosDrives ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"MountieVerifyMsdosDrives: GetLogicalDrives failed, error %1!u! \n",
            GetLastError() );
        goto FnExit;
    }

    partitionCount = Info->Volume->PartitionCount;

    //
    // Compare the MSDOS drive letters to those letters stored in
    // the disk resource.  If they are different, we have work to do.
    //

    if ( msdosDrives &&
         ( msdosDrives & Info->DriveLetters ) != Info->DriveLetters ) {

        //
        // We have a mismatch between drive letters MSDOS namespace has
        // and what mountmgr has.  We need to update the MSDOS namespace.
        // Assume mountmgr is always correct.
        //

        //
        // Find out which drive letters we are missing.
        //

        msdosDrives = (~msdosDrives & Info->DriveLetters) & 0x3ffffff ;

        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"MountieVerifyMsdosDrives: Missing MSDOS letters, mask %1!x! \n",
            msdosDrives );

        //
        // Set flag to ignore pnp notifications.
        //

        ResourceEntry->IgnoreMPNotifications = TRUE;

        //
        // Walk through each partition until we find a missing
        // drive letter.
        //

        for ( idx = 0; idx < partitionCount; ++idx ) {

            //
            // From the disk resource, get the current drive
            // letter for the volume.
            //

            ch = Info->Volume->Partition[idx].DriveLetter;

            //
            // If this is no drive letter that is supposed to be assigned to
            // this partition, skip it.
            //

            if ( 0 == ch ) {
                continue;
            }

            if ( !isupper( ch ) ) {
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"MountieVerifyMsdosDrives: Drive letter is incorrect format %1!c! \n",
                    ch );

                continue;
            }

            //
            // Convert drive letter to drive bitmap.
            //

            driveBitmap = (DWORD)( 1 << (ch - 'A') );

            //
            // If the drive letter isn't set, then create the MSDOS
            // device name again.  We are going to use the mountmgr
            // to do this work.
            //

            if ( driveBitmap & msdosDrives ) {

                szDriveLetterA[0] = ch;
                szDriveLetterA[1] = ':';
                szDriveLetterA[2] = '\\';
                szDriveLetterA[3] = '\0';

                //
                // Convert string to wide.
                //

                result = MultiByteToWideChar( CP_ACP,
                                              0,
                                              szDriveLetterA,
                                              -1,
                                              szDriveLetterW,
                                              RTL_NUMBER_OF(szDriveLetterW) - 1 );

                if ( !result ) {

                    dwError = GetLastError();

                    (DiskpLogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"MountieVerifyMsdosDrives: Unable to convert drive letter string, error %1!u! \n",
                        dwError );

                    continue;
                }

                //
                // Get the current VolGuid name.
                //

                (VOID) StringCchPrintf( szGlobalDiskPartName,
                                        RTL_NUMBER_OF( szGlobalDiskPartName ),
                                        GLOBALROOT_HARDDISK_PARTITION_FMT,
                                        Info->HarddiskNo,
                                        Info->Volume->Partition[idx].PartitionNumber );

                if ( !GetVolumeNameForVolumeMountPoint( szGlobalDiskPartName,
                                                        szVolumeName,
                                                        RTL_NUMBER_OF(szVolumeName) ) ) {
                    dwError = GetLastError();

                    (DiskpLogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"MountieVerifyMsdosDrives: Unable to get mount point for %1!ws! returned %2!u! \n",
                        dwError );

                    continue;
                }

                //
                // Remove the current mount point.
                //

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"MountieVerifyMsdosDrives: deleting mount point %1!ws! \n",
                    szDriveLetterW );

                if ( !DeleteVolumeMountPoint( szDriveLetterW ) ) {

                    dwError = GetLastError();

                    (DiskpLogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_WARNING,
                        L"MountieVerifyMsdosDrives: deleting mount point %1!ws! failed %2!u! \n",
                        szDriveLetterW,
                        dwError );

                    //
                    // Fall through...
                    //
                }

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"MountieVerifyMsdosDrives: recreating mount point %1!ws! \n",
                    szDriveLetterW );

                //
                // Recreate the mount point.
                //

                if ( !SetVolumeMountPoint( szDriveLetterW,
                                           szVolumeName ) ) {

                    dwError = GetLastError();

                } else {
                    dwError = NO_ERROR;
                }

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    ( dwError == NO_ERROR ) ? LOG_INFORMATION : LOG_ERROR,
                    L"MountieVerifyMsdosDrives: recreating mount point %1!ws! returns %2!u! \n",
                    szDriveLetterW,
                    dwError );
            }

        }

    }

FnExit:

    //
    // Clear flag to process pnp notifications again.
    //

    ResourceEntry->IgnoreMPNotifications = FALSE;


    if ( INVALID_HANDLE_VALUE != devHandle ) {
        DevfileClose( devHandle );
        devHandle = INVALID_HANDLE_VALUE;
    }

    return dwError;

}   // MountieVerifyMsdosDrives



DWORD VolumesReadyLoop(
    IN PMOUNTIE_INFO Info,
    IN PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Checks whether each partition described in the MountieInfo can be seen by the
    Mount Manager.  We call VolumesReady in a loop because mount manager might
    not yet have created all volume names, even though all volumes are known
    to pnp.

Inputs:


--*/
{
    DWORD   status = NO_ERROR;
    DWORD   retryCount;

    for ( retryCount = 0; retryCount < 5; retryCount++) {

        status = VolumesReady( Info, ResourceEntry );

        //
        // If the volume is ready, then exit.  For only a couple
        // specific errors will we retry waiting for the volume.
        //

        if ( ERROR_NOT_A_REPARSE_POINT != status &&
             ERROR_NOT_READY != status ) {
            break;
        }

        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_WARNING,
              L"VolumesReady: sleep and retry \n" );

        Sleep( 250 );
    }

    return status;

}   // VolumesReadyLoop


DWORD VolumesReady(
   IN PMOUNTIE_INFO Info,
   IN PDISK_RESOURCE ResourceEntry
   )
/*++

Routine Description:

    Checks whether each partition described in the MountieInfo can be seen by the
    Mount Manager.

Inputs:


--*/
{
    PMOUNTIE_PARTITION entry;

    DWORD status = NO_ERROR;
    DWORD nPartitions = MountiePartitionCount( Info );
    DWORD i;
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;

    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];

    for ( i = 0; i < nPartitions; ++i ) {

        entry = MountiePartition( Info, i );

        if ( !entry ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"VolumesReady: no partition entry for partition %1!u! \n", i );

            //
            // Something bad happened to our data structures.  Stop processing and
            // return error.
            //

            status = ERROR_INVALID_DATA;

            break;
        }

        //
        // Given the DiskPartName, get the VolGuid name.  This name must have a trailing
        // backslash to work correctly.
        //

        (VOID) StringCchPrintf( szGlobalDiskPartName,
                                RTL_NUMBER_OF( szGlobalDiskPartName ),
                                GLOBALROOT_HARDDISK_PARTITION_FMT,
                                physicalDrive,
                                entry->PartitionNumber );

        if ( !GetVolumeNameForVolumeMountPointW( szGlobalDiskPartName,
                                                 szVolumeName,
                                                 RTL_NUMBER_OF(szVolumeName) )) {

            status = GetLastError();

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_ERROR,
                  L"VolumesReady: GetVolumeNameForVolumeMountPoint for %1!ws! returned %2!u!\n",
                  szGlobalDiskPartName,
                  status );

            //
            // Something bad happened - stop checking this disk.  Return the
            // error status we received.
            //

            break;
        }

        //
        // If we get here, this volume is recognized by the Mount Manager.
        //
    }

    //
    // If disk corrupt or file corrupt error returned, disk is ready and
    // we need to run chkdsk.  Change status to success and fall through.
    //

    if ( ERROR_DISK_CORRUPT == status || ERROR_FILE_CORRUPT == status ) {

        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"VolumesReady, Allowing corrupt disk online for chkdsk processing \n" );

        status = STATUS_SUCCESS;
    }

    return status;

}   // VolumesReady


NTSTATUS
GetAssignedLetter (
    PWCHAR deviceName,
    PCHAR driveLetter )
{
   HANDLE MountMgrHandle = NULL;
   DWORD status = DevfileOpen( &MountMgrHandle, MOUNTMGR_DEVICE_NAME );

   if (driveLetter) {
      *driveLetter = 0;
   }

   if ( NT_SUCCESS(status) && MountMgrHandle ) {
      status = GetAssignedLetterM(MountMgrHandle, deviceName, driveLetter);
      DevfileClose(MountMgrHandle);
   }

   return status;
}


DWORD
SetDiskInfoThread(
    LPVOID lpThreadParameter
    )
/*++

Routine Description:

    Mount point list update thread.  Updates the cluster data base.

Arguments:

    lpThreadParameter - stores ResourceEntry.

Return Value:

    None

--*/

{
    DWORD dwError;
    PDISK_RESOURCE ResourceEntry = lpThreadParameter;
    DWORD idx;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"SetDiskInfoThread: started.\n");

    //
    // Will die in 10 minutes if unsuccessful
    //

    for ( idx = 0; idx < 300; ++idx ) {

        //
        // Wait for either the terminate event or the timeout
        //

        dwError = WaitForSingleObject( DisksTerminateEvent, 2000 );

        if ( WAIT_TIMEOUT == dwError ) {

            //
            // Timer expired.  Update the cluster database.
            //

            dwError = ClusterRegDeleteValue( ResourceEntry->ResourceParametersKey,
                                 DISKS_DISK_INFO );

            if ( ERROR_SUCCESS == dwError ) {

                //
                // We're done.
                //

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"SetDiskInfoThread: DiskInfo updated in cluster data base \n" );

                break;

            } else if ( ERROR_SHARING_PAUSED != dwError ) {

                //
                // If the drive is not yet online, we should have seen ERROR_SHARING_PAUSED.  If
                // we see any other error, something bad happened.
                //

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"SetDiskInfoThread: Failed to update cluster data base, error = %1!u! \n",
                    dwError );
                break;
            }

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"SetDiskInfoThread: Wait again for event or timeout, count %1!u! \n",
                idx );

        } else {

            //
            // The terminate event is possibly set.
            //

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_WARNING,
                L"SetDiskInfoThread: WaitForSingleObject returned error = %1!u! \n",
                dwError );
            break;
        }
    }

    //
    // Thread ending, clear the flag.
    //

    InterlockedExchange( &DiskInfoUpdateThreadIsActive, 0 );

    return(ERROR_SUCCESS);

}   // SetDiskInfoThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\newdisks.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    newdisks.c

Abstract:

    Some of the functions that used to be
    in disks.c reside now here

Author:

    Gor Nishanov (GorN) 31-July-1998

Revision History:

--*/

#include "disksp.h"
#include "partmgrp.h"

#include "arbitrat.h"
#include "newdisks.h"
#include "newmount.h"
#include "mountmgr.h"
#include <strsafe.h>    // Should be included last.

#define LOG_CURRENT_MODULE LOG_MODULE_DISK


DWORD
WaitForVolumes(
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  timeOutInSeconds
    );

DWORD
DiskspCheckPathLite(
    IN LPWSTR VolumeName,
    IN PDISK_RESOURCE ResourceEntry
    );

NTSTATUS
ForcePnpVolChangeEvent(
    PWSTR RootPath
    );

DWORD
DiskCleanup(
    PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Stops the reservations, dismount drive and frees DiskCpInfo

Arguments:

    ResourceEntry - the disk info structure for the disk.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status = ERROR_SUCCESS;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"DiskCleanup started.\n");

    StopPersistentReservations(ResourceEntry);
    //
    // If the remaining data in the resource entry is not valid, then leave
    // now.
    //
    if ( !ResourceEntry->Valid ) {
        goto FnExit;
    }

    //
    // Delete the DiskCpInfo.
    //
    if ( ResourceEntry->DiskCpInfo ) {
        LocalFree(ResourceEntry->DiskCpInfo);
        ResourceEntry->DiskCpInfo = NULL;
        ResourceEntry->DiskCpSize = 0;
    }

    ResourceEntry->Attached = FALSE;
    ResourceEntry->Valid = FALSE;

    //
    // Remove the Dos Drive Letters, this is better done here rather than
    // in ClusDisk.
    //
    DisksDismountDrive( ResourceEntry,
                        ResourceEntry->DiskInfo.Params.Signature );

FnExit:

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"DiskCleanup returning final error %1!u! \n",
        status );

    return(status);
} // DiskCleanup

static
DWORD
DisksSetDiskInfoThread(
    LPVOID lpThreadParameter
    )

/*++

Routine Description:

    Registry update thread.

Arguments:

    lpThreadParameter - stores ResourceEntry.

Return Value:

    None

--*/

{
    DWORD Status;
    PDISK_RESOURCE ResourceEntry = lpThreadParameter;
    DWORD i;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Checkpoint thread started.\n");
    //
    // Will die in 10 minutes if unsuccessful
    //
    for(i = 0; i < 300; ++i) {
        //
        // Wait for either the terminate event or the timeout
        //
        Status = WaitForSingleObject( DisksTerminateEvent, 2000 );
        if (Status == WAIT_TIMEOUT ) {
            Status = MountieUpdate(&ResourceEntry->MountieInfo, ResourceEntry);
            if ( Status == ERROR_SUCCESS ) {
                // We're done
                break;
            } else if ( Status != ERROR_SHARING_PAUSED ) {
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Watcher Failed to checkpoint disk info, status = %1!u!.\n", Status );
                break;
            }
        } else {
           (DiskpLogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_INFORMATION,
               L"CheckpointThread: WaitForSingleObject returned status = %1!u!.\n", Status );
           break;
        }
    }

    InterlockedExchange(
      &ResourceEntry->MountieInfo.UpdateThreadIsActive, 0);
    return(ERROR_SUCCESS);

} // DisksSetDiskInfoThread



DWORD
DisksOfflineOrTerminate(
    IN PDISK_RESOURCE resourceEntry,
    IN BOOL Terminate
    )
/*++

Routine Description:

    Used by DisksOffline and DisksTerminate.

    Routine performs the following steps:

      1. ClusWorkerTerminate (Terminate only)

      2. Then for all of the partitions on the drive...

         a. Flush the file buffers.                                        (Offline only)
         b. Lock the volume to purge all in memory contents of the volume. (Offline only)
         c. Dismount the volume

      3. Removes default network shares (C$, F$, etc)


Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

    Terminate     - Set it to TRUE to cause Termination Behavior


Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    PWCHAR WideName = (Terminate)?L"Terminate":L"Offline";

    PHANDLE handleArray = NULL;

    BOOL   Offline  = !Terminate;
    DWORD status;
    DWORD idx;
    DWORD PartitionCount;
    DWORD handleArraySize;

    HANDLE fileHandle;
    DWORD  bytesReturned;
    WCHAR  szDiskPartName[MAX_PATH];
    NTSTATUS ntStatus;

    ACCESS_MASK access = SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA;

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"%1!ws!, ResourceEntry @ %2!p!  Valid %3!x! \n",
        WideName,
        resourceEntry,
        resourceEntry->Valid );

    if (Terminate) {
        access = SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES;
        ClusWorkerTerminate(&resourceEntry->OnlineThread);
    }

    StopWatchingDisk(resourceEntry);

    //
    // If the disk info is not valid, then don't use it!
    //
    if ( !resourceEntry->Valid ) {
        DiskCleanup( resourceEntry );
        return(ERROR_SUCCESS);
    }

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"%1!ws!, Processing disk number %2!u!.\n",
        WideName,
        resourceEntry->DiskInfo.PhysicalDrive );

#if 0
    if( Offline ) {
        //
        // Checkpoint our registry state
        //
    }
#endif

    PartitionCount = MountiePartitionCount(&resourceEntry->MountieInfo);

    //
    // Allocate a buffer to hold handle for each partition.  Since the
    // lock is released as soon as we call CloseHandle, we need to save all
    // the handles and close them after the disk is marked offline by
    // DiskCleanup.  If we cannot allocate the storage for the handle
    // array, we will fall back to the previous behavior.
    //

    handleArraySize = PartitionCount * sizeof(HANDLE);
    handleArray = LocalAlloc( LPTR, handleArraySize );

    if ( !handleArray ) {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_WARNING,
            L"%1!ws!, Unable to allocate storage for handle array, error %2!u!.\n",
            WideName,
            GetLastError() );
    } else {
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"%1!ws!, Using handle array. \n",
            WideName );
    }

    //
    // For all of the partitions on the drive...
    //
    // 1. Flush the file buffers.                                        (Offline only)
    // 2. Lock the volume to purge all in memory contents of the volume. (Offline only)
    // 3. Dismount the volume
    //

    for ( idx = 0; idx < PartitionCount; ++idx ) {
        PMOUNTIE_PARTITION partition = MountiePartition(&resourceEntry->MountieInfo, idx);

        (VOID) StringCchPrintf( szDiskPartName,
                                RTL_NUMBER_OF( szDiskPartName),
                                DEVICE_HARDDISK_PARTITION_FMT,
                                resourceEntry->DiskInfo.PhysicalDrive,
                                partition->PartitionNumber );

        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"%1!ws!, Opening device %2!ws!.\n",
            WideName,
            szDiskPartName );

        ntStatus = DevfileOpenEx( &fileHandle, szDiskPartName, access );
        if ( !NT_SUCCESS(ntStatus) ) {
            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%1!ws!, error opening %2!ws!, error %3!X!.\n",
                WideName, szDiskPartName, ntStatus );

            //
            // For terminate, we can't do anything else but try the next
            // partition.
            //

            if ( Terminate ) {
                continue;
            }

            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"%1!ws!, Opening %2!ws! with restricted access.\n",
                WideName, szDiskPartName );

            //
            // If creating the device handle failed for offline, try opening
            // the device once more with the restricted attributes.
            //

            access = SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES;

            ntStatus = DevfileOpenEx( &fileHandle, szDiskPartName, access );

            //
            // If this still fails, then try the next partition.
            //

            if ( !NT_SUCCESS(ntStatus) ) {
                (DiskpLogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"%1!ws!, error opening %2!ws! (restricted access), error %3!X!.\n",
                    WideName, szDiskPartName, ntStatus );

                continue;
            }

            //
            // Offline: created handle with restricted attributes.
            // Fall through and try to flush everything...
            //

        }

        //
        // Save the current partition handle and close it after the device has been
        // marked offline.
        //

        if ( handleArray ) {
            handleArray[idx] = fileHandle;
        }

        if (Offline) {
            DWORD retryCount;
            //
            // Flush file buffers
            //

            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"%1!ws!, FlushFileBuffers for %2!ws!.\n",
                WideName,
                szDiskPartName );

            if ( !FlushFileBuffers( fileHandle ) ) {
                (DiskpLogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"%1!ws!, error flushing file buffers on device %2!ws!. Error: %3!u!.\n",
                    WideName, szDiskPartName, GetLastError() );

                //
                // If FlushFileBuffers fails, we should still try locking
                // and dismounting the volume.
                //
                // Fall through...
            }

            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"%1!ws!, Locking volume for %2!ws!.\n",
                WideName,
                szDiskPartName );

            //
            // Lock the volume, try this twice
            //
            retryCount = 0;
            while ( ( retryCount < 2 ) &&
                !DeviceIoControl( fileHandle,
                                  FSCTL_LOCK_VOLUME,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &bytesReturned,
                                  NULL ) ) {

                (DiskpLogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"%1!ws!, Locking volume failed, error %2!u!.\n",
                    WideName,
                    GetLastError() );

                retryCount++;
                Sleep(600);
            }
        }

        //
        // Now Dismount the volume.
        //
        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"%1!ws!, Dismounting volume %2!ws!.\n", WideName, szDiskPartName);

        if ( !DeviceIoControl( fileHandle,
                               FSCTL_DISMOUNT_VOLUME,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               NULL ) ) {
            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_WARNING,
                L"%1!ws!, error dismounting volume %2!ws!. Error %3!u!.\n",
                WideName, szDiskPartName, GetLastError() );
        }

        (DiskpLogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"%1!ws!, Dismount complete, volume %2!ws!.\n", WideName, szDiskPartName);

        //
        // Close the handle only if we couldn't allocate the handle array.
        //

        if ( !handleArray ) {
            (DiskpLogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"%1!ws!, No handle array, closing device %2!ws!.\n",
                WideName,
                szDiskPartName );

            DevfileClose( fileHandle );
            fileHandle = INVALID_HANDLE_VALUE;
        }
    }

    //
    // Take this resource off the 'online' list.
    //
    EnterCriticalSection( &DisksLock );
    if ( resourceEntry->Inserted ) {
        RemoveEntryList( &resourceEntry->ListEntry );
        resourceEntry->Inserted = FALSE;
        if ( IsListEmpty( &DisksListHead ) ) {
            //
            // Fire Disk Terminate Event
            //
            SetEvent( DisksTerminateEvent ) ;
            CloseHandle( DisksTerminateEvent );
            DisksTerminateEvent = NULL;
        }
    }
    LeaveCriticalSection( &DisksLock );

    status = ERROR_SUCCESS;

    DiskCleanup( resourceEntry );

    //
    // If we have the handle array, close the handles to all the partitions.  This
    // is done after DiskCleanup sets the disk state to offline.  Issuing the lock
    // and keeping the handle open will prevent new mounts on the partition.
    //

    if ( handleArray ) {

        for ( idx = 0; idx < PartitionCount; idx++ ) {
            if ( handleArray[idx] ) {
                DevfileClose( handleArray[idx] );
            }
        }

        LocalFree( handleArray );
    }

    resourceEntry->Valid = FALSE;

    (DiskpLogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"%1!ws!, Returning final error %2!u!.\n",
        WideName,
        status );

    return(status);

} // DisksOfflineOrTerminate


DWORD
DisksOnlineThread(
    IN PCLUS_WORKER Worker,
    IN PDISK_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the cluster worker context

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD       status = ERROR_INVALID_PARAMETER;
    HANDLE      fileHandle = NULL;
    HANDLE      event = NULL;
    RESOURCE_STATUS resourceStatus;
    BOOL        success;
    DWORD       bytesReturned;
    UINT        i, nRetries;
    HANDLE      MountManager = 0;
    DWORD       ntStatus;
    BOOL        autoMountDisabled;
    MOUNTMGR_QUERY_AUTO_MOUNT   queryAutoMount;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    //
    // Check if we've been here before... without offline/terminate
    //
    if ( ResourceEntry->Inserted ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, resource is already in online list! Skip this online request.\n");
        goto exit;
    }

    ResourceEntry->DiskInfo.FailStatus = 0;

    status = DisksOpenResourceFileHandle(ResourceEntry, L"Online", &fileHandle);
    if (status != ERROR_SUCCESS) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Online, DisksOpenResourceFileHandle failed. Error: %1!u!\n", status);
       goto exit;
    }

    if( !ReservationInProgress(ResourceEntry) ) { // [GN] 209018 //
#if DBG
        (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_WARNING,
           L"DiskArbitration must be called before DisksOnline.\n");
#endif
// [GN] We can steal the disk while regular arbitration is in progress in another thread //
//      We have to do a regular arbitration, no shortcuts as the one below
//       status = StartPersistentReservations(ResourceEntry, fileHandle);
//       if ( status != ERROR_SUCCESS ) {
          status = DiskArbitration( ResourceEntry, DiskspClusDiskZero );
//       }
       if ( status != ERROR_SUCCESS ) {
           (DiskpLogEvent)(
               ResourceEntry->ResourceHandle,
               LOG_ERROR,
               L"Online, arbitration failed. Error: %1!u!.\n",
               status );
           status = ERROR_RESOURCE_NOT_AVAILABLE;
           goto exit;
       }
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, Wait for async cleanup worker thread in ClusDisk to complete. \n");

    //
    // Synchronize with async cleanup worker
    //
    {
        ULONG waitTimeInSeconds = 10;
        status = DevfileIoctl( fileHandle,
                               IOCTL_DISK_CLUSTER_WAIT_FOR_CLEANUP,
                               &waitTimeInSeconds, sizeof(waitTimeInSeconds),
                               NULL, 0,
                               &bytesReturned );
        if ( !NT_SUCCESS(status) ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Online, WaitForCleanup returned. Status: 0x%1!x!.\n",
                status );
            status = RtlNtStatusToDosError( status );
            goto exit;
        }
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, Send Offline IOCTL to all existing volumes, then Online IOCTL. \n");

    //
    // Volume snapshots require us to make sure everything is offline first.
    // Ignore the returned status.
    //

    GoOffline( ResourceEntry );

    //
    // Bring the device online.
    // we have to do this here for PartMgr poke to succeed.
    //
    status = GoOnline( ResourceEntry );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, error bringing device online. Error: %1!u!.\n",
            status );
        goto exit;
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, Recreate volume information from cluster database. \n");

    //
    // Create volume information
    //
    status = MountieRecreateVolumeInfoFromHandle(fileHandle,
                                     ResourceEntry->DiskInfo.PhysicalDrive,
                                     ResourceEntry->ResourceHandle,
                                     &ResourceEntry->MountieInfo);
    if (status != ERROR_SUCCESS) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Online, MountieCreateFromHandle failed. Error: %1!u!\n", status);
       goto exit;
    }

    //
    // Check that the cached signature is the same as the signature on the disk.
    // They can be different if the disk fails and the user replaces the failed
    // disk with a new disk having a different disk signature.  If the user doesn't
    // change the signature of the new disk to be the same as the original disk,
    // and doesn't reboot or reinstall the disk (uninstall via devmgmt and rescan
    // via diskmgmt), then the disk will try to come online using the old signature.
    // Either online will succeed, or pnp will say the volume doesn't come online.
    // We don't want online to succeed because if the disk fails to another node,
    // it will likely fail when DoAttach is called (if disk wasn't ever online to
    // the other node).  If the disk was previously online, then we didn't previously
    // verify the cached signature in DiskInfo.Params matches the disk, so now we
    // make that check.
    //

    if ( ResourceEntry->DiskInfo.Params.Signature &&
         ResourceEntry->DiskInfo.Params.Signature != ResourceEntry->MountieInfo.Volume->Signature ) {

        WCHAR sigStr[10];

        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, Cluster DB signature %1!lX! does not match PhysicalDrive%2!u! signature %3!lX!\n",
            ResourceEntry->DiskInfo.Params.Signature,
            ResourceEntry->DiskInfo.PhysicalDrive,
            ResourceEntry->MountieInfo.Volume->Signature );

        if ( SUCCEEDED( StringCchPrintf( sigStr,
                                         RTL_NUMBER_OF(sigStr),
                                         TEXT("%08lX"),
                                         ResourceEntry->DiskInfo.Params.Signature ) ) ) {
            ClusResLogSystemEventByKey1(ResourceEntry->ResourceKey,
                                        LOG_CRITICAL,
                                        RES_DISK_MISSING,
                                        sigStr);
        }

        status = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    //
    // Now poke partition manager
    //
    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, Ask partition manager to create volumes for any new partitions. \n");

    success = DeviceIoControl( fileHandle,
                               IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    if (!success) {
        status = GetLastError();
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, Partmgr failed to claim all partitions. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Before attempting to access the device, close our open handles.
    //
    CloseHandle( fileHandle );
    fileHandle = NULL;

    ntStatus = DevfileOpen(&MountManager, MOUNTMGR_DEVICE_NAME);
    if (!NT_SUCCESS(ntStatus)) {
       status = RtlNtStatusToDosError(ntStatus);
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Online, MountMgr open failed. Error: %1!u!.\n", status);
        goto exit;
    }

    resourceStatus.ResourceState = ClusterResourceOnlinePending;

    //
    // Find out if volume auto mount is enabled or disabled.
    //

    if ( !DeviceIoControl( MountManager,
                           IOCTL_MOUNTMGR_QUERY_AUTO_MOUNT,
                           NULL,
                           0,
                           &queryAutoMount,
                           sizeof (queryAutoMount),
                           &bytesReturned,
                           NULL )) {

        status = GetLastError();
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"Online, MountMgr unable to return automount status - assume automount disabled. Error: %1!u!.\n",
            status );

        autoMountDisabled = TRUE;

    } else {
        autoMountDisabled = (Disabled == queryAutoMount.CurrentState);
    }


    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, volume auto-mount is %1!ws! \n",
        autoMountDisabled ? L"disabled" : L"enabled" );

    // we will wait not more than 48 seconds per partition
    nRetries = 24 * ResourceEntry->MountieInfo.Volume->PartitionCount;
    // Don't wait for longer than 10 minutes total time //
    if (nRetries > 300) {
        nRetries = 300;
    }

    __try {

        // We cannot call VolumesReady because pnp might be adding this device
        // the same time we are trying to get the volume name.  We must wait
        // for the volume to show up in the pnp list.
        //
        // Check the PnP thread's volume list to see if the volume arrived.
        // If not in the list, fall through and wait for the event to be
        // signaled.
        //
        // First time through the list, don't update the volume list as this
        // can be time consuming.
        //

        if ( IsDiskInPnpVolumeList( ResourceEntry, FALSE ) ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, disk found in PnP volume list on first attempt \n");

            //
            // VolumesReady should work now.  If not, there is some other problem.
            //

            status = VolumesReadyLoop(&ResourceEntry->MountieInfo, ResourceEntry);

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, VolumesReady returns: %1!u!.  PnP informs us that all volumes exist. \n",
                status );

            __leave;
        }

        //
        // Create event for waiting.
        //

        event = CreateEvent( NULL,      // security attributes
                             TRUE,      // manual reset
                             FALSE,     // initial state: nonsignaled
                             NULL );    // object name

        if ( !event ) {
            status = GetLastError();
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Online, Failed to create event for PnP notification. Error: %1!u!.\n",
                status );
            __leave;
        }

        //
        // Tell our PnP code we are waiting for this disk.
        //

        status = QueueWaitForVolumeEvent( event,
                                          ResourceEntry );

        if ( ERROR_SUCCESS != status ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Online, Failed to create event for PnP notification. Error: %1!u!.\n",
                status );
            __leave;
        }

        resourceStatus.CheckPoint += 1;
        (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                 &resourceStatus );

        for (i = 0; i < nRetries; ++i) {

            //
            // Make sure we aren't terminated.  We don't need to wait for pnp
            // in this case.
            //

            if ( ResourceEntry->OnlineThread.Terminate ) {
                status = ERROR_SHUTDOWN_CLUSTER;
                __leave;
            }

            //
            // Ask mountmgr to process volumes.
            //

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, call MountMgr to check for new, unprocessed volumes.\n");
            success = DeviceIoControl( MountManager,
                                       IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES,
                                       NULL,
                                       0,
                                       NULL,
                                       0,
                                       &bytesReturned,
                                       FALSE );

            if ( !success ) {
                status = GetLastError();
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"Online, MountMgr failed to check unprocessed volumes. Error: %1!u!.\n",
                    status );

                // The call to the mountmgr can return an error if there are
                // disks reserved by another node.  Fall through...

            }

            //
            // Wait for event signal or timeout.  We wait only 2 seconds
            // at a time so we can update the checkpoint.
            //

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, waiting for notification from PnP thread that all volumes exist...\n");

            status = WaitForSingleObject( event,
                                          2000 );

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, wait for PnP notification returns %1!u!. \n", status );

            if ( WAIT_OBJECT_0 == status ) {

                //
                // Event was signaled, try VolumesReady one more time.
                // This should work or there is a more serious problem.

                status = VolumesReadyLoop(&ResourceEntry->MountieInfo, ResourceEntry);
                __leave;
            }

            if ( WAIT_TIMEOUT != status ) {
                status = GetLastError();
                __leave;
            }

            //
            // Force a check in the PnP thread's volume list in
            // case we somehow missed the volume arrival.  If all
            // volumes are available for this disk, we are done
            // waiting.
            //

            if ( IsDiskInPnpVolumeList( ResourceEntry, TRUE ) ) {
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Online, disk found in PnP volume list - all volumes exist. \n");

                //
                // VolumesReady should work now.  If not, there is some other problem.
                //

                status = VolumesReadyLoop(&ResourceEntry->MountieInfo, ResourceEntry);
                __leave;
            }


            resourceStatus.CheckPoint += 1;
            (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                                     &resourceStatus );

            //
            // If auto mount is disabled in mountmgr, the volumes will
            // arrive from pnp in offline state.  In order for our pnp
            // thread to read the drive layout, we have to make sure
            // they are online.  If we online the physical disk, the
            // volumes associated with this disk will also be brought
            // online.
            //
            // Only do the clusdisk online after waiting for a "reasonable"
            // period of time.  If we send online to clusdisk, then there is
            // a chance the volume may be just arriving via pnp and then
            // the volume might be marked as requiring a reboot.  We are
            // going to wait for at least 6 seconds, and every 6 seconds
            // we will try another clusdisk online request.
            //

            //
            // Remove the check for autoMountDisabled.  Now send the volume
            // offline and volume online after a "reasonable" time has passed.
            //

            if ( i && ( i % 3 == 0 ) ) {

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Online, send IOCTL to mark all volumes online.\n" );

                GoOffline( ResourceEntry );
                status = GoOnline( ResourceEntry );
                if ( status != ERROR_SUCCESS ) {
                    (DiskpLogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_WARNING,
                        L"Online, error bringing device online. Error: %1!u!.\n",
                        status );
                    status = ERROR_SUCCESS;
                }
            }

        }

    } __finally {

        //
        // Tell our PnP code that we are no longer waiting.  Not a
        // problem if we never queued the request previously.
        //

        RemoveWaitForVolumeEvent( ResourceEntry );

        if ( event ) {
            CloseHandle( event );
        }
    }

    DevfileClose(MountManager);
    resourceStatus.ResourceState = ClusterResourceFailed;

    if (status != ERROR_SUCCESS) {
       (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, volumes not ready. Error: %1!u!.\n",
            status );
       goto exit;
    }

   (DiskpLogEvent)(
       ResourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"Online, all volumes for this disk exist.\n");

    //
    // Need to synchronize with ClusDisk by issuing
    // IOCTL_CLUSTER_VOLUME_TEST on all partitions
    //
    // Need to read volume type. If it is RAW, we need to
    // dismount and mount it again as a workaround for 389861
    //

    resourceStatus.ResourceState = ClusterResourceOnline;
    ResourceEntry->Valid = TRUE;

    //
    // Start the registry notification thread, if needed.
    //
    EnterCriticalSection( &DisksLock );

    if ( IsListEmpty( &DisksListHead ) ) {
        DisksTerminateEvent = CreateEventW( NULL,
                                            TRUE,
                                            FALSE,
                                            NULL );
        if ( DisksTerminateEvent == NULL ) {
            status = GetLastError();
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Online, error %1!d! creating registry thread terminate event\n",
                status);
            LeaveCriticalSection( &DisksLock );
            goto exit;
        }
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Online, created registry thread terminate event \n");
    }

    ResourceEntry->Inserted = TRUE;
    InsertTailList( &DisksListHead, &ResourceEntry->ListEntry );
    LeaveCriticalSection( &DisksLock );

    DiskspSsyncDiskInfo(L"Online", ResourceEntry, MOUNTIE_VALID | MOUNTIE_THREAD );

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, Wait for all volume GUIDs and drive letters to be accessible and mounted. \n");

    status = WaitForVolumes( ResourceEntry,
                             30 // seconds timeout //
                             );

    //
    // We cannot just check for NO_ERROR status.  The problem is that WaitForVolumes
    // calls GetFileAttributes, which can return ERROR_DISK_CORRUPT (1393).  If the
    // disk is corrupt, we should fall through and let chkdsk try to clean it up.
    // We should also do this if ERROR_FILE_CORRUPT (1392) is returned  (haven't
    // yet seen file corrupt error returned from GetFileAttributes, but one never knows).
    //

    if ( NO_ERROR != status && ERROR_DISK_CORRUPT != status && ERROR_FILE_CORRUPT != status ) {
        ClusResLogSystemEventByKey( ResourceEntry->ResourceKey,
                                    LOG_CRITICAL,
                                    RES_DISK_MOUNT_FAILED );
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, error waiting for file system to mount. Error: %1!u!.\n",
            status );
        resourceStatus.ResourceState = ClusterResourceFailed;
        ResourceEntry->Valid = FALSE;

        EnterCriticalSection( &DisksLock );
        CL_ASSERT ( ResourceEntry->Inserted );
        ResourceEntry->Inserted = FALSE;
        RemoveEntryList( &ResourceEntry->ListEntry );
        if ( IsListEmpty( &DisksListHead ) ) {
            //
            // Fire Disk Terminate Event
            //
            SetEvent( DisksTerminateEvent ) ;
            CloseHandle( DisksTerminateEvent );
            DisksTerminateEvent = NULL;
        }
        LeaveCriticalSection( &DisksLock );
        goto exit;
    }

    status = DisksMountDrives( &ResourceEntry->DiskInfo,
                               ResourceEntry,
                               ResourceEntry->DiskInfo.Params.Signature );

    if ( status != ERROR_SUCCESS ) {
        ClusResLogSystemEventByKey( ResourceEntry->ResourceKey,
                                    LOG_CRITICAL,
                                    RES_DISK_MOUNT_FAILED );
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online, error mounting disk or creating share names for disk. Error: %1!u!.\n",
            status );
        resourceStatus.ResourceState = ClusterResourceFailed;
        ResourceEntry->Valid = FALSE;

        EnterCriticalSection( &DisksLock );
        CL_ASSERT ( ResourceEntry->Inserted );
        ResourceEntry->Inserted = FALSE;
        RemoveEntryList( &ResourceEntry->ListEntry );
        if ( IsListEmpty( &DisksListHead ) ) {
            //
            // Fire Disk Terminate Event
            //
            SetEvent( DisksTerminateEvent ) ;
            CloseHandle( DisksTerminateEvent );
            DisksTerminateEvent = NULL;
        }
        LeaveCriticalSection( &DisksLock );
    }

    if ( ERROR_SUCCESS == status ) {

        LPWSTR newSerialNumber = NULL;
        DWORD newSerNumLen = 0;
        DWORD oldSerNumLen = 0;
        WCHAR deviceName[64];

        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Online, Insure mount point information is correct.\n" );

        DisksProcessMountPointInfo( ResourceEntry );

        (VOID) StringCchPrintf( deviceName,
                                RTL_NUMBER_OF( deviceName ),
                                TEXT("\\\\.\\PhysicalDrive%d"),
                                ResourceEntry->DiskInfo.PhysicalDrive );

        fileHandle = CreateFile( deviceName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL );
        if ( INVALID_HANDLE_VALUE == fileHandle ||
             NULL == fileHandle ) {
            status = GetLastError();

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Online, error opening disk to retrieve serial number. Error: %1!u!.\n",
                status );

        } else {

            // Retrieve and validate serial number.

            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Online, Retrieve and validate the disk serial number.\n" );

            status = RetrieveSerialNumber( fileHandle,
                                           &newSerialNumber );

            CloseHandle( fileHandle );
            fileHandle = NULL;

            if ( NO_ERROR == status && newSerialNumber ) {
                newSerNumLen = wcslen( newSerialNumber );

                if ( ResourceEntry->DiskInfo.Params.SerialNumber ) {
                    oldSerNumLen = wcslen( ResourceEntry->DiskInfo.Params.SerialNumber );
                }

                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Online, Old SerNum (%1!ws!)   Old SerNumLen (%2!d!) \n",
                    ResourceEntry->DiskInfo.Params.SerialNumber,
                    oldSerNumLen
                    );
                (DiskpLogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Online, New SerNum (%1!ws!)   New SerNumLen (%2!d!) \n",
                    newSerialNumber,
                    newSerNumLen
                    );

                if ( 0 == oldSerNumLen ||
                     NULL == ResourceEntry->DiskInfo.Params.SerialNumber ||
                     newSerNumLen != oldSerNumLen ||
                     ( 0 != wcsncmp( ResourceEntry->DiskInfo.Params.SerialNumber,
                                   newSerialNumber,
                                   newSerNumLen ) ) ) {

                    // Need to log an error?

                    (DiskpLogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_WARNING,
                        L"Online, disk serial number has changed.  Saving new serial number.\n" );

                    // Free existing serial number and update serial number.

                    if ( ResourceEntry->DiskInfo.Params.SerialNumber ) {
                        LocalFree( ResourceEntry->DiskInfo.Params.SerialNumber );
                    }

                    ResourceEntry->DiskInfo.Params.SerialNumber = newSerialNumber;
                    newSerialNumber = NULL;

                    // User MP thread to post info into registry.

                    PostMPInfoIntoRegistry( ResourceEntry );
                }
            }
        }

        if ( newSerialNumber ) {
            LocalFree( newSerialNumber );
        }

        // Reset status to success so online completes.

        status = ERROR_SUCCESS;
    }

exit:

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, setting ResourceState %1!u! .\n",
        resourceStatus.ResourceState );

    (DiskpSetResourceStatus)(ResourceEntry->ResourceHandle,
                             &resourceStatus );

    if ( fileHandle != NULL)  {
        CloseHandle( fileHandle );
    }

    if (status == ERROR_SUCCESS) {
        WatchDisk(ResourceEntry);
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online, returning final error %1!u!   ResourceState %2!u!  Valid %3!x! \n",
        status,
        resourceStatus.ResourceState,
        ResourceEntry->Valid );

    return(status);

} // DisksOnlineThread


DWORD
DisksOpenResourceFileHandle(
    IN PDISK_RESOURCE ResourceEntry,
    IN PWCHAR         InfoString,
    OUT PHANDLE       fileHandle OPTIONAL
    )
/*++

Routine Description:

    Open a file handle for the resource.
    It performs the following steps:
      1. Read Disk signature from cluster registry
      2. Attaches clusdisk driver to a disk with this signature
      3. Gets Harddrive no from ClusDisk driver
      4. Opens \\.\PhysicalDrive%d device and returns the handle

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

    InfoString - Supplies a label to be printed with error messages

    fileHandle - receives file handle


Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    DWORD       status;
    WCHAR       deviceName[MAX_PATH];
    HKEY        signatureKey = NULL;
    PWCHAR      diskName;
    DWORD       count;
    LPWSTR      nameOfPropInError;
    WCHAR       resourceString[MAX_PATH];

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb]------- Disks%1!ws! -------.\n", InfoString);

    //
    // Read our disk signature from the resource parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ResourceParametersKey,
                                                   DiskResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->DiskInfo.Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"%3!ws!: Unable to read the '%1' property from cluster database. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status, InfoString );
        return(status);
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] DisksOpenResourceFileHandle: Attaching to disk with signature %1!x! \n",
        ResourceEntry->DiskInfo.Params.Signature
        );

    //
    // Try to attach to this device.
    //
    status = DoAttach( ResourceEntry->DiskInfo.Params.Signature,
                       ResourceEntry->ResourceHandle,
                       FALSE );                         // Offline, then dismount
    if ( status != ERROR_SUCCESS ) {
        WCHAR Signature[9];
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"%3!ws!: Unable to attach to signature %1!lx!. Error: %2!u!.\n",
            ResourceEntry->DiskInfo.Params.Signature,
            status, InfoString );

        // Added this event message back in as replication has been changed (regroup
        // shouldn't be blocked now).

        if ( SUCCEEDED( StringCchPrintf( Signature,
                                         RTL_NUMBER_OF(Signature),
                                         TEXT("%08lX"),
                                         ResourceEntry->DiskInfo.Params.Signature ) ) ) {
            ClusResLogSystemEventByKey1(ResourceEntry->ResourceKey,
                                        LOG_CRITICAL,
                                        RES_DISK_MISSING,
                                        Signature);
        }

        return(status);
    }

    //
    // Now open the signature key under ClusDisk.
    //

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] DisksOpenResourceFileHandle: Retrieving disk number from ClusDisk registry key \n" );

    if ( FAILED( StringCchPrintf( resourceString,
                                  RTL_NUMBER_OF(resourceString),
                                  TEXT("%08lX"),
                                  ResourceEntry->DiskInfo.Params.Signature ) ) ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    status = RegOpenKeyEx( ResourceEntry->ClusDiskParametersKey,
                           resourceString,
                           0,
                           KEY_READ,
                           &signatureKey );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"%3!ws!: Unable to open ClusDisk signature key %1!lx!. Error: %2!u!.\n",
            ResourceEntry->DiskInfo.Params.Signature,
            status, InfoString );
            return(status);
    }

    //
    // Read our disk name from ClusDisk.
    //

    diskName = GetRegParameter(signatureKey, L"DiskName");

    RegCloseKey( signatureKey );

    if ( diskName == NULL ) {
        (DiskpLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"%1!ws!: Unable to read disk name.\n", InfoString );
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Parse disk name to find disk drive number.
    //
    count = swscanf( diskName, DEVICE_HARDDISK, &ResourceEntry->DiskInfo.PhysicalDrive );
    // count is zero if failed! Otherwise count of parsed values.

    LocalFree(diskName);

    if (count == 0) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"%1!ws!: Unable to parse disk name.\n", InfoString );
       return ERROR_INVALID_PARAMETER;
    }
    //
    // Build device string for CreateFile
    //

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] DisksOpenResourceFileHandle: Retrieving handle to PhysicalDrive%1!u! \n",
        ResourceEntry->DiskInfo.PhysicalDrive );

    if ( fileHandle ) {
        (VOID) StringCchPrintf( deviceName,
                                RTL_NUMBER_OF( deviceName ),
                                TEXT("\\\\.\\PhysicalDrive%d"),
                                ResourceEntry->DiskInfo.PhysicalDrive );

        *fileHandle = CreateFile( deviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL );
        if ( (*fileHandle == INVALID_HANDLE_VALUE) ||
             (*fileHandle == NULL) ) {
            status = GetLastError();
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%3!ws!: error opening device '%1!ws!'. Error: %2!u!\n",
                deviceName,
                status, InfoString );
            return(status);
        }
    }

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"[DiskArb] DisksOpenResourceFileHandle: Returns success.\n" );

    return(ERROR_SUCCESS);
} // DisksOpenResourceFileHandle



DWORD
DiskspSsyncDiskInfo(
    IN PWCHAR InfoLabel,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  Options
    )
/*++

Routine Description:

    Restores the disk registry information
    if necessary.

Arguments:

    InfoLabel - Supplies a label to be printed with error messages

    ResourceEntry - Supplies the disk resource structure.

    Options - 0 or combination of the following:

        MOUNTIE_VALID: ResourceEntry contains up to date MountieInfo.
                       If this flag is not set, MountieInfo will be recomputed

        MOUNTIE_THREAD: If ERROR_SHARING_PAUSED prevents updating cluster registry,
                        launch a thread to do it later

        MOUNTIE_QUIET: Quiet mode. Less noise in logs.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
   DWORD status;
   DWORD errorLevel;

    (DiskpLogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"%1!ws!: Update disk registry information. \n",
        InfoLabel );

   if ( !(Options & MOUNTIE_VALID) ) {
      HANDLE fileHandle;
      status = DisksOpenResourceFileHandle(ResourceEntry, InfoLabel, &fileHandle);
      if (status != ERROR_SUCCESS) {
         return status;
      }
      status = MountieRecreateVolumeInfoFromHandle(fileHandle,
                                       ResourceEntry->DiskInfo.PhysicalDrive,
                                       ResourceEntry->ResourceHandle,
                                       &ResourceEntry->MountieInfo);
      CloseHandle(fileHandle);
      if (status != ERROR_SUCCESS) {
         if ( !(Options & MOUNTIE_QUIET) ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%1!ws!: MountieCreateFromHandle failed, error: %2!u!\n",
                InfoLabel, status );
         }
         return status;
      }
   }

   status = MountieVerify(&ResourceEntry->MountieInfo, ResourceEntry, FALSE);
   if (status != ERROR_SUCCESS) {
      if ( !(Options & MOUNTIE_QUIET) ) {

         if ( !DisksGetLettersForSignature( ResourceEntry ) ) {
             // No drive letters, we are using mount points and this is not an error.
             errorLevel = LOG_WARNING;
         } else {
             // Drive letters exist, this is likely an error.
             errorLevel = LOG_ERROR;
         }

         (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             errorLevel,
             L"%1!ws!: MountieVerify failed, error: %2!u! \n",
             InfoLabel, status );
      }
   }


   status = MountieUpdate(&ResourceEntry->MountieInfo, ResourceEntry);
   if (status != ERROR_SUCCESS) {
      if (status != ERROR_SHARING_PAUSED) {
         if ( !(Options & MOUNTIE_QUIET) ) {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%1!ws!: MountieUpdate failed, error: %2!u!\n",
                InfoLabel, status );
         }
         return status;
      }

      if ( Options & MOUNTIE_THREAD ) {

         if ( InterlockedCompareExchange(
                &ResourceEntry->MountieInfo.UpdateThreadIsActive,
                1, 0)
            )
         {
            (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"%1!ws!: update thread is already running.\n",
                InfoLabel );
            status = ERROR_ALREADY_EXISTS;

         } else {
            HANDLE thread;
            DWORD threadId;


            thread = CreateThread( NULL,
                                   0,
                                   DisksSetDiskInfoThread,
                                   ResourceEntry,
                                   0,
                                   &threadId );
            if ( thread == NULL ) {
                status = GetLastError();
                if ( !(Options & MOUNTIE_QUIET) ) {
                   (DiskpLogEvent)(
                       ResourceEntry->ResourceHandle,
                       LOG_ERROR,
                       L"%1!ws!: CreateThread failed, error: %2!u!\n",
                       InfoLabel, status );
                }
                InterlockedExchange(
                  &ResourceEntry->MountieInfo.UpdateThreadIsActive, 0);
            } else {
               CloseHandle( thread );
               status = ERROR_SUCCESS;
            }
         }

      }
   }

   return status;

} // DiskspSsyncDiskInfo



DWORD
DisksIsVolumeDirty(
    IN PWCHAR         DeviceName,
    IN PDISK_RESOURCE ResourceEntry,
    OUT PBOOL         Dirty
    )
/*++

Routine Description:

    This routine opens the given nt drive and sends down
    FSCTL_IS_VOLUME_DIRTY to determine the state of that volume's
    dirty bit.

Arguments:

    DeviceName      -- name of the form:
                       \Device\HarddiskX\PartitionY    [Note: no trailing backslash]

    Dirty           -- receives TRUE if the dirty bit is set

Return Value:

    dos error code

--*/
{
    DWORD               status;
    NTSTATUS            ntStatus;
    HANDLE              fileHandle;
    DWORD               result = 0;
    DWORD               bytesReturned;

    ntStatus = DevfileOpen( &fileHandle, DeviceName );

    if ( !NT_SUCCESS(ntStatus) ) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"Error opening %1!ws!, error %2!x!.\n",
           DeviceName, ntStatus );
       return RtlNtStatusToDosError(ntStatus);
    }

    status = ERROR_SUCCESS;
    if ( !DeviceIoControl( fileHandle,
                           FSCTL_IS_VOLUME_DIRTY,
                           NULL,
                           0,
                           &result,
                           sizeof(result),
                           &bytesReturned,
                           NULL ) ) {
        status = GetLastError();
        (DiskpLogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"FSCTL_IS_VOLUME_DIRTY for volume %1!ws! returned error %2!u!.\n",
                DeviceName, status );
    }

    DevfileClose( fileHandle );
    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    if (result & VOLUME_IS_DIRTY) {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_INFORMATION,
           L"DisksIsVolumeDirty: Volume is dirty \n");
        *Dirty = TRUE;
    } else {
       (DiskpLogEvent)(
           ResourceEntry->ResourceHandle,
           LOG_INFORMATION,
           L"DisksIsVolumeDirty: Volume is clean \n");
        *Dirty = FALSE;
    }
    return ERROR_SUCCESS;

} // DisksIsVolumeDirty


#define IS_SPECIAL_DIR(x)  ( (x)[0]=='.' && ( (x)[1]==0 || ( (x)[1]=='.'&& (x)[2] == 0) ) )
#define FA_SUPER_HIDDEN    (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)
#define IS_SUPER_HIDDEN(x) ( ((x) & FA_SUPER_HIDDEN) == FA_SUPER_HIDDEN )
#define IS_REPARSE_POINT(x) ( (x) & FILE_ATTRIBUTE_REPARSE_POINT )

#define DISKP_CHECK_PATH_BUF_SIZE (MAX_PATH)

typedef struct _DISKP_CHECK_PATH_DATA {
    WCHAR FileName[DISKP_CHECK_PATH_BUF_SIZE];
    WIN32_FIND_DATAW FindData;
    PDISK_RESOURCE   ResourceEntry;
    BOOL             OpenFiles;
    DWORD            FileCount;
    DWORD            Level;
    BOOL             LogFileNotFound;
} DISKP_CHECK_PATH_DATA, *PDISKP_CHECK_PATH_DATA;


DWORD
DiskspCheckPathInternal(
    IN OUT PDISKP_CHECK_PATH_DATA data,
    IN DWORD FileNameLength
)

/*++

Routine Description:

    Checks out a disk partition to see if the filesystem has mounted
    it and it's working.

Arguments:

    data - Filled in structure for checking the volume.

    FileNameLength - Number of characters (not including trailing NULL) in
                     data->FileName.
                     VolumeGUID names always end in a trailing backslash.

Return Value:

--*/

{
    HANDLE FindHandle;
    DWORD Status;
    DWORD len;
    DWORD adjust;

    if ( FileNameLength < 1 ) {
        return ERROR_INVALID_DATA;
    }

    data->FileName[FileNameLength] = 0;

    //
    // GetFileAttributes must use a trailing slash on the Volume{GUID} name.
    //

    Status = GetFileAttributesW(data->FileName);
    if (Status == 0xFFFFFFFF) {
        Status = GetLastError();
        (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"DiskspCheckPath: GetFileAttrs(%1!s!) returned status of %2!d!.\n",
                        data->FileName,
                        Status);
        return Status;
    }
    Status = ERROR_SUCCESS;

    if ( data->FileName[FileNameLength - 1] == L'\\' ) {

        //
        // If path ends in backslash, simply add the asterisk.
        //

        if ( FileNameLength + 1 >= DISKP_CHECK_PATH_BUF_SIZE ) {
            (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskspCheckPath: FileNameLength > buffer size (#1) \n" );
            return(ERROR_ALLOTTED_SPACE_EXCEEDED);
        }

        data->FileName[FileNameLength + 0] = '*';
        data->FileName[FileNameLength + 1] = 0;

        adjust = 0;

    } else {

        if ( FileNameLength + 2 >= DISKP_CHECK_PATH_BUF_SIZE ) {
            (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskspCheckPath: FileNameLength > buffer size (#2) \n" );
            return(ERROR_ALLOTTED_SPACE_EXCEEDED);
        }

        data->FileName[FileNameLength + 0] = '\\';
        data->FileName[FileNameLength + 1] = '*';
        data->FileName[FileNameLength + 2] = 0;

        adjust = 1;
    }

    FindHandle = FindFirstFileW(data->FileName, &data->FindData);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        if (Status != ERROR_FILE_NOT_FOUND || data->LogFileNotFound) {
            (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                            LOG_WARNING,
                            L"DiskspCheckPath: fff(%1!s!) returned status of %2!d!.\n",
                            data->FileName,
                            Status);
        }
        if (Status == ERROR_FILE_NOT_FOUND) {
            Status = ERROR_EMPTY;
        }
        return Status;
    }

    ++ data->Level;
    ++ data->FileCount;

    if (data->OpenFiles) {
        do {
            if ( data->ResourceEntry->OnlineThread.Terminate ) {
                // Returning SUCCESS means that we've closed all
                // FindFile handles.
                return(ERROR_SHUTDOWN_CLUSTER);
            }
            if ( IS_SPECIAL_DIR(data->FindData.cFileName )
              || IS_SUPER_HIDDEN(data->FindData.dwFileAttributes)
              || IS_REPARSE_POINT( data->FindData.dwFileAttributes ) )
            {
                continue;
            }
            len = wcslen(data->FindData.cFileName);
            if (FileNameLength + len + 1 >= DISKP_CHECK_PATH_BUF_SIZE ) {
                return(ERROR_ALLOTTED_SPACE_EXCEEDED);
            }
            MoveMemory(data->FileName + FileNameLength + adjust,
                       data->FindData.cFileName,
                       sizeof(WCHAR) * (len + 1) );

            if ( data->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                Status = DiskspCheckPathInternal(data, FileNameLength + len + adjust);
                if (Status != ERROR_SUCCESS) {
                    goto exit;
                }
            } else {
                HANDLE FileHandle;
                //
                // Open with the same parameters that LogpCreate uses to try to catch quorum
                // log corruption during online.
                //
                // We previously used OPEN_EXISTING parameter.  Try OPEN_ALWAYS to match exactly what
                // LogpCreate is using.
                //

                FileHandle = CreateFileW(data->FileName,
                                         GENERIC_READ | GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
                                         NULL );
                if ( FileHandle == INVALID_HANDLE_VALUE ) {
                    Status = GetLastError();
                    (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                                        LOG_ERROR,
                                        L"DiskspCheckPath: Open %1!ws! failed, status %2!d!.\n",
                                        data->FileName,
                                        Status
                                        );
                    if (Status != ERROR_SHARING_VIOLATION) {
                        goto exit;
                    }
                } else {

                    (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                                        LOG_INFORMATION,
                                        L"DiskspCheckPath: Open %1!ws! succeeded. \n",
                                        data->FileName
                                        );

                    CloseHandle( FileHandle );
                }
            }
            ++(data->FileCount);
        } while ( FindNextFileW( FindHandle, &data->FindData ) );
        --(data->FileCount);
        Status = GetLastError();
        if (Status != ERROR_NO_MORE_FILES) {
            (DiskpLogEvent)(data->ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"DiskspCheckPath: fnf(%1!s!) returned status of %2!d!.\n",
                            data->FileName,
                            Status);
        } else {
            Status = ERROR_SUCCESS;
        }
    }
exit:
    FindClose(FindHandle);
    --(data->Level);
    return Status;
} // DiskspCheckPathInternal



DWORD
DiskspCheckPath(
    IN LPWSTR VolumeName,
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL OpenFiles,
    IN BOOL LogFileNotFound
    )
/*++

Routine Description:

    Checks out a drive letter to see if the filesystem has mounted
    it and it's working. We will also run CHKDSK if the partition/certain
    files are Corrupt

Arguments:

    VolumeName - Supplies the device name of the form:
                 \\?\Volume{GUID}\    [Note trailing backslash!]

    ResourceEntry - Supplies a pointer to the disk resource entry.

    OpenFiles - Span subdirectories and open files if TRUE.

    Online - FILE_NOT_FOUND error is logged if TRUE

Return Value:

    ERROR_SUCCESS if no corruption or corruption was found and corrected.

    Win32 error code otherwise

--*/

{
    DISKP_CHECK_PATH_DATA data;
    DWORD                 len;
    DWORD                 status;
    ZeroMemory( &data, sizeof(data) );

    data.OpenFiles = OpenFiles;
    data.LogFileNotFound = LogFileNotFound;
    data.ResourceEntry = ResourceEntry;

    len = wcslen( VolumeName );
    if (len >= RTL_NUMBER_OF(data.FileName) - 1 ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"DiskspCheckPath: VolumeName length > buffer size \n" );
        return ERROR_ALLOTTED_SPACE_EXCEEDED;
    }
    if ( FAILED( StringCchCopy( data.FileName,
                                RTL_NUMBER_OF(data.FileName),
                                VolumeName ) ) ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Send the path with trailing backslash to DiskspCheckPathInternal.
    //

    status = DiskspCheckPathInternal( &data, len );
    data.FileName[len] = 0;

    if (status != ERROR_SUCCESS || data.FileCount == 0) {
        if (status != ERROR_EMPTY || data.LogFileNotFound) {
            (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                            LOG_WARNING,
                            L"DiskspCheckPath: DCPI(%1!s!) returned status of %2!d!, files scanned %3!d!.\n",
                            data.FileName, status, data.FileCount);
        }

        if ( (status == ERROR_DISK_CORRUPT) ||
             (status == ERROR_FILE_CORRUPT) )
        {

            if ( ResourceEntry->OnlineThread.Terminate ) {
                return(ERROR_SHUTDOWN_CLUSTER);
            }
            // Should FixCorruption take forever?  For now, "yes".
            status = DisksFixCorruption( VolumeName,
                                         ResourceEntry,
                                         status );
            if ( status != ERROR_SUCCESS ) {
                (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                                LOG_ERROR,
                                L"DiskspCheckPath: FixCorruption for drive <%1!ws!:> returned status of %2!d!.\n",
                                VolumeName,
                                status);
            }
        } else {
            // Some other error
            // Assume that the error is benign if data.FileCount > 0
            // ERROR_FILE_NOT_FOUND will be returned if there is no files on the volume
            if (data.FileCount > 0 || status == ERROR_EMPTY) {
                status = ERROR_SUCCESS;
            }
        }
    }
    return status;
} // DiskspCheckPath


DWORD
WaitForVolumes(
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  TimeOutInSeconds
    )
/*++

Routine Description:

    Checks out all volumes on a disk resource.  In addition, will check
    all drive letters on the volumes.  If no drive letters on the disk,
    volumes are always checked.

    If a volume or drive letter is not ready, wait the specified number
    of seconds before retrying.

Arguments:

    ResourceEntry - Supplies a pointer to the disk resource entry.

    TimeOutInSeconds - Number of seconds to wait for drive letter to come active.

Return Value:

    ERROR_SUCCESS - all drive letters and volumes on disk are accessible.

    ERROR_DISK_CORRUPT - drive letters or volumes not accessible.
                         Chkdsk.exe should be run on all volumes.

    Win32 error code - one or more drive letters is not accessible.

--*/
{
    PMOUNTIE_PARTITION entry;

    DWORD retryInterval = 2000;
    DWORD retries = TimeOutInSeconds / (retryInterval / 1000);

    DWORD i;
    DWORD partMap;
    DWORD tempPartMap;
    DWORD status;
    DWORD nPartitions = MountiePartitionCount( &ResourceEntry->MountieInfo );
    DWORD physicalDrive = ResourceEntry->DiskInfo.PhysicalDrive;

    WCHAR szGlobalDiskPartName[MAX_PATH];
    WCHAR szVolumeName[MAX_PATH];

    //
    // Check drive letters, if any.  If no drive letters, check only volumes.
    // If drive letters, we still fall through and check volumes.
    //

    status = WaitForDriveLetters( DisksGetLettersForSignature( ResourceEntry ),
                                  ResourceEntry,
                                  TimeOutInSeconds      // seconds timeout
                                  );

    if ( NO_ERROR != status ) {

        //
        // For any error checking drive letters, always return
        // either disk or file corrupt so chkdsk will run.
        //

        return ERROR_DISK_CORRUPT;
    }

    //
    // Make sure the partition count is not too large for the bitmap.
    //

    if ( nPartitions > ( sizeof(partMap) * 8 ) ) {

        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"WaitForVolumes: Partition count (%1!u!) greater than bitmap (%2!u!) \n",
                        nPartitions, sizeof(partMap) );

        return ERROR_INVALID_DATA;
    }

    //
    // Convert the partition count to a bitmap.
    //

    partMap = 0;
    for (i = 0; i < nPartitions; i++) {
        partMap |= (1 << i);
    }

    while ( TRUE ) {

        tempPartMap = partMap;

        for ( i = 0; tempPartMap; i++ ) {

            if ( (1 << i) & tempPartMap ) {

                tempPartMap &= ~(1 << i);

                entry = MountiePartition( &ResourceEntry->MountieInfo, i );

                if ( !entry ) {
                    (DiskpLogEvent)(
                          ResourceEntry->ResourceHandle,
                          LOG_ERROR,
                          L"WaitForVolumes: No partition entry for partition %1!u! \n", i );

                    //
                    // Something bad happened to our data structures.  We want to keep checking
                    // each of the other partitions.

                    continue;
                }

                //
                // Given the DiskPartName, get the VolGuid name.  This name must have a trailing
                // backslash to work correctly.
                //

                (VOID)StringCchPrintf( szGlobalDiskPartName,
                                       RTL_NUMBER_OF( szGlobalDiskPartName ),
                                       GLOBALROOT_HARDDISK_PARTITION_FMT,
                                       physicalDrive,
                                       entry->PartitionNumber );

                (DiskpLogEvent)(
                      ResourceEntry->ResourceHandle,
                      LOG_INFORMATION,
                      L"WaitForVolumes: Insure volume GUID name exists and accessible for %1!ws! \n",
                      szGlobalDiskPartName );

                szVolumeName[0] = L'\0';

                if ( !GetVolumeNameForVolumeMountPointW( szGlobalDiskPartName,
                                                         szVolumeName,
                                                         RTL_NUMBER_OF(szVolumeName) )) {

                    status = GetLastError();

                    (DiskpLogEvent)(
                          ResourceEntry->ResourceHandle,
                          LOG_ERROR,
                          L"WaitForVolumes: GetVolumeNameForVolumeMountPoint for %1!ws! returned %2!u!\n",
                          szGlobalDiskPartName,
                          status );

                    //
                    // Disk is corrupt.  Immediately return an error so chkdsk can run during
                    // online processing.
                    //

                    if ( ERROR_DISK_CORRUPT == status || ERROR_FILE_CORRUPT == status ) {
                        return status;
                    }

                    //
                    // Something bad happened.  Continue with the next partition.

                    continue;
                }

                ForcePnpVolChangeEvent( szVolumeName );

                status = DiskspCheckPathLite( szVolumeName, ResourceEntry );

                switch (status) {
                case ERROR_SUCCESS:
                case ERROR_EMPTY:
                    // Not an error
                    // Clear this partition number from the check list
                    partMap &= ~(1 << i);
                    break;
                case ERROR_FILE_NOT_FOUND:
                case ERROR_INVALID_PARAMETER:
                    // This is an error we expect to get when the volume
                    // wasn't mounted yet
                    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                                    LOG_ERROR,
                                    L"WaitForVolumes: Volume (%1!ws!) file system not mounted (%2!u!) \n",
                                    szVolumeName, status );
                    break;
                default:
                    // This is not an error we expect.
                    // Probably something is very wrong with the system
                    // bail out
                    (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                                    LOG_ERROR,
                                    L"WaitForVolumes: Volume (%1!ws!) returns (%2!u!) \n",
                                    szVolumeName, status );
                    return status;
                }
            }
        }

        if ( !partMap ) {
            // All partitions are verified //
            return ERROR_SUCCESS;
        }
        if ( retries-- == 0 ) {
            return status;
        }
        Sleep(retryInterval);

    }

    return ERROR_SUCCESS;

}   // WaitForVolumes


DWORD
DiskspCheckPathLite(
    IN LPWSTR VolumeName,
    IN PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Checks out a disk partition to see if the filesystem has mounted
    it and it's working.

Arguments:

    VolumeName - Supplies the device name of the form:
                 \\?\Volume{GUID}\    [Note trailing backslash!]

    ResourceEntry - Supplies a pointer to the disk resource entry.

Return Value:

    ERROR_SUCCESS if no corruption or corruption was found and corrected.

    Win32 error code otherwise

--*/

{
    DISKP_CHECK_PATH_DATA data;
    DWORD                 len;
    DWORD                 status;

    (DiskpLogEvent)(
          ResourceEntry->ResourceHandle,
          LOG_INFORMATION,
          L"DiskspCheckPathLite: Volume name %1!ws! \n",
          VolumeName );

    ZeroMemory( &data, sizeof(data) );

    data.OpenFiles = FALSE;
    data.LogFileNotFound = FALSE;
    data.ResourceEntry = ResourceEntry;

    len = wcslen( VolumeName );
    if ( len >= RTL_NUMBER_OF(data.FileName) - 1 ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"DiskspCheckPathLite: VolumeName length > buffer size \n" );
        return ERROR_ALLOTTED_SPACE_EXCEEDED;
    }
    if ( FAILED( StringCchCopy( data.FileName,
                                RTL_NUMBER_OF(data.FileName),
                                VolumeName ) ) ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Send the path with trailing backslash to DiskspCheckPathInternal.
    //

    status = DiskspCheckPathInternal( &data, len );

    return status;

}   // DiskspCheckPathLite


DWORD
DiskspCheckDriveLetter(
    IN WCHAR  DriveLetter,
    IN PDISK_RESOURCE ResourceEntry,
    IN BOOL Online
    )
/*++

Routine Description:

    Checks out a drive letter to see if the filesystem has mounted
    it and it's working. This is lightweight version of DiskspCheckPath

Arguments:

    DriveLetter - Supplies find first file failed

    ResourceEntry - Supplies a pointer to the disk resource entry.

    Online - Indicates whether this is Online or IsAlive processing.
             ERROR_FILE_NOT_FOUND error is logged only during Online.

Return Value:

    ERROR_SUCCESS or
    Win32 error code otherwise

--*/

{
    DISKP_CHECK_PATH_DATA data;
    DWORD                 len;
    DWORD                 status;
    ZeroMemory( &data, sizeof(data) );

    data.OpenFiles = FALSE;
    data.LogFileNotFound = FALSE;
    data.ResourceEntry = ResourceEntry;

    data.FileName[0] = DriveLetter;
    data.FileName[1] = L':';
    // data->FileName is zero initialized  data->FileName[2] = 0 //
    len = 2;

    status = DiskspCheckPathInternal( &data, len );

    if ( NO_ERROR != status ) {

        //
        // Log all errors during Online, but don't log errors indicating
        // the volume is empty (no files) during IsAlive (too noisy).
        //

        if ( ( ERROR_FILE_NOT_FOUND != status &&
               ERROR_EMPTY != status ) || Online ) {

            (DiskpLogEvent)(
                  ResourceEntry->ResourceHandle,
                  LOG_WARNING,
                  L"DiskspCheckDriveLetter: Checking drive name (%1!ws!) returns %2!u! \n",
                  data.FileName,
                  status );

        }

    }

    return status;

} // DiskspCheckDriveLetter


DWORD
WaitForDriveLetters(
    IN DWORD DriveLetters,
    IN PDISK_RESOURCE ResourceEntry,
    IN DWORD  TimeOutInSeconds
    )
/*++

Routine Description:

    Checks out all drive letters on a disk resource.  If a drive letter
    is not ready, wait the specified number of seconds before retrying.

Arguments:

    DriveLetter - Bit map of the drive letters for the disk

    ResourceEntry - Supplies a pointer to the disk resource entry.

    TimeOutInSeconds - Number of seconds to wait for drive letter to come active.
                       If zero, this routine is called during IsAlive.
                       If nonzero, this routine is called during Online.

Return Value:

    ERROR_SUCCESS - all drive letters on disk are accessible.

    Win32 error code - one or more drive letters is not accessible.

--*/
{
    DWORD retryInterval = 2000;
    DWORD retries = TimeOutInSeconds / (retryInterval / 1000);

    BOOL online = ( TimeOutInSeconds ? TRUE : FALSE );

    //
    // If device has no drive letters, then we are done.  Only log
    // this fact during online, not IsAlive (TimeOutInSeconds
    // is zero for IsAlive).
    //

    if ( !DriveLetters && online ) {
        (DiskpLogEvent)(
              ResourceEntry->ResourceHandle,
              LOG_INFORMATION,
              L"WaitForDriveLetters: No drive letters for volume, skipping drive letter check \n" );
        return ERROR_SUCCESS;
    }

    for(;;) {
        DWORD tempDriveLetters = DriveLetters;
        UINT  i = 0;
        DWORD status = ERROR_SUCCESS;

        while (tempDriveLetters) {
            if ( (1 << i) & tempDriveLetters ) {
                tempDriveLetters &= ~(1 << i);
                status = DiskspCheckDriveLetter( (WCHAR)(i + L'A'), ResourceEntry, online );
                switch (status) {
                case ERROR_SUCCESS:
                case ERROR_EMPTY:
                    // Not an error
                    // Clear this drive letter from the check list
                    DriveLetters &= ~(1 << i);
                    break;
                case ERROR_FILE_NOT_FOUND:
                case ERROR_INVALID_PARAMETER:
                    // This is an error we expect to get when the volume
                    // wasn't mounted yet
                    break;
                default:
                    // This is not an error we expect.
                    // Probably something is very wrong with the system
                    // bail out
                    return status;
                }
            }
            ++i;
        }
        if (!DriveLetters) {
            // All drive letters are verified //
            return ERROR_SUCCESS;
        }

        //
        // If user requested no wait time (ie. IsAlive running),
        // retries will be zero.  In this case, return status
        // immediately.
        //

        if (retries-- == 0) {
            return status;
        }
        Sleep(retryInterval);
    }
    return ERROR_SUCCESS;
}

NTSTATUS
ForcePnpVolChangeEvent(
    PWSTR RootPath
    )
/*++

Routine Description:

    Get the current volume label, then write it back.  This causes a
    PnP event for GUID_IO_VOLUME_CHANGE to take place.  We do this so
    the shell can see the new online disk.  The problem is that the
    shell sees a GUID_IO_VOLUME_MOUNT, but the disk is not yet online
    so the shell doesn't correctly display the file system type or
    volume label.

Arguments:

    RootPath - Supplies the device name of the form:
                 \\?\Volume{GUID}\    [Note trailing backslash!]

Return Value:

    ERROR_SUCCESS or
    Win32 error code otherwise

--*/
{
    LPWSTR  volumeLabel = NULL;
    LPWSTR  fileSystemName = NULL;

    DWORD   dwError = NO_ERROR;
    DWORD   maxComponentLength;
    DWORD   fileSystemFlags;

    if ( !RootPath ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    volumeLabel = LocalAlloc( LPTR, MAX_PATH * sizeof(WCHAR) );
    if ( !volumeLabel ) {
        dwError = GetLastError();
        goto FnExit;
    }

    fileSystemName = LocalAlloc( LPTR, MAX_PATH * sizeof(WCHAR) );
    if ( !fileSystemName ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // RootPath must end in a trailing backslash.
    //

    if ( !GetVolumeInformationW( RootPath,
                                 volumeLabel,
                                 MAX_PATH,                  // Number of chars
                                 NULL,
                                 &maxComponentLength,
                                 &fileSystemFlags,
                                 fileSystemName,
                                 MAX_PATH ) ) {             // Number of chars

        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Set the volume label to the same as the current.  This will force
    // PnP event for GUID_IO_VOLUME_CHANGE to take place.
    //

    if ( !SetVolumeLabelW( RootPath,
                           volumeLabel )) {

        dwError = GetLastError();
        goto FnExit;
    }

FnExit:

    if ( volumeLabel ) {
        LocalFree( volumeLabel );
    }

    if ( fileSystemName ) {
        LocalFree( fileSystemName );
    }

    return dwError;

}   // ForcePnpVolChangeEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\scsi.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    scsi.c

Abstract:

    Common routines for dealing with SCSI disks, usable
    by both raw disks and FT sets

Author:

    John Vert (jvert) 11/6/1996

Revision History:

--*/

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddstor.h>   // IOCTL_STORAGE_QUERY_PROPERTY

#include "disksp.h"
#include "newmount.h"
#include <string.h>
#include <shlwapi.h>    // SHDeleteKey
#include <ntddvol.h>    // IOCTL_VOLUME_QUERY_FAILOVER_SET
#include <setupapi.h>
#include <strsafe.h>    // Should be included last.

#define _NTSCSI_USER_MODE_
#include <scsi.h>
#undef  _NTSCSI_USER_MODE_

//
// The registry key containing the system partition
//
#define DISKS_REGKEY_SETUP                  L"SYSTEM\\SETUP"
#define DISKS_REGVALUE_SYSTEM_PARTITION     L"SystemPartition"

extern  PWCHAR g_DiskResource;                      // L"rtPhysical Disk"
#define RESOURCE_TYPE ((RESOURCE_HANDLE)g_DiskResource)

#define INVALID_SCSIADDRESS_VALUE   (DWORD)-1

#define SIG_LEN_WITH_NULL   9

typedef struct _SCSI_PASS_THROUGH_WITH_SENSE {
    SCSI_PASS_THROUGH Spt;
    UCHAR   SenseBuf[32];
} SCSI_PASS_THROUGH_WITH_SENSE, *PSCSI_PASS_THROUGH_WITH_SENSE;


typedef struct _UPDATE_AVAIL_DISKS {
    HKEY    AvailDisksKey;
    HKEY    SigKey;
    DWORD   EnableSanBoot;
    BOOL    SigKeyIsEmpty;
    PSCSI_ADDRESS_ENTRY CriticalDiskList;
} UPDATE_AVAIL_DISKS, *PUPDATE_AVAIL_DISKS;

typedef struct _SCSI_INFO {
    DWORD   Signature;
    DWORD   DiskNumber;
    DWORD   ScsiAddress;
} SCSI_INFO, *PSCSI_INFO;

typedef struct _SCSI_INFO_ARRAY {
    int Capacity;
    int Count;
    SCSI_INFO Info[1];
} SCSI_INFO_ARRAY, *PSCSI_INFO_ARRAY;

typedef struct _SERIAL_INFO {
    DWORD   Signature;
    DWORD   Error;
    LPWSTR  SerialNumber;
} SERIAL_INFO, *PSERIAL_INFO;

typedef
DWORD
(*LPDISK_ENUM_CALLBACK) (
    HANDLE DeviceHandle,
    DWORD Index,
    PVOID Param1
    );

//
// Local Routines
//


DWORD
AddSignatureToRegistry(
    HKEY RegKey,
    DWORD Signature
    );

BOOL
IsClusterCapable(
    IN DWORD ScsiAddress
    );

BOOL
IsSignatureInRegistry(
    HKEY RegKey,
    DWORD Signature
    );

DWORD
UpdateAvailableDisks(
    );

DWORD
UpdateAvailableDisksCallback(
    HANDLE DeviceHandle,
    DWORD Index,
    PVOID Param1
    );

DWORD
AddScsiAddressToList(
    PSCSI_ADDRESS ScsiAddress,
    PSCSI_ADDRESS_ENTRY *AddressList
    );

VOID
GetSystemBusInfo(
    PSCSI_ADDRESS_ENTRY *AddressList
    );

DWORD
GetVolumeDiskExtents(
    IN HANDLE DevHandle,
    OUT PVOLUME_DISK_EXTENTS *DiskExtents
    );

DWORD
BuildScsiListFromDiskExtents(
    IN HANDLE DevHandle,
    PSCSI_ADDRESS_ENTRY *AddressList
    );

HANDLE
OpenNtldrDisk(
    );

HANDLE
OpenOSDisk(
    );

DWORD
EnumerateDisks(
    LPDISK_ENUM_CALLBACK DiskEnumCallback,
    PVOID Param1
    );

DWORD
GetScsiAddressCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    );

DWORD
GetSerialNumberCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    );

DWORD
GetSigFromSerNumCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    );

DWORD
GetScsiAddressForDrive(
    WCHAR DriveLetter,
    PSCSI_ADDRESS ScsiAddress
    );

DWORD
FillScsiAddressCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    );

DWORD
GetDiskInfoEx(
    IN DWORD  Signature,
    IN PSCSI_INFO_ARRAY scsiInfos,
    OUT PVOID *OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    );


DWORD
ClusDiskGetAvailableDisks(
    OUT PVOID OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Enumerate and build a list of available disks on this system.

Arguments:

    OutBuffer - pointer to the output buffer to return the data.

    OutBufferSize - size of the output buffer.

    BytesReturned - the actual number of bytes that were returned (or
                the number of bytes that should have been returned if
                OutBufferSize is too small).

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

Remarks:

    Disk grovelling algorithm was changed to linear (see bug 738013).
    
    Previous behavior:
    
        For every signature in the clusdisk registery, 
        we used to call GetDiskInfo that will in turn do another scan of all available disks via SetupDI api's 
        in order to find a scsi address for a disk.
        It used to take about a minute to add a new disk on a system with 72 disks
    
    New behavior:
    
        Collect ScsiInfo for all known disks in one pass and then give it to GetDiskInfo, so
        that it doesn't have to enum all the disks to find a ScsiAddress for it.

--*/

{
    DWORD   status;
    HKEY    resKey;
    DWORD   ival;
    DWORD   signature;
    DWORD   bytesReturned = 0;
    DWORD   totalBytesReturned = 0;
    DWORD   dataLength;
    DWORD   outBufferSize = OutBufferSize;
    PVOID   ptrBuffer = OutBuffer;
    WCHAR   signatureName[SIG_LEN_WITH_NULL];
    PCLUSPROP_SYNTAX ptrSyntax;
    int     diskCount = 0;
    PSCSI_INFO_ARRAY scsiInfos = NULL;
    
    //
    // Make sure the AvailableDisks key is current.
    //

    UpdateAvailableDisks();

    *BytesReturned = 0;

    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           CLUSDISK_REGISTRY_AVAILABLE_DISKS,
                           0,
                           KEY_READ,
                           &resKey );

    if ( status != ERROR_SUCCESS ) {

        // If the key wasn't found, return an empty list.
        if ( status == ERROR_FILE_NOT_FOUND ) {

            // Add the endmark.
            bytesReturned += sizeof(CLUSPROP_SYNTAX);
            if ( bytesReturned <= outBufferSize ) {
                ptrSyntax = ptrBuffer;
                ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                ptrSyntax++;
                ptrBuffer = ptrSyntax;
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }

            *BytesReturned = bytesReturned;
        }
        // We can't log an error, we have no resource handle!
        return(status);
    }

    status = RegQueryInfoKey(
        resKey,
        NULL, // lpClass,
        NULL, // lpcClass,
        NULL, // lpReserved,
        &diskCount, // lpcSubKeys,
        NULL, // lpcMaxSubKeyLen,
        NULL, // lpcMaxClassLen,
        NULL, // lpcValues,
        NULL, // lpcMaxValueNameLen,
        NULL, // lpcMaxValueLen,
        NULL, // lpcbSecurityDescriptor,
        NULL // lpftLastWriteTime
        );
    if (status != ERROR_SUCCESS) {
        goto exit_gracefully;
    }

    scsiInfos = LocalAlloc(LMEM_ZEROINIT, sizeof(SCSI_INFO_ARRAY) + (diskCount - 1) * sizeof(SCSI_INFO));
    if (scsiInfos == NULL) {
        status = GetLastError();
        goto exit_gracefully;
    }
    scsiInfos->Capacity = diskCount;
    scsiInfos->Count = 0;

    totalBytesReturned = bytesReturned;
    bytesReturned = 0;

    for ( ival = 0; ; ival++ ) {
        dataLength = SIG_LEN_WITH_NULL;
        status = RegEnumKey( resKey,
                             ival,
                             signatureName,
                             dataLength );
        if ( status == ERROR_NO_MORE_ITEMS ) {
            status = ERROR_SUCCESS;
            break;
        } else if ( status != ERROR_SUCCESS ) {
            goto exit_gracefully;
        }

        dataLength = swscanf( signatureName, TEXT("%08x"), &signature );
        if ( dataLength != 1 ) {
            status = ERROR_INVALID_DATA;
            goto exit_gracefully;
        }

        if (scsiInfos->Count >= scsiInfos->Capacity) {
            // a signature was added after we queried number of keys.
            // ignore newly added disks. 
            break;
        }

        scsiInfos->Info[scsiInfos->Count++].Signature = signature;
    }

    // query SCSI-INFO information for all the disks in one pass
    status = EnumerateDisks( FillScsiAddressCallback, scsiInfos );
    if (status != ERROR_SUCCESS) {
        goto exit_gracefully;
    }

    for (ival = 0; ival < (DWORD)scsiInfos->Count; ++ival) {

        //
        // If not cluster capable, then skip it.
        //
        if ( !IsClusterCapable(scsiInfos->Info[ival].ScsiAddress) ) {
            continue;
        }

        signature = scsiInfos->Info[ival].Signature;

        GetDiskInfoEx( signature, scsiInfos,
                     &ptrBuffer,
                     outBufferSize,
                     &bytesReturned );
        if ( outBufferSize > bytesReturned ) {
            outBufferSize -= bytesReturned;
        } else {
            outBufferSize = 0;
        }
        totalBytesReturned += bytesReturned;
        bytesReturned = 0;

    }

exit_gracefully:

    if (scsiInfos != NULL) {
        LocalFree(scsiInfos);
    }

    RegCloseKey( resKey );

    bytesReturned = totalBytesReturned;

    // Add the endmark.
    bytesReturned += sizeof(CLUSPROP_SYNTAX);
    if ( bytesReturned <= outBufferSize ) {
        ptrSyntax = ptrBuffer;
        ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
        ptrSyntax++;
        ptrBuffer = ptrSyntax;
    }

    if ( bytesReturned > OutBufferSize ) {
        status = ERROR_MORE_DATA;
    }

    *BytesReturned = bytesReturned;

    return(status);

} // ClusDiskGetAvailableDisks


DWORD
GetScsiAddressEx(
    IN DWORD Signature,
    IN PSCSI_INFO_ARRAY ScsiInfos,
    OUT LPDWORD ScsiAddress,
    OUT LPDWORD DiskNumber
    )

/*++

Routine Description:

    Find the SCSI addressing for a given signature.

Arguments:

    Signature - the signature to find.

    ScsiInfos - array of signature/scsi-address pairs. 
                Can be NULL. (reverts to enumerating all the disks to find the address)

    ScsiAddress - pointer to a DWORD to return the SCSI address information.

    DiskNumber - the disk number associated with the signature.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD       dwError;

    SCSI_INFO   scsiInfo;

    if (ScsiInfos != NULL) {
        // if ScsiInfos was provided, gets ScsiAddress from there
        int i;
        for(i = 0; i < ScsiInfos->Count; ++i) {
            if (ScsiInfos->Info[i].Signature == Signature) {
                *ScsiAddress = ScsiInfos->Info[i].ScsiAddress;
                *DiskNumber = ScsiInfos->Info[i].DiskNumber;
                return ERROR_SUCCESS;
            }
        }
        return ERROR_FILE_NOT_FOUND;
    }

    ZeroMemory( &scsiInfo, sizeof(scsiInfo) );

    scsiInfo.Signature = Signature;

    dwError = EnumerateDisks( GetScsiAddressCallback, &scsiInfo );

    //
    // If the SCSI address was not set, we know the disk was not found.
    //

    if ( INVALID_SCSIADDRESS_VALUE == scsiInfo.ScsiAddress ) {
        dwError = ERROR_FILE_NOT_FOUND;
        goto FnExit;
    }

    //
    // The callback routine will use ERROR_POPUP_ALREADY_ACTIVE to stop
    // the disk enumeration.  Reset the value to success if that special
    // value is returned.
    //

    if ( ERROR_POPUP_ALREADY_ACTIVE == dwError ) {
        dwError = ERROR_SUCCESS;
    }

    *ScsiAddress    = scsiInfo.ScsiAddress;
    *DiskNumber     = scsiInfo.DiskNumber;

FnExit:

    return dwError;

}   // GetScsiAddress

DWORD
GetScsiAddress(
    IN DWORD Signature,
    OUT LPDWORD ScsiAddress,
    OUT LPDWORD DiskNumber
    )
{
    return GetScsiAddressEx(Signature, NULL, ScsiAddress, DiskNumber);
}


DWORD
GetScsiAddressCommon(
    HANDLE DevHandle,
    DWORD Index,
    PSCSI_INFO scsiInfo,
    PSCSI_INFO_ARRAY scsiInfoArray
    )
/*++

Routine Description:

    Find the SCSI address and disk number for a given signature.

Arguments:

    DevHandle - open handle to a physical disk.  Do not close
                the handle on exit.

    Index - current disk count.  Not used.

    scsiInfo - pointer to PSCSI_INFO structure. 

    scsiInfoArray - pointer to PSCSI_INFO_ARRAY 
    

Return Value:

    ERROR_SUCCESS to continue disk enumeration.

    ERROR_POPUP_ALREADY_ACTIVE to stop disk enumeration.  This
    value will be changed to ERROR_SUCCESS by GetScsiAddress.

Remarks:

    If scsiInfo is not null, the address will be stored in scsiInfo->address,
    otherwise, it will be stored in the corresponding entry of scsiInfoArray.

--*/
{
    int i;

    PDRIVE_LAYOUT_INFORMATION driveLayout = NULL;

    // Always return success to keep enumerating disks.  Any
    // error value will stop the disk enumeration.

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   bytesReturned;

    BOOL    success;

    SCSI_ADDRESS            scsiAddress;
    STORAGE_DEVICE_NUMBER   deviceNumber;
    CLUSPROP_SCSI_ADDRESS   clusScsiAddress;

    if (scsiInfo != NULL) {
        scsiInfo->ScsiAddress = INVALID_SCSIADDRESS_VALUE;
    }

    UpdateCachedDriveLayout( DevHandle );
    success = ClRtlGetDriveLayoutTable( DevHandle,
                                        &driveLayout,
                                        NULL );

    if ( !success || !driveLayout ) {
        goto FnExit;
    }

    if ( scsiInfoArray == NULL ) {

        if ( driveLayout->Signature != scsiInfo->Signature ) {
            goto FnExit;
        }       

    } else {

        // find the disk with that signature

        scsiInfo = NULL;
 
        for (i = 0; i < scsiInfoArray->Count; ++i) {
            if ( driveLayout->Signature == scsiInfoArray->Info[i].Signature ) {
                scsiInfo = &scsiInfoArray->Info[i];
                break;
            }
        }

        if (scsiInfo == NULL) {
            goto FnExit;
        }
    }

    //
    // We have a signature match.  Now get the scsi address.
    //

    ZeroMemory( &scsiAddress, sizeof(scsiAddress) );
    success = DeviceIoControl( DevHandle,
                               IOCTL_SCSI_GET_ADDRESS,
                               NULL,
                               0,
                               &scsiAddress,
                               sizeof(scsiAddress),
                               &bytesReturned,
                               FALSE );

    if ( !success ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Get the disk number.
    //

    ZeroMemory( &deviceNumber, sizeof(deviceNumber) );

    success = DeviceIoControl( DevHandle,
                               IOCTL_STORAGE_GET_DEVICE_NUMBER,
                               NULL,
                               0,
                               &deviceNumber,
                               sizeof(deviceNumber),
                               &bytesReturned,
                               NULL );

    if ( !success ) {
        dwError = GetLastError();
        goto FnExit;
    }

    clusScsiAddress.PortNumber  = scsiAddress.PortNumber;
    clusScsiAddress.PathId      = scsiAddress.PathId;
    clusScsiAddress.TargetId    = scsiAddress.TargetId;
    clusScsiAddress.Lun         = scsiAddress.Lun;

    scsiInfo->ScsiAddress   = clusScsiAddress.dw;
    scsiInfo->DiskNumber    = deviceNumber.DeviceNumber;

    if ( scsiInfoArray == NULL ) {
        dwError = ERROR_POPUP_ALREADY_ACTIVE;        
    }

FnExit:

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }

    return dwError;

} // GetScsiAddressCommon

DWORD
GetScsiAddressCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    )
{
    return GetScsiAddressCommon(DevHandle, Index, (PSCSI_INFO)Param1, NULL);
}

DWORD
FillScsiAddressCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    )
{
    return GetScsiAddressCommon(DevHandle, Index, NULL, (PSCSI_INFO_ARRAY)Param1);
}

BOOL
IsClusterCapable(
    IN DWORD ScsiAddress
    )

/*++

Routine Description:

    Check if the device is cluster capable. If this function cannot read
    the disk information, then it will assume that the device is cluster
    capable!

Arguments:

    ScsiAddress - ScsiAddress of a disk to test.

Return Value:

    TRUE if the device is cluster capable, FALSE otherwise.

Notes:

    On failures... we err on the side of being cluster capable.

--*/

{
    NTSTATUS        ntStatus;
    HANDLE          fileHandle;
    ANSI_STRING     objName;
    UNICODE_STRING  unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOL            success;
    DWORD           bytesReturned;
    CLUS_SCSI_ADDRESS address;
    WCHAR buf[] = L"\\device\\ScsiPort000000000000000000";
    SRB_IO_CONTROL  srbControl;

    address.dw = ScsiAddress;

    (VOID) StringCchPrintf( buf,
                            RTL_NUMBER_OF( buf ),
                            L"\\device\\ScsiPort%u",
                            address.PortNumber );

    RtlInitUnicodeString( &unicodeName, buf );

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &fileHandle,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    if ( !NT_SUCCESS(ntStatus) ) {
        return(TRUE);
    }

    ZeroMemory(&srbControl, sizeof(srbControl));
    srbControl.HeaderLength = sizeof(SRB_IO_CONTROL);
    CopyMemory( srbControl.Signature, "CLUSDISK", 8 );
    srbControl.Timeout = 3;
    srbControl.Length = 0;
    srbControl.ControlCode = IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE;
    

    success = DeviceIoControl( fileHandle,
                               IOCTL_SCSI_MINIPORT,
                               &srbControl,
                               sizeof(srbControl),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );
    NtClose( fileHandle );

    return(!success);

} // IsClusterCapable



DWORD
GetDiskInfo(
    IN DWORD  Signature,
    OUT PVOID *OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    return GetDiskInfoEx(
               Signature, NULL,
               OutBuffer, OutBufferSize, BytesReturned);
}

DWORD
GetDiskInfoEx(
    IN DWORD  Signature,
    IN PSCSI_INFO_ARRAY scsiInfos,
    OUT PVOID *OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Gets all of the disk information for a given signature.

Arguments:

    Signature - the signature of the disk to return info.

    OutBuffer - pointer to the output buffer to return the data.

    OutBufferSize - size of the output buffer.

    BytesReturned - the actual number of bytes that were returned (or
                the number of bytes that should have been returned if
                OutBufferSize is too small).

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD   status;
    DWORD   bytesReturned = *BytesReturned;
    PVOID   ptrBuffer = *OutBuffer;
    PCLUSPROP_DWORD ptrDword;
    PCLUSPROP_SCSI_ADDRESS ptrScsiAddress;
    PCLUSPROP_DISK_NUMBER ptrDiskNumber;
    PCLUSPROP_PARTITION_INFO ptrPartitionInfo;
    PCLUSPROP_SZ ptrSerialNumber;
    DWORD   cbSzSize;
    DWORD   cbDataSize;
    DWORD   scsiAddress;
    DWORD   diskNumber;

    NTSTATUS    ntStatus;
    CHAR        driveLetter;
    DWORD       i;
    MOUNTIE_INFO mountieInfo;
    PMOUNTIE_PARTITION entry;
    PWCHAR  serialNumber = NULL;

    WCHAR szDiskPartName[MAX_PATH];
    WCHAR szGlobalDiskPartName[MAX_PATH];

    LONGLONG    llCurrentMinUsablePartLength = 0x7FFFFFFFFFFFFFFF;
    PCLUSPROP_PARTITION_INFO ptrMinUsablePartitionInfo = NULL;

    // Return the signature - a DWORD
    bytesReturned += sizeof(CLUSPROP_DWORD);
    if ( bytesReturned <= OutBufferSize ) {
        ptrDword = ptrBuffer;
        ptrDword->Syntax.dw = CLUSPROP_SYNTAX_DISK_SIGNATURE;
        ptrDword->cbLength = sizeof(DWORD);
        ptrDword->dw = Signature;
        ptrDword++;
        ptrBuffer = ptrDword;
    }

    // Return the SCSI_ADDRESS - a DWORD
    status = GetScsiAddressEx( Signature,
                             scsiInfos,
                             &scsiAddress,
                             &diskNumber );

    if ( status == ERROR_SUCCESS ) {
        bytesReturned += sizeof(CLUSPROP_SCSI_ADDRESS);
        if ( bytesReturned <= OutBufferSize ) {
            ptrScsiAddress = ptrBuffer;
            ptrScsiAddress->Syntax.dw = CLUSPROP_SYNTAX_SCSI_ADDRESS;
            ptrScsiAddress->cbLength = sizeof(DWORD);
            ptrScsiAddress->dw = scsiAddress;
            ptrScsiAddress++;
            ptrBuffer = ptrScsiAddress;
        }

        // Return the DISK NUMBER - a DWORD
        bytesReturned += sizeof(CLUSPROP_DISK_NUMBER);
        if ( bytesReturned <= OutBufferSize ) {
            ptrDiskNumber = ptrBuffer;
            ptrDiskNumber->Syntax.dw = CLUSPROP_SYNTAX_DISK_NUMBER;
            ptrDiskNumber->cbLength = sizeof(DWORD);
            ptrDiskNumber->dw = diskNumber;
            ptrDiskNumber++;
            ptrBuffer = ptrDiskNumber;
        }
    } else {
        return( status);
    }

#if 0
    // Remove this until SQL team can fix their setup program.
    // SQL is shipping a version of setup that doesn't parse the property
    // list correctly and causes SQL setup to AV.  Since the SQL
    // setup is shipping and broken, remove the serial number.
    // SQL setup doesn't use ALIGN_CLUSPROP to find the next list entry.

    // Get the disk serial number.

    status = GetSerialNumber( Signature,
                              &serialNumber );

    if ( ERROR_SUCCESS == status && serialNumber ) {

        cbSzSize = (wcslen( serialNumber ) + 1) * sizeof(WCHAR);
        cbDataSize = sizeof(CLUSPROP_SZ) + ALIGN_CLUSPROP( cbSzSize );

        bytesReturned += cbDataSize;

        if ( bytesReturned <= OutBufferSize ) {
            ptrSerialNumber = ptrBuffer;
            ZeroMemory( ptrSerialNumber, cbDataSize );
            ptrSerialNumber->Syntax.dw = CLUSPROP_SYNTAX_DISK_SERIALNUMBER;
            ptrSerialNumber->cbLength = cbSzSize;
            (VOID) StringCbCopy( ptrSerialNumber->sz, cbSzSize, serialNumber );
            ptrBuffer = (PCHAR)ptrBuffer + cbDataSize;
        }

        if ( serialNumber ) {
            LocalFree( serialNumber );
        }
    }
#endif

    // Get all the valid partitions on the disk.  We must free the
    // volume info structure later.

    status = MountieFindPartitionsForDisk( diskNumber,
                                           &mountieInfo
                                           );

    if ( ERROR_SUCCESS == status ) {

        // For each partition, build a Property List.

        for ( i = 0; i < MountiePartitionCount( &mountieInfo ); ++i ) {

            entry = MountiePartition( &mountieInfo, i );

            if ( !entry ) {
                break;
            }

            // Always update the bytesReturned, even if there is more data than the
            // caller requested.  On return, the caller will see that there is more
            // data available.

            bytesReturned += sizeof(CLUSPROP_PARTITION_INFO);

            if ( bytesReturned <= OutBufferSize ) {
                ptrPartitionInfo = ptrBuffer;
                ZeroMemory( ptrPartitionInfo, sizeof(CLUSPROP_PARTITION_INFO) );
                ptrPartitionInfo->Syntax.dw = CLUSPROP_SYNTAX_PARTITION_INFO;
                ptrPartitionInfo->cbLength = sizeof(CLUSPROP_PARTITION_INFO) - sizeof(CLUSPROP_VALUE);

                // Create a name that can be used with some of our routines.
                // Don't use the drive letter as the name because we might be using
                // partitions without drive letters assigned.

                (VOID) StringCchPrintf( szDiskPartName,
                                        RTL_NUMBER_OF( szDiskPartName ),
                                        DEVICE_HARDDISK_PARTITION_FMT,
                                        diskNumber,
                                        entry->PartitionNumber );

                //
                // Create a global DiskPart name that we can use with the Win32
                // GetVolumeInformationW call.  This name must have a trailing
                // backslash to work correctly.
                //

                (VOID) StringCchPrintf( szGlobalDiskPartName,
                                        RTL_NUMBER_OF( szGlobalDiskPartName ),
                                        GLOBALROOT_HARDDISK_PARTITION_FMT,
                                        diskNumber,
                                        entry->PartitionNumber );

                // If partition has a drive letter assigned, return this info.
                // If no drive letter assigned, need a system-wide (i.e. across nodes)
                // way of identifying the device.

                ntStatus = GetAssignedLetter( szDiskPartName, &driveLetter );

                if ( NT_SUCCESS(status) && driveLetter ) {

                    // Return the drive letter as the device name.

                    (VOID) StringCchPrintf( ptrPartitionInfo->szDeviceName,
                                            RTL_NUMBER_OF( ptrPartitionInfo->szDeviceName ),
                                            TEXT("%hc:"),
                                            driveLetter );

                    ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_STICKY;

                } else {

                    // Return a physical device name.

                    // Return string name:
                    //   DiskXXXPartionYYY

                    (VOID) StringCchPrintf( ptrPartitionInfo->szDeviceName,
                                            RTL_NUMBER_OF( ptrPartitionInfo->szDeviceName ),
                                            TEXT("Disk%uPartition%u"),
                                            diskNumber,
                                            entry->PartitionNumber );
                }

                //
                // Call GetVolumeInformationW with the GlobalName we have created.
                //

                if ( !GetVolumeInformationW ( szGlobalDiskPartName,
                                              ptrPartitionInfo->szVolumeLabel,
                                              sizeof(ptrPartitionInfo->szVolumeLabel)/sizeof(WCHAR),
                                              &ptrPartitionInfo->dwSerialNumber,
                                              &ptrPartitionInfo->rgdwMaximumComponentLength,
                                              &ptrPartitionInfo->dwFileSystemFlags,
                                              ptrPartitionInfo->szFileSystem,
                                              sizeof(ptrPartitionInfo->szFileSystem)/sizeof(WCHAR) ) ) {

                    ptrPartitionInfo->szVolumeLabel[0] = L'\0';

                } else if ( CompareStringW( LOCALE_INVARIANT,
                                            NORM_IGNORECASE,
                                            ptrPartitionInfo->szFileSystem,
                                            -1,
                                            L"NTFS",
                                            -1
                                            ) == CSTR_EQUAL ) {

                    // Only NTFS drives are currently supported.

                    ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_USABLE;

                    //
                    //  Find the minimum size partition that is larger than MIN_QUORUM_PARTITION_LENGTH
                    //
                    if ( ( entry->PartitionLength.QuadPart >= MIN_USABLE_QUORUM_PARTITION_LENGTH ) &&
                         ( entry->PartitionLength.QuadPart < llCurrentMinUsablePartLength ) )
                    {
                        ptrMinUsablePartitionInfo = ptrPartitionInfo;
                        llCurrentMinUsablePartLength = entry->PartitionLength.QuadPart;
                    }
                }

                ptrPartitionInfo++;
                ptrBuffer = ptrPartitionInfo;
            }

        } // for

        // Free the volume information.

        MountieCleanup( &mountieInfo );
    }

    //
    //  If we managed to find a default quorum partition, change the flags to indicate this.
    //
    if ( ptrMinUsablePartitionInfo != NULL )
    {
        ptrMinUsablePartitionInfo->dwFlags |= CLUSPROP_PIFLAG_DEFAULT_QUORUM;
    }

    *OutBuffer = ptrBuffer;
    *BytesReturned = bytesReturned;

    return(status);

} // GetDiskInfo




DWORD
UpdateAvailableDisks(
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    HKEY    availDisksKey;
    HKEY    sigKey;

    PSCSI_ADDRESS_ENTRY criticalDiskList = NULL;

    DWORD   dwError = NO_ERROR;
    DWORD   enableSanBoot;

    BOOL    availDisksOpened = FALSE;
    BOOL    sigKeyOpened = FALSE;
    BOOL    sigKeyIsEmpty = FALSE;

    UPDATE_AVAIL_DISKS  updateDisks;

    __try {

        enableSanBoot = 0;
        GetRegDwordValue( CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                          CLUSREG_VALUENAME_MANAGEDISKSONSYSTEMBUSES,
                          &enableSanBoot );

        //
        // Delete the old AvailableDisks key.  This will remove any stale information.
        //

        SHDeleteKey( HKEY_LOCAL_MACHINE, CLUSDISK_REGISTRY_AVAILABLE_DISKS );

        //
        // Open the AvailableDisks key.  If the key doesn't exist, it will be created.
        //

        dwError = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                  CLUSDISK_REGISTRY_AVAILABLE_DISKS,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_CREATE_SUB_KEY,
                                  NULL,
                                  &availDisksKey,
                                  NULL );

        if ( NO_ERROR != dwError) {
            __leave;
        }

        availDisksOpened = TRUE;

        //
        // Open the Signatures key.
        //

        dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                CLUSDISK_REGISTRY_SIGNATURES,
                                0,
                                KEY_READ,
                                &sigKey );

        //
        // If Signatures key does not exist, save all valid signatures
        // in the AvailableDisks key.
        //

        if ( ERROR_FILE_NOT_FOUND == dwError ) {
            dwError = NO_ERROR;
            sigKeyIsEmpty = TRUE;
        } else if ( NO_ERROR != dwError) {
            __leave;
        } else {
            sigKeyOpened = TRUE;
        }

        GetCriticalDisks( &criticalDiskList );

        ZeroMemory( &updateDisks, sizeof(updateDisks) );
        updateDisks.EnableSanBoot       = enableSanBoot;
        updateDisks.SigKeyIsEmpty       = sigKeyIsEmpty;
        updateDisks.SigKey              = sigKey;
        updateDisks.AvailDisksKey       = availDisksKey;
        updateDisks.CriticalDiskList    = criticalDiskList;

        EnumerateDisks( UpdateAvailableDisksCallback, &updateDisks );

    } __finally {

        if ( criticalDiskList ) {
            CleanupScsiAddressList( criticalDiskList );
        }

        if ( availDisksOpened ) {
            RegCloseKey( availDisksKey );
        }

        if ( sigKeyOpened ) {
            RegCloseKey( sigKey );
        }
    }

    return  dwError;

} // UpdateAvailableDisks


DWORD
UpdateAvailableDisksCallback(
    HANDLE DeviceHandle,
    DWORD Index,
    PVOID Param1
    )
{
    PDRIVE_LAYOUT_INFORMATION driveLayout = NULL;
    PUPDATE_AVAIL_DISKS       updateDisks = Param1;
    PPARTITION_INFORMATION    partitionInfo;
    PSCSI_ADDRESS_ENTRY       criticalDiskList = updateDisks->CriticalDiskList;

    DWORD   bytesReturned;
    DWORD   enableSanBoot;
    DWORD   idx;

    BOOL    success;

    SCSI_ADDRESS    scsiAddress;

    //
    // Look at all disks on the system.  For each valid signature, add it to the
    // AvailableList if it is not already in the Signature key.
    //

    UpdateCachedDriveLayout( DeviceHandle );
    success = ClRtlGetDriveLayoutTable( DeviceHandle,
                                        &driveLayout,
                                        NULL );

    if ( !success || !driveLayout || 0 == driveLayout->Signature ) {
        goto FnExit;
    }

    //
    // Walk through partitions and make sure none are dynamic.  If any
    // partition is dynamic, ignore the disk.
    //

    for ( idx = 0; idx < driveLayout->PartitionCount; idx++ ) {
        partitionInfo = &driveLayout->PartitionEntry[idx];

        if ( 0 == partitionInfo->PartitionNumber ) {
            continue;
        }

        //
        // If any partition on the disk is dynamic, skip the disk.
        //

        if ( PARTITION_LDM == partitionInfo->PartitionType ) {

            (DiskpLogEvent)(
                  RESOURCE_TYPE,
                  LOG_INFORMATION,
                  L"UpdateAvailableDisks: skipping dynamic disk with signature %1!08x! \n",
                  driveLayout->Signature );

            goto FnExit;
        }
    }

    //
    // Get SCSI address info.
    //

    success = DeviceIoControl( DeviceHandle,
                               IOCTL_SCSI_GET_ADDRESS,
                               NULL,
                               0,
                               &scsiAddress,
                               sizeof(scsiAddress),
                               &bytesReturned,
                               NULL );

    if ( !success ) {
        goto FnExit;
    }

    //
    // Check if disk can be a cluster resource.
    //

    if ( !updateDisks->EnableSanBoot ) {

        //
        // Add signature to AvailableDisks key if:
        //  - the signature is for a disk not on system bus
        //  - the signature is for a disk not on same bus as paging disk
        //  - the signature is not already in the Signatures key
        //

        if ( !IsBusInList( &scsiAddress, criticalDiskList ) &&
             ( updateDisks->SigKeyIsEmpty ||
               !IsSignatureInRegistry( updateDisks->SigKey, driveLayout->Signature ) ) ) {

            AddSignatureToRegistry( updateDisks->AvailDisksKey,
                                    driveLayout->Signature );
        } else {
            (DiskpLogEvent)(
                  RESOURCE_TYPE,
                  LOG_INFORMATION,
                  L"UpdateAvailableDisks: Disk %1!08x! on critical bus or already clustered \n",
                  driveLayout->Signature );
        }

    } else {

        (DiskpLogEvent)(
              RESOURCE_TYPE,
              LOG_INFORMATION,
              L"UpdateAvailableDisks: Enable SAN boot key set \n" );

        // Allow disks on system bus to be added to cluster.

        //
        // Add signature to AvailableDisks key if:
        //  - the signature is not for the system disk
        //  - the signature is not a pagefile disk
        //  - the signature is not already in the Signatures key
        //

        if ( !IsDiskInList( &scsiAddress, criticalDiskList ) &&
             ( updateDisks->SigKeyIsEmpty ||
               !IsSignatureInRegistry( updateDisks->SigKey, driveLayout->Signature ) ) ) {

            AddSignatureToRegistry( updateDisks->AvailDisksKey,
                                    driveLayout->Signature );
        } else {
            (DiskpLogEvent)(
                  RESOURCE_TYPE,
                  LOG_INFORMATION,
                  L"UpdateAvailableDisks: Disk %1!08x! is critical disk or already clustered \n",
                  driveLayout->Signature );
        }

    }

FnExit:

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }

    //
    // Always return success so all disks are enumerated.
    //

    return ERROR_SUCCESS;

}   // UpdateAvailableDisksCallback


DWORD
AddSignatureToRegistry(
    HKEY RegKey,
    DWORD Signature
    )
/*++

Routine Description:

    Add the specified disk signature to the ClusDisk registry subkey.
    The disk signatures are subkeys of the ClusDisk\Parameters\AvailableDisks
    and ClusDisk\Parameters\Signatures keys.

Arguments:

    RegKey - Previously opened ClusDisk registry subkey

    Signature - Signature value to add

Return Value:

    Win32 error on failure.

--*/
{
    HKEY subKey;
    DWORD dwError;

    WCHAR signatureName[MAX_PATH];

    (DiskpLogEvent)(
          RESOURCE_TYPE,
          LOG_INFORMATION,
          L"AddSignatureToRegistry: Disk %1!08x! added to registry \n",
          Signature );

    if ( FAILED( StringCchPrintf( signatureName,
                                  SIG_LEN_WITH_NULL,
                                  TEXT("%08X"),
                                  Signature ) ) ) {
        dwError = ERROR_INSUFFICIENT_BUFFER;
    } else {

        //
        // Try and create the key.  If it exists, the existing key will be opened.
        //

        dwError = RegCreateKeyEx( RegKey,
                                  signatureName,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_WRITE,
                                  NULL,
                                  &subKey,
                                  NULL );

        //
        // If the key exists, ERROR_SUCCESS is still returned.
        //

        if ( ERROR_SUCCESS == dwError ) {
            RegCloseKey( subKey );
        }
    }

    return dwError;

}   // AddSignatureToRegistry


BOOL
IsSignatureInRegistry(
    HKEY RegKey,
    DWORD Signature
    )
/*++

Routine Description:

    Check if the specified disk signature is in the ClusDisk registry subkey.
    The disk signatures are subkeys of the ClusDisk\Parameters\AvailableDisks
    and ClusDisk\Parameters\Signatures keys.

    On error, assume the key is in the registry so it is not recreated.

Arguments:

    RegKey - Previously opened ClusDisk registry subkey

    Signature - Signature value to check

Return Value:

    TRUE - Signature is in registry

--*/
{
    DWORD   ival;
    DWORD   sig;
    DWORD   dataLength;
    DWORD   dwError;

    BOOL retVal = FALSE;

    WCHAR   signatureName[SIG_LEN_WITH_NULL];

    for ( ival = 0; ; ival++ ) {
        dataLength = SIG_LEN_WITH_NULL;

        dwError = RegEnumKey( RegKey,
                              ival,
                              signatureName,
                              dataLength );

        // If the list is exhausted, return FALSE.

        if ( ERROR_NO_MORE_ITEMS == dwError ) {
            break;
        }

        // If some other type of error, return TRUE.

        if ( ERROR_SUCCESS != dwError ) {
            retVal = TRUE;
            break;
        }

        dataLength = swscanf( signatureName, TEXT("%08x"), &sig );
        if ( dataLength != 1 ) {
            retVal = TRUE;
            break;
        }

        // If signature is a subkey, return TRUE.

        if ( sig == Signature ) {
            retVal = TRUE;
            break;
        }
    }

    return retVal;

}   // IsSignatureInRegistry


VOID
GetSystemBusInfo(
    PSCSI_ADDRESS_ENTRY *AddressList
    )
/*++

Routine Description:

    Need to find out where the NTLDR files reside (the "system disk") and where the
    OS files reside (the "boot disk").  We will call all these disks the "system disk".

    There may be more than one system disk if the disks are mirrored.  So if the NTLDR
    files are on a different disk than the OS files, and each of these disks is
    mirrored, we could be looking at 4 different disks.

    Find all the system disks and save the information in a list we can look at later.

Arguments:

Return Value:

    None

--*/
{
    HANDLE  hOsDevice = INVALID_HANDLE_VALUE;
    HANDLE  hNtldrDevice = INVALID_HANDLE_VALUE;

    DWORD   dwError;
    DWORD   bytesReturned;

    if ( !AddressList ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    // Open the disk with the OS files on it.
    //

    hOsDevice = OpenOSDisk();

    if ( INVALID_HANDLE_VALUE == hOsDevice ) {
        goto FnExit;
    }

    BuildScsiListFromDiskExtents( hOsDevice, AddressList );

    //
    // Now find the disks with NTLDR on it.  Disk could be mirrored.
    //

    hNtldrDevice = OpenNtldrDisk();

    if ( INVALID_HANDLE_VALUE == hNtldrDevice ) {
        goto FnExit;
    }

    BuildScsiListFromDiskExtents( hNtldrDevice, AddressList );

FnExit:

    if ( INVALID_HANDLE_VALUE != hOsDevice ) {
        CloseHandle( hOsDevice );
    }
    if ( INVALID_HANDLE_VALUE != hNtldrDevice ) {
        NtClose( hNtldrDevice );
    }

    return;

}   // GetSystemBusInfo


HANDLE
OpenOSDisk(
    )
{
    PWCHAR  systemDir = NULL;

    HANDLE  hDevice = INVALID_HANDLE_VALUE;
    DWORD   len;

    WCHAR   systemPath[] = TEXT("\\\\.\\?:");

    //
    // First find the disks with OS files.  Disk could be mirrored.
    //

    systemDir = LocalAlloc( LPTR, MAX_PATH * sizeof(WCHAR) );

    if ( !systemDir ) {
        goto FnExit;
    }

    len = GetSystemDirectory( systemDir,
                              MAX_PATH );

    if ( !len || len < 3 ) {
        goto FnExit;
    }

    //
    // If system path doesn't start with a drive letter, exit.
    //  c:\windows ==> c:

    if ( L':' != systemDir[1] ) {
        goto FnExit;
    }

    //
    // Stuff the drive letter in the system path.
    //

    systemPath[4] = systemDir[0];

    //
    // Now open the device.
    //

    hDevice = CreateFile( systemPath,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );

FnExit:

    if ( systemDir ) {
        LocalFree( systemDir );
    }

    return hDevice;

}   // OpenOSDisk


HANDLE
OpenNtldrDisk(
    )
{
    PWSTR   systemPartition = NULL;

    HANDLE  hDevice = INVALID_HANDLE_VALUE;

    HKEY    regKey = NULL;

    NTSTATUS    ntStatus;

    DWORD   dwError;
    DWORD   cbSystemPartition;
    DWORD   cbDeviceName;
    DWORD   type = 0;

    UNICODE_STRING      unicodeName;
    OBJECT_ATTRIBUTES   objAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;

    //
    // Open the reg key to find the system partition
    //

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,    // hKey
                            DISKS_REGKEY_SETUP,    // lpSubKey
                            0,                     // ulOptions--Reserved, must be 0
                            KEY_READ,              // samDesired
                            &regKey                // phkResult
                            );

    if ( ERROR_SUCCESS != dwError ) {
        goto FnExit;
    }

    //
    // Allocate a reasonably sized buffer for the system partition, to
    // start off with.  If this isn't big enough, we'll re-allocate as
    // needed.
    //

    cbSystemPartition = MAX_PATH + 1;
    systemPartition = LocalAlloc( LPTR, cbSystemPartition );

    if ( !systemPartition ) {
        goto FnExit;
    }

    //
    // Get the system partition device Name. This is of the form
    //      \Device\Harddisk0\Partition1                (basic disks)
    //      \Device\HarddiskDmVolumes\DgName\Volume1    (dynamic disks)
    //

    dwError = RegQueryValueEx( regKey,
                               DISKS_REGVALUE_SYSTEM_PARTITION,
                               NULL,
                               &type,
                               (LPBYTE)systemPartition,
                               &cbSystemPartition        // \0 is included
                               );

    while ( ERROR_MORE_DATA == dwError ) {

        //
        // Our buffer wasn't big enough, cbSystemPartition contains
        // the required size.
        //

        LocalFree( systemPartition );
        systemPartition = NULL;

        systemPartition = LocalAlloc( LPTR, cbSystemPartition );

        if ( !systemPartition ) {
            goto FnExit;
        }

        dwError = RegQueryValueEx( regKey,
                                   DISKS_REGVALUE_SYSTEM_PARTITION,
                                   NULL,
                                   &type,
                                   (LPBYTE)systemPartition,
                                   &cbSystemPartition        // \0 is included
                                   );
    }

    RtlInitUnicodeString( &unicodeName, systemPartition );

    InitializeObjectAttributes( &objAttributes,
                                &unicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtCreateFile( &hDevice,
                             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                             &objAttributes,
                             &ioStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             0,
                             NULL,
                             0 );

    if ( !NT_SUCCESS(ntStatus) ) {
        hDevice = INVALID_HANDLE_VALUE;
    }

FnExit:

    if ( regKey ) {
        RegCloseKey( regKey );
    }

    if ( systemPartition ) {
        LocalFree( systemPartition );
    }

    return hDevice;

}   // OpenNtldrDisk


DWORD
BuildScsiListFromDiskExtents(
    IN HANDLE DevHandle,
    PSCSI_ADDRESS_ENTRY *AddressList
    )
{
    PVOLUME_DISK_EXTENTS    diskExtents = NULL;
    PDISK_EXTENT            diskExt;

    HANDLE  hDevice = INVALID_HANDLE_VALUE;

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   idx;
    DWORD   bytesReturned;
    DWORD   deviceNameChars = MAX_PATH;

    SCSI_ADDRESS    scsiAddress;

    PWCHAR  deviceName = NULL;

    deviceName = LocalAlloc( LPTR, deviceNameChars * sizeof(WCHAR) );

    if ( !deviceName ) {
        dwError = GetLastError();
        goto FnExit;
    }

    //
    // Find out how many physical disks are represented by this device.
    //

    dwError = GetVolumeDiskExtents( DevHandle, &diskExtents );

    if ( ERROR_SUCCESS != dwError || !diskExtents ) {
        goto FnExit;
    }

    //
    // For each physical disk, get the scsi address and add it to the list.
    //

    for ( idx = 0; idx < diskExtents->NumberOfDiskExtents; idx++ ) {

        diskExt = &diskExtents->Extents[idx];

        (VOID) StringCchPrintf( deviceName,
                                deviceNameChars,
                                TEXT("\\\\.\\\\PhysicalDrive%d"),
                                diskExt->DiskNumber );

        hDevice = CreateFile( deviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );

        if ( INVALID_HANDLE_VALUE == hDevice ) {
            continue;
        }

        ZeroMemory( &scsiAddress, sizeof( scsiAddress ) );
        if ( DeviceIoControl( hDevice,
                              IOCTL_SCSI_GET_ADDRESS,
                              NULL,
                              0,
                              &scsiAddress,
                              sizeof(scsiAddress),
                              &bytesReturned,
                              NULL ) ) {

            AddScsiAddressToList( &scsiAddress, AddressList );
        }

        CloseHandle( hDevice );
        hDevice = INVALID_HANDLE_VALUE;
    }

FnExit:

    if ( diskExtents ) {
        LocalFree( diskExtents );
    }

    if ( deviceName ) {
        LocalFree( deviceName );
    }

    return dwError;

}   // BuildScsiListFromDiskExtents


DWORD
GetVolumeDiskExtents(
    IN HANDLE DevHandle,
    OUT PVOLUME_DISK_EXTENTS *DiskExtents
    )
{
    PVOLUME_DISK_EXTENTS    extents = NULL;

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   bytesReturned;
    DWORD   sizeExtents;

    BOOL    result;

    if ( !DiskExtents ) {
        goto FnExit;
    }

    *DiskExtents = NULL;

    sizeExtents = ( sizeof(VOLUME_DISK_EXTENTS) + 10 * sizeof(DISK_EXTENT) );

    extents = (PVOLUME_DISK_EXTENTS) LocalAlloc( LPTR, sizeExtents );

    if ( !extents ) {
        dwError = GetLastError();
        goto FnExit;
    }

    result = DeviceIoControl( DevHandle,
                              IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                              NULL,
                              0,
                              extents,
                              sizeExtents,
                              &bytesReturned,
                              NULL );

    //
    // We're doing this in a while loop because if the disk configuration
    // changes in the small interval between when we get the reqd buffer
    // size and when we send the ioctl again with a buffer of the "reqd"
    // size, we may still end up with a buffer that isn't big enough.
    //

    while ( !result ) {

        dwError = GetLastError();

        if ( ERROR_MORE_DATA == dwError ) {
            //
            // The buffer was too small, reallocate the requested size.
            //

            dwError = ERROR_SUCCESS;

            sizeExtents = ( sizeof(VOLUME_DISK_EXTENTS) +
                             ((extents->NumberOfDiskExtents) * sizeof(DISK_EXTENT)) );

            LocalFree( extents );
            extents = NULL;

            extents = (PVOLUME_DISK_EXTENTS) LocalAlloc( LPTR, sizeExtents );

            if ( !extents ) {
                dwError = GetLastError();
                goto FnExit;
            }

            result = DeviceIoControl( DevHandle,
                                      IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                      NULL,
                                      0,
                                      extents,
                                      sizeExtents,
                                      &bytesReturned,
                                      NULL );

        } else {

            // Some other error, return error.

            goto FnExit;

        }
    }

    *DiskExtents = extents;

FnExit:

    if ( ERROR_SUCCESS != dwError && extents ) {
        LocalFree( extents );
    }

    return dwError;

}   // GetVolumeDiskExtents


DWORD
GetScsiAddressForDrive(
    WCHAR DriveLetter,
    PSCSI_ADDRESS ScsiAddress
    )
{
    HANDLE  hDev = INVALID_HANDLE_VALUE;

    DWORD   dwError = NO_ERROR;
    DWORD   bytesReturned;

    WCHAR   diskName[32];

    //
    // Open device to get SCSI address.
    //

    (VOID) StringCchPrintf( diskName,
                            RTL_NUMBER_OF(diskName),
                            TEXT("\\\\.\\%wc:"),
                            DriveLetter );

    hDev = CreateFile( diskName,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );

    if ( INVALID_HANDLE_VALUE == hDev ) {
        dwError = GetLastError();
        goto FnExit;
    }

    ZeroMemory( ScsiAddress, sizeof(SCSI_ADDRESS) );
    if ( !DeviceIoControl( hDev,
                           IOCTL_SCSI_GET_ADDRESS,
                           NULL,
                           0,
                           ScsiAddress,
                           sizeof(SCSI_ADDRESS),
                           &bytesReturned,
                           FALSE ) ) {

        dwError = GetLastError();
    }

FnExit:

    if ( INVALID_HANDLE_VALUE != hDev ) {
        CloseHandle( hDev );
    }

    return dwError;

}   // GetScsiAddressForDrive


DWORD
GetCriticalDisks(
    PSCSI_ADDRESS_ENTRY *AddressList
    )
{
    //
    // Add system disk(s) to the list.
    //

    GetSystemBusInfo( AddressList );

    //
    // Add disks with page files to the list.
    //

    GetPagefileDisks( AddressList );

    //
    // Add disks with crash dump files to the list.
    //

    GetCrashdumpDisks( AddressList );

    //
    // Add disks with hibernation files to the list.
    //

    return NO_ERROR;

}   // GetCriticalDisks


DWORD
GetPagefileDisks(
    PSCSI_ADDRESS_ENTRY *AddressList
    )
/*++

Routine Description:

    Finds pagefile disks and saves path info.  Since these files can
    be added and removed as the system is running, it is best to build
    this list when we need it.

Arguments:

Return Value:

    NO_ERROR if successful

    Win32 error code otherwise

--*/
{
    LPWSTR          pagefileStrs = NULL;
    PWCHAR          currentStr;

    HKEY    pagefileKey = INVALID_HANDLE_VALUE;

    DWORD   dwError = NO_ERROR;

    SCSI_ADDRESS    scsiAddress;

    if ( !AddressList ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    dwError = RegOpenKey( HKEY_LOCAL_MACHINE,
                          TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
                          &pagefileKey );

    if ( dwError != NO_ERROR ) {
        goto FnExit;
    }

    //
    // Get the pagefile REG_MULTI_SZ buffer.
    //

    pagefileStrs = GetRegParameter( pagefileKey,
                                    TEXT("PagingFiles") );

    if ( !pagefileStrs ) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }

    //
    // Walk through the REG_MULTI_SZ buffer.  For each entry, get the
    // SCSI address and add it to the list.
    //
    // Syntax is:
    //      "C:\pagefile.sys 1152 1152"
    //      "D:\pagefile.sys 1152 1152"
    //

    currentStr = (PWCHAR)pagefileStrs;

    while ( *currentStr != L'\0' ) {

        //
        // Check that beginning of line looks like a drive letter and path.
        //

        if ( wcslen( currentStr ) <= 3 ||
             !isalpha( *currentStr ) ||
             *(currentStr + 1) != L':' ||
             *(currentStr + 2) != L'\\' ) {

            dwError = ERROR_INVALID_DATA;
            goto FnExit;
        }

        dwError = GetScsiAddressForDrive( *currentStr,
                                          &scsiAddress );

        if ( NO_ERROR == dwError ) {
            AddScsiAddressToList( &scsiAddress, AddressList );
        }

        //
        // Skip to next string.  Should be pointing to the next string
        // if it exists, or to another NULL if the end of the list.
        //

        while ( *currentStr++ != L'\0' ) {
            ;   // do nothing...
        }

    }

FnExit:

    if ( pagefileStrs ) {
        LocalFree( pagefileStrs );
    }

    if ( INVALID_HANDLE_VALUE != pagefileKey ) {
        RegCloseKey( pagefileKey );
    }

    return dwError;

}   // GetPagefileDisks


DWORD
GetCrashdumpDisks(
    PSCSI_ADDRESS_ENTRY *AddressList
    )
/*++

Routine Description:

    Finds crash dump disks and saves path info.  Since these files can
    be added and removed as the system is running, it is best to build
    this list when we need it.

Arguments:

Return Value:

    NO_ERROR if successful

    Win32 error code otherwise

--*/
{
    LPWSTR  dumpfileStr = NULL;
    PWCHAR  currentStr;

    HKEY    crashKey = INVALID_HANDLE_VALUE;

    DWORD   dwError = NO_ERROR;
    DWORD   enableCrashDump;

    SCSI_ADDRESS    scsiAddress;

    //
    // First check whether crash dump is enabled.  If not, we are done.
    //

    enableCrashDump = 0;
    dwError = GetRegDwordValue( TEXT("SYSTEM\\CurrentControlSet\\Control\\CrashControl"),
                                TEXT("CrashDumpEnabled"),
                                &enableCrashDump );

    if ( NO_ERROR != dwError || 0 == enableCrashDump ) {
        goto FnExit;
    }

    dwError = RegOpenKey( HKEY_LOCAL_MACHINE,
                          TEXT("SYSTEM\\CurrentControlSet\\Control\\CrashControl"),
                          &crashKey );

    if ( dwError != NO_ERROR ) {
        goto FnExit;
    }

    //
    // Get the pagefile REG_EXPAND_SZ buffer.  The routine will expand the
    // string before returning.
    //

    dumpfileStr = GetRegParameter( crashKey,
                                   TEXT("DumpFile") );

    if ( !dumpfileStr ) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }

    currentStr = (PWCHAR)dumpfileStr;

    //
    // Check that beginning of line looks like a drive letter and path.
    //

    if ( wcslen( currentStr ) <= 3 ||
         !iswalpha( *currentStr ) ||
         *(currentStr + 1) != L':' ||
         *(currentStr + 2) != L'\\' ) {

        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }

    dwError = GetScsiAddressForDrive( *currentStr,
                                      &scsiAddress );

    if ( NO_ERROR == dwError ) {
        AddScsiAddressToList( &scsiAddress, AddressList );
    }

    // Do we need to also store the disk where MinidumpDir is located?

FnExit:

    if ( INVALID_HANDLE_VALUE != crashKey ) {
        RegCloseKey( crashKey );
    }

    if ( dumpfileStr ) {
        LocalFree( dumpfileStr );
    }

    return dwError;

}   // GetCrashdumpDisks


DWORD
AddScsiAddressToList(
    PSCSI_ADDRESS ScsiAddress,
    PSCSI_ADDRESS_ENTRY *AddressList
    )
{
    PSCSI_ADDRESS_ENTRY entry;

    DWORD   dwError = ERROR_SUCCESS;

    if ( !ScsiAddress || !AddressList ) {
        goto FnExit;
    }

    //
    // Optimization: don't add the SCSI address if it already
    // matches one in the list.
    //

    if ( IsDiskInList( ScsiAddress, *AddressList ) ) {
        goto FnExit;
    }

    entry = LocalAlloc( LPTR, sizeof( SCSI_ADDRESS_ENTRY ) );

    if ( !entry ) {
        dwError = GetLastError();
        goto FnExit;
    }

    entry->ScsiAddress.Length       = ScsiAddress->Length;
    entry->ScsiAddress.PortNumber   = ScsiAddress->PortNumber;
    entry->ScsiAddress.PathId       = ScsiAddress->PathId;
    entry->ScsiAddress.TargetId     = ScsiAddress->TargetId;
    entry->ScsiAddress.Lun          = ScsiAddress->Lun;

    if ( *AddressList ) {

        entry->Next = *AddressList;
        *AddressList = entry;

    } else {

        *AddressList = entry;
    }

FnExit:

    return dwError;

}   // AddScsiAddressToList


VOID
CleanupScsiAddressList(
    PSCSI_ADDRESS_ENTRY AddressList
    )
{
    PSCSI_ADDRESS_ENTRY entry;
    PSCSI_ADDRESS_ENTRY next;

    entry = AddressList;

    while ( entry ) {
        next = entry->Next;
        LocalFree( entry );
        entry = next;
    }

}   // CleanupSystemBusInfo


BOOL
IsDiskInList(
    PSCSI_ADDRESS DiskAddr,
    PSCSI_ADDRESS_ENTRY AddressList
    )
{
    PSCSI_ADDRESS_ENTRY     entry = AddressList;
    PSCSI_ADDRESS_ENTRY     next;

    while ( entry ) {
        next = entry->Next;

        if ( DiskAddr->PortNumber   == entry->ScsiAddress.PortNumber &&
             DiskAddr->PathId       == entry->ScsiAddress.PathId &&
             DiskAddr->TargetId     == entry->ScsiAddress.TargetId &&
             DiskAddr->Lun          == entry->ScsiAddress.Lun ) {

             return TRUE;
        }

        entry = next;
    }

    return FALSE;

}   // IsDiskInList


BOOL
IsBusInList(
    PSCSI_ADDRESS DiskAddr,
    PSCSI_ADDRESS_ENTRY AddressList
    )
{
    PSCSI_ADDRESS_ENTRY     entry = AddressList;
    PSCSI_ADDRESS_ENTRY     next;

    while ( entry ) {
        next = entry->Next;

        if ( DiskAddr->PortNumber   == entry->ScsiAddress.PortNumber &&
             DiskAddr->PathId       == entry->ScsiAddress.PathId ) {

            return TRUE;
        }

        entry = next;
    }

    return FALSE;

}   // IsBusInList


DWORD
EnumerateDisks(
    LPDISK_ENUM_CALLBACK DiskEnumCallback,
    PVOID Param1
    )
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pDiDetail = NULL;

    HANDLE                      hDevice;

    DWORD                       dwError = ERROR_SUCCESS;
    DWORD                       count;
    DWORD                       sizeDiDetail;

    BOOL                        result;

    HDEVINFO                    hdevInfo = INVALID_HANDLE_VALUE;

    SP_DEVICE_INTERFACE_DATA    devInterfaceData;
    SP_DEVINFO_DATA             devInfoData;

    if ( !DiskEnumCallback ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    // Get a device interface set which includes all Disk devices
    // present on the machine. DiskClassGuid is a predefined GUID that
    // will return all disk-type device interfaces
    //

    hdevInfo = SetupDiGetClassDevs( &DiskClassGuid,
                                    NULL,
                                    NULL,
                                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );

    if ( INVALID_HANDLE_VALUE == hdevInfo ) {
        dwError = GetLastError();
        goto FnExit;
    }

    ZeroMemory( &devInterfaceData, sizeof( SP_DEVICE_INTERFACE_DATA) );

    //
    // Iterate over all devices interfaces in the set
    //

    for ( count = 0; ; count++ ) {

        // must set size first
        devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        //
        // Retrieve the device interface data for each device interface
        //

        result = SetupDiEnumDeviceInterfaces( hdevInfo,
                                              NULL,
                                              &DiskClassGuid,
                                              count,
                                              &devInterfaceData );

        if ( !result ) {

            //
            // If we retrieved the last item, break
            //

            dwError = GetLastError();

            if ( ERROR_NO_MORE_ITEMS == dwError ) {
                dwError = ERROR_SUCCESS;
                break;

            }

            //
            // Some other error occurred.  Stop processing.
            //

            goto FnExit;
        }

        //
        // Get the required buffer-size for the device path.  Note that
        // this call is expected to fail with insufficient buffer error.
        //

        result = SetupDiGetDeviceInterfaceDetail( hdevInfo,
                                                  &devInterfaceData,
                                                  NULL,
                                                  0,
                                                  &sizeDiDetail,
                                                  NULL
                                                  );

        if ( !result ) {

            dwError = GetLastError();

            //
            // If a value other than "insufficient buffer" is returned,
            // we have to skip this device.
            //

            if ( ERROR_INSUFFICIENT_BUFFER != dwError ) {
                continue;
            }

        } else {

            //
            // The call should have failed since we're getting the
            // required buffer size.  If it doesn't fail, something bad
            // happened.
            //

            continue;
        }

        //
        // Allocate memory for the device interface detail.
        //

        pDiDetail = LocalAlloc( LPTR, sizeDiDetail );

        if ( !pDiDetail ) {
            dwError = GetLastError();
            goto FnExit;
        }

        // must set the struct's size member

        pDiDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        //
        // Finally, retrieve the device interface detail info.
        //

        result = SetupDiGetDeviceInterfaceDetail( hdevInfo,
                                                  &devInterfaceData,
                                                  pDiDetail,
                                                  sizeDiDetail,
                                                  NULL,
                                                  &devInfoData
                                                  );

        if ( !result ) {

            dwError = GetLastError();

            LocalFree( pDiDetail );
            pDiDetail = NULL;

            //
            // Shouldn't fail, if it does, try the next device.
            //

            continue;
        }

        //
        // Open a handle to the device.
        //

        hDevice = CreateFile( pDiDetail->DevicePath,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

        LocalFree( pDiDetail );
        pDiDetail = NULL;

        if ( INVALID_HANDLE_VALUE == hDevice ) {
            continue;
        }

        //
        // Call the specified callback routine.  An error returned stops the
        // disk enumeration.
        //

        dwError = (*DiskEnumCallback)( hDevice, count, Param1 );

        CloseHandle( hDevice );

        if ( ERROR_SUCCESS != dwError ) {
            goto FnExit;
        }
    }

FnExit:

    if ( INVALID_HANDLE_VALUE != hdevInfo ) {
        SetupDiDestroyDeviceInfoList( hdevInfo );
    }

    if ( pDiDetail ) {
        LocalFree( pDiDetail );
    }

    return dwError;

}   // EnumerateDisks



DWORD
GetSerialNumber(
    IN DWORD Signature,
    OUT LPWSTR *SerialNumber
    )

/*++

Routine Description:

    Find the disk serial number for a given signature.

Arguments:

    Signature - the signature to find.

    SerialNumber - pointer to allocated buffer holding the returned serial
                   number.  The caller must free this buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD       dwError;

    SERIAL_INFO serialInfo;

    if ( !Signature || !SerialNumber ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    *SerialNumber = NULL;

    ZeroMemory( &serialInfo, sizeof(serialInfo) );

    serialInfo.Signature = Signature;
    serialInfo.Error = ERROR_SUCCESS;

    dwError = EnumerateDisks( GetSerialNumberCallback, &serialInfo );

    //
    // The callback routine will use ERROR_POPUP_ALREADY_ACTIVE to stop
    // the disk enumeration.  Reset the value to the value returned
    // in the SERIAL_INFO structure.
    //

    if ( ERROR_POPUP_ALREADY_ACTIVE == dwError ) {
        dwError = serialInfo.Error;
    }

    // This will either be NULL or an allocated buffer.  Caller is responsible
    // to free.

    *SerialNumber = serialInfo.SerialNumber;

FnExit:

    return dwError;

}   // GetSerialNumber


DWORD
GetSerialNumberCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    )
/*++

Routine Description:

    Find the disk serial number for a given signature.

Arguments:

    DevHandle - open handle to a physical disk.  Do not close
                the handle on exit.

    Index - current disk count.  Not used.

    Param1 - pointer to PSERIAL_INFO structure.

Return Value:

    ERROR_SUCCESS to continue disk enumeration.

    ERROR_POPUP_ALREADY_ACTIVE to stop disk enumeration.  This
    value will be changed to ERROR_SUCCESS by GetScsiAddress.

--*/
{
    PSERIAL_INFO                serialInfo = Param1;

    PDRIVE_LAYOUT_INFORMATION   driveLayout = NULL;

    DWORD   dwError = ERROR_SUCCESS;

    BOOL    success;

    // Always return success to keep enumerating disks.  Any
    // error value will stop the disk enumeration.

    STORAGE_PROPERTY_QUERY propQuery;

    UpdateCachedDriveLayout( DevHandle );
    success = ClRtlGetDriveLayoutTable( DevHandle,
                                        &driveLayout,
                                        NULL );

    if ( !success || !driveLayout ||
         ( driveLayout->Signature != serialInfo->Signature ) ) {
        goto FnExit;
    }

    //
    // At this point, we have a signature match.  Now this function
    // must return this error value to stop the disk enumeration.  The
    // error value for the serial number retrieval will be returned in
    // the SERIAL_INFO structure.
    //

    dwError = ERROR_POPUP_ALREADY_ACTIVE;

    serialInfo->Error = RetrieveSerialNumber( DevHandle, &serialInfo->SerialNumber );

FnExit:

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }

    if ( serialInfo->Error != ERROR_SUCCESS && serialInfo->SerialNumber ) {
        LocalFree( serialInfo->SerialNumber );
    }

    return dwError;

} // GetSerialNumberCallback


DWORD
GetSignatureFromSerialNumber(
    IN LPWSTR SerialNumber,
    OUT LPDWORD Signature
    )

/*++

Routine Description:

    Find the disk signature for the given serial number.

Arguments:

    SerialNumber - pointer to allocated buffer holding the serial number.

    Signature - pointer to location to hold the signature.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD       dwError;

    SERIAL_INFO serialInfo;

    if ( !Signature || !SerialNumber ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    *Signature = 0;

    ZeroMemory( &serialInfo, sizeof(serialInfo) );

    serialInfo.SerialNumber = SerialNumber;
    serialInfo.Error = ERROR_SUCCESS;

    dwError = EnumerateDisks( GetSigFromSerNumCallback, &serialInfo );

    //
    // The callback routine will use ERROR_POPUP_ALREADY_ACTIVE to stop
    // the disk enumeration.  Reset the value to the value returned
    // in the SERIAL_INFO structure.
    //

    if ( ERROR_POPUP_ALREADY_ACTIVE == dwError ) {
        dwError = serialInfo.Error;
    }

    // This signature will either be zero or valid.

    *Signature = serialInfo.Signature;

FnExit:

    return dwError;

}   // GetSignatureFromSerialNumber


DWORD
GetSigFromSerNumCallback(
    HANDLE DevHandle,
    DWORD Index,
    PVOID Param1
    )
/*++

Routine Description:

    Find the disk signature for a given serial number.

Arguments:

    DevHandle - open handle to a physical disk.  Do not close
                the handle on exit.

    Index - current disk count.  Not used.

    Param1 - pointer to PSERIAL_INFO structure.

Return Value:

    ERROR_SUCCESS to continue disk enumeration.

    ERROR_POPUP_ALREADY_ACTIVE to stop disk enumeration.  This
    value will be changed to ERROR_SUCCESS by GetScsiAddress.

--*/
{
    PSERIAL_INFO                serialInfo = Param1;
    LPWSTR                      serialNum = NULL;
    PDRIVE_LAYOUT_INFORMATION   driveLayout = NULL;

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   oldLen;
    DWORD   newLen;

    BOOL    success;

    // Always return success to keep enumerating disks.  Any
    // error value will stop the disk enumeration.

    dwError = RetrieveSerialNumber( DevHandle, &serialNum );

    if ( NO_ERROR != dwError || !serialNum ) {
        dwError = ERROR_SUCCESS;
        goto FnExit;
    }

    //
    // We have a serial number, now try to match it.
    //

    newLen = wcslen( serialNum );
    oldLen = wcslen( serialInfo->SerialNumber );

    if ( newLen != oldLen ||
         0 != wcsncmp( serialNum, serialInfo->SerialNumber, newLen ) ) {
        goto FnExit;
    }

    //
    // At this point, we have a serial number match.  Now this function
    // must return this error value to stop the disk enumeration.  The
    // error value for the signature retrieval will be returned in
    // the SERIAL_INFO structure.
    //

    dwError = ERROR_POPUP_ALREADY_ACTIVE;

    UpdateCachedDriveLayout( DevHandle );
    success = ClRtlGetDriveLayoutTable( DevHandle,
                                        &driveLayout,
                                        NULL );

    if ( !success || !driveLayout ) {
        serialInfo->Error = ERROR_INVALID_DATA;
        goto FnExit;
    }

    serialInfo->Signature = driveLayout->Signature;
    serialInfo->Error = NO_ERROR;

FnExit:

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }

    if ( serialNum ) {
        LocalFree( serialNum );
    }

    return dwError;

} // GetSigFromSerNumCallback


DWORD
RetrieveSerialNumber(
    HANDLE DevHandle,
    LPWSTR *SerialNumber
    )
{
    PSTORAGE_DEVICE_DESCRIPTOR  descriptor = NULL;

    PWCHAR  wSerNum = NULL;
    PCHAR   sigString;

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   bytesReturned;
    DWORD   descriptorSize;

    size_t  count;

    BOOL    success;

    STORAGE_PROPERTY_QUERY propQuery;

    if ( !SerialNumber ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    *SerialNumber = NULL;

    descriptorSize = sizeof( STORAGE_DEVICE_DESCRIPTOR) + 4096;

    descriptor = LocalAlloc( LPTR, descriptorSize );

    if ( !descriptor ) {
        dwError = GetLastError();
        goto FnExit;
    }

    ZeroMemory( &propQuery, sizeof( propQuery ) );

    propQuery.PropertyId = StorageDeviceProperty;
    propQuery.QueryType  = PropertyStandardQuery;

    success = DeviceIoControl( DevHandle,
                               IOCTL_STORAGE_QUERY_PROPERTY,
                               &propQuery,
                               sizeof(propQuery),
                               descriptor,
                               descriptorSize,
                               &bytesReturned,
                               NULL );

    if ( !success ) {
        dwError = GetLastError();
        goto FnExit;
    }

    if ( !bytesReturned ) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }

    //
    // Make sure the offset is reasonable.
    // IA64 sometimes returns -1 for SerialNumberOffset.
    //

    if ( 0 == descriptor->SerialNumberOffset ||
         descriptor->SerialNumberOffset > descriptor->Size ) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }

    //
    // Serial number string is a zero terminated ASCII string.
    //
    // The header ntddstor.h says the for devices with no serial number,
    // the offset will be zero.  This doesn't seem to be true.
    //
    // For devices with no serial number, it looks like a string with a single
    // null character '\0' is returned.
    //

    sigString = (PCHAR)descriptor + (DWORD)descriptor->SerialNumberOffset;

    if ( strlen(sigString) == 0) {
        dwError = ERROR_INVALID_DATA;
        goto FnExit;
    }

    //
    // Convert string to WCHAR.
    //

    // Figure out how big the WCHAR buffer should be.  Allocate the WCHAR
    // buffer and copy the string into it.

    wSerNum = LocalAlloc( LPTR, ( strlen(sigString) + 1 ) * sizeof(WCHAR) );

    if ( !wSerNum ) {
        dwError = GetLastError();
        goto FnExit;
    }

    count = mbstowcs( wSerNum, sigString, strlen(sigString) );

    if ( count != strlen(sigString) ) {
        dwError = ERROR_INVALID_DATA;
        LocalFree( wSerNum );
        wSerNum = NULL;
        goto FnExit;
    }

    *SerialNumber = wSerNum;
    dwError = NO_ERROR;

FnExit:

    if ( descriptor ) {
        LocalFree( descriptor );
    }

    return dwError;

}   // RetrieveSerialNumber


DWORD
UpdateCachedDriveLayout(
    IN HANDLE DiskHandle
    )
/*++

Routine Description:

    Tell storage drivers to flush their cached drive layout information.

    This routine must only be called for the physical disk or a deadlock may
    occur in partmgr/ftdisk.

Arguments:

    DevHandle - open handle to a physical disk.  Do not close
                the handle on exit.

Return Value:

    Win32 error value

--*/
{
    DWORD dwBytes;
    DWORD dwError;

    if ( !DeviceIoControl( DiskHandle,
                           IOCTL_DISK_UPDATE_PROPERTIES,
                           NULL,
                           0,
                           NULL,
                           0,
                           &dwBytes,
                           NULL ) ) {
        dwError = GetLastError();
    } else {
        dwError = NO_ERROR;
    }

    return dwError;

}   // UpdateCachedDriveLayout
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\pnp.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pnp

Abstract:

    This module processes disk related PnP notifications
    and tries to adjust partitions and drive letter information
    accordingly.

Author:

    Gor Nishanov (gorn) 21-Dec-1998

Environment:

    User Mode

Revision History:


--*/

#define UNICODE 1
#define INITGUID 1
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <dbt.h>
#include <devioctl.h>
#include <devguid.h>
#include <ioevent.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <mountmgr.h>
#include <pnpmgr.h>
#include <setupapi.h>

//#include <windows.h>

#include "disksp.h"
#include "newmount.h"
#include "newdisks.h"

#include <strsafe.h>    // Should be included last.


#define LOG_CURRENT_MODULE LOG_MODULE_DISK

static HWND DummyWindow = 0;
static BOOL PnPInitialized = FALSE;
static HANDLE NotificationWatcherThreadHandle;

static HANDLE PnpInterfacesRegistered;

static LONG VolumeListUpdateInProcess = 0;

RTL_RESOURCE    PnpVolumeLock;
RTL_RESOURCE    PnpWaitingListLock;

PWCHAR g_DiskResource = L"rtPhysical Disk";
#define RESOURCE_TYPE ((RESOURCE_HANDLE)g_DiskResource)

LIST_ENTRY WaitingDisks;

typedef struct _WAITING_DISK  {
    LIST_ENTRY  ListEntry;
    PDISK_RESOURCE ResourceEntry;
    HANDLE      Event;
    DWORD       Signature;
    ULONG       PartitionCount;
} WAITING_DISK, *PWAITING_DISK;

#define AcquireShared( _res_lock )      \
    RtlAcquireResourceShared( _res_lock, TRUE );

#define ReleaseShared( _res_lock )      \
    RtlReleaseResource( _res_lock );

#define AcquireExclusive( _res_lock )   \
    RtlAcquireResourceExclusive( _res_lock, TRUE );

#define ReleaseExclusive( _res_lock )   \
    RtlReleaseResource( _res_lock );

DWORD
NotificationWatcherThread(
    IN LPVOID
    );

VOID
ProcessMountPointChange(
    HDEVNOTIFY devNotify,
    DWORD Signature
    );

PWAITING_DISK
FindWaitingDisk(
    DWORD Signature
    );

DWORD
GetVolName(
    PWCHAR Name,
    PWCHAR *VolGuid
    );


DWORD
StartNotificationWatcherThread(
    VOID)
{
    DWORD status = ERROR_SUCCESS;
    HANDLE thread;

    if ( InterlockedCompareExchange(&PnPInitialized, TRUE, FALSE) ) {
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] PnP was already initialized.\n",
             status );
        return ERROR_SUCCESS;
    }

    PnpInterfacesRegistered = NULL;
    PnpInterfacesRegistered = CreateEvent( NULL,    // security attributes
                                           TRUE,    // manual reset
                                           FALSE,   // initial state nonsignaled
                                           NULL );  // event name

    if ( NULL == PnpInterfacesRegistered ) {
        status = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] Unable to create event for PnP interface registration. \n",
             status );
        status = ERROR_SUCCESS;
    }

    thread =
        CreateThread( NULL, // security attributes
                      0,    // stack_size = default
                      NotificationWatcherThread,
                      (LPVOID)0, // no parameters
                      0,    // runs immediately
                      0 );  // don't need thread id
    if(thread == NULL) {
        status = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] StartNotificationWatcherThread failed, error: %1!u!. \n",
             status );
    } else {

        if ( NULL != PnpInterfacesRegistered ) {

            //
            // Before returning to caller, make sure all PnP interfaces
            // are registered.
            //

            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] Waiting for PnP interface registration to complete.\n" );

            status = WaitForSingleObject( PnpInterfacesRegistered, 30 * 1000 );

            if ( WAIT_TIMEOUT == status ) {
                (DiskpLogEvent)(
                     RESOURCE_TYPE,
                     LOG_ERROR,
                     L"[PnP] PnP interface registration failed to complete in time, error: %1!u! \n",
                     status );
            }

            CloseHandle( PnpInterfacesRegistered );
            PnpInterfacesRegistered = NULL;

            status = ERROR_SUCCESS;
        }

    }
    NotificationWatcherThreadHandle = thread;

    return status;
}

VOID
StopNotificationWatcher(
    VOID
    )
/*++

 Routine Description:

     Handler for console control events

 Arguments:

     dwCtrlType - Indicates the console event to handle.

 Return Value:

     TRUE if the event was handled, FALSE otherwise.

--*/

{
    HANDLE localHandle = NotificationWatcherThreadHandle;
    if (DummyWindow) {
        PostMessage(DummyWindow, WM_QUIT, 0, 0);
        if (localHandle) {
            WaitForSingleObject(localHandle, 10 * 1000);
            CloseHandle(localHandle);
        }
    }
}

#define WM_WatchDisk        (WM_USER + 1)
#define WM_StopWatchingDisk (WM_USER + 2)

VOID
WatchDisk(
    IN PDISK_RESOURCE ResourceEntry
    )
{
    if (DummyWindow) {
        PostMessage(DummyWindow, WM_WatchDisk, 0, (LPARAM)ResourceEntry);
    }
}

VOID
StopWatchingDisk(
    IN PDISK_RESOURCE ResourceEntry
    )
{
    if (DummyWindow) {
        SendMessage(DummyWindow, WM_StopWatchingDisk, 0, (LPARAM)ResourceEntry);
    }
}

///////////////////////////////////////////////////////////////////////////

VOID
MyUnregisterDeviceNotification(HDEVNOTIFY hNotify)
{
#if DBG
    (DiskpLogEvent)(
         RESOURCE_TYPE,
         LOG_INFORMATION,
         L"[PnP] Unregistering device notification - HDEVNOTIFY %1!x! \n",
         hNotify );
#endif

    UnregisterDeviceNotification( hNotify );
}

HDEVNOTIFY
MyRegisterDeviceNotification(
    IN HANDLE hRecipient,
    IN LPVOID NotificationFilter,
    IN DWORD Flags
    )
{

#if DBG
    (DiskpLogEvent)(
         RESOURCE_TYPE,
         LOG_INFORMATION,
         L"[PnP] Registering device notification - Recipient %1!x!  Flags %2!x! \n",
         hRecipient,
         Flags );
#endif

    return RegisterDeviceNotification( hRecipient,
                                       NotificationFilter,
                                       Flags
                                       );
}

DWORD
RegisterDeviceHandle(
    IN HANDLE wnd,
    IN HANDLE device,
    OUT HDEVNOTIFY *devNotify)
{
    DEV_BROADCAST_HANDLE DbtHandle;
    DWORD status = ERROR_SUCCESS;
    *devNotify = 0;

    ZeroMemory(&DbtHandle,sizeof(DEV_BROADCAST_HANDLE));

    DbtHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
    DbtHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
    DbtHandle.dbch_handle = device;


    *devNotify = MyRegisterDeviceNotification(
                                    (HANDLE)wnd,
                                    &DbtHandle,
                                    DEVICE_NOTIFY_WINDOW_HANDLE
                                    );
    if (!*devNotify) {
        status = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] DBT_DEVTYP_HANDLE failed, error %1!u!\n",
             status );
    }
    return status;
}

DWORD
RegisterDeviceInterface(
    IN HANDLE wnd,
    IN const GUID * guid,
    OUT HDEVNOTIFY *devNotify)
{
    DEV_BROADCAST_DEVICEINTERFACE filter;
    DWORD status = ERROR_SUCCESS;
    *devNotify = 0;

    ZeroMemory(&filter, sizeof(filter));
    filter.dbcc_size = sizeof(filter);
    filter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    CopyMemory(&filter.dbcc_classguid, guid, sizeof(filter.dbcc_classguid));

    *devNotify = MyRegisterDeviceNotification(
                                    (HANDLE)wnd,
                                    &filter,
                                    DEVICE_NOTIFY_WINDOW_HANDLE
                                    );
    if (!*devNotify) {
        status = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] DBT_DEVTYP_DEVICEINTERFACE failed, error %1!u!\n",
             status );
    }
    return status;
}

///////////// Forward Declarations /////////////////
typedef struct _VOLUME *PVOLUME;

#define LOG_GUID_START( _Broadcast_, _Vol_ )    LogPnpGuid( _Broadcast_, _Vol_, L"Received" );
#define LOG_GUID_END( _Broadcast_, _Vol_ )      LogPnpGuid( _Broadcast_, _Vol_, L"Processed" );


VOID
LogPnpGuid(
    PDEV_BROADCAST_HANDLE Broadcast,
    PVOLUME Vol,
    PWSTR BeginEndStr
    );


VOID
PokeDiskResource(
    PVOLUME vol
    );
/*++

Routine Description:

    Updates ClusterRegistry info if necessary

Arguments:

    Volume of interest (used only to get the disk signature)
    Updates a per disk basis

Return Value:

    None

--*/

DWORD
GetVolumeInfo(
    PVOLUME Vol,
    PHANDLE FileHandle
    );


///////////// End Forward Declarations /////////////


////////////// Notification List Management //////////////////////////////
//
// We maintain a list of all volumes we are getting PnP notifications for
//
//   PVOLUME FindVolume(HDEVNOTIFY Key);
//   VOID    DestroyVolume(PVOLUME vol);
//   VOID    RemoveVolume(HDEVNOTIFY devNotify);
//   VOID    AddVolume(PWCHAR Name)
//
LIST_ENTRY VolumeList;

typedef struct _VOLUME  {
    LIST_ENTRY ListEntry;
    HDEVNOTIFY DevNotify;
    DWORD Signature;
    LONG UpdateActive;
    LARGE_INTEGER PartOffset;
    LARGE_INTEGER PartLength;
    ULONG         PartNo;
    BYTE PartitionType;
    CHAR DriveLetter;
    WCHAR Name[1];
} VOLUME;


PVOLUME
FindVolume(HDEVNOTIFY Key)
{
    PLIST_ENTRY entry;
    for ( entry = VolumeList.Flink;
          entry != &VolumeList;
          entry = entry->Flink
        )
    {
        PVOLUME vol = CONTAINING_RECORD(
                       entry,
                       VOLUME,
                       ListEntry
                       );

        if (vol->DevNotify == Key) {
            return(vol);
        }
    }
    return 0;
}

VOID
DestroyVolume(
    PVOLUME vol)
{
//    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
//        L"Destroying entry for %1!s!\n", vol->Name);
    MyUnregisterDeviceNotification(vol->DevNotify);
    LocalFree(vol);
}

VOID
RemoveVolume(HDEVNOTIFY devNotify)
{
    PVOLUME vol = NULL;

    // Use a lock here as the online thread might be parsing the volume list.

    AcquireExclusive( &PnpVolumeLock );

    vol = FindVolume( devNotify );
    if (!vol) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] RemoveVolume: devNotify %1!d! is not in the list\n", devNotify);
        ReleaseExclusive( &PnpVolumeLock );
        return;
    }

    PokeDiskResource(vol);

    RemoveEntryList(&vol->ListEntry);
    ReleaseExclusive( &PnpVolumeLock );
    DestroyVolume(vol);
}


VOID
AddVolume(
    PWCHAR Name
    )
{
    PWAITING_DISK  waitDisk;
    PLIST_ENTRY entry;
    PVOLUME volList;
    PVOLUME vol = NULL;
    PWCHAR  volGuid = NULL;

    DWORD   status;
    DWORD   signature;

    size_t  len;

    HANDLE  fileHandle;

    BOOL    duplicateEntry;
    BOOL    keepVolume = FALSE;


    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] AddVolume: Adding Name %1!s! \n", Name );

    //
    // Convert name to VolGuid name.  If name is already a VolGuid
    // name, the correct name will be returned.  GetVolName will
    // always return a name with a trailing backslash.
    //

    status = GetVolName( Name, &volGuid );

    if ( ERROR_SUCCESS != status || !volGuid ) {
        goto FnExit;
    }

    len = wcslen(volGuid);

    // VOLUME structure includes 1 char for Name, so just add the
    // length of the VolGuid (not length + 1).
    vol = LocalAlloc(LPTR, sizeof(VOLUME) + len * sizeof(WCHAR));

    if ( NULL == vol ) {

        status = GetLastError();
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] AddVolume: can't alloc VOL+%1!d!, error %2!u!\n", len, status );

        goto FnExit;
    }

    wcsncpy( vol->Name, volGuid, len );
    vol->Name[len] = L'\0';             // Allocation included space for NULL.

    //
    // Skip CDROM devices.  This requires a trailing backslash and
    // prefix \\?\.
    //

    if ( DRIVE_CDROM == GetDriveType( vol->Name ) ) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Skipping CDROM volume %1!s!\n", vol->Name );
        goto FnExit;
    }

    //
    // Skip floppy devices.  This requires a trailing backslash and
    // prefix \\?\.
    //

    if ( DRIVE_REMOVABLE == GetDriveType( vol->Name ) ) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Skipping floppy volume %1!s!\n", vol->Name );
        goto FnExit;
    }

    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] AddVolume: Attempting to add volume %1!s!\n", volGuid );

    if (len > 0 && vol->Name[len-1] == L'\\')
    {
        // remove trailing backslash
        vol->Name[len-1] = 0;
    }

    if (len > 2 && vol->Name[0] == L'\\' && vol->Name[1] == L'\\') {
        // Convert to NT file name
        vol->Name[1] = L'?';
    }

    //
    // Make sure the volume isn't already in the list.  If so,
    // skip it.
    //

    duplicateEntry = FALSE;
    AcquireShared( &PnpVolumeLock );

    len = wcslen( vol->Name );
    for ( entry = VolumeList.Flink;
          entry != &VolumeList;
          entry = entry->Flink
        )
    {
        volList = CONTAINING_RECORD( entry,
                                     VOLUME,
                                     ListEntry
                                     );

        if ( ( len == wcslen( volList->Name) ) &&
             ( 0 == ClRtlStrNICmp( vol->Name, volList->Name, len ) ) ) {

            duplicateEntry = TRUE;
            break;
        }
    }

    ReleaseShared( &PnpVolumeLock );

    if ( duplicateEntry ) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Skipping duplicate volume %1!s!\n", vol->Name );
        goto FnExit;
    }

    status = GetVolumeInfo( vol, &fileHandle );

    //
    // We might have a clustered disk now, but we can't read the
    // partition info or drive layout because the disk is reserved
    // by another node.
    //
    // If the disk is reserved by another node, we typically see
    // this returned:
    //   170 ERROR_BUSY
    // If the disk is offline, we can see this:
    //   2 ERROR_FILE_NOT_FOUND
    //
    // About all we know for sure is that if this is a non-fixed device,
    // ERROR_INVALID_FUNCTION will be returned.  For now, skip these
    // devices and track any other volumes coming through.
    //

    if ( ERROR_INVALID_FUNCTION == status ) {

        if ( INVALID_HANDLE_VALUE != fileHandle) {
            DevfileClose( fileHandle );
        }

        // Change this from LOG_ERROR to LOG_INFORMATION.  This thread gets
        // notified when non-fixed disks arrive (i.e. floppy), so logging
        // an error for a floppy disk is misleading.

        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Skipping volume %1!ws! \n",
            vol->Name);

        goto FnExit;
    }

    if ( INVALID_HANDLE_VALUE == fileHandle ) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_WARNING,
            L"[PnP] AddVolume: Unable to get volume handle (%1!ws!), error %2!u!\n",
            vol->Name, status);

        goto FnExit;
    }

    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] AddVolume: adding volume %1!s!\n", vol->Name );

    status = RegisterDeviceHandle(DummyWindow, fileHandle, &vol->DevNotify);
    DevfileClose( fileHandle );

    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] AddVolume: RDN(%1!ws!), error %2!u!\n",
            vol->Name,
            status);
        goto FnExit;
    }

    GetAssignedLetter(vol->Name, &vol->DriveLetter);

    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] AddVolume: %1!s! '%2!c!', %3!d! (%4!u!)\n",
        Name, (vol->DriveLetter)?vol->DriveLetter:' ', vol->PartitionType, vol->DevNotify);

    // Use a lock here as the online thread might be parsing the volume list.

    // As soon as the volume is added to the list, another thread could come
    // through and remove it.  Save the signature to a local variable so
    // we can check the waiting list.

    signature = vol->Signature;
    keepVolume = TRUE;
    AcquireExclusive( &PnpVolumeLock );
    InsertTailList(&VolumeList, &vol->ListEntry);
    ReleaseExclusive( &PnpVolumeLock );

    AcquireShared( &PnpWaitingListLock );
    waitDisk = FindWaitingDisk( signature );
    if ( waitDisk ) {

        //
        // We have a waiting disk that matches this volume signature.
        // Now see if all the volumes are in the volume list.
        //

        if ( IsDiskInPnpVolumeList( waitDisk->ResourceEntry, FALSE ) ) {

            (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
                L"[PnP] AddVolume: All volumes present, signal event for signature %1!x!\n",
                signature );

            //
            // All volumes present, signal the event.
            //

            SetEvent( waitDisk->Event );

        } else {

            (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
                L"[PnP] AddVolume: All volumes not ready for signature %1!x!\n",
                signature );
        }
    } else {

        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] AddVolume: Online request not queued for signature %1!x!\n",
            signature );

    }

    ReleaseShared( &PnpWaitingListLock );

FnExit:

    if ( volGuid ) {
        LocalFree( volGuid );
    }

    if ( !keepVolume && vol ) {
        LocalFree( vol );
    }

    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] AddVolume: Adding Name %1!s! - processed \n", Name );

}


DWORD
GetVolName(
    PWCHAR Name,
    PWCHAR *VolGuid
    )
{
    PWCHAR  volName = NULL;
    PWCHAR  tempName = NULL;

    DWORD   volNameLenBytes;
    DWORD   tempNameLenBytes;
    DWORD   nameLen;

    DWORD   dwError = ERROR_SUCCESS;

    if ( VolGuid ) {
        *VolGuid = NULL;
    }

#if DBG
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] GetVolName: Name %1!s!\n", Name );
#endif

    nameLen = wcslen( Name );

    //
    // Create a buffer with room for a backslash.
    //

    tempNameLenBytes = ( nameLen * sizeof(WCHAR) ) + sizeof(UNICODE_NULL) + sizeof(WCHAR);


    tempName = LocalAlloc( LPTR, tempNameLenBytes );

    if ( !tempName ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] GetVolName: LocalAlloc for tempName failed, error %1!d! \n",
             dwError );
        goto FnExit;
    }

    wcsncpy( tempName, Name, nameLen );     // Room for NULL and '\' in buffer.

    //
    // Add trailing backslash.
    //

    if ( nameLen > 0 && tempName[nameLen-1] != L'\\' ) {
         //
         // This is safe because temporary buffer is larger than
         // original buffer.
         //
         tempName[nameLen] = L'\\';
    }

#if DBG
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] GetVolName: tempName %1!s!\n", tempName );
#endif

    volNameLenBytes = MAX_PATH * sizeof(WCHAR);
    volName = LocalAlloc( LPTR, volNameLenBytes );

    if ( !volName ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] GetVolName: LocalAlloc for volName failed, error %1!d! \n",
             dwError );
        goto FnExit;
    }

    if ( !GetVolumeNameForVolumeMountPointW( tempName,
                                             volName,
                                             volNameLenBytes / sizeof(WCHAR) ) ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] GetVolName: GetVolumeNameForVolumeMountPoint failed, error %1!d! \n",
             dwError );
        goto FnExit;
    }

    if ( VolGuid ) {
        *VolGuid = volName;
    }

FnExit:

    if ( dwError != ERROR_SUCCESS && volName ) {
        LocalFree( volName );
    }

    if ( tempName ) {
        LocalFree( tempName );
    }

#if DBG
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] GetVolName: returns error %1!d!\n", dwError );
#endif

    return dwError;

}   // GetVolName


///////////////////// VolumeManagement code ends //////////////////////////////////////////

//////////////////// WatchedList //////////////////////
//
// We maintain a list of disks that are currently online
// and under cluster control. Any PnP notification
// coming for the volumes belonging to these disks,
// need to be processed and cluster registry might need
// to be updated
//

LIST_ENTRY  WatchedList;

PDISK_RESOURCE
FindDisk(DWORD Signature)
{
    PLIST_ENTRY entry;
    PDISK_RESOURCE watchedDisk = NULL;

    if ( !Signature ) {
        goto FnExit;
    }

    if ( IsListEmpty( &WatchedList ) ) {
        goto FnExit;
    }

    for ( entry = WatchedList.Flink;
          entry != &WatchedList;
          entry = entry->Flink ) {

        watchedDisk = CONTAINING_RECORD( entry,
                                         DISK_RESOURCE,
                                         PnpWatchedListEntry );

        if ( watchedDisk->DiskInfo.Params.Signature == Signature ) {
            goto FnExit;
        }

        watchedDisk = NULL;
    }

FnExit:

    return watchedDisk;
}

VOID
RemoveDisk(
    PDISK_RESOURCE ResourceEntry
    )
{
    (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_INFORMATION,
        L"[PnP] Stop watching PnP events for disk %1!x!\n",
        ResourceEntry->DiskInfo.Params.Signature );

    if ( IsListEmpty( &WatchedList ) ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] RemoveDisk: WatchedList is empty \n");
        goto FnExit;
    }

    if ( ResourceEntry->PnpWatchedListEntry.Flink == 0 ||
         ResourceEntry->PnpWatchedListEntry.Blink == 0 ) {
       (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
           L"[PnP] RemoveDisk: disk %1!x! not found or previously removed \n",
           ResourceEntry->DiskInfo.Params.Signature);
       goto FnExit;
    }

    RemoveEntryList( &ResourceEntry->PnpWatchedListEntry );
    ResourceEntry->PnpWatchedListEntry.Flink = 0;
    ResourceEntry->PnpWatchedListEntry.Blink = 0;

FnExit:

    (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_INFORMATION,
        L"[PnP] Stop watching disk %1!x! - processed \n",
        ResourceEntry->DiskInfo.Params.Signature );

    return;
}

VOID
MarkMatchingPartition(
    PVOLUME Volume,
    PDRIVE_LAYOUT_INFORMATION driveLayout)
/*++

Routine Description:

    Finds a partition in DRIVE_LAYOUT_INFORMATION corresponding to
    the Volume in question and marks it.
    This routine is used in the code that verifies that there is a
    volume in the VolumeList for every recognized partition on the disk.

Arguments:

Return Value:

    none

--*/
{
    PPARTITION_INFORMATION   p   = driveLayout->PartitionEntry;
    PPARTITION_INFORMATION   end = p + driveLayout->PartitionCount;

    for(;p < end; ++p)
    {
        if(p->RecognizedPartition &&
           p->StartingOffset.QuadPart == Volume->PartOffset.QuadPart &&
           p->PartitionLength.QuadPart == Volume->PartLength.QuadPart)
        {
            p->PartitionType = 1;
        }
    }
}

VOID
AddDisk(
    PDISK_RESOURCE ResourceEntry
    )
{
    DWORD idx;
    PDRIVE_LAYOUT_INFORMATION driveLayout = NULL;
    HANDLE fileHandle;
    WCHAR deviceName[MAX_PATH];
    PLIST_ENTRY entry;
    BOOL success;

    (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_INFORMATION,
        L"[PnP] Start watching PnP events for disk %1!x!\n",
        ResourceEntry->DiskInfo.Params.Signature );

    if ( ResourceEntry->PnpWatchedListEntry.Flink != NULL &&
         ResourceEntry->PnpWatchedListEntry.Blink != NULL ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] AddDisk: disk %1!x! is already being watched\n",
            ResourceEntry->DiskInfo.Params.Signature);
        goto FnExit;
    }

    InsertHeadList( &WatchedList, &ResourceEntry->PnpWatchedListEntry );

    // Now we need to verify that we are watching for changes on every //
    // recognized partition on this drive                              //

    if ( FAILED( StringCchPrintf( deviceName,
                                  RTL_NUMBER_OF(deviceName),
                                  TEXT("\\\\.\\PhysicalDrive%d"),
                                  ResourceEntry->DiskInfo.PhysicalDrive ) ) ) {
        goto FnExit;
    }

    fileHandle = CreateFile(deviceName,
                     GENERIC_READ | GENERIC_WRITE,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     0,
                     NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] AddDisk: Can't open %1!s!, error %2!d! \n", deviceName, GetLastError() );
        goto FnExit;
    }

    UpdateCachedDriveLayout( fileHandle );
    success = ClRtlGetDriveLayoutTable(fileHandle, &driveLayout, 0);
    CloseHandle( fileHandle );

    if ( !success ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_ERROR,
            L"[PnP] AddDisk: Error performing GetDriveLayout; error %1!d!\n",
            GetLastError() );
        goto FnExit;
    }

    // Clear PartitionType field. We will be using it to mark partions
    // which are in the our list of watched volumes

    for ( idx = 0; idx < (INT)driveLayout->PartitionCount; ++idx ) {
        driveLayout->PartitionEntry[idx].PartitionType = 0;
    }

    // Walk the list of all volumes and mark if this volume is in the partition table //
    for ( entry = VolumeList.Flink;
          entry != &VolumeList;
          entry = entry->Flink
        )
    {
        PVOLUME vol = CONTAINING_RECORD(
                       entry,
                       VOLUME,
                       ListEntry
                       );

        if (vol->Signature == driveLayout->Signature) {
            MarkMatchingPartition(vol, driveLayout);
        }
    }

    // Now all partitions that are in our list is marked
    // We need to add all unmarked partitions to the list

    for ( idx = 0; idx < (INT)driveLayout->PartitionCount; ++idx ) {
        if (driveLayout->PartitionEntry[idx].PartitionType == 0
            && driveLayout->PartitionEntry[idx].RecognizedPartition
            )
        {
            if ( FAILED( StringCchPrintf( deviceName,
                                          RTL_NUMBER_OF( deviceName ),
                                          GLOBALROOT_HARDDISK_PARTITION_FMT,
                                          ResourceEntry->DiskInfo.PhysicalDrive,
                                          driveLayout->PartitionEntry[idx].PartitionNumber ) ) ) {
                continue;
            }

            AddVolume( deviceName );
        }
    }

FnExit:

    if ( driveLayout ) {
        LocalFree( driveLayout );
    }

    (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_INFORMATION,
        L"[PnP] Start watching PnP events for disk %1!x! - processed \n",
        ResourceEntry->DiskInfo.Params.Signature );

}
//////////////////// WatchedList management end //////////////////////



void PokeDiskResource(
    PVOLUME vol)
/*++

Routine Description:

    Updates ClusterRegistry info if necessary

Arguments:

    Volume of interest (used only to get the disk signature)
    Updates a per disk basis

Return Value:

    None

--*/
{
    PDISK_RESOURCE ResourceEntry;
    MOUNTIE_INFO Info;
    HANDLE fileHandle;
    DWORD status;
    PVOID OldMountieVolume;
    WCHAR deviceName[MAX_PATH];

    ResourceEntry = FindDisk( vol->Signature );

    if ( !ResourceEntry ) {
        return;
    }

    if( ResourceEntry->MountieInfo.UpdateThreadIsActive ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] PokeDiskResource: ClusApi is read only. PnP request ignored\n");
        return;
    }

    ZeroMemory( &Info, sizeof(Info) );

    (VOID) StringCchPrintf( deviceName,
                            RTL_NUMBER_OF(deviceName),
                            TEXT("\\\\.\\PhysicalDrive%d"),
                            ResourceEntry->DiskInfo.PhysicalDrive );

    fileHandle = CreateFile(deviceName,
                     GENERIC_READ | GENERIC_WRITE,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     0,
                     NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] PokeDiskResource: Can't open %1!s!\n", deviceName);
        return;
    }

    status = MountieRecreateVolumeInfoFromHandle(
                fileHandle,
                ResourceEntry->MountieInfo.HarddiskNo,
                0,
                &Info);
    CloseHandle(fileHandle);

    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] PokeDiskResource: Can't read partition table, error %1!d!\n", status);
        return;
    }

    MountiePrint(&Info, ResourceEntry->ResourceHandle);

    status = VolumesReady(&Info, ResourceEntry);

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(ResourceEntry->ResourceHandle, LOG_WARNING,
            L"[PnP] PokeDiskResource: Volumes not ready, error %1!d!\n", status);
        MountieCleanup(&Info);
        return;
    }

    MountieVerify(&Info, ResourceEntry, TRUE);

    ResourceEntry->MountieInfo.DriveLetters = Info.DriveLetters;
    OldMountieVolume = InterlockedExchangePointer(&ResourceEntry->MountieInfo.Volume, Info.Volume);
    Info.Volume = OldMountieVolume;
    ResourceEntry->MountieInfo.NeedsUpdate = Info.NeedsUpdate;
    ResourceEntry->MountieInfo.VolumeStructSize = Info.VolumeStructSize;

    MountiePrint(&ResourceEntry->MountieInfo, ResourceEntry->ResourceHandle);
    MountieUpdate(&ResourceEntry->MountieInfo, ResourceEntry);

    MountieCleanup(&Info);
}

//
// [HACKHACK] Currently, there is not polically correct way
//  for the resource to learn whether it is a quorum resource or not
//
DWORD
GetQuorumSignature(
    OUT PDWORD QuorumSignature)
{
    WCHAR buf[MAX_PATH];
    WCHAR guid[ sizeof(GUID) * 3 + 1];
    // 2 character per byte + 1, in case somebody will put a dash //
    // between every byte                                         //

    DWORD BufSize;
    DWORD Status;
    DWORD Type;
    HKEY  Key;

    Status = RegOpenKey( HKEY_LOCAL_MACHINE,
                         DISKS_REG_CLUSTER_QUORUM,
                         &Key );
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    BufSize = sizeof(guid);
    Status = RegQueryValueExW(Key,
                              CLUSREG_NAME_QUORUM_RESOURCE,
                              0,
                              &Type,
                              (LPBYTE)guid,
                              &BufSize );
    RegCloseKey( Key );
    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    //
    // Now, we got a quorum resource guid.
    // Let's try to open this resource and read its parameters.
    //

    (VOID) StringCchPrintf( buf,
                            RTL_NUMBER_OF(buf),
                            TEXT("Cluster\\Resources\\%ws\\Parameters"),
                            guid );

    Status = RegOpenKey( HKEY_LOCAL_MACHINE,
                         buf,
                         &Key );
    if (Status != ERROR_SUCCESS) {
        return Status;
    }
    BufSize = sizeof(DWORD);
    Status = RegQueryValueExW(Key,
                              CLUSREG_NAME_PHYSDISK_SIGNATURE,
                              0,
                              &Type,
                              (LPBYTE)QuorumSignature,
                              &BufSize );
    if (Status != ERROR_SUCCESS) {

        // During cluster install, the registry key doesn't yet exist.

        (DiskpLogEvent)(RESOURCE_TYPE, LOG_WARNING,
            L"[PnP] DriveLetterChange: failed to open Path = %1!ws!\n", buf);
    }

    RegCloseKey(Key);
    return Status;
}

DWORD
CheckQuorumLetterChange(
    HDEVNOTIFY devNotify,
    UCHAR Old,
    UCHAR New,
    DWORD Signature)
{
    static HDEVNOTIFY QuorumDevNotify = 0;
    static UCHAR StoredDriveLetter = 0;
    DWORD status;
    UCHAR  QuorumDriveLetter;
    LPWSTR QuorumPath;
    DWORD  QuorumSignature;

    //
    // If we are not watching the disk this volume is on, do nothing
    //
    if ( FindDisk(Signature) == NULL ) {
        return ERROR_SUCCESS;
    }

    status = GetQuorumSignature(&QuorumSignature);
    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] DriveLetterChange: Unable to query quorum drive signature, status %1!u!\n", status);
        QuorumDevNotify = 0;
        StoredDriveLetter = 0;
        return status;
    }

    //
    // Not a quorum disk. Ignore this notification
    //
    if ( QuorumSignature != Signature ) {
        return ERROR_SUCCESS;
    }

    status = DiskspGetQuorumPath(&QuorumPath);
    if (status != ERROR_SUCCESS) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] DriveLetterChange: Unable to query quorum drive letter, status %1!u!\n", status);
        QuorumDevNotify = 0;
        StoredDriveLetter = 0;
        return status;
    }
    QuorumDriveLetter = (UCHAR) QuorumPath[0];

    if (QuorumDriveLetter == Old) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] DriveLetterChange: Quorum drive letter %1!c! is being changed\n", QuorumDriveLetter);
        QuorumDevNotify = devNotify;
        StoredDriveLetter = QuorumDriveLetter;
    }

    if (New && QuorumDevNotify == devNotify
        && QuorumDriveLetter != New
        && QuorumDriveLetter == StoredDriveLetter)
    {
        WCHAR szOld[2] = {QuorumDriveLetter, 0};
        WCHAR szNew[2] = {New, 0};

        ClusterLogEvent2(
            LOG_UNUSUAL, LOG_CURRENT_MODULE,
            __FILE__, __LINE__,
            RES_DISK_PNP_CHANGING_QUORUM,
            0, NULL,
            szOld, szNew);

        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] DriveLetterChange: Quorum drive letter changed from %1!c! to %2!c!\n",
            QuorumDriveLetter, New);
        QuorumPath[0] = New;
        status = DiskspSetQuorumPath(QuorumPath);
        if (status != ERROR_SUCCESS) {
            (DiskpLogEvent)(RESOURCE_TYPE, LOG_SEVERE,
                L"[PnP] DriveLetterChange: Unable to update QuorumPath (%1!c!: => %2!c!:), status %3!u!\n",
                QuorumDriveLetter, New, status);
        }
    }

    LocalFree(QuorumPath);
    return status;
}

VOID
ProcessDriveLetterChange( HDEVNOTIFY devNotify )
{
    PVOLUME vol = FindVolume(devNotify);
    CHAR ch;
    if (!vol) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] DriveLetterChange: devNotify %1!d! is not in the list\n", devNotify);
        return;
    }
    GetAssignedLetter(vol->Name, &ch);
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] DriveLetterChange: %1!c! => %2!c!\n",
                    NICE_DRIVE_LETTER(vol->DriveLetter),
                    NICE_DRIVE_LETTER(ch)
        );
    if (vol->PartitionType == PARTITION_IFS
     && vol->DriveLetter != ch)
    {
        CheckQuorumLetterChange(devNotify, vol->DriveLetter, ch, vol->Signature);
        PokeDiskResource(vol);
    }
    vol->DriveLetter = ch;
}

VOID
ProcessVolumeInfoChange( HDEVNOTIFY devNotify )
{
    PVOLUME vol = FindVolume(devNotify);
    BOOL success;
    HANDLE fileHandle = NULL;
    PARTITION_INFORMATION partInfo;
    DWORD bytesReturned;
    NTSTATUS ntStatus;

    if (!vol) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
            L"[PnP] VolumeInfoChange: devNotify %1!d! is not in the list\n", devNotify);
        return;
    }
    ntStatus = DevfileOpen(&fileHandle, vol->Name);
    if ( !NT_SUCCESS(ntStatus) || !fileHandle ) {
        (DiskpLogEvent)(
            RESOURCE_TYPE,
            LOG_ERROR,
            L"[PnP] VolumeInfoChange: Can't open %1!ws!, error %2!X!.\n",
            vol->Name, ntStatus);
        return;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_PARTITION_INFO,
                               NULL,
                               0,
                               &partInfo,
                               sizeof(PARTITION_INFORMATION),
                               &bytesReturned,
                               FALSE );

    DevfileClose( fileHandle );
    if (!success) {
        (DiskpLogEvent)(RESOURCE_TYPE, LOG_ERROR,
            L"[PnP] VolumeInfoChange: Error performing GetPartitionInfo; error %1!d!\n",
            GetLastError());
        return;
    }
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] VolumeInfoChange: partType %1!d! => %2!d!\n",
                    vol->PartitionType,
                    partInfo.PartitionType
                    );
    if (vol->PartitionType != partInfo.PartitionType
     && (partInfo.PartitionType == PARTITION_IFS
         || vol->PartitionType == PARTITION_IFS) )
    {
        PokeDiskResource(vol);
    }
    vol->PartitionType = partInfo.PartitionType;
}

//////////////////////////// WindowProc /////////////////////////////////////

#ifndef PDEV_BROADCAST_HEADER
typedef struct _DEV_BROADCAST_HEADER * PDEV_BROADCAST_HEADER;
#endif


LRESULT CALLBACK TestWndProc(
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
) {
    if (uMsg == WM_WatchDisk) {
        PDISK_RESOURCE p = (PDISK_RESOURCE)lParam;
        if (p) {
            AddDisk(p);
        }
        return TRUE;
    }
    if (uMsg == WM_StopWatchingDisk) {
        PDISK_RESOURCE p = (PDISK_RESOURCE)lParam;
        if (p) {
            RemoveDisk(p);
        }
        return TRUE;
    }
    if (uMsg != WM_DEVICECHANGE) {
        LRESULT result;

#if DBG
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] WM_DEVICECHANGE - calling DefWindowProc \n"
             );
#endif

        result = DefWindowProc(hwnd, uMsg, wParam, lParam);
#if DBG
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] WM_DEVICECHANGE - DefWindowProc returns %1!x! \n",
             result );
#endif

        return result;
    }

    if (!lParam) {
        return TRUE;
    }
#if DBG
    (DiskpLogEvent)(
         RESOURCE_TYPE,
         LOG_INFORMATION,
         L"[PnP] Event %1!x! received\n",
         wParam );
#endif
    switch( ((PDEV_BROADCAST_HEADER)lParam)->dbcd_devicetype )
    {
    case DBT_DEVTYP_DEVICEINTERFACE:
        {
            PDEV_BROADCAST_DEVICEINTERFACE p = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;

            if (wParam == DBT_DEVICEARRIVAL &&
                IsEqualGUID(&p->dbcc_classguid, &GUID_IO_VOLUME_DEVICE_INTERFACE)
               )
            {
                AddVolume( p->dbcc_name );
            }
            break;
        }
    case DBT_DEVTYP_HANDLE:
        {
            PDEV_BROADCAST_HANDLE p = (PDEV_BROADCAST_HANDLE)lParam;

            if (wParam == DBT_DEVICEREMOVECOMPLETE) {

                PVOLUME vol = 0;
                DWORD signature = 0;

                (DiskpLogEvent)(
                     RESOURCE_TYPE,
                     LOG_INFORMATION,
                     L"[PnP] Event DBT_DEVICEREMOVECOMPLETE received \n" );

                // First, save the signature because we are going
                // to remove the volume.

                vol = FindVolume( p->dbch_hdevnotify );
                if ( vol ) {
                    signature = vol->Signature;
                }

                RemoveVolume(p->dbch_hdevnotify);

                if ( signature ) {
                    ProcessMountPointChange( p->dbch_hdevnotify, signature );
                }

                (DiskpLogEvent)(
                     RESOURCE_TYPE,
                     LOG_INFORMATION,
                     L"[PnP] Event DBT_DEVICEREMOVECOMPLETE processed \n" );

            } else if (wParam == DBT_CUSTOMEVENT) {
                PVOLUME Vol = 0;

                Vol = FindVolume( p->dbch_hdevnotify );

                LOG_GUID_START( p, Vol );

                //
                // If we are watching this volume and it has a valid disk
                // resource structure, find out if we are re-creating the
                // drive letter.  If so, we can safely ignore the following
                // pnp events.
                //

                if ( Vol && Vol->Signature ) {

                    PDISK_RESOURCE  resourceEntry = NULL;

                    resourceEntry = FindDisk( Vol->Signature );

                    if ( resourceEntry &&
                         resourceEntry->IgnoreMPNotifications ) {

                        (DiskpLogEvent)(
                             RESOURCE_TYPE,
                             LOG_INFORMATION,
                             L"[PnP] Skipping event processing for signature %x \n",
                             Vol->Signature );

                        LOG_GUID_END( p, Vol );
                        break;
                    }
                }

                if ( IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_NAME_CHANGE) )
                {
                    // Update disk info.
                    GetVolumeInfo( Vol, NULL );
                    ProcessDriveLetterChange( p->dbch_hdevnotify );
                    ProcessMountPointChange( p->dbch_hdevnotify, 0 );
                }
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_CHANGE) )
                {
                    // Update disk info.
                    GetVolumeInfo( Vol, NULL );
                    ProcessVolumeInfoChange( p->dbch_hdevnotify );

                    if ( Vol ) {
                        ProcessMountPointChange( p->dbch_hdevnotify, Vol->Signature );
                    }
                }
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE) )
                {
                    // Update disk info.
                    GetVolumeInfo( Vol, NULL );
                    ProcessVolumeInfoChange( p->dbch_hdevnotify );

                    if ( Vol ) {
                        ProcessMountPointChange( p->dbch_hdevnotify, 0 );
                    }

                }
                else if (IsEqualGUID(&p->dbch_eventguid, &GUID_IO_VOLUME_MOUNT) )
                {
//                        ProcessDriveLetterChange( p->dbch_hdevnotify );
                }

                LOG_GUID_END( p, Vol );

            }

            break;
        }
    }
    return TRUE;
}


VOID
LogPnpGuid(
    PDEV_BROADCAST_HANDLE Broadcast,
    PVOLUME Vol,
    PWSTR BeginEndStr
    )
{
    PWCHAR guidName = 0;
    LPDWORD dw = (LPDWORD)&Broadcast->dbch_eventguid;

    if ( IsEqualGUID(&Broadcast->dbch_eventguid, &GUID_IO_VOLUME_NAME_CHANGE) )
    {
        guidName = L"GUID_IO_VOLUME_NAME_CHANGE";
    }
    else if (IsEqualGUID(&Broadcast->dbch_eventguid, &GUID_IO_VOLUME_CHANGE) )
    {
        guidName = L"GUID_IO_VOLUME_CHANGE";
    }
    else if (IsEqualGUID(&Broadcast->dbch_eventguid, &GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE) )
    {
        guidName = L"GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE";
    }
    else if (IsEqualGUID(&Broadcast->dbch_eventguid, &GUID_IO_VOLUME_LOCK) )
    {
#if DBG
        guidName = L"GUID_IO_VOLUME_LOCK";
#else
        return;
#endif
    }
    else if (IsEqualGUID(&Broadcast->dbch_eventguid, &GUID_IO_VOLUME_UNLOCK) )
    {
#if DBG
        guidName = L"GUID_IO_VOLUME_UNLOCK";
#else
        return;
#endif
    }
    else if (IsEqualGUID(&Broadcast->dbch_eventguid, &GUID_IO_VOLUME_MOUNT) )
    {
#if DBG
        guidName = L"GUID_IO_VOLUME_MOUNT";
#else
        return;
#endif
    }
    else if (IsEqualGUID(&Broadcast->dbch_eventguid, &GUID_IO_VOLUME_DISMOUNT) )
    {
        guidName = L"GUID_IO_VOLUME_DISMOUNT";
    }
    else if (IsEqualGUID(&Broadcast->dbch_eventguid, &GUID_IO_VOLUME_LOCK_FAILED) )
    {
        guidName = L"GUID_IO_VOLUME_LOCK_FAILED";
    }
    else if (IsEqualGUID(&Broadcast->dbch_eventguid, &GUID_IO_VOLUME_DISMOUNT_FAILED) )
    {
        guidName = L"GUID_IO_VOLUME_DISMOUNT_FAILED";
    }

    if (guidName) {
        if (Vol) {
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] Event %1!s! for %2!c! (Partition%3!d!) - %4!s! \n",
                 guidName, NICE_DRIVE_LETTER(Vol->DriveLetter), Vol->PartNo,
                 BeginEndStr );
        } else {
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] Event %1!s! for %2!d! - %3!s! \n",
                 guidName, Broadcast->dbch_hdevnotify,
                 BeginEndStr );
        }
    } else {
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] Event %2!x! %3!x! %4!x! %5!x! for %1!d! - %6!s! \n",
             Broadcast->dbch_hdevnotify, dw[0], dw[1], dw[2], dw[3],
             BeginEndStr );
    }


}   // LogPnpGuid


VOID
AddVolumes()
/*++

Routine Description:

    Enumerate all known volumes and register for the notifications on these volumes

Arguments:

    None

Return Value:

    None

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pDiDetail = NULL;

    DWORD                       dwError = ERROR_SUCCESS;
    DWORD                       count;
    DWORD                       sizeDiDetail;

    LONG                        oldValue;

    BOOL                        result;

    HDEVINFO                    hdevInfo = INVALID_HANDLE_VALUE;

    SP_DEVICE_INTERFACE_DATA    devInterfaceData;
    SP_DEVINFO_DATA             devInfoData;

    //
    // If this routine is currently running, the old value will be 1.  If so,
    // we don't need to run again.  This call will set the flag to 1 if it is 0.
    //

    oldValue = InterlockedCompareExchange( &VolumeListUpdateInProcess,
                                           1,
                                           0 );

    if ( 1 == oldValue ) {
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] AddVolumes: Volume list update in process, skipping update \n" );
        goto FnExit;
    }

    //
    // Get a device interface set which includes all volume devices
    // present on the machine. VolumeClassGuid is a predefined GUID that
    // will return all volume-type device interfaces
    //

    hdevInfo = SetupDiGetClassDevs( &VolumeClassGuid,
                                    NULL,
                                    NULL,
                                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );

    if ( INVALID_HANDLE_VALUE == hdevInfo ) {
        dwError = GetLastError();
        goto FnExit;
    }

    ZeroMemory( &devInterfaceData, sizeof( SP_DEVICE_INTERFACE_DATA) );

    //
    // Iterate over all devices interfaces in the set
    //

    for ( count = 0; ; count++ ) {

        // must set size first
        devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        //
        // Retrieve the device interface data for each device interface
        //

        result = SetupDiEnumDeviceInterfaces( hdevInfo,
                                              NULL,
                                              &VolumeClassGuid,
                                              count,
                                              &devInterfaceData );

        if ( !result ) {

            //
            // If we retrieved the last item, break
            //

            dwError = GetLastError();

            if ( ERROR_NO_MORE_ITEMS == dwError ) {
                dwError = ERROR_SUCCESS;
                break;

            }

            //
            // Some other error occurred.  Stop processing.
            //

            goto FnExit;
        }

        //
        // Get the required buffer-size for the device path.  Note that
        // this call is expected to fail with insufficient buffer error.
        //

        result = SetupDiGetDeviceInterfaceDetail( hdevInfo,
                                                  &devInterfaceData,
                                                  NULL,
                                                  0,
                                                  &sizeDiDetail,
                                                  NULL
                                                  );

        if ( !result ) {

            dwError = GetLastError();

            //
            // If a value other than "insufficient buffer" is returned,
            // we have to skip this device.
            //

            if ( ERROR_INSUFFICIENT_BUFFER != dwError ) {
                continue;
            }

        } else {

            //
            // The call should have failed since we're getting the
            // required buffer size.  If it doesn't fail, something bad
            // happened.
            //

            continue;
        }

        //
        // Allocate memory for the device interface detail.
        //

        pDiDetail = LocalAlloc( LPTR, sizeDiDetail );

        if ( !pDiDetail ) {
            dwError = GetLastError();
            goto FnExit;
        }

        // must set the struct's size member

        pDiDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        //
        // Finally, retrieve the device interface detail info.
        //

        result = SetupDiGetDeviceInterfaceDetail( hdevInfo,
                                                  &devInterfaceData,
                                                  pDiDetail,
                                                  sizeDiDetail,
                                                  NULL,
                                                  &devInfoData
                                                  );

        if ( !result ) {

            dwError = GetLastError();

            LocalFree( pDiDetail );
            pDiDetail = NULL;

            //
            // Shouldn't fail, if it does, try the next device.
            //

            continue;
        }

#if DBG
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] AddVolumes: Found volume %1!ws! \n",
             pDiDetail->DevicePath );
#endif

        AddVolume( pDiDetail->DevicePath );

        LocalFree( pDiDetail );
        pDiDetail = NULL;

    }

FnExit:

    //
    // If old update value was zero, then it is now 1.  Reset it to
    // zero so another update can take place if needed.
    //

    if ( 0 == oldValue ) {
        InterlockedExchange( &VolumeListUpdateInProcess, 0 );
    }

    if ( INVALID_HANDLE_VALUE != hdevInfo ) {
        SetupDiDestroyDeviceInfoList( hdevInfo );
    }

    if ( pDiDetail ) {
        LocalFree( pDiDetail );
    }

#if DBG
    if ( ERROR_SUCCESS != dwError ) {
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_WARNING,
             L"[PnP] AddVolumes: returns error %1!d! \n",
             dwError );
    }
#endif

}   // AddVolumes


DWORD
GetVolumeInfo(
    PVOLUME Vol,
    PHANDLE FileHandle
    )
/*++

Routine Description:

    Get drive layout info and partition info for the specified volume.

Arguments:

    Vol - Pointer to PVOLUME structure.  Caller is responsible for allocating
          and freeing.

    FileHandle - Returned handle to volume.  Caller is responsible for closing.
                 This parameter is optional.  If not specified by the user,
                 the volume handle will be closed by this routine.

Return Value:

    Win32 error value.

--*/
{
    PARTITION_INFORMATION partInfo;
    PDRIVE_LAYOUT_INFORMATION driveLayout;

    DWORD status = ERROR_SUCCESS;
    DWORD bytesReturned;
    DWORD oldValue;
    NTSTATUS ntStatus;

    HANDLE hFile = NULL;

    BOOL success;

    //
    // If no VOL parameter specified or the signature is already set,
    // we don't need to update the volume information.
    //
    if ( !Vol || Vol->Signature ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( FileHandle ) {
        *FileHandle = INVALID_HANDLE_VALUE;
    }

#if DBG
    (DiskpLogEvent)(RESOURCE_TYPE, LOG_INFORMATION,
        L"[PnP] GetVolumeInfo: Updating info: %1!s!\n", Vol->Name );
#endif

    ntStatus = DevfileOpen(&hFile, Vol->Name);
    if ( !NT_SUCCESS(ntStatus) ) {
        (DiskpLogEvent)(
            RESOURCE_TYPE,
            LOG_ERROR,
            L"[PnP] GetVolumeInfo: error opening: %1!ws!, error %2!X!.\n",
            Vol->Name, ntStatus);

        return RtlNtStatusToDosError(ntStatus);
    }

    //
    // If update already in progress for this disk, skip the update.
    //

    oldValue = InterlockedCompareExchange( &Vol->UpdateActive,
                                           1,
                                           0 );

    if ( 1 == oldValue ) {
        (DiskpLogEvent)(
            RESOURCE_TYPE,
            LOG_WARNING,
            L"[PnP] GetVolumeInfo: Skip update:   %1!ws! \n",
            Vol->Name);
        goto FnExit;
    }

    success = DeviceIoControl( hFile,
                               IOCTL_DISK_GET_PARTITION_INFO,
                               NULL,
                               0,
                               &partInfo,
                               sizeof(PARTITION_INFORMATION),
                               &bytesReturned,
                               FALSE );

    if (!success) {

        status = GetLastError();

        // Change this from LOG_ERROR to LOG_WARNING.  This thread gets
        // notified when non-fixed disks arrive (i.e. floppy), so logging
        // an error for a floppy disk is misleading.

        (DiskpLogEvent)(RESOURCE_TYPE, LOG_WARNING,
            L"[PnP] GetVolumeInfo: GetPartitionInfo (%1!ws!), error %2!u!\n",
            Vol->Name, status);

        goto FnExit;
    }

    Vol->PartOffset = partInfo.StartingOffset;
    Vol->PartLength = partInfo.PartitionLength;
    Vol->PartNo     = partInfo.PartitionNumber;
    Vol->PartitionType = partInfo.PartitionType;

    success = ClRtlGetDriveLayoutTable(hFile, &driveLayout, 0);

    if ( !success ) {

        status = GetLastError();

        if ( ERROR_NOT_READY != status ) {
            (DiskpLogEvent)(RESOURCE_TYPE, LOG_WARNING,
                L"[PnP] GetVolumeInfo: GetDriveLayout (%1!ws!), error %2!u!\n",
                Vol->Name,
                status );
        }

        goto FnExit;
    }

    Vol->Signature = driveLayout->Signature;

    LocalFree(driveLayout);

    GetAssignedLetter(Vol->Name, &Vol->DriveLetter);

FnExit:

    if ( FileHandle ) {
        *FileHandle = hFile;
    } else {
        DevfileClose( hFile );
    }

    //
    // If old update value was zero, then it is now 1.  Reset it to
    // zero so another update can take place if needed.
    //

    if ( 0 == oldValue ) {
        InterlockedExchange( &Vol->UpdateActive, 0 );
    }

    return status;

}   // GetVolumeInfo


DWORD
NotificationWatcherThread(
    IN LPVOID unused
    )

/*++

Routine Description:

    Creates window. Process messages until WM_QUIT is received

Arguments:

    unused

Return Value:

    status

--*/

{
    WNDCLASSEX cl;
    ATOM classAtom;
    DWORD status = ERROR_SUCCESS;
    static WCHAR* clsname = L"RESDLL!DISKS!MESSAGEWND";
    HDEVNOTIFY devNotify = 0;
    MSG msg;

    try {

        SetErrorMode(SEM_FAILCRITICALERRORS);
        InitializeListHead( &VolumeList );
        InitializeListHead( &WaitingDisks );
        InitializeListHead( &WatchedList );

        ZeroMemory( &cl, sizeof(cl) );

        cl.cbSize = sizeof(cl);
        cl.lpfnWndProc = TestWndProc;
        cl.lpszClassName = clsname;

        classAtom = RegisterClassEx( &cl );
        if (classAtom == 0) {
            status = GetLastError();
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_ERROR,
                 L"[PnP] Failed to register window class, error %1!u!.\n", status );
            return status;
        }

        DummyWindow = CreateWindowEx(
            0,            // extended window style
            clsname,    // pointer to registered class name
            L"ClusterDiskPnPWatcher",// pointer to window name
            0,            // window style
            0,            // horizontal position of window
            0,            // vertical position of window
            0,            // window width
            0,            // window height
            HWND_MESSAGE, // handle to parent or owner window
            0,            // handle to menu, or child-window identifier
            0,            // handle to application instance (ignored on NT)
            NULL          // pointer to window-creation data
        );
        if (DummyWindow == 0) {
            status = GetLastError();
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_ERROR,
                 L"[PnP] Failed to create message window, error %u.\n", status );
            UnregisterClass( clsname , 0);
            return status;
        }

        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] PnP window created successfully.\n");

        //
        // Call AddVolumes after registering for device arrival notification.
        //
        status = RegisterDeviceInterface(DummyWindow, &MOUNTDEV_MOUNTED_DEVICE_GUID, &devNotify);
        AddVolumes();

        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_INFORMATION,
             L"[PnP] PnP interface registration complete.\n");

        if ( NULL != PnpInterfacesRegistered ) {
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] Setting PnP interface registration event.\n");
            SetEvent( PnpInterfacesRegistered );
        }

        if (status == ERROR_SUCCESS) {
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] NotifierThread is waiting for messages.\n");
            while(GetMessage(&msg, 0, 0, 0)) {
                if (msg.message == WM_QUIT) {
                    break;
                }
                DispatchMessage(&msg);
            }
            MyUnregisterDeviceNotification( devNotify );
#if 0
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_INFORMATION,
                 L"[PnP] NotifierThread is shutting down.\n");
#endif
        } else {
            (DiskpLogEvent)(
                 RESOURCE_TYPE,
                 LOG_ERROR,
                 L"[PnP] Unable to register for MOUNTDEV_MOUNTED_DEVICE_GUID, error %1!u!.\n", status );
        }

        DestroyWindow( DummyWindow );
        DummyWindow = 0;
        UnregisterClass( clsname , 0 );

        // Use a lock here as the online thread might be parsing the volume list.
        AcquireExclusive( &PnpVolumeLock );
        while ( !IsListEmpty(&VolumeList) ) {
            PLIST_ENTRY listEntry;
            PVOLUME vol;
            listEntry = RemoveHeadList(&VolumeList);
            vol = CONTAINING_RECORD( listEntry,
                                     VOLUME,
                                     ListEntry );
            DestroyVolume(vol);
        }
        ReleaseExclusive( &PnpVolumeLock );
#if 0
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] PnpThread: Volumes destroyed.\n");
#endif

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // We can leave without this thread
        //
        status = GetExceptionCode();
        (DiskpLogEvent)(
             RESOURCE_TYPE,
             LOG_ERROR,
             L"[PnP] PnpThread: Exception caught, error %1!u!.\n", status );
    }

    InterlockedCompareExchange(&PnPInitialized, FALSE, TRUE);
    return status;
}


VOID
ProcessMountPointChange(
    HDEVNOTIFY devNotify,
    DWORD Signature
    )
/*++

Routine Description:

    Updates mount point info in the cluster registry.

Arguments:

    devNotify - Handle to the device notification.

    Signature - Disk signature when a volume is being added or removed
                from the system.  If zero, then volume is not added
                or removed.

Return Value:

    None

--*/
{
    PDISK_RESOURCE resourceEntry;
    PVOLUME vol = 0;
    DWORD diskSig = 0;

    if ( !Signature ) {

        //
        // Get the volume for the device notification.
        //

        vol = FindVolume( devNotify );

        if ( !vol ) {

            (DiskpLogEvent)(
                RESOURCE_TYPE,
                LOG_INFORMATION,
                L"[PnP] ProcessMountPointChange: devNotify %1!d! is not in the list \n",
                devNotify );
            return;
        }

        diskSig = vol->Signature;

    } else {

        diskSig = Signature;
    }

    //
    // Search the WatchedList to find a disk that matches the signature.
    // If no entry found, we are not watching this disk.
    //

    resourceEntry = FindDisk( diskSig );

    if ( !resourceEntry ) {
        (DiskpLogEvent)(
            RESOURCE_TYPE,
            LOG_INFORMATION,
            L"[PnP] ProcessMountPointChange: Unable to get ResourceEntry for signature %1!x! \n",
            diskSig );
        return;
    }

    //
    // If disk not online, don't do anything.
    //

    if ( !resourceEntry->Valid ) {
        return;
    }

    //
    // If a new volume is being added to or removed from the system, then
    // rebuild the mountpoint list.  Otherwise, just validate mountpoints.
    //

    if ( Signature ) {
        DisksProcessMountPointInfo( resourceEntry );
    } else {
        DisksUpdateMPList( resourceEntry );
    }

}   // ProcessMountPointChange



//////////////////////////////////////////////////////////////////////////////////



DWORD
QueueWaitForVolumeEvent(
    HANDLE Event,
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Queues a request to watch for particular volume arrivals.
    The event will be signaled only when all volumes are
    available on the system.

Arguments:

    Event - event to be signaled when all volumes for the specified
            disk are available.

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

Return Value:

    ERROR_SUCCESS - request queued.

    Win32 error on failure.

--*/
{
    PWAITING_DISK   waitDisk;
    PMOUNTIE_VOLUME mountVol = ResourceEntry->MountieInfo.Volume;

    DWORD   dwError = ERROR_SUCCESS;

    waitDisk = LocalAlloc( LPTR, sizeof(WAITING_DISK) );

    if ( !waitDisk ) {
        dwError = GetLastError();
        (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_ERROR,
             L"[PnP] QueueWaitForVolumeEvent: can't allocate storage for disk entry. Error %1!u! \n",
             dwError );
        goto FnExit;
    }

    waitDisk->ResourceEntry = ResourceEntry;
    waitDisk->Event = Event;
    waitDisk->Signature = mountVol->Signature;
    waitDisk->PartitionCount = mountVol->PartitionCount;

    AcquireExclusive( &PnpWaitingListLock );
    InsertHeadList( &WaitingDisks, &waitDisk->ListEntry );
    ReleaseExclusive( &PnpWaitingListLock );

FnExit:

    return dwError;

}   // QueueWaitForVolumeEvent


BOOL
IsDiskInPnpVolumeList(
    PDISK_RESOURCE ResourceEntry,
    BOOL UpdateVolumeList
    )
/*++

Routine Description:

    Checks all the volumes currently known by the PnP thread and see if
    all volumes for the specified disk are recognized.

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

    UpdateVolumeList - TRUE means call AddVolumes to make sure all volumes
                       are in the volume list.

Return Value:

    TRUE - If all volumes for the specified disk are available on the system.

--*/
{
    PLIST_ENTRY entry;
    PVOLUME vol = 0;
    PMOUNTIE_VOLUME mountVol = ResourceEntry->MountieInfo.Volume;

    DWORD partitionCount = 0;

    BOOL retVal = FALSE;

    partitionCount = 0;
    AcquireShared( &PnpVolumeLock );

    for ( entry = VolumeList.Flink;
          entry != &VolumeList;
          entry = entry->Flink
        )
    {
        vol = CONTAINING_RECORD(
                   entry,
                   VOLUME,
                   ListEntry
                   );

        GetVolumeInfo( vol, NULL );

        if ( vol->Signature && vol->Signature == mountVol->Signature ) {
            partitionCount++;
        }
    }

    ReleaseShared( &PnpVolumeLock );

    //
    // Might be some non-NTFS partitions on the disk, so if there
    // are more volumes than partitions, we are good.
    //

    retVal =  ( partitionCount >= mountVol->PartitionCount ) ? TRUE : FALSE;

    //
    // If we didn't find all the volumes, ask system to walk through the
    // volumes again.
    //

    if ( !retVal && UpdateVolumeList ) {

        //
        // This call shouldn't be required.  However, sometimes we can't
        // find volumes that should be available.  So we need to walk through
        // the pnp list again.
        //
        AddVolumes();

        //
        // Walk the list one more time...
        //

        partitionCount = 0;
        AcquireShared( &PnpVolumeLock );

        for ( entry = VolumeList.Flink;
              entry != &VolumeList;
              entry = entry->Flink
            )
        {
            vol = CONTAINING_RECORD(
                       entry,
                       VOLUME,
                       ListEntry
                       );

            GetVolumeInfo( vol, NULL );

            if ( vol->Signature && vol->Signature == mountVol->Signature ) {
                partitionCount++;
            }
        }

        ReleaseShared( &PnpVolumeLock );

        //
        // Might be some non-NTFS partitions on the disk, so if there
        // are more volumes than partitions, we are good.
        //

        retVal =  ( partitionCount >= mountVol->PartitionCount ) ? TRUE : FALSE;
    }

    return retVal;

}   // IsDiskInPnpVolumeList


PWAITING_DISK
FindWaitingDisk(
    DWORD Signature
    )
/*++

Routine Description:

    Find the entry in the waiting list for the specified disk
    signature.

    The caller will hold the critical section.

Arguments:

    Signature - Disk signature of the entry to be removed.

Return Value:

    Pointer to a WAITING_DISK entry for the disk.

    NULL if entry not found.

--*/
{
    PLIST_ENTRY entry;
    PWAITING_DISK waitDisk = NULL;

    if ( !Signature ) {
        goto FnExit;
    }

    for ( entry = WaitingDisks.Flink;
          entry != &WaitingDisks;
          entry = entry->Flink
        )
    {
        waitDisk = CONTAINING_RECORD( entry,
                                      WAITING_DISK,
                                      ListEntry
                                      );

        if ( waitDisk->Signature == Signature ) {
            goto FnExit;
        }

        waitDisk = 0;
    }

FnExit:

    return waitDisk;

}   // FindWaitingDisk


DWORD
RemoveWaitForVolumeEvent(
    PDISK_RESOURCE ResourceEntry
    )
/*++

Routine Description:

    Remove from the disk waiting list the entry for the specified disk.

Arguments:

    ResourceEntry - A pointer to the DISK_RESOURCE block for this resource.

Return Value:


--*/
{
    PWAITING_DISK   waitDisk = NULL;
    PMOUNTIE_VOLUME mountVol = ResourceEntry->MountieInfo.Volume;

    AcquireExclusive( &PnpWaitingListLock );

    waitDisk = FindWaitingDisk( mountVol->Signature );

    if ( !waitDisk ) {
#if DBG
        (DiskpLogEvent)(
             ResourceEntry->ResourceHandle,
             LOG_INFORMATION,
             L"[PnP] RemoveWaitForVolumeEvent: can't locate waiting volume in list \n" );
#endif
        ReleaseExclusive( &PnpWaitingListLock );
        return ERROR_INVALID_PARAMETER;
    }

    RemoveEntryList( &waitDisk->ListEntry );
    ReleaseExclusive( &PnpWaitingListLock );

    LocalFree( waitDisk );

    return ERROR_SUCCESS;

}   // RemoveWaitForVolumeEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\extdll\dll\passthru.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define BOOT_SECTOR_SIZE    512



BOOLEAN
WINAPI
PassThruDllEntry(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
/*++

Routine Description:

    Main DLL entrypoint

Arguments:

    DllHandle - Supplies the DLL handle.

    Reason - Supplies the call reason

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
   switch ( Reason ) {

   case DLL_PROCESS_ATTACH:
      // DLL is attaching to the address
      // space of the current process.

      break;

   case DLL_THREAD_ATTACH:
      // A new thread is being created in the current process.
      break;

   case DLL_THREAD_DETACH:
      // A thread is exiting cleanly.
      break;

   case DLL_PROCESS_DETACH:
      // The calling process is detaching
      // the DLL from its address space.

      break;
   }

   return(TRUE);
}


DWORD
WINAPI
TestDllGetBootSector(
    IN LPSTR DeviceName,
    IN LPSTR ContextStr,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    HANDLE  hDisk = NULL;
    
    DWORD   dwStatus = NO_ERROR;
    
    UNREFERENCED_PARAMETER( ContextStr );
    
    if ( !DeviceName || !OutBuffer || !BytesReturned ) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    
    if ( OutBufferSize < BOOT_SECTOR_SIZE ) {
        *BytesReturned = BOOT_SECTOR_SIZE;
        dwStatus = ERROR_MORE_DATA;
        goto FnExit;    
    }
    
    //
    // Open a handle to the disk drive.
    //

    hDisk = CreateFile( DeviceName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        0,                               // No security attributes
                        OPEN_EXISTING,
                        FILE_FLAG_NO_BUFFERING,
                        NULL                             // No template file
                        );


    if ( INVALID_HANDLE_VALUE ==  hDisk ) {
        dwStatus = GetLastError();
        goto FnExit;
    }

    //
    // Clear out the array holding the boot sector.
    //

    ZeroMemory( OutBuffer, BOOT_SECTOR_SIZE );

    //
    // Read the boot sector.
    //

    if ( !ReadFile( hDisk,
                    OutBuffer,
                    BOOT_SECTOR_SIZE,
                    BytesReturned,
                    NULL
                    ) ) {

        dwStatus = GetLastError();
        goto FnExit;
    }

    if ( *BytesReturned != BOOT_SECTOR_SIZE ) {
        dwStatus = ERROR_BAD_LENGTH;
        goto FnExit;
    }

FnExit:

    if ( hDisk ) {
        CloseHandle( hDisk );
    }
    
    return dwStatus;
    

}   // TestDllGetBootSector


DWORD
WINAPI
TestDllReturnContextAsError(
    IN LPSTR DeviceName,
    IN LPSTR ContextStr,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    DWORD   dwStatus = NO_ERROR;
    
    UNREFERENCED_PARAMETER( DeviceName );
    UNREFERENCED_PARAMETER( OutBuffer );
    UNREFERENCED_PARAMETER( OutBufferSize );

    if ( !BytesReturned ) {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    *BytesReturned = 0;

    //
    // Convert context string to a DWORD value.  Note that
    // strtol will return zero if it can't convert the string.
    // Zero happens to be NO_ERROR.
    //
    
    dwStatus = strtol( ContextStr, NULL, 10 );
    
FnExit:
    
    return dwStatus;

}   // TestDllReturnContextAsError


DWORD
WINAPI
TestDllNotEnoughParms(
    IN LPSTR DeviceName
    )
{
    //
    // This routine _should_ fail and possibly cause a stack exception.
    //
    
    UNREFERENCED_PARAMETER( DeviceName );

    return NO_ERROR;    

}   // TestDllNotEnoughParms

       
DWORD
WINAPI
TestDllTooManyParms(
    IN LPSTR DeviceName,
    IN LPSTR ContextStr,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    IN PVOID Nada1,
    IN PVOID Nada2,
    IN PVOID Nada3
    )
{
    //
    // This routine _should_ fail and possibly cause a stack exception.
    //
    
    UNREFERENCED_PARAMETER( DeviceName );
    UNREFERENCED_PARAMETER( ContextStr );
    UNREFERENCED_PARAMETER( OutBuffer );
    UNREFERENCED_PARAMETER( OutBufferSize );
    UNREFERENCED_PARAMETER( BytesReturned );
    UNREFERENCED_PARAMETER( Nada1 );
    UNREFERENCED_PARAMETER( Nada2 );
    UNREFERENCED_PARAMETER( Nada3 );

    return NO_ERROR;
    
}   // TestDllTooManyParms
    
    
DWORD
WINAPI
TestDllCauseException(
    IN LPSTR DeviceName,
    IN LPSTR ContextStr,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )
{
    DWORD   x = 0;
    DWORD   y;
    
    UNREFERENCED_PARAMETER( DeviceName );
    UNREFERENCED_PARAMETER( ContextStr );
    UNREFERENCED_PARAMETER( OutBuffer );
    UNREFERENCED_PARAMETER( OutBufferSize );
    UNREFERENCED_PARAMETER( BytesReturned );

    //
    // How about divide by zero?
    //
    
    y = 7 / x;
    
    return NO_ERROR;

}   // CauseException
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummy\dummy.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//
//		Dummy.cpp
//
//	Abstract:
//
//		Resource DLL for Dummy (Dummy).
//
//	Author:
//
//		Galen Barbee (galenb)	Sept 03, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma comment(lib, "clusapi.lib")
#pragma comment(lib, "resutils.lib")

#define UNICODE 1

#pragma warning( disable : 4115 )	// named type definition in parentheses
#pragma warning( disable : 4201 )	// nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )	// nonstandard extension used : bit field types other than int

#include <windows.h>

#pragma warning( default : 4214 )	// nonstandard extension used : bit field types other than int
#pragma warning( default : 4201 )	// nonstandard extension used : nameless struct/union
#pragma warning( default : 4115 )	// named type definition in parentheses

#include <clusapi.h>
#include <resapi.h>
#include <stdio.h>

//
// Type and constant definitions.
//
#define DUMMY_RESNAME	L"Dummy"
#define DBG_PRINT		printf

#define MAX_WAIT		(10000)			 // wait for 10 seconds

#define DUMMY_FLAG_VALID	0x00000001
#define DUMMY_FLAG_ASYNC	0x00000002		// Asynchronous failure mode
#define DUMMY_FLAG_PENDING	0x00000004		// Pending mode on shutdown

#define AsyncMode(Resource)		 (Resource->Flags &	DUMMY_FLAG_ASYNC)
#define PendingMode(Resource)		(Resource->Flags &	DUMMY_FLAG_PENDING)
#define EnterAsyncMode(Resource)	(Resource->Flags |= DUMMY_FLAG_ASYNC)

#define DummyAcquireResourceLock(_res)	EnterCriticalSection(&((_res)->Lock))
#define DummyReleaseResourceLock(_res)	LeaveCriticalSection(&((_res)->Lock))

#define DummyAcquireGlobalLock()	\
			{						\
				DWORD status;		\
				status = WaitForSingleObject( DummyGlobalMutex, INFINITE );	\
			}

#define DummyReleaseGlobalLock()	\
			{						\
				BOOLEAN released;	\
				released = ReleaseMutex( DummyGlobalMutex );	\
			}

//
// ADDPARAM: Add new parameters here.
//
#define PARAM_NAME__PENDING		 L"Pending"
#define PARAM_NAME__PENDTIME		L"PendTime"
#define PARAM_NAME__OPENSFAIL		L"OpensFail"
#define PARAM_NAME__FAILED			L"Failed"
#define PARAM_NAME__ASYNCHRONOUS	L"Asynchronous"

#define PARAM_MIN__PENDING			(0)
#define PARAM_MAX__PENDING			(1)
#define PARAM_DEFAULT__PENDING		(0)
#define PARAM_MIN__PENDTIME		 (0)
#define PARAM_MAX__PENDTIME		 (4294967295)
#define PARAM_DEFAULT__PENDTIME	 (0)
#define PARAM_MIN__OPENSFAIL		(0)
#define PARAM_MAX__OPENSFAIL		(1)
#define PARAM_DEFAULT__OPENSFAIL	(0)
#define PARAM_MIN__FAILED			(0)
#define PARAM_MAX__FAILED			(1)
#define PARAM_DEFAULT__FAILED		(0)
#define PARAM_MIN__ASYNCHRONOUS	 (0)
#define PARAM_MAX__ASYNCHRONOUS	 (1)
#define PARAM_DEFAULT__ASYNCHRONOUS (0)

typedef enum TimerType
{
	TimerNotUsed = 0,
	TimerErrorPending,
	TimerOnlinePending,
	TimerOfflinePending
};

//
// ADDPARAM: Add new parameters here.
//
typedef struct _DUMMY_PARAMS
{
	DWORD	Pending;
	DWORD	PendTime;
	DWORD	OpensFail;
	DWORD	Failed;
	DWORD	Asynchronous;
} DUMMY_PARAMS, *PDUMMY_PARAMS;

typedef struct _DUMMY_RESOURCE
{
	RESID					ResId; // for validation
	DUMMY_PARAMS			Params;
	HKEY					ParametersKey;
	RESOURCE_HANDLE		 ResourceHandle;
	LPWSTR					ResourceName;
	CLUS_WORKER			 OnlineThread;
	CLUS_WORKER			 OfflineThread;
	CLUSTER_RESOURCE_STATE	State;
	DWORD					Flags;
	HANDLE					SignalEvent;
	HANDLE					TimerThreadWakeup;
	DWORD					TimerType;
	CRITICAL_SECTION		Lock;
} DUMMY_RESOURCE, *PDUMMY_RESOURCE;

//
// Global data.
//

// Sync Mutex

HANDLE	DummyGlobalMutex = NULL;

// Event Logging routine.

PLOG_EVENT_ROUTINE g_LogEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL;

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_DummyFunctionTable;

//
// Dummy resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
DummyResourcePrivateProperties[] =
{
	{ PARAM_NAME__PENDING,		NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__PENDING,		PARAM_MIN__PENDING,		 PARAM_MAX__PENDING,		 0, FIELD_OFFSET(DUMMY_PARAMS,Pending) },
	{ PARAM_NAME__PENDTIME,	 NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__PENDTIME,		PARAM_MIN__PENDTIME,		PARAM_MAX__PENDTIME,		0, FIELD_OFFSET(DUMMY_PARAMS,PendTime) },
	{ PARAM_NAME__OPENSFAIL,	NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__OPENSFAIL,		PARAM_MIN__OPENSFAIL,		PARAM_MAX__OPENSFAIL,		0, FIELD_OFFSET(DUMMY_PARAMS,OpensFail) },
	{ PARAM_NAME__FAILED,		NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__FAILED,		 PARAM_MIN__FAILED,			PARAM_MAX__FAILED,			0, FIELD_OFFSET(DUMMY_PARAMS,Failed) },
	{ PARAM_NAME__ASYNCHRONOUS, NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__ASYNCHRONOUS,	PARAM_MIN__ASYNCHRONOUS,	PARAM_MAX__ASYNCHRONOUS,	0, FIELD_OFFSET(DUMMY_PARAMS,Asynchronous) },
	{ 0 }
};

//
// Function prototypes.
//

DWORD WINAPI Startup(
	IN LPCWSTR ResourceType,
	IN DWORD MinVersionSupported,
	IN DWORD MaxVersionSupported,
	IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
	IN PLOG_EVENT_ROUTINE LogEvent,
	OUT PCLRES_FUNCTION_TABLE *FunctionTable
	);

RESID WINAPI DummyOpen(
	IN LPCWSTR ResourceName,
	IN HKEY ResourceKey,
	IN RESOURCE_HANDLE ResourceHandle
	);

void WINAPI DummyClose(
	IN RESID ResourceId
	);

DWORD WINAPI DummyOnline(
	IN RESID		ResourceId,
	IN OUT PHANDLE	EventHandle
	);

DWORD WINAPI DummyOnlineThread(
	IN PCLUS_WORKER	 WorkerPtr,
	IN PDUMMY_RESOURCE	ResourceEntry
	);

DWORD WINAPI DummyOffline(
	IN RESID ResourceId
	);

DWORD WINAPI DummyOfflineThread(
	PCLUS_WORKER		WorkerPtr,
	IN PDUMMY_RESOURCE	ResourceEntry
	);

void WINAPI DummyTerminate(
	IN RESID ResourceId
	);

DWORD DummyDoTerminate(
	IN PDUMMY_RESOURCE ResourceEntry
	);

BOOL WINAPI DummyLooksAlive(
	IN RESID ResourceId
	);

BOOL WINAPI DummyIsAlive(
	IN RESID ResourceId
	);

BOOL DummyCheckIsAlive(
	IN PDUMMY_RESOURCE ResourceEntry
	);

DWORD WINAPI DummyResourceControl(
	IN RESID	ResourceId,
	IN DWORD	ControlCode,
	IN void *	InBuffer,
	IN DWORD	InBufferSize,
	OUT void *	OutBuffer,
	IN DWORD	OutBufferSize,
	OUT LPDWORD BytesReturned
	);

DWORD DummyGetPrivateResProperties(
	IN OUT PDUMMY_RESOURCE	ResourceEntry,
	OUT void *				OutBuffer,
	IN DWORD				OutBufferSize,
	OUT LPDWORD			 BytesReturned
	);

DWORD DummyValidatePrivateResProperties(
	IN OUT PDUMMY_RESOURCE	ResourceEntry,
	IN const PVOID			InBuffer,
	IN DWORD				InBufferSize,
	OUT PDUMMY_PARAMS		Params
	);

DWORD DummySetPrivateResProperties(
	IN OUT PDUMMY_RESOURCE	ResourceEntry,
	IN const PVOID			InBuffer,
	IN DWORD				InBufferSize
	);

DWORD DummyTimerThread(
	IN PDUMMY_RESOURCE	ResourceEntry,
	IN PCLUS_WORKER	 WorkerPtr
	);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyInit
//
//	Routine Description:
//
//		Process attach initialization routine.
//
//	Arguments:
//
//		None.
//
//	Return Value:
//
//		TRUE if initialization succeeded. FALSE otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
static BOOLEAN DummyInit(
	void
	)
{
	DummyGlobalMutex = CreateMutex( NULL, FALSE, NULL );

	return DummyGlobalMutex != NULL;

} //*** DummyInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyCleanup
//
//	Routine Description:
//
//		Process detach cleanup routine.
//
//	Arguments:
//
//		None.
//
//	Return Value:
//
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
static void DummyCleanup(
	void
	)
{
	if ( DummyGlobalMutex != NULL )
	{
		CloseHandle( DummyGlobalMutex );
		DummyGlobalMutex = NULL;
	}

	return;

} //*** DummyCleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllMain
//
//	Routine Description:
//
//		Main DLL entry point.
//
//	Arguments:
//
//		DllHandle - DLL instance handle.
//
//		Reason - Reason for being called.
//
//		Reserved - Reserved argument.
//
//	Return Value:
//
//		TRUE - Success.
//
//		FALSE - Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI DllMain(
	IN HINSTANCE	DllHandle,
	IN DWORD		Reason,
	IN void *		//Reserved
	)
{
	BOOLEAN bRet = TRUE;

	switch( Reason )
	{
		case DLL_PROCESS_ATTACH:
			DisableThreadLibraryCalls( DllHandle );
			bRet = DummyInit();
			break;

		case DLL_PROCESS_DETACH:
			DummyCleanup();
			break;
	}

	return bRet;

} //*** DllMain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	Startup
//
//	Routine Description:
//
//		Startup the resource DLL. This routine verifies that at least one
//		currently supported version of the resource DLL is between
//		MinVersionSupported and MaxVersionSupported. If not, then the resource
//		DLL should return ERROR_REVISION_MISMATCH.
//
//		If more than one version of the resource DLL interface is supported by
//		the resource DLL, then the highest version (up to MaxVersionSupported)
//		should be returned as the resource DLL's interface. If the returned
//		version is not within range, then startup fails.
//
//		The ResourceType is passed in so that if the resource DLL supports more
//		than one ResourceType, it can pass back the correct function table
//		associated with the ResourceType.
//
//	Arguments:
//
//		ResourceType - The type of resource requesting a function table.
//
//		MinVersionSupported - The minimum resource DLL interface version
//			supported by the cluster software.
//
//		MaxVersionSupported - The maximum resource DLL interface version
//			supported by the cluster software.
//
//		SetResourceStatus - Pointer to a routine that the resource DLL should
//			call to update the state of a resource after the Online or Offline
//			routine returns a status of ERROR_IO_PENDING.
//
//		LogEvent - Pointer to a routine that handles the reporting of events
//			from the resource DLL.
//
//		FunctionTable - Returns a pointer to the function table defined for the
//			version of the resource DLL interface returned by the resource DLL.
//
//	Return Value:
//
//		ERROR_SUCCESS - The operation was successful.
//
//		ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.
//
//		ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
//			match the versrion of the DLL.
//
//		Win32 error code - The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI Startup(
	IN	LPCWSTR						 ResourceType,
	IN	DWORD							MinVersionSupported,
	IN	DWORD							MaxVersionSupported,
	IN	PSET_RESOURCE_STATUS_ROUTINE	SetResourceStatus,
	IN	PLOG_EVENT_ROUTINE				LogEvent,
	OUT PCLRES_FUNCTION_TABLE *		 FunctionTable
	)
{
	if ( ( MinVersionSupported > CLRES_VERSION_V1_00 ) ||
		 ( MaxVersionSupported < CLRES_VERSION_V1_00 ) )
	{
		return ERROR_REVISION_MISMATCH;
	}

	if ( lstrcmpiW( ResourceType, DUMMY_RESNAME ) != 0 )
	{
		return ERROR_MOD_NOT_FOUND;
	}

	if ( g_LogEvent == NULL )
	{
		g_LogEvent = LogEvent;
		g_SetResourceStatus = SetResourceStatus;
	}

	if ( FunctionTable != NULL )
	{
		*FunctionTable = &g_DummyFunctionTable;
	}

	return ERROR_SUCCESS;

} //*** Startup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOpen
//
//	Routine Description:
//
//		Open routine for Dummy resources.
//
//		Open the specified resource (create an instance of the resource).
//		Allocate all structures necessary to bring the specified resource
//		online.
//
//	Arguments:
//
//		ResourceName - Supplies the name of the resource to open.
//
//		ResourceKey - Supplies handle to the resource's cluster configuration
//			database key.
//
//		ResourceHandle - A handle that is passed back to the resource monitor
//			when the SetResourceStatus or LogEvent method is called. See the
//			description of the SetResourceStatus and LogEvent methods on the
//			DummyStatup routine. This handle should never be closed or used
//			for any purpose other than passing it as an argument back to the
//			Resource Monitor in the SetResourceStatus or LogEvent callback.
//
//	Return Value:
//
//		RESID of created resource.
//
//		NULL on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
RESID WINAPI DummyOpen(
	IN LPCWSTR			ResourceName,
	IN HKEY				ResourceKey,
	IN RESOURCE_HANDLE	ResourceHandle
	)
{
	DWORD			status;
	RESID			resid = 0;
	HKEY			parametersKey = NULL;
	PDUMMY_RESOURCE ResourceEntry = NULL;
	LPWSTR			nameOfPropInError;

	//
	// Open the Parameters registry key for this resource.
	//
	status = ClusterRegOpenKey( ResourceKey, L"Parameters", KEY_ALL_ACCESS, &parametersKey );
	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)( ResourceHandle, LOG_ERROR,	L"Unable to open Parameters key. Error: %1!u!.\n", status );
		goto exit;
	}

	//
	// Allocate a resource entry.
	//
	ResourceEntry = (PDUMMY_RESOURCE)LocalAlloc( LMEM_ZEROINIT, sizeof( DUMMY_RESOURCE ) );
	if ( ResourceEntry == NULL )
	{
		status = GetLastError();
		(g_LogEvent)(
			ResourceHandle,
			LOG_ERROR,
			L"Unable to allocate resource entry structure.	Error: %1!u!.\n",
			status
			);
		goto exit;
	}

	//
	// Initialize the resource entry..
	//

	ZeroMemory( ResourceEntry, sizeof( DUMMY_RESOURCE ) );

	ResourceEntry->ResId = (RESID)ResourceEntry; // for validation
	ResourceEntry->ResourceHandle = ResourceHandle;
	ResourceEntry->ParametersKey = parametersKey;
	ResourceEntry->State = ClusterResourceOffline;

	InitializeCriticalSection( &( ResourceEntry->Lock ) );

	//
	// Save the name of the resource.
	//
	ResourceEntry->ResourceName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT, (lstrlenW( ResourceName ) + 1 ) * sizeof( WCHAR ) );
	if ( ResourceEntry->ResourceName == NULL )
	{
		goto exit;
	}

	lstrcpyW( ResourceEntry->ResourceName, ResourceName );

	//
	// Startup for the resource.
	//
	// TODO: Add your resource startup code here.

	//
	// Read parameters.
	//
	status = ResUtilGetPropertiesToParameterBlock(
										ResourceEntry->ParametersKey,
										DummyResourcePrivateProperties,
										(LPBYTE)&ResourceEntry->Params,
										FALSE, //	CheckForRequiredProperties
										&nameOfPropInError
										);
	if ( status == ERROR_SUCCESS )
	{
		if ( ResourceEntry->Params.OpensFail )
		{
			goto exit;
		}
		else
		{
			resid = (RESID)ResourceEntry;
		}
	}
	else
	{
		goto exit;
	}

	//
	// Create a TimerThreadWakeup event
	//
	ResourceEntry->TimerThreadWakeup = CreateEvent( NULL, FALSE, FALSE, NULL );
	if ( ResourceEntry->TimerThreadWakeup == NULL )
	{
		(g_LogEvent)( ResourceHandle, LOG_ERROR, L"Failed to create timer thread wakeup event\n" );
		resid = 0;
		goto exit;
	}

	if ( ResourceEntry->Params.Pending )
	{
		ResourceEntry->Flags |= DUMMY_FLAG_PENDING;
	}

	if ( ResourceEntry->Params.Asynchronous )
	{
		EnterAsyncMode( ResourceEntry );
		ResourceEntry->SignalEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

		if ( ResourceEntry->SignalEvent == NULL )
		{
			(g_LogEvent)( ResourceHandle, LOG_ERROR, L"Failed to create a timer event\n");
			resid = 0;
			goto exit;
		}
	}

exit:

	if ( resid == 0 )
	{
		if ( parametersKey != NULL )
		{
			ClusterRegCloseKey( parametersKey );
		}

		if ( ResourceEntry != NULL )
		{
			LocalFree( ResourceEntry->ResourceName );
			LocalFree( ResourceEntry );
		}
	}

	if ( status != ERROR_SUCCESS )
	{
		SetLastError( status );
	}

	return resid;

} //*** DummyOpen()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyClose
//
//	Routine Description:
//
//		Close routine for Dummy resources.
//
//		Close the specified resource and deallocate all structures, etc.,
//		allocated in the Open call. If the resource is not in the offline state,
//		then the resource should be taken offline (by calling Terminate) before
//		the close operation is performed.
//
//	Arguments:
//
//		ResourceId - Supplies the RESID of the resource to close.
//
//	Return Value:
//
//		None.
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI DummyClose(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE ResourceEntry;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT( "Dummy: Close request for a nonexistent resource id 0x%p\n", ResourceId );
		return;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Close resource sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return;
	}

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Close request.\n"	);
#endif

	DeleteCriticalSection( &( ResourceEntry->Lock ) );

	if ( ResourceEntry->TimerThreadWakeup != NULL )
	{
		CloseHandle( ResourceEntry->TimerThreadWakeup );
	}

	if ( ResourceEntry->SignalEvent != NULL )
	{
		CloseHandle( ResourceEntry->SignalEvent );
	}

	//
	// Close the Parameters key.
	//
	if ( ResourceEntry->ParametersKey )
	{
		ClusterRegCloseKey( ResourceEntry->ParametersKey );
	}

	//
	// Deallocate the resource entry.
	//

	// ADDPARAM: Add new parameters here.

	LocalFree( ResourceEntry->ResourceName );
	LocalFree( ResourceEntry );

	return;

} //*** DummyClose()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOnline
//
//	Routine Description:
//
//		Online routine for Dummy resources.
//
//		Bring the specified resource online (available for use). The resource
//		DLL should attempt to arbitrate for the resource if it is present on a
//		shared medium, like a shared SCSI bus.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to be brought
//			online (available for use).
//
//		EventHandle - Returns a signalable handle that is signaled when the
//			resource DLL detects a failure on the resource. This argument is
//			NULL on input, and the resource DLL returns NULL if asynchronous
//			notification of failures is not supported, otherwise this must be
//			the address of a handle that is signaled on resource failures.
//
//	Return Value:
//
//		ERROR_SUCCESS - The operation was successful, and the resource is now
//			online.
//
//		ERROR_RESOURCE_NOT_FOUND - RESID is not valid.
//
//		ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some
//			other systems and one of the other systems won the arbitration.
//
//		ERROR_IO_PENDING - The request is pending, a thread has been activated
//			to process the online request. The thread that is processing the
//			online request will periodically report status by calling the
//			SetResourceStatus callback method, until the resource is placed into
//			the ClusterResourceOnline state (or the resource monitor decides to
//			timeout the online request and Terminate the resource. This pending
//			timeout value is settable and has a default value of 3 minutes.).
//
//		Win32 error code - The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyOnline(
	IN RESID	ResourceId,
	IN OUT		PHANDLE //EventHandle
	)
{
	PDUMMY_RESOURCE ResourceEntry = NULL;
	DWORD			status;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT( "Dummy: Online request for a nonexistent resource id 0x%p.\n",	ResourceId );
		return ERROR_RESOURCE_NOT_FOUND;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Online service sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return ERROR_RESOURCE_NOT_FOUND;
	}

	DummyAcquireResourceLock( ResourceEntry );

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Online request.\n" );
#endif

	ResourceEntry->State = ClusterResourceOffline;
	ClusWorkerTerminate( &ResourceEntry->OnlineThread );
	ClusWorkerTerminate( &ResourceEntry->OfflineThread );

	status = ClusWorkerCreate( &ResourceEntry->OnlineThread, (PWORKER_START_ROUTINE)DummyOnlineThread, ResourceEntry );
	if ( status != ERROR_SUCCESS )
	{
		ResourceEntry->State = ClusterResourceFailed;
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Online: Unable to start thread, status %1!u!.\n",
			status
			);
	}
	else
	{
		status = ERROR_IO_PENDING;
	}

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOnlineThread
//
//	Routine Description:
//
//		Worker function which brings a resource from the resource table online.
//		This function is executed in a separate thread.
//
//	Arguments:
//
//		WorkerPtr - Supplies the worker structure
//
//		ResourceEntry - A pointer to the DUMMY_RESOURCE block for this resource.
//
//	Return Value:
//
//		ERROR_SUCCESS - The operation completed successfully.
//
//		Win32 error code - The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyOnlineThread(
	IN PCLUS_WORKER	 WorkerPtr,
	IN PDUMMY_RESOURCE	ResourceEntry
	)
{
	RESOURCE_STATUS	 resourceStatus;
	DWORD				status = ERROR_SUCCESS;
	LPWSTR				nameOfPropInError;

	DummyAcquireResourceLock( ResourceEntry );

	ResUtilInitializeResourceStatus( &resourceStatus );

	resourceStatus.ResourceState = ClusterResourceFailed;
	resourceStatus.WaitHint = 0;
	resourceStatus.CheckPoint = 1;

	//
	// Read parameters.
	//
	status = ResUtilGetPropertiesToParameterBlock(
										ResourceEntry->ParametersKey,
										DummyResourcePrivateProperties,
										(LPBYTE)&ResourceEntry->Params,
										TRUE, //	CheckForRequiredProperties
										&nameOfPropInError
										);
	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Unable to read the '%1' property. Error: %2!u!.\n",
			(nameOfPropInError == NULL ? L"" : nameOfPropInError),
			status
			);
		goto exit;
	}

	//
	// Bring the resource online.
	//
	if ( ResourceEntry->Params.Pending )
	{
		ResourceEntry->Flags |= DUMMY_FLAG_PENDING;
		ResourceEntry->TimerType = TimerOnlinePending;

		status = DummyTimerThread( ResourceEntry, WorkerPtr );
	}

exit:

	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_ERROR, L"Error %1!u! bringing resource online.\n", status );
	}
	else
	{
		resourceStatus.ResourceState = ClusterResourceOnline;
	}

	// _ASSERTE(g_SetResourceStatus != NULL);
	g_SetResourceStatus( ResourceEntry->ResourceHandle, &resourceStatus );
	ResourceEntry->State = resourceStatus.ResourceState;

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyOnlineThread()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOffline
//
//	Routine Description:
//
//		Offline routine for Dummy resources.
//
//		Take the specified resource offline gracefully (unavailable for use).
//		Wait for any cleanup operations to complete before returning.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to be shutdown
//			gracefully.
//
//	Return Value:
//
//		ERROR_SUCCESS - The request completed successfully and the resource is
//			offline.
//
//		ERROR_RESOURCE_NOT_FOUND - RESID is not valid.
//
//		ERROR_IO_PENDING - The request is still pending, a thread has been
//			activated to process the offline request. The thread that is
//			processing the offline will periodically report status by calling
//			the SetResourceStatus callback method, until the resource is placed
//			into the ClusterResourceOffline state (or the resource monitor decides
//			to timeout the offline request and Terminate the resource).
//
//		Win32 error code - Will cause the resource monitor to log an event and
//			call the Terminate routine.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyOffline(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE ResourceEntry;
	DWORD			status = ERROR_SUCCESS;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT( "Dummy: Offline request for a nonexistent resource id 0x%p\n",	ResourceId );
		return ERROR_RESOURCE_NOT_FOUND;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return ERROR_RESOURCE_NOT_FOUND;
	}

	DummyAcquireResourceLock( ResourceEntry );

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Offline request.\n" );
#endif

	// TODO: Offline code

	// NOTE: Offline should try to shut the resource down gracefully, whereas
	// Terminate must shut the resource down immediately. If there are no
	// differences between a graceful shut down and an immediate shut down,
	// Terminate can be called for Offline, as it is below.	However, if there
	// are differences, replace the call to Terminate below with your graceful
	// shutdown code.

	ResourceEntry->State = ClusterResourceOnline;
	ClusWorkerTerminate( &ResourceEntry->OfflineThread );
	ClusWorkerTerminate( &ResourceEntry->OnlineThread );

	status = ClusWorkerCreate( &ResourceEntry->OfflineThread, (PWORKER_START_ROUTINE)DummyOfflineThread, ResourceEntry );
	if ( status != ERROR_SUCCESS )
	{
		ResourceEntry->State = ClusterResourceFailed;
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Online: Unable to start thread, status %1!u!.\n",
			status
			);
	}
	else
	{
		status = ERROR_IO_PENDING;
	}

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyOfflineThread
//
//	Routine Description:
//
//		Worker function which brings a resource from the resource table online.
//		This function is executed in a separate thread.
//
//	Arguments:
//
//		WorkerPtr - Supplies the worker structure
//
//		ResourceEntry - A pointer to the DUMMY_RESOURCE block for this resource.
//
//	Return Value:
//
//		ERROR_SUCCESS - The operation completed successfully.
//
//		Win32 error code - The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyOfflineThread(
	IN PCLUS_WORKER	 WorkerPtr,
	IN PDUMMY_RESOURCE	ResourceEntry
	)
{
	RESOURCE_STATUS	 resourceStatus;
	DWORD				status = ERROR_SUCCESS;
	LPWSTR				nameOfPropInError;

	DummyAcquireResourceLock( ResourceEntry );

	ResUtilInitializeResourceStatus( &resourceStatus );

	resourceStatus.ResourceState = ClusterResourceFailed;
	resourceStatus.WaitHint = 0;
	resourceStatus.CheckPoint = 1;

	//
	// Read parameters.
	//
	status = ResUtilGetPropertiesToParameterBlock(
										ResourceEntry->ParametersKey,
										DummyResourcePrivateProperties,
										(LPBYTE)&ResourceEntry->Params,
										FALSE, //	CheckForRequiredProperties
										&nameOfPropInError
										);
	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Unable to read the '%1' property. Error: %2!u!.\n",
			(nameOfPropInError == NULL ? L"" : nameOfPropInError),
			status
			);
		goto exit;
	}

	//
	// Bring the resource online.
	//
	if ( ResourceEntry->Params.Pending )
	{
		ResourceEntry->Flags |= DUMMY_FLAG_PENDING;
		ResourceEntry->TimerType = TimerOfflinePending;

		status = DummyTimerThread( ResourceEntry, WorkerPtr );
	}

exit:

	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_ERROR, L"Error %1!u! bringing resource online.\n", status );
	}
	else
	{
		resourceStatus.ResourceState = ClusterResourceOffline;
	}

	// _ASSERTE(g_SetResourceStatus != NULL);
	g_SetResourceStatus( ResourceEntry->ResourceHandle, &resourceStatus );
	ResourceEntry->State = resourceStatus.ResourceState;

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyOfflineThread()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyTerminate
//
//	Routine Description:
//
//		Terminate routine for Dummy resources.
//
//		Take the specified resource offline immediately (the resource is
//		unavailable for use).
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to be brought
//			offline.
//
//	Return Value:
//
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI DummyTerminate(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE ResourceEntry;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT( "Dummy: Terminate request for a nonexistent resource id 0x%p\n", ResourceId );
		return;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return;
	}

	DummyAcquireResourceLock( ResourceEntry );

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Terminate request.\n" );
#endif

	//
	// Terminate the resource.
	//
	DummyDoTerminate( ResourceEntry );
	ResourceEntry->State = ClusterResourceOffline;

	DummyReleaseResourceLock( ResourceEntry );

	return;

} //*** DummyTerminate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyDoTerminate
//
//	Routine Description:
//
//		Do the actual Terminate work for Dummy resources.
//
//	Arguments:
//
//		ResourceEntry - Supplies resource entry for resource to be terminated
//
//	Return Value:
//
//		ERROR_SUCCESS - The request completed successfully and the resource is
//			offline.
//
//		Win32 error code - Will cause the resource monitor to log an event and
//			call the Terminate routine.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyDoTerminate(
	IN PDUMMY_RESOURCE ResourceEntry
	)
{
	DWORD	status = ERROR_SUCCESS;

	if ( ResourceEntry->TimerType != TimerNotUsed )
	{
		SetEvent( ResourceEntry->TimerThreadWakeup );
	}
	//
	// Kill off any pending threads.
	//
	ClusWorkerTerminate( &ResourceEntry->OnlineThread );
	ClusWorkerTerminate( &ResourceEntry->OfflineThread );

	//
	// Terminate the resource.
	//
	// TODO: Add code to terminate your resource.
	if ( status == ERROR_SUCCESS )
	{
		ResourceEntry->State = ClusterResourceOffline;
	}

	return status;

} //*** DummyDoTerminate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyLooksAlive
//
//	Routine Description:
//
//		LooksAlive routine for Dummy resources.
//
//		Perform a quick check to determine if the specified resource is probably
//		online (available for use).	This call should not block for more than
//		300 ms, preferably less than 50 ms.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to polled.
//
//	Return Value:
//
//		TRUE - The specified resource is probably online and available for use.
//
//		FALSE - The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DummyLooksAlive(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE	ResourceEntry;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT("Dummy: LooksAlive request for a nonexistent resource id 0x%p\n", ResourceId );
		return FALSE;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"LooksAlive sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return FALSE;
	}

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"LooksAlive request.\n" );
#endif

	// TODO: LooksAlive code

	// NOTE: LooksAlive should be a quick check to see if the resource is
	// available or not, whereas IsAlive should be a thorough check.	If
	// there are no differences between a quick check and a thorough check,
	// IsAlive can be called for LooksAlive, as it is below.	However, if there
	// are differences, replace the call to IsAlive below with your quick
	// check code.

	//
	// Check to see if the resource is alive.
	//
	return DummyCheckIsAlive( ResourceEntry );

} //*** DummyLooksAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyIsAlive
//
//	Routine Description:
//
//		IsAlive routine for Dummy resources.
//
//		Perform a thorough check to determine if the specified resource is online
//		(available for use). This call should not block for more than 400 ms,
//		preferably less than 100 ms.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the resource to polled.
//
//	Return Value:
//
//		TRUE - The specified resource is online and functioning normally.
//
//		FALSE - The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DummyIsAlive(
	IN RESID ResourceId
	)
{
	PDUMMY_RESOURCE	ResourceEntry;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT("Dummy: IsAlive request for a nonexistent resource id 0x%p\n", ResourceId );
		return FALSE;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return FALSE;
	}

#ifdef LOG_VERBOSE
	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"IsAlive request.\n" );
#endif

	//
	// Check to see if the resource is alive.
	//
	return DummyCheckIsAlive( ResourceEntry );

} //*** DummyIsAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyCheckIsAlive
//
//	Routine Description:
//
//		Check to see if the resource is alive for Dummy resources.
//
//	Arguments:
//
//		ResourceEntry - Supplies the resource entry for the resource to polled.
//
//	Return Value:
//
//		TRUE - The specified resource is online and functioning normally.
//
//		FALSE - The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DummyCheckIsAlive(
	IN PDUMMY_RESOURCE ResourceEntry
	)
{
	DummyAcquireResourceLock( ResourceEntry );

	//
	// Check to see if the resource is alive.
	//
	// TODO: Add code to determine if your resource is alive.

	DummyReleaseResourceLock( ResourceEntry );

	return TRUE;

} //*** DummyCheckIsAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyResourceControl
//
//	Routine Description:
//
//		ResourceControl routine for Dummy resources.
//
//		Perform the control request specified by ControlCode on the specified
//		resource.
//
//	Arguments:
//
//		ResourceId - Supplies the resource id for the specific resource.
//
//		ControlCode - Supplies the control code that defines the action
//			to be performed.
//
//		InBuffer - Supplies a pointer to a buffer containing input data.
//
//		InBufferSize - Supplies the size, in bytes, of the data pointed
//			to by InBuffer.
//
//		OutBuffer - Supplies a pointer to the output buffer to be filled in.
//
//		OutBufferSize - Supplies the size, in bytes, of the available space
//			pointed to by OutBuffer.
//
//		BytesReturned - Returns the number of bytes of OutBuffer actually
//			filled in by the resource. If OutBuffer is too small, BytesReturned
//			contains the total number of bytes for the operation to succeed.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_RESOURCE_NOT_FOUND - RESID is not valid.
//
//		ERROR_INVALID_FUNCTION - The requested control code is not supported.
//			In some cases, this allows the cluster software to perform the work.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyResourceControl(
	IN RESID	ResourceId,
	IN DWORD	ControlCode,
	IN void *	InBuffer,
	IN DWORD	InBufferSize,
	OUT void *	OutBuffer,
	IN DWORD	OutBufferSize,
	OUT LPDWORD BytesReturned
	)
{
	DWORD			status;
	PDUMMY_RESOURCE ResourceEntry;
	DWORD			required;

	ResourceEntry = (PDUMMY_RESOURCE)ResourceId;
	if ( ResourceEntry == NULL )
	{
		DBG_PRINT("Dummy: ResourceControl request for a nonexistent resource id 0x%p\n", ResourceId );
		return ERROR_RESOURCE_NOT_FOUND;
	}

	if ( ResourceEntry->ResId != ResourceId )
	{
		(g_LogEvent)(
			ResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"ResourceControl sanity check failed! ResourceId = %1!u!.\n",
			ResourceId
			);
		return ERROR_RESOURCE_NOT_FOUND;
	}

	DummyAcquireResourceLock( ResourceEntry );

	switch ( ControlCode )
	{

		case CLUSCTL_RESOURCE_UNKNOWN:
			*BytesReturned = 0;
			status = ERROR_SUCCESS;
			break;

		case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
			status = ResUtilEnumProperties(
								DummyResourcePrivateProperties,
								(LPWSTR)OutBuffer,
								OutBufferSize,
								BytesReturned,
								&required
								);
			if ( status == ERROR_MORE_DATA )
			{
				*BytesReturned = required;
			}

			break;

		case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
			status = DummyGetPrivateResProperties(
												ResourceEntry,
												OutBuffer,
												OutBufferSize,
												BytesReturned
												);
			break;

		case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
			status = DummyValidatePrivateResProperties( ResourceEntry, InBuffer, InBufferSize, NULL );
			break;

		case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
			status = DummySetPrivateResProperties( ResourceEntry, InBuffer, InBufferSize );
			break;

		default:
			status = ERROR_INVALID_FUNCTION;
			break;
	}

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyResourceControl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyResourceTypeControl
//
//	Routine Description:
//
//		ResourceTypeControl routine for Dummy resources.
//
//		Perform the control request specified by ControlCode.
//
//	Arguments:
//
//		ResourceTypeName - Supplies the name of the resource type.
//
//		ControlCode - Supplies the control code that defines the action
//			to be performed.
//
//		InBuffer - Supplies a pointer to a buffer containing input data.
//
//		InBufferSize - Supplies the size, in bytes, of the data pointed
//			to by InBuffer.
//
//		OutBuffer - Supplies a pointer to the output buffer to be filled in.
//
//		OutBufferSize - Supplies the size, in bytes, of the available space
//			pointed to by OutBuffer.
//
//		BytesReturned - Returns the number of bytes of OutBuffer actually
//			filled in by the resource. If OutBuffer is too small, BytesReturned
//			contains the total number of bytes for the operation to succeed.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_INVALID_FUNCTION - The requested control code is not supported.
//			In some cases, this allows the cluster software to perform the work.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DummyResourceTypeControl(
	IN LPCWSTR, //ResourceTypeName,
	IN DWORD	ControlCode,
	IN void *,	//InBuffer,
	IN DWORD,	//InBufferSize,
	OUT void *	OutBuffer,
	IN DWORD	OutBufferSize,
	OUT LPDWORD BytesReturned
	)
{
	DWORD				status;
	DWORD				required;

	switch ( ControlCode )
	{

		case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
			*BytesReturned = 0;
			status = ERROR_SUCCESS;
			break;

		case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
			status = ResUtilEnumProperties(
									DummyResourcePrivateProperties,
									(LPWSTR)OutBuffer,
									OutBufferSize,
									BytesReturned,
									&required
									);
			if ( status == ERROR_MORE_DATA )
			{
				*BytesReturned = required;
			}

			break;

		default:
			status = ERROR_INVALID_FUNCTION;
			break;
	}

	return status;

} //*** DummyResourceTypeControl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyGetPrivateResProperties
//
//	Routine Description:
//
//		Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
//			for resources of type Dummy.
//
//	Arguments:
//
//		ResourceEntry - Supplies the resource entry on which to operate.
//
//		OutBuffer - Returns the output data.
//
//		OutBufferSize - Supplies the size, in bytes, of the data pointed
//			to by OutBuffer.
//
//		BytesReturned - The number of bytes returned in OutBuffer.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_INVALID_PARAMETER - The data is formatted incorrectly.
//
//		ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyGetPrivateResProperties(
	IN OUT	PDUMMY_RESOURCE ResourceEntry,
	OUT	 void *			OutBuffer,
	IN		DWORD			OutBufferSize,
	OUT	 LPDWORD		 BytesReturned
	)
{
	DWORD	status;
	DWORD	required;

	DummyAcquireResourceLock( ResourceEntry );

	status = ResUtilGetAllProperties(
							ResourceEntry->ParametersKey,
							DummyResourcePrivateProperties,
							OutBuffer,
							OutBufferSize,
							BytesReturned,
							&required
							);
	if ( status == ERROR_MORE_DATA )
	{
		*BytesReturned = required;
	}

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummyGetPrivateResProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyValidatePrivateResProperties
//
//	Routine Description:
//
//		Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
//			function for resources of type Dummy.
//
//	Arguments:
//
//		pResourceEntry - Supplies the resource entry	on which to operate.
//
//		InBuffer - Supplies a pointer to a buffer containing input data.
//
//		InBufferSize - Supplies the size, in bytes, of the data pointed
//			to by InBuffer.
//
//		Params - Supplies the parameter block to fill in.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_INVALID_PARAMETER - The data is formatted incorrectly.
//
//		ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyValidatePrivateResProperties(
	IN OUT	PDUMMY_RESOURCE pResourceEntry,
	IN		const PVOID	 InBuffer,
	IN		DWORD			InBufferSize,
	OUT	 PDUMMY_PARAMS	Params
	)
{
	DWORD			status = ERROR_SUCCESS;
	DUMMY_PARAMS	propsCurrent;
	DUMMY_PARAMS	propsNew;
	PDUMMY_PARAMS	pParams;
	LPWSTR			pszNameOfPropInError;

	DummyAcquireResourceLock( pResourceEntry );

	//
	// Check if there is input data.
	//
	if ( ( InBuffer == NULL ) || ( InBufferSize < sizeof( DWORD ) ) )
	{
		status = ERROR_INVALID_DATA;
		goto exit;
	}

	//
	// Retrieve the current set of private properties from the
	// cluster database.
	//
	ZeroMemory( &propsCurrent, sizeof( propsCurrent ) );

	status = ResUtilGetPropertiesToParameterBlock(
				 pResourceEntry->ParametersKey,
				 DummyResourcePrivateProperties,
				 reinterpret_cast< LPBYTE >( &propsCurrent ),
				 FALSE, /*CheckForRequiredProperties*/
				 &pszNameOfPropInError
				 );

	if ( status != ERROR_SUCCESS )
	{
		(g_LogEvent)(
			pResourceEntry->ResourceHandle,
			LOG_ERROR,
			L"Unable to read the '%1' property. Error: %2!u!.\n",
			(pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
			status
			);
		goto exit;
	} // if:	error getting properties


	//
	// Duplicate the resource parameter block.
	//
	if ( Params == NULL )
	{
		pParams = &propsNew;
	}
	else
	{
		pParams = Params;
	}

	ZeroMemory( pParams, sizeof(DUMMY_PARAMS) );
	status = ResUtilDupParameterBlock(
					reinterpret_cast< LPBYTE >( pParams ),
					reinterpret_cast< LPBYTE >( &propsCurrent ),
					DummyResourcePrivateProperties
					);
	if ( status != ERROR_SUCCESS )
	{
		goto cleanup;
	}

	//
	// Parse and validate the properties.
	//
	status = ResUtilVerifyPropertyTable(
								DummyResourcePrivateProperties,
								NULL,
								TRUE, // AllowUnknownProperties
								InBuffer,
								InBufferSize,
								(LPBYTE)pParams
								);

	if ( status == ERROR_SUCCESS )
	{
		//
		// Validate the parameter values.
		//
		// TODO: Code to validate interactions between parameters goes here.
	}

cleanup:
	//
	// Cleanup our parameter block.
	//
	if (	(pParams == &propsNew)
		||	(	(status != ERROR_SUCCESS)
			&&	(pParams != NULL)
			)
		)
	{
		ResUtilFreeParameterBlock(
			reinterpret_cast< LPBYTE >( pParams ),
			reinterpret_cast< LPBYTE >( &propsCurrent ),
			DummyResourcePrivateProperties
			);
	} // if:	we duplicated the parameter block

	ResUtilFreeParameterBlock(
		reinterpret_cast< LPBYTE >( &propsCurrent ),
		NULL,
		DummyResourcePrivateProperties
		);

exit:

	DummyReleaseResourceLock( pResourceEntry );

	return status;

} //*** DummyValidatePrivateResProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummySetPrivateResProperties
//
//	Routine Description:
//
//		Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
//			for resources of type Dummy.
//
//	Arguments:
//
//		ResourceEntry - Supplies the resource entry on which to operate.
//
//		InBuffer - Supplies a pointer to a buffer containing input data.
//
//		InBufferSize - Supplies the size, in bytes, of the data pointed
//			to by InBuffer.
//
//	Return Value:
//
//		ERROR_SUCCESS - The function completed successfully.
//
//		ERROR_INVALID_PARAMETER - The data is formatted incorrectly.
//
//		ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.
//
//		Win32 error code - The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummySetPrivateResProperties(
	IN OUT	PDUMMY_RESOURCE ResourceEntry,
	IN		void *			InBuffer,
	IN		DWORD			InBufferSize
	)
{
	DWORD			status = ERROR_SUCCESS;
	DUMMY_PARAMS	params;

	DummyAcquireResourceLock( ResourceEntry );

	//
	// Parse the properties so they can be validated together.
	// This routine does individual property validation.
	//
	status = DummyValidatePrivateResProperties( ResourceEntry, InBuffer, InBufferSize, &params );
	if ( status != ERROR_SUCCESS )
	{
		ResUtilFreeParameterBlock( (LPBYTE)&params, (LPBYTE)&ResourceEntry->Params, DummyResourcePrivateProperties );
		goto exit;
	}

	//
	// Save the parameter values.
	//

	status = ResUtilSetPropertyParameterBlock(
								ResourceEntry->ParametersKey,
								DummyResourcePrivateProperties,
								NULL,
								(LPBYTE) &params,
								InBuffer,
								InBufferSize,
								(LPBYTE) &ResourceEntry->Params
								);

	ResUtilFreeParameterBlock( (LPBYTE)&params, (LPBYTE)&ResourceEntry->Params, DummyResourcePrivateProperties );

	//
	// If the resource is online, return a non-success status.
	//
	// TODO: Modify the code below if your resource can handle
	// changes to properties while it is still online.
	if ( status == ERROR_SUCCESS )
	{
		if ( ResourceEntry->State == ClusterResourceOnline )
		{
			status = ERROR_RESOURCE_PROPERTIES_STORED;
		}
		else if ( ResourceEntry->State == ClusterResourceOnlinePending )
		{
			status = ERROR_RESOURCE_PROPERTIES_STORED;
		}
		else
		{
			status = ERROR_SUCCESS;
		}
	}

exit:

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} //*** DummySetPrivateResProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyDoPending
//
//	Routine Description:
//
//		Does the online and offline pending and waiting processing
//
//	Arguments:
//
//		resource - A pointer to the DummyResource block for this resource.
//
//		nDelay - How long should we wait?
//
//		WorkerPtr - Supplies the worker structure
//
//	Return Value:
//
//		ERROR_SUCCESS if successful.
//
//		Win32 error code on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyDoPending(
	IN PDUMMY_RESOURCE	ResourceEntry,
	IN DWORD			nDelay,
	IN PCLUS_WORKER	 WorkerPtr
	)
{
	RESOURCE_STATUS	 resourceStatus;
	DWORD				status;
	DWORD				nWait = MAX_WAIT;
	RESOURCE_EXIT_STATE exit;

	ResUtilInitializeResourceStatus( &resourceStatus );

	resourceStatus.ResourceState = ( ResourceEntry->TimerType == TimerOnlinePending
									? ClusterResourceOnlinePending
									: ClusterResourceOfflinePending );
	resourceStatus.WaitHint = 0;
	resourceStatus.CheckPoint = 1;

	(g_SetResourceStatus)( ResourceEntry->ResourceHandle, &resourceStatus );

	if ( nDelay < nWait )
	{
		nWait = nDelay;
		nDelay = 0;
	}

	for ( ; ; )
	{
		status = WaitForSingleObject( ResourceEntry->TimerThreadWakeup, nWait );

		//
		// Check to see if the online operation was aborted while this thread
		// was starting up.
		//
		if ( ClusWorkerCheckTerminate( WorkerPtr ) )
		{
			status = ERROR_OPERATION_ABORTED;
			ResourceEntry->State = ( ResourceEntry->TimerType == TimerOnlinePending )
									? ClusterResourceOnlinePending
									: ClusterResourceOfflinePending;
			break;
		}

		//
		// Either the terminate routine was called, or we timed out.
		// If we timed out, then indicate that we've completed.
		//
		if ( status == WAIT_TIMEOUT )
		{

			if ( nDelay == 0 )
			{
				status = ERROR_SUCCESS;
				break;
			}

			nDelay -= nWait;

			if ( nDelay < nWait )
			{
				nWait = nDelay;
				nDelay = 0;
			}
		}
		else
		{
			(g_LogEvent)(
				ResourceEntry->ResourceHandle,
				LOG_INFORMATION,
				( ResourceEntry->TimerType == TimerOnlinePending ) ? L"Online pending terminated\n" : L"Offline pending terminated\n"
				);
			if ( ResourceEntry->State == ClusterResourceOffline )
			{
				ResourceEntry->TimerType = TimerOfflinePending;
				break;
			}
			else if ( ResourceEntry->State == ClusterResourceOnline )
			{
				ResourceEntry->TimerType	= TimerOnlinePending;
				break;
			}
		}

		exit = (_RESOURCE_EXIT_STATE)(g_SetResourceStatus)( ResourceEntry->ResourceHandle, &resourceStatus );
		if ( exit == ResourceExitStateTerminate )
		{
			ResourceEntry->State = ( ResourceEntry->TimerType == TimerOnlinePending )
										? ClusterResourceOnline
										: ClusterResourceOffline;

			status = ERROR_SUCCESS; //TODO

			if ( ResourceEntry->TimerType == TimerOnlinePending )
			{
				break;
			}
		}
		else
		{
			ResourceEntry->State = ( ResourceEntry->TimerType == TimerOnlinePending )
									? ClusterResourceOnline
									: ClusterResourceOffline;
			status = ERROR_SUCCESS;
		}
	} // for:

	resourceStatus.ResourceState = ( ResourceEntry->TimerType == TimerOnlinePending ? ClusterResourceOnline : ClusterResourceOffline );
	(g_SetResourceStatus)( ResourceEntry->ResourceHandle, &resourceStatus );

	return status;

} //*** DummyDoPending()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DummyTimerThread
//
//	Routine Description:
//
//		Starts a timer thread to wait and signal failures
//
//	Arguments:
//
//		resource - A pointer to the DummyResource block for this resource.
//
//		WorkerPtr - Supplies the worker structure
//
//	Return Value:
//
//		ERROR_SUCCESS if successful.
//
//		Win32 error code on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DummyTimerThread(
	IN PDUMMY_RESOURCE	ResourceEntry,
	IN PCLUS_WORKER	 WorkerPtr
	)
{
	RESOURCE_STATUS	 resourceStatus;
	SYSTEMTIME			time;
	DWORD				delay;
	DWORD				status = ERROR_SUCCESS;

	DummyAcquireResourceLock( ResourceEntry );

	(g_LogEvent)( NULL, LOG_INFORMATION, L"TimerThread Entry\n" );

	//
	// If we are not running in async failure mode, or
	// pending mode then exit now.
	//
	if ( !AsyncMode( ResourceEntry ) && !PendingMode( ResourceEntry ) )
	{
		status = ERROR_SUCCESS;
		goto exit;
	}

	//
	// Check to see if the online/offline operation was aborted while this thread
	// was starting up.
	//
	if ( ClusWorkerCheckTerminate( WorkerPtr ) )
	{
		status = ERROR_OPERATION_ABORTED;
		ResourceEntry->State = ClusterResourceOfflinePending;
		goto exit;
	}

more_pending:

	ResUtilInitializeResourceStatus( &resourceStatus );

	//
	// Otherwise, get system time for random delay.
	//
	if ( ResourceEntry->Params.PendTime == 0 )
	{
		GetSystemTime( &time );
		delay = ( time.wMilliseconds + time.wSecond ) * 6;
	}
	else
	{
		delay = ResourceEntry->Params.PendTime * 1000;
	}

	//
	// Use longer delays for errors
	//
	if ( ResourceEntry->TimerType == TimerErrorPending )
	{
		delay *= 10;
	}

	//
	// This routine is either handling an Offline Pending or an error timeout.
	//
	switch ( ResourceEntry->TimerType )
	{

		case TimerOnlinePending :
		{
			(g_LogEvent)(
				ResourceEntry->ResourceHandle,
				LOG_INFORMATION,
				L"Will complete online in approximately %1!u! seconds\n",
				( delay + 500 ) / 1000
				);

			status = DummyDoPending( ResourceEntry, delay, WorkerPtr );

			break;
		}

		case TimerOfflinePending :
		{
			(g_LogEvent)(
				ResourceEntry->ResourceHandle,
				LOG_INFORMATION,
				L"Will complete offline in approximately %1!u! seconds\n",
				(delay+500)/1000
				);

			status = DummyDoPending( ResourceEntry, delay, WorkerPtr );

			break;
		}

		case TimerErrorPending :
		{
			(g_LogEvent)(
				ResourceEntry->ResourceHandle,
				LOG_INFORMATION,
				L"Will fail in approximately %1!u! seconds\n",
				( delay + 500 ) / 1000
				);

			if ( !ResetEvent( ResourceEntry->SignalEvent	) )
			{
				(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_ERROR, L"Failed to reset the signal event\n");
				status = ERROR_GEN_FAILURE;
				goto exit;
			}

			status = WaitForSingleObject( ResourceEntry->TimerThreadWakeup, delay );

			//
			// Either the terminate routine was called, or we timed out.
			// If we timed out, then signal the waiting event.
			//
			if ( status == WAIT_TIMEOUT )
			{
				(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"Failed randomly\n");
				ResourceEntry->TimerType	= TimerNotUsed;
				SetEvent( ResourceEntry->SignalEvent	);
			}
			else
			{
				if ( ResourceEntry->State ==	ClusterResourceOfflinePending )
				{
					ResourceEntry->TimerType	= TimerOfflinePending;
					goto more_pending;
				}
			}

			break;
		}

		default:
			(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_ERROR, L"DummyTimer internal error, timer %1!u!\n", ResourceEntry->TimerType);
			break;

	}

	(g_LogEvent)( ResourceEntry->ResourceHandle, LOG_INFORMATION, L"TimerThread Exit\n" );


	ResourceEntry->TimerType = TimerNotUsed;

exit:

	DummyReleaseResourceLock( ResourceEntry );

	return status;

} // DummyTimerThread

//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE(
						g_DummyFunctionTable,		// Name
						CLRES_VERSION_V1_00,		// Version
						Dummy,						// Prefix
						NULL,						// Arbitrate
						NULL,						// Release
						DummyResourceControl,		// ResControl
						DummyResourceTypeControl	// ResTypeControl
						);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Description:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_INL_
#define _BASEPAGE_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

IWCWizardCallback * CBasePropertyPage::PiWizardCallback(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->PiWizardCallback();
}

BOOL CBasePropertyPage::BWizard(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->BWizard();
}

HCLUSTER CBasePropertyPage::Hcluster(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Hcluster();
}

CLUADMEX_OBJECT_TYPE CBasePropertyPage::Cot(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Cot();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\disks\extdll\exe\tstdllex.c ===
#include <windows.h>
#include <stdio.h>

#include <resapi.h>
#include <clusapi.h>
#include <clusstor.h>

#define MAX_NAME_SIZE       MAX_PATH
#define START_BUFFER_SIZE   2048

#define PHYSICAL_DISK_WSTR  L"Physical Disk"

//
// Always specify the fully qualified path name to the DLL.
//

#define MODULE_NAME_VALID       "%SystemRoot%\\cluster\\passthru.dll"

#define PROC_EXCEPTION          "TestDllCauseException"
#define PROC_GET_BOOT_SECTOR    "TestDllGetBootSector"
#define PROC_CONTEXT_AS_ERROR   "TestDllReturnContextAsError"
#define PROC_NOT_ENOUGH_PARMS   "TestDllNotEnoughParms"
#define PROC_TOO_MANY_PARMS     "TestDllTooManyParms"

// 6118L    ERROR_NO_BROWSER_SERVERS_FOUND
#define CONTEXT_ERROR_STR       "6118"

#define MODULE_NAME_INVALID     "NoSuchModule.dll"
#define PROC_NAME_INVALID       "NoSuchProc"

#define MAX_OUT_BUFFER_SIZE 2048

#define BOOT_SECTOR_SIZE        512

// Specfic ASR tests
#define ASRP_GET_LOCAL_DISK_INFO    "AsrpGetLocalDiskInfo"
#define ASRP_GET_LOCAL_VOLUME_INFO  "AsrpGetLocalVolumeInfo"
#define SYSSETUP_DLL                "syssetup.dll"

//
// Use this to verify the parse routine.
//
// #define TEST_PARSE_ROUTINE  11


typedef struct _RESOURCE_STATE {
    CLUSTER_RESOURCE_STATE  State;
    LPWSTR  ResNodeName;
    LPWSTR  ResGroupName;
} RESOURCE_STATE, *PRESOURCE_STATE;


VOID
DumpBuffer(
    IN PUCHAR Buffer,
    IN DWORD ByteCount
    );

DWORD
GetResourceInfo(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    );

DWORD
GetResourceState(
    HRESOURCE Resource,
    PRESOURCE_STATE ResState
    );

DWORD
GetSignature(
    RESOURCE_HANDLE hResource,
    DWORD *dwSignature
    );

BOOLEAN
GetSignatureFromDiskInfo(
    PBYTE DiskInfo,
    DWORD *Signature,
    DWORD DiskInfoSize
    );


LPBYTE
ParseDiskInfo(
    PBYTE DiskInfo,
    DWORD DiskInfoSize,
    DWORD SyntaxValue
    );

VOID
PrintError(
    DWORD ErrorCode
    );


DWORD
ResourceCallback(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    );

CLUSTER_RESOURCE_STATE
WINAPI
WrapGetClusterResourceState(
	IN HRESOURCE hResource,
	OUT OPTIONAL LPWSTR * ppwszNodeName,
	OUT OPTIONAL LPWSTR * ppwszGroupName
	);

DWORD
WrapClusterResourceControl(
    RESOURCE_HANDLE hResource,
    DWORD dwControlCode,
    LPVOID *ppwszOutBuffer,
    DWORD *dwBytesReturned
    );


DWORD
__cdecl
main(
    int argc,
    char *argv[]
    )

{
    DWORD dwStatus = NO_ERROR;

    //
    // No parameter validation...
    //

    dwStatus = ResUtilEnumResources( NULL,
                                     PHYSICAL_DISK_WSTR,
                                     ResourceCallback,
                                     NULL
                                     );

    if ( NO_ERROR != dwStatus ) {
        printf("\nResUtilEnumResources returns: %d \n", dwStatus);
        PrintError(dwStatus);
    }

    return dwStatus;

}   // main



DWORD
ResourceCallback(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    )
{
    PCHAR outBuffer = NULL;

    DWORD dwStatus = NO_ERROR;

    DWORD   inBufferSize = sizeof(DISK_DLL_EXTENSION_INFO);
    DWORD   outBufferSize = MAX_OUT_BUFFER_SIZE;
    DWORD   bytesReturned;

    DISK_DLL_EXTENSION_INFO inBuffer;

    // printf("hOriginal 0x%x  hResource 0x%x  lpParams 0x%x \n", hOriginal, hResource, lpParams);

    //
    // Demonstrate how to get various resource info.
    //

    dwStatus = GetResourceInfo( hOriginal,
                                hResource,
                                lpParams );

    //////////////////////////////////////////////////////////////////////////
    //
    // Demonstrate calling into the disk extension DLL.
    //
    //////////////////////////////////////////////////////////////////////////

    printf("\nStarting disk extension DLL tests \n");

    outBuffer = LocalAlloc( LPTR, outBufferSize );

    if ( !outBuffer ) {

        dwStatus = GetLastError();
        goto FnExit;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // Buffer verification tests
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // No input buffer - should fail.
    //

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       NULL,                                    // Error
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("Input buffer missing: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);

    //
    // Incorrect input buffer size - should fail.
    //

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       28,                                      // Error
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("Input buffer size incorrect: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);

    //
    // Input buffer incorrect version - should fail.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );

    inBuffer.MajorVersion = NT4_MAJOR_VERSION;                                  // Error

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("Input buffer version incorrect: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);

    //
    // No output buffer - should fail.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       NULL,                                    // Error
                                       outBufferSize,
                                       &bytesReturned );

    printf("Output buffer missing: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);

    //////////////////////////////////////////////////////////////////////////
    //
    // DLL verification tests
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Disk resource has hard-coded DLL name.  A call with any invalid
    // proc name will always fail.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;

    strncpy( inBuffer.DllModuleName,
             MODULE_NAME_INVALID,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             PROC_NAME_INVALID,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL name invalid: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);

    //
    // Valid ASR DLL, invalid proc name - should fail.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strncpy( inBuffer.DllModuleName,
             SYSSETUP_DLL,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             PROC_NAME_INVALID,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL valid, Proc invalid: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);

#if ALLOW_DLL_PARMS

    //
    // DLL procedure generates exception - should fail gracefully.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strncpy( inBuffer.DllModuleName,
             MODULE_NAME_VALID,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             PROC_EXCEPTION,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL proc generates exception: %d (0x%x) [failure expected] \n", dwStatus, dwStatus);
    PrintError(dwStatus);

#if 0

    //
    // We can't protect against this type of error, so don't test it.
    //

    //
    // DLL procedure has less parameters then we are calling - should fail gracefully.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strncpy( inBuffer.DllModuleName,
             MODULE_NAME_VALID,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             PROC_NOT_ENOUGH_PARMS,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL proc doesn't support required number of parms: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);

    //
    // DLL procedure has more parameters then we are calling - should fail gracefully.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strncpy( inBuffer.DllModuleName,
             MODULE_NAME_VALID,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             PROC_TOO_MANY_PARMS,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL proc supports more parms than expected: %d [failure expected] \n", dwStatus);
    PrintError(dwStatus);
#endif

    //
    // DLL procedure returns error based on context.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strncpy( inBuffer.DllModuleName,
             MODULE_NAME_VALID,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             PROC_CONTEXT_AS_ERROR,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );
    strncpy( inBuffer.ContextStr,
             CONTEXT_ERROR_STR,
             RTL_NUMBER_OF( inBuffer.ContextStr ) - 1 );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("DLL proc returns error based on context (%s) : %d [failure expected] \n",
           CONTEXT_ERROR_STR,
           dwStatus);
    PrintError(dwStatus);

#endif  // ALLOW_DLL_PARMS


    ////////////////////////////////////
    // Check: AsrpGetLocalDiskInfo
    ////////////////////////////////////

    //
    // Amount of data returned is larger than the buffer we specified.  Should
    // indicate an error and bytesReturned should show how many bytes we need.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strncpy( inBuffer.DllModuleName,
             SYSSETUP_DLL,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             ASRP_GET_LOCAL_DISK_INFO,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       1,
                                       &bytesReturned );

    printf("Output buffer too small (bytes returned %d): %d [failure expected] \n", bytesReturned, dwStatus);
    PrintError(dwStatus);

    if ( 0 == bytesReturned ) {
        printf("Bytes returned is zero, stopping. \n");
        goto FnExit;
    }

    if ( ERROR_MORE_DATA != dwStatus ) {
        printf("Unexpected status returned, stopping. \n");
        goto FnExit;
    }

    //
    // This valid ASR routine should work.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );

    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strncpy( inBuffer.DllModuleName,
             SYSSETUP_DLL,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             ASRP_GET_LOCAL_DISK_INFO,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );

    LocalFree( outBuffer );
    outBuffer = NULL;

    outBufferSize = bytesReturned + 1;
    outBuffer = LocalAlloc( LPTR, outBufferSize );

    if ( !outBuffer ) {
        dwStatus = GetLastError();
        printf("Unable to allocate real buffer size %d bytes, error %d \n",
               outBufferSize,
               dwStatus);
        PrintError(dwStatus);
        goto FnExit;
    }

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("Returned buffer size %d (0x%x) and status %d [success expected] \n",
            bytesReturned,
            bytesReturned,
            dwStatus);

    printf("\nDLL: %s     Proc: %s \n\n",
           inBuffer.DllModuleName,
           inBuffer.DllProcName );

    PrintError(dwStatus);

    if ( NO_ERROR == dwStatus ) {
        DumpBuffer( outBuffer, bytesReturned );
    }

    ////////////////////////////////////
    // Check: AsrpGetLocalVolumeInfo
    ////////////////////////////////////

    //
    // Amount of data returned is larger than the buffer we specified.  Should
    // indicate an error and bytesReturned should show how many bytes we need.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strncpy( inBuffer.DllModuleName,
             SYSSETUP_DLL,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             ASRP_GET_LOCAL_VOLUME_INFO,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       1,
                                       &bytesReturned );

    printf("Output buffer too small (bytes returned %d): %d [failure expected] \n", bytesReturned, dwStatus);
    PrintError(dwStatus);

    if ( 0 == bytesReturned ) {
        printf("Bytes returned is zero, stopping. \n");
        goto FnExit;
    }

    if ( ERROR_MORE_DATA != dwStatus ) {
        printf("Unexpected status returned, stopping. \n");
        goto FnExit;
    }

    //
    // This valid ASR routine should work.
    //

    ZeroMemory( &inBuffer, sizeof(inBuffer) );

    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strncpy( inBuffer.DllModuleName,
             SYSSETUP_DLL,
             RTL_NUMBER_OF( inBuffer.DllModuleName ) - 1 );
    strncpy( inBuffer.DllProcName,
             ASRP_GET_LOCAL_VOLUME_INFO,
             RTL_NUMBER_OF( inBuffer.DllProcName ) - 1 );

    LocalFree( outBuffer );
    outBuffer = NULL;

    outBufferSize = bytesReturned + 1;
    outBuffer = LocalAlloc( LPTR, outBufferSize );

    if ( !outBuffer ) {
        dwStatus = GetLastError();
        printf("Unable to allocate real buffer size %d bytes, error %d \n",
               outBufferSize,
               dwStatus);
        PrintError(dwStatus);
        goto FnExit;
    }

    dwStatus = ClusterResourceControl( hResource,
                                       NULL,
                                       CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
                                       &inBuffer,
                                       inBufferSize,
                                       outBuffer,
                                       outBufferSize,
                                       &bytesReturned );

    printf("Returned buffer size %d (0x%x) and status %d [success expected] \n",
            bytesReturned,
            bytesReturned,
            dwStatus);

    printf("\nDLL: %s     Proc: %s \n\n",
           inBuffer.DllModuleName,
           inBuffer.DllProcName );

    PrintError(dwStatus);

    if ( NO_ERROR == dwStatus ) {
        DumpBuffer( outBuffer, bytesReturned );
    }

FnExit:

    if ( outBuffer ) {
        LocalFree( outBuffer);
    }

    //
    // If you return any kind of error, the enumeration stops.  Since we want to enumerate all
    // the disks, always return success.
    //

    return NO_ERROR;

}   // ResourceCallBack


DWORD
GetResourceInfo(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    )
{
    DWORD dwSignature;
    DWORD dwStatus;

    RESOURCE_STATE resState;

    ZeroMemory( &resState, sizeof(RESOURCE_STATE) );

    dwStatus = GetSignature( hResource, &dwSignature );

    if ( NO_ERROR != dwStatus ) {
        printf("Unable to get signature: %d \n", dwStatus);
        PrintError(dwStatus);
        goto FnExit;
    }

    dwStatus = GetResourceState( hResource, &resState );

    if ( NO_ERROR != dwStatus ) {
        printf("Unable to get resource state: %d \n", dwStatus);
        PrintError(dwStatus);
        goto FnExit;
    }

    printf("\n");
    printf("Signature: %08X \n", dwSignature);
    printf("Node     : %ws \n",  resState.ResNodeName);
    printf("Group    : %ws \n", resState.ResGroupName);

    printf("Status   : %08X - ", resState.State);

    switch( resState.State )
    {
        case ClusterResourceInherited:
            printf("Inherited");
            break;

        case ClusterResourceInitializing:
            printf("Initializing");
            break;

        case ClusterResourceOnline:
            printf("Online");
            break;

        case ClusterResourceOffline:
            printf("Offline");
            break;

        case ClusterResourceFailed:
            printf("Failed");
            break;

        case ClusterResourcePending:
            printf("Pending");
            break;

        case ClusterResourceOnlinePending:
            printf("Online Pending");
            break;

        case ClusterResourceOfflinePending:
            printf("Offline Pending");
            break;

        default:
            printf("Unknown");
    }

    printf("\n");

FnExit:

    if ( resState.ResNodeName ) {
        LocalFree( resState.ResNodeName );
    }

    if ( resState.ResGroupName ) {
        LocalFree( resState.ResGroupName );
    }

    return dwStatus;

} // GetResourceInfo


DWORD
GetResourceState(
    HRESOURCE Resource,
    PRESOURCE_STATE ResState
    )
{
    CLUSTER_RESOURCE_STATE  nState;

    LPWSTR  lpszResNodeName = NULL;
    LPWSTR  lpszResGroupName = NULL;

    DWORD   dwStatus = NO_ERROR;

    nState = WrapGetClusterResourceState( Resource,
                                          &lpszResNodeName,
                                          &lpszResGroupName
                                          );

    if ( nState == ClusterResourceStateUnknown ) {

        dwStatus = GetLastError();
        printf("WrapGetClusterResourceState failed: %d \n", dwStatus);
        PrintError(dwStatus);
        goto FnExit;
    }

    ResState->State = nState;
    ResState->ResNodeName = lpszResNodeName;
    ResState->ResGroupName = lpszResGroupName;

FnExit:

    return dwStatus;

}   // GetResourceState


DWORD
DisplayResourceName(
    RESOURCE_HANDLE hResource
    )
{
    LPWSTR  lpszOutBuffer = NULL;
    DWORD   dwStatus;
    DWORD   dwBytesReturned;

    dwStatus = WrapClusterResourceControl( hResource,
                                          CLUSCTL_RESOURCE_GET_NAME,
                                          &lpszOutBuffer,
                                          &dwBytesReturned );

    if ( NO_ERROR == dwStatus ) {
        wprintf( L"Resource Name: %ls\n", lpszOutBuffer );

    } else {
        printf("CLUSCTL_RESOURCE_GET_NAME failed: %d \n", dwStatus);
        PrintError(dwStatus);
    }

    if (lpszOutBuffer) {
        LocalFree(lpszOutBuffer);
    }

    return dwStatus;

}   // DisplayResourceName


DWORD
GetSignature(
    RESOURCE_HANDLE hResource,
    DWORD *dwSignature
    )
{
    PBYTE   outBuffer = NULL;

    DWORD   dwStatus;
    DWORD   dwBytesReturned;

    dwStatus = WrapClusterResourceControl( hResource,
                                          CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                                          &outBuffer,
                                          &dwBytesReturned );

    if ( NO_ERROR == dwStatus ) {

        if ( !GetSignatureFromDiskInfo(outBuffer, dwSignature, dwBytesReturned) ) {
            printf("Unable to get signature from DiskInfo. \n");
            dwStatus = ERROR_BAD_FORMAT;
        }

    } else {
        printf("CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO failed: %d \n", dwStatus);
        PrintError(dwStatus);
    }

    if (outBuffer) {
        LocalFree(outBuffer);
    }

    return dwStatus;

}   // GetSignature

BOOLEAN
GetSignatureFromDiskInfo(
    PBYTE DiskInfo,
    DWORD *Signature,
    DWORD DiskInfoSize
    )
{
#if TEST_PARSE_ROUTINE

    PCLUSPROP_DISK_NUMBER   diskNumber = NULL;
    PCLUSPROP_SCSI_ADDRESS  scsiAddress = NULL;
    PCLUSPROP_PARTITION_INFO    partInfo = NULL;

    PBYTE   junkInfo = NULL;
    PDWORD  dumpInfo = (PDWORD)DiskInfo;

#endif

    PCLUSPROP_DISK_SIGNATURE    diskSignature = NULL;

    diskSignature = (PCLUSPROP_DISK_SIGNATURE)ParseDiskInfo( DiskInfo,
                                                             DiskInfoSize,
                                                             CLUSPROP_SYNTAX_DISK_SIGNATURE );

    if ( !diskSignature ) {
        return FALSE;
    }

    *Signature = diskSignature->dw;

#if TEST_PARSE_ROUTINE

    diskNumber = (PCLUSPROP_DISK_NUMBER)ParseDiskInfo( DiskInfo,
                                                       DiskInfoSize,
                                                       CLUSPROP_SYNTAX_DISK_NUMBER );

    if ( diskNumber ) {
        printf("diskNumber->Syntax:   %08X \n", diskNumber->Syntax);
        printf("diskNumber->cbLength: %08X \n", diskNumber->cbLength);
        printf("diskNumber->dw:       %08X \n", diskNumber->dw);
    }

    scsiAddress = (PCLUSPROP_SCSI_ADDRESS)ParseDiskInfo( DiskInfo,
                                                         DiskInfoSize,
                                                         CLUSPROP_SYNTAX_SCSI_ADDRESS );

    if ( scsiAddress ) {
        printf("scsiAddress->Syntax:     %08X \n", scsiAddress->Syntax);
        printf("scsiAddress->cbLength:   %08X \n", scsiAddress->cbLength);
        printf("scsiAddress->PortNumber: %02X \n", scsiAddress->PortNumber);
        printf("scsiAddress->PathId:     %02X \n", scsiAddress->PathId);
        printf("scsiAddress->TargetId:   %02X \n", scsiAddress->TargetId);
        printf("scsiAddress->Lun:        %02X \n", scsiAddress->Lun);
    }

    partInfo = (PCLUSPROP_PARTITION_INFO)ParseDiskInfo( DiskInfo,
                                                        DiskInfoSize,
                                                        CLUSPROP_SYNTAX_PARTITION_INFO );

    if ( partInfo ) {

        printf("Partition info... \n");
    }


    //
    // The following should fail...
    //

    junkInfo = ParseDiskInfo( DiskInfo,
                              DiskInfoSize,
                              -1 );

    if (junkInfo) {
        printf("Problem parsing list.  Used invalid syntax and pointer returned! \n");
    }

#endif


    return TRUE;

}   // GetSignatureFromDiskInfo


LPBYTE
ParseDiskInfo(
    PBYTE DiskInfo,
    DWORD DiskInfoSize,
    DWORD SyntaxValue
    )
{
    CLUSPROP_BUFFER_HELPER ListEntry; // used to parse the value list

    DWORD  cbOffset    = 0;    // offset to next entry in the value list
    DWORD  cbPosition  = 0;    // tracks the advance through the value list buffer

    LPBYTE returnPtr = 0;

    ListEntry.pb = DiskInfo;

    while (TRUE) {

        if ( CLUSPROP_SYNTAX_ENDMARK == *ListEntry.pdw ) {
            break;
        }

        cbOffset = ALIGN_CLUSPROP( ListEntry.pValue->cbLength + sizeof(CLUSPROP_VALUE) );

        //
        // Check for specific syntax in the property list.
        //

        if ( SyntaxValue == *ListEntry.pdw ) {

            //
            // Make sure the complete entry fits in the buffer specified.
            //

            if ( cbPosition + cbOffset > DiskInfoSize ) {

                printf("Possibly corrupt list!  \n");

            } else {

                returnPtr = ListEntry.pb;
            }

            break;
        }

        //
        // Verify that the offset to the next entry is
        // within the value list buffer, then advance
        // the CLUSPROP_BUFFER_HELPER pointer.
        //
        cbPosition += cbOffset;
        if ( cbPosition > DiskInfoSize ) break;
        ListEntry.pb += cbOffset;
    }

    return returnPtr;

}   // ParseDiskInfo



VOID
PrintError(
    IN DWORD ErrorCode
    )
{
    LPVOID lpMsgBuf;
    ULONG count;

    count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          ErrorCode,
                          0,
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL
                          );

    if (count != 0) {
        printf("  (%d) %s\n", ErrorCode, (LPCTSTR) lpMsgBuf);
        LocalFree( lpMsgBuf );
    } else {
        printf("Format message failed.  Error: %d\n", GetLastError());
    }

}   // PrintError


DWORD
WrapClusterResourceControl(
    RESOURCE_HANDLE hResource,
    DWORD dwControlCode,
    LPVOID *OutBuffer,
    DWORD *dwBytesReturned
    )
{
    DWORD dwStatus;

    DWORD  cbOutBufferSize  = MAX_NAME_SIZE;
    DWORD  cbResultSize     = MAX_NAME_SIZE;
    LPVOID tempOutBuffer    = LocalAlloc( LPTR, cbOutBufferSize );

    dwStatus = ClusterResourceControl( hResource,
                                      NULL,
                                      dwControlCode,
                                      NULL,
                                      0,
                                      tempOutBuffer,
                                      cbOutBufferSize,
                                      &cbResultSize );

    //
    // Reallocation routine if buffer is too small
    //

    if ( ERROR_MORE_DATA == dwStatus )
    {
        LocalFree( tempOutBuffer );

        cbOutBufferSize = cbResultSize;

        tempOutBuffer = LocalAlloc( LPTR, cbOutBufferSize );

        dwStatus = ClusterResourceControl( hResource,
                                          NULL,
                                          dwControlCode,
                                          NULL,
                                          0,
                                          tempOutBuffer,
                                          cbOutBufferSize,
                                          &cbResultSize );
    }

    //
    // On success, give the user the allocated buffer.  The user is responsible
    // for freeing this buffer.  On failure, free the buffer and return a status.
    //

    if ( NO_ERROR == dwStatus ) {
        *OutBuffer = tempOutBuffer;
        *dwBytesReturned = cbResultSize;
    } else {
        *OutBuffer = NULL;
        *dwBytesReturned = 0;
        LocalFree( tempOutBuffer );
    }

    return dwStatus;

}   // WrapClusterResourceControl



CLUSTER_RESOURCE_STATE WINAPI WrapGetClusterResourceState(
	IN HRESOURCE hResource,
	OUT OPTIONAL LPWSTR * ppwszNodeName,
	OUT OPTIONAL LPWSTR * ppwszGroupName
	)
{
	CLUSTER_RESOURCE_STATE	cState = ClusterResourceStateUnknown;
	LPWSTR					pwszNodeName = NULL;
	DWORD					cchNodeName = 128;
	LPWSTR					pwszGroupName = NULL;
	DWORD					cchGroupName = 128;
	DWORD					cchTempNodeName = cchNodeName;
	DWORD					cchTempGroupName = cchGroupName;

	// Zero the out parameters
	if ( ppwszNodeName != NULL )
	{
		*ppwszNodeName = NULL;
	}

	if ( ppwszGroupName != NULL )
	{
		*ppwszGroupName = NULL;
	}

	pwszNodeName = (LPWSTR) LocalAlloc( LPTR, cchNodeName * sizeof( *pwszNodeName ) );
	if ( pwszNodeName != NULL )
	{
		pwszGroupName = (LPWSTR) LocalAlloc( LPTR, cchGroupName * sizeof( *pwszGroupName ) );
		if ( pwszGroupName != NULL )
		{
			cState = GetClusterResourceState( hResource, pwszNodeName, &cchTempNodeName, pwszGroupName, &cchTempGroupName );
			if ( GetLastError() == ERROR_MORE_DATA )
			{
				cState = ClusterResourceStateUnknown;	// reset to error condition

				LocalFree( pwszNodeName );
				pwszNodeName = NULL;
				cchNodeName = ++cchTempNodeName;

				LocalFree( pwszGroupName );
				pwszGroupName = NULL;
				cchGroupName = ++cchTempGroupName;

				pwszNodeName = (LPWSTR) LocalAlloc( LPTR, cchNodeName * sizeof( *pwszNodeName ) );
				if ( pwszNodeName != NULL )
				{
					pwszGroupName = (LPWSTR) LocalAlloc( LPTR, cchGroupName * sizeof( *pwszGroupName ) );
					if ( pwszGroupName != NULL )
					{
						cState = GetClusterResourceState( hResource,
															pwszNodeName,
															&cchNodeName,
															pwszGroupName,
															&cchGroupName );
					}
				}
			}
		}
	}

	//
	// if there was not an error and the argument was not NULL, then return the string.
	//
	if ( ( cState != ClusterResourceStateUnknown ) && ( ppwszNodeName != NULL ) )
	{
		*ppwszNodeName = pwszNodeName;
	}

	//
	// if there was not an error and the argument was not NULL, then return the string.
	//
	if ( ( cState != ClusterResourceStateUnknown ) && ( ppwszGroupName != NULL ) )
	{
		*ppwszGroupName = pwszGroupName;
	}

	//
	// if there was an error or the argument was NULL, then free the string.
	//
	if ( ( cState == ClusterResourceStateUnknown ) || ( ppwszNodeName == NULL ) )
	{
		LocalFree( pwszNodeName );
	}

	//
	// if there was an error or the argument was NULL, then free the string.
	//
	if ( ( cState == ClusterResourceStateUnknown ) || ( ppwszGroupName == NULL ) )
	{
		LocalFree( pwszGroupName );
	}

	return cState;

} //*** WrapGetClusterResourceState()


#define MAX_COLUMNS 16

VOID
DumpBuffer(
    IN PUCHAR Buffer,
    IN DWORD ByteCount
    )
{
    DWORD   idx;
    DWORD   jdx;
    DWORD   columns;

    UCHAR   tempC;

    if ( !Buffer || !ByteCount ) {
        printf("Invalid parameter specified: buffer %p  byte count %d \n", Buffer, ByteCount);
        return;
    }

    //
    // Print header.
    //

    printf("\n");
    printf(" Address   00 01 02 03 04 05 06 07 - 08 09 0a 0b 0c 0d 0e 0f \n");
    printf("---------  -- -- -- -- -- -- -- --   -- -- -- -- -- -- -- -- ");

    for ( idx = 0; idx < ByteCount; idx += MAX_COLUMNS ) {

        if ( idx % MAX_COLUMNS == 0 ) {
            printf("\n%08x:  ", idx);
        }

        if ( ByteCount - idx >= MAX_COLUMNS ) {
            columns = MAX_COLUMNS;
        } else {
            columns = ByteCount - idx;
        }

        for ( jdx = 0; jdx < MAX_COLUMNS; jdx++) {

            if ( jdx == 8 ) {
                printf("- ");
            }

            if ( jdx < columns ) {
                printf("%02x ", Buffer[idx+jdx]);
            } else {
                printf("   ");
            }
        }

        printf("   ");

        for ( jdx = 0; jdx < columns; jdx++ ) {

            tempC = Buffer[idx+jdx];

            if ( isprint(tempC) ) {
                printf("%c", tempC);
            } else {
                printf(".");
            }

        }

    }

    printf("\n\n");

}   // DumpBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\ddxddv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.cpp
//
//	Description:
//		Implementation of custom dialog data exchange/dialog data validation
//		routines.
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//		The IDS_REQUIRED_FIELD_EMPTY string resource must be defined in
//		the resource file.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DDxDDv.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////
static void CleanupLabel(LPTSTR psz);


/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDX_Number
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		dwValue		[IN OUT] Value to set or get.
//		dwMin		[IN] Minimum value.
//		dwMax		[IN] Maximum value.
//		bSigned		[IN] TRUE = value is signed, FALSE = value is unsigned
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned
	)
{
	HWND	hwndCtrl;
	DWORD	dwValue;

	ASSERT(pDX != NULL);
#ifdef _DEBUG
	if (bSigned)
	{
		ASSERT((LONG) dwMin < (LONG) dwMax);
	}
	else
	{
		ASSERT(dwMin < dwMax);
	}
#endif // _DEBUG

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Get the control window handle.
	hwndCtrl = pDX->PrepareEditCtrl(nIDC);

	if (pDX->m_bSaveAndValidate)
	{
		BOOL	bTranslated;

		// Get the number from the control.
		dwValue = GetDlgItemInt(pDX->m_pDlgWnd->m_hWnd, nIDC, &bTranslated, bSigned);

		// If the retrival failed, it is a signed number, and the minimum
		// value is the smallest negative value possible, check the string itself.
		if (!bTranslated && bSigned && (dwMin == 0x80000000))
		{
			UINT	cch;
			TCHAR	szNumber[20];

			// See if it is the smallest negative number.
			cch = GetDlgItemText(pDX->m_pDlgWnd->m_hWnd, nIDC, szNumber, sizeof(szNumber) / sizeof(TCHAR));
			if ((cch != 0) && (lstrcmp(szNumber, _T("-2147483648")) == 0))
			{
				dwValue = 0x80000000;
				bTranslated = TRUE;
			}  // if:  text retrieved successfully and is highest negative number
		}  // if:  error translating number and getting signed number

		// If the retrieval failed or the specified number is
		// out of range, display an error.
		if (   !bTranslated
			|| (bSigned && (((LONG) dwValue < (LONG) dwMin) || ((LONG) dwValue > (LONG) dwMax)))
			|| (!bSigned && ((dwValue < dwMin) || (dwValue > dwMax)))
			)
		{
			TCHAR szMin[32];
			TCHAR szMax[32];
			CString strPrompt;

			if (bSigned)
			{
				wsprintf(szMin, _T("%d%"), dwMin);
				wsprintf(szMax, _T("%d%"), dwMax);
			}  // if:  signed number
			else
			{
				wsprintf(szMin, _T("%u%"), dwMin);
				wsprintf(szMax, _T("%u%"), dwMax);
			}  // else:  unsigned number
			AfxFormatString2(strPrompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_INT_RANGE);
			strPrompt.Empty(); // exception prep
			pDX->Fail();
		}  // if:  invalid string
		else
			rdwValue = dwValue;
	}  // if:  saving data
	else
	{
		CString		strMinValue;
		CString		strMaxValue;
		UINT		cchMax;

		// Set the maximum number of characters that can be entered.
		if (bSigned)
		{
			strMinValue.Format(_T("%d"), dwMin);
			strMaxValue.Format(_T("%d"), dwMax);
		}  // if:  signed value
		else
		{
			strMinValue.Format(_T("%u"), dwMin);
			strMaxValue.Format(_T("%u"), dwMax);
		}  // else:  unsigned value
		cchMax = max(strMinValue.GetLength(), strMaxValue.GetLength());
		SendMessage(hwndCtrl, EM_LIMITTEXT, cchMax, 0);

		// Set the value into the control.
		if (bSigned)
		{
			LONG lValue = (LONG) rdwValue;
			DDX_Text(pDX, nIDC, lValue);
		}  // if:  signed value
		else
			DDX_Text(pDX, nIDC, rdwValue);
	}  // else:  setting data onto the dialog

}  //*** DDX_Number()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DDV_RequiredText
//
//	Routine Description:
//		Validate that the dialog string is present.
//
//	Arguments:
//		pDX			[IN OUT] Data exchange object 
//		nIDC		[IN] Control ID.
//		nIDCLabel	[IN] Label control ID.
//		rstrValue	[IN] Value to set or get.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	)
{
	ASSERT(pDX != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (pDX->m_bSaveAndValidate)
	{
		if (rstrValue.GetLength() == 0)
		{
			HWND		hwndLabel;
			TCHAR		szLabel[1024];
			CString		strPrompt;

			// Get the label window handle
			hwndLabel = pDX->PrepareEditCtrl(nIDCLabel);

			// Get the text of the label.
			GetWindowText(hwndLabel, szLabel, sizeof(szLabel) / sizeof(TCHAR));

			// Remove ampersands (&) and colons (:).
			CleanupLabel(szLabel);

			// Format and display a message.
			strPrompt.FormatMessage(IDS_REQUIRED_FIELD_EMPTY, szLabel);
			AfxMessageBox(strPrompt, MB_ICONEXCLAMATION);

			// Do this so that the control receives focus.
			(void) pDX->PrepareEditCtrl(nIDC);

			// Fail the call.
			strPrompt.Empty();	// exception prep
			pDX->Fail();
		}  // if:  field not specified
	}  // if:  saving data

}  //*** DDV_RequiredText()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupLabel
//
//	Routine Description:
//		Prepare a label read from a dialog to be used as a string in a
//		message by removing ampersands (&) and colons (:).
//
//	Arguments:
//		pszLabel	[IN OUT] Label to be cleaned up.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
static void CleanupLabel(LPTSTR pszLabel)
{
	LPTSTR	pIn, pOut;
	LANGID	langid;
	WORD	primarylangid;
	BOOL	bFELanguage;

	// Get the language ID.
	langid = GetUserDefaultLangID();
	primarylangid = (WORD) PRIMARYLANGID(langid);
	bFELanguage = ((primarylangid == LANG_JAPANESE)
					|| (primarylangid == LANG_CHINESE)
					|| (primarylangid == LANG_KOREAN));

	//
	// copy the name sans '&' and ':' chars
	//

	pIn = pOut = pszLabel;
	do
	{
		//
		// strip FE accelerators with parentheses. e.g. "foo(&F)" -> "foo"
		//
		if (   bFELanguage
			&& (pIn[0] == _T('('))
			&& (pIn[1] == _T('&'))
			&& (pIn[2] != _T('\0'))
			&& (pIn[3] == _T(')')))
		{
			pIn += 3;
		}
		else if ((*pIn != _T('&')) && (*pIn != _T(':')))
			*pOut++ = *pIn;
	} while (*pIn++ != _T('\0')) ;

}  //*** CleanupLabel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.cpp
//
//	Description:
//		Implementation of the CBasePropertyPage class.
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <clusapi.h>
#include "DummyEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePropertyPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBasePropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CBasePropertyPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(void)
{
	CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		nIDTemplate		[IN] Dialog template resource ID.
//		nIDCaption		[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
	IN UINT		nIDTemplate,
	IN UINT		nIDCaption
	)
	: CPropertyPage(nIDTemplate, nIDCaption)
{
	CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CommonConstruct
//
//	Routine Description:
//		Common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct(void)
{
	//{{AFX_DATA_INIT(CBasePropertyPage)
	//}}AFX_DATA_INIT

	m_peo = NULL;
	m_hpage = NULL;
	m_bBackPressed = FALSE;

	m_iddPropertyPage = NULL;
	m_iddWizardPage = NULL;
	m_idsCaption = NULL;

	m_bDoDetach = FALSE;

}  //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		peo			[IN OUT] Pointer to the extension object.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BInit(IN OUT CExtObject * peo)
{
	ASSERT(peo != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	m_peo = peo;

	// Don't display a help button.
	m_psp.dwFlags &= ~PSP_HASHELP;

	// Construct the property page.
	if (Peo()->BWizard())
	{
		ASSERT(IddWizardPage() != NULL);
		Construct(IddWizardPage(), IdsCaption());
	}  // if:  adding page to wizard
	else
	{
		ASSERT(IddPropertyPage() != NULL);
		Construct(IddPropertyPage(), IdsCaption());
	}  // else:  adding page to property sheet

	// Read the properties private to this resource and parse them.
	{
		DWORD			dwStatus = ERROR_SUCCESS;
		CClusPropList	cpl;

		ASSERT(Peo() != NULL);
		ASSERT(Peo()->PodObjData());

		// Read the properties.
		switch (Cot())
		{
			case CLUADMEX_OT_NODE:
				ASSERT(Peo()->PndNodeData()->m_hnode != NULL);
				dwStatus = cpl.DwGetNodeProperties(
										Peo()->PndNodeData()->m_hnode,
										CLUSCTL_NODE_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_GROUP:
				ASSERT(Peo()->PgdGroupData()->m_hgroup != NULL);
				dwStatus = cpl.DwGetGroupProperties(
										Peo()->PgdGroupData()->m_hgroup,
										CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_RESOURCE:
				ASSERT(Peo()->PrdResData()->m_hresource != NULL);
				dwStatus = cpl.DwGetResourceProperties(
										Peo()->PrdResData()->m_hresource,
										CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_RESOURCETYPE:
				ASSERT(Peo()->PodObjData()->m_strName.GetLength() > 0);
				dwStatus = cpl.DwGetResourceTypeProperties(
										Hcluster(),
										Peo()->PodObjData()->m_strName,
										CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_NETWORK:
				ASSERT(Peo()->PndNetworkData()->m_hnetwork != NULL);
				dwStatus = cpl.DwGetNetworkProperties(
										Peo()->PndNetworkData()->m_hnetwork,
										CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES
										);
				break;
			case CLUADMEX_OT_NETINTERFACE:
				ASSERT(Peo()->PndNetInterfaceData()->m_hnetinterface != NULL);
				dwStatus = cpl.DwGetNetInterfaceProperties(
										Peo()->PndNetInterfaceData()->m_hnetinterface,
										CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES
										);
				break;
			default:
				ASSERT(0);
		}  // switch:  object type

		// Parse the properties.
		if (dwStatus == ERROR_SUCCESS)
		{
			// Parse the properties.
			try
			{
				dwStatus = DwParseProperties(cpl);
			}  // try
			catch (CMemoryException * pme)
			{
				dwStatus = ERROR_NOT_ENOUGH_MEMORY;
				pme->Delete();
			}  // catch:  CMemoryException
		}  // if:  properties read successfully

		if (dwStatus != ERROR_SUCCESS)
		{
			return FALSE;
		}  // if:  error parsing getting or parsing properties
	}  // Read the properties private to this resource and parse them

	return TRUE;

}  //*** CBasePropertyPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DwParseProperties
//
//	Routine Description:
//		Parse the properties of the resource.  This is in a separate function
//		from BInit so that the optimizer can do a better job.
//
//	Arguments:
//		rcpl			[IN] Cluster property list to parse.
//
//	Return Value:
//		ERROR_SUCCESS	Properties were parsed successfully.
//
//	Exceptions Thrown:
//		Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::DwParseProperties(IN const CClusPropList & rcpl)
{
	DWORD							cProps;
	DWORD							cprop;
	DWORD							cbProps;
	const CObjectProperty *			pprop;
	CLUSPROP_BUFFER_HELPER			props;
	CLUSPROP_PROPERTY_NAME const *	pName;

	ASSERT(rcpl.PbProplist() != NULL);

	props.pb = rcpl.PbProplist();
	cbProps = rcpl.CbProplist();

	// Loop through each property.
	for (cProps = *(props.pdw++) ; cProps > 0 ; cProps--)
	{
		pName = props.pName;
		ASSERT(pName->Syntax.dw == CLUSPROP_SYNTAX_NAME);
		props.pb += sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

		// Decrement the counter by the size of the name.
		ASSERT(cbProps > sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength));
		cbProps -= sizeof(*pName) + ALIGN_CLUSPROP(pName->cbLength);

		ASSERT(cbProps > sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength));

		// Parse known properties.
		for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
		{
			if (lstrcmpiW(pName->sz, pprop->m_pwszName) == 0)
			{
				ASSERT(props.pSyntax->wFormat == pprop->m_propFormat);
				switch (pprop->m_propFormat)
				{
					case CLUSPROP_FORMAT_SZ:
					case CLUSPROP_FORMAT_EXPAND_SZ:
						ASSERT((props.pValue->cbLength == (lstrlenW(props.pStringValue->sz) + 1) * sizeof(WCHAR))
								|| ((props.pValue->cbLength == 0) && (props.pStringValue->sz[0] == L'\0')));
						*pprop->m_value.pstr = props.pStringValue->sz;
						*pprop->m_valuePrev.pstr = props.pStringValue->sz;
						break;
					case CLUSPROP_FORMAT_DWORD:
					case CLUSPROP_FORMAT_LONG:
						ASSERT(props.pValue->cbLength == sizeof(DWORD));
						*pprop->m_value.pdw = props.pDwordValue->dw;
						*pprop->m_valuePrev.pdw = props.pDwordValue->dw;
						break;
					case CLUSPROP_FORMAT_BINARY:
					case CLUSPROP_FORMAT_MULTI_SZ:
						*pprop->m_value.ppb = props.pBinaryValue->rgb;
						*pprop->m_value.pcb = props.pBinaryValue->cbLength;
						*pprop->m_valuePrev.ppb = props.pBinaryValue->rgb;
						*pprop->m_valuePrev.pcb = props.pBinaryValue->cbLength;
						break;
					default:
						ASSERT(0);	// don't know how to deal with this type
				}  // switch:  property format

				// Exit the loop since we found the parameter.
				break;
			}  // if:  found a match
		}  // for:  each property

		// If the property wasn't known, ask the derived class to parse it.
		if (cprop == 0)
		{
			DWORD		dwStatus;

			dwStatus = DwParseUnknownProperty(pName->sz, props, cbProps);
			if (dwStatus != ERROR_SUCCESS)
				return dwStatus;
		}  // if:  property not parsed

		// Advance the buffer pointer past the value in the value list.
		while ((props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
				&& (cbProps > 0))
		{
			ASSERT(cbProps > sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength));
			cbProps -= sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
			props.pb += sizeof(*props.pValue) + ALIGN_CLUSPROP(props.pValue->cbLength);
		}  // while:  more values in the list

		// Advance the buffer pointer past the value list endmark.
		ASSERT(cbProps >= sizeof(*props.pSyntax));
		cbProps -= sizeof(*props.pSyntax);
		props.pb += sizeof(*props.pSyntax); // endmark
	}  // for:  each property

	return ERROR_SUCCESS;

}  //*** CBasePropertyPage::DwParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCreate
//
//	Routine Description:
//		Handler for the WM_CREATE message.
//
//	Arguments:
//		lpCreateStruct	[IN OUT] Window create structure.
//
//	Return Value:
//		-1		Error.
//		0		Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Attach the window to the property page structure.
	// This has been done once already in the main application, since the
	// main application owns the property sheet.  It needs to be done here
	// so that the window handle can be found in the DLL's handle map.
	if (FromHandlePermanent(m_hWnd) == NULL) // is the window handle already in the handle map
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach(hWnd);
		m_bDoDetach = TRUE;
	} // if: is the window handle in the handle map

	return CPropertyPage::OnCreate(lpCreateStruct);

}  //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnDestroy
//
//	Routine Description:
//		Handler for the WM_DESTROY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Detach the window from the property page structure.
	// This will be done again by the main application, since it owns the
	// property sheet.  It needs to be done here so that the window handle
	// can be removed from the DLL's handle map.
	if (m_bDoDetach)
	{
		if (m_hWnd != NULL)
		{
			HWND hWnd = m_hWnd;

			Detach();
			m_hWnd = hWnd;
		} // if: do we have a window handle?
	} // if: do we need to balance the attach we did with a detach?

	CPropertyPage::OnDestroy();

}  //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange(CDataExchange * pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//{{AFX_DATA_MAP(CBasePropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
	DDX_Control(pDX, IDC_PP_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_PP_TITLE, m_staticTitle);

	if (pDX->m_bSaveAndValidate)
	{
		if (!BBackPressed())
		{
			CWaitCursor	wc;

			// Validate the data.
			if (!BSetPrivateProps(TRUE /*bValidateOnly*/))
				pDX->Fail();
		}  // if:  Back button not pressed
	}  // if:  saving data from dialog
	else
	{
		// Set the title.
		DDX_Text(pDX, IDC_PP_TITLE, m_strTitle);
	}  // if:  not saving data

	CPropertyPage::DoDataExchange(pDX);

}  //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog(void)
{
	ASSERT(Peo() != NULL);
	ASSERT(Peo()->PodObjData() != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Set the title string.
	m_strTitle = Peo()->PodObjData()->m_strName;

	// Call the base class method.
	CPropertyPage::OnInitDialog();

	// Display an icon for the object.
	if (Peo()->Hicon() != NULL)
		m_staticIcon.SetIcon(Peo()->Hicon());

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive(void)
{
	HRESULT		hr;

	ASSERT(Peo() != NULL);
	ASSERT(Peo()->PodObjData() != NULL);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Reread the data.
	hr = Peo()->HrGetObjectInfo();
	if (hr != NOERROR)
		return FALSE;

	// Set the title string.
	m_strTitle = Peo()->PodObjData()->m_strName;

	m_bBackPressed = FALSE;
	return CPropertyPage::OnSetActive();

}  //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnApply
//
//	Routine Description:
//		Handler for the PSM_APPLY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply(void)
{
	ASSERT(!BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return FALSE;

	if (!BApplyChanges())
		return FALSE;

	return CPropertyPage::OnApply();

}  //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardBack
//
//	Routine Description:
//		Handler for the PSN_WIZBACK message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack(void)
{
	LRESULT		lResult;

	ASSERT(BWizard());

	lResult = CPropertyPage::OnWizardBack();
	if (lResult != -1)
		m_bBackPressed = TRUE;

	return lResult;

}  //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardNext
//
//	Routine Description:
//		Handler for the PSN_WIZNEXT message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext(void)
{
	ASSERT(BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return -1;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return -1;

	// Create the object.

	return CPropertyPage::OnWizardNext();

}  //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardFinish
//
//	Routine Description:
//		Handler for the PSN_WIZFINISH message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		FALSE	Don't change the page.
//		TRUE	Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish(void)
{
	ASSERT(BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return FALSE;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return FALSE;

	return CPropertyPage::OnWizardFinish();

}  //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnChangeCtrl
//
//	Routine Description:
//		Handler for the messages sent when a control is changed.  This
//		method can be specified in a message map if all that needs to be
//		done is enable the Apply button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SetModified(TRUE);

}  //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::EnableNext
//
//	Routine Description:
//		Enables or disables the NEXT or FINISH button.
//
//	Arguments:
//		bEnable		[IN] TRUE = enable the button, FALSE = disable the button.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext(IN BOOL bEnable /*TRUE*/)
{
	ASSERT(BWizard());

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	PiWizardCallback()->EnableNext((LONG *) Hpage(), bEnable);

}  //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CWaitCursor	wc;

	// Save data.
	return BSetPrivateProps();

}  //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BuildPropList
//
//	Routine Description:
//		Build the property list.
//
//	Arguments:
//		rcpl		[IN OUT] Cluster property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CClusPropList::AddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::BuildPropList(
	IN OUT CClusPropList & rcpl
	)
{
	DWORD					cprop;
	const CObjectProperty *	pprop;

	for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
	{
		switch (pprop->m_propFormat)
		{
			case CLUSPROP_FORMAT_SZ:
			case CLUSPROP_FORMAT_EXPAND_SZ:
				rcpl.AddProp(
						pprop->m_pwszName,
						*pprop->m_value.pstr,
						*pprop->m_valuePrev.pstr
						);
				break;
			case CLUSPROP_FORMAT_DWORD:
				rcpl.AddProp(
						pprop->m_pwszName,
						*pprop->m_value.pdw,
						*pprop->m_valuePrev.pdw
						);
				break;
			case CLUSPROP_FORMAT_BINARY:
			case CLUSPROP_FORMAT_MULTI_SZ:
				rcpl.AddProp(
						pprop->m_pwszName,
						*pprop->m_value.ppb,
						*pprop->m_value.pcb,
						*pprop->m_valuePrev.ppb,
						*pprop->m_valuePrev.pcb
						);
				break;
			default:
				ASSERT(0);	// don't know how to deal with this type
				return;
		}  // switch:  property format
	}  // for:  each property

}  //*** CBasePropertyPage::BuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BSetPrivateProps
//
//	Routine Description:
//		Set the private properties for this object.
//
//	Arguments:
//		bValidateOnly	[IN] TRUE = only validate the data.
//
//	Return Value:
//		ERROR_SUCCESS	The operation was completed successfully.
//		!0				Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BSetPrivateProps(IN BOOL bValidateOnly)
{
	BOOL			bSuccess	= TRUE;
	CClusPropList	cpl(BWizard() /*bAlwaysAddProp*/);
	CWaitCursor	wc;

	ASSERT(Peo() != NULL);

	// Build the property list.
	try
	{
		BuildPropList(cpl);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		bSuccess = FALSE;
	}  // catch:  CException

	// Set the data.
	if (bSuccess)
	{
		if ((cpl.PbProplist() != NULL) && (cpl.CbProplist() > 0))
		{
			DWORD		dwStatus = ERROR_SUCCESS;
			DWORD		dwControlCode;
			DWORD		cbProps;

			switch (Cot())
			{
				case CLUADMEX_OT_NODE:
					ASSERT(Peo()->PndNodeData() != NULL);
					ASSERT(Peo()->PndNodeData()->m_hnode != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_NODE_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterNodeControl(
									Peo()->PndNodeData()->m_hnode,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_GROUP:
					ASSERT(Peo()->PgdGroupData() != NULL);
					ASSERT(Peo()->PgdGroupData()->m_hgroup != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterGroupControl(
									Peo()->PgdGroupData()->m_hgroup,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_RESOURCE:
					ASSERT(Peo()->PrdResData() != NULL);
					ASSERT(Peo()->PrdResData()->m_hresource != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterResourceControl(
									Peo()->PrdResData()->m_hresource,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_RESOURCETYPE:
					ASSERT(Peo()->PodObjData() != NULL);
					ASSERT(Peo()->PodObjData()->m_strName.GetLength() > 0);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterResourceTypeControl(
									Hcluster(),
									Peo()->PodObjData()->m_strName,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_NETWORK:
					ASSERT(Peo()->PndNetworkData() != NULL);
					ASSERT(Peo()->PndNetworkData()->m_hnetwork != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_NETWORK_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_NETWORK_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterNetworkControl(
									Peo()->PndNetworkData()->m_hnetwork,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				case CLUADMEX_OT_NETINTERFACE:
					ASSERT(Peo()->PndNetInterfaceData() != NULL);
					ASSERT(Peo()->PndNetInterfaceData()->m_hnetinterface != NULL);

					// Determine which control code to use.
					if (bValidateOnly)
						dwControlCode = CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES;
					else
						dwControlCode = CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES;

					// Set private properties.
					dwStatus = ClusterNetInterfaceControl(
									Peo()->PndNetInterfaceData()->m_hnetinterface,
									NULL,	// hNode
									dwControlCode,
									cpl.PbProplist(),
									cpl.CbProplist(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&cbProps
									);
					break;
				default:
					ASSERT(0);
			}  // switch:  object type

			// Handle errors.
			if (dwStatus != ERROR_SUCCESS)
			{
				CString strMsg;
				FormatError(strMsg, dwStatus);
				AfxMessageBox(strMsg);
				if (bValidateOnly
						|| (dwStatus != ERROR_RESOURCE_PROPERTIES_STORED))
					bSuccess = FALSE;
			}  // if:  error setting/validating data
		}  // if:  there is data to set
	}  // if:  no errors building the property list

	// Save data locally.
	if (!bValidateOnly && bSuccess)
	{
		// Save new values as previous values.
		try
		{
			DWORD					cprop;
			const CObjectProperty *	pprop;

			for (pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop--)
			{
				switch (pprop->m_propFormat)
				{
					case CLUSPROP_FORMAT_SZ:
					case CLUSPROP_FORMAT_EXPAND_SZ:
						ASSERT(pprop->m_value.pstr != NULL);
						ASSERT(pprop->m_valuePrev.pstr != NULL);
						*pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
						break;
					case CLUSPROP_FORMAT_DWORD:
						ASSERT(pprop->m_value.pdw != NULL);
						ASSERT(pprop->m_valuePrev.pdw != NULL);
						*pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
						break;
					case CLUSPROP_FORMAT_BINARY:
					case CLUSPROP_FORMAT_MULTI_SZ:
						ASSERT(pprop->m_value.ppb != NULL);
						ASSERT(*pprop->m_value.ppb != NULL);
						ASSERT(pprop->m_value.pcb != NULL);
						ASSERT(pprop->m_valuePrev.ppb != NULL);
						ASSERT(*pprop->m_valuePrev.ppb != NULL);
						ASSERT(pprop->m_valuePrev.pcb != NULL);
						delete [] *pprop->m_valuePrev.ppb;
						*pprop->m_valuePrev.ppb = new BYTE[*pprop->m_value.pcb];
						CopyMemory(*pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb);
						*pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
						break;
					default:
						ASSERT(0);	// don't know how to deal with this type
				}  // switch:  property format
			}  // for:  each property
		}  // try
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
			bSuccess = FALSE;
		}  // catch:  CException
	}  // if:  not just validating and successful so far

	return bSuccess;

}  //*** CBasePropertyPage::BSetPrivateProps()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\ddxddv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		DDxDDv.h
//
//	Description:
//		Definition of custom dialog data exchange/dialog data validation
//		routines.
//
//	Implementation File:
//		DDxDDv.cpp
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DDXDDV_H_
#define _DDXDDV_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT DWORD &			rdwValue,
	IN DWORD				dwMin,
	IN DWORD				dwMax,
	IN BOOL					bSigned = FALSE
	);
void AFXAPI DDV_RequiredText(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN int					nIDCLabel,
	IN const CString &		rstrValue
	);

inline void AFXAPI DDX_Number(
	IN OUT CDataExchange *	pDX,
	IN int					nIDC,
	IN OUT LONG &			rnValue,
	IN LONG					nMin,
	IN LONG					nMax,
	IN BOOL					bSigned
	)
{
	DDX_Number(pDX, nIDC, (DWORD &) rnValue, (DWORD) nMin, (DWORD) nMax, bSigned);
}

/////////////////////////////////////////////////////////////////////////////

#endif // _DDXDDV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		BasePage.h
//
//	Description:
//		Definition of the CBasePropertyPage class.  This class provides base
//		functionality for extension DLL property pages.
//
//	Implementation File:
//		BasePage.cpp
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _EXTOBJ_H_
#include "ExtObj.h"		// for CExtObject
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
	CBasePropertyPage(void);
	CBasePropertyPage(IN UINT nIDTemplate, IN UINT nIDCaption = 0);
	virtual ~CBasePropertyPage(void) { }

	// Second phase construction.
	virtual BOOL			BInit(IN OUT CExtObject * peo);
	BOOL					BCreateParamsKey(void);

protected:
	void					CommonConstruct(void);

// Attributes
protected:
	CExtObject *			m_peo;
	HPROPSHEETPAGE			m_hpage;

	IDD						m_iddPropertyPage;
	IDD						m_iddWizardPage;
	IDS						m_idsCaption;

	HPROPSHEETPAGE			Hpage(void) const				{ return m_hpage; }

	IDD						IddPropertyPage(void) const		{ return m_iddPropertyPage; }
	IDD						IddWizardPage(void) const		{ return m_iddWizardPage; }
	IDS						IdsCaption(void) const			{ return m_idsCaption; }

public:
	CExtObject *			Peo(void) const					{ return m_peo; }
	void					SetHpage(IN OUT HPROPSHEETPAGE hpage) { m_hpage = hpage; }
	CLUADMEX_OBJECT_TYPE	Cot(void) const;

// Dialog Data
	//{{AFX_DATA(CBasePropertyPage)
	enum { IDD = 0 };
	//}}AFX_DATA
	CStatic	m_staticIcon;
	CStatic	m_staticTitle;
	CString	m_strTitle;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertyPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual DWORD			DwParseUnknownProperty(
								IN LPCWSTR							pwszName,
								IN const CLUSPROP_BUFFER_HELPER &	rvalue,
								IN DWORD							cbBuf
								)		{ return ERROR_SUCCESS; }
	virtual BOOL			BApplyChanges(void);
	virtual void			BuildPropList(IN OUT CClusPropList & rcpl);

	virtual const CObjectProperty *	Pprops(void) const	{ return NULL; }
	virtual DWORD					Cprops(void) const	{ return 0; }

// Implementation
protected:
	BOOL					m_bBackPressed;
	BOOL					m_bDoDetach;

	BOOL					BBackPressed(void) const		{ return m_bBackPressed; }
	IWCWizardCallback *		PiWizardCallback(void) const;
	BOOL					BWizard(void) const;
	HCLUSTER				Hcluster(void) const;
	void					EnableNext(IN BOOL bEnable = TRUE);

	DWORD					DwParseProperties(IN const CClusPropList & rcpl);
	BOOL					BSetPrivateProps(IN BOOL bValidateOnly = FALSE);

	// Generated message map functions
	//{{AFX_MSG(CBasePropertyPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg void OnChangeCtrl();
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\dummyex.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-2000 <company name>
//
//	Module Name:
//		DummyEx.cpp
//
//	Abstract:
//		Implementation of the CDummyApp class and DLL initialization
//		routines.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//		NOTE: You must use the MIDL compiler from NT 4.0,
//		version 3.00.44 or greater
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <initguid.h>
#include <CluAdmEx.h>
#include "DummyEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning(disable : 4701) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning(default : 4701)

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CoDummyEx, CExtObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void);
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hcluster);
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hcluster);

/////////////////////////////////////////////////////////////////////////////
// class CDummyApp
/////////////////////////////////////////////////////////////////////////////

class CDummyApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

/////////////////////////////////////////////////////////////////////////////
// The one and only CDummyApp object

CDummyApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyApp::InitInstance
//
//	Routine Description:
//		Initialize this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any return codes from CWinApp::InitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDummyApp::InitInstance(void)
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();

}  //*** CDummyApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyApp::ExitInstance
//
//	Routine Description:
//		Deinitialize this instance of the application.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Any return codes from CWinApp::ExitInstance().
//
//--
/////////////////////////////////////////////////////////////////////////////
int CDummyApp::ExitInstance(void)
{
	_Module.Term();
	return CWinApp::ExitInstance();

}  //*** CDummyApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	FormatError
//
//	Routine Description:
//		Format an error.
//
//	Arguments:
//		rstrError	[OUT] String in which to return the error message.
//		dwError		[IN] Error code to format.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError(CString & rstrError, DWORD dwError)
{
	DWORD	_cch;
	TCHAR	_szError[512];

	_cch = FormatMessage(
					FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					dwError,
					MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
					_szError,
					sizeof(_szError) / sizeof(TCHAR),
					0
					);
	if (_cch == 0)
	{
		// Format the NT status code from NTDLL since this hasn't been
		// integrated into the system yet.
		_cch = FormatMessage(
						FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
						::GetModuleHandle(_T("NTDLL.DLL")),
						dwError,
						MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
						_szError,
						sizeof(_szError) / sizeof(TCHAR),
						0
						);
	}  // if:  error formatting status code from system

	if (_cch > 0)
	{
		rstrError = _szError;
	}  // if:  no error
	else
	{

#ifdef _DEBUG

		DWORD	_sc = GetLastError();

		TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), _sc, dwError);

#endif

		rstrError.Format(_T("Error 0x%08.8x"), dwError);

	}  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow() && _Module.GetLockCount()==0) ? S_OK : S_FALSE;

}  //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);

}  //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HRESULT hRes = S_OK;
	// registers object, typelib and all interfaces in typelib
	hRes = _Module.RegisterServer(FALSE /*bRegTypeLib*/);
	return hRes;

}  //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	HRESULT hRes = S_OK;
	_Module.UnregisterServer();
	return hRes;

}  //*** DllUnregisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterCluAdminExtension
//
//	Routine Description:
//		Register the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hCluster)
{
	HRESULT		hr;
	HRESULT		hrReturn = S_OK;
	LPCWSTR		pwszResTypes = g_wszResourceTypeNames;

	while (*pwszResTypes != L'\0')
	{
		wprintf(L"  %s\n", pwszResTypes);
		hr = RegisterCluAdminResourceTypeExtension(
					hCluster,
					pwszResTypes,
					&CLSID_CoDummyEx
					);
		if (hr != S_OK)
			hrReturn = hr;
		pwszResTypes += lstrlenW(pwszResTypes) + 1;
	}  // while:  more resource types

	return hrReturn;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllUnregisterCluAdminExtension
//
//	Routine Description:
//		Unregister the extension with the cluster database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hCluster)
{
	HRESULT		hr;
	HRESULT		hrReturn = S_OK;
	LPCWSTR		pwszResTypes = g_wszResourceTypeNames;

	while (*pwszResTypes != L'\0')
	{
		wprintf(L"  %s\n", pwszResTypes);
		hr = UnregisterCluAdminResourceTypeExtension(
					hCluster,
					pwszResTypes,
					&CLSID_CoDummyEx
					);
		if (hr != S_OK)
			hrReturn = hr;
		pwszResTypes += lstrlenW(pwszResTypes) + 1;
	}  // while:  more resource types

	return hrReturn;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\dummyex.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		DummyEx.h
//
//	Abstract:
//		Global definitions across the DLL.
//
//	Implementation File:
//		DummyEx.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DUMMYEX_H_
#define _DUMMYEX_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_DUMMY_PENDING L"Pending"
#define REGPARAM_DUMMY_PENDTIME L"PendTime"
#define REGPARAM_DUMMY_OPENSFAIL L"OpensFail"
#define REGPARAM_DUMMY_FAILED L"Failed"
#define REGPARAM_DUMMY_ASYNCHRONOUS L"Asynchronous"

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

// Defined in Extensn.cpp
extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;

/////////////////////////////////////////////////////////////////////////////

#endif // _DUMMYEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\proplist.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		PropList.cpp
//
//	Abstract:
//		Implementation of the CClusPropList class.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define BUFFER_GROWTH_FACTOR 256

/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CClusPropList, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CClusPropList
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropList::CClusPropList(IN BOOL bAlwaysAddProp)
{
	m_proplist.pList = NULL;
	m_propCurrent.pb = NULL;
	m_cbBufferSize = 0;
	m_cbDataSize = 0;

	m_bAlwaysAddProp = bAlwaysAddProp;

}  //*** CClusPropList::CClusPropList();

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::~CClusPropList
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropList::~CClusPropList(void)
{
	delete [] m_proplist.pb;

}  //*** CClusPropList::~CClusPropList();

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a string property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		rstrValue		[IN] Value of the property to set in the list.
//		rstrPrevValue	[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR			pwszName,
	IN const CString &	rstrValue,
	IN const CString &	rstrPrevValue
	)
{
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_SZ			pValue;

	ASSERT(pwszName != NULL);

	if (m_bAlwaysAddProp || (rstrValue != rstrPrevValue))
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_SZ)
						+ ALIGN_CLUSPROP((rstrValue.GetLength() + 1) * sizeof(WCHAR))
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pStringValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, rstrValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value has changed

}  //*** CClusPropList::AddProp(CString)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a DWORD property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		dwValue			[IN] Value of the property to set in the list.
//		dwPrevValue		[IN] Previous value of the property.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR		pwszName,
	IN DWORD		dwValue,
	IN DWORD		dwPrevValue
	)
{
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_DWORD			pValue;

	ASSERT(pwszName != NULL);

	if (m_bAlwaysAddProp || (dwValue != dwPrevValue))
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_DWORD)
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pDwordValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, dwValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value has changed

}  //*** CClusPropList::AddProp(DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AddProp
//
//	Routine Description:
//		Add a binary property to a property list if it has changed.
//
//	Arguments:
//		pwszName		[IN] Name of the property.
//		pbValue			[IN] Value of the property to set in the list.
//		cbValue			[IN] Count of bytes in pbValue.
//		pbPrevValue		[IN] Previous value of the property.
//		cbPrevValue		[IN] Count of bytes in pbPrevValue.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AddProp(
	IN LPCWSTR			pwszName,
	IN const PBYTE		pbValue,
	IN DWORD			cbValue,
	IN const PBYTE		pbPrevValue,
	IN DWORD			cbPrevValue
	)
{
	BOOL					bChanged = FALSE;
	PCLUSPROP_PROPERTY_NAME	pName;
	PCLUSPROP_BINARY		pValue;

	ASSERT(pwszName != NULL);
	ASSERT(((cbValue == 0) && (cbPrevValue == 0)) || (pbValue != pbPrevValue));

	// Determine if the buffer has changed.
	if (m_bAlwaysAddProp || (cbValue != cbPrevValue))
		bChanged = TRUE;
	else if (!((cbValue == 0) && (cbPrevValue == 0)))
		bChanged = memcmp(pbValue, pbPrevValue, cbValue) == 0;

	if (bChanged)
	{
		DWORD	cbNameSize;
		DWORD	cbValueSize;

		// Calculate sizes and make sure we have a property list.
		cbNameSize = sizeof(CLUSPROP_PROPERTY_NAME)
						+ ALIGN_CLUSPROP((lstrlenW(pwszName) + 1) * sizeof(WCHAR));
		cbValueSize = sizeof(CLUSPROP_BINARY)
						+ ALIGN_CLUSPROP(cbValue)
						+ sizeof(CLUSPROP_SYNTAX); // value list endmark
		AllocPropList(cbNameSize + cbValueSize);

		// Set the property name.
		pName = m_propCurrent.pName;
		CopyProp(pName, CLUSPROP_TYPE_NAME, pwszName);
		m_propCurrent.pb += cbNameSize;

		// Set the property value.
		pValue = m_propCurrent.pBinaryValue;
		CopyProp(pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue);
		m_propCurrent.pb += cbValueSize;

		// Increment the property count and buffer size.
		m_proplist.pList->nPropertyCount++;
		m_cbDataSize += cbNameSize + cbValueSize;
	}  // if:  the value changed

}  //*** CClusPropList::AddProp(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a string property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of string.
//		pwsz		[IN] String to copy.
//		cbsz		[IN] Count of bytes in pwsz string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_SZ			pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN LPCWSTR					pwsz,
	IN DWORD					cbsz
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);
	ASSERT(pwsz != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
	pprop->Syntax.wType = (WORD) proptype;
	if (cbsz == 0)
		cbsz = (lstrlenW(pwsz) + 1) * sizeof(WCHAR);
	ASSERT(cbsz == (lstrlenW(pwsz) + 1) * sizeof(WCHAR));
	pprop->cbLength = cbsz;
	lstrcpyW(pprop->sz, pwsz);

	// Set an endmark.
	props.pStringValue = pprop;
	props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cbsz);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(CString)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a DWORD property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of DWORD.
//		dw			[IN] DWORD to copy.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_DWORD			pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN DWORD					dw
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
	pprop->Syntax.wType = (WORD) proptype;
	pprop->cbLength = sizeof(DWORD);
	pprop->dw = dw;

	// Set an endmark.
	props.pDwordValue = pprop;
	props.pb += sizeof(*props.pDwordValue);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::CopyProp
//
//	Routine Description:
//		Copy a binary property to a property structure.
//
//	Arguments:
//		pprop		[OUT] Property structure to fill.
//		proptype	[IN] Type of string.
//		pb			[IN] Block to copy.
//		cbsz		[IN] Count of bytes in pb buffer.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
	OUT PCLUSPROP_BINARY		pprop,
	IN CLUSTER_PROPERTY_TYPE	proptype,
	IN const PBYTE				pb,
	IN DWORD					cb
	)
{
	CLUSPROP_BUFFER_HELPER	props;

	ASSERT(pprop != NULL);

	pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
	pprop->Syntax.wType = (WORD) proptype;
	pprop->cbLength = cb;
	if (cb > 0)
		CopyMemory(pprop->rgb, pb, cb);

	// Set an endmark.
	props.pBinaryValue = pprop;
	props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(cb);
	props.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

}  //*** CClusPropList::CopyProp(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::AllocPropList
//
//	Routine Description:
//		Allocate a property list buffer that's big enough to hold the next
//		property.
//
//	Arguments:
//		cbMinimum	[IN] Minimum size of the property list.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by BYTE::operator new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::AllocPropList(
	IN DWORD	cbMinimum
	)
{
	DWORD		cbTotal;

	ASSERT(cbMinimum > 0);

	// Add the size of the item count and final endmark.
	cbMinimum += sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
	cbTotal = m_cbDataSize + cbMinimum;

	if (m_cbBufferSize < cbTotal)
	{
		PBYTE	pbNewProplist;

		cbMinimum = max(BUFFER_GROWTH_FACTOR, cbMinimum);
		cbTotal = m_cbDataSize + cbMinimum;

		// Allocate and zero a new buffer.
		pbNewProplist = new BYTE[cbTotal];
		ZeroMemory(pbNewProplist, cbTotal);

		// If there was a previous buffer, copy it and the delete it.
		if (m_proplist.pb != NULL)
		{
			if (m_cbDataSize != 0)
				CopyMemory(pbNewProplist, m_proplist.pb, m_cbDataSize);
			delete [] m_proplist.pb;
			m_propCurrent.pb = pbNewProplist + (m_propCurrent.pb - m_proplist.pb);
		}  // if:  there was a previous buffer
		else
			m_propCurrent.pb = pbNewProplist + sizeof(DWORD); // move past prop count

		// Save the new buffer.
		m_proplist.pb = pbNewProplist;
		m_cbBufferSize = cbTotal;
	}  // if:  buffer isn't big enough

}  //*** CClusPropList::AllocPropList(PBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNodeProperties
//
//	Routine Description:
//		Get properties on a node.
//
//	Arguments:
//		hNode			[IN] Handle for the node to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNodeProperties(
	IN HNODE		hNode,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hNode != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterNodeControl(
						hNode,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterNodeControl(
							hNode,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNodeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetGroupProperties
//
//	Routine Description:
//		Get properties on a group.
//
//	Arguments:
//		hGroup			[IN] Handle for the group to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetGroupProperties(
	IN HGROUP		hGroup,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hGroup != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterGroupControl(
						hGroup,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterGroupControl(
							hGroup,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetResourceProperties
//
//	Routine Description:
//		Get properties on a resource.
//
//	Arguments:
//		hResource		[IN] Handle for the resource to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetResourceProperties(
	IN HRESOURCE	hResource,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hResource != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterResourceControl(
							hResource,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetResourceProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetResourceTypeProperties
//
//	Routine Description:
//		Get properties on a resource type.
//
//	Arguments:
//		hCluster		[IN] Handle for the cluster in which the resource
//							type resides.
//		pwszResTypeName	[IN] Name of the resource type.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetResourceTypeProperties(
	IN HCLUSTER		hCluster,
	IN LPCWSTR		pwszResTypeName,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hCluster != NULL);
	ASSERT(pwszResTypeName != NULL);
	ASSERT(*pwszResTypeName != L'\0');
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterResourceTypeControl(
						hCluster,
						pwszResTypeName,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterResourceTypeControl(
							hCluster,
							pwszResTypeName,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetResourceTypeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNetworkProperties
//
//	Routine Description:
//		Get properties on a network.
//
//	Arguments:
//		hNetwork		[IN] Handle for the network to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNetworkProperties(
	IN HNETWORK		hNetwork,
	IN DWORD		dwControlCode,
	IN HNODE		hHostNode,
	IN LPVOID		lpInBuffer,
	IN DWORD		cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hNetwork != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterNetworkControl(
						hNetwork,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterNetworkControl(
							hNetwork,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNetworkProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropList::DwGetNetInterfaceProperties
//
//	Routine Description:
//		Get properties on a network interface.
//
//	Arguments:
//		hNetInterface	[IN] Handle for the network interface to get properties from.
//		dwControlCode	[IN] Control code for the request.
//		hHostNode		[IN] Handle for the node to direct this request to.
//							Defaults to NULL.
//		lpInBuffer		[IN] Input buffer for the request.  Defaults to NULL.
//		cbInBufferSize	[IN] Size of the input buffer.  Defaults to 0.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions CClusPropList::AllocPropList().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::DwGetNetInterfaceProperties(
	IN HNETINTERFACE	hNetInterface,
	IN DWORD			dwControlCode,
	IN HNODE			hHostNode,
	IN LPVOID			lpInBuffer,
	IN DWORD			cbInBufferSize
	)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	DWORD		cbProps		= 256;

	ASSERT(hNetInterface != NULL);
	ASSERT((dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
			== (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT));

	try
	{
		// Get properties.
		AllocPropList(cbProps);
		dwStatus = ClusterNetInterfaceControl(
						hNetInterface,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						cbInBufferSize,
						m_proplist.pb,
						m_cbBufferSize,
						&cbProps
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			AllocPropList(cbProps);
			dwStatus = ClusterNetInterfaceControl(
							hNetInterface,
							hHostNode,
							dwControlCode,
							lpInBuffer,
							cbInBufferSize,
							m_proplist.pb,
							m_cbBufferSize,
							&cbProps
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if (dwStatus != ERROR_SUCCESS)
	{
		delete [] m_proplist.pb;
		m_proplist.pb = NULL;
		m_propCurrent.pb = NULL;
		m_cbBufferSize = 0;
		m_cbDataSize = 0;
	}  // if:  error getting private properties.
	else
		m_cbDataSize = cbProps;

	return dwStatus;

}  //*** CClusPropList::DwGetNetInterfaceProperties()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		PropList.h
//
//	Abstract:
//		Definition of the CClusPropList class.
//
//	Implementation File:
//		PropList.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _PROPLIST_H_
#define _PROPLIST_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CObjectProperty
/////////////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

class CObjectProperty
{
public:
	LPCWSTR					m_pwszName;
	CLUSTER_PROPERTY_FORMAT	m_propFormat;

	union CValue
	{
		CString *	pstr;
		LONG *		pl;
		DWORD *		pdw;
		BOOL *		pb;
		struct
		{
			PBYTE *	ppb;
			DWORD *	pcb;
		};
	};
	CValue					m_value;
	CValue					m_valuePrev;

	void	Set(
				IN LPCWSTR pwszName,
				IN CString & rstrValue,
				IN CString & rstrPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_SZ;
		m_value.pstr = &rstrValue;
		m_value.pcb = NULL;
		m_valuePrev.pstr = &rstrPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN LONG & rnValue,
				IN LONG & rnPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pl = &rnValue;
		m_value.pcb = NULL;
		m_valuePrev.pl = &rnPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN DWORD & rdwValue,
				IN DWORD & rdwPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pdw = &rdwValue;
		m_value.pcb = NULL;
		m_valuePrev.pdw = &rdwPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN BOOL & rbValue,
				IN BOOL & rbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_DWORD;
		m_value.pb = &rbValue;
		m_value.pcb = NULL;
		m_valuePrev.pb = &rbPrevValue;
		m_valuePrev.pcb = NULL;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN PBYTE & rpbValue,
				IN DWORD & rcbValue,
				IN PBYTE & rpbPrevValue,
				IN DWORD & rcbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_BINARY;
		m_value.ppb = &rpbValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = &rpbPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
	}

	void	Set(
				IN LPCWSTR pwszName,
				IN LPWSTR & rpwszValue,
				IN DWORD & rcbValue,
				IN LPWSTR & rpwszPrevValue,
				IN DWORD & rcbPrevValue
				)
	{
		m_pwszName = pwszName;
		m_propFormat = CLUSPROP_FORMAT_MULTI_SZ;
		m_value.ppb = (PBYTE *) &rpwszValue;
		m_value.pcb = &rcbValue;
		m_valuePrev.ppb = (PBYTE *) &rpwszPrevValue;
		m_valuePrev.pcb = &rcbPrevValue;
	}

};  //*** class CObjectProperty

/////////////////////////////////////////////////////////////////////////////
// CClusPropList dialog
/////////////////////////////////////////////////////////////////////////////

class CClusPropList : public CObject
{
	DECLARE_DYNAMIC(CClusPropList);

// Construction
public:
	CClusPropList(IN BOOL bAlwaysAddProp = FALSE);
	~CClusPropList(void);

// Attributes
protected:
	BOOL					m_bAlwaysAddProp;

	CLUSPROP_BUFFER_HELPER	m_proplist;
	CLUSPROP_BUFFER_HELPER	m_propCurrent;
	DWORD					m_cbBufferSize;
	DWORD					m_cbDataSize;

public:
	CLUSPROP_BUFFER_HELPER const *	Proplist(void) const	{ return &m_proplist; }
	PBYTE					PbProplist(void) const	{ return m_proplist.pb; }
	DWORD					CbProplist(void) const	{ return m_cbDataSize + sizeof(CLUSPROP_SYNTAX); /*endmark*/ }
	DWORD					Cprops(void) const
	{
		if (m_proplist.pb == NULL)
			return 0;
		return m_proplist.pList->nPropertyCount;
	}

	void					AddProp(
								IN LPCWSTR			pwszName,
								IN const CString &	rstrValue,
								IN const CString &	rstrPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN DWORD			dwValue,
								IN DWORD			dwPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN LONG				nValue,
								IN LONG				nPrevValue
								);
	void					AddProp(
								IN LPCWSTR			pwszName,
								IN const PBYTE		pbValue,
								IN DWORD			cbValue,
								IN const PBYTE		pbPrevValue,
								IN DWORD			cbPrevValue
								);

	void					AllocPropList(IN DWORD cbMinimum);

// Operations
public:
	DWORD					DwGetNodeProperties(
								IN HNODE		hNode,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetGroupProperties(
								IN HGROUP		hGroup,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetResourceProperties(
								IN HRESOURCE	hResource,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetResourceTypeProperties(
								IN HCLUSTER		hCluster,
								IN LPCWSTR		pwszResTypeName,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetNetworkProperties(
								IN HNETWORK		hNetwork,
								IN DWORD		dwControlCode,
								IN HNODE		hHostNode		= NULL,
								IN LPVOID		lpInBuffer		= NULL,
								IN DWORD		cbInBufferSize	= 0
								);

	DWORD					DwGetNetInterfaceProperties(
								IN HNETINTERFACE	hNetInterface,
								IN DWORD			dwControlCode,
								IN HNODE			hHostNode		= NULL,
								IN LPVOID			lpInBuffer		= NULL,
								IN DWORD			cbInBufferSize	= 0
								);

// Overrides

// Implementation
protected:
	void					CopyProp(
								IN PCLUSPROP_SZ				pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN LPCWSTR					pwsz,
								IN DWORD					cbsz = 0
								);
	void					CopyProp(
								IN PCLUSPROP_DWORD			pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN DWORD					dw
								);
	void					CopyProp(
								IN PCLUSPROP_BINARY			pprop,
								IN CLUSTER_PROPERTY_TYPE	proptype,
								IN const PBYTE				pb,
								IN DWORD					cb
								);

	DWORD					DwGetPrivateProps(
								OUT PBYTE *					ppbProps,
								IN CLUSTER_CONTROL_OBJECT	ccobjtype = CLUS_OBJECT_RESOURCE
								);
	DWORD					DwSetPrivateProps(
								IN PBYTE					pbProps,
								IN DWORD					cbProps,
								IN CLUSTER_CONTROL_OBJECT	ccobjtype = CLUS_OBJECT_RESOURCE
								);

};  //*** class CClusPropList

#pragma warning( default : 4201 )

/////////////////////////////////////////////////////////////////////////////

#endif // _PROPLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\regext.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		RegExt.cpp
//
//	Abstract:
//		Implementation of routines for extension registration.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ole2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define REG_VALUE_ADMIN_EXTENSIONS L"AdminExtensions"

/////////////////////////////////////////////////////////////////////////////
// Static Function Prototypes
/////////////////////////////////////////////////////////////////////////////

static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	);
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	);
static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	);

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminClusterExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** RegisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** RegisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** RegisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNetworksExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all networks.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"Networks", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminAllNetInterfacesExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends all network interfaces.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = RegisterAnyCluAdminExtension(hCluster, L"NetInterfaces", pClsid);

	return hr;

}  //*** RegisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Register with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Register the extension.
		hr = RegisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** RegisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminClusterExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends the cluster object.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the cluster registry key.
	hkey = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterKey succeeded

	return hr;

}  //*** UnregisterCluAdminClusterExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNodesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all nodes.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Nodes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNodesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllGroupsExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all groups.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Groups", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllGroupsExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourcesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resources.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Resources", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourcesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllResourceTypesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all resource types.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"ResourceTypes", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllResourceTypesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNetworksExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all networks.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"Networks", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNetworksExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminAllNetInterfacesExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends all network interfaces.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;

	hr = UnregisterAnyCluAdminExtension(hCluster, L"NetInterfaces", pClsid);

	return hr;

}  //*** UnregisterCluAdminAllNetInterfacesExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterCluAdminResourceTypeExtension
//
//	Routine Description:
//		Unregister with the cluster database a Cluster Administrator Extension
//		DLL that extends resources of a specific type, or the resource type
//		itself.
//
//	Arguments:
//		hCluster			[IN] Handle to the cluster to modify.
//		pwszResourceType	[IN] Resource type name.
//		pClsid				[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkey;

	// Get the resource type registry key.
	hkey = GetClusterResourceTypeKey(hCluster, pwszResourceType, KEY_ALL_ACCESS);
	if (hkey == NULL)
		hr = GetLastError();
	else
	{
		// Unregister the extension.
		hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

		ClusterRegCloseKey(hkey);
	}  // else:  GetClusterResourceTypeKey succeeded

	return hr;

}  //*** UnregisterCluAdminResourceTypeExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Register the extension.
			hr = RegisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterAnyCluAdminExtension
//
//	Routine Description:
//		Register any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension registered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT RegisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyRegistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been registered yet.
			if (pwszValue == NULL)
				bAlreadyRegistered = FALSE;
			else
			{
				LPCWSTR	pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpiW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyRegistered = (*pwszValueBuf != L'\0');
			}  // else:  extension value exists

			// Register the extension.
			if (!bAlreadyRegistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize + (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				if (cbSize == 0) // Add size of final NULL if first entry.
					cbNewSize += sizeof(WCHAR);
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	cch;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if (pwszValue != NULL)
					{
						while (*pwszValueBuf != L'\0')
						{
							lstrcpyW(pwszNewValueBuf, pwszValueBuf);
							cch = lstrlenW(pwszValueBuf);
							pwszValueBuf += cch + 1;
							pwszNewValueBuf += cch + 1;
						}  // while:  more strings in the extension list
					}  // if:  previous value buffer existed

					// Add the new CLSID to the list.
					lstrcpyW(pwszNewValueBuf, pwszClsid);
					pwszNewValueBuf += lstrlenW(pwszClsid) + 1;
					*pwszNewValueBuf = L'\0';

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not registered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** RegisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hCluster		[IN] Handle to the cluster to modify.
//		pwszKeyName		[IN] Key name.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszKeyName,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	HKEY		hkeyCluster;
	HKEY		hkey;

	// Get the cluster key.
	hkeyCluster = GetClusterKey(hCluster, KEY_ALL_ACCESS);
	if (hkeyCluster == NULL)
		hr = GetLastError();
	else
	{
		// Get the specified key.
		hr = ClusterRegOpenKey(hkeyCluster, pwszKeyName, KEY_ALL_ACCESS, &hkey);
		if (hr == ERROR_SUCCESS)
		{
			// Unregister the extension.
			hr = UnregisterAnyCluAdminExtension(hkey, pClsid);

			ClusterRegCloseKey(hkey);
		}  // else:  GetClusterResourceTypeKey succeeded

		ClusterRegCloseKey(hkeyCluster);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterAnyCluAdminExtension
//
//	Routine Description:
//		Unregister any Cluster Administrator Extension DLL with the cluster
//		database.
//
//	Arguments:
//		hkey			[IN] Cluster database key.
//		pClsid			[IN] Extension's CLSID.
//
//	Return Value:
//		S_OK			Extension unregistered successfully.
//		Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
static HRESULT UnregisterAnyCluAdminExtension(
	IN HKEY				hkey,
	IN const CLSID *	pClsid
	)
{
	HRESULT		hr;
	LPOLESTR	pwszClsid;
	DWORD		cbSize;
	DWORD		cbNewSize;
	LPWSTR		pwszValue;
	LPWSTR		pwszNewValue;
	BOOL		bAlreadyUnregistered;

	// Convert the CLSID to a string.
	hr = StringFromCLSID(*pClsid, &pwszClsid);
	if (hr == S_OK)
	{
		// Read the current value.
		hr = ReadValue(hkey, REG_VALUE_ADMIN_EXTENSIONS, &pwszValue, &cbSize);
		if (hr == S_OK)
		{
			// Check to see if the extension has been unregistered yet.
			if (pwszValue == NULL)
				bAlreadyUnregistered = TRUE;
			else
			{
				LPCWSTR pwszValueBuf = pwszValue;

				while (*pwszValueBuf != L'\0')
				{
					if (lstrcmpiW(pwszClsid, pwszValueBuf) == 0)
						break;
					pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
				}  // while:  more strings in the extension list
				bAlreadyUnregistered = (*pwszValueBuf == L'\0');
			}  // else:  extension value exists

			// Unregister the extension.
			if (!bAlreadyUnregistered)
			{
				// Allocate a new buffer.
				cbNewSize = cbSize - (lstrlenW(pwszClsid) + 1) * sizeof(WCHAR);
				if (cbNewSize == sizeof(WCHAR))
					cbNewSize = 0;
				pwszNewValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbNewSize);
				if (pwszNewValue == NULL)
					hr = GetLastError();
				else
				{
					LPCWSTR	pwszValueBuf	= pwszValue;
					LPWSTR	pwszNewValueBuf	= pwszNewValue;
					DWORD	dwType;

					// Copy the existing extensions to the new buffer.
					if ((cbNewSize > 0) && (pwszValue != NULL))
					{
						while (*pwszValueBuf != L'\0')
						{
							if (lstrcmpiW(pwszClsid, pwszValueBuf) != 0)
							{
								lstrcpyW(pwszNewValueBuf, pwszValueBuf);
								pwszNewValueBuf += lstrlenW(pwszNewValueBuf) + 1;
							}  // if:  not CLSID being removed
							pwszValueBuf += lstrlenW(pwszValueBuf) + 1;
						}  // while:  more strings in the extension list
						*pwszNewValueBuf = L'\0';
					}  // if:  previous value buffer existed

					// Write the value to the cluster database.
					dwType = REG_MULTI_SZ;
					hr = ClusterRegSetValue(
									hkey,
									REG_VALUE_ADMIN_EXTENSIONS,
									dwType,
									(LPBYTE) pwszNewValue,
									cbNewSize
									);

					LocalFree(pwszNewValue);
				}  // else:  new buffer allocated successfully

			}  // if:  extension not unregistered yet

			LocalFree(pwszValue);
		}  // if:  value read successfully

		CoTaskMemFree(pwszClsid);
	}  // if:  CLSID converted to a string successfully

	return hr;

}  //*** UnregisterAnyCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ReadValue
//
//	Routine Description:
//		Reads a value from the cluster database.
//
//	Arguments:
//		hkey			[IN] Handle for the key to read from.
//		pwszValueName	[IN] Name of value to read.
//		ppwszValue		[OUT] Address of pointer in which to return data.
//							The string is allocated using LocalAlloc and must
//							be deallocated by the calling LocalFree.
//		pcbSize			[OUT] Size in bytes of the allocated value buffer.
//
//	Return Value:
//		Any return values from ClusterRegQueryValue or errors from new.
//
//--
/////////////////////////////////////////////////////////////////////////////

static DWORD ReadValue(
	IN HKEY			hkey,
	IN LPCWSTR		pwszValueName,
	OUT LPWSTR *	ppwszValue,
	OUT DWORD *		pcbSize
	)
{
	DWORD		dwStatus;
	DWORD		cbSize;
	DWORD		dwType;
	LPWSTR		pwszValue;

	*ppwszValue = NULL;
	*pcbSize = 0;

	// Get the length of the value.
	dwStatus = ClusterRegQueryValue(
					hkey,
					pwszValueName,
					&dwType,
					NULL,
					&cbSize
					);
	if (   (dwStatus != ERROR_SUCCESS)
		&& (dwStatus != ERROR_MORE_DATA))
	{
		if (dwStatus  == ERROR_FILE_NOT_FOUND)
			dwStatus = ERROR_SUCCESS;
		return dwStatus;
	}  // if:  error occurred

	if (cbSize > 0)
	{
		// Allocate a value string.
		pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, cbSize);
		if (pwszValue == NULL)
		{
			dwStatus = GetLastError();
			return dwStatus;
		}  // if:  error allocating memory

		// Read the the value.
		dwStatus = ClusterRegQueryValue(
						hkey,
						pwszValueName,
						&dwType,
						(LPBYTE) pwszValue,
						&cbSize
						);
		if (dwStatus != ERROR_SUCCESS)
		{
			LocalFree(pwszValue);
			pwszValue = NULL;
			cbSize = 0;
		}  // if:  error occurred

		*ppwszValue = pwszValue;
		*pcbSize = cbSize;
	}  // if:  value is not empty

	return dwStatus;

}  //*** ReadValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Description:
//		Implementation of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DummyEx.h"
#include "ExtObj.h"
#include "ResProp.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
		L"Dummy\0"
		;
const DWORD g_cchResourceTypeNames	= sizeof(g_wszResourceTypeNames) / sizeof(WCHAR);

static CRuntimeClass * g_rgprtcResPSPages[]	= {
	RUNTIME_CLASS(CDummyParamsPage),
	NULL
	};
static CRuntimeClass ** g_rgpprtcResPSPages[]	= {
	g_rgprtcResPSPages,
	};
static CRuntimeClass ** g_rgpprtcResWizPages[]	= {
	g_rgprtcResPSPages,
	};

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CExtObject
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject(void)
{
	m_piData = NULL;
	m_piWizardCallback = NULL;
	m_bWizard = FALSE;
	m_istrResTypeName = 0;

	m_lcid = NULL;
	m_hfont = NULL;
	m_hicon = NULL;
	m_hcluster = NULL;
	m_cobj = 0;
	m_podObjData = NULL;

}  //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::~CExtObject
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject(void)
{
	// Release the data interface.
	if (PiData() != NULL)
	{
		PiData()->Release();
		m_piData = NULL;
	}  // if:  we have a data interface pointer

	// Release the wizard callback interface.
	if (PiWizardCallback() != NULL)
	{
		PiWizardCallback()->Release();
		m_piWizardCallback = NULL;
	}  // if:  we have a wizard callback interface pointer

	// Delete the pages.
	{
		POSITION	pos;

		pos = Lpg().GetHeadPosition();
		while (pos != NULL)
			delete Lpg().GetNext(pos);
	}  // Delete the pages

	delete m_podObjData;

}  //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//	Routine Description:
//		Indicates whether an interface suportes the IErrorInfo interface.
//		This interface is provided by ATL.
//
//	Arguments:
//		riid		Interface ID.
//
//	Return Value:
//		S_OK		Interface supports IErrorInfo.
//		S_FALSE		Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID * rgiid[] =
	{
		&IID_IWEExtendPropertySheet,
		&IID_IWEExtendWizard,
	};
	int		iiid;

	for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
	{
		if (InlineIsEqualGUID(*rgiid[iiid], riid))
			return S_OK;
	}
	return S_FALSE;

}  //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//	Routine Description:
//		Create property sheet pages and add them to the sheet.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the sheet is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
	IN IUnknown *					piData,
	IN IWCPropertySheetCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	CRuntimeClass **	pprtc	= NULL;
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		// Create property pages.
		ASSERT(PodObjData() != NULL);
		switch (PodObjData()->m_cot)
		{
			case CLUADMEX_OT_RESOURCE:
				pprtc = g_rgpprtcResPSPages[IstrResTypeName()];
				break;
			default:
				hr = E_NOTIMPL;
				throw &exc;
				break;
		}  // switch:  object type

		// Create each page.
		for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++)
		{
			// Create the page.
			ppage = (CBasePropertyPage *) pprtc[irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(pprtc[irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddPropertySheetPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page in the list

	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	piCallback->Release();
	return hr;

}  //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::CreateWizardPages (IWEExtendWizard)
//
//	Routine Description:
//		Create property sheet pages and add them to the wizard.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object for
//							which the wizard is being displayed.
//		piCallback		Pointer to an IWCPropertySheetCallback interface
//							for adding pages to the sheet.
//
//	Return Value:
//		NOERROR			Pages added successfully.
//		E_INVALIDARG	Invalid arguments to the function.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_FAIL			Error creating a page.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
	IN IUnknown *			piData,
	IN IWCWizardCallback *	piCallback
	)
{
	HRESULT				hr		= NOERROR;
	HPROPSHEETPAGE		hpage	= NULL;
	CException			exc(FALSE /*bAutoDelete*/);
	CRuntimeClass **	pprtc	= NULL;
	int					irtc;
	CBasePropertyPage *	ppage;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate the parameters.
	if ((piData == NULL) || (piCallback == NULL))
		return E_INVALIDARG;

	try
	{
		// Get info about displaying UI.
		hr = HrGetUIInfo(piData);
		if (hr != NOERROR)
			throw &exc;

		// Save the data.
		hr = HrSaveData(piData);
		if (hr != NOERROR)
			throw &exc;

		// Delete any previous pages.
		{
			POSITION	pos;

			pos = Lpg().GetHeadPosition();
			while (pos != NULL)
				delete Lpg().GetNext(pos);
			Lpg().RemoveAll();
		}  // Delete any previous pages

		m_piWizardCallback = piCallback;
		m_bWizard = TRUE;

		// Create property pages.
		ASSERT(PodObjData() != NULL);
		switch (PodObjData()->m_cot)
		{
			case CLUADMEX_OT_RESOURCE:
				pprtc = g_rgpprtcResWizPages[IstrResTypeName()];
				break;
			default:
				hr = E_NOTIMPL;
				throw &exc;
				break;
		}  // switch:  object type

		// Create each page.
		for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++)
		{
			// Create the page.
			ppage = (CBasePropertyPage *) pprtc[irtc]->CreateObject();
			ASSERT(ppage->IsKindOf(pprtc[irtc]));

			// Add it to the list.
			Lpg().AddTail(ppage);

			// Initialize the property page.
			if (!ppage->BInit(this))
				throw &exc;

			// Create the page.
			hpage = ::CreatePropertySheetPage(&ppage->m_psp);
			if (hpage == NULL)
				throw &exc;

			// Save the hpage in the page itself.
			ppage->SetHpage(hpage);

			// Add it to the property sheet.
			hr = piCallback->AddWizardPage((LONG *) hpage);
			if (hr != NOERROR)
				throw &exc;
		}  // for:  each page in the list

	}  // try
	catch (CMemoryException * pme)
	{
		TRACE(_T("CExtObject::CreateWizardPages() - Failed to add wizard page\n"));
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  anything
	catch (CException * pe)
	{
		TRACE(_T("CExtObject::CreateWizardPages() - Failed to add wizard page\n"));
		pe->Delete();
		if (hr == NOERROR)
			hr = E_FAIL;
	}  // catch:  anything

	if (hr != NOERROR)
	{
		if (hpage != NULL)
			::DestroyPropertySheetPage(hpage);
		piCallback->Release();
		piData->Release();
		m_piData = NULL;
	}  // if:  error occurred

	return hr;

}  //*** CExtObject::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetUIInfo
//
//	Routine Description:
//		Get info about displaying UI.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	// Save info about all types of objects.
	{
		IGetClusterUIInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_lcid = pi->GetLocale();
		m_hfont = pi->GetFont();
		m_hicon = pi->GetIcon();

		pi->Release();
	}  // Save info about all types of objects

	return hr;

}  //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrSaveData
//
//	Routine Description:
//		Save data from the object so that it can be used for the life
//		of the object.
//
//	Arguments:
//		piData			IUnkown pointer from which to obtain interfaces
//							for obtaining data describing the object.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IUnknown * piData)
{
	HRESULT			hr	= NOERROR;

	ASSERT(piData != NULL);

	if (piData != m_piData)
	{
		if (m_piData != NULL)
			m_piData->Release();
		m_piData = piData;
	}  // if:  different data interface pointer

	// Save info about all types of objects.
	{
		IGetClusterDataInfo *	pi;

		hr = piData->QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &pi);
		if (hr != NOERROR)
			return hr;

		m_hcluster = pi->GetClusterHandle();
		m_cobj = pi->GetObjectCount();
		if (Cobj() != 1)	// Only have support for one selected object.
			hr = E_NOTIMPL;

		pi->Release();
		if (hr != NOERROR)
			return hr;
	}  // Save info about all types of objects

	// Save info about this object.
	hr = HrGetObjectInfo();
	if (hr != NOERROR)
		return hr;

	return hr;

}  //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectInfo
//
//	Routine Description:
//		Get information about the object.
//
//	Arguments:
//		None.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//		or HrGetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
	HRESULT						hr	= NOERROR;
	IGetClusterObjectInfo *		piGcoi;
	CLUADMEX_OBJECT_TYPE		cot = CLUADMEX_OT_NONE;
	CException					exc(FALSE /*bAutoDelete*/);
	const CString *				pstrResTypeName = NULL;

	ASSERT(PiData() != NULL);

	// Get object info.
	{
		// Get an IGetClusterObjectInfo interface pointer.
		hr = PiData()->QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &piGcoi);
		if (hr != NOERROR)
			return hr;

		// Read the object data.
		try
		{
			// Delete the previous object data.
			delete m_podObjData;
			m_podObjData = NULL;

			// Get the type of the object.
			cot = piGcoi->GetObjectType(0);
			switch (cot)
			{
				case CLUADMEX_OT_RESOURCE:
					{
						IGetClusterResourceInfo *	pi;

						m_podObjData = new CResData;

						// Get an IGetClusterResourceInfo interface pointer.
						hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &pi);
						if (hr != NOERROR)
							throw &exc;

						PrdResDataRW()->m_hresource = pi->GetResourceHandle(0);
						ASSERT(PrdResDataRW()->m_hresource != NULL);
						if (PrdResDataRW()->m_hresource == NULL)
							hr = E_INVALIDARG;
						else
							hr = HrGetResourceTypeName(pi);
						pi->Release();
						if (hr != NOERROR)
							throw &exc;

						pstrResTypeName = &PrdResDataRW()->m_strResTypeName;
					}  // if:  object is a resource
					break;
				default:
					hr = E_NOTIMPL;
					throw &exc;
			}  // switch:  object type

			PodObjDataRW()->m_cot = cot;
			hr = HrGetObjectName(piGcoi);
		}  // try
		catch (CException * pe)
		{
			pe->Delete();
		}  // catch:  CException

		piGcoi->Release();
		if (hr != NOERROR)
			return hr;
	}  // Get object info

	// If this is a resource or resource type, see if we know about this type.
	if (((cot == CLUADMEX_OT_RESOURCE)
			|| (cot == CLUADMEX_OT_RESOURCETYPE))
		&& (hr == NOERROR))
	{
		LPCWSTR	pwszResTypeName;

		// Find the resource type name in our list.
		// Save the index for use in other arrays.
		for (m_istrResTypeName = 0, pwszResTypeName = g_wszResourceTypeNames
				; *pwszResTypeName != L'\0'
				; m_istrResTypeName++, pwszResTypeName += lstrlenW(pwszResTypeName) + 1
				)
		{
			if (pstrResTypeName->CompareNoCase(pwszResTypeName) == 0)
				break;
		}  // for:  each resource type in the list
		if (*pwszResTypeName == L'\0')
			hr = E_NOTIMPL;
	}  // See if we know about this resource type

	return hr;

}  //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetObjectName
//
//	Routine Description:
//		Get the name of the object.
//
//	Arguments:
//		piData			IGetClusterObjectInfo interface pointer for getting
//							the object name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IGetClusterObjectInfo::GetObjectInfo().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(
	IN OUT IGetClusterObjectInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetObjectName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetObjectName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting object name

		PodObjDataRW()->m_strName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CExtObject::HrGetResourceTypeName
//
//	Routine Description:
//		Get the name of the resource's type.
//
//	Arguments:
//		piData			IGetClusterResourceInfo interface pointer for getting
//							the resource type name.
//
//	Return Value:
//		NOERROR			Data saved successfully.
//		E_OUTOFMEMORY	Error allocating memory.
//		E_NOTIMPL		Not implemented for this type of data.
//		Any error codes from IGetClusterResourceInfo::GetResourceTypeName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(
	IN OUT IGetClusterResourceInfo *	pi
	)
{
	HRESULT		hr			= NOERROR;
	WCHAR *		pwszName	= NULL;
	LONG		cchName;

	ASSERT(pi != NULL);

	hr = pi->GetResourceTypeName(0, NULL, &cchName);
	if (hr != NOERROR)
		return hr;

	try
	{
		pwszName = new WCHAR[cchName];
		hr = pi->GetResourceTypeName(0, pwszName, &cchName);
		if (hr != NOERROR)
		{
			delete [] pwszName;
			pwszName = NULL;
		}  // if:  error getting resource type name

		PrdResDataRW()->m_strResTypeName = pwszName;
	}  // try
	catch (CMemoryException * pme)
	{
		pme->Delete();
		hr = E_OUTOFMEMORY;
	}  // catch:  CMemoryException

	delete [] pwszName;
	return hr;

}  //*** CExtObject::HrGetResourceTypeName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Dummy.rc
//
#define IDD_PP_DUMMY_PARAMETERS      130
#define IDD_WIZ_DUMMY_PARAMETERS     131
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_DUMMY_PENDING_LABEL 1010
#define IDC_PP_DUMMY_PENDING       1011
#define IDC_PP_DUMMY_PENDTIME_LABEL 1012
#define IDC_PP_DUMMY_PENDTIME       1013
#define IDC_PP_DUMMY_OPENSFAIL_LABEL 1014
#define IDC_PP_DUMMY_OPENSFAIL       1015
#define IDC_PP_DUMMY_FAILED_LABEL 1016
#define IDC_PP_DUMMY_FAILED       1017
#define IDC_PP_DUMMY_ASYNCHRONOUS_LABEL 1018
#define IDC_PP_DUMMY_ASYNCHRONOUS       1019
#define IDS_CLUADMEX_COMOBJ_DESC        31100
#define IDS_REQUIRED_FIELD_EMPTY        31101
#define IDS_APPLY_PARAM_CHANGES_ERROR   31200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1110
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (C) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		ExtObj.h
//
//	Description:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Maintained By:
//		Galen Barbee (GalenB) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_OBJECT_TYPE and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"	// for CLSID_CoDummyEx
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList<CBasePropertyPage *, CBasePropertyPage *> CPageList;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** class CObjData

/////////////////////////////////////////////////////////////////////////////
// class CNodeData
/////////////////////////////////////////////////////////////////////////////

class CNodeData : public CObjData
{
public:
	HNODE		m_hnode;

};  //*** class CNodeData

/////////////////////////////////////////////////////////////////////////////
// class CGroupData
/////////////////////////////////////////////////////////////////////////////

class CGroupData : public CObjData
{
public:
	HGROUP		m_hgroup;

};  //*** class CGroupData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** class CResData

/////////////////////////////////////////////////////////////////////////////
// class CNetworkData
/////////////////////////////////////////////////////////////////////////////

class CNetworkData : public CObjData
{
public:
	HNETWORK	m_hnetwork;

};  //*** class CNetworkData

/////////////////////////////////////////////////////////////////////////////
// class CNetInterfaceData
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceData : public CObjData
{
public:
	HNETINTERFACE	m_hnetinterface;

};  //*** class CNetInterfaceData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoDummyEx>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(IWEExtendWizard)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.DummyEx"), _T("CLUADMEX.DummyEx"), IDS_CLUADMEX_COMOBJ_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD(CreateWizardPages)(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterUIInfo data
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;

	// IGetClusterDataInfo data
	HCLUSTER					m_hcluster;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW(void) const		{ return m_podObjData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) m_podObjData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback(void) const	{ return m_piWizardCallback; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterUIInfo data
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }

	// IGetClusterDataInfo data
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CObjData *			PodObjData(void) const			{ return m_podObjData; }
	const CNodeData *			PndNodeData(void) const			{ ASSERT(Cot() == CLUADMEX_OT_NODE); return (CNodeData *) m_podObjData; }
	const CGroupData *			PgdGroupData(void) const		{ ASSERT(Cot() == CLUADMEX_OT_GROUP); return (CGroupData *) m_podObjData; }
	const CResData *			PrdResData(void) const			{ ASSERT(Cot() == CLUADMEX_OT_RESOURCE); return (CResData *) m_podObjData; }
	const CNetworkData *		PndNetworkData(void) const		{ ASSERT(Cot() == CLUADMEX_OT_NETWORK); return (CNetworkData *) m_podObjData; }
	const CNetInterfaceData *	PndNetInterfaceData(void) const	{ ASSERT(Cot() == CLUADMEX_OT_NETINTERFACE); return (CNetInterfaceData *) m_podObjData; }

	CLUADMEX_OBJECT_TYPE		Cot(void) const					{ ASSERT(PodObjData() != NULL); return PodObjData()->m_cot; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\regext.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		RegExt.h
//
//	Abstract:
//		Definitions of routines for extension registration.
//
//	Implementation File:
//		RegExt.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGEXT_H_
#define _REGEXT_H_

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

// Registration routines.

STDAPI RegisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI RegisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

// Unregistration routines.

STDAPI UnregisterCluAdminClusterExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNodesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllGroupsExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourcesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllResourceTypesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetworksExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminAllNetInterfacesExtension(
	IN HCLUSTER			hCluster,
	IN const CLSID *	pClsid
	);

STDAPI UnregisterCluAdminResourceTypeExtension(
	IN HCLUSTER			hCluster,
	IN LPCWSTR			pwszResourceType,
	IN const CLSID *	pClsid
	);

/////////////////////////////////////////////////////////////////////////////

#endif // _REGEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DummyEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\resprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		ResProp.h
//
//	Abstract:
//		Definition of the resource extension property page classes.
//
//	Implementation File:
//		ResProp.cpp
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESPROP_H_
#define _RESPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectPropert
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDummyParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CDummyParamsPage
//
//	Purpose:
//		Parameters page for resources.
//
/////////////////////////////////////////////////////////////////////////////

class CDummyParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CDummyParamsPage)

// Construction
public:
	CDummyParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CDummyParamsPage)
	enum { IDD = IDD_PP_DUMMY_PARAMETERS };
	BOOL	m_bPending;
	DWORD	m_nPendTime;
	BOOL	m_bOpensFail;
	BOOL	m_bFailed;
	BOOL	m_bAsynchronous;
	//}}AFX_DATA
	BOOL	m_bPrevPending;
	DWORD	m_nPrevPendTime;
	BOOL	m_bPrevOpensFail;
	BOOL	m_bPrevFailed;
	BOOL	m_bPrevAsynchronous;

protected:
	enum
	{
		epropPending,
		epropPendTime,
		epropOpensFail,
		epropFailed,
		epropAsynchronous,
		epropMAX
	};
	CObjectProperty		m_rgProps[epropMAX];

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDummyParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:
	BOOL	BAllRequiredFieldsPresent(void) const;

	// Generated message map functions
	//{{AFX_MSG(CDummyParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeRequiredField();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CDummyParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _RESPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE			// Microsoft Windows NT Cluster Administrator
							//   Extension DLLs need to be Unicode
							//   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

// Link against Resource Utilities library.
#pragma comment(lib, "resutils.lib")

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>			// MFC core and standard components
#include <afxext.h>			// MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <clusapi.h>

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT	IDS;
typedef UINT	IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\dummyex\resprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 <company name>
//
//	Module Name:
//		ResProp.cpp
//
//	Abstract:
//		Implementation of the resource extension property page classes.
//
//	Author:
//		<name> (<e-mail name>) Mmmm DD, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DummyEx.h"
#include "ResProp.h"
#include "ExtObj.h"
#include "DDxDDv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDummyParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CDummyParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CDummyParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CDummyParamsPage)
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
	ON_EN_CHANGE(IDC_PP_DUMMY_PENDING, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_DUMMY_PENDTIME, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_DUMMY_OPENSFAIL, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_DUMMY_FAILED, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_DUMMY_ASYNCHRONOUS, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::CDummyParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDummyParamsPage::CDummyParamsPage(void) : CBasePropertyPage(CDummyParamsPage::IDD)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CDummyParamsPage)
	m_bPending = 0;
	m_nPendTime = (DWORD) (0);
	m_bOpensFail = 0;
	m_bFailed = 0;
	m_bAsynchronous = 0;
	//}}AFX_DATA_INIT

	// Setup the property array.
	{
		m_rgProps[epropPending].Set(REGPARAM_DUMMY_PENDING, m_bPending, m_bPrevPending);
		m_rgProps[epropPendTime].Set(REGPARAM_DUMMY_PENDTIME, m_nPendTime, m_nPrevPendTime);
		m_rgProps[epropOpensFail].Set(REGPARAM_DUMMY_OPENSFAIL, m_bOpensFail, m_bPrevOpensFail);
		m_rgProps[epropFailed].Set(REGPARAM_DUMMY_FAILED, m_bFailed, m_bPrevFailed);
		m_rgProps[epropAsynchronous].Set(REGPARAM_DUMMY_ASYNCHRONOUS, m_bAsynchronous, m_bPrevAsynchronous);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_DUMMY_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_DUMMY_PARAMETERS;

}  //*** CDummyParamsPage::CDummyParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDummyParamsPage::DoDataExchange(CDataExchange * pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_MAP(CDummyParamsPage)
	DDX_Text(pDX, IDC_PP_DUMMY_PENDING, m_bPending);
	DDX_Text(pDX, IDC_PP_DUMMY_PENDTIME, m_nPendTime);
	DDX_Text(pDX, IDC_PP_DUMMY_OPENSFAIL, m_bOpensFail);
	DDX_Text(pDX, IDC_PP_DUMMY_FAILED, m_bFailed);
	DDX_Text(pDX, IDC_PP_DUMMY_ASYNCHRONOUS, m_bAsynchronous);
	//}}AFX_DATA_MAP

	// Handle numeric parameters.
	if (!BBackPressed())
	{
		DDX_Number(pDX, IDC_PP_DUMMY_PENDTIME, m_nPendTime, (DWORD) (0), (DWORD) (4294967295), FALSE /*bSigned*/);
	}  // if:  back button not pressed

	// TODO: Add any additional field validation here.
	if (pDX->m_bSaveAndValidate)
	{
		// Make sure all required fields are present.
		if (!BBackPressed())
		{
		}  // if:  back button not pressed
	}  // if:  saving data from dialog

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CDummyParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDummyParamsPage::OnInitDialog(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CBasePropertyPage::OnInitDialog();

	// TODO:
	// Limit the size of the text that can be entered in edit controls.

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CDummyParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDummyParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Enable/disable the Next/Finish button.
	if (BWizard())
		EnableNext(BAllRequiredFieldsPresent());

	return CBasePropertyPage::OnSetActive();

}  //*** CDummyParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::OnChangeRequiredField
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDummyParamsPage::OnChangeRequiredField(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
		EnableNext(BAllRequiredFieldsPresent());

}  //*** CDummyParamsPage::OnChangeRequiredField()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDummyParamsPage::BAllRequiredFieldsPresent
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Share name or Path edit
//		controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDummyParamsPage::BAllRequiredFieldsPresent(void) const
{
	return TRUE;

}  //*** CDummyParamsPage::BAllRequiredFieldsPresent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <DebugSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genapp\genapp.c ===
/*++

Copyright (c) 1992-1998  Microsoft Corporation

Module Name:

    genapp.c

Abstract:

    Resource DLL for Generic Applications.

Author:

    Rod Gamache (rodga) 8-Jan-1996

Revision History:

--*/
#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "userenv.h"

#define LOG_CURRENT_MODULE LOG_MODULE_GENAPP

#define DBG_PRINT printf


#define PARAM_NAME__COMMANDLINE         CLUSREG_NAME_GENAPP_COMMAND_LINE
#define PARAM_NAME__CURRENTDIRECTORY    CLUSREG_NAME_GENAPP_CURRENT_DIRECTORY
#define PARAM_NAME__USENETWORKNAME      CLUSREG_NAME_GENAPP_USE_NETWORK_NAME
#define PARAM_NAME__INTERACTWITHDESKTOP CLUSREG_NAME_GENAPP_INTERACT_WITH_DESKTOP

#define PARAM_MIN__USENETWORKNAME           0
#define PARAM_MAX__USENETWORKNAME           1
#define PARAM_DEFAULT__USENETWORKNAME       0

#define PARAM_MIN__INTERACTWITHDESKTOP      0
#define PARAM_MAX__INTERACTWITHDESKTOP      1
#define PARAM_DEFAULT__INTERACTWITHDESKTOP  0

typedef struct _GENAPP_PARAMS {
    PWSTR           CommandLine;
    PWSTR           CurrentDirectory;
    DWORD           UseNetworkName;
    DWORD           InteractWithDesktop;
} GENAPP_PARAMS, *PGENAPP_PARAMS;

typedef struct _GENAPP_RESOURCE {
    GENAPP_PARAMS   Params;
    HRESOURCE       hResource;
    HANDLE          hProcess;
    DWORD           ProcessId;
    HKEY            ResourceKey;
    HKEY            ParametersKey;
    RESOURCE_HANDLE ResourceHandle;
    CLUS_WORKER     PendingThread;
    BOOL            Online;
    BOOL            SentCloseMessage;
} GENAPP_RESOURCE, *PGENAPP_RESOURCE;


//
// Global Data
//
RESUTIL_PROPERTY_ITEM
GenAppResourcePrivateProperties[] = {
    { PARAM_NAME__COMMANDLINE,         NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(GENAPP_PARAMS,CommandLine) },
    { PARAM_NAME__CURRENTDIRECTORY,    NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(GENAPP_PARAMS,CurrentDirectory) },
    { PARAM_NAME__INTERACTWITHDESKTOP, NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__INTERACTWITHDESKTOP, PARAM_MIN__INTERACTWITHDESKTOP, PARAM_MAX__INTERACTWITHDESKTOP, 0, FIELD_OFFSET(GENAPP_PARAMS,InteractWithDesktop) },
    { PARAM_NAME__USENETWORKNAME,      NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__USENETWORKNAME, PARAM_MIN__USENETWORKNAME, PARAM_MAX__USENETWORKNAME, 0, FIELD_OFFSET(GENAPP_PARAMS,UseNetworkName) },
    { 0 }
};

//
// critsec to synchronize calling of SetProcessWindowStation in ClRtl routine
//
CRITICAL_SECTION GenAppWinsta0Lock;

// Event Logging routine

#define g_LogEvent ClusResLogEvent
#define g_SetResourceStatus ClusResSetResourceStatus

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE GenAppFunctionTable;


//
// Forward routines
//
BOOLEAN
VerifyApp(
    IN RESID ResourceId,
    IN BOOLEAN IsAliveFlag
    );

BOOL
FindOurWindow(
    HWND    WindowHandle,
    LPARAM  OurProcessId
    );

DWORD
GenAppGetPrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
GenAppValidatePrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENAPP_PARAMS Params
    );

DWORD
GenAppSetPrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
GenAppGetPids(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

//
// end of forward declarations
//

BOOL
GenAppInit(
    VOID
    )
{
    BOOL    success;
    DWORD   spinCount;

    //
    // set spinCount so system pre-allocates the event for critical
    // sections. use the same spin count that the heap mgr uses as doc'ed in
    // MSDN
    //
    spinCount = 0x80000000 | 4000;
    success = InitializeCriticalSectionAndSpinCount(&GenAppWinsta0Lock,
                                                    spinCount);

    return success;
}


VOID
GenAppUninit(
    VOID
    )
{
    DeleteCriticalSection( &GenAppWinsta0Lock );
}


BOOLEAN
WINAPI
GenAppDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        if ( !GenAppInit() ) {
            return(FALSE);
        }

        break;

    case DLL_PROCESS_DETACH:
        GenAppUninit();
        break;

    default:
        break;
    }

    return(TRUE);

} // GenAppDllEntryPoint


RESID
WINAPI
GenAppOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for generic application resource.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    RESID   appResid = 0;
    DWORD   errorCode;
    HKEY    parametersKey = NULL;
    HKEY    resKey = NULL;
    PGENAPP_RESOURCE resourceEntry = NULL;
    DWORD   paramNameMaxSize = 0;
    HCLUSTER hCluster;

    //
    // Get registry parameters for this resource.
    //

    errorCode = ClusterRegOpenKey( ResourceKey,
                                   CLUSREG_KEYNAME_PARAMETERS,
                                   KEY_READ,
                                   &parametersKey );

    if ( errorCode != NO_ERROR ) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open parameters key. Error: %1!u!.\n",
                     errorCode );
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    errorCode = ClusterRegOpenKey( ResourceKey,
                                   L"",
                                   KEY_READ,
                                   &resKey);
    if (errorCode != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     errorCode );
        goto error_exit;
    }

    resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(GENAPP_RESOURCE) );
    if ( resourceEntry == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a process info structure.\n" );
        errorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( resourceEntry, sizeof(GENAPP_RESOURCE) );

    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;
    hCluster = OpenCluster(NULL);
    if (hCluster == NULL) {
        errorCode = GetLastError();
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Failed to open cluster, error %1!u!.\n",
                     errorCode);
        goto error_exit;
    }
    resourceEntry->hResource = OpenClusterResource( hCluster, ResourceName );
    errorCode = GetLastError();
    CloseCluster(hCluster);
    if (resourceEntry->hResource == NULL) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open resource, error %1!u!.\n",
            errorCode
            );
        goto error_exit;
    }

    appResid = (RESID)resourceEntry;

error_exit:

    if ( appResid == NULL) {
        if (parametersKey != NULL) {
            ClusterRegCloseKey( parametersKey );
        }
        if (resKey != NULL) {
            ClusterRegCloseKey( resKey );
        }
    }

    if ( (appResid == 0) && (resourceEntry != NULL) ) {
        LocalFree( resourceEntry );
    }

    if ( errorCode != ERROR_SUCCESS ) {
        SetLastError( errorCode );
    }

    return(appResid);

} // GenAppOpen



DWORD
WINAPI
GenAppOnlineWorker(
    IN PCLUS_WORKER     Worker,
    IN PGENAPP_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Does the work of bringing a genapp resource online.

Arguments:

    Worker - Supplies the worker structure

    ResourceEntry - A pointer to the GenApp block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    RESOURCE_STATUS     resourceStatus;
    DWORD               status = ERROR_SUCCESS;
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION Process;
    LPWSTR              nameOfPropInError;
    LPWSTR              expandedDir = NULL;
    LPWSTR              expandedCommand = NULL;


    // Create Process parameters

    LPVOID   Environment = NULL;
    LPVOID   OldEnvironment;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    //resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    //
    // Read our parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ParametersKey,
                                                   GenAppResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto error_exit;
    }

    if ( ResourceEntry->Params.UseNetworkName ) {
        //
        // Create the new environment with the simulated net name.
        //
        Environment = ResUtilGetEnvironmentWithNetName( ResourceEntry->hResource );
    } else {
        HANDLE processToken;

        //
        // get the current process token. If it fails, we revert to using just the
        // system environment area
        //
        OpenProcessToken( GetCurrentProcess(), MAXIMUM_ALLOWED, &processToken );

        //
        // Clone the current environment, picking up any changes that might have
        // been made after resmon started
        //
        CreateEnvironmentBlock(&Environment, processToken, FALSE );

        if ( processToken != NULL ) {
            CloseHandle( processToken );
        }
    }

    ZeroMemory( &StartupInfo, sizeof(StartupInfo) );
    StartupInfo.cb = sizeof(StartupInfo);
    //StartupInfo.lpTitle = NULL;
    //StartupInfo.lpDesktop = NULL;
    StartupInfo.wShowWindow = SW_HIDE;
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    if ( ResourceEntry->Params.InteractWithDesktop ) {

        //
        // don't blindly hang waiting for the lock to become available.
        //
        while ( !TryEnterCriticalSection( &GenAppWinsta0Lock )) {
            if ( ClusWorkerCheckTerminate( Worker )) {
                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_WARNING,
                             L"Aborting online due to worker thread terminate request. lock currently "
                             L"owned by thread %1!u!.\n",
                             GenAppWinsta0Lock.OwningThread );
                
                goto error_exit;
            }

            Sleep( 1000 );
        }

        status = ClRtlAddClusterServiceAccountToWinsta0DACL();
        LeaveCriticalSection( &GenAppWinsta0Lock );

        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Unable to set DACL on interactive window station and its desktop. Error: %1!u!.\n",
                         status );
            goto error_exit;
        }

        StartupInfo.lpDesktop = L"WinSta0\\Default";
        StartupInfo.wShowWindow = SW_SHOW;
    }

    //
    // Expand the current directory parameter
    //
    if ( ResourceEntry->Params.CurrentDirectory ) {

        expandedDir = ResUtilExpandEnvironmentStrings( ResourceEntry->Params.CurrentDirectory );
        if ( expandedDir == NULL ) {
            status = GetLastError();
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Error expanding the current directory, %1!ls!. Error: %2!u!.\n",
                     ResourceEntry->Params.CurrentDirectory,
                     status );
            goto error_exit;
        }
    }

    //
    // Expand the command line parameter
    //
    if ( ResourceEntry->Params.CommandLine ) {

        expandedCommand = ResUtilExpandEnvironmentStrings( ResourceEntry->Params.CommandLine );
        if ( expandedCommand == NULL ) {
            status = GetLastError();
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Error expanding the command line, %1!ls!. Error: %2!u!.\n",
                     ResourceEntry->Params.CommandLine,
                     status );
            goto error_exit;
        }
    }

    if ( !CreateProcess( NULL,
                         expandedCommand,
                         NULL,
                         NULL,
                         FALSE,
                         CREATE_UNICODE_ENVIRONMENT,
                         Environment,
                         expandedDir,
                         &StartupInfo,
                         &Process ) )
    {
        status = GetLastError();
        ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                       LOG_CRITICAL,
                                       RES_GENAPP_CREATE_FAILED,
                                       sizeof(status),
                                       &status);
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     LOG_ERROR,
                     L"Failed to create process. Error: %1!u!.\n",
                         status );
        goto error_exit;
    }

    //
    // Save the handle to the process
    //
    ResourceEntry->hProcess = Process.hProcess;
    ResourceEntry->ProcessId = Process.dwProcessId;
    CloseHandle( Process.hThread );

    ResourceEntry->Online = TRUE;

    //
    // When the process fails EventHandle will be signaled.
    // Because of this no polling is necessary.
    //

    resourceStatus.EventHandle = ResourceEntry->hProcess;
    resourceStatus.ResourceState = ClusterResourceOnline;

error_exit:

    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }

    if ( expandedDir != NULL ) {
        LocalFree( expandedDir );
    }

    if ( expandedCommand != NULL ) {
        LocalFree( expandedCommand );
    }

    if (Environment != NULL) {
        RtlDestroyEnvironment(Environment);
    }

    return(status);

} // GenAppOnlineWorker



DWORD
WINAPI
GenAppOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Generic Application resource.

Arguments:

    ResourceId - Supplies resource id to be brought online

    EventHandle - Supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PGENAPP_RESOURCE resourceEntry;
    DWORD   status = ERROR_SUCCESS;

    resourceEntry = (PGENAPP_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
#if DBG
        OutputDebugStringA( "GenApp: Online request for a nonexistent resource\n" );
#endif
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->hProcess != NULL ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online request and process handle is not NULL!\n" );
        return(ERROR_NOT_READY);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               GenAppOnlineWorker,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // GenAppOnline

VOID
WINAPI
GenAppTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate entry point for the Generic Application resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PGENAPP_RESOURCE    pResource;

    DWORD   errorCode;

    pResource = ( PGENAPP_RESOURCE ) ResourceId;

    //
    // synchronize with any existing pending operation
    //
    ClusWorkerTerminate( &pResource->PendingThread );

    if ( pResource->hProcess != NULL ) {

        if ( !TerminateProcess( pResource->hProcess, 1 ) ) {
            errorCode = GetLastError();
            if ( errorCode != ERROR_ACCESS_DENIED ) {
                (g_LogEvent)(pResource->ResourceHandle,
                             LOG_ERROR,
                             L"Failed to terminate Process ID %1!u!. Error: %2!u!.\n",
                             pResource->ProcessId,
                             errorCode );
            }
        }

        pResource->ProcessId = 0;

        CloseHandle( pResource->hProcess );
        pResource->hProcess = NULL;

        pResource->Online = FALSE;
    }
} // GenAppTerminate

DWORD
WINAPI
GenAppOfflineWorker(
    IN PCLUS_WORKER     Worker,
    IN PGENAPP_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Real worker routine for offlining a Generic Application resource.

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the GenApp block for this resource.

Return Value:

    None.

--*/

{
    DWORD   errorCode = ERROR_SUCCESS;
    BOOL    switchedDesktop = FALSE;
    HDESK   previousDesktop = NULL;
    HDESK   inputDesktop;
    HDESK   desktopHandle = NULL;
    BOOL    success;
    BOOL    callTerminateProc = TRUE;
    HWINSTA winsta0 = NULL;
    HWINSTA previousWinsta;
    DWORD   logLevel = LOG_INFORMATION;

    RESOURCE_STATUS     resourceStatus;

    //
    // init resource status structure
    //
    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //
    // get a handle to the appropriate desktop so we enum the correct window
    // set.
    //
    if ( ResourceEntry->Params.InteractWithDesktop ) {

        //
        // periodically check to see if we should terminate
        //
        while ( !TryEnterCriticalSection( &GenAppWinsta0Lock )) {
            if ( ClusWorkerCheckTerminate( Worker )) {
                (g_LogEvent)(ResourceEntry->ResourceHandle,
                             LOG_WARNING,
                             L"Aborting offline while trying to acquire desktop lock. lock currently "
                             L"owned by thread %1!u!.\n",
                             GenAppWinsta0Lock.OwningThread );
                
                goto error_exit;
            }

            Sleep( 500 );
        }

        winsta0 = OpenWindowStation( L"winsta0", FALSE, GENERIC_ALL );
        if ( winsta0 != NULL ) {

            previousWinsta = GetProcessWindowStation();
            if ( previousWinsta != NULL ) {

                success = SetProcessWindowStation( winsta0 );
                if ( success ) {
                    //
                    // if we have window station access, we should have desktop as well
                    //

                    desktopHandle = OpenInputDesktop( 0, FALSE, GENERIC_ALL );
                    if ( desktopHandle != NULL ) {
                        switchedDesktop = TRUE;
                    }
                }
            }
        }

        if ( !switchedDesktop ) {
            errorCode = GetLastError();
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Unable to switch to interactive desktop for process %1!u!, status %2!u!.\n",
                         ResourceEntry->ProcessId,
                         errorCode );

            LeaveCriticalSection( &GenAppWinsta0Lock );

            if ( winsta0 != NULL ) {
                CloseWindowStation( winsta0 );
            }
        }
    } else {
        //
        // get handle to service controller's desktop
        //
        desktopHandle = GetThreadDesktop( GetCurrentThreadId() );
    }

    ResourceEntry->SentCloseMessage = FALSE;
#if DBG
    (g_LogEvent)(ResourceEntry->ResourceHandle,
                 LOG_INFORMATION,
                 L"Looking for window with PID %1!u!.\n",
                 ResourceEntry->ProcessId );
#endif

    //
    // find our window. If found, we'll post a WM_CLOSE and set
    // SentCloseMessage. It's possible, under heavy load conditions with rapid
    // resource state transition, that the primary top level window associated
    // with the process has not been created when the offline request is
    // made. We'll send WM_CLOSE to the ones we find and hope that it shuts
    // down the process. If no windows are found, we just terminate the
    // process.
    //
    do {
        if ( desktopHandle ) {
            EnumDesktopWindows( desktopHandle, FindOurWindow, (LPARAM)ResourceEntry );
        }

        if ( ResourceEntry->SentCloseMessage ) {
            //
            // we found a toplevel window. wait on the process handle until the
            // handle is signalled or a pending timeout has occurred
            //
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_INFORMATION,
                         L"Sent WM_CLOSE to process %1!u! - waiting for process to terminate.\n",
                         ResourceEntry->ProcessId);

            errorCode = WaitForSingleObject( ResourceEntry->hProcess, 1000 );

            if ( errorCode == WAIT_OBJECT_0 ) {
                callTerminateProc = FALSE;
                break;
            } else {
                if ( ClusWorkerCheckTerminate( Worker )) {
                    (g_LogEvent)(ResourceEntry->ResourceHandle,
                                 LOG_WARNING,
                                 L"Aborting offline while waiting for process to terminate.\n");

                    logLevel = LOG_WARNING;
                    break;
                }
            }
        } else {
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_INFORMATION,
                         L"No windows detected for process %1!u!\n",
                         ResourceEntry->ProcessId);
            break;
        }
    } while ( TRUE );

    if ( switchedDesktop ) {
        SetProcessWindowStation( previousWinsta );

        CloseDesktop( desktopHandle );
        CloseWindowStation( winsta0 );

        LeaveCriticalSection( &GenAppWinsta0Lock );
    }

    if ( callTerminateProc ) {
        (g_LogEvent)(ResourceEntry->ResourceHandle,
                     logLevel,
                     L"Terminating process %1!u!\n",
                     ResourceEntry->ProcessId);

        if ( !TerminateProcess( ResourceEntry->hProcess, 1 ) ) {
            errorCode = GetLastError();
            if ( errorCode != ERROR_ACCESS_DENIED ) {
                (g_LogEvent)(
                             ResourceEntry->ResourceHandle,
                             LOG_ERROR,
                             L"Failed to terminate Process ID %1!u!. Error: %2!u!.\n",
                             ResourceEntry->ProcessId,
                             errorCode );
            }
        }
    }

    ResourceEntry->ProcessId = 0;

    CloseHandle( ResourceEntry->hProcess );
    ResourceEntry->hProcess = NULL;

    ResourceEntry->Online = FALSE;

    resourceStatus.ResourceState = ClusterResourceOffline;

error_exit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return ERROR_SUCCESS;
} // GenAppOfflineThread


DWORD
WINAPI
GenAppOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for Generic Application resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    PGENAPP_RESOURCE resourceEntry;
    DWORD   status = ERROR_SUCCESS;

    resourceEntry = (PGENAPP_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
#if DBG
        OutputDebugStringA( "GenApp: Offline request for a nonexistent resource\n" );
#endif
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->hProcess == NULL ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline request and process handle is NULL!\n" );
        return(ERROR_NOT_READY);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               GenAppOfflineWorker,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // GenAppOffline


BOOL
WINAPI
GenAppIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Generice Applications resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    return VerifyApp( ResourceId, TRUE );

} // GenAppIsAlive



BOOLEAN
VerifyApp(
    IN RESID ResourceId,
    IN BOOLEAN IsAliveFlag
    )

/*++

Routine Description:

    Verify that a Generic Applications resource is running

Arguments:

    ResourceId - Supplies the resource id to be polled.

    IsAliveFlag - TRUE if called from IsAlive, otherwise called from LooksAlive.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/
{

    return TRUE;

} // VerifyApp



BOOL
WINAPI
GenAppLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Generic Applications resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    return VerifyApp( ResourceId, FALSE );

} // GenAppLooksAlive



VOID
WINAPI
GenAppClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Generic Applications resource.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PGENAPP_RESOURCE resourceEntry;
    DWORD   errorCode;

    resourceEntry = (PGENAPP_RESOURCE)ResourceId;
    if ( resourceEntry == NULL ) {
#if DBG
        OutputDebugStringA( "GenApp: Close request for a nonexistent resource\n" );
#endif
        return;
    }

    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );

    LocalFree( resourceEntry->Params.CommandLine );
    LocalFree( resourceEntry->Params.CurrentDirectory );

    LocalFree( resourceEntry );

} // GenAppClose



DWORD
GenAppResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Generic Application resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PGENAPP_RESOURCE    resourceEntry;
    DWORD               required;

    resourceEntry = (PGENAPP_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
#if DBG
        OutputDebugStringA( "GenApp: ResourceControl request for a nonexistent resource\n" );
#endif
        return(FALSE);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenAppResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenAppResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = GenAppGetPrivateResProperties( resourceEntry,
                                                    OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = GenAppValidatePrivateResProperties( resourceEntry,
                                                         InBuffer,
                                                         InBufferSize,
                                                         NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = GenAppSetPrivateResProperties( resourceEntry,
                                                    InBuffer,
                                                    InBufferSize );
            break;

        case CLUSCTL_RESOURCE_GET_LOADBAL_PROCESS_LIST:
            status = GenAppGetPids( resourceEntry,
                                    OutBuffer,
                                    OutBufferSize,
                                    BytesReturned );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenAppResourceControl



DWORD
GenAppResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Generic Application resources.

    Perform the control request specified by ControlCode for this resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenAppResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenAppResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenAppResourceTypeControl



DWORD
GenAppGetPrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type GenApp.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      GenAppResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // GenAppGetPrivateResProperties



DWORD
GenAppValidatePrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENAPP_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Generic Application.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    ERROR_DEPENDENCY_NOT_FOUND - Trying to set UseNetworkName when there
        is no dependency on a Network Name resource.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENAPP_PARAMS   currentProps;
    GENAPP_PARAMS   newProps;
    PGENAPP_PARAMS  pParams = NULL;
    BOOL            hResDependency;
    LPWSTR          nameOfPropInError;
    WCHAR           netnameBuffer[ MAX_PATH + 1 ];
    DWORD           netnameBufferSize = sizeof( netnameBuffer ) / sizeof( WCHAR );

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Retrieve the current set of private properties from the
    // cluster database.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 GenAppResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(GENAPP_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       GenAppResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( GenAppResourcePrivateProperties,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the CurrentDirectory
        //
        if ( pParams->CurrentDirectory &&
             !ResUtilIsPathValid( pParams->CurrentDirectory ) ) {
            status = ERROR_INVALID_PARAMETER;
            goto FnExit;
        }

        //
        // If the resource should use the network name as the computer
        // name, make sure there is a dependency on a Network Name
        // resource.
        //
        if ( pParams->UseNetworkName ) {
            hResDependency = GetClusterResourceNetworkName(ResourceEntry->hResource,
                                                           netnameBuffer,
                                                           &netnameBufferSize);
            if ( !hResDependency ) {
                status = ERROR_DEPENDENCY_NOT_FOUND;
            }
        }
    }

FnExit:
    //
    // Cleanup our parameter block.
    //
    if (   (   (status != ERROR_SUCCESS)
            && (pParams != NULL)
           )
        || ( pParams == &newProps )
       )
    {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   GenAppResourcePrivateProperties );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        GenAppResourcePrivateProperties
        );

    return(status);

} // GenAppValidatePrivateResProperties



DWORD
GenAppSetPrivateResProperties(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Generic Application.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENAPP_PARAMS   params;

    ZeroMemory( &params, sizeof(GENAPP_PARAMS) );

    //
    // Parse and validate the properties.
    //
    status = GenAppValidatePrivateResProperties( ResourceEntry,
                                                 InBuffer,
                                                 InBufferSize,
                                                 &params );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               GenAppResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               GenAppResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( ResourceEntry->Online ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // GenAppSetPrivateResProperties

DWORD
GenAppGetPids(
    IN OUT PGENAPP_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Get array of PIDs (as DWORDS) to return for load balancing purposes.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Supplies a pointer to a buffer for output data.

    OutBufferSize - Supplies the size, in bytes, of the buffer pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    CLUSPROP_BUFFER_HELPER props;

    props.pb = OutBuffer;
    *BytesReturned = sizeof(*props.pdw);

    if ( OutBufferSize < sizeof(*props.pdw) ) {
        return(ERROR_MORE_DATA);
    }

    *(props.pdw) = ResourceEntry->ProcessId;

    return(ERROR_SUCCESS);

} // GenAppGetPids



BOOL
FindOurWindow(
    HWND    WindowHandle,
    LPARAM  Resource
    )

/*++

Routine Description:

    Find our window handle in the midst of all of this confusion.

Arguments:

    WindowHandle - a handle to the current window being enumerated.

    Resource - pointer to resource's context block

Return Value:

    TRUE - if we should continue enumeration.

    FALSE - if we should not continue enumeration.

--*/

{
    DWORD   windowPid;
    BOOL    success;
    PGENAPP_RESOURCE    resource = (PGENAPP_RESOURCE)Resource;

    GetWindowThreadProcessId( WindowHandle, &windowPid );

    if ( windowPid == resource->ProcessId ) {
        success = PostMessage(WindowHandle, WM_CLOSE, 0, 0);
        if ( success ) {

#if DBG
            if ( !resource->SentCloseMessage ) {
                (g_LogEvent)(resource->ResourceHandle,
                             LOG_ERROR,
                             L"Posting WM_CLOSE message on HWND %2!08X! for process %1!u!\n",
                             resource->ProcessId,
                             WindowHandle);
            } else {
                (g_LogEvent)(resource->ResourceHandle,
                             LOG_ERROR,
                             L"Posting WM_CLOSE message on addt'l HWND %2!08X! for process %1!u!\n",
                             resource->ProcessId,
                             WindowHandle);
            }
#endif

            resource->SentCloseMessage = TRUE;
        }
        else {
            (g_LogEvent)(resource->ResourceHandle,
                         LOG_ERROR,
                         L"Posting of WM_CLOSE message to window for process %1!u! failed - status %2!u!\n",
                         resource->ProcessId,
                         GetLastError());

        }
    }

    //
    // continue to enum since a process can have more than one top level window
    //
    return TRUE;

} // FindOurWindow



//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( GenAppFunctionTable,  // Name
                         CLRES_VERSION_V1_00,  // Version
                         GenApp,               // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         GenAppResourceControl,// ResControl
                         GenAppResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\activescriptsite.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2002 Microsoft Corporation
//
//  Module Name:
//      ActiveScriptSite.cpp
//
//  Description:
//      CActiveScript class implementation.
//
//  Maintained By:
//      Ozan Ozhan  (OzanO)     27-MAR-2002
//      Geoff Pease (GPease)    08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ResourceObject.h"
#include "ActiveScriptSite.h"

DEFINE_THISCLASS( "CActiveScriptSite" );

//////////////////////////////////////////////////////////////////////
// 
//  Constructor
//
//////////////////////////////////////////////////////////////////////
CActiveScriptSite::CActiveScriptSite(
    RESOURCE_HANDLE     hResourceIn
    , PLOG_EVENT_ROUTINE    plerIn
    , HKEY                  hkeyIn
    , LPCWSTR               pszNameIn
    )
    : m_cRef( 1 )
    , m_hResource( hResourceIn )
    , m_pler( plerIn )
    , m_hkey( hkeyIn )
    , m_pszName( pszNameIn )
{
    TraceFunc( "" );

    Assert( m_punkResource == 0 );

    TraceFuncExit();

} //*** CActiveScriptSite::CActiveScriptSite

//////////////////////////////////////////////////////////////////////
// 
//  Destructor
//
//////////////////////////////////////////////////////////////////////
CActiveScriptSite::~CActiveScriptSite( void )
{
    TraceFunc( "" );

    // Don't close m_hkey.
    // Don't free m_pszName
    
    if ( m_punkResource != NULL )
    {
        m_punkResource->Release();
    }

    TraceFuncExit();

} //*** CActiveScriptSite::~CActiveScriptSite

//****************************************************************************
//
//  IUnknown
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::[IUnknown] QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::QueryInterface( 
      REFIID    riidIn
    , void **   ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    if ( riidIn == IID_IUnknown )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IUnknown, (IActiveScriptSite*) this, 0 );
    }
    else if ( riidIn == IID_IActiveScriptSite )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IActiveScriptSite, (IActiveScriptSite*) this, 0 );
    }
    else if ( riidIn == IID_IActiveScriptSiteInterruptPoll )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IActiveScriptSiteInterruptPoll, (IActiveScriptSiteInterruptPoll*) this, 0 );
    }
    else if ( riidIn == IID_IActiveScriptSiteWindow )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IActiveScriptSiteWindow, (IActiveScriptSiteWindow*) this, 0 );
    }
    else if ( riidIn == IID_IDispatchEx )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDispatchEx, (IDispatchEx*) this, 0 );
    }
    else if ( riidIn == IID_IDispatch )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDispatch, (IDispatchEx*) this, 0 );
    }
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    }

    QIRETURN2( hr, riidIn, IID_IActiveScriptSiteDebug32, IID_IActiveScriptSiteDebug64 );

} //*** CActiveScriptSite::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) 
CActiveScriptSite::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CActiveScriptSite::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) 
CActiveScriptSite::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CActiveScriptSite::Release

//****************************************************************************
//
// IActiveScriptSite
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetLCID( 
//      LCID *plcid // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetLCID( 
    LCID * plcid // out
    )
{
    TraceFunc( "[IActiveScriptSite]" );

    HRESULT hr = S_FALSE;
   
    if ( plcid == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );   // use system-defined locale

} //*** CActiveScriptSite::GetLCID
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetItemInfo( 
//      LPCOLESTR pstrName,     // in
//      DWORD dwReturnMask,     // in
//      IUnknown **ppiunkItem,  // out
//      ITypeInfo **ppti        // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetItemInfo( 
      LPCOLESTR     pstrName        // in
    , DWORD         dwReturnMask    // in
    , IUnknown **   ppiunkItem      // out
    , ITypeInfo **  ppti            // out
    )
{
    TraceFunc( "[IActiveScriptSite]" );

    HRESULT hr;

    if ( ( dwReturnMask & SCRIPTINFO_IUNKNOWN ) && ( ppiunkItem == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( ( dwReturnMask & SCRIPTINFO_ITYPEINFO ) && ( ppti == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( pstrName == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    hr = TYPE_E_ELEMENTNOTFOUND;

    if ( ClRtlStrICmp( pstrName, L"Resource" ) == 0 )
    {
        if ( dwReturnMask & SCRIPTINFO_IUNKNOWN )
        {
            if ( m_punkResource == NULL )
            {
                m_punkResource = new CResourceObject( m_hResource, m_pler, m_hkey, m_pszName );
                if ( m_punkResource == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                }

                //
                //  No need to AddRef() as the constructor does that for us.
                //
            }

            hr = m_punkResource->TypeSafeQI( IUnknown, ppiunkItem );
        }

        if ( SUCCEEDED( hr ) && ( dwReturnMask & SCRIPTINFO_ITYPEINFO ) )
        {
            *ppti = NULL;
            hr = THR( E_FAIL );
        }
    }

Cleanup:

    HRETURN( hr );

} //*** CActiveScriptSite::GetItemInfo
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetDocVersionString( 
//      BSTR *pbstrVersion  // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetDocVersionString( 
    BSTR * pbstrVersion  // out
    )
{
    TraceFunc( "[IActiveScriptSite]" );

    HRESULT hr = S_OK;

    if ( pbstrVersion == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pbstrVersion = SysAllocString( L"Cluster Scripting Host Version 1.0" );
    if ( *pbstrVersion == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CActiveScriptSite::GetDocVersionString
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnScriptTerminate( 
//      const VARIANT *pvarResult,      // in
//      const EXCEPINFO *pexcepinfo     // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnScriptTerminate( 
      const VARIANT *   pvarResult  // in
    , const EXCEPINFO * pexcepinfo  // in
    )
{
    TraceFunc( "[IActiveScriptSite]" );

    HRETURN( S_OK );    // nothing to do

} //*** CActiveScriptSite::OnScriptTerminate
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnStateChange( 
//      SCRIPTSTATE ssScriptState   // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnStateChange( 
    SCRIPTSTATE ssScriptState   // in
    )
{
    TraceFunc( "[IActiveScriptSite]" );

#if defined(DEBUG)
    //
    // We don't really care.
    //
    switch ( ssScriptState )
    {
        case SCRIPTSTATE_UNINITIALIZED:
            TraceMsg( mtfCALLS, "OnStateChange: Uninitialized\n" );
            break;

        case SCRIPTSTATE_INITIALIZED:
            TraceMsg( mtfCALLS, "OnStateChange: Initialized\n" );
            break;

        case SCRIPTSTATE_STARTED:
            TraceMsg( mtfCALLS, "OnStateChange: Started\n" );
            break;

        case SCRIPTSTATE_CONNECTED:
            TraceMsg( mtfCALLS, "OnStateChange: Connected\n" );
            break;

        case SCRIPTSTATE_DISCONNECTED:
            TraceMsg( mtfCALLS, "OnStateChange: Disconnected\n" );
            break;

        case SCRIPTSTATE_CLOSED:
            TraceMsg( mtfCALLS, "OnStateChange: Closed\n" );
            break;

        default:
            TraceMsg( mtfCALLS, "OnStateChange: Unknown value\n" );
            break;
    }
#endif // defined(DEBUG)

    HRETURN( S_OK );

} //*** CActiveScriptSite::OnStateChange
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnScriptError( 
//      IActiveScriptError *pscripterror    // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnScriptError( 
    IActiveScriptError * pscripterror    // in
    )
{
    TraceFunc( "[IActiveScriptSite]" );

    HRESULT     hr;
    BSTR        bstrSourceLine = NULL;
    DWORD       dwSourceContext;
    ULONG       ulLineNumber;
    LONG        lCharacterPosition;
    EXCEPINFO   excepinfo;

    hr = THR( pscripterror->GetSourcePosition( &dwSourceContext, &ulLineNumber, &lCharacterPosition ) );
    // Should this be handled?

    hr = THR( pscripterror->GetSourceLineText( &bstrSourceLine ) );
    if (SUCCEEDED( hr ))
    {
        TraceMsg( mtfCALLS, "Script Error: Line=%u, Character=%u: %s\n", ulLineNumber, lCharacterPosition, bstrSourceLine );
        (ClusResLogEvent)( m_hResource, 
                           LOG_ERROR, 
                           L"Script Error: Line=%1!u!, Character=%2!u!: %3\n", 
                           ulLineNumber, 
                           lCharacterPosition, 
                           bstrSourceLine 
                           );
        SysFreeString( bstrSourceLine );
    }
    else
    {
        TraceMsg( mtfCALLS, "Script Error: ulLineNumber = %u, lCharacter = %u\n", ulLineNumber, lCharacterPosition );
        (ClusResLogEvent)( m_hResource, 
                           LOG_ERROR, 
                           L"Script Error: Line=%1!u!, Character = %2!u!\n", 
                           ulLineNumber, 
                           lCharacterPosition 
                           );
    }

    hr = THR( pscripterror->GetExceptionInfo( &excepinfo ) );
    if (SUCCEEDED( hr ))
    {
        if ( excepinfo.bstrSource )
        {
            TraceMsg( mtfCALLS, "Source: %s\n", excepinfo.bstrSource );
            (ClusResLogEvent)( m_hResource, LOG_ERROR, L"Source: %1\n", excepinfo.bstrSource );
        }

        if ( excepinfo.bstrDescription )
        {
            TraceMsg( mtfCALLS, "Description: %s\n", excepinfo.bstrDescription );
            (ClusResLogEvent)( m_hResource, LOG_ERROR, L"Description: %1\n", excepinfo.bstrDescription );
        }

        if ( excepinfo.bstrHelpFile )
        {
            TraceMsg( mtfCALLS, "Help File: %s\n", excepinfo.bstrHelpFile );
            (ClusResLogEvent)( m_hResource, LOG_ERROR, L"Help File: %1\n", excepinfo.bstrHelpFile );
        }

        hr = THR( excepinfo.scode );
    }

    HRETURN( S_FALSE );

} //*** CActiveScriptSite::OnScriptError
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnEnterScript( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnEnterScript( void )
{
    TraceFunc( "[IActiveScriptSite]" );

    HRETURN( S_OK );

} //*** CActiveScriptSite::OnEnterScript
    
//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::OnLeaveScript( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::OnLeaveScript( void )
{
    TraceFunc( "[IActiveScriptSite]" );

    HRETURN( S_OK );

} //*** CActiveScript::OnLeaveScript


//****************************************************************************
//
//  IActiveScriptSiteInterruptPoll 
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::QueryContinue( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::QueryContinue( void )
{
    TraceFunc( "[IActiveScriptSiteInterruptPoll]" );

    HRETURN( S_OK );

} //*** CActiveScriptSite::QueryContinue

//****************************************************************************
//
//  IActiveScriptSiteWindow
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetWindow( 
//      HWND *phwnd // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetWindow(
    HWND * phwnd // out
    )
{
    TraceFunc( "[IActiveScriptSiteInterruptPoll]" );

    HRESULT hr = S_OK;

    if ( phwnd == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *phwnd = NULL;  // desktop;

Cleanup:

    HRETURN( S_OK );

} //*** CActiveScriptSite::GetWindow

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::EnableModeless( 
//      BOOL fEnable // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::EnableModeless( 
    BOOL fEnable // in
    )
{
    TraceFunc( "[IActiveScriptSiteInterruptPoll]" );

    HRETURN( S_OK );

} //*** CActiveScriptSite::EnableModeless


//****************************************************************************
//
//  IDispatch
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetTypeInfoCount( 
//      UINT * pctinfo // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetTypeInfoCount( 
    UINT * pctinfo // out
    )
{
    TraceFunc( "[Dispatch]" );

    HRESULT hr = E_NOTIMPL;

    if ( pctinfo == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pctinfo = 0;

Cleanup:

    HRETURN( hr );

} //*** CActiveScriptSite::GetTypeInfoCount

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetTypeInfo( 
//      UINT iTInfo,            // in
//      LCID lcid,              // in
//      ITypeInfo * * ppTInfo   // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetTypeInfo( 
      UINT          iTInfo  // in
    , LCID          lcid    // in
    , ITypeInfo **  ppTInfo // out
    )
{
    TraceFunc( "[Dispatch]" );

    HRESULT hr = E_NOTIMPL;

    if ( ppTInfo == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *ppTInfo = NULL;

Cleanup:

    HRETURN( hr );

} //*** CActiveScriptSite::GetTypeInfo

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetIDsOfNames( 
//      REFIID      riid,       // in
//      LPOLESTR *  rgszNames,  // in
//      UINT        cNames,     // in
//      LCID        lcid,       // in
//      DISPID *    rgDispId    // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetIDsOfNames( 
      REFIID        riid        // in
    , LPOLESTR *    rgszNames   // in
    , UINT          cNames      // in
    , LCID          lcid        // in
    , DISPID *      rgDispId    // out
    )
{
    TraceFunc( "[Dispatch]" );

    HRESULT hr = E_NOTIMPL;

    ZeroMemory( rgDispId, cNames * sizeof(DISPID) );

    HRETURN( hr );

} //*** CActiveScriptSite::GetIDsOfNames

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::Invoke( 
//      DISPID dispIdMember,        // in
//      REFIID riid,                // in
//      LCID lcid,                  // in
//      WORD wFlags,                // in
//      DISPPARAMS *pDispParams,    // out in
//      VARIANT *pVarResult,        // out
//      EXCEPINFO *pExcepInfo,      // out
//      UINT *puArgErr              // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::Invoke( 
      DISPID        dispIdMember    // in
    , REFIID        riid            // in
    , LCID          lcid            // in
    , WORD          wFlags          // in
    , DISPPARAMS *  pDispParams     // out in
    , VARIANT *     pVarResult      // out
    , EXCEPINFO *   pExcepInfo      // out
    , UINT *        puArgErr        // out
    )
{
    TraceFunc( "[Dispatch]" );

    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CActiveScript::Invoke


//****************************************************************************
//
//  IDispatchEx
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetDispID(
//      BSTR bstrName,  // in
//      DWORD grfdex,   //in
//      DISPID *pid     //out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetDispID(
      BSTR      bstrName    // in
    , DWORD     grfdex      // in
    , DISPID *  pid         // out
    )
{
    TraceFunc( "[DispatchEx]" );

    HRESULT hr = S_OK;

    if ( pid == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    if ( ClRtlStrICmp( bstrName, L"Resource" ) == 0 )
    {
        *pid = 0;
    }
    else
    {
        hr = DISP_E_UNKNOWNNAME;
    }

Cleanup:

    HRETURN( hr );

} //*** CActiveScript::GetDiskID

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::InvokeEx( 
//      DISPID id,                  // in
//      LCID lcid,                  // in
//      WORD wFlags,                // in
//      DISPPARAMS *pdp,            // in
//      VARIANT *pvarRes,           // out
//      EXCEPINFO *pei,             // out
//      IServiceProvider *pspCaller // in
//      )
//      
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::InvokeEx(
      DISPID                id          // in
    , LCID                  lcid        // in
    , WORD                  wFlags      // in
    , DISPPARAMS *          pdp         // in
    , VARIANT *             pvarRes     // out
    , EXCEPINFO *           pei         // out
    , IServiceProvider *    pspCaller   // in
    )
{
    TraceFunc2( "[DispatchEx] id = %u, ..., wFlags = 0x%08x, ...", id, wFlags );

    HRESULT hr = S_OK;

    switch ( id )
    {
        case 0:
            pvarRes->vt = VT_DISPATCH;
            hr = THR( QueryInterface( IID_IDispatch, (void **) &pvarRes->pdispVal ) );
            break;

        default:
            hr = THR( DISP_E_MEMBERNOTFOUND );
            break;
    }

    HRETURN( hr );

} //*** CActiveScriptSite::InvokeEx

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::DeleteMemberByName( 
//      BSTR bstr,   // in
//      DWORD grfdex // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::DeleteMemberByName(
      BSTR  bstr    // in
    , DWORD grfdex  // in
    )
{
    TraceFunc( "[DispatchEx]" );

    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CActiveScriptSite::DeleteMemberByName

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::DeleteMemberByDispID( 
//      DISPID id   // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::DeleteMemberByDispID(
    DISPID id   // in
    )
{
    TraceFunc1( "[DispatchEx] id = %u", id );

    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CActiveScriptSite::DeleteMemberByDiskID

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetMemberProperties( 
//      DISPID id,          // in
//      DWORD grfdexFetch,  // in
//      DWORD * pgrfdex     // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetMemberProperties( 
      DISPID    id          // in
    , DWORD     grfdexFetch // in
    , DWORD *   pgrfdex     // out
    )
{
    TraceFunc2( "[DispatchEx] id = %u, grfdexFetch = 0x%08x", id, grfdexFetch );

    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CActiveScriptSite::GetMemberProperties

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetMemberName( 
//      DISPID id,          // in
//      BSTR * pbstrName    // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetMemberName(
      DISPID    id          // in
    , BSTR *    pbstrName   // out
    )
{
    TraceFunc1( "[DispatchEx] id = %u", id );

    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CActiveScriptSite::GetMemberName

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetNextDispID(
//      DWORD grfdex,  // in
//      DISPID id,     // in
//      DISPID * pid   // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetNextDispID(
      DWORD     grfdex  // in
    , DISPID    id      // in
    , DISPID *  pid     // out
    )
{
    TraceFunc2( "[DispatchEx] grfdex = 0x%08x, id = %u, ...", grfdex, id );

    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CActiveScriptSite::GetNextDiskID

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CActiveScriptSite::GetNameSpaceParent(
//      IUnknown * * ppunk  // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CActiveScriptSite::GetNameSpaceParent(
    IUnknown ** ppunk  // out
    )
{
    TraceFunc( "[DispatchEx]" );

    HRESULT hr = E_NOTIMPL;

    if ( ppunk == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *ppunk = NULL;

Cleanup:

    HRETURN( hr );

} //*** CActiveScriptSite::GetNameSpaceParent


//****************************************************************************
//
// Private Methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CActiveScriptSite::LogError(
//      HRESULT hrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CActiveScriptSite::LogError(
    HRESULT hrIn
    )
{
    TraceFunc1( "hrIn = 0x%08x", hrIn );

    HRESULT hr = S_OK;
    
    TraceMsg( mtfCALLS, "HRESULT: 0x%08x\n", hrIn );
    (ClusResLogEvent)( m_hResource, LOG_ERROR, L"HRESULT: 0x%1!08x!.\n", hrIn );

    HRETURN( hr );

} //*** CActiveScriptSite::LogError


//****************************************************************************
//
// Automation Methods
//
//****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\guids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      GUIDS.H
//
//  Description:
//      Guid definition file.
//
//  Maintained By:
//      Geoffrey Pease (GPEASE) 22-NOV-1999
//
//  Notes:
//      File gets re-include after INITGUID.H is included in GUIDS.CPP. You
//      should not use "#pragma once" in this file.
//
//////////////////////////////////////////////////////////////////////////////

// not pragma once
#ifndef _GUIDS_H_
#define _GUIDS_H_

//
// External CLSIDs
//


#endif // _GUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2002 Microsoft Corporation
//
//  Module Name:
//      Log.cpp
//
//  Description:
//      Sucks in the log library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <DirectoryUtilities.cpp>
#include <LogSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"

#pragma warning( push )
#pragma warning( disable : 4100 )
#include <CITrackerSrc.cpp>
#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\guids.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Guids.cpp
//
//  Description:
//      Guids definition instantiation and DEBUG interface table definitions.
//
//  Maintained By:
//      gpease 08-FEB-1999
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>

#undef _GUIDS_H_
#include "guids.h"

//
// Interface Table
//
// This table is used in builds in which interface tracking was turned on. It
// is used to map a name with a particular IID. It also helps the CITracker
// determine the size of the interfaces Vtable to mimic (haven't figured out
// a runtime or compile time way to do this). To improve speed, put the most
// used interfaces first such as IUnknown (the search routine is a simple
// linear search).
//
BEGIN_INTERFACETABLE
    // most used interfaces
DEFINE_INTERFACE( IID_IUnknown,                 "IUnknown",                 0   )
DEFINE_INTERFACE( IID_IDispatch,                "IDispatch",                4   )
DEFINE_INTERFACE( IID_IDispatchEx,              "IDispatchEx",              12  ) 
DEFINE_INTERFACE( IID_IActiveScript,            "IActiveScript",            13  ) // activscp.idl
DEFINE_INTERFACE( IID_IActiveScriptSite,        "IActiveScriptSite",        8   ) // activscp.idl
DEFINE_INTERFACE( IID_IActiveScriptParse,       "IActiveScriptParse",       3   ) // activscp.idl
DEFINE_INTERFACE( IID_IActiveScriptError,       "IActiveScriptError",       3   ) // activscp.idl
DEFINE_INTERFACE( IID_IActiveScriptSiteWindow,  "IActiveScriptSiteWindow",  2   ) // activscp.idl
DEFINE_INTERFACE( IID_IActiveScriptSiteInterruptPoll,  "IActiveScriptSiteInterruptPoll",  1   ) // activscp.idl
END_INTERFACETABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\genscript.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CFactory.h
//
//  Description:
//      Class Factory implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#define CCH(sz)     (sizeof(sz)/sizeof(sz[0]))

//
// DLL Globals
//
extern HINSTANCE g_hInstance;
extern LONG      g_cObjects;
extern LONG      g_cLock;
extern WCHAR     g_szDllFilename[ MAX_PATH ];

extern LPVOID    g_GlobalMemoryList;            // Global memory tracking list

#define DllExport   __declspec( dllimport )

#define SCRIPTRES_RESTYPE_NAME                  L"ScriptRes"

//
// Class Definitions for DLLGetClassObject
//
typedef LPUNKNOWN (*LPCREATEINST)();

typedef struct _ClassTable {
    LPCREATEINST    pfnCreateInstance;  // creation function for class
    const CLSID *   rclsid;             // classes in this DLL
    LPCTSTR         pszName;            // Class name for debugging
    LPCTSTR         pszComModel;        // String indicating COM threading model
} CLASSTABLE[], *LPCLASSTABLE;

//
// Class Table Macros
//
#define BEGIN_CLASSTABLE const CLASSTABLE g_DllClasses = {
#define DEFINE_CLASS( _pfn, _riid, _name, _model ) { _pfn, &_riid, TEXT(_name), TEXT(_model) },
#define END_CLASSTABLE  { NULL, NULL, NULL, NULL } };
extern const CLASSTABLE  g_DllClasses;

//
// DLL required headers
//
#include <Debug.h>          // debugging
#include <CITracker.h>

#if defined( _X86_ ) && defined( TRACE_INTERFACES_ENABLED )
//
// DLL Interface Table Macros
//
#define BEGIN_INTERFACETABLE const INTERFACE_TABLE g_itTable = {
#define DEFINE_INTERFACE( _iid, _name, _count ) { &_iid, TEXT(_name), _count },
#define END_INTERFACETABLE { NULL, NULL, NULL } };
#endif  // TRACE_INTERFACES_ENABLED

//
// DLL Useful Macros
//
#define PtrToByteOffset(base, offset)   (((LPBYTE)base)+offset)

#define STATUS_TO_RETURN( _hr ) \
    ( ( HRESULT_FACILITY( _hr ) == FACILITY_WIN32 ) ? HRESULT_CODE( _hr ) : _hr )

//
// DLL Global Function Prototypes
//
HRESULT
HrClusCoCreateInstance(
    REFCLSID rclsidIn,
    LPUNKNOWN pUnkOuterIn,
    DWORD dwClsContextIn,
    REFIID riidIn,
    LPVOID * ppvOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\genscript.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2003 Microsoft Corporation
//
//  Module Name:
//      GenScript.cpp
//
//  Description:
//      DLL services/entry points for the generic script resource.
//
//  Maintained By:
//      Ozan Ozhan  (OzanO)     04-APR-2002
//      Geoff Pease (GPease)    08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ActiveScriptSite.h"
#include "ScriptResource.h"
#include "SpinLock.h"

//
// Debugging Module Name
//
DEFINE_MODULE("SCRIPTRES")

//
// DLL Globals
//
HINSTANCE g_hInstance = NULL;
LONG      g_cObjects  = 0;
LONG      g_cLock     = 0;
WCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };

#if defined(DEBUG)
LPVOID    g_GlobalMemoryList = NULL;    // Global memory tracking list
#endif

PSET_RESOURCE_STATUS_ROUTINE    g_prsrCallback  = NULL;

extern "C"
{

extern CLRES_FUNCTION_TABLE     GenScriptFunctionTable;

//
// GenScript resource read-write private properties
//
RESUTIL_PROPERTY_ITEM
GenScriptResourcePrivateProperties[] = {
    { CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( GENSCRIPT_PROPS, pszScriptFilePath ) },
    { 0 }
};

DWORD 
ScriptValidateResourcePrivateProperties(
      CScriptResource * pres
    , PVOID pvBufferIn
    , DWORD dwBufferInSizeIn
    , PGENSCRIPT_PROPS pPropsCurrent
    , PGENSCRIPT_PROPS pPropsNew
    );

//****************************************************************************
//
// DLL Entry Points
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// BOOL
// WINAPI
// GenScriptDllEntryPoint(
//      HANDLE  hInstIn, 
//      ULONG   ulReasonIn, 
//      LPVOID  lpReservedIn
//      )
//        
// Description:
//      Dll entry point.
//
// Arguments:
//      hInstIn      - DLL instance handle.
//      ulReasonIn   - DLL reason code for entrance.
//      lpReservedIn - Not used.
//
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
GenScriptDllEntryPoint(
    HINSTANCE   hInstIn,
    ULONG       ulReasonIn,
    LPVOID      // lpReservedIn
    )
{
    //
    // KB: THREAD_OPTIMIZATIONS gpease 19-OCT-1999
    //
    // By defining this you can prevent the linker
    // from calling your DllEntry for every new thread.
    // This makes creating new threads significantly
    // faster if every DLL in a process does it.
    // Unfortunately, not all DLLs do this.
    //
    // In CHKed/DEBUG, we keep this on for memory
    // tracking.
    //
#if ! defined( DEBUG )
    #define THREAD_OPTIMIZATIONS
#endif // DEBUG

    switch( ulReasonIn )
    {
        //////////////////////////////////////////////////////////////////////
        // DLL_PROCESS_ATTACH
        //////////////////////////////////////////////////////////////////////
        case DLL_PROCESS_ATTACH:
        {
#if defined( DEBUG_SW_TRACING_ENABLED )
            TraceInitializeProcess( g_rgTraceControlGuidList, ARRAYSIZE( g_rgTraceControlGuidList ), TRUE );
#else // ! DEBUG_SW_TRACING_ENABLED
            TraceInitializeProcess( TRUE );
#endif // DEBUG_SW_TRACING_ENABLED

            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_ATTACH - ThreadID = %#x"),
                          GetCurrentThreadId()
                          );

            g_hInstance = hInstIn;

#if defined( ENTRY_PREFIX )
             hProxyDll = g_hInstance;
#endif // ENTRY_PREFIX

            GetModuleFileNameW( g_hInstance, g_szDllFilename, ARRAYSIZE( g_szDllFilename ) );

            //
            // Create a global memory list so that memory allocated by one
            // thread and handed to another can be tracked without causing
            // unnecessary trace messages.
            //
            TraceCreateMemoryList( g_GlobalMemoryList );

#if defined( THREAD_OPTIMIZATIONS )
            {
                //
                // Disable thread library calls so that we don't get called
                // on thread attach and detach.
                //
                BOOL fResult = DisableThreadLibraryCalls( g_hInstance );
                if ( ! fResult )
                {
                    TW32MSG( GetLastError(), "DisableThreadLibraryCalls()" );
                }
            }
#endif // THREAD_OPTIMIZATIONS

#if defined( USE_FUSION )
            //
            // Initialize Fusion.
            //
            // The value of IDR_MANIFEST in the call to
            // SHFusionInitializeFromModuleID() must match the value specified in the
            // sources file for SXS_MANIFEST_RESOURCE_ID.
            //
            BOOL fResult = SHFusionInitializeFromModuleID( hInstIn, IDR_MANIFEST );
            if ( ! fResult )
            {
                TW32MSG( GetLastError(), "SHFusionInitializeFromModuleID()" );
            }
#endif // USE_FUSION

#if defined( DO_MODULE_INIT )
            THR( HrLocalProcessInit() );
#endif

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

            break;
        } // case: DLL_PROCESS_ATTACH

        //////////////////////////////////////////////////////////////////////
        // DLL_PROCESS_DETACH
        //////////////////////////////////////////////////////////////////////
        case DLL_PROCESS_DETACH:
        {
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId(),
                          g_cLock,
                          g_cObjects
                          );

#if defined( DO_MODULE_UNINIT )
            THR( HrLocalProcessUninit() );
#endif

            //
            // Cleanup the global memory list used to track memory allocated
            // in one thread and then handed to another.
            //
            TraceTerminateMemoryList( g_GlobalMemoryList );

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

#if defined( DEBUG_SW_TRACING_ENABLED )
            TraceTerminateProcess( g_rgTraceControlGuidList, ARRAYSIZE( g_rgTraceControlGuidList )
                                   );
#else // ! DEBUG_SW_TRACING_ENABLED
            TraceTerminateProcess();
#endif // DEBUG_SW_TRACING_ENABLED

#if defined( USE_FUSION )
            SHFusionUninitialize();
#endif // USE_FUSION

            break;
        } // case: DLL_PROCESS_DETACH

#if ! defined( THREAD_OPTIMIZATIONS )
        //////////////////////////////////////////////////////////////////////
        // DLL_THREAD_ATTACH
        //////////////////////////////////////////////////////////////////////
        case DLL_THREAD_ATTACH:
        {
            TraceInitializeThread( NULL );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("Thread %#x has started."),
                          GetCurrentThreadId()
                          );
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_ATTACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId(),
                          g_cLock,
                          g_cObjects
                          );

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

            break;
        } // case: DLL_THREAD_ATTACH

        //////////////////////////////////////////////////////////////////////
        // DLL_THREAD_DETACH
        //////////////////////////////////////////////////////////////////////
        case DLL_THREAD_DETACH:
        {
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId(),
                          g_cLock,
                          g_cObjects
                          );

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

            TraceThreadRundown();

            break;
        } // case: DLL_THREAD_DETACH
#endif // ! THREAD_OPTIMIZATIONS

        default:
        {
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: UNKNOWN ENTRANCE REASON - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId(),
                          g_cLock,
                          g_cObjects
                          );

#if defined( THREAD_OPTIMIZATIONS )
            Assert( ( ulReasonIn != DLL_THREAD_ATTACH )
                &&  ( ulReasonIn != DLL_THREAD_DETACH ) );
#endif // THREAD_OPTIMIZATIONS

            //
            // This is necessary here because TraceFunc defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after TraceFunc.
            //
            FRETURN( TRUE );

            break;
        } // default case
    } // switch on reason code

    return TRUE;

} //*** GenScriptDllEntryPoint()


//****************************************************************************
//
// Cluster Resource Entry Points
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  void
//  WINAPI
//  ScriptResClose(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
void 
WINAPI 
ScriptResClose(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResClose( residIn = 0x%08x )\n", residIn );

    HRESULT hr;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
    {
        goto Cleanup;
    }

    hr = THR( pres->Close( ) );
    hr = STATUS_TO_RETURN( hr );

    //
    // Matching Release() for object creation in ScriptResOpen( ).
    //

    pres->Release( );

Cleanup:

    TraceFuncExit( );

} //*** ScriptResClose( )

//////////////////////////////////////////////////////////////////////////////
//
//  RESID
//  WINAPI
//  ScriptResOpen(
//      LPCWSTR         pszNameIn,
//      HKEY            hkeyIn,
//      RESOURCE_HANDLE hResourceIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
RESID 
WINAPI 
ScriptResOpen(
    LPCWSTR             pszNameIn,
    HKEY                hkeyIn,
    RESOURCE_HANDLE     hResourceIn
    )
{
    TraceFunc1( "ScriptResOpen( pszNameIn = '%s', hkeyIn, hResourceIn )\n", pszNameIn );

    HRESULT hr;
    CScriptResource * pres;

    pres = CScriptResource_CreateInstance( pszNameIn, hkeyIn, hResourceIn );
    if ( pres == NULL )
    {
        hr = TW32( ERROR_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( pres->Open( ) );
    hr = STATUS_TO_RETURN( hr );

Cleanup:

    //
    // KB:  Don't pres->Release( ) as we are handing it out as out RESID.
    //
    RETURN( pres );

} //*** ScriptResOpen( )

//////////////////////////////////////////////////////////////////////////////
// 
//  DWORD
//  WINAPI
//  ScriptResOnline(
//      RESID   residIn,
//      PHANDLE hEventInout
//      )
//
//////////////////////////////////////////////////////////////////////////////
DWORD 
WINAPI 
ScriptResOnline(
    RESID       residIn,
    PHANDLE     hEventInout
    )
{
    TraceFunc2( "ScriptResOnline( residIn = 0x%08x, hEventInout = 0x%08x )\n",
                residIn, hEventInout );

    HRESULT hr;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
    {
        hr = THR( E_INVALIDARG ); // TODO: Replace with Win32 error code
        goto Cleanup;
    }

    hr = THR( pres->Online( ) );
    hr = STATUS_TO_RETURN( hr );

Cleanup:

    RETURN( hr );

} //*** ScriptResOnline( )

//////////////////////////////////////////////////////////////////////////////
//
//  DWORD
//  WINAPI
//  ScriptResOffline(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
DWORD 
WINAPI 
ScriptResOffline(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResOffline( residIn = 0x%08x )\n", residIn );

    HRESULT hr;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
    {
        hr = THR( E_INVALIDARG ); // TODO: Replace with Win32 error code
        goto Cleanup;
    }

    hr = THR( pres->Offline( ) );
    hr = STATUS_TO_RETURN( hr );

Cleanup:

    RETURN( hr );

} //*** ScriptResOffline( )

//////////////////////////////////////////////////////////////////////////////
//
//  void
//  WINAPI
//  ScriptResTerminate(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
void 
WINAPI 
ScriptResTerminate(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResTerminate( residIn = 0x%08x )\n", residIn );

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
    {
        THR( E_INVALIDARG ); // TODO: Replace with Win32 error code
        goto Cleanup;
    }

    THR( pres->Terminate( ) );

Cleanup:

    TraceFuncExit( );

} // ScriptResTerminate( )

//////////////////////////////////////////////////////////////////////////////
//
//  BOOL
//  WINAPI
//  ScriptResLooksAlive(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
BOOL 
WINAPI 
ScriptResLooksAlive(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResLooksAlive( residIn = 0x%08x )\n", residIn );

    HRESULT hr;
    BOOL    fLooksAlive = FALSE;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
    {
        hr = THR( E_INVALIDARG ); // TODO: Replace with Win32 error code
        goto Cleanup;
    }

    hr = STHR( pres->LooksAlive( ) );
    if ( hr == S_OK )
    {
        fLooksAlive = TRUE;
    } // if: S_OK
    hr = STATUS_TO_RETURN( hr );

Cleanup:

    RETURN( fLooksAlive );

} //*** ScriptResLooksAlive( )

//////////////////////////////////////////////////////////////////////////////
//
//  BOOL
//  WINAPI
//  ScriptResIsAlive(
//      RESID   residIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
BOOL 
WINAPI 
ScriptResIsAlive(
    RESID residIn
    )
{
    TraceFunc1( "ScriptResIsAlive( residIn = 0x%08x )\n", residIn );

    HRESULT hr;
    BOOL    fIsAlive = FALSE;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );

    if ( pres == NULL )
    {
        hr = THR( E_INVALIDARG ); // TODO: Replace with Win32 error code
        goto Cleanup;
    }

    hr = STHR( pres->IsAlive( ) );
    if ( hr == S_OK )
    {
        fIsAlive = TRUE;
    } // if: S_OK
    hr = STATUS_TO_RETURN( hr );

Cleanup:

    RETURN( fIsAlive );

} //*** ScriptResIsAlive( )


//////////////////////////////////////////////////////////////////////////////
//
// DWORD
// ScriptResResourceControl(
//     RESID residIn,
//     DWORD dwControlCodeIn,
//     PVOID pvBufferIn,
//     DWORD dwBufferInSizeIn,
//     PVOID pvBufferOut,
//     DWORD dwBufferOutSizeIn,
//     LPDWORD pdwBytesReturnedOut
//     )
//
//////////////////////////////////////////////////////////////////////////////
DWORD
ScriptResResourceControl(
    RESID residIn,
    DWORD dwControlCodeIn,
    PVOID pvBufferIn,
    DWORD dwBufferInSizeIn,
    PVOID pvBufferOut,
    DWORD dwBufferOutSizeIn,
    LPDWORD pdwBytesReturnedOut
    )
{
    TraceFunc( "ScriptResResourceControl( ... )\n " );

    DWORD               scErr = ERROR_SUCCESS;
    DWORD               dwBytesRequired = 0;
    DWORD               dwPendingTimeout = 0;
    GENSCRIPT_PROPS     propsNew;
    GENSCRIPT_PROPS     propsCurrent;

    *pdwBytesReturnedOut = 0;

    CScriptResource * pres = reinterpret_cast< CScriptResource * >( residIn );
    if ( pres == NULL )
    {
        scErr = (DWORD) THR( E_INVALIDARG );
        goto Cleanup;
    }

    switch ( dwControlCodeIn )
    {
        case CLUSCTL_RESOURCE_UNKNOWN:
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            scErr = TW32( ResUtilGetPropertyFormats(
                                              GenScriptResourcePrivateProperties
                                            , pvBufferOut
                                            , dwBufferOutSizeIn
                                            , pdwBytesReturnedOut
                                            , &dwBytesRequired
                                            ) );
            if ( scErr == ERROR_MORE_DATA )
            {
                *pdwBytesReturnedOut = dwBytesRequired;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            scErr = TW32( ResUtilGetAllProperties( 
                                  pres->GetRegistryParametersKey()
                                , GenScriptResourcePrivateProperties
                                , pvBufferOut
                                , dwBufferOutSizeIn
                                , pdwBytesReturnedOut
                                , &dwBytesRequired
                                ) );
            if ( scErr == ERROR_MORE_DATA )
            {
                *pdwBytesReturnedOut = dwBytesRequired;
            }
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            scErr= TW32( ScriptValidateResourcePrivateProperties(
                                  pres
                                , pvBufferIn
                                , dwBufferInSizeIn
                                , &propsCurrent
                                , &propsNew
                                ) );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            scErr= TW32( ScriptValidateResourcePrivateProperties(
                                  pres
                                , pvBufferIn
                                , dwBufferInSizeIn
                                , &propsCurrent
                                , &propsNew
                                ) );
            if ( scErr != ERROR_SUCCESS )
            {
                goto Cleanup;
            }
            scErr = pres->SetPrivateProperties( &propsNew );
            break;

        case CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES:
            //
            // Find the resource pending timeout in the property list.
            //
            scErr = ResUtilFindDwordProperty(
                              pvBufferIn
                            , dwBufferInSizeIn
                            , CLUSREG_NAME_RES_PENDING_TIMEOUT
                            , &dwPendingTimeout
                            );
            if ( scErr == ERROR_SUCCESS )
            {
                //
                // Pending timeout period was changed.
                //
                pres->SetResourcePendingTimeoutChanged( TRUE );
            }
            scErr = ERROR_INVALID_FUNCTION;
            break;

        default:
            scErr = ERROR_INVALID_FUNCTION;
            break;
    } // switch: on control code

Cleanup:

    RETURN( scErr );

} //*** ScriptResResourceControl


//////////////////////////////////////////////////////////////////////////////
//
// DWORD
// ScriptResTypeControl(
//    LPCWSTR ResourceTypeName,
//    DWORD dwControlCodeIn,
//    PVOID pvBufferIn,
//    DWORD dwBufferInSizeIn,
//    PVOID pvBufferOut,
//    DWORD dwBufferOutSizeIn,
//    LPDWORD pdwBytesReturnedOut
//     )
//
//////////////////////////////////////////////////////////////////////////////
DWORD
ScriptResTypeControl(
    LPCWSTR ResourceTypeName,
    DWORD dwControlCodeIn,
    PVOID pvBufferIn,
    DWORD dwBufferInSizeIn,
    PVOID pvBufferOut,
    DWORD dwBufferOutSizeIn,
    LPDWORD pdwBytesReturnedOut
    )
{
    TraceFunc( "ScriptResTypeControl( ... )\n " );

    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwBytesRequired;

    *pdwBytesReturnedOut = 0;

    switch ( dwControlCodeIn )
    {
    case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
        break;

    case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
        dwErr = ResUtilGetPropertyFormats( GenScriptResourcePrivateProperties,
                                           pvBufferOut,
                                           dwBufferOutSizeIn,
                                           pdwBytesReturnedOut,
                                           &dwBytesRequired );
        if ( dwErr == ERROR_MORE_DATA ) {
            *pdwBytesReturnedOut = dwBytesRequired;
        }
        break;

    default:
        dwErr = ERROR_INVALID_FUNCTION;
        break;
    }

    RETURN( dwErr );

} //*** ScriptResTypeControl( )

//////////////////////////////////////////////////////////////////////////////
//
// DWORD
// ScriptValidateResourcePrivateProperties(
//      CScriptResource * pres
//    , PVOID pvBufferIn
//    , DWORD dwBufferInSizeIn
//    , PGENSCRIPT_PROPS pPropsCurrent
//    , PGENSCRIPT_PROPS pPropsNew
//    )
//
//////////////////////////////////////////////////////////////////////////////
DWORD 
ScriptValidateResourcePrivateProperties(
      CScriptResource * pres
    , PVOID pvBufferIn
    , DWORD dwBufferInSizeIn
    , PGENSCRIPT_PROPS pPropsCurrent
    , PGENSCRIPT_PROPS pPropsNew
    )
{
    DWORD   scErr = ERROR_SUCCESS;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    LPWSTR  pszNameOfPropInError;
    LPWSTR  pszFilePath = NULL;

    //
    // Check if there is input data.
    //
    if ( ( pvBufferIn == NULL ) || ( dwBufferInSizeIn < sizeof( DWORD ) ) )
    {
        scErr = ERROR_INVALID_DATA;
        goto Cleanup;
    } // if: no input buffer or input buffer not big enough to contain property list

    //
    // Retrieve the current set of private properties from the
    // cluster database.
    //
    ZeroMemory( pPropsCurrent, sizeof( *pPropsCurrent ) );
    scErr = TW32( ResUtilGetPropertiesToParameterBlock(
                          pres->GetRegistryParametersKey()
                        , GenScriptResourcePrivateProperties
                        , reinterpret_cast< LPBYTE >( pPropsCurrent )
                        , FALSE // CheckForRequiredProperties
                        , &pszNameOfPropInError
                        ) );
    if ( scErr != ERROR_SUCCESS )
    {
        (ClusResLogEvent)(
                  pres->GetResourceHandle()
                , LOG_ERROR
                , L"ValidatePrivateProperties: Unable to read the '%1!ws!' property. Error: %2!u! (%2!#08x!).\n"
                , (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError)
                , scErr
                );
        goto Cleanup;
    } // if: error getting properties

    ZeroMemory( pPropsNew, sizeof( *pPropsNew ) );
    scErr = TW32( ResUtilDupParameterBlock(
                          reinterpret_cast< LPBYTE >( pPropsNew )
                        , reinterpret_cast< LPBYTE >( pPropsCurrent )
                        , GenScriptResourcePrivateProperties
                        ) );
    if ( scErr != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error duplicating the parameter block

    //
    // Parse and validate the properties.
    //
    scErr = TW32( ResUtilVerifyPropertyTable(
                          GenScriptResourcePrivateProperties
                        , NULL
                        , TRUE  // AllowUnknownProperties
                        , pvBufferIn
                        , dwBufferInSizeIn
                        , reinterpret_cast< LPBYTE >( pPropsNew )
                        ) );
    if ( scErr != ERROR_SUCCESS )
    {
        goto Cleanup;
    } // if: error parsing the property table.

    //
    // If the new script file path is NULL: i.e. the case where /usedefault
    // switch is used to set ScriptFilePath property using cluster.exe.
    // Or if an empty string specified for the ScriptFilePath property.
    //
    if ( ( pPropsNew->pszScriptFilePath == NULL ) || ( *pPropsNew->pszScriptFilePath == L'\0' ) )
    {
        scErr = TW32( ERROR_INVALID_PARAMETER );
        goto Cleanup;            
    } // if: the new ScriptFilePath is NULL, or it is an empty string.

    //
    // Expand the new script file path.
    //
    pszFilePath = ClRtlExpandEnvironmentStrings( pPropsNew->pszScriptFilePath );
    if ( pszFilePath == NULL )
    {
        scErr = TW32( ERROR_OUTOFMEMORY );
        goto Cleanup;
    } // if: ( pszFilePath == NULL )

    //
    // Open the script file.
    //
    hFile = CreateFile(
                      pszFilePath
                    , GENERIC_READ
                    , FILE_SHARE_READ
                    , NULL
                    , OPEN_EXISTING
                    , 0
                    , NULL
                    );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        scErr = TW32( GetLastError() );
        (ClusResLogEvent)( 
                  pres->GetResourceHandle()
                , LOG_ERROR
                , L"Error opening script '%1!ws!'. SCODE: 0x%2!08x!\n"
                , pPropsNew->pszScriptFilePath
                , scErr
                );
        goto Cleanup;
    } // if: failed to open

Cleanup:

    LocalFree( pszFilePath );
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    } // if: hFile

    return scErr;
    
} //*** ScriptValidateResourcePrivateProperties

//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( GenScriptFunctionTable,    // Name
                         CLRES_VERSION_V1_00,       // Version
                         ScriptRes,                 // Prefix
                         NULL,                      // Arbitrate
                         NULL,                      // Release
                         ScriptResResourceControl,  // ResControl
                         ScriptResTypeControl       // ResTypeControl
                         );

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\activescriptsite.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      ActiveScriptSite.h
//
//  Description:
//      CActiveScriptSite class header file.
//
//  Maintained By:
//      gpease 14-DEC-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CActiveScriptSite :
    public IActiveScriptSite,
    public IActiveScriptSiteInterruptPoll,
    public IActiveScriptSiteWindow,
    public IDispatchEx
{
private:
    LONG m_cRef;

    RESOURCE_HANDLE     m_hResource;        
    PLOG_EVENT_ROUTINE  m_pler;
    HKEY                m_hkey;
    IUnknown *          m_punkResource;
    LPCWSTR             m_pszName;      // DONT'T FREE

private:
    STDMETHOD(LogError)( HRESULT hrIn );

public:
    explicit CActiveScriptSite( RESOURCE_HANDLE     hResourceIn,
                                PLOG_EVENT_ROUTINE  plerIn,
                                HKEY                hkeyIn,
                                LPCWSTR             pszName
                                );
    virtual ~CActiveScriptSite();

    // IUnknown
    STDMETHOD( QueryInterface )(
        REFIID riid,
        void ** ppUnk );
    STDMETHOD_(ULONG, AddRef )( );
    STDMETHOD_(ULONG, Release )( );

    // IActiveScriptSite
    STDMETHOD( GetLCID )( 
            /* [out] */ LCID __RPC_FAR *plcid );
        
    STDMETHOD( GetItemInfo )( 
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwReturnMask,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti );
        
    STDMETHOD( GetDocVersionString )( 
            /* [out] */ BSTR __RPC_FAR *pbstrVersion );
        
    STDMETHOD( OnScriptTerminate )( 
            /* [in] */ const VARIANT __RPC_FAR *pvarResult,
            /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo );
        
    STDMETHOD( OnStateChange )( 
            /* [in] */ SCRIPTSTATE ssScriptState );
        
    STDMETHOD( OnScriptError )( 
            /* [in] */ IActiveScriptError __RPC_FAR *pscripterror );
        
    STDMETHOD( OnEnterScript )( void );
        
    STDMETHOD( OnLeaveScript )( void );

    // IActiveScriptSiteInterruptPoll 
    STDMETHOD( QueryContinue )( void );

    // IActiveScriptSiteWindow
    STDMETHOD( GetWindow )( 
            /* [out] */ HWND __RPC_FAR *phwnd );        
    STDMETHOD( EnableModeless)( 
            /* [in] */ BOOL fEnable );

    // IDispatch
    STDMETHOD( GetTypeInfoCount )( 
            /* [out] */ UINT __RPC_FAR *pctinfo );        
    STDMETHOD( GetTypeInfo )( 
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo );        
    STDMETHOD( GetIDsOfNames )( 
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId );        
    STDMETHOD( Invoke )( 
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr );
 
    // IDispatchEx
    STDMETHOD( GetDispID )( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid );        
    STDMETHOD( InvokeEx )( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller );        
    STDMETHOD( DeleteMemberByName )( 
            /* [in] */ BSTR bstr,
            /* [in] */ DWORD grfdex );        
    STDMETHOD( DeleteMemberByDispID )( 
            /* [in] */ DISPID id );        
    STDMETHOD( GetMemberProperties )( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex );        
    STDMETHOD( GetMemberName )( 
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName );        
    STDMETHOD( GetNextDispID )( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid );        
    STDMETHOD( GetNameSpaceParent )( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\resourceobject.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2003 Microsoft Corporation
//
//  Module Name:
//      ResourceObject.cpp
//
//  Description:
//      CResourceObject automation class implementation.
//
//  Maintained By:
//      Ozan Ozhan  (OzanO)     27-MAR-2002
//      Geoff Pease (GPease)    08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ResourceObject.h"

DEFINE_THISCLASS( "CResourceObject" );
#define STATIC_AUTOMATION_METHODS 5

//////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
//////////////////////////////////////////////////////////////////////////////
CResourceObject::CResourceObject(
    RESOURCE_HANDLE     hResourceIn,
    PLOG_EVENT_ROUTINE  plerIn,
    HKEY                hkeyIn,
    LPCWSTR             pszNameIn
    ) :
    m_hResource( hResourceIn ),
    m_pler( plerIn ),
    m_hkey( hkeyIn ),
    m_pszName( pszNameIn )
{
    TraceFunc( "" );

    Assert( m_cRef == 0 );

    AddRef();

    TraceFuncExit();

} //*** CRsesourceObject::CResourceObject

//////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
//////////////////////////////////////////////////////////////////////////////
CResourceObject::~CResourceObject( void )
{
    TraceFunc( "" );

    // Don't free m_pszName.
    // Don't close m_hkey.

    TraceFuncExit();

} //*** CResourceObject::~CResourceObject


//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CScriptResource::[IUnknown] QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::QueryInterface( 
      REFIID    riidIn
    , void **   ppvOut 
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    *ppvOut = NULL;

    if ( riidIn == IID_IUnknown )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IUnknown, (IDispatchEx*) this, 0 );
        hr = S_OK;
    }
    else if ( riidIn == IID_IDispatchEx )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDispatchEx, (IDispatchEx*) this, 0 );
        hr = S_OK;
    }
    else if ( riidIn == IID_IDispatch )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IDispatch, (IDispatchEx*) this, 0 );
        hr = S_OK;
    }
    else
    {
        *ppvOut = NULL;
        hr = E_NOINTERFACE;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    }

    QIRETURN( hr, riidIn );

} //*** CResourceObject::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) 
CResourceObject::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    CRETURN( m_cRef );

} //*** CResourceObject::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) 
CResourceObject::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    }

    CRETURN( cRef );

} //*** CResourceObject::Release


//****************************************************************************
//
//  IDispatch
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetTypeInfoCount(
//      UINT * pctinfo // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetTypeInfoCount(
    UINT * pctinfo // out
    )
{
    TraceFunc( "[IDispatch]" );

    HRESULT hr = E_NOTIMPL;

    if ( pctinfo == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pctinfo = 0;

Cleanup:

    HRETURN( hr );

} //*** CResourceObject::GetTypeInfoCount

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetTypeInfo(
//      UINT iTInfo,            // in
//      LCID lcid,              // in
//      ITypeInfo * * ppTInfo   // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetTypeInfo(
      UINT          iTInfo  // in
    , LCID          lcid    // in
    , ITypeInfo **  ppTInfo // out
    )
{
    TraceFunc( "[IDispatch]" );

    HRESULT hr = E_NOTIMPL;

    if ( ppTInfo == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *ppTInfo = NULL;

Cleanup:

    HRETURN( hr );

} //*** CResourceObject::GetTypeInfo

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetIDsOfNames(
//      REFIID      riid,       // in
//      LPOLESTR *  rgszNames,  // in
//      UINT        cNames,     // in
//      LCID        lcid,       // in
//      DISPID *    rgDispId    // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetIDsOfNames(
      REFIID        riid        // in
    , LPOLESTR *    rgszNames   // in
    , UINT          cNames      // in
    , LCID          lcid        // in
    , DISPID *      rgDispId    // out
    )
{
    TraceFunc( "[IDispatch]" );

    HRESULT hr = E_NOTIMPL;

    ZeroMemory( rgDispId, cNames * sizeof(DISPID) );

    HRETURN( hr );

} //*** CResourceObject::GetIDsOfNames

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::Invoke(
//      DISPID dispIdMember,        // in
//      REFIID riid,                // in
//      LCID lcid,                  // in
//      WORD wFlags,                // in
//      DISPPARAMS *pDispParams,    // out in
//      VARIANT *pVarResult,        // out
//      EXCEPINFO *pExcepInfo,      // out
//      UINT *puArgErr              // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::Invoke(
      DISPID        dispIdMember    // in
    , REFIID        riid            // in
    , LCID          lcid            // in
    , WORD          wFlags          // in
    , DISPPARAMS *  pDispParams     // out in
    , VARIANT *     pVarResult      // out
    , EXCEPINFO *   pExcepInfo      // out
    , UINT *        puArgErr        // out
    )
{
    TraceFunc( "[IDispatch]" );
    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CResourceObject::Invoke


//****************************************************************************
//
//  IDispatchEx
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetDispID(
//      BSTR bstrName,  // in
//      DWORD grfdex,   //in
//      DISPID *pid     //out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetDispID(
      BSTR      bstrName    // in
    , DWORD     grfdex      // in
    , DISPID *  pid         // out
    )
{
    TraceFunc( "[IDispatchEx]" );

    HRESULT hr = S_OK;

    if ( ( pid == NULL ) || ( bstrName == NULL ) )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    TraceMsg( mtfCALLS, "Looking for: %s\n", bstrName );

    if ( ClRtlStrICmp( bstrName, L"Name" ) == 0 )
    {
        *pid = 0;
    }
    else if ( ClRtlStrICmp( bstrName, L"LogInformation" ) == 0 )
    {
        *pid = 1;
    }
    else if ( ClRtlStrICmp( bstrName, L"AddProperty" ) == 0 )
    {
        *pid = 2;
    }
    else if ( ClRtlStrICmp( bstrName, L"RemoveProperty" ) == 0 )
    {
        *pid = 3;
    }
    else if ( ClRtlStrICmp( bstrName, L"PropertyExists" ) == 0 )
    {
        *pid = 4;
    }
    else
    {
        //
        //  See if it is a private property.
        //

        DWORD dwIndex;
        DWORD scErr = ERROR_SUCCESS;

        hr = DISP_E_UNKNOWNNAME;

        //
        // Enum all the value under the \Cluster\Resources\{Resource}\Parameters.
        //
        for( dwIndex = 0; scErr == ERROR_SUCCESS; dwIndex ++ )
        {
            WCHAR szName[ 1024 ];   // randomly large
            DWORD cbName = sizeof(szName)/sizeof(szName[0]);

            scErr = ClusterRegEnumValue( m_hkey, 
                                         dwIndex,
                                         szName,
                                         &cbName,
                                         NULL,
                                         NULL,
                                         NULL
                                         );
            if ( scErr == ERROR_NO_MORE_ITEMS )
                break;  // done!

            if ( scErr != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( scErr ) );
                goto Error;
            }

            if ( ClRtlStrICmp( bstrName, szName ) == 0 )
            {
                //
                //  Found a match.
                //
                *pid = STATIC_AUTOMATION_METHODS + dwIndex;
                hr   = S_OK;
                break;
            }

            //
            // ...else keep going.
            //
        }
    }

Cleanup:

    HRETURN( hr );

Error:
    LogError( hr );
    goto Cleanup;

} //*** CResourceObject::GetDiskID

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::InvokeEx(
//      DISPID             idIn,
//      LCID               lcidIn,
//      WORD               wFlagsIn,
//      DISPPARAMS *       pdpIn,
//      VARIANT *          pvarResOut,
//      EXCEPINFO *        peiOut,
//      IServiceProvider * pspCallerIn
//      )
//      
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::InvokeEx(
      DISPID                idIn
    , LCID                  lcidIn
    , WORD                  wFlagsIn
    , DISPPARAMS *          pdpIn
    , VARIANT *             pvarResOut
    , EXCEPINFO *           peiOut
    , IServiceProvider *    pspCallerIn
    )
{
    TraceFunc2( "[IDispatchEx] idIn = %u, ..., wFlagsIn = 0x%08x, ...", idIn, wFlagsIn );

    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    switch ( idIn )
    {
        case 0: // Name
            if ( wFlagsIn & DISPATCH_PROPERTYGET )
            {
                pvarResOut->vt = VT_BSTR;
                pvarResOut->bstrVal = SysAllocString( m_pszName );
                if ( pvarResOut->bstrVal == NULL )
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = S_OK;
                }
            }
            break;

        case 1: // LogInformation
            if ( wFlagsIn & DISPATCH_METHOD )
            {
                hr = THR( LogInformation( pdpIn->rgvarg->bstrVal ) );
            }
            break;

        case 2: // AddProperty
            if ( wFlagsIn & DISPATCH_METHOD )
            {
                hr = THR( AddPrivateProperty( pdpIn ) );
            }
            break;

        case 3: // RemoveProperty
            if ( wFlagsIn & DISPATCH_METHOD )
            {
                hr = THR( RemovePrivateProperty( pdpIn ) );
            }
            break;

        case 4: // PropertyExists
            if ( wFlagsIn & DISPATCH_METHOD )
            {
                pvarResOut->vt = VT_BOOL;
                hr = THR( PrivatePropertyExists( pdpIn ) );
                //
                // Property exists if hr is S_OK
                //
                if ( hr == S_OK ) 
                {
                    pvarResOut->boolVal = VARIANT_TRUE;
                }
                else if ( hr == S_FALSE )
                {
                    hr = S_OK; // Set hr to S_OK since there's no failure at all
                    pvarResOut->boolVal = VARIANT_FALSE;
                }
            } // if: ( wFlagsIn & DISPATCH_METHOD )
            break;

        default:
            //
            //  See if it is a private property.
            //
            if ( wFlagsIn & DISPATCH_PROPERTYGET )
            {
                hr = THR( ReadPrivateProperty( idIn - STATIC_AUTOMATION_METHODS, pvarResOut ) );
            }
            else if ( wFlagsIn & DISPATCH_PROPERTYPUT )
            {
                hr = THR( WritePrivateProperty( idIn - STATIC_AUTOMATION_METHODS, pdpIn ) );
            }
            break;

    } // switch: id

    HRETURN( hr );

} //*** CResourceObject::InvokeEx

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::DeleteMemberByName(
//      BSTR bstr,   // in
//      DWORD grfdex // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::DeleteMemberByName(
      BSTR  bstr    // in
    , DWORD grfdex  // in
    )
{
    TraceFunc( "[IDispatchEx]" );
    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CResourceObject::DeleteMemberByName

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::DeleteMemberByDispID(
//      DISPID id   // in
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::DeleteMemberByDispID(
    DISPID id   // in
    )
{
    TraceFunc1( "[IDispatchEx] id = %u", id );
    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CResourceObject::DeleteMemberByDispID

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetMemberProperties(
//      DISPID id,          // in
//      DWORD grfdexFetch,  // in
//      DWORD * pgrfdex     // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetMemberProperties(
      DISPID    id          // in
    , DWORD     grfdexFetch // in
    , DWORD *   pgrfdex     // out
    )
{
    TraceFunc2( "[IDispatchEx] id = %u, grfdexFetch = 0x%08x", id, grfdexFetch );
    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CResourceObject::GetMemberProperties

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetMemberName(
//      DISPID id,          // in
//      BSTR * pbstrName    // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetMemberName(
      DISPID    id          // in
    , BSTR *    pbstrName   // out
    )
{
    TraceFunc1( "[IDispatchEx] id = %u, ...", id );
    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CResourceObject::GetMemberName

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetNextDispID(
//      DWORD grfdex,  // in
//      DISPID id,     // in
//      DISPID * pid   // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetNextDispID(
      DWORD     grfdex  // in
    , DISPID    id      // in
    , DISPID *  pid     // out
    )
{
    TraceFunc2( "[IDispatchEx] grfdex = 0x%08x, id = %u, ...", grfdex, id );
    HRESULT hr = E_NOTIMPL;

    HRETURN( hr );

} //*** CResourceObject::GetNextDiskID

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::GetNameSpaceParent(
//      IUnknown * * ppunk  // out
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::GetNameSpaceParent(
    IUnknown ** ppunk  // out
    )
{
    TraceFunc( "[IDispatchEx]" );

    HRESULT hr = E_NOTIMPL;

    if ( ppunk == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *ppunk = NULL;

Cleanup:

    HRETURN( hr );

} //*** CResourceObject::GetNameSpaceParent


//****************************************************************************
//
// Private Methods
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::LogError(
//      HRESULT hrIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::LogError(
    HRESULT hrIn
    )
{
    TraceFunc1( "hrIn = 0x%08x", hrIn );
    HRESULT hr = S_OK;

    TraceMsg( mtfCALLS, "HRESULT: 0x%08x\n", hrIn );
    (ClusResLogEvent)( m_hResource, LOG_ERROR, L"HRESULT: 0x%1!08x!.\n", hrIn );

    HRETURN( hr );

} //*** CResourceObject::LogError

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::ReadPrivateProperty(
//      DISPID      idIn,
//      VARIANT *   pvarResOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::ReadPrivateProperty(
      DISPID    idIn
    , VARIANT * pvarResOut
    )
{
    TraceFunc( "" );

    BSTR *  pbstrList;

    BYTE    rgbData[ 1024 ];    // randomly large
    WCHAR   szName[ 1024 ];     // randomly large
    DWORD   dwType;
    DWORD   scErr;

    DWORD   cbName = sizeof(szName)/sizeof(szName[0]);
    DWORD   cbData = sizeof(rgbData);
    BOOL    fFreepData = FALSE;
    LPBYTE  pData = NULL;
    
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    //  We can jump to the exact entry because the script called 
    //  GetDispID() before calling this method. 
    //
    for ( ;; )
    {
        scErr = ClusterRegEnumValue(
                          m_hkey
                        , idIn
                        , szName
                        , &cbName
                        , &dwType
                        , rgbData
                        , &cbData
                        );
        if ( scErr == ERROR_MORE_DATA )
        {
            //
            //  Make some space if our stack buffer is too small.
            //
            pData = (LPBYTE) TraceAlloc( LMEM_FIXED, cbData );
            if ( pData == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }

            fFreepData = TRUE;

            continue;   // try again
        }

        if ( scErr == ERROR_NO_MORE_ITEMS )
        {
            goto Cleanup;   // item must have dissappeared
        }

        if ( scErr != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( scErr ) );
            goto Error;
        }

        Assert( scErr == ERROR_SUCCESS );
        break;  // exit loop
    } // for ever enumerating registry values

    //
    //  It's a private property. Convert the data into the appropriate
    //  VARIANT.
    //

    switch ( dwType )
    {
        case REG_DWORD:
        {
            DWORD * pdw = (DWORD *) rgbData;

            pvarResOut->vt = VT_I4;
            pvarResOut->intVal = *pdw;
            hr = S_OK;
        }
        break;

        case REG_EXPAND_SZ:
        {
            DWORD   cbNeeded;
            WCHAR   szExpandedString[ 2 * MAX_PATH ]; // randomly large
            DWORD   cbSize = RTL_NUMBER_OF( szExpandedString );
            LPCWSTR pszData = (LPCWSTR) rgbData;

            cbNeeded = ExpandEnvironmentStringsW( pszData, szExpandedString, cbSize );
            if ( cbSize == 0 )
            {
                hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                goto Cleanup;
            }

            if ( cbNeeded > cbSize )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }

            pvarResOut->vt = VT_BSTR;
            pvarResOut->bstrVal = SysAllocString( szExpandedString );
            if ( pvarResOut->bstrVal == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }

            hr = S_OK;
        }
        break;

        case REG_MULTI_SZ:
        {
            //
            //  KB: gpease  08-FEB-2000
            //      Currently VBScript doesn't support SAFEARRAYs. So someone
            //      trying to access a multi-sz will get the following error:
            //
            //      Error: 2148139466
            //      Source: Microsoft VBScript runtime error
            //      Description: Variable uses an Automation type not supported in VBScript
            //
            //      The code is correct as far as I can tell, so I am just
            //      going to leave it in (it doesn't AV or cause bad things
            //      to happen).
            //
            LPWSTR psz;
            DWORD  nCount;
            DWORD  cbCount;
            DWORD  cbBiggestOne;

            LPWSTR pszData = (LPWSTR) rgbData;

            SAFEARRAYBOUND rgsabound[ 1 ];

            //
            //  Figure out how many item there are in the list.
            //
            cbBiggestOne = cbCount = nCount = 0;
            psz = pszData;
            while ( *psz != 0 )
            {
                psz++;
                cbCount ++;
                if ( *psz == 0 )
                {
                    if ( cbCount > cbBiggestOne )
                    {
                        cbBiggestOne = cbCount;
                    }
                    cbCount = 0;
                    nCount++;
                    psz++;
                }
            }

            Assert( psz <= ( (LPWSTR) &rgbData[ cbData ] ) );

            //
            //  Create a safe array to package the string into.
            //
            rgsabound[0].lLbound   = 0;
            rgsabound[0].cElements = nCount;
            pvarResOut->vt = VT_SAFEARRAY;
            pvarResOut->parray = SafeArrayCreate( VT_BSTR, 1, rgsabound );
            if ( pvarResOut->parray == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }

            //
            //  Fix the memory location of the array so it can be accessed
            //  thru an array pointer.
            //
            hr = THR( SafeArrayAccessData( pvarResOut->parray, (void**) &pbstrList ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            //
            //  Convert the multi-string into BSTRs
            //
            psz = pszData;
            for( nCount = 0; *psz != 0 ; nCount ++ )
            {
                pbstrList[ nCount ] = SysAllocString( psz );
                if ( pbstrList[ nCount ] == NULL )
                {
                    hr = THR( E_OUTOFMEMORY );
                    goto Cleanup;
                }
                
                //
                //  Skip the next entry.
                //
                while ( *psz != 0 )
                {
                    psz++;
                }
                psz++;
            }

            Assert( psz <= ( (LPWSTR) &rgbData[ cbData ] ) );

            //
            //  Release the array.
            //
            hr = THR( SafeArrayUnaccessData( pvarResOut->parray ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            hr = S_OK;
        }
        break;

        case REG_SZ:
        {
            LPCWSTR pszData = (LPCWSTR) rgbData;
            pvarResOut->bstrVal = SysAllocString( pszData );
            if ( pvarResOut->bstrVal == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Cleanup;
            }

            pvarResOut->vt = VT_BSTR;
            hr = S_OK;
        }
        break;

        case REG_BINARY:
        default:
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATATYPE );
            goto Error;
    } // switch: dwType

Cleanup:

    if ( fFreepData && ( pData != NULL ) )
    {
        TraceFree( pData );
    }

    // 
    // Make sure this has been wiped if there is a problem.
    //
    if ( FAILED( hr ) )
    {
        VariantClear( pvarResOut );
    }

    HRETURN( hr );

Error:

    LogError( hr );
    goto Cleanup;

} //*** CResourceObject::ReadPrivateProperty

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::WritePrivateProperty(
//      DISPID       idIn,
//      DISPPARAMS * pdpIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::WritePrivateProperty(
      DISPID        idIn
    , DISPPARAMS *  pdpIn
    )
{
    TraceFunc( "" );

    DWORD   dwType;
    DWORD   scErr;
    DWORD   cbData;
    UINT    uiArg;

    WCHAR   szName [ 1024 ];    // randomly large

    DWORD   cbName = sizeof(szName)/sizeof(szName[0]);
    
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    //  Do some parameter validation.
    //
    if ( ( pdpIn->cArgs != 1 ) || ( pdpIn->cNamedArgs > 1 ) )
    {
        hr = THR( DISP_E_BADPARAMCOUNT );
        goto Error;
    }

    //
    //  We can jump to the exact entry because the script called 
    //  GetDispID() before calling this method. Here we are only
    //  going to validate that the value exists and what type
    //  the value is.
    //
    scErr = ClusterRegEnumValue( m_hkey, 
                                 idIn,
                                 szName,
                                 &cbName,
                                 &dwType,
                                 NULL,
                                 NULL
                                 );
    if ( scErr == ERROR_NO_MORE_ITEMS )
    {
        goto Cleanup;   // item must have dissappeared
    }

    if ( scErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( scErr ) );
        goto Error;
    }

    //
    //  It's a private property. Convert the script data into the 
    //  appropriate VARIANT and then write it into the hive.
    //
    switch ( dwType )
    {
        case REG_DWORD:
        {
            VARIANT var;

            VariantInit( &var );

            hr = THR( DispGetParam( pdpIn, (UINT) DISPID_PROPERTYPUT, VT_I4, &var, &uiArg ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            cbData = sizeof( var.intVal );
            scErr = TW32( ClusterRegSetValue( m_hkey, szName, dwType, (LPBYTE) &var.intVal, cbData ) );
            if ( scErr != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( scErr );
                goto Error;
            }

            VariantClear( &var );

            hr = S_OK;
        }
        break;

        case REG_EXPAND_SZ:
        case REG_SZ:
        {
            VARIANT var;

            VariantInit( &var );

            hr = THR( DispGetParam( pdpIn, (UINT) DISPID_PROPERTYPUT, VT_BSTR, &var, &uiArg ) );
            if ( FAILED( hr ) )
            {
                goto Error;
            }

            cbData = sizeof(WCHAR) * ( SysStringLen( var.bstrVal ) + 1 );

            scErr = TW32( ClusterRegSetValue( m_hkey, szName, dwType, (LPBYTE) var.bstrVal, cbData ) );
            if ( scErr != ERROR_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( scErr );
                goto Error;
            }

            VariantClear( &var );

            hr = S_OK;
        }
        break;

        case REG_MULTI_SZ:
        case REG_BINARY:
        //
        //  Can't handle these since VBScript can't generate them.
        //
        default:
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATATYPE );
            goto Error;
    } // switch: dwType

Cleanup:

    HRETURN( hr );

Error:

    LogError( hr );
    goto Cleanup;

} //*** CResourceObject::WritePrivateProperty

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::RemovePrivateProperty(
//      DISPPARAMS * pdpIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::RemovePrivateProperty(
    DISPPARAMS * pdpIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   scErr;
    UINT    uiArg;
    VARIANT var;

    VariantInit( &var );

    //
    //  Do some parameter validation.
    //
    if ( pdpIn->cArgs != 1 || pdpIn->cNamedArgs > 1 )
    {
        hr = THR( DISP_E_BADPARAMCOUNT );
        goto Error;
    }

    //
    //  Retrieve the name of the property to remove.
    //
    hr = THR( DispGetParam( pdpIn, 0, VT_BSTR, &var, &uiArg ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Delete the value from the hive.
    //
    scErr = TW32( ClusterRegDeleteValue( m_hkey, var.bstrVal ) );
    if ( scErr == ERROR_FILE_NOT_FOUND )
    {
        hr = THR( DISP_E_UNKNOWNNAME );
        goto Error;
    }
    else if ( scErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    }

    hr = S_OK;

Cleanup:

    VariantClear( &var );

    HRETURN( hr );

Error:

    LogError( hr );
    goto Cleanup;

} //*** CResourceObject::RemovePrivateProperty

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::AddPrivateProperty(
//      DISPPARAMS * pdpIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::AddPrivateProperty(
    DISPPARAMS * pdpIn
    )
{
    TraceFunc( "" );

    DWORD   dwType;
    DWORD   scErr;
    DWORD   cbData;
    UINT    uiArg;

    LPBYTE  pData;

    VARIANT varProperty;
    VARIANT varValue;

    HRESULT hr;

    WCHAR szNULL [] = L"";

    VariantInit( &varProperty );
    VariantInit( &varValue );

    //
    //  Do some parameter validation.
    //
    if ( ( pdpIn->cArgs == 0 )
      || ( pdpIn->cArgs > 2 )
      || ( pdpIn->cNamedArgs > 2 )
       )
    {
        hr = THR( DISP_E_BADPARAMCOUNT );
        goto Error;
    }

    //
    //  Retrieve the name of the property. 
    //
    hr = THR( DispGetParam( pdpIn, 0, VT_BSTR, &varProperty, &uiArg ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  If there are 2 args, the second one indicates the default value.
    //
    if ( pdpIn->cArgs == 2 )
    {
        //
        //  DISPPARAMS are parsed in reverse order so "1" is actually the name 
        //  and "0" is the default value.
        //
        switch ( pdpIn->rgvarg[0].vt )
        {
            case VT_I4:
            case VT_I2:
            case VT_BOOL:
            case VT_UI1:
            case VT_UI2:
            case VT_UI4:
            case VT_INT:
            case VT_UINT:
                hr = THR( DispGetParam( pdpIn, 1, VT_I4, &varValue, &uiArg ) );
                if ( FAILED( hr ) )
                    goto Error;

                dwType = REG_DWORD;
                pData  = (LPBYTE) &varValue.intVal;
                cbData = sizeof(DWORD);
                break;

            case VT_BSTR:
                hr = THR( DispGetParam( pdpIn, 1, VT_BSTR, &varValue, &uiArg ) );
                if ( FAILED( hr ) )
                    goto Error;

                dwType = REG_SZ;
                pData  = (LPBYTE) varValue.bstrVal;
                cbData = sizeof(WCHAR) * ( SysStringLen( varValue.bstrVal ) + 1 );
                break;

            default:
                hr = THR( E_INVALIDARG );
                goto Error;
        } // switch: variant type
    } // if: 2 args specified
    else
    {
        //
        //  Provide a default of a NULL string.
        //
        dwType = REG_SZ;
        pData = (LPBYTE) &szNULL[0];
        cbData = sizeof(szNULL);
    } // else: 2 args not specified

    //
    //  Create the value in the hive.
    //
    scErr = TW32( ClusterRegSetValue( m_hkey, varProperty.bstrVal, dwType, pData, cbData ) );
    if ( scErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    }

    hr = S_OK;

Cleanup:

    VariantClear( &varProperty );
    VariantClear( &varValue );
    HRETURN( hr );

Error:

    LogError( hr );
    goto Cleanup;

}//*** CResourceObject::AddPrivateProperty

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CResourceObject::PrivatePropertyExists(
//      DISPID       idIn,
//      DISPPARAMS * pdpIn
//      )
//
//  Return Value:
//      S_OK        - If the property exists
//      S_FALSE     - If the property does not exist
//      Other       - On failure
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourceObject::PrivatePropertyExists(
    DISPPARAMS *  pdpIn
    )
{
    TraceFunc( "" );

    DWORD   scErr;
    DWORD   cbData;
    UINT    uiArg;
    VARIANT varProperty;
    HRESULT hr = S_OK;

    VariantInit( &varProperty );

    //
    //  Do some parameter validation.
    //
    if ( ( pdpIn->cArgs != 1 ) || ( pdpIn->cNamedArgs > 1 ) )
    {
        hr = THR( DISP_E_BADPARAMCOUNT );
        LogError( hr );
        goto Cleanup;
    }

    //
    //  Retrieve the name of the property. 
    //
    hr = THR( DispGetParam( pdpIn, 0, VT_BSTR, &varProperty, &uiArg ) );
    if ( FAILED( hr ) )
    {
        LogError( hr );
        goto Cleanup;
    }

    //
    // Query the cluster hive for this property.
    //
    scErr = ClusterRegQueryValue( 
                      m_hkey
                    , varProperty.bstrVal
                    , NULL
                    , NULL
                    , &cbData
                    );
    if ( scErr == ERROR_FILE_NOT_FOUND )
    {
        hr = S_FALSE;
        goto Cleanup;   // Property is not in the cluster hive.
    }

    if ( scErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( scErr ) );
        LogError( hr );
        goto Cleanup;
    }
    
Cleanup:

    VariantClear( &varProperty );
    HRETURN( hr );

} //*** CResourceObject::PrivatePropertyExists


//////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP 
//  CResourceObject::LogInformation(
//      BSTR bstrString
//      )
// 
//////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CResourceObject::LogInformation(
    BSTR bstrString
    )
{
    TraceFunc1( "%ws", bstrString );

    TraceMsg( mtfCALLS, "LOG_INFORMATION: %s\n", bstrString );

    m_pler( m_hResource, LOG_INFORMATION, L"%1\n", bstrString );

    HRETURN( S_OK );

} //*** CResourceObject::LogInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2003 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Ozan Ozhan      (OzanO)     08-JAN-2003
//      Geoffrey Pease  (GPease)    15-OCT-1999
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to 
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <dispex.h>
#include <shlwapi.h>
#include <resapi.h>
#include <activscp.h>
#include <activdbg.h>
#include <nserror.h>

// Safe string functions
#include <strsafe.h>
#include <Pragmas.h>
#include <CITracker.h>
#include <Debug.h>
#include <Log.h>
#include <Common.h>
#include <clusudef.h>
#include <clusrtl.h>

#include "clstrcmp.h"
#include "genscript.h"
#define cchGUID_STRING_SIZE (sizeof("{12345678-1234-1234-1234-123456789012}"))

extern "C" {
extern PLOG_EVENT_ROUTINE ClusResLogEvent;
}

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

//
// Generic script resource type private properties.
//
typedef struct GENSCRIPT_PROPS
{
    LPWSTR           pszScriptFilePath;
} GENSCRIPT_PROPS, * PGENSCRIPT_PROPS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\spinlock.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      SpinLock.h
//
//  Description:
//      Spin Lock implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// CSpinLock
class 
CSpinLock
{
private: // Data
    LONG *  m_plLock;           // pointer to the lock
    LONG    m_lSpinCount;       // counts the number of sleeps
    LONG    m_lTimeout;         // count until acquire lock fails
#if DBG==1
    BOOL    m_fAcquired;        // DEBUG: internal state of the lock
    BOOL    m_fAcquiredOnce;    // DEBUG: lock was acquired at least once.
#endif

public: // Methods
    explicit 
        CSpinLock( LONG * plLock, LONG lTimeout ) : 
            m_plLock( plLock ),
            m_lTimeout( lTimeout )
    { 
        Assert( m_lTimeout >= 0 || m_lTimeout == INFINITE );
#if DBG==1
        m_fAcquired     = FALSE;
        m_fAcquiredOnce = FALSE;
#endif
    };

    //
    ~CSpinLock() 
    { 
#if DBG==1
        AssertMsg( m_fAcquired     == FALSE, "Lock was not released!" ); 
        AssertMsg( m_fAcquiredOnce != FALSE, "Lock was never acquired. Why was I needed?" );
#endif
    };

    //////////////////////////////////////////////////////////////////////////
    //
    // HRESULT
    // AcquireLock( void )
    //
    // Description:
    //      Acquires the spin lock. Does not return until the lock is 
    //      acquired.
    //
    // Arguments:
    //      None.
    //
    // Return Values:
    //      S_OK    - Sucess.
    //      HRESULT_FROM_WIN32( ERROR_LOCK_FAILED ) - Lock failed.
    //
    //////////////////////////////////////////////////////////////////////////
    HRESULT
        AcquireLock( void )
    {
        HRESULT hr;
        LONG l = TRUE;

#if DBG==1
        AssertMsg( m_fAcquired == FALSE, "Trying to acquire a lock that it already own. Thread is going to freeze up." );
        m_fAcquiredOnce = TRUE;
#endif

        m_lSpinCount = 0;

        for(;;)
        {
            l = InterlockedCompareExchange( m_plLock, TRUE, FALSE );
            if ( l == FALSE )
            {
                //
                // Lock acquired.
                //
                hr = S_OK;
                break;
            } // if: got lock
            else
            {
                m_lSpinCount++;
                if ( m_lSpinCount > m_lTimeout )
                {
                    AssertMsg( m_lSpinCount >= 0, "This lock doesn't seem to have been released properly." );
                    if ( m_lTimeout != INFINITE )
                    {
                        hr = THR( HRESULT_FROM_WIN32( ERROR_LOCK_FAILED ) );
                        break;

                    } // if: not infinite

                } // if: count exceeded

                //
                // Put a breakpoint here if you think that someone is double
                // locking.
                //
                Sleep( 1 );

            } // if: lock not acquired

        } // for: forever        

#if DBG==1
        m_fAcquired = TRUE;
#endif
        return hr;
    }; // AcquireLock( )

    //////////////////////////////////////////////////////////////////////////
    //
    // HRESULT
    // ReleaseLock( void )
    //
    // Description:
    //      Releases the spin lock. Return immediately.
    //
    // Arguments:
    //      None.
    //
    // Return Values:
    //      S_OK    - Success.
    //
    //////////////////////////////////////////////////////////////////////////
    HRESULT
        ReleaseLock( void )
    {
#if DBG==1
        AssertMsg( m_fAcquired == TRUE, "Releasing a lock that was not owned." );
#endif
        *m_plLock   = FALSE;
#if DBG==1
        m_fAcquired = FALSE;
#endif
        return S_OK;
    }; // ReleaseLock( )

}; // class CSpinLock
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\scriptresource.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2003 Microsoft Corporation
//
//  Module Name:
//      ScriptResource.cpp
//
//  Description:
//      CScriptResource class implementation.
//
//  Maintained By:
//      Ozan Ozhan      (OzanO)     22-MAR-2002
//      David Potter    (DavidP)    14-JUN-2001
//      Geoff Pease     (GPease)    14-DEC-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ActiveScriptSite.h"
#include "ScriptResource.h"
#include "SpinLock.h"

DEFINE_THISCLASS("CScriptResource")

//
// We need this to log to the system event log
//
#define LOG_CURRENT_MODULE LOG_MODULE_GENSCRIPT

//
//  KB:  gpease  08-FEB-2000
//
//  The Generic Scripting Resource uses a separate working thread to do all
//  calls into the Script. This is because the Scripting Host Engines require
//  only the creating thread to call them (remember, scripting is designed
//  to be used in a user mode application where usually the UI thread runs
//  the script). To make this possible, we serialize the threads entering the
//  the script using a user-mode spinlock (m_lockSerialize). We then use two events
//  to signal the "worker thread" (m_EventWait) and to signal when the "worker 
//  thread" has completed the task (m_EventDone).
//
//  LooksAlive is implemented by returning the last result of a LooksAlive. It
//  will start the "worker thread" doing the LooksAlive, but not wait for the
//  thread to return the result. Because of this, all the other threads must
//  make sure that the "Done Event" (m_EventDone) is signalled before writing
//  into the common buffers (m_msg and m_hr).
//

//////////////////////////////////////////////////////////////////////////////
//
//  CScriptResource_CreateInstance
//
//  Description:
//      Creates an intialized instance of CScriptResource.
//
//  Arguments:
//      None.
//
//  Return Values:
//      NULL    - Failure to create or initialize.
//      valid pointer to a CScriptResource.
//
//////////////////////////////////////////////////////////////////////////////
CScriptResource *
CScriptResource_CreateInstance( 
    LPCWSTR pszNameIn, 
    HKEY hkeyIn, 
    RESOURCE_HANDLE hResourceIn
    )
{
    TraceFunc( "" );

    CScriptResource * lpcc = new CScriptResource();
    if ( lpcc != NULL )
    {
        HRESULT hr = THR( lpcc->HrInit( pszNameIn, hkeyIn, hResourceIn ) );
        if ( SUCCEEDED( hr ) )
        {
            RETURN( lpcc );
        } // if: success

        delete lpcc;

    } // if: got object

    RETURN(NULL);

} //*** CScriptResource_CreateInstance

//////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
//////////////////////////////////////////////////////////////////////////////
CScriptResource::CScriptResource( void ) :
    m_dispidOpen(DISPID_UNKNOWN),
    m_dispidClose(DISPID_UNKNOWN),
    m_dispidOnline(DISPID_UNKNOWN),
    m_dispidOffline(DISPID_UNKNOWN),
    m_dispidTerminate(DISPID_UNKNOWN),
    m_dispidLooksAlive(DISPID_UNKNOWN),
    m_dispidIsAlive(DISPID_UNKNOWN),
    m_pszScriptFilePath( NULL ),
    m_pszHangEntryPoint( NULL ),
    m_hScriptFile( INVALID_HANDLE_VALUE ),
    m_fHangDetected( FALSE ),
    m_fPendingTimeoutChanged( TRUE ),
    m_dwPendingTimeout( CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT ),
    m_msgLastExecuted( msgUNKNOWN ),
    m_pProps( NULL )
{
    TraceFunc1( "%s", __THISCLASS__ );
    Assert( m_cRef == 0 );

    Assert( m_pass == NULL );
    Assert( m_pasp == NULL );
    Assert( m_pas == NULL );
    Assert( m_pidm == NULL );

    TraceFuncExit();

} //*** constructor

//////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
//////////////////////////////////////////////////////////////////////////////
CScriptResource::~CScriptResource( void )
{
    TraceFunc( "" );

    HRESULT hr;

    CSpinLock SpinLock( &m_lockSerialize, INFINITE );

    //
    // Make sure no one else has this lock.... else why are we going away?
    //
    hr = SpinLock.AcquireLock();
    Assert( hr == S_OK );

    //
    //  Kill the worker thread.
    //
    if ( m_hThread != NULL )
    {
        //  Tell it to DIE
        m_msg = msgDIE;

        //  Signal the event.
        SetEvent( m_hEventWait );

        //  Wait for it to happen. This shouldn't take long at all.
        WaitForSingleObject( m_hThread, 30000 );    // 30 seconds

        //  Cleanup the handle.
        CloseHandle( m_hThread );
    }

    if ( m_hEventDone != NULL )
    {
        CloseHandle( m_hEventDone );
    }

    if ( m_hEventWait != NULL )
    {
        CloseHandle( m_hEventWait );
    }
    
    LocalFree( m_pszScriptFilePath );
    TraceFree( m_pszName );
    delete [] m_pszHangEntryPoint;

    if ( m_hkeyParams != NULL )
    {
        ClusterRegCloseKey( m_hkeyResource );
    } // if: m_hkeyResource
    
    if ( m_hkeyParams != NULL )
    {
        ClusterRegCloseKey( m_hkeyParams );
    } // if: m_hkeyParams

#if defined(DEBUG)
    //
    // Make the debug build happy. Not needed in RETAIL.
    //
    SpinLock.ReleaseLock();
#endif // defined(DEBUG)

    TraceFuncExit();

} //*** destructor

//////////////////////////////////////////////////////////////////////////////
//
//  CScriptResource::Init
//
//  Description:
//      Initializes the class.
//
//  Arguments:
//      pszNameIn   - Name of resource instance.
//      hkeyIn      - The cluster key root for this resource instance.
//      hResourceIn - The hResource for this instance.
//
//  Return Value:
//      S_OK -
//          Success.
//      HRESULT_FROM_WIN32() error - 
//          if Win32 call failed.
//      E_OUTOFMEMORY - 
//          Out of memory.
//      other HRESULT errors.
//
//////////////////////////////////////////////////////////////////////////////

HRESULT
CScriptResource::HrInit( 
    LPCWSTR             pszNameIn,
    HKEY                hkeyIn,
    RESOURCE_HANDLE     hResourceIn
    )
{
    TraceFunc1( "pszNameIn = '%ws'", pszNameIn );

    HRESULT hr = S_OK;
    DWORD   scErr;

    // IUnknown
    AddRef();

    // Other
    m_hResource = hResourceIn;
    Assert( m_pszName == NULL );
    Assert( m_pszScriptFilePath == NULL );
    Assert( m_pszScriptEngine == NULL );
    Assert( m_hEventWait == NULL );
    Assert( m_hEventDone == NULL );
    Assert( m_lockSerialize == FALSE );

    //
    // Create some event to wait on.
    //

    // Scripting engine thread wait event
    m_hEventWait = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_hEventWait == NULL )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    }

    // Task completion event
    m_hEventDone = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_hEventDone == NULL )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    }

    //
    // Copy the resource name.
    //

    m_pszName = TraceStrDup( pszNameIn );
    if ( m_pszName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    //
    // Save the registry key for this resource in m_kheyResource.
    //
    scErr = TW32( ClusterRegOpenKey( hkeyIn, L"", KEY_ALL_ACCESS, &m_hkeyResource ) );
    if ( scErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    } // if: failed
    
    //
    // Open the parameters key.
    //
    scErr = TW32( ClusterRegOpenKey( hkeyIn, L"Parameters", KEY_ALL_ACCESS, &m_hkeyParams ) );
    if ( scErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    } // if: failed

    //
    // Create the scripting engine thread.
    //

    m_hThread = CreateThread( NULL,
                              0,
                              &S_ThreadProc,
                              this,
                              0,
                              &m_dwThreadId
                              );
    if ( m_hThread == NULL )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    }

Cleanup:
    //
    // All class variable clean up should be done in the destructor.
    //
    HRETURN( hr );

Error:

    LogError( hr, L"HrInit() failed." );
    goto Cleanup;

} //*** CScriptResource::Init

//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      riidIn
//          Id of interface requested.
//
//      ppvOut
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//      E_POINTER
//          ppvOut was NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::QueryInterface(
      REFIID    riidIn
    , LPVOID *  ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = S_OK;

    //
    // Validate arguments.
    //

    Assert( ppvOut != NULL );
    if ( ppvOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    // Handle known interfaces.
    //

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IUnknown, static_cast< IUnknown * >( this ), 0 );
    } // if: IUnknown
    else
    {
        *ppvOut = NULL;
        hr = THR( E_NOINTERFACE );
    } // else

    //
    // Add a reference to the interface if successful.
    //

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppvOut)->AddRef();
    } // if: success

Cleanup:

    QIRETURN( hr, riidIn );

} //*** CScriptResource::QueryInterface

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CScriptResource::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    LONG cRef = InterlockedIncrement( &m_cRef );

    RETURN( cRef );

} //*** CScriptResource::AddRef

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_( ULONG )
//  CScriptResource::[IUnknown] Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CScriptResource::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count decremented to zero

    RETURN( cRef );

} //*** CScriptResource::Release


//****************************************************************************
//
//  Publics
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::Open
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Open( void )
{
    TraceFunc( "" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgOPEN ) );

    // CMCM:+ 19-Dec-2000 commented this out to make the DBG PRINT quiet since we now return ERROR_RETRY
    // HRETURN( hr );
    // DavidP 27-MAR-2002 Reverting the above change.  DBG PRINTs are okay.
    // Besides, it needs to balance out the TraceFunc above.
    // return hr;
    HRETURN( hr );

} //*** CScriptResource::Open

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::Close
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Close( void )
{
    TraceFunc( "" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgCLOSE ) );

    HRETURN( hr );

} //*** CScriptResource::Close

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::Online
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Online( void )
{
    TraceFunc( "" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgONLINE ) );

    HRETURN( hr );

} //*** CScriptResource::Online

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::Offline
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Offline( void )
{
    TraceFunc( "" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgOFFLINE ) );

    HRETURN( hr );

} //*** CScriptResource::Offline

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::Terminate
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::Terminate( void )
{
    TraceFunc( "" );

    HRESULT hr;

    hr = THR( WaitForMessageToComplete( msgTERMINATE ) );

    HRETURN( hr );

} //*** CScriptResource::Terminate

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::LooksAlive
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::LooksAlive( void )
{
    TraceFunc( "" );

    HRESULT hr;
    BOOL    fSuccess;
    DWORD   dw;
    DWORD   scErr;

    CSpinLock SerializeLock( &m_lockSerialize, INFINITE );

    //
    // A potential hang has already been detected in this script. Therefore we
    // will not process any other calls to this script.
    //
    if ( m_fHangDetected == TRUE )
    {
        LogHangMode( msgLOOKSALIVE );
        scErr = TW32( ERROR_TIMEOUT );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Cleanup;
    } // if: ( m_fHangDetected == TRUE )

    if ( m_fPendingTimeoutChanged == TRUE )
    {
        //
        // Read the new pending timeout from the cluster hive.
        //
        m_dwPendingTimeout = DwGetResourcePendingTimeout();
        m_fPendingTimeoutChanged = FALSE;
    } // if: pending timeout has changed.

    //
    //  Acquire the serialization lock.
    //
    hr = THR( SerializeLock.AcquireLock() );
    if ( FAILED( hr ) )
    {
        //
        //  Can't "goto Error" because we didn't acquire the lock.
        //
        LogError( hr, L"LooksAlive() failed to acquire the serialization lock." );
        goto Cleanup;
    }

    //
    //  Wait for the script thread to be "done." 
    //
    dw = WaitForSingleObject( m_hEventDone, m_dwPendingTimeout );
    if ( dw == WAIT_TIMEOUT )
    {
        m_fHangDetected = TRUE;
        hr = HrSetHangEntryPoint();
        if ( FAILED( hr ) )
        {
            goto Error;
        }
        scErr = TW32( ERROR_TIMEOUT );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    } // if: ( dw == WAIT_TIMEOUT )
    else if ( dw != WAIT_OBJECT_0 )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    } // else if: ( dw != WAIT_OBJECT_0 )

    //
    //  Reset the done event to indicate that the thread is not busy.
    //
    fSuccess = ResetEvent( m_hEventDone );
    if ( fSuccess == FALSE )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    }

    //
    //  Store the message in the common memory buffer.
    //
    m_msg = msgLOOKSALIVE;

    //
    //  Signal the script thread to process the message, but don't wait for 
    //  it to complete.
    //
    dw = SetEvent( m_hEventWait );

    if ( m_fLastLooksAlive )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

ReleaseLockAndCleanup:

    SerializeLock.ReleaseLock();

Cleanup:

    HRETURN( hr );

Error:

    LogError( hr, L"LooksAlive() failed." );
    goto ReleaseLockAndCleanup;

} //*** CScriptResource::LooksAlive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::IsAlive
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::IsAlive( void )
{
    TraceFunc( "" );

    HRESULT hr;
    
    hr = THR( WaitForMessageToComplete( msgISALIVE ) );

    HRETURN( hr );

} //*** CScriptResource::IsAlive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::SetPrivateProperties
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control code.
//
//  Arguments:
//      pProps
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CScriptResource::SetPrivateProperties(
      PGENSCRIPT_PROPS pProps
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc = ERROR_SUCCESS;
    
    hr = STHR( WaitForMessageToComplete(
                      msgSETPRIVATEPROPERTIES
                    , pProps
                    ) );

    sc = STATUS_TO_RETURN( hr );
    W32RETURN( sc );

} //*** CScriptResource::SetPrivateProperties

//****************************************************************************
//
//  Privates
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::DwGetResourcePendingTimeout
//
//  Description:
//      Returns the resource pending timeout from the cluster hive. If it can
//      not read this value for some reason, it returns the default resource 
//      pending timeout.
//
//  Return Values:
//     Resource pending timeout.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CScriptResource::DwGetResourcePendingTimeout( void )
{
    DWORD scErr = ERROR_SUCCESS;
    DWORD   dwType;
    DWORD   dwValue = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;
    DWORD   cbSize= sizeof( DWORD );
    
    scErr = ClusterRegQueryValue( m_hkeyResource, CLUSREG_NAME_RES_PENDING_TIMEOUT, &dwType, (LPBYTE) &dwValue, &cbSize );
    if ( scErr != ERROR_SUCCESS )
    {
        if ( scErr != ERROR_FILE_NOT_FOUND )
        {
            //
            // Log an error to the cluster log.
            //
            (ClusResLogEvent)(
                      m_hResource
                    , LOG_ERROR
                    , L"DwGetResourcePendingTimeout: Failed to query the cluster hive for the resource pending time out. SCODE: 0x%1!08x! \n"
                    , scErr
                    );
        }
        dwValue = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;
        goto Cleanup;
    } //if: ( scErr != ERROR_SUCCESS )

    Assert( dwType == REG_DWORD );  

Cleanup:

    return dwValue;
    
} //*** CScriptResource::DwGetResourcePendingTimeout

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::LogHangMode
//
//  Description:
//      Log an error that informs that the incoming request will not be
//      proccessed due to a hang mode.
//
//  Arguments:
//      msgIn   - Incoming request message.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CScriptResource::LogHangMode( EMESSAGE msgIn )
{

    //
    // If the msgIn request is a known user request, let's log an entry to 
    // the system event log.
    //
    if ( ( msgIn > msgUNKNOWN ) && ( msgIn < msgDIE ) )
    {
        //
        // Cluster logging infrastructure can display upto LOGENTRY_BUFFER_SIZE
        // characters. Since our error message text is too long, we'll cut it into two 
        // and display it as two error messages.
        //

        //
        // Log an error to the cluster log.
        //
        (ClusResLogEvent)(
                  m_hResource
                , LOG_ERROR
                , L"Request to perform the %1 operation will not be processed. This is because of a previous failed attempt to execute "
                  L"the %2 entry point in a timely fashion. Please review the script code for this entry point to make sure there is no infinite "
                  L"loop or a hang in it, and then consider increasing the resource pending timeout value if necessary.\n"
                , g_rgpszScriptEntryPointNames[ msgIn ]
                , m_pszHangEntryPoint == NULL ? L"<unknown>" : m_pszHangEntryPoint
                );

        //
        // Log an error to the cluster log.
        //
        (ClusResLogEvent)(
                  m_hResource
                , LOG_ERROR
                , L"In a command shell, run \"cluster res \"%1\" /prop PersistentState=0\" to disable this resource, and then run \"net stop clussvc\" "
                  L"to stop the cluster service. Ensure that any problem in the script code is fixed.  Then run \"net start clussvc\" to start the cluster "
                  L"service. If necessary, ensure that the pending time out is increased before bringing the resource online again.\n"
                , m_pszName
                );

        //
        // Log an error to the system event log.
        //
        ClusterLogEvent3(
                  LOG_CRITICAL
                , LOG_CURRENT_MODULE
                , __FILE__
                , __LINE__
                , RES_GENSCRIPT_HANGMODE
                , 0
                , NULL
                , m_pszName
                , g_rgpszScriptEntryPointNames[ msgIn ]
                , m_pszHangEntryPoint == NULL ? L"<unknown>" : m_pszHangEntryPoint
                );        
    } // if: ( pszEntryPoint != NULL )

} //*** CScriptResource::LogHangMode

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::HrSetHangEntryPoint
//
//  Description:
//      Allocates memory and sets m_pszHangEntryPoint and logs an error
//
//  Return Values:
//      S_OK on success
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::HrSetHangEntryPoint( void )
{
    TraceFunc( "" );
    HRESULT hr = S_OK;
    
    size_t      cch = 0;

    //
    // m_msgLastExecuted is initially set to msgUNKNOWN in the constructor. 
    //
    if ( m_msgLastExecuted != msgUNKNOWN )
    {
        delete [] m_pszHangEntryPoint;
        cch = wcslen( g_rgpszScriptEntryPointNames[ m_msgLastExecuted ] ) + 1;
        m_pszHangEntryPoint = new WCHAR[ cch ];
        if ( m_pszHangEntryPoint == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        } // if: ( m_pszHangEntryPoint == NULL )

        hr = THR( StringCchCopyW( m_pszHangEntryPoint, cch, g_rgpszScriptEntryPointNames[ m_msgLastExecuted ] ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: ( FAILED( hr ) )

        //
        // Cluster logging infrastructure can display upto LOGENTRY_BUFFER_SIZE
        // characters. Since our error message text is too long, we'll cut it into two 
        // and display it as two error messages.
        //
        
        //
        // Log an error to the cluster log.
        //
        (ClusResLogEvent)(
                  m_hResource
                , LOG_ERROR
                , L"%1 entry point did not complete execution in a timely manner. "
                  L"This could be due to an infinite loop or a hang in this entry point, or the pending timeout may be too short for this resource. "
                  L"Please review the script code for this entry point to make sure there is no infinite loop or a hang in it, and then consider "
                  L"increasing the resource pending timeout value if necessary.\n"
                , m_pszHangEntryPoint
                );

        //
        // Log an error to the cluster log.
        //
        (ClusResLogEvent)(
                  m_hResource
                , LOG_ERROR
                , L"In a command shell, run \"cluster res \"%1\" /prop PersistentState=0\" "
                  L"to disable this resource, and then run \"net stop clussvc\" to stop the cluster service. Ensure that any problem in the script code is fixed. "
                  L"Then run \"net start clussvc\" to start the cluster service. If necessary, ensure that the pending time out is increased before bringing the "
                  L"resource online again.\n"
                , m_pszName
                );

        //
        // Log an error to the system event log.
        //
        ClusterLogEvent2(
                  LOG_CRITICAL
                , LOG_CURRENT_MODULE
                , __FILE__
                , __LINE__
                , RES_GENSCRIPT_TIMEOUT
                , 0
                , NULL
                , m_pszName
                , m_pszHangEntryPoint
                );        
    } // if: ( m_msgLastExecuted != msgUNKNOWN )
    else
    {
        (ClusResLogEvent)(
                  m_hResource
                , LOG_ERROR
                , L"HrSetHangEntryPoint: Unsupported entry point. \n"
                );
    } // else:

Cleanup:

    HRETURN( hr );

} //*** CScriptResource::HrSetHangEntryPoint

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::WaitForMessageToComplete
//
//  Description:
//      Send a message to the script thread and wait for it to complete.
//
//  Arguments:
//      msgIn
//      pProps
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::WaitForMessageToComplete(
      EMESSAGE  msgIn
    , PGENSCRIPT_PROPS pProps
    )
{
    TraceFunc( "" );

    HRESULT hr;
    BOOL    fSuccess;
    DWORD   dw;
    DWORD   scErr;

    CSpinLock SerializeLock( &m_lockSerialize, INFINITE );

    //
    // A potential hang has already been detected in this script. Therefore we
    // will not process any other calls to this script.
    //
    if ( m_fHangDetected == TRUE )
    {
        LogHangMode( msgIn );
        scErr = TW32( ERROR_TIMEOUT );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Cleanup;
    } // if: ( m_fHangDetected == TRUE )

    if ( m_fPendingTimeoutChanged == TRUE )
    {
        //
        // Read the new pending timeout from the cluster hive.
        //
        m_dwPendingTimeout = DwGetResourcePendingTimeout();
        m_fPendingTimeoutChanged = FALSE;
    } // if: pending timeout has changed.

    //
    //  Acquire the serialization lock.
    //
    hr = THR( SerializeLock.AcquireLock() );
    if ( FAILED( hr ) )
    {
        //
        //  Can't "goto Error" because we didn't acquire the lock.
        //
        LogError( hr, L"WaitForMessageToComplete() failed to acquire the serialization lock." );
        goto Cleanup;
    }

    //
    //  Wait for the script thread to be "done."
    //
    dw = WaitForSingleObject( m_hEventDone, m_dwPendingTimeout ); 
    if ( dw == WAIT_TIMEOUT )
    {
        m_fHangDetected = TRUE;
        hr = HrSetHangEntryPoint();
        if ( FAILED( hr ) )
        {
            goto Error;
        }
        scErr = TW32( ERROR_TIMEOUT );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    } // if: ( dw == WAIT_TIMEOUT )
    else if ( dw != WAIT_OBJECT_0 )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    } // else if: ( dw != WAIT_OBJECT_0 )

    //
    //  Reset the done event to indicate that the thread is not busy.
    //
    fSuccess = ResetEvent( m_hEventDone );
    if ( fSuccess == FALSE )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    }

    //
    //  Store the message in the common memory buffer.
    //
    m_msg = msgIn;
    m_pProps = pProps;

    //
    //  Signal the script thread to process the message.
    //
    fSuccess = SetEvent( m_hEventWait );
    if ( fSuccess == FALSE )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    }

    //
    //  Wait for the thread to complete.
    //
    dw = WaitForSingleObject( m_hEventDone, m_dwPendingTimeout );
    if ( dw == WAIT_TIMEOUT )
    {
        m_fHangDetected = TRUE;
        hr = HrSetHangEntryPoint();
        if ( FAILED( hr ) )
        {
            goto Error;
        }
        scErr = TW32( ERROR_TIMEOUT );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    } // if: ( dw == WAIT_TIMEOUT )
    else if ( dw != WAIT_OBJECT_0 )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    } // else if: ( dw != WAIT_OBJECT_0 )

    //
    //  Get the result of the task from the common buffer.
    //
    hr = m_hr;

ReleaseLockAndCleanup:

    SerializeLock.ReleaseLock();

Cleanup:

    m_pProps = NULL;
    HRETURN( hr );

Error:

    LogError( hr, L"WaitForMessageToComplete() failed.\n" );
    goto ReleaseLockAndCleanup;

} //*** CScriptResource::WaitForMessageToComplete

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::LogError
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::LogError(
      HRESULT   hrIn
    , LPCWSTR   pszPrefixIn
    )
{
    TraceFunc1( "hrIn = 0x%08x", hrIn );

    Assert( pszPrefixIn != NULL );

    static WCHAR s_szFormat[] = L"HRESULT: 0x%1!08x!\n";
    LPWSTR       pszFormat = NULL;
    size_t       cchAlloc;
    HRESULT      hr = S_OK;

    TraceMsg( mtfCALLS, "%ws failed. HRESULT: 0x%08x\n", m_pszName, hrIn );

    cchAlloc = RTL_NUMBER_OF( s_szFormat ) + wcslen( pszPrefixIn );
    pszFormat = new WCHAR[ cchAlloc ];
    if ( pszFormat == NULL )
    {
        THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( StringCchPrintfW( pszFormat, cchAlloc, L"%ws %ws", pszPrefixIn, s_szFormat ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: StringCchPrintfW failed.
    
    (ClusResLogEvent)( m_hResource, LOG_ERROR, pszFormat, hrIn );

Cleanup:

    delete [] pszFormat;
    HRETURN( hr );

} //*** CScriptResource::LogError

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::LogScriptError
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CScriptResource::LogScriptError( 
    EXCEPINFO ei 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( ei.pfnDeferredFillIn != NULL )
    {
        hr = THR( ei.pfnDeferredFillIn( &ei ) );
    }

    TraceMsg( mtfCALLS, "%ws failed.\nError: %u\nSource: %ws\nDescription: %ws\n", 
              m_pszName, 
              ( ei.wCode == 0 ? ei.scode : ei.wCode ), 
              ( ei.bstrSource == NULL ? L"<null>" : ei.bstrSource ),
              ( ei.bstrDescription == NULL ? L"<null>" : ei.bstrDescription )
              );
    (ClusResLogEvent)( m_hResource, 
                       LOG_ERROR, 
                       L"Error: %1!u! (0x%1!08.8x!) - Description: %2!ws! (Source: %3!ws!)\n", 
                       ( ei.wCode == 0 ? ei.scode : ei.wCode ), 
                       ( ei.bstrDescription == NULL ? L"<null>" : ei.bstrDescription ),
                       ( ei.bstrSource == NULL ? L"<null>" : ei.bstrSource )
                       );
    HRETURN( S_OK );

} //*** CScriptResource::LogScriptError

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::HrGetDispIDs
//
//  Description:
//      Get the DISPIDs for the entry points in the script.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK        Operation succeeded.
//      Other HRESULTs.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::HrGetDispIDs( void )
{
    TraceFunc( "" );

    HRESULT hr;
    LPWSTR  pszCommand;

    Assert( m_pidm != NULL );

    //
    // Get DISPIDs for each method we will call.
    //
    pszCommand = L"Open";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                    &pszCommand, 
                                    1, 
                                    LOCALE_USER_DEFAULT, 
                                    &m_dispidOpen 
                                    ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidOpen = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pszCommand = L"Close";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                    &pszCommand, 
                                    1, 
                                    LOCALE_USER_DEFAULT, 
                                    &m_dispidClose 
                                    ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidClose = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pszCommand = L"Online";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                    &pszCommand, 
                                    1, 
                                    LOCALE_USER_DEFAULT, 
                                    &m_dispidOnline 
                                    ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidOnline = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pszCommand = L"Offline";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                    &pszCommand, 
                                    1, 
                                    LOCALE_USER_DEFAULT, 
                                    &m_dispidOffline
                                    ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidOffline = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pszCommand = L"Terminate";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                     &pszCommand, 
                                     1, 
                                     LOCALE_USER_DEFAULT, 
                                     &m_dispidTerminate 
                                     ) );
    if ( hr == DISP_E_UNKNOWNNAME )
    {
        m_dispidTerminate = DISPID_UNKNOWN;
    }
    else if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pszCommand = L"LooksAlive";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                     &pszCommand, 
                                     1, 
                                     LOCALE_USER_DEFAULT, 
                                     &m_dispidLooksAlive 
                                     ) );
    if ( FAILED( hr ) )
    {
        //
        // If there's no LooksAlive entry point in the script. 
        //
        if ( hr == DISP_E_UNKNOWNNAME )
        {
            m_dispidLooksAlive = DISPID_UNKNOWN;
            hr = DISP_E_MEMBERNOTFOUND;
            (ClusResLogEvent)(
                      m_hResource
                    ,  LOG_ERROR
                    , L"%1 did not implement LooksAlive() script entry point. This is a required script entry point.\n"
                    , m_pszName
                    );
         }
        goto Cleanup;
    }

    pszCommand = L"IsAlive";
    hr = THR( m_pidm->GetIDsOfNames( IID_NULL, 
                                     &pszCommand, 
                                     1, 
                                     LOCALE_USER_DEFAULT, 
                                     &m_dispidIsAlive 
                                     ) );
    if ( FAILED( hr ) )
    {
        //
        // If there's no IsAlive entry point in the script. 
        //
        if ( hr == DISP_E_UNKNOWNNAME )
        {
            m_dispidIsAlive = DISPID_UNKNOWN;
            hr = DISP_E_MEMBERNOTFOUND;
            (ClusResLogEvent)(
                      m_hResource
                    ,  LOG_ERROR
                    , L"%1 did not implement IsAlive() script entry point. This is a required script entry point.\n"
                    , m_pszName
                    );
        }
        goto Cleanup;
    }

    //
    // Don't return DISP_E_UNKNOWNNAME to caller.
    //
    hr = S_OK;

Cleanup:

    HRETURN( hr );

} //*** CScriptResource::HrGetDispIDs

//////////////////////////////////////////////////////////////////////////////
//
//  CScriptResource::HrLoadScriptFile
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::HrLoadScriptFile( void )
{
    TraceFunc( "" );
    
    HRESULT hr;
    DWORD   scErr;
    DWORD   dwLow;
    DWORD   dwRead;
    VARIANT varResult;
    EXCEPINFO   ei;

    BOOL    fSuccess;

    HANDLE  hFile = INVALID_HANDLE_VALUE;

    LPSTR  paszText = NULL;
    LPWSTR pszScriptText = NULL;

    Assert( m_hScriptFile == INVALID_HANDLE_VALUE );

    //
    // Open the script file.
    //
    hFile = CreateFile(
                      m_pszScriptFilePath
                    , GENERIC_READ
                    , FILE_SHARE_READ
                    , NULL
                    , OPEN_EXISTING
                    , 0
                    , NULL
                    );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        scErr = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    } // if: failed to open

    //
    // Figure out its size.
    //
    dwLow = GetFileSize( hFile, NULL );
    if ( dwLow == -1 )
    {
        scErr = TW32( GetLastError() );
        hr = THR( HRESULT_FROM_WIN32( scErr ) );
        goto Error;
    } // if: failed to figure out size
    else if ( dwLow == -2 )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }

    //
    // Make a buffer big enough to hold it.
    //
    dwLow++;    // add one for trailing NULL.
    paszText = reinterpret_cast<LPSTR>( TraceAlloc( LMEM_FIXED, dwLow ) );
    if ( paszText == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }

    //
    // Read the script into memory.
    //
    fSuccess = ReadFile( hFile, paszText, dwLow - 1, &dwRead, NULL );
    if ( fSuccess == FALSE )
    {
        scErr = TW32( GetLastError() );
        hr = THR( HRESULT_FROM_WIN32( scErr ) );
        goto Error;
    } // if: failed

    if ( dwRead == - 1 )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }

    if ( dwLow - 1 != dwRead )
    {
        hr = THR( E_OUTOFMEMORY ); // TODO: figure out a better error code.
        goto Error;
    }

    //
    // Make sure it is terminated.
    //
    paszText[ dwRead ] = '\0';

    //
    // Make a buffer to convert the text into UNICODE.
    //
    dwRead++;
    pszScriptText = reinterpret_cast<LPWSTR>( TraceAlloc( LMEM_FIXED, dwRead * sizeof(WCHAR) ) );
    if ( pszScriptText == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }

    //
    // Convert it to UNICODE.
    //
    Assert( lstrlenA( paszText ) + 1 == (signed)dwRead );
    int cchWideFormat = MultiByteToWideChar(
                                              CP_ACP
                                            , 0
                                            , paszText
                                            , -1
                                            , pszScriptText
                                            , dwRead
                                            );
    if ( cchWideFormat == 0 )
    {
        scErr = TW32( GetLastError() );
        hr = THR( HRESULT_FROM_WIN32( scErr ) );
        goto Error;
    }

    //
    // Load the script into the engine for pre-parsing.
    //
    hr = THR( m_pasp->ParseScriptText( pszScriptText,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0,
                                       0,
                                       0,
                                       &varResult,
                                       &ei
                                       ) );
    if ( hr == DISP_E_EXCEPTION )
    {
        LogScriptError( ei );
        goto Error;
    }
    else if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    // Get DISPIDs for each method in the script that we will call.
    //
    hr = THR( HrGetDispIDs() );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    // Save the file handle to keep it open while we are using it.
    // Set hFile so that the file won't be closed below.
    //
    m_hScriptFile = hFile;
    hFile = INVALID_HANDLE_VALUE;

    (ClusResLogEvent)( m_hResource, LOG_INFORMATION, L"Loaded script '%1!ws!' successfully.\n", m_pszScriptFilePath );

Cleanup:

    VariantClear( &varResult );

    if ( paszText != NULL )
    {
        TraceFree( paszText );
    } // if: paszText

    if ( pszScriptText != NULL )
    {
        TraceFree( pszScriptText );
    } // if: pszScriptText;

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    } // if: hFile

    HRETURN( hr );

Error:

    (ClusResLogEvent)( m_hResource, LOG_ERROR, L"Error loading script '%1!ws!'. HRESULT: 0x%2!08x!\n", m_pszScriptFilePath, hr );
    goto Cleanup;


} //*** CScriptResource::HrLoadScriptFile

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::UnLoadScriptFile
//
//  Description:
//      Unload the script file and close the file.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CScriptResource::UnloadScriptFile( void )
{
    TraceFunc( "" );
    
    m_dispidOpen = DISPID_UNKNOWN;
    m_dispidClose = DISPID_UNKNOWN;
    m_dispidOnline = DISPID_UNKNOWN;
    m_dispidOffline = DISPID_UNKNOWN;
    m_dispidTerminate = DISPID_UNKNOWN;
    m_dispidLooksAlive = DISPID_UNKNOWN;
    m_dispidIsAlive = DISPID_UNKNOWN;

    if ( m_hScriptFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hScriptFile );
        m_hScriptFile = INVALID_HANDLE_VALUE;
        (ClusResLogEvent)( m_hResource, LOG_INFORMATION, L"Unloaded script '%1!ws!' successfully.\n", m_pszScriptFilePath );
    } // if: file is open

    TraceFuncExit();

} //*** CScriptResource::UnloadScriptFile

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::S_ThreadProc
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD 
WINAPI
CScriptResource::S_ThreadProc( 
    LPVOID pParam 
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   dw;
    DWORD   scErr;
    BOOL    fSuccess;

    CScriptResource * pscript = reinterpret_cast< CScriptResource * >( pParam );

    Assert( pscript != NULL );

    //
    // Initialize COM.
    //
    hr = THR( CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    for( ;; ) // ever
    {
        //
        //  Indicate that we are ready to do something.
        //
        fSuccess = SetEvent( pscript->m_hEventDone );
        if ( fSuccess == FALSE )
        {
            scErr = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( scErr );
            goto Error;
        }

        //
        //  Wait for someone to need something.
        //
        dw = WaitForSingleObject( pscript->m_hEventWait, INFINITE );
        if ( dw != WAIT_OBJECT_0 )
        {
            hr = HRESULT_FROM_WIN32( dw );
            goto Error;
        }

        //
        //  Reset the event.
        //
        fSuccess = ResetEvent( pscript->m_hEventWait );
        if ( fSuccess == FALSE )
        {
            scErr = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( scErr );
            goto Error;
        }

        //
        //  Do what they ask.
        //
        switch ( pscript->m_msg )
        {
            case msgOPEN:
                pscript->m_hr = THR( pscript->OnOpen() );
                break;

            case msgCLOSE:
                pscript->m_hr = THR( pscript->OnClose() );
                break;

            case msgONLINE:
                pscript->m_hr = THR( pscript->OnOnline() );
                break;

            case msgOFFLINE:
                pscript->m_hr = THR( pscript->OnOffline() );
                break;

            case msgTERMINATE:
                pscript->m_hr = THR( pscript->OnTerminate() );
                break;

            case msgLOOKSALIVE:
                pscript->m_hr = STHR( pscript->OnLooksAlive() );
                break;

            case msgISALIVE:
                pscript->m_hr = STHR( pscript->OnIsAlive() );
                break;

            case msgSETPRIVATEPROPERTIES:
                pscript->m_hr = STHR( pscript->OnSetPrivateProperties( pscript->m_pProps ) );
                break;

            case msgDIE:
                //
                // This means the resource is being released.
                //
                goto Cleanup;
        } // switch: on message

    } // spin forever

Cleanup:

    CoUninitialize();
    HRETURN( hr );

Error:

    pscript->LogError( hr, L"S_ThreadProc() failed." );
    goto Cleanup;

} //*** CScriptResource::S_ThreadProc

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::HrInvoke
//
//  Description:
//      Invoke a script method.
//
//  Arguments:
//      dispidIn    - ID of the method to call.
//      msgIn       - Used in figuring out which entry point is being executed.
//      pvarInout   - Variant in which to return the results of the call.
//      fRequiredIn - TRUE = method must exist, FALSE = method doesn't have to exist.
//
//  Return Values:
//      S_OK                    - Operation completed successfully.
//      DISP_E_MEMBERNOTFOUND   -Method not implemented by the script.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::HrInvoke(
      DISPID    dispidIn
    , EMESSAGE  msgIn      
    , VARIANT * pvarInout   // = NULL
    , BOOL      fRequiredIn // = FALSE
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    EXCEPINFO   ei;
    VARIANT     varResult;
    VARIANT *   pvarResult = pvarInout;

    DISPPARAMS  dispparamsNoArgs = { NULL, NULL, 0, 0 };

    Assert( m_pidm != NULL );

    VariantInit( &varResult );
    if ( pvarInout == NULL )
    {
        pvarResult = &varResult;
    }

    if ( dispidIn != DISPID_UNKNOWN )
    {
        m_msgLastExecuted = msgIn;
        hr = m_pidm->Invoke(
                                          dispidIn
                                        , IID_NULL
                                        , LOCALE_USER_DEFAULT
                                        , DISPATCH_METHOD
                                        , &dispparamsNoArgs
                                        , pvarResult
                                        , &ei
                                        , NULL
                                        );
        if ( hr == DISP_E_EXCEPTION )
        {
            THR( hr );
            LogScriptError( ei );
        }
        else if ( FAILED( hr ) )
        {
            LogError( hr, L"Failed to invoke a method in the script." );
        }
    } // if: entry point is known
    else
    {
        //
        // If this is a required method in the script.
        //
        if ( fRequiredIn == TRUE )
        {
            (ClusResLogEvent)(
                      m_hResource
                    ,  LOG_ERROR
                    , L"%1 entry point is not implemented in the script. This is a required entry point.\n"
                    , g_rgpszScriptEntryPointNames[ msgIn ]
                    );
            hr = DISP_E_MEMBERNOTFOUND;
        } // Log an error message if this is a required entry point, and fail.
        else
        {
            (ClusResLogEvent)(
                      m_hResource
                    ,  LOG_INFORMATION
                    , L"%1 entry point is not implemented in the script. It is not required but recommended to have this entry point.\n"
                    , g_rgpszScriptEntryPointNames[ msgIn ]
                    );
            hr = S_OK; 
        } // Log an information message if the method is not required but missing in the script.
    } // if: method does not exist in the script

    VariantClear( &varResult );

    HRETURN( hr );

} //*** CScriptResource::HrInvoke

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::ScTranslateVariantReturnValue
//
//  Description:
//      Translates a numeric variant value to a status code.
//
//  Arguments:
//      varResultIn     - Variant that holds the return value of a script entry point.
//      vTypeIn         - Type of the variant.
//
//  Return Values:
//      DWORD value of the variant.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CScriptResource::ScTranslateVariantReturnValue(
      VARIANT varResultIn
    , VARTYPE vTypeIn
    )
{
    DWORD sc = ERROR_SUCCESS;

    switch ( vTypeIn )
    {
        case VT_I1 :
            sc = (DWORD) V_I1( &varResultIn );
            break;

        case VT_I2 :
            sc = (DWORD) V_I2( &varResultIn );
            break;

        case VT_I4 :
            sc = (DWORD) V_I4( &varResultIn );
            break;

        case VT_I8 :
            sc = (DWORD) V_I8( &varResultIn );
            break;

        case VT_UI1 :
            sc = (DWORD) V_UI1( &varResultIn );
            break;

        case VT_UI2 :
            sc = (DWORD) V_UI2( &varResultIn );
            break;

        case VT_UI4 :
            sc = (DWORD) V_UI4( &varResultIn );
            break;

        case VT_UI8 :
            sc = (DWORD) V_UI8( &varResultIn );
            break;

        case VT_INT :
            sc = (DWORD) V_INT( &varResultIn );
            break;

        case VT_UINT :
            sc = (DWORD) V_UINT( &varResultIn );
            break;

        case VT_R4 :
            sc = (DWORD) V_R4( &varResultIn );
            break;

        case VT_R8 :
            sc = (DWORD) V_R8( &varResultIn );
            break;

    } // switch( vTypeIn )

    return sc;

} //*** CScriptResource::ScTranslateVariantReturnValue

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::HrProcessResult
//
//  Description:
//      Processes and logs the return value that is stored in varResultIn and
//      generates an HRESULT from the return value.
//
//  Arguments:
//      varResultIn - Variant that holds the return value of a script entry point.
//      msgIn       - Used in figuring out which entry point that was executed.
//
//  Return Values:
//      S_OK            - Script entry point (i.e. Online) was executed successfully.
//      S_FALSE         - Script entry point returned an error.
//      Other HRESULTs  - Script entry point returned an error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::HrProcessResult( VARIANT varResultIn, EMESSAGE  msgIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   dwReturnValue = 0;
    VARTYPE vType = V_VT( &varResultIn );

    //
    // Get the return value from varResultIn.
    //

    switch ( vType )
    {
        case VT_BOOL : 
            if ( V_BOOL( &varResultIn ) == VARIANT_FALSE ) // FALSE was returned
            {
                //
                // Are we processing an IsAlive/LooksAlive return value?
                //
                if ( ( msgIn == msgISALIVE ) || ( msgIn == msgLOOKSALIVE ) )
                {
                    hr = S_FALSE;
                } // if: processing IsAlive/LooksAlive
                else
                {
                    hr = HRESULT_FROM_WIN32( TW32( ERROR_RESOURCE_FAILED ) );
                } // else: processing IsAlive/LooksAlive

                //
                // Log the FALSE return value.
                //
                (ClusResLogEvent)( 
                      m_hResource
                    , LOG_ERROR
                    , L"'%1!ws!' script entry point returned FALSE.'\n"
                    , g_rgpszScriptEntryPointNames[ msgIn ]
                    );
            } // if: Return value is FALSE
            break;

        case VT_I1 :
        case VT_I2 :
        case VT_I4 :
        case VT_I8 :
        case VT_UI1 :
        case VT_UI2 :
        case VT_UI4 :
        case VT_UI8 :
        case VT_INT :
        case VT_UINT :
        case VT_R4 :
        case VT_R8 :
            dwReturnValue = TW32( ScTranslateVariantReturnValue( varResultIn, vType ) );

            //
            // Log the return value on failure.
            //
            if ( dwReturnValue != 0 )
            {
                (ClusResLogEvent)( 
                      m_hResource
                    , LOG_ERROR
                    , L"'%1!ws!' script entry point returned '%2!d!'.\n"
                    , g_rgpszScriptEntryPointNames[ msgIn ]
                    , dwReturnValue
                    );
            }
            hr = HRESULT_FROM_WIN32( dwReturnValue );
            break;

        case VT_BSTR : // A string was returned, so let's just log it.
            (ClusResLogEvent)( 
                  m_hResource
                , LOG_INFORMATION
                , L"'%1!ws!' script entry point returned '%2!ws!'.\n"
                , g_rgpszScriptEntryPointNames[ msgIn ]
                , V_BSTR( &varResultIn )
                );
            break;

        case VT_NULL : // NULL was returned, will not treat this as an error
            (ClusResLogEvent)( 
                  m_hResource
                , LOG_INFORMATION
                , L"'%1!ws!' script entry point returned NULL.'\n"
                , g_rgpszScriptEntryPointNames[ msgIn ]
                );
            break;
            
        case VT_EMPTY : // No return value.
            (ClusResLogEvent)( 
                  m_hResource
                , LOG_INFORMATION
                , L"'%1!ws!' script entry point did not return a value.'\n"
                , g_rgpszScriptEntryPointNames[ msgIn ]
                );
            break;

        default: // Unsupported return type.
            (ClusResLogEvent)( 
                  m_hResource
                , LOG_INFORMATION
                , L"'%1!ws!' script entry point returned a value type is not supported. The return value will be ignored.'\n"
                , g_rgpszScriptEntryPointNames[ msgIn ]
                );
            break;

    } // switch ( V_VT( &varResultIn ) )

    if ( FAILED( hr ) )
    {
        (ClusResLogEvent)(
                  m_hResource
                ,  LOG_ERROR
                , L"Return value of '%1!ws!' script entry point caused HRESULT to be set to 0x%2!08x!.\n"
                , g_rgpszScriptEntryPointNames[ msgIn ]
                , hr
                );
    } // if:  ( FAILED( hr ) )
    else if ( hr != S_OK )
    {
        (ClusResLogEvent)(
                  m_hResource
                ,  LOG_INFORMATION
                , L"Return value of '%1!ws!' script entry point caused HRESULT to be set to 0x%2!08x!.\n"
                , g_rgpszScriptEntryPointNames[ msgIn ]
                , hr
                );
    } // else:  ( FAILED( hr ) )
   
    HRETURN( hr );

} //*** CScriptResource::HrProcessResult

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::OnOpen
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnOpen( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HRESULT hrOpen = S_OK;
    HRESULT hrClose = S_OK;
    VARIANT varResultOpen;
    VARIANT varResultClose;

    VariantInit( &varResultOpen );
    VariantInit( &varResultClose );
    
    //
    // Get the script file path from the cluster database if we don't already have it.
    //
    if ( m_pszScriptFilePath == NULL ) 
    {
        hr = HrGetScriptFilePath();
        if ( FAILED( hr ) )
        {
            if ( ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) ) || ( hr == HRESULT_FROM_WIN32( ERROR_KEY_DELETED ) ) )
            {
                // This can happen when the resource is first created since the
                // ScriptFilePath property has not been specified yet.
                hr = S_OK;
            }
            THR( hr );
            goto Cleanup;
        }
    } // if: no script file path

    //
    // If the script file path is set.
    //

    if ( m_pszScriptFilePath != NULL ) 
    {
        //
        // Load the script engine for the specified script.
        //
        hr = THR( HrLoadScriptEngine() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        // Open the script file and parse it
        //
        hr = THR( HrLoadScriptFile() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        // Call the Open routine of the script if there's one.
        // Call the Close routine as well since we are going to be unloading the script.
        //
        hrOpen = THR( HrInvoke( m_dispidOpen, msgOPEN, &varResultOpen, FALSE /* fRequiredIn */ ) );
        hrClose = THR( HrInvoke( m_dispidClose, msgCLOSE, &varResultClose, FALSE /* fRequiredIn */ ) );
        if ( FAILED( hrOpen ) )
        {
            hr = hrOpen;
            goto Cleanup;
        } // if: ( FAILED( hrOpen ) )
        else if ( FAILED( hrClose ) )
        {
            hr = hrClose;
            goto Cleanup;
        } // elseif: ( FAILED( hrClose ) )

        //
        // We only care about the return value of Open.
        // We don't care about the return value of Close,
        // however processing the return value of Close 
        // might log an entry to the log file.
        //
        hr = HrProcessResult( varResultOpen, msgOPEN );
        hrClose = HrProcessResult( varResultClose, msgCLOSE );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: FAILED( hr )

    } // if: script file path is set

Cleanup:

    //
    // Unload the script and the script engine.  Note they may not be loaded
    // but these routines are safe to call either way.
    //
    UnloadScriptFile();
    UnloadScriptEngine();

    VariantClear( &varResultOpen );
    VariantClear( &varResultClose );

    HRETURN( hr );

} //*** CScriptResource::OnOpen

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnClose
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnClose( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HRESULT hrOpen = S_OK;
    HRESULT hrClose = S_OK;
    BOOL    fCallOpen = FALSE;
    VARIANT varResultOpen;
    VARIANT varResultClose;
    
    VariantInit( &varResultOpen );
    VariantInit( &varResultClose );
    
    //
    // If m_pidm is NULL call HrLoadScriptEngine to have it set.
    //
    if ( m_pidm == NULL )
    {
        //
        // Get the script file path if we don't already have it.
        //
        if ( m_pszScriptFilePath == NULL ) 
        {
            hr = HrGetScriptFilePath();
            if ( FAILED( hr ) )
            {
                if ( ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) ) || ( hr == HRESULT_FROM_WIN32( ERROR_KEY_DELETED ) ) )
                {
                    // This can happen when the resource is cancelled before the
                    // ScriptFilePath property has not been specified.
                    hr = S_OK;
                }
                THR( hr );
                goto Cleanup;
            }

        } // if: no script file path

        //
        // Load the script engine based on the script file path.
        //
        hr = HrLoadScriptEngine();
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        // We need to call open since we loaded the script.
        //
        fCallOpen = TRUE;
    } // if: script and script engine is not loaded
    
    if ( m_dispidClose == DISPID_UNKNOWN )
    {
        //
        // Open the script file and parse it
        //
        hr = THR( HrLoadScriptFile() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: DISPID for Close not loaded

    //
    // If we loaded the script, then we need to call the script's Open method.
    //
    if ( fCallOpen )
    {
        hrOpen = THR( HrInvoke( m_dispidOpen, msgOPEN, &varResultOpen, FALSE /* fRequiredIn */ ) );
    }

    //
    // Call the script's Close method.
    //
    hrClose = THR( HrInvoke( m_dispidClose, msgCLOSE, &varResultClose, FALSE /* fRequiredIn */ ) );

    if ( FAILED( hrClose ) )
    {
        hr = hrClose;
        goto Cleanup;
    } // if: ( FAILED( hrClose ) )
    else if ( FAILED( hrOpen ) )
    {
        hr = hrOpen;
        goto Cleanup;
    }  // else if: ( FAILED( hrOpen ) )

    //
    // We don't care about the return values of Open
    // and Close script entry points in here, however processing the 
    // return values below might log an entry to the log file.
    //
    hr = HrProcessResult( varResultOpen, msgOPEN );
    hr = HrProcessResult( varResultClose, msgCLOSE );
    hr = S_OK;

Cleanup:

    //
    // Unload the script and the script engine.  Note they may not be loaded
    // but these routines are safe to call either way.
    //
    UnloadScriptFile();
    UnloadScriptEngine();

    VariantClear( &varResultOpen );
    VariantClear( &varResultClose );

    HRETURN( hr );

} //*** CScriptResource::OnClose

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CScriptResource::OnOnline
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnOnline( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HRESULT hrOpen = S_OK;
    HRESULT hrOnline = S_OK;
    VARIANT varResultOpen;
    VARIANT varResultOnline;

    VariantInit( &varResultOpen );
    VariantInit( &varResultOnline );
    
    //
    // Get the ScriptFilePath property.
    //
    hr = HrGetScriptFilePath();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Load the script engine based on the script file path.
    //
    hr = HrLoadScriptEngine();
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Load the script file.
    //
    hr = THR( HrLoadScriptFile() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Call the script's Open method since we just loaded the script.
    //
    hrOpen = THR( HrInvoke( m_dispidOpen, msgOPEN, &varResultOpen, FALSE /* fRequiredIn */ ) );
    if ( FAILED( hrOpen ) )
    {
        hr = hrOpen;
        goto Cleanup;
    } // if: FAILED( hrOpen )

    //
    // Call the script's Online method.
    //
    hrOnline = THR( HrInvoke( m_dispidOnline, msgONLINE, &varResultOnline, FALSE /* fRequiredIn */ ) );
    if ( FAILED( hrOnline ) )
    {
        hr = hrOnline;
        goto Cleanup;
    } // if: FAILED( hrOnline )

    //
    // We only care about the return value of Online.
    // We don't care about the return value of Open,
    // however processing the return value of Open 
    // might log an entry to the log file.
    //
    hr = HrProcessResult( varResultOpen, msgOPEN );
    hr = HrProcessResult( varResultOnline, msgONLINE );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: FAILED( hr )

    //
    // Assume the resource LooksAlive...
    //
    m_fLastLooksAlive = TRUE;

Cleanup:

    VariantClear( &varResultOpen );
    VariantClear( &varResultOnline );

    HRETURN( hr );

} //*** CScriptResource::OnOnline

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CScriptResource::OnOffline
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnOffline( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HRESULT hrOffline = S_OK;
    HRESULT hrClose = S_OK;
    VARIANT varResultOffline;
    VARIANT varResultClose;

    VariantInit( &varResultOffline );
    VariantInit( &varResultClose );
    
    //
    // Call the script's Offline method.
    //
    hrOffline = THR( HrInvoke( m_dispidOffline, msgOFFLINE, &varResultOffline, FALSE /* fRequiredIn */ ) );

    //
    // Call the script's Close method since we are going to unload the script.
    //
    hrClose = THR( HrInvoke( m_dispidClose, msgCLOSE, &varResultClose, FALSE /* fRequiredIn */ ) );

    if ( FAILED( hrOffline ) )
    {
        hr = hrOffline;
        goto Cleanup;
    } // if: ( FAILED( hrOffline ) )
    else if ( FAILED( hrClose ) )
    {
        hr = hrClose;
        goto Cleanup;
    } // else if: ( FAILED( hrClose ) )

    //
    // We only care about the return value of Offline.
    // We don't care about the return value of Close,
    // however processing the return value of Close 
    // might log an entry to the log file.
    //
    hr = HrProcessResult( varResultOffline, msgOFFLINE );
    hrClose = HrProcessResult( varResultClose, msgCLOSE );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } //if: FAILED( hr )

Cleanup:
    
    //
    // Unload the script and the script engine.
    //
    UnloadScriptFile();
    UnloadScriptEngine();

    VariantClear( &varResultOffline );
    VariantClear( &varResultClose );

    HRETURN( hr );

} //*** CScriptResource::OnOffline

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnTerminate
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnTerminate( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    HRESULT hrOpen = S_OK;
    HRESULT hrTerminate = S_OK;
    HRESULT hrClose = S_OK;
    VARIANT varResultOpen;
    VARIANT varResultTerminate;
    VARIANT varResultClose;

    VariantInit( &varResultOpen );
    VariantInit( &varResultTerminate );
    VariantInit( &varResultClose );
    
    //
    // If the script engine is not loaded yet, load it now.
    //
    if ( m_pidm == NULL )
    {
        //
        // Get the script file path if we don't already have it.
        //
        if ( m_pszScriptFilePath == NULL )
        {
            hr = THR( HrGetScriptFilePath() );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // if: no script file path

        //
        // Load the script engine based on the script file path.
        //
        hr = HrLoadScriptEngine();
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        // Open the script file and parse it
        //
        hr = THR( HrLoadScriptFile() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        //
        // We need to call open since we loaded the script.
        //
        hrOpen = THR( HrInvoke( m_dispidOpen, msgOPEN, &varResultOpen, FALSE /* fRequiredIn */ ) );
        if ( FAILED( hrOpen ) )
        {
            hr = hrOpen;
            goto Cleanup;
        } // if: FAILED( hrOpen )

        //
        // We don't care about the return value of Open
        // however processing the return value below might 
        // log an entry to the log file.
        //
        hrOpen = HrProcessResult( varResultOpen, msgOPEN );
        
    } // if: script and script engine is not loaded

    //
    // Call the script's Terminate method.
    //
    hrTerminate = THR( HrInvoke( m_dispidTerminate, msgTERMINATE, &varResultTerminate, FALSE /* fRequiredIn */ ) );
    if ( FAILED( hrTerminate ) )
    {
        hr = hrTerminate;
        goto Cleanup;
    } // if: ( FAILED( hrTerminate ) )

    //
    // Call the script's Close method since we are unloading the script.
    //
    hrClose = THR( HrInvoke( m_dispidClose, msgCLOSE, &varResultClose, FALSE /* fRequiredIn */ ) );
    if ( FAILED( hrClose ) )
    {
        hr = hrClose;
        goto Cleanup;
    } // if: ( FAILED( hrClose ) )
    
    //
    // We don't care about the return values of Terminate
    // and Close script entry points in here, however processing the 
    // return values below might log an entry to the log file.
    //
    hrTerminate = HrProcessResult( varResultTerminate, msgTERMINATE );
    hrClose = HrProcessResult( varResultClose, msgCLOSE );
    hr = S_OK;

Cleanup:

    //
    // Unload the script and the script engine.
    //
    UnloadScriptFile();
    UnloadScriptEngine();

    VariantClear( &varResultOpen );
    VariantClear( &varResultTerminate );
    VariantClear( &varResultClose );

    HRETURN( hr );

} //*** CScriptResource::OnTerminate

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnLooksAlive
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnLooksAlive( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    VARIANT     varResult;

    VariantInit( &varResult );

    //
    // Call the script's LooksAlive method.
    //
    hr = THR( HrInvoke( m_dispidLooksAlive, msgLOOKSALIVE, &varResult, TRUE /* fRequiredIn */ ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the result of the LooksAlive call
    // and process it.
    //
    hr = HrProcessResult( varResult, msgLOOKSALIVE );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } //if: FAILED( hr )

Cleanup:

    VariantClear( &varResult );

    //
    //  Only if the result of this script entry point is S_OK is the resource
    //  considered alive.
    //
    if ( hr == S_OK )
    {
        m_fLastLooksAlive = TRUE;
    } // if: S_OK
    else
    {
        m_fLastLooksAlive = FALSE;
    } // else: failed

    HRETURN( hr );

} //*** CScriptResource::OnLooksAlive

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CScriptResource::OnIsAlive
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::OnIsAlive( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    VARIANT     varResult;

    VariantInit( &varResult );

    //
    // Call the script's IsAlive method.
    //
    hr = THR( HrInvoke( m_dispidIsAlive, msgISALIVE, &varResult, TRUE /* fRequiredIn */ ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the result of the IsAlive call
    // and process it.
    //
    hr = HrProcessResult( varResult, msgISALIVE );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } //if: FAILED( hr )

Cleanup:

    VariantClear( &varResult );

    HRETURN( hr );

} //*** CScriptResource::OnIsAlive

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::OnSetPrivateProperties
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control code in
//      the script thread.
//
//  Arguments:
//
//  Return Values:
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
CScriptResource::OnSetPrivateProperties(
    PGENSCRIPT_PROPS pProps
    )
{
    TraceFunc( "" );

    DWORD   sc = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    LPWSTR  pszFilePath = NULL;

    //
    // Search the property list for the properties we know about.
    //
    if ( pProps != NULL )
    {

        //
        // If the resource is online, we can't allow the user to set the ScriptFilePath
        // out from under us, so return an error.
        //
        if ( m_pidm != NULL )
        {
            sc = ERROR_RESOURCE_ONLINE;
            goto Cleanup;
        } // if: script engine is loaded

        //
        // Expand the new script file path.
        //
        pszFilePath = ClRtlExpandEnvironmentStrings( pProps->pszScriptFilePath );
        if ( pszFilePath == NULL )
        {
            sc = TW32( ERROR_OUTOFMEMORY );
            goto Cleanup;
        } // if: ( pszFilePath == NULL )
       
        LocalFree( m_pszScriptFilePath );
        m_pszScriptFilePath = pszFilePath;
        if ( m_pszScriptFilePath == NULL )
        {
            sc = TW32( GetLastError() );
            goto Cleanup;
        }

        //
        // Since the script is being set, we need to load it again and call Open and Close on it.
        //
        hr = THR( OnOpen() );
        if ( FAILED( hr ) )
        {
            sc = STATUS_TO_RETURN( hr );
            goto Cleanup;
        }

    } // if: a property list was specified


Cleanup:

    if ( sc == ERROR_SUCCESS )
    {
        //
        // To allow the Resource Monitor to save the properties in the property list
        // (especially unknown properties) to the cluster database, we will return
        // ERROR_INVALID_FUNCTION.
        //
        sc = ERROR_INVALID_FUNCTION;
    }

    W32RETURN( sc );
    
} //*** CScriptResource::OnSetPrivateProperties

//////////////////////////////////////////////////////////////////////////////
//
//  CScriptResource::HrMakeScriptEngineAssociation
//
//  Description:
//      Using the filename, this method splits off the extension then 
//      queries the registry to obtain the association and finally queries
//      the ScriptingEngine key under that association and allocates a
//      buffer containing the engine name.  This engine name is suitable
//      for input into CLSIDFromProgID.
//
//  Return Values:
//      S_OK    - Success
//      Other HRESULTs
//
//////////////////////////////////////////////////////////////////////////////

#define SCRIPTENGINE_KEY_STRING L"\\ScriptEngine"
HRESULT
CScriptResource::HrMakeScriptEngineAssociation( void )
{
    TraceFunc( "" );

    LPWSTR  pszAssociation = NULL;
    LPWSTR  pszEngineName  = NULL;
    HKEY    hKey           = NULL;
    WCHAR   szExtension[ _MAX_EXT ];
    DWORD   scErr = ERROR_SUCCESS;
    DWORD   dwType;
    DWORD   cbAssociationSize;
    DWORD   cbEngineNameSize;
    DWORD   dwNumChars;
    size_t  cchBufSize;
    HRESULT hr = S_OK;

    TraceFree( m_pszScriptEngine );
    m_pszScriptEngine = NULL;

    //
    // First split the path to get the extension.
    //
    _wsplitpath( m_pszScriptFilePath, NULL, NULL, NULL, szExtension );
    if ( szExtension[ 0 ] == L'\0' )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_FILE_NOT_FOUND ) );
        goto Cleanup;
    }

    //
    // Go to the HKEY_CLASSES_ROOT\szExtenstion registry key.
    //
    scErr = TW32( RegOpenKeyExW(
                                  HKEY_CLASSES_ROOT     // handle to open key
                                , szExtension           // subkey name
                                , 0                     // reserved
                                , KEY_READ              // security access desired.
                                , &hKey                 // key handle returned
                                ) );
    if ( scErr == ERROR_FILE_NOT_FOUND ) // The fix for bug 737013 in windows database.
    {
        hr = THR( MK_E_INVALIDEXTENSION );
        goto Cleanup;
    } // if: ( scErr == ERROR_FILE_NOT_FOUND )
    else if ( scErr != ERROR_SUCCESS )
    {
        goto MakeHr;
    }

    //
    // Query the value to get the size of the buffer to allocate.
    // NB cbSize contains the size including the '\0'
    //
    scErr = TW32( RegQueryValueExW(
                                  hKey                  // handle to key
                                , NULL                  // value name
                                , 0                     // reserved
                                , &dwType               // type buffer
                                , NULL                  // data buffer
                                , &cbAssociationSize    // size of data buffer
                                ) );
    if ( scErr == ERROR_FILE_NOT_FOUND ) // The fix for bug 737013 in windows database.
    {
        hr = THR( MK_E_INVALIDEXTENSION );
        goto Cleanup;
    } // if: ( scErr == ERROR_FILE_NOT_FOUND )
    else if ( scErr != ERROR_SUCCESS )
    {
        goto MakeHr;
    }

    if ( dwType != REG_SZ )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_FILE_NOT_FOUND ) );
        goto Cleanup;
    }

    dwNumChars = cbAssociationSize / sizeof( WCHAR );
    cchBufSize = static_cast<size_t> ( cbAssociationSize ) + sizeof( SCRIPTENGINE_KEY_STRING );
    pszAssociation = (LPWSTR) TraceAlloc( GPTR, static_cast<DWORD> ( cchBufSize ) );
    if ( pszAssociation == NULL )
    {
        hr  = HRESULT_FROM_WIN32( TW32( ERROR_NOT_ENOUGH_MEMORY ) );
        goto Cleanup;
    }

    //
    // Get the value for real.
    //
    scErr = TW32( RegQueryValueExW(
                                  hKey                      // handle to key
                                , NULL                      // value name
                                , 0                         // reserved
                                , &dwType                   // type buffer
                                , (LPBYTE) pszAssociation   // data buffer
                                , &cbAssociationSize        // size of data buffer
                                ) );
    if ( scErr == ERROR_FILE_NOT_FOUND ) // The fix for bug 737013 in windows database.
    {
        hr = THR( MK_E_INVALIDEXTENSION );
        goto Cleanup;
    } // if: ( scErr == ERROR_FILE_NOT_FOUND )
    else if ( scErr != ERROR_SUCCESS )
    {
        goto MakeHr;
    }

    if ( dwType != REG_SZ )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_FILE_NOT_FOUND ) );
        goto Cleanup;
    }
    
    scErr = TW32( RegCloseKey( hKey ) );
    if ( scErr != ERROR_SUCCESS )
    {
        goto MakeHr;
    }
    
    hKey = NULL;

    //
    // Take the data and make a key with \ScriptEngine on the end.  If
    // we find this then we can use the file.
    //
    hr = THR( StringCchPrintfW( &pszAssociation[ dwNumChars - 1 ], cchBufSize - ( dwNumChars - 1 ), SCRIPTENGINE_KEY_STRING ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: FAILED( hr )

    scErr = TW32( RegOpenKeyExW(
                                  HKEY_CLASSES_ROOT // handle to open key
                                , pszAssociation    // subkey name
                                , 0                 // reserved
                                , KEY_READ          // security access
                                , &hKey             // key handle 
                                ) );
    if ( scErr == ERROR_FILE_NOT_FOUND ) // The fix for bug 737013 in windows database.
    {
        hr = THR( MK_E_INVALIDEXTENSION );
        goto Cleanup;
    } // if: ( scErr == ERROR_FILE_NOT_FOUND )
    else if ( scErr != ERROR_SUCCESS )
    {
        goto MakeHr;
    } // else if: ( scErr != ERROR_SUCCESS )

    scErr = TW32( RegQueryValueExW(
                                  hKey              // handle to key
                                , NULL              // value name
                                , 0                 // reserved
                                , &dwType           // type buffer
                                , NULL              // data buffer
                                , &cbEngineNameSize // size of data buffer
                                ) );
    if ( scErr == ERROR_FILE_NOT_FOUND ) // The fix for bug 737013 in windows database.
    {
        hr = THR( MK_E_INVALIDEXTENSION );
        goto Cleanup;
    } // if: ( scErr == ERROR_FILE_NOT_FOUND )
    else if ( scErr != ERROR_SUCCESS )
    {
        goto MakeHr;
    }

    if ( dwType != REG_SZ )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_FILE_NOT_FOUND ) );
        goto Cleanup;
    }

    dwNumChars = cbEngineNameSize / sizeof( WCHAR );
    pszEngineName = (LPWSTR) TraceAlloc( GPTR, cbEngineNameSize );
    if ( NULL == pszEngineName )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_NOT_ENOUGH_MEMORY ) );
        goto Cleanup;
    }
    pszEngineName[ dwNumChars - 1 ] = L'\0';

    //
    // Get the value for real.
    //
    scErr = TW32( RegQueryValueExW(
                                  hKey                      // handle to key
                                , NULL                      // value name
                                , 0                         // reserved
                                , &dwType                   // type buffer
                                , (LPBYTE) pszEngineName    // data buffer
                                , &cbEngineNameSize         // size of data buffer
                                ) );
    if ( scErr == ERROR_FILE_NOT_FOUND ) // The fix for bug 737013 in windows database.
    {
        hr = THR( MK_E_INVALIDEXTENSION );
        goto Cleanup;
    } // if: ( scErr == ERROR_FILE_NOT_FOUND )
    else if ( scErr != ERROR_SUCCESS )
    {
        goto MakeHr;
    }

    if ( dwType != REG_SZ )
    {
        hr = HRESULT_FROM_WIN32( TW32( ERROR_FILE_NOT_FOUND ) );
        goto Cleanup;
    }
    
    scErr = RegCloseKey( hKey );
    if ( scErr != ERROR_SUCCESS )
    {
        goto MakeHr;
    }
    
    hKey = NULL;
    goto Cleanup;

MakeHr:

    hr = HRESULT_FROM_WIN32( TW32( scErr ) );
    goto Cleanup;

Cleanup:

    if ( FAILED( hr ) )
    {
        TraceFree( pszEngineName );
        pszEngineName = NULL;
    } 
    else
    {
        m_pszScriptEngine = pszEngineName;
    }

    if ( hKey != NULL )
    {
        (void) RegCloseKey( hKey );
    }

    TraceFree( pszAssociation );
    HRETURN( hr );

} //*** CScriptResource::MakeScriptEngineAssociation
#undef SCRIPTENGINE_KEY_STRING


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::HrGetScriptFilePath
//
//  Description:
//      Reads the registry, extracts the script file path and sets m_pszScriptFilePath.
//
//  Arguments:
//      None
//
//  Return Values:
//      S_OK                    - Script file path retrieved successfully.
//      ERROR_FILE_NOT_FOUND    - Script file path not set yet.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::HrGetScriptFilePath( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   scErr;
    DWORD   cbSize;
    DWORD   dwType;
    LPWSTR  pszScriptFilePathTmp = NULL;

    //
    // Figure out how big the filepath is.
    //
    scErr = ClusterRegQueryValue( m_hkeyParams, CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH, NULL, NULL, &cbSize );
    if ( scErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scErr );
        if ( ( scErr == ERROR_FILE_NOT_FOUND ) || ( scErr == ERROR_KEY_DELETED ) )
        {
            goto Cleanup; // We don't want to log this error, goto Cleanup.
        }
        else
        {
            TW32( scErr );
            goto Error;
        }
    } // if: failed

    //
    // Make a buffer big enough.
    //    
    cbSize += sizeof( L'\0' );

    pszScriptFilePathTmp = reinterpret_cast<LPWSTR>( TraceAlloc( LMEM_FIXED, cbSize ) );
    if ( pszScriptFilePathTmp == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }

    //
    // Grab it for real this time,
    //
    scErr = TW32( ClusterRegQueryValue(
                                  m_hkeyParams
                                , CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH
                                , &dwType
                                , reinterpret_cast<LPBYTE>( pszScriptFilePathTmp )
                                , &cbSize
                                ) );
    if ( scErr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( scErr );
        goto Error;
    }
    Assert( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) );
    
    //
    // If we have some old data from before then free this first.
    //
    LocalFree( m_pszScriptFilePath );
    m_pszScriptFilePath = ClRtlExpandEnvironmentStrings( pszScriptFilePathTmp );
    if ( m_pszScriptFilePath == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        goto Error;
    }

Cleanup:

    if ( pszScriptFilePathTmp != NULL )
    {
        TraceFree( pszScriptFilePathTmp );
    } // if: pszScriptFilePathTmp

    HRETURN( hr );

Error:

    LogError( hr, L"Error getting the script file path property from the cluster database." );
    goto Cleanup;

}  //***  CScriptResource::HrGetScriptFilePath

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CScriptResource::HrLoadScriptEngine
//
//  Description:
//      Connects to the script engine associated with the script passed in.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK - connected OK.
//      Failure status - local cleanup performed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CScriptResource::HrLoadScriptEngine( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    CLSID   clsidScriptEngine;

    CActiveScriptSite * psite = NULL;

    Assert( m_pszScriptFilePath != NULL );
    Assert( m_pass == NULL );
    Assert( m_pasp == NULL );
    Assert( m_pas == NULL );
    Assert( m_pidm == NULL );
 
    //
    // Create the scripting site.
    //
    psite = new CActiveScriptSite( m_hResource, ClusResLogEvent, m_hkeyParams, m_pszName );
    if ( psite == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        LogError( hr, L"Error allocating memory for the active script site object instance." );
        goto Cleanup;
    }

    hr = THR( psite->QueryInterface( IID_IActiveScriptSite, reinterpret_cast< void ** >( &m_pass ) ) );
    if ( FAILED( hr ) )
    {
        LogError( hr, L"Error getting the active script site interface." );
        goto Cleanup;
    }

    //
    // Find the Active Engine.
    //
    if ( m_pszScriptFilePath == NULL )
    {
        (ClusResLogEvent)( m_hResource, LOG_ERROR, L"HrLoadScriptEngine: No script file path set\n" );

        hr = HRESULT_FROM_WIN32( TW32( ERROR_FILE_NOT_FOUND ) );
        goto Cleanup;
    } // if: no script file path specified
    else
    {
        //
        // Find the program associated with the extension.
        //
        hr = HrMakeScriptEngineAssociation();
        if ( FAILED( hr ) )
        {
            LogError( hr, L"Error getting script engine." );
            goto Cleanup;
        }

        hr = THR( CLSIDFromProgID( m_pszScriptEngine, &clsidScriptEngine ) );
        if ( FAILED( hr ) ) 
        {
            LogError( hr, L"Error getting the ProgID for the script engine." );
            goto Cleanup;
        }
    } // else: script file path specified

    //
    // Create an instance of it.
    //
    TraceDo( hr = THR( CoCreateInstance(
                                          clsidScriptEngine
                                        , NULL
                                        , ( CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER )
                                        , IID_IActiveScriptParse
                                        , reinterpret_cast< void ** >( &m_pasp ) 
                                        ) ) );
    if ( FAILED( hr ) )
    {
        LogError( hr, L"Error creating the script engine object instance." );
        goto Cleanup;
    }
    m_pasp = TraceInterface( L"Active Script Engine", IActiveScriptParse, m_pasp, 1 );

    TraceDo( hr = THR( m_pasp->QueryInterface( IID_IActiveScript, reinterpret_cast<void**> ( &m_pas ) ) ) );
    if ( FAILED( hr ) )
    {
        LogError( hr, L"Error getting the active script interface from the script parse object." );
        goto Cleanup;
    }
    m_pas = TraceInterface( L"Active Script Engine", IActiveScript, m_pas, 1 );

    //
    // Initialize it.
    //
    TraceDo( hr = THR( m_pasp->InitNew() ) );
    if ( FAILED( hr ) ) 
    {
        LogError( hr, L"Error initializing the script site parser object." );
        goto Cleanup;
    }

#if defined(DEBUG)
    //
    // Set our site. We'll give out a new tracking interface to track this separately.
    //
    {
        IActiveScriptSite * psiteDbg;
        hr = THR( m_pass->TypeSafeQI( IActiveScriptSite, &psiteDbg ) );
        Assert( hr == S_OK );

        TraceDo( hr = THR( m_pas->SetScriptSite( psiteDbg ) ) );
        psiteDbg->Release();      // release promptly
        psiteDbg = NULL;
        if ( FAILED( hr ) )
        {
            LogError( hr, L"Error setting the script site on the script engine." );
            goto Cleanup;
        }
    }
#else
    TraceDo( hr = THR( m_pas->SetScriptSite( m_pass ) ) );
    if ( FAILED( hr ) )
    {
        LogError( hr, L"Error setting the script site on the script engine." );
        goto Cleanup;
    }
#endif

    //
    // Add Document to the global members.
    //
    TraceDo( hr = THR( m_pas->AddNamedItem( L"Resource", SCRIPTITEM_ISVISIBLE ) ) );
    if ( FAILED( hr ) )
    {
        LogError( hr, L"Error adding the 'Resource' named item to the script object." );
        goto Cleanup;
    }

    //
    // Connect the script.
    //
    TraceDo( hr = THR( m_pas->SetScriptState( SCRIPTSTATE_CONNECTED ) ) );
    if ( FAILED( hr ) )
    {
        LogError( hr, L"Error setting the script state on the script engine." );
        goto Cleanup;
    }
    //
    // Get the dispatch inteface to the script.
    //
    TraceDo( hr = THR( m_pas->GetScriptDispatch( NULL, &m_pidm ) ) );
    if ( FAILED( hr) )
    {
        LogError( hr, L"Error getting the script dispatch table." );
        goto Cleanup;
    }
    m_pidm = TraceInterface( L"Active Script", IDispatch, m_pidm, 1 );

    hr = S_OK;
    (ClusResLogEvent)( m_hResource, LOG_INFORMATION, L"Loaded script engine '%1!ws!' successfully.\n", m_pszScriptEngine );

Cleanup:

    if ( psite != NULL )
    {
        psite->Release();
        psite = NULL;
    }
 
    HRETURN( hr );

} //*** CScriptResource::HrLoadScriptEngine

//////////////////////////////////////////////////////////////////////////////
//
//  CScriptResource::UnloadScriptEngine
//
//  Description:
//      Disconnects from any currently connected script engine.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//////////////////////////////////////////////////////////////////////////////
void
CScriptResource::UnloadScriptEngine( void )
{
    TraceFunc( "" );

    //
    // Cleanup the scripting engine.
    //
    if ( m_pszScriptEngine != NULL )
    {
        (ClusResLogEvent)( m_hResource, LOG_INFORMATION, L"Unloaded script engine '%1!ws!' successfully.\n", m_pszScriptEngine );
        TraceFree( m_pszScriptEngine );
        m_pszScriptEngine = NULL;
    }

    if ( m_pidm != NULL )
    {
        TraceDo( m_pidm->Release() );
        m_pidm = NULL;
    } // if: m_pidm

    if ( m_pasp != NULL )
    {
        TraceDo( m_pasp->Release() );
        m_pasp = NULL;
    } // if: m_pasp

    if ( m_pas != NULL )
    {
        TraceDo( m_pas->Close() );
        TraceDo( m_pas->Release() );
        m_pas = NULL;
    } // if: m_pas

    if ( m_pass != NULL )
    {
        TraceDo( m_pass->Release() );
        m_pass = NULL;
    } // if: m_pass

    TraceFuncExit();

} //*** CScriptResource::UnloadScriptEngine
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\gensvc\gensvc.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    gensvc.c

Abstract:

    Resource DLL to control and monitor NT services.

Author:


    Robs 3/28/96, based on RodGa's generic resource dll

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
#include "userenv.h"
#include <strsafe.h>

// Uncomment the next line to test the Terminate() function when
// a shutdown is in progress.
//#define TEST_TERMINATE_ON_SHUTDOWN

#define LOG_CURRENT_MODULE LOG_MODULE_GENSVC

#define SERVICES_ROOT L"SYSTEM\\CurrentControlSet\\Services\\"

#define DBG_PRINT printf

#define PARAM_NAME__SERVICENAME         CLUSREG_NAME_GENSVC_SERVICE_NAME
#define PARAM_NAME__STARTUPPARAMETERS   CLUSREG_NAME_GENSVC_STARTUP_PARAMS
#define PARAM_NAME__USENETWORKNAME      CLUSREG_NAME_GENSVC_USE_NETWORK_NAME

#define PARAM_MIN__USENETWORKNAME     0
#define PARAM_MAX__USENETWORKNAME     1
#define PARAM_DEFAULT__USENETWORKNAME 0

typedef struct _GENSVC_PARAMS {
    PWSTR           ServiceName;
    PWSTR           StartupParameters;
    DWORD           UseNetworkName;
} GENSVC_PARAMS, *PGENSVC_PARAMS;

typedef struct _GENSVC_RESOURCE {
    GENSVC_PARAMS   Params;
    HRESOURCE       hResource;
    HANDLE          ServiceHandle;
    RESOURCE_HANDLE ResourceHandle;
    HKEY            ResourceKey;
    HKEY            ParametersKey;
    CLUS_WORKER     PendingThread;
    BOOL            Online;
    DWORD           dwServicePid;
    HANDLE          hSem;
} GENSVC_RESOURCE, *PGENSVC_RESOURCE;

//
// Global Data
//

// Handle to service controller,  set by the first create resource call.

SC_HANDLE g_ScHandle = NULL;

// Log Event Routine

#define g_LogEvent ClusResLogEvent
#define g_SetResourceStatus ClusResSetResourceStatus

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE GenSvcFunctionTable;

//
// Generic Service resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
GenSvcResourcePrivateProperties[] = {
    { PARAM_NAME__SERVICENAME,       NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(GENSVC_PARAMS,ServiceName) },
    { PARAM_NAME__STARTUPPARAMETERS, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0, FIELD_OFFSET(GENSVC_PARAMS,StartupParameters) },
    { PARAM_NAME__USENETWORKNAME,    NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__USENETWORKNAME, PARAM_MIN__USENETWORKNAME, PARAM_MAX__USENETWORKNAME, 0, FIELD_OFFSET(GENSVC_PARAMS,UseNetworkName) },
    { 0 }
};

//
// Forward routines
//

BOOL
VerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag
    );

void
wparse_cmdline (
    WCHAR *cmdstart,
    WCHAR **argv,
    WCHAR *args,
    int *numargs,
    int *numchars
    );

DWORD
GenSvcGetPrivateResProperties(
    IN const PGENSVC_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
GenSvcValidatePrivateResProperties(
    IN const PGENSVC_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENSVC_PARAMS Params
    );

DWORD
GenSvcSetPrivateResProperties(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
GenSvcCheckInvalidService(
    IN PGENSVC_RESOURCE pGenSvcCandidateResourceEntry,
    IN LPCWSTR pGenSvcCandidateServiceName,
    IN LPCWSTR pCheckedServiceName,
    IN SC_HANDLE hSCManager
    );

DWORD
GenSvcIsValidService(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN LPCWSTR ServiceName
    );

DWORD
GenSvcOfflineThread(
    PCLUS_WORKER pWorker,
    IN PGENSVC_RESOURCE ResourceEntry
    );

BOOLEAN
GenSvcInit(
    VOID
    )
{
    return(TRUE);
}


BOOLEAN
WINAPI
GenSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{

    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        if ( !GenSvcInit() ) {
            return(FALSE);
        }

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return(TRUE);

} // GenSvc DllEntryPoint


DWORD
GenSvcOnlineThread(
    PCLUS_WORKER pWorker,
    IN PGENSVC_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a disk resource online.

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the DiskInfo block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    SERVICE_STATUS_PROCESS      ServiceStatus;
    DWORD                       status = ERROR_SUCCESS;
    DWORD                       numchars;
    LPWSTR *                    serviceArgArray = NULL;
    DWORD                       serviceArgCount;
    SC_HANDLE                   serviceHandle;
    RESOURCE_STATUS             resourceStatus;
    DWORD                       valueSize;
    LPVOID                      Environment = NULL;
    WCHAR *                     p;
    LPWSTR                      nameOfPropInError;
    LPSERVICE_FAILURE_ACTIONS   pSvcFailureActions = NULL;
    DWORD                       cbBytesNeeded, i;
    LPQUERY_SERVICE_CONFIG      lpquerysvcconfig=NULL;
    HANDLE                      processToken = NULL;
    DWORD                       dwRetryCount = 2400; // Try 10 min max.
    DWORD                       dwRetryTick = 250; // msec

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //set it to NULL, when it is brought online and if the
    //service is not running in the system or lsa process
    //then store the process id for forceful termination
    ResourceEntry->dwServicePid = 0;
    //
    // Read our parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock( ResourceEntry->ParametersKey,
                                                   GenSvcResourcePrivateProperties,
                                                   (LPBYTE) &ResourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1!ls!' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto error_exit;
    }

    //
    // Parse the startup parameters
    //
    if ( ResourceEntry->Params.StartupParameters != NULL ) {
        //
        // Crack the startup parameters into its component arguments because
        // the service controller is not good enough to do this for us.
        // First, find out how many args we have.
        //
        wparse_cmdline( ResourceEntry->Params.StartupParameters, NULL, NULL, &serviceArgCount, &numchars );

        //
        // Allocate space for vector and strings
        //
        serviceArgArray = LocalAlloc( LMEM_FIXED,
                                      serviceArgCount * sizeof(WCHAR *) +
                                      numchars * sizeof(WCHAR) );
        if ( serviceArgArray == NULL ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        wparse_cmdline( ResourceEntry->Params.StartupParameters,
                        serviceArgArray,
                        (WCHAR *)(((char *)serviceArgArray) + serviceArgCount * sizeof(WCHAR *)),
                        &serviceArgCount,
                        &numchars );
    } else {
        serviceArgCount = 0;
        serviceArgArray = NULL;
    }

    //
    // Now open the requested service
    //

    ResourceEntry->ServiceHandle = OpenService( g_ScHandle,
                                                ResourceEntry->Params.ServiceName,
                                                SERVICE_ALL_ACCESS );

    if ( ResourceEntry->ServiceHandle == NULL ) {
        status = GetLastError();

        ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                       LOG_CRITICAL,
                                       RES_GENSVC_OPEN_FAILED,
                                       sizeof(status),
                                       &status);
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to open service, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    valueSize = sizeof(QUERY_SERVICE_CONFIG);
AllocSvcConfig:
    // Query the service to make sure it is not disabled
    lpquerysvcconfig=(LPQUERY_SERVICE_CONFIG)LocalAlloc(LMEM_FIXED, valueSize);
    if(lpquerysvcconfig==NULL){
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[Gensvc] Failed to allocate memory for query_service_config, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    if (!QueryServiceConfig(ResourceEntry->ServiceHandle,
                            lpquerysvcconfig,
                            valueSize,
                            &cbBytesNeeded))
    {
        status=GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER){
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"svc: Failed to query service configuration, error= %1!u!.\n",
                         status );
            goto error_exit;
        }

        status=ERROR_SUCCESS; 
        LocalFree(lpquerysvcconfig);
        lpquerysvcconfig=NULL;
        valueSize = cbBytesNeeded;
        goto AllocSvcConfig;
    }

    if (lpquerysvcconfig->dwStartType == SERVICE_DISABLED)
    {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
           LOG_ERROR,
           L"svc:The service is DISABLED\n");    
        status=ERROR_SERVICE_DISABLED;
        goto error_exit;
    }

    //
    // Make sure service is set to manual start.
    //
    ChangeServiceConfig( ResourceEntry->ServiceHandle,
                         SERVICE_NO_CHANGE,
                         SERVICE_DEMAND_START, // Manual start
                         SERVICE_NO_CHANGE,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL );

    //
    // if any of the service actions is set to service restart, set it to none
    //
    if (!(QueryServiceConfig2(ResourceEntry->ServiceHandle, SERVICE_CONFIG_FAILURE_ACTIONS,
        (LPBYTE)&valueSize, sizeof(DWORD), &cbBytesNeeded)))
    {
        status = GetLastError();
        if (status != ERROR_INSUFFICIENT_BUFFER)
        {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"svc: Failed to query service configuration for size, error= %1!u!.\n",
                status );
            goto error_exit;
        }
        else
            status = ERROR_SUCCESS;
    }

    pSvcFailureActions = (LPSERVICE_FAILURE_ACTIONS)LocalAlloc(LMEM_FIXED, cbBytesNeeded);

    if ( pSvcFailureActions == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[Gensvc] Failed to allocate memory, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    if (!(QueryServiceConfig2(ResourceEntry->ServiceHandle, SERVICE_CONFIG_FAILURE_ACTIONS,
        (LPBYTE)pSvcFailureActions, cbBytesNeeded, &cbBytesNeeded)))
    {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"[Gensvc] Failed to query service configuration, error = %1!u!.\n",
            status );
        goto error_exit;
    }

    for (i=0; i<pSvcFailureActions->cActions;i++)
    {
        if (pSvcFailureActions->lpsaActions[i].Type == SC_ACTION_RESTART)
            pSvcFailureActions->lpsaActions[i].Type = SC_ACTION_NONE;
    }

    ChangeServiceConfig2(ResourceEntry->ServiceHandle,
                         SERVICE_CONFIG_FAILURE_ACTIONS,
                         pSvcFailureActions);

    //
    // if the resource has a dependent netname and the service should use that
    // as the computer name, then build the env. vars that SCM will use to
    // augment the normal environment. The hostname APIs will look for these
    // vars and report back the netname instead of the actual hostname.
    //
    if ( ResourceEntry->Params.UseNetworkName ) 
    {
        status = ResUtilSetResourceServiceEnvironment(
                     ResourceEntry->Params.ServiceName,
                     ResourceEntry->hResource,
                     g_LogEvent,
                     ResourceEntry->ResourceHandle);
        if ( status != ERROR_SUCCESS )
        {
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Failed to set service environment. Error: %1!u!.\n",
                         status);
            goto error_exit;
        } // if:
    }

    //
    // start it up...
    //
    if ( !StartServiceW( ResourceEntry->ServiceHandle,
                         serviceArgCount,
                         serviceArgArray ) )
    {
        status = GetLastError();

        if (status != ERROR_SERVICE_ALREADY_RUNNING) {

            ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                           LOG_CRITICAL,
                                           RES_GENSVC_START_FAILED,
                                           sizeof(status),
                                           &status);
            (g_LogEvent)(ResourceEntry->ResourceHandle,
                         LOG_ERROR,
                         L"Failed to start service. Error: %1!u!.\n",
                         status );
            goto error_exit;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    //
    // wait for the service to comeonline unless we are asked to terminate
    //
    while (!ClusWorkerCheckTerminate(pWorker) && dwRetryCount--)  {

        //
        // Tell the Resource Monitor that we are still working.
        //
        resourceStatus.ResourceState = ClusterResourceOnlinePending;
        resourceStatus.CheckPoint++;
        (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                               &resourceStatus );
        resourceStatus.ResourceState = ClusterResourceFailed;

        if ( !QueryServiceStatusEx( ResourceEntry->ServiceHandle,
                SC_STATUS_PROCESS_INFO, (LPBYTE)&ServiceStatus, 
                sizeof(SERVICE_STATUS_PROCESS), &cbBytesNeeded ) )
        {
            status = GetLastError();

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Query Service Status failed %1!u!.\n",
                status );

            goto error_exit;
        }

        if ( ServiceStatus.dwCurrentState != SERVICE_START_PENDING ) {
            break;
        }

        Sleep(dwRetryTick);
    }

    //
    // If we terminated the loop above before setting ServiceStatus,
    // then return now.
    //
    if (ClusWorkerCheckTerminate(pWorker) || (dwRetryCount == (DWORD)-1))  {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"GensvcOnlineThread: Asked to terminate or retry period expired...\n");
        // Error code choices are:
        // ERROR_PROCESS_ABORTED
        // ERROR_SERVICE_MARKED_FOR_DELETE  
        // ERROR_SERVICE_REQUEST_TIMEOUT
        // ERROR_SERVICE_START_HANG
        // I vote for ERROR_SERVICE_START_HANG
        status = ERROR_SERVICE_START_HANG;
        goto error_exit;
    }

    if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING ) {
        
        if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
            status = ServiceStatus.dwServiceSpecificExitCode;
        } else {
            status = ServiceStatus.dwWin32ExitCode;
        }

        ClusResLogSystemEventByKeyData(ResourceEntry->ResourceKey,
                                       LOG_CRITICAL,
                                       RES_GENSVC_FAILED_AFTER_START,
                                       sizeof(status),
                                       &status);

        (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Service failed during initialization. Error: %1!u!.\n",
                status );

        goto error_exit;
    }

    //
    // we're online. Let resmon know...
    //
    resourceStatus.ResourceState = ClusterResourceOnline;
    if (!(ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS)) {
        ResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
    }

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Service is now on line.\n" );

error_exit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    if ( resourceStatus.ResourceState == ClusterResourceOnline ) {
        ResourceEntry->Online = TRUE;
    } else {
        ResourceEntry->Online = FALSE;
    }

    //cleanup
    if (pSvcFailureActions) 
        LocalFree(pSvcFailureActions);
    if (lpquerysvcconfig)
        LocalFree(lpquerysvcconfig);
    LocalFree( serviceArgArray );
    if (Environment != NULL) {
        RtlDestroyEnvironment(Environment);
    }

    return(status);

} // GenSvcOnlineThread



RESID
WINAPI
GenSvcOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for generic service resource.
    This routine gets a handle to the service controller, if we don't already have one,
    and then gets a handle to the specified service.  The service handle is saved
    in the GENSVC_RESOURCE structure.

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - supplies a handle to the resource's cluster registry key

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    Zero on failure

--*/

{
    RESID   svcResid = 0;
    DWORD   status;
    HKEY    parametersKey = NULL;
    HKEY    resKey = NULL;
    PGENSVC_RESOURCE resourceEntry = NULL;
    DWORD   paramNameSize = 0;
    DWORD   paramNameMaxSize = 0;
    HCLUSTER hCluster;
    LPWSTR  nameOfPropInError;    
    LPWSTR  lpwTemp=NULL;
    DWORD   cchTempSize = 0;

    //
    // Open registry parameters key for this resource.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                CLUSREG_KEYNAME_PARAMETERS,
                                KEY_READ,
                                &parametersKey );

    if ( status != NO_ERROR ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open parameters key. Error: %1!u!.\n",
            status);
        goto error_exit;
    }

    //
    // Get a handle to our resource key so that we can get our name later
    // if we need to log an event.
    //
    status = ClusterRegOpenKey( ResourceKey,
                                L"",
                                KEY_READ,
                                &resKey);
    if (status != ERROR_SUCCESS) {
        (g_LogEvent)(ResourceHandle,
                     LOG_ERROR,
                     L"Unable to open resource key. Error: %1!u!.\n",
                     status );
        goto error_exit;
    }

    //
    // First get a handle to the service controller.
    //

    if ( g_ScHandle == NULL ) {

        g_ScHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS);

        if ( g_ScHandle == NULL ) {
            status = GetLastError();
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to open service control manager, error %1!u!.\n",
                status);
            goto error_exit;
        }
    }

    resourceEntry = LocalAlloc( LMEM_FIXED, sizeof(GENSVC_RESOURCE) );

    if ( resourceEntry == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate a service info structure.\n");
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory( resourceEntry, sizeof(GENSVC_RESOURCE) );

    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ResourceKey = resKey;
    resourceEntry->ParametersKey = parametersKey;

    status = ResUtilGetPropertiesToParameterBlock( resourceEntry->ParametersKey,
                                                   GenSvcResourcePrivateProperties,
                                                   (LPBYTE) &resourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &nameOfPropInError );

    if ( status == ERROR_SUCCESS ) {

        // Create the Semaphore - this will be executed only if this is not a new
        // GenericService Type resource being created for the first time
        cchTempSize =  (lstrlenW(resourceEntry->Params.ServiceName)+
                                lstrlenW(L"GenSvc$") + 1);
        lpwTemp = (LPWSTR)LocalAlloc(LMEM_FIXED, cchTempSize * sizeof(WCHAR) );
        if (lpwTemp==NULL)
        {
            status=GetLastError();
            (g_LogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Service '%1!ls!': Not enough memory for storing semaphore name. Error: %2!u!.\n",
                    resourceEntry->Params.ServiceName,
                    status );
            goto error_exit;
        }

        StringCchCopy(lpwTemp, cchTempSize, L"GenSvc$");
        StringCchCat(lpwTemp, cchTempSize, resourceEntry->Params.ServiceName);        

        resourceEntry->hSem=CreateSemaphore(NULL,0,1,lpwTemp); 
        status=GetLastError();
        if(resourceEntry->hSem)
        {
            // Check if there is another resource controlling the same service
            if(status==ERROR_ALREADY_EXISTS)
            {
                status = ERROR_OBJECT_ALREADY_EXISTS;
                (g_LogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"Service '%1!ls!' is controlled by another resource. Error: %2!u!.\n",
                    resourceEntry->Params.ServiceName,
                    status );
                CloseHandle(resourceEntry->hSem);
                resourceEntry->hSem = NULL;
                goto error_exit;
            }  
        }
        else
        {
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to create semaphore for Service '%1!ls!' . Error: %2!u!.\n",
                resourceEntry->Params.ServiceName,
                status );
            goto error_exit;
        }    
        
    }
    else {
        (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to read parameters from registry  for Service '%1!ls!' . Error: %2!u!, property in error is '%3!ls!' .\n",
                resourceEntry->Params.ServiceName,
                status,
                nameOfPropInError);
    }

    status = ERROR_SUCCESS;

    hCluster = OpenCluster(NULL);
    if (hCluster == NULL) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open cluster, error %1!u!.\n",
            status );
        goto error_exit;
    }

    resourceEntry->hResource = OpenClusterResource(hCluster, ResourceName);
    status = GetLastError();
    CloseCluster(hCluster);
    if ( resourceEntry->hResource == NULL ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to open resource, error %1!u!.\n", status );
        goto error_exit;
    }

    svcResid = (RESID)resourceEntry;

    if (lpwTemp) {
        LocalFree(lpwTemp);
    }

    return(svcResid);

error_exit:

    if ( parametersKey != NULL ) {
        ClusterRegCloseKey( parametersKey );
    }
    if ( resKey != NULL) {
        ClusterRegCloseKey( resKey );
    }

    if ( resourceEntry != NULL)  {
        LocalFree( resourceEntry );
    }

    if (lpwTemp) {
        LocalFree(lpwTemp);
    }

    SetLastError( status );

    return((RESID)NULL);

} // GenSvcOpen


DWORD
WINAPI
GenSvcOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Generic Service resource.

Arguments:

    ResourceId - Supplies resource id to be brought online

    EventHandle - Supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    DWORD   status;
    PGENSVC_RESOURCE resourceEntry;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: Online request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               GenSvcOnlineThread,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // GenSvcOnline


VOID
WINAPI
GenSvcTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for Generic Application resource.

Arguments:

    ResourceId - Supplies resource id to be terminated

Return Value:

    None.

--*/

{
    SERVICE_STATUS ServiceStatus;
    PGENSVC_RESOURCE resourceEntry;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: Terminate request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
       resourceEntry->ResourceHandle,
       LOG_INFORMATION,
       L"Terminate request.\n" );

#ifdef TEST_TERMINATE_ON_SHUTDOWN
    {
        DWORD   dwStatus;
        BOOLEAN fWasEnabled;

        //
        // Test terminate on shutdown code.
        //
        (g_LogEvent)(
           resourceEntry->ResourceHandle,
           LOG_ERROR,
           L"GenSvcTerminate: TEST_TERMINATE_ON_SHUTDOWN - enabling shutdown privilege.\n"
           );
        dwStatus = ClRtlEnableThreadPrivilege(
                    SE_SHUTDOWN_PRIVILEGE,
                    &fWasEnabled
                    );
        if ( dwStatus != ERROR_SUCCESS ) {
            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"GetSvcTerminate: TEST_TERMINATE_ON_SHUTDOWN - Unable to enable shutdown privilege. Error: %1!u!...\n",
                dwStatus
                );
        } else {
            AbortSystemShutdown( NULL );
            (g_LogEvent)(
               resourceEntry->ResourceHandle,
               LOG_ERROR,
               L"GenSvcTerminate: TEST_TERMINATE_ON_SHUTDOWN - initiating system shutdown.\n"
               );
            if ( ! InitiateSystemShutdown(
                        NULL,   // lpMachineName
                        L"Testing Generic Service cluster resource DLL",
                        0,      // dwTimeout
                        TRUE,   // bForceAppsClosed
                        TRUE    // bRebootAfterShutdown
                        ) ) {
                dwStatus = GetLastError();
                (g_LogEvent)(
                   resourceEntry->ResourceHandle,
                   LOG_ERROR,
                   L"GenSvcTerminate: TEST_TERMINATE_ON_SHUTDOWN - Unable to shutdown the system. Error: %1!u!.\n",
                   dwStatus
                   );
            } else {
                Sleep( 30000 );
            }
            ClRtlRestoreThreadPrivilege(
                SE_SHUTDOWN_PRIVILEGE,
                fWasEnabled
                );
        }
    }
#endif

    //if there is a pending thread close it
    //if the online pending thread is active, the service may be online
    //if the offline pending thread is active, the service might be offline
    ClusWorkerTerminate( &resourceEntry->PendingThread );

    //if the service isnt gone by now, terminate it forcibly
    if ( resourceEntry->ServiceHandle != NULL ) 
    {
        DWORD   dwRetryCount= 100;
        BOOL    didStop = FALSE;
        DWORD   dwRetryTick = 300;      // 300 msec at a time
        DWORD   dwStatus;  

            
        while (dwRetryCount--)
        {

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"GenSvcTerminate : calling SCM (didStop=%1!d!)\n",
                didStop
                );

            dwStatus = (ControlService(
                            resourceEntry->ServiceHandle,
                            (didStop
                             ? SERVICE_CONTROL_INTERROGATE
                             : SERVICE_CONTROL_STOP),
                            &ServiceStatus )
                      ? NO_ERROR
                      : GetLastError());

            if (dwStatus == NO_ERROR) 
            {
                didStop = TRUE;
                if (ServiceStatus.dwCurrentState == SERVICE_STOPPED)
                {

                    (g_LogEvent)(
                        resourceEntry->ResourceHandle,
                        LOG_INFORMATION,
                        L"Service stopped.\n" );

                    //set the status                                    
                    resourceEntry->Online = FALSE;
                    resourceEntry->dwServicePid = 0;
                    break;
                }
            }

            // 
            //  Chittur Subbaraman (chitturs) - 2/21/2000
            //
            //  Since SCM doesn't accept any control requests during
            //  windows shutdown, don't send any more control
            //  requests. Just exit from this loop and terminate
            //  the process brute force.
            //
            if ( dwStatus == ERROR_SHUTDOWN_IN_PROGRESS )
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"System shutdown in progress. Will try to terminate process brute force...\n" );
                break;
            }

            if (dwStatus == ERROR_EXCEPTION_IN_SERVICE ||
                dwStatus == ERROR_PROCESS_ABORTED ||
                dwStatus == ERROR_SERVICE_NOT_ACTIVE) 
            {
                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service died; status = %1!u!.\n",
                    dwStatus);
                
                //set the status                                    
                resourceEntry->Online = FALSE;
                resourceEntry->dwServicePid = 0;
                break;
            }

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"GenSvcTerminate: retrying...\n" );

            Sleep(dwRetryTick);

        }
        //declare this service is offline
        //if there is a pid for this, try and terminate that process
        //note that terminating a process doesnt terminate all
        //the child processes
        //also if it is running in a system process, we do nothing
        //about it
        if (resourceEntry->dwServicePid)
        {
            DWORD dwResourceState;

            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"GenSvcTerminate: Attempting to terminate process with pid=%1!u!...\n",
                resourceEntry->dwServicePid );

            ResUtilTerminateServiceProcessFromResDll( resourceEntry->dwServicePid,
                                                      FALSE, // bOffline
                                                      &dwResourceState,
                                                      g_LogEvent,
                                                      resourceEntry->ResourceHandle );
        }                

        CloseServiceHandle( resourceEntry->ServiceHandle );
        resourceEntry->ServiceHandle = NULL;
        resourceEntry->dwServicePid = 0;
    }

    //
    // finally, clean up the Environment key for this service if we were
    // substituting the netname for the hostname.
    //
    if ( resourceEntry->Params.UseNetworkName ) 
    {
        ResUtilRemoveResourceServiceEnvironment(resourceEntry->Params.ServiceName,
                                                g_LogEvent,
                                                resourceEntry->ResourceHandle);
    }

    resourceEntry->Online = FALSE;

    return;

} // GenSvcTerminate



DWORD
WINAPI
GenSvcOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for Generic Service resource.

Arguments:

    ResourceId - Supplies the resource to be taken offline

Return Value:

    ERROR_SUCCESS - always successful.

--*/

{
    PGENSVC_RESOURCE resourceEntry;
    DWORD            status;
    
    resourceEntry = (PGENSVC_RESOURCE)ResourceId;
    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: Offline request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    ClusWorkerTerminate( &resourceEntry->PendingThread );
    status = ClusWorkerCreate( &resourceEntry->PendingThread,
                               GenSvcOfflineThread,
                               resourceEntry );

    if ( status == ERROR_SUCCESS ) {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // GenSvcOffline


DWORD
GenSvcOfflineThread(
    PCLUS_WORKER pWorker,
    IN PGENSVC_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Brings a generic resource offline

Arguments:

    Worker - Supplies the worker structure

    Context - A pointer to the DiskInfo block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/
{
    RESOURCE_STATUS resourceStatus;
    DWORD           retryTick = 300;      // 300 msec at a time
    DWORD           status = ERROR_SUCCESS;
    BOOL            didStop = FALSE;
    SERVICE_STATUS  ServiceStatus;
    DWORD           dwRetryCount = 2000; //  Try 10 min max.

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    //check if the service has gone offline or was never brought online
    if ( ResourceEntry->ServiceHandle == NULL )
    {
        resourceStatus.ResourceState = ClusterResourceOffline;
        goto FnExit;
    }

    //try to stop the target service. wait for it to be terminated
    //as long as we are not asked to terminate
    while (!ClusWorkerCheckTerminate(pWorker) && dwRetryCount--) {


        //
        // Tell the Resource Monitor that we are still working.
        //
        resourceStatus.ResourceState = ClusterResourceOfflinePending;
        resourceStatus.CheckPoint++;
        (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                               &resourceStatus );
        resourceStatus.ResourceState = ClusterResourceFailed;

        //
        // Request that the service be stopped, or if we already did that,
        // request the current status of the service.
        //
        status = (ControlService(
                        ResourceEntry->ServiceHandle,
                        (didStop
                         ? SERVICE_CONTROL_INTERROGATE
                         : SERVICE_CONTROL_STOP),
                        &ServiceStatus )
                  ? NO_ERROR
                  : GetLastError());

        if (status == NO_ERROR) {

            didStop = TRUE;

            if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {

                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service stopped.\n" );

                //set the status                                    
                ResourceEntry->Online = FALSE;
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Service is now offline.\n" );
                break;
            }
        }

        if (status == ERROR_EXCEPTION_IN_SERVICE ||
            status == ERROR_PROCESS_ABORTED ||
            status == ERROR_SERVICE_NOT_ACTIVE) {

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service died or not active any more; status = %1!u!.\n",
                status);
                
            //set the status                                    
            ResourceEntry->Online = FALSE;
            resourceStatus.ResourceState = ClusterResourceOffline;
            CloseServiceHandle( ResourceEntry->ServiceHandle );
            ResourceEntry->ServiceHandle = NULL;
            ResourceEntry->dwServicePid = 0;
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Service is now offline.\n" );
            break;

        }

        //
        //  Chittur Subbaraman (chitturs) - 2/21/2000
        //
        //  Handle the case in which the SCM refuses to accept control
        //  requests since windows is shutting down.
        //
        if ( status == ERROR_SHUTDOWN_IN_PROGRESS ) 
        {
            DWORD   dwResourceState;
            
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"GenSvcOfflineThread: System shutting down. Attempt to terminate service process %1!u!...\n",
                ResourceEntry->dwServicePid );

            status = ResUtilTerminateServiceProcessFromResDll( ResourceEntry->dwServicePid,
                                                               TRUE, // bOffline
                                                               &dwResourceState,
                                                               g_LogEvent,
                                                               ResourceEntry->ResourceHandle );
            if ( status == ERROR_SUCCESS )
            {
                CloseServiceHandle( ResourceEntry->ServiceHandle );
                ResourceEntry->ServiceHandle = NULL;
                ResourceEntry->dwServicePid = 0;
                ResourceEntry->Online = FALSE;
            }
            resourceStatus.ResourceState = dwResourceState;
            break;            
        }
        
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Offline: retrying...\n" );

        Sleep(retryTick);
    }

    //
    // clean up the netname Environment in the registry if necessary
    //
    if ( ResourceEntry->Params.UseNetworkName ) 
    {
        ResUtilRemoveResourceServiceEnvironment(ResourceEntry->Params.ServiceName,
                                                g_LogEvent,
                                                ResourceEntry->ResourceHandle);
    }

FnExit:
    (g_SetResourceStatus)( ResourceEntry->ResourceHandle,
                           &resourceStatus );

    return(status);

} // GenSvcOfflineThread


BOOL
WINAPI
GenSvcIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Generic service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - if service is running

    FALSE - if service is in any other state

--*/
{
    return( VerifyService( ResourceId, TRUE ) );

} // GenSvcIsAlive


BOOL
VerifyService(
    IN RESID ResourceId,
    IN BOOL IsAliveFlag
    )

/*++

Routine Description:

        Verify that a specified service is running

Arguments:

        ResourceId - Supplies the resource id
        IsAliveFlag - Says this is an IsAlive call - used only for debug print

Return Value:

        TRUE - if service is running or starting

        FALSE - service is in any other state

--*/
{
    SERVICE_STATUS ServiceStatus;
    PGENSVC_RESOURCE resourceEntry;
    DWORD   status = TRUE;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: IsAlive request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(FALSE);
    }

#ifdef TEST_TERMINATE_ON_SHUTDOWN
    //
    // Test terminate on shutdown.
    //
    if ( IsAliveFlag ) {
         (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"GenSvcIsAlive: TEST_TERMINATE_ON_SHUTDOWN - Artificially failing IsAlive call.\n",
            GetLastError() );
        return FALSE;
    }
#endif

    if ( !QueryServiceStatus( resourceEntry->ServiceHandle,
                              &ServiceStatus ) ) {

         (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Query Service Status failed %1!u!.\n",
            GetLastError() );
         return(FALSE);
    }

    //
    //  Now check the status of the service
    //

    if ( (ServiceStatus.dwCurrentState != SERVICE_RUNNING) &&
         (ServiceStatus.dwCurrentState != SERVICE_START_PENDING) ) {
        status = FALSE;
    }

    if (!status) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed the IsAlive test. Current State is %1!u!.\n",
            ServiceStatus.dwCurrentState );
    }

    return(status);

} // Verify Service


BOOL
WINAPI
GenSvcLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Generic Service resource.

Arguments:

    ResourceId - Supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{

    return( VerifyService( ResourceId, FALSE ) );

} // GenSvcLooksAlive



VOID
WINAPI
GenSvcClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Generic Applications resource.
    This routine will stop the service, and delete the cluster
    information regarding that service.

Arguments:

    ResourceId - Supplies resource id to be closed

Return Value:

    None.

--*/

{
    PGENSVC_RESOURCE resourceEntry;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );

    //
    // Shut it down if it's on line
    //

    GenSvcTerminate( ResourceId );

    ResUtilFreeParameterBlock( (LPBYTE) &(resourceEntry->Params), 
                               NULL,
                               GenSvcResourcePrivateProperties );

    ClusterRegCloseKey( resourceEntry->ParametersKey );
    ClusterRegCloseKey( resourceEntry->ResourceKey );
    CloseClusterResource( resourceEntry->hResource );
    CloseHandle(resourceEntry->hSem);

    LocalFree( resourceEntry );

} // GenSvcClose

//
// Following logic stolen from the CRTs so that our command line parsing
// works the same as the standard CRT parsing.
//
void
wparse_cmdline (
    WCHAR *cmdstart,
    WCHAR **argv,
    WCHAR *args,
    int *numargs,
    int *numchars
    )
{
    WCHAR *p;
    WCHAR c;
    int inquote;                /* 1 = inside quotes */
    int copychar;               /* 1 = copy char to *args */
    unsigned numslash;                  /* num of backslashes seen */

    *numchars = 0;
    *numargs = 0;

    p = cmdstart;

    inquote = 0;

    /* loop on each argument */
    for(;;) {

        if ( *p ) {
            while (*p == L' ' || *p == L'\t')
                ++p;
        }

        if (*p == L'\0')
            break;              /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = args;     /* store ptr to arg */
        ++*numargs;


    /* loop through scanning one argument */
        for (;;) {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
               2N+1 backslashes + " ==> N backslashes + literal "
               N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == L'\\') {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == L'\"') {
                /* if 2N backslashes before, start/end quote, otherwise
                    copy literally */
                if (numslash % 2 == 0) {
                    if (inquote) {
                        if (p[1] == L'\"')
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    } else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--) {
                if (args)
                    *args++ = L'\\';
                ++*numchars;
            }

            /* if at end of arg, break loop */
            if (*p == L'\0' || (!inquote && (*p == L' ' || *p == L'\t')))
                break;

            /* copy character into argument */
            if (copychar) {
                if (args)
                    *args++ = *p;
                ++*numchars;
            }
            ++p;
        }

        /* null-terminate the argument */

        if (args)
            *args++ = L'\0';          /* terminate string */
        ++*numchars;
    }

} // wparse_cmdline



DWORD
GenSvcResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Generic Service resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PGENSVC_RESOURCE    resourceEntry;
    DWORD               required;

    resourceEntry = (PGENSVC_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "GenSvc: ResourceControl request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(FALSE);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenSvcResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenSvcResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = GenSvcGetPrivateResProperties( resourceEntry,
                                                    OutBuffer,
                                                    OutBufferSize,
                                                    BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = GenSvcValidatePrivateResProperties( resourceEntry,
                                                         InBuffer,
                                                         InBufferSize,
                                                         NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = GenSvcSetPrivateResProperties( resourceEntry,
                                                    InBuffer,
                                                    InBufferSize );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenSvcResourceControl



DWORD
GenSvcResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Generic Service resources.

    Perform the control request specified by ControlCode on this resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( GenSvcResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( GenSvcResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // GenSvcResourceTypeControl



DWORD
GenSvcGetPrivateResProperties(
    IN const PGENSVC_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type Generic Service.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      GenSvcResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // GenSvcGetPrivateResProperties



DWORD
GenSvcValidatePrivateResProperties(
    IN const PGENSVC_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PGENSVC_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Generic Service.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    ERROR_DEPENDENCY_NOT_FOUND - Trying to set UseNetworkName when there
        is no dependency on a Network Name resource.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENSVC_PARAMS   currentProps;
    GENSVC_PARAMS   newProps;
    PGENSVC_PARAMS  pParams = NULL;
    BOOL            hResDependency;
    LPWSTR          lpwTemp=NULL;
    DWORD           cchTempSize = 0;
    LPWSTR          nameOfPropInError;
    WCHAR           netnameBuffer[ MAX_PATH + 1 ];
    DWORD           netnameBufferSize = sizeof( netnameBuffer ) / sizeof( WCHAR );

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Retrieve the current set of private properties from the
    // cluster database.
    //
    ZeroMemory( &currentProps, sizeof(currentProps) );

    status = ResUtilGetPropertiesToParameterBlock(
                 ResourceEntry->ParametersKey,
                 GenSvcResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1!ls!' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status
            );
        goto FnExit;
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &newProps;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(GENSVC_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &currentProps,
                                       GenSvcResourcePrivateProperties
                                       );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( GenSvcResourcePrivateProperties,
                                         NULL,
                                         TRUE,    // Allow unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams
                                         );
    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //
    // Validate the parameter values.
    //
    status = GenSvcIsValidService( ResourceEntry, pParams->ServiceName );
    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }

    //
    // If the resource should use the network name as the computer
    // name, make sure there is a dependency on a Network Name
    // resource.
    //
    if ( pParams->UseNetworkName ) {
        hResDependency = GetClusterResourceNetworkName( ResourceEntry->hResource,
                                                        netnameBuffer,
                                                        &netnameBufferSize
                                                        );
        if ( ! hResDependency ) {
            status = ERROR_DEPENDENCY_NOT_FOUND;
        }
    }

    if ( status != ERROR_SUCCESS ) {
        goto FnExit;
    }


    if ( ResourceEntry->hSem == NULL ) {
        // This is executed only if this is a new resource being created
        cchTempSize =  (lstrlenW(pParams->ServiceName) +
                                lstrlenW(L"GenSvc$") + 1);
        lpwTemp = (LPWSTR)LocalAlloc(LMEM_FIXED, cchTempSize * sizeof(WCHAR) );
        if ( lpwTemp == NULL ) {
            status = GetLastError();
            (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Service '%1!ls!': Not enough memory for storing semaphore name. Error: %2!u!.\n",
                    pParams->ServiceName,
                    status
                    );
            goto FnExit;
        }
        StringCchCopy(lpwTemp, cchTempSize, L"GenSvc$");
        StringCchCat(lpwTemp, cchTempSize, pParams->ServiceName);        
        
        ResourceEntry->hSem = CreateSemaphore( NULL, 0, 1,lpwTemp );
        status=GetLastError();
    
        if ( ResourceEntry->hSem ) {
            // Check if there is another resource controlling the same service
            if ( status == ERROR_ALREADY_EXISTS ) {   
                status = ERROR_OBJECT_ALREADY_EXISTS;
                (g_LogEvent)(
                    ResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Service '%1!ls!' is controlled by another resource. Error: %2!u!.\n",
                    pParams->ServiceName,
                    status
                    );
                CloseHandle( ResourceEntry->hSem );
                ResourceEntry->hSem = NULL;
                goto FnExit;
            }
        } else {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"SetPrivateProperties: Unable to create Semaphore %1!ls! for Service '%2!ls!' . Error: %3!u!.\n",
                lpwTemp,
                pParams->ServiceName,
                status
                );
            goto FnExit;
        }
    }

FnExit:
    //
    // Cleanup our parameter block.
    //
    if (   (   (status != ERROR_SUCCESS)
            && (pParams != NULL) )
        || ( pParams == &newProps )
        ) {
        ResUtilFreeParameterBlock( (LPBYTE) pParams,
                                   (LPBYTE) &currentProps,
                                   GenSvcResourcePrivateProperties
                                   );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        GenSvcResourcePrivateProperties
        );

    if ( lpwTemp ) {
        LocalFree( lpwTemp );
    }

    return(status);

} // GenSvcValidatePrivateResProperties



DWORD
GenSvcSetPrivateResProperties(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Generic Service.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    GENSVC_PARAMS   params;

    ZeroMemory( &params, sizeof(GENSVC_PARAMS) );

    //
    // Parse and validate the properties.
    //
    status = GenSvcValidatePrivateResProperties( ResourceEntry,
                                                 InBuffer,
                                                 InBufferSize,
                                                 &params );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               GenSvcResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );
  


    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               GenSvcResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    if (status == ERROR_SUCCESS) {
        if ( ResourceEntry->Online ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // GenSvcSetPrivateResProperties

DWORD
GenSvcIsValidService(
    IN OUT PGENSVC_RESOURCE ResourceEntry,
    IN LPCWSTR ServiceName
    )

/*++

Routine Description:

    Determines if the specified service is a valid service or not.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    ServiceName - Service name to verify.

Return Value:

    ERROR_SUCCESS - Service is valid for a Generic Service resource.

    Any status returned by OpenSCManager(), OpenService(), or
    GenSvcInvalidGenericServiceCheck.

--*/

{
    DWORD   status;
    HANDLE  scManagerHandle;
    HANDLE  serviceHandle;

    scManagerHandle = OpenSCManager( NULL,        // local machine
                                     NULL,        // ServicesActive database
                                     SC_MANAGER_ALL_ACCESS ); // all access

    if ( scManagerHandle == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Cannot access service controller for validating service '%1!ws!'. Error: %2!u!....\n",
            ServiceName,
            status
            );
        return(status);
    }

    serviceHandle = OpenService( scManagerHandle,
                                 ServiceName,
                                 GENERIC_READ );

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Cannot open service '%1!ws!'. Error: %2!u!....\n",
            ServiceName,
            status
            );
    } else {
        status = GenSvcCheckInvalidService( ResourceEntry, ServiceName, TEXT ( "clussvc" ), scManagerHandle );

        if ( status == ERROR_NOT_SUPPORTED )
        {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Service %1!ws! is a possible provider of clussvc, so %1!ws! cannot be gensvc resource, status %2!u!\n",
                ServiceName,
                status
                );
        }
    }

    CloseServiceHandle( serviceHandle );
    CloseServiceHandle( scManagerHandle );
    return(status);

} // GenSvcIsValidService

DWORD
GenSvcCheckInvalidService(
    IN PGENSVC_RESOURCE pGenSvcCandidateResourceEntry,
    IN LPCWSTR pGenSvcCandidateServiceName,
    IN LPCWSTR pCheckedServiceName,
    IN SC_HANDLE hSCManager
    )

/*++

Routine Description:

    Determines if the specified service is an invalid service for
    use as a generic service.  Invalid services include the cluster
    service and any services upon which it depends.

Arguments:

    pGenSvcCandidateResourceEntry - Supplies the resource entry of the gensvc candidate.

    pGenSvcCandidateServiceName - Gensvc candidate service name.

    pCheckedServiceName - The name of the service whose provider list is checked.

    hSCManager - An open handle to the SC manager.

Return Value:

    ERROR_SUCCESS - Service is valid for a Generic Service resource.

    ERROR_NOT_SUPPORTED - Service can not be used for a Generic Service resource.

--*/

{
    DWORD                           dwStatus = ERROR_SUCCESS;
    DWORD                           cbServiceConfig;
    LPQUERY_SERVICE_CONFIG          pServiceConfig = NULL;
    LPWSTR                          pCurrentProvider = NULL;
    SC_HANDLE                       hService = NULL;
    LPENUM_SERVICE_STATUS_PROCESS   pEnumInfo = NULL;

    //
    //  First check the gensvc candidate against the checked service itself.
    //
    if ( lstrcmpi ( pGenSvcCandidateServiceName, pCheckedServiceName ) == 0 )
    {
        dwStatus = ERROR_NOT_SUPPORTED;
        goto FnExit;
    }

    //
    //  Get a handle to the service that is checked.
    //
    hService = OpenService ( hSCManager,
                             pCheckedServiceName,
                             SERVICE_QUERY_CONFIG );

    if ( hService == NULL )
    {
        dwStatus = GetLastError();
        (g_LogEvent)(
            pGenSvcCandidateResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to open service %1!ws! for querying config, status %2!u!\n",
            pCheckedServiceName,
            dwStatus
            );
        goto FnExit;
    }
    
    //
    //  Query the configuration info of the service to get the total config info size
    //
    if ( !QueryServiceConfig ( hService,
                               NULL,
                               0,
                               &cbServiceConfig ) )
    {
        dwStatus = GetLastError();

        if ( dwStatus != ERROR_INSUFFICIENT_BUFFER )
        {
            (g_LogEvent)(
                pGenSvcCandidateResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to query config info of service %1!ws! for config size, status %2!u!\n",
                pCheckedServiceName,
                dwStatus
                );
            goto FnExit;
        }
        dwStatus = ERROR_SUCCESS;
    }

    pServiceConfig = LocalAlloc ( LMEM_FIXED, cbServiceConfig );

    if ( pServiceConfig == NULL )
    {
        dwStatus = GetLastError();
        (g_LogEvent)(
            pGenSvcCandidateResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to alloc memory for service %1!ws! config, status %2!u!\n",
            pCheckedServiceName,
            dwStatus
            );
        goto FnExit;
    }

    //
    //  Now get the config info
    //
    if ( !QueryServiceConfig ( hService,
                               pServiceConfig,
                               cbServiceConfig,
                               &cbServiceConfig ) )
    {
        dwStatus = GetLastError();
        (g_LogEvent)(
            pGenSvcCandidateResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to query config info of service %1!ws!, status %2!u!\n",
            pCheckedServiceName,
            dwStatus
            );
        goto FnExit;
    }

    pCurrentProvider = pServiceConfig->lpDependencies;

    //
    //  No dependencies, bail.
    //
    if ( pCurrentProvider == NULL )
    {
        dwStatus = ERROR_SUCCESS;
        goto FnExit;
    }

    //
    //  Walk the provider list
    //
    while ( *pCurrentProvider != UNICODE_NULL )
    {
        //
        //  The service depends on a group. Enumerate the services in the group and check
        //  if the gensvc candidate is one of them or one of the providers of the group
        //  members.
        //
        if ( pCurrentProvider[0] == SC_GROUP_IDENTIFIER )
        {
            DWORD  i, cbStatusBuffer, cServices, dwResumeIndex = 0;
            
            if ( !EnumServicesStatusEx ( hSCManager,
                                         SC_ENUM_PROCESS_INFO,
                                         SERVICE_DRIVER | SERVICE_WIN32,
                                         SERVICE_STATE_ALL,
                                         NULL,
                                         0,
                                         &cbStatusBuffer,
                                         &cServices,    // Number of services in the group
                                         &dwResumeIndex,
                                         &pCurrentProvider[1] ) ) // group name
            {
                dwStatus = GetLastError ();
                if ( dwStatus != ERROR_MORE_DATA )
                {
                    (g_LogEvent)(
                        pGenSvcCandidateResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Unable to enum status of services in group %1!ws! for status size, status %2!u!\n",
                        &pCurrentProvider[1],
                        dwStatus
                        );
                    goto FnExit;
                }
                dwStatus = ERROR_SUCCESS; 
                dwResumeIndex = 0;
            }

            pEnumInfo = LocalAlloc ( LMEM_FIXED, cbStatusBuffer );

            if ( pEnumInfo == NULL )
            {
                dwStatus = GetLastError ();
                (g_LogEvent)(
                    pGenSvcCandidateResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Unable to alloc memory for status of services in group %1!ws!, status %2!u!\n",
                    &pCurrentProvider[1],
                    dwStatus
                    );
                goto FnExit;
            }

            if ( !EnumServicesStatusEx ( hSCManager,
                                         SC_ENUM_PROCESS_INFO,
                                         SERVICE_DRIVER | SERVICE_WIN32,
                                         SERVICE_STATE_ALL,
                                         ( LPBYTE ) pEnumInfo,
                                         cbStatusBuffer,
                                         &cbStatusBuffer,
                                         &cServices,    // Number of services in the group
                                         &dwResumeIndex,
                                         &pCurrentProvider[1] ) ) // group name
            {
                dwStatus = GetLastError ();
                (g_LogEvent)(
                    pGenSvcCandidateResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Unable to enum status of services in group %1!ws!, status %2!u!\n",
                    &pCurrentProvider[1],
                    dwStatus
                    );
                goto FnExit;
            }

            //
            //  Walk the list of services in the group and check each one and its providers for
            //  a match against the gensvc candidate.
            //
            for ( i=0; i<cServices; i++ )
            {
                dwStatus = GenSvcCheckInvalidService( pGenSvcCandidateResourceEntry,
                                                      pGenSvcCandidateServiceName,
                                                      pEnumInfo[i].lpServiceName,
                                                      hSCManager );
                if ( dwStatus != ERROR_SUCCESS )
                {
                    if ( dwStatus == ERROR_NOT_SUPPORTED )
                    {
                        (g_LogEvent)(
                            pGenSvcCandidateResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"Service %1!ws! (group %2!ws!) is a provider of %3!ws!, so %1!ws! cannot be gensvc resource, status %4!u!\n",
                            pGenSvcCandidateServiceName,
                            &pCurrentProvider[1],
                            pCheckedServiceName,
                            dwStatus
                            );
                    }
                    goto FnExit;
                }
            }

            LocalFree ( pEnumInfo );
            pEnumInfo = NULL;
            
            pCurrentProvider += lstrlen ( pCurrentProvider ) + 1;
            continue;
        }

        //
        //  Check the provider list of the provider service and see if the candidate service
        //  name is present in the list.
        //
        dwStatus = GenSvcCheckInvalidService( pGenSvcCandidateResourceEntry,
                                              pGenSvcCandidateServiceName,
                                              pCurrentProvider,
                                              hSCManager );

        if ( dwStatus != ERROR_SUCCESS )
        {
            if ( dwStatus == ERROR_NOT_SUPPORTED )
            {
                (g_LogEvent)(
                    pGenSvcCandidateResourceEntry->ResourceHandle,
                    LOG_ERROR,
                    L"Service %1!ws! is a provider of %2!ws!, so %1!ws! cannot be gensvc resource, status %3!u!\n",
                    pGenSvcCandidateServiceName,
                    pCheckedServiceName,
                    dwStatus
                    );
            }
            goto FnExit;
        }
        pCurrentProvider += lstrlen ( pCurrentProvider ) + 1;
    }// while
    
FnExit:
    if ( hService ) CloseServiceHandle ( hService );
    LocalFree ( pServiceConfig );
    LocalFree ( pEnumInfo );
    return ( dwStatus );
} // GenSvcCheckInvalidService

//***********************************************************
//
// Define Function Table
//
//***********************************************************


CLRES_V1_FUNCTION_TABLE( GenSvcFunctionTable,  // Name
                         CLRES_VERSION_V1_00,  // Version
                         GenSvc,               // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         GenSvcResourceControl,// ResControl
                         GenSvcResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\resourceobject.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2003 Microsoft Corporation
//
//  Module Name:
//      ResourceObject.h
//
//  Description:
//      Interface for the CResourceObject class.
//
//  Maintained By:
//      Ozan Ozhan  (OzanO)     27-MAR-2002
//      Geoff Pease (GPease)    08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CResourceObject :
    public IDispatchEx
{
private:
    LONG m_cRef;

    RESOURCE_HANDLE     m_hResource;        
    PLOG_EVENT_ROUTINE  m_pler;
    HKEY                m_hkey;
    LPCWSTR             m_pszName;  // DON'T FREE

private:
    STDMETHOD(LogInformation)( BSTR bstrIn );
    STDMETHOD(ReadPrivateProperty)( DISPID idIn, VARIANT * pvarResOut );
    STDMETHOD(WritePrivateProperty)( DISPID idIn, DISPPARAMS * pdpIn );
    STDMETHOD(AddPrivateProperty)( DISPPARAMS * pdpIn );
    STDMETHOD(RemovePrivateProperty)( DISPPARAMS * pdpIn );
    STDMETHOD(PrivatePropertyExists)( DISPPARAMS * pdpIn );

    STDMETHOD(LogError)( HRESULT hrIn );

public:
    explicit CResourceObject( RESOURCE_HANDLE     hResourceIn,
                              PLOG_EVENT_ROUTINE  plerIn, 
                              HKEY                hkeyIn,
                              LPCWSTR             pszNameIn
                              );
    virtual ~CResourceObject();

    // IUnknown
    STDMETHOD( QueryInterface )(
        REFIID riid,
        void ** ppUnk );
    STDMETHOD_(ULONG, AddRef )( );
    STDMETHOD_(ULONG, Release )( );

    // IDispatch
    STDMETHOD( GetTypeInfoCount )( 
            /* [out] */ UINT __RPC_FAR *pctinfo );        
    STDMETHOD( GetTypeInfo )( 
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo );        
    STDMETHOD( GetIDsOfNames )( 
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId );        
    STDMETHOD( Invoke )( 
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr );
 
    // IDispatchEx
    STDMETHOD( GetDispID )( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid );        
    STDMETHOD( InvokeEx )( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller );        
    STDMETHOD( DeleteMemberByName )( 
            /* [in] */ BSTR bstr,
            /* [in] */ DWORD grfdex );        
    STDMETHOD( DeleteMemberByDispID )( 
            /* [in] */ DISPID id );        
    STDMETHOD( GetMemberProperties )( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex );        
    STDMETHOD( GetMemberName )( 
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName );        
    STDMETHOD( GetNextDispID )( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid );        
    STDMETHOD( GetNameSpaceParent )( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\genscript\scriptresource.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      ScriptResource.h
//
//  Description:
//      CScriptResource class header file.
//
//  Maintained By:
//      ozano   15-NOV-2002
//      gpease 14-DEC-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// Forward declarations
//
class CScriptResource;

//
// Message types.
//
typedef enum _EMESSAGE 
{
      msgUNKNOWN = 0
    , msgOPEN
    , msgCLOSE
    , msgONLINE
    , msgOFFLINE
    , msgTERMINATE
    , msgLOOKSALIVE
    , msgISALIVE
    , msgSETPRIVATEPROPERTIES
    , msgDIE
    , msgMAX
} EMESSAGE;

//
// Mapping of message types to strings.  Ordering is based on the order of the
// EMESSAGE enumeration.
//
static WCHAR * g_rgpszScriptEntryPointNames[] = 
{
      L"<unknown>"
    , L"Open"
    , L"Close"
    , L"Online"
    , L"Offline"
    , L"Terminate"
    , L"LooksAlive"
    , L"IsAlive"
    , L"SetPrivateProperties"
    , L"<unknown>"
    , L"<unknown>"
};


//
// CreateInstance
//
CScriptResource *
CScriptResource_CreateInstance( 
    LPCWSTR pszNameIn, 
    HKEY hkeyIn, 
    RESOURCE_HANDLE hResourceIn
    );

//
// Class CScriptResource
//
class
CScriptResource :
    public IUnknown
{
private:    // data
    LONG                    m_cRef;

    LPWSTR                  m_pszName;
    LPWSTR                  m_pszScriptFilePath;
    LPWSTR                  m_pszScriptEngine;
    LPWSTR                  m_pszHangEntryPoint;
    HKEY                    m_hkeyParams;
    HKEY                    m_hkeyResource;
    IActiveScriptSite *     m_pass;
    IDispatch *             m_pidm;
    IActiveScriptParse *    m_pasp;
    IActiveScript *         m_pas;

    HANDLE                  m_hThread;
    DWORD                   m_dwThreadId;
    HANDLE                  m_hEventWait;
    HANDLE                  m_hEventDone;
    LONG                    m_lockSerialize;
    HANDLE                  m_hScriptFile;
    DWORD                   m_dwPendingTimeout;
    BOOL                    m_fPendingTimeoutChanged;


    EMESSAGE                m_msg;              // Task to do.
    EMESSAGE                m_msgLastExecuted;  // Last executed entry point; used in telling us where the potential hang is in the script.
    PGENSCRIPT_PROPS        m_pProps;           // Property table for generic script resource.
    HRESULT                 m_hr;               // Result of doing m_msg.

    // the following don't need to be freed, closed or released.
    RESOURCE_HANDLE         m_hResource;

    DISPID                  m_dispidOpen;
    DISPID                  m_dispidClose;
    DISPID                  m_dispidOnline;
    DISPID                  m_dispidOffline;
    DISPID                  m_dispidTerminate;
    DISPID                  m_dispidLooksAlive;
    DISPID                  m_dispidIsAlive;

    BOOL                    m_fLastLooksAlive;
    BOOL                    m_fHangDetected;

private:    // methods
    CScriptResource( void );
    ~CScriptResource( void );
    HRESULT HrInit(
                  LPCWSTR pszNameIn
                , HKEY hkeyIn
                , RESOURCE_HANDLE hResourceIn
                );
    HRESULT HrMakeScriptEngineAssociation( void );
    HRESULT HrGetScriptFilePath( void );
    HRESULT HrGetDispIDs( void );
    HRESULT HrProcessResult( VARIANT varResultIn, EMESSAGE  msgIn );
    HRESULT HrSetHangEntryPoint( void );
    HRESULT HrInvoke( DISPID dispidIn, EMESSAGE  msgIn, VARIANT * pvarInout = NULL, BOOL fRequiredIn = FALSE );
    DWORD   ScTranslateVariantReturnValue( VARIANT varResultIn, VARTYPE vTypeIn );
    DWORD   DwGetResourcePendingTimeout( void );

    HRESULT HrLoadScriptFile( void );
    HRESULT HrLoadScriptEngine( void );
    void UnloadScriptFile( void );    
    void UnloadScriptEngine( void );
    void LogHangMode( EMESSAGE msgIn );
    
    static DWORD WINAPI S_ThreadProc( LPVOID pParam );

    STDMETHOD(LogError)( HRESULT hrIn, LPCWSTR pszPrefixIn );
    STDMETHOD(LogScriptError)( EXCEPINFO ei );

    HRESULT OnOpen( void );
    HRESULT OnClose( void );
    HRESULT OnOnline( void );
    HRESULT OnOffline( void );
    HRESULT OnTerminate( void );
    HRESULT OnLooksAlive( void );
    HRESULT OnIsAlive( void );
    DWORD OnSetPrivateProperties( PGENSCRIPT_PROPS pProps );

    HRESULT WaitForMessageToComplete(
                  EMESSAGE  msgIn
                , PGENSCRIPT_PROPS pProps = NULL
                );

public:     // methods
    friend CScriptResource *
        CScriptResource_CreateInstance( LPCWSTR pszNameIn, 
                                        HKEY hkeyIn, 
                                        RESOURCE_HANDLE hResourceIn
                                        );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)( void );
    STDMETHOD_(ULONG, Release)( void );

    // Publics
    STDMETHOD(Open)( void );
    STDMETHOD(Close)( void );
    STDMETHOD(Online)( void );
    STDMETHOD(Offline)( void );
    STDMETHOD(Terminate)( void );
    STDMETHOD(LooksAlive)( void );
    STDMETHOD(IsAlive)( void );
    DWORD SetPrivateProperties( PGENSCRIPT_PROPS pProps );

    HKEY GetRegistryParametersKey( void )
    {
        return m_hkeyParams;

    } //*** CScriptResource::GetRegistryParametersKey
 
    RESOURCE_HANDLE GetResourceHandle( void )
    {
        return m_hResource;
        
    } //*** CScriptResource::SetResourcePendingTimeout

    void SetResourcePendingTimeoutChanged( BOOL fChanged )
    {
        m_fPendingTimeoutChanged = fChanged;
        
    } //*** CScriptResource::SetResourcePendingTimeout

}; //*** class CScriptResource
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\inc\clusres.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    clusres.h

Abstract:

    Common Resource DLL Header

Author:

    John Vert (jvert) 12/15/1996

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "clusudef.h"
#include "clusapi.h"
#include "resapi.h"
#include "clusvmsg.h"


#define LOCAL_SERVICES  L"System\\CurrentControlSet\\Services"

#define CLUSRES_MODULE_NAME L"clusres.dll"

#ifdef __cplusplus
extern "C" {
#endif

extern PLOG_EVENT_ROUTINE ClusResLogEvent;
extern PSET_RESOURCE_STATUS_ROUTINE ClusResSetResourceStatus;

//
// Cluster Resource Specific routines
//

DWORD
ClusResOpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    );

NTSTATUS
ClusResDoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    );

LPWSTR
ClusResLoadMessage(
    DWORD   MessageID
    );

//
// Helpful macros for logging cluster service events
//
VOID
ClusResLogEventWithName0(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );

VOID
ClusResLogEventWithName1(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    );

VOID
ClusResLogEventWithName2(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    );

VOID
ClusResLogEventWithName3(
    IN HKEY hResourceKey,
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    );

#define ClusResLogSystemEventByKey(_hKey_, _level_, _msgid_)       \
    ClusResLogEventWithName0(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL)

#define ClusResLogSystemEventByKey1(_hKey_, _level_, _msgid_, _arg1_)       \
    ClusResLogEventWithName1(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL,                           \
                             _arg1_)

#define ClusResLogSystemEventByKey2(_hKey_, _level_, _msgid_, _arg1_, _arg2_)       \
    ClusResLogEventWithName2(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL,                           \
                             _arg1_,                         \
                             _arg2_)

#define ClusResLogSystemEventByKey3(_hKey_, _level_, _msgid_, _arg1_, _arg2_, _arg3_)       \
    ClusResLogEventWithName3(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             0,                              \
                             NULL,                           \
                             _arg1_,                         \
                             _arg2_,                         \
                             _arg3_)

#define ClusResLogSystemEventByKeyData(_hKey_, _level_, _msgid_, dwBytes, pData)       \
    ClusResLogEventWithName0(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             dwBytes,                        \
                             pData)

#define ClusResLogSystemEventByKeyData1(_hKey_, _level_, _msgid_, dwBytes, pData, _arg1_)       \
    ClusResLogEventWithName1(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             dwBytes,                        \
                             pData,                          \
                             _arg1_)

#define ClusResLogSystemEventByKeyData2(_hKey_, _level_, _msgid_, dwBytes, pData, _arg1_, _arg2_)       \
    ClusResLogEventWithName2(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             dwBytes,                        \
                             pData,                          \
                             _arg1_,                         \
                             _arg2_)

#define ClusResLogSystemEventByKeyData3(_hKey_, _level_, _msgid_, dwBytes, pData, _arg1_, _arg2_, _arg3_)       \
    ClusResLogEventWithName3(_hKey_,                         \
                             _level_,                        \
                             LOG_CURRENT_MODULE,             \
                             __FILE__,                       \
                             __LINE__,                       \
                             _msgid_,                        \
                             dwBytes,                        \
                             pData,                          \
                             _arg1_,                         \
                             _arg2_,                         \
                             _arg3_)

#define ClusResLogSystemEvent0(_level_, _msgid_)           \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL)

#define ClusResLogSystemEvent1(_level_, _msgid_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define ClusResLogSystemEvent2(_level_, _msgid_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_))

#define ClusResLogSystemEvent3(_level_, _msgid_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

#define ClusResLogSystemEventData(_level_, _msgid_, _dwBytes_, _pData_)                \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_))

#define ClusResLogSystemEventData1(_level_, _msgid_, _dwBytes_, _pData_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_))

#define ClusResLogSystemEventData2(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_))

#define ClusResLogSystemEventData3(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

//
// interfaces for GENAPP
//
extern CLRES_FUNCTION_TABLE GenAppFunctionTable;

BOOLEAN
WINAPI
GenAppDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for GENSVC
//
extern CLRES_FUNCTION_TABLE GenSvcFunctionTable;

BOOLEAN
WINAPI
GenSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for DISKS and FTSET
//
extern CLRES_FUNCTION_TABLE DisksFunctionTable;
extern CLRES_FUNCTION_TABLE FtSetFunctionTable;

BOOLEAN
WINAPI
DisksDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

BOOLEAN
WINAPI
FtSetDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for NETNAME
//
extern CLRES_FUNCTION_TABLE NetNameFunctionTable;

BOOLEAN
WINAPI
NetNameDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for IPADDR
//
extern CLRES_FUNCTION_TABLE IpAddrFunctionTable;

BOOLEAN
WINAPI
IpAddrDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for File Shares
//
extern CLRES_FUNCTION_TABLE SmbShareFunctionTable;

BOOLEAN
WINAPI
SmbShareDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Spool Service
//
extern CLRES_FUNCTION_TABLE SplSvcFunctionTable;

BOOLEAN
WINAPI
SplSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );


//
// interfaces for Local Quorum
//
extern CLRES_FUNCTION_TABLE LkQuorumFunctionTable;

BOOLEAN
WINAPI
LkQuorumDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DHCP Server
//
extern CLRES_FUNCTION_TABLE DhcpFunctionTable;

BOOLEAN
WINAPI
DhcpDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for MSMQ Server
//
extern CLRES_FUNCTION_TABLE MsMQFunctionTable;

BOOLEAN
WINAPI
MsMQDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for DTC Server
//
extern CLRES_FUNCTION_TABLE MsDTCFunctionTable;

BOOLEAN
WINAPI
MsDTCDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Time Service
//
extern CLRES_FUNCTION_TABLE TimeSvcFunctionTable;

BOOLEAN
WINAPI
TimeSvcDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for WINS Server
//
extern CLRES_FUNCTION_TABLE WinsFunctionTable;

BOOLEAN
WINAPI
WinsDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Generic Script
//
extern CLRES_FUNCTION_TABLE GenScriptFunctionTable;

BOOLEAN
WINAPI
GenScriptDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

//
// interfaces for Majority Node Set
//
extern CLRES_FUNCTION_TABLE MajorityNodeSetFunctionTable;

BOOLEAN
WINAPI
MajorityNodeSetDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    );

#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ipaddr\nteapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nteapi.c

Abstract:

    Routines for manipulating dynamic IP Network Table Entries (NTEs)
    and NBT devices (interfaces).

Author:

    Mike Massa (mikemas)  18-Mar-1996

Environment:

    User Mode - Win32

Revision History:

--*/


#include "clusres.h"
#include <winsock2.h>
#include <ipexport.h>
#include <ntddip.h>
#include <nteapi.h>
#include <nbtioctl.h>
#include <clusdef.h>
#include <ntddcnet.h>
#include <clusrtl.h>

//
// Public Routines
//
DWORD
TcpipAddNTE(
    IN LPWSTR  AdapterId,
    IN IPAddr  Address,
    IN IPMask  SubnetMask,
    OUT PULONG  NTEContext,
    OUT PULONG  NTEInstance
    )
/*++

Routine Description:

    Adds a new NTE to a specified IP interface. The target IP interface is
    identified by the name of the adapter associated with it.

Arguments:

    AdapterId - A unicode string identifying the adapter/interface to which
                to add the new NTE.

    Address - The IP address to assign to the new NTE.

    SubnetMask - The IP subnet mask to assign to the new NTE.

    NTEContext - On output, contains the context value identifying the new NTE.

    NTEInstance - On output, contains the instance ID of the new NTE.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    PCLRTL_NET_ADAPTER_INFO      adapterInfo;
    PCLRTL_NET_ADAPTER_ENUM      adapterEnum;
    HANDLE                       handle;
    IP_ADD_NTE_REQUEST           requestBuffer;
    PIP_ADD_NTE_RESPONSE         responseBuffer =
                                 (PIP_ADD_NTE_RESPONSE) &requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = sizeof(*responseBuffer);


    adapterEnum = ClRtlEnumNetAdapters();

    if (adapterEnum != NULL) {
        adapterInfo = ClRtlFindNetAdapterById(adapterEnum, AdapterId);

        if (adapterInfo != NULL) {
            status = ClusResOpenDriver(&handle, DD_CLUSNET_DEVICE_NAME);

            if ( status == ERROR_SUCCESS ) {
                requestBuffer.InterfaceContext = adapterInfo->Index;
                requestBuffer.Address = Address;
                requestBuffer.SubnetMask = SubnetMask;

                requestBuffer.InterfaceName.Length = 0;
                requestBuffer.InterfaceName.MaximumLength = 0;
                requestBuffer.InterfaceName.Buffer = NULL;

                status = ClusResDoIoctl(
                             handle,
                             IOCTL_CLUSNET_ADD_NTE,
                             &requestBuffer,
                             requestBufferSize,
                             responseBuffer,
                             &responseBufferSize
                             );

                if (NT_SUCCESS(status)) {
                    *NTEContext = (ULONG) responseBuffer->Context;
                    *NTEInstance = responseBuffer->Instance;
                    status = ERROR_SUCCESS;
                }

                CloseHandle(handle);
            }
        }
        else {
            status = ERROR_INVALID_PARAMETER;
        }

        ClRtlFreeNetAdapterEnum(adapterEnum);
    }
    else {
        status = GetLastError();
    }

    return(status);
}


DWORD
TcpipDeleteNTE(
    IN ULONG  NTEContext
    )
/*++

Routine Description:

    Deletes a specified NTE. The target NTE must have been added using
    TcpipAddNTE.

Arguments:

    NTEContext - The context value identifying the NTE to delete.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    IP_DELETE_NTE_REQUEST        requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = 0;


    status = ClusResOpenDriver(&handle, DD_CLUSNET_DEVICE_NAME);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.Context = (unsigned short) NTEContext;

    status = ClusResDoIoctl(
                 handle,
                 IOCTL_CLUSNET_DELETE_NTE,
                 &requestBuffer,
                 requestBufferSize,
                 NULL,
                 &responseBufferSize
                 );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
TcpipSetNTEAddress(
    DWORD   NTEContext,
    IPAddr  Address,
    IPMask  SubnetMask
    )
/*++

Routine Description:

    Sets the address of a specified NTE.

Arguments:

    NTEContext - The context value identifying the target NTE.

    Address - The IP address to assign to the NTE. Assigning 0.0.0.0
              invalidates the NTE.

    SubnetMask - The IP subnet mask to assign to the NTE.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    IP_SET_ADDRESS_REQUEST_EX    requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = 0;


    status = ClusResOpenDriver(&handle, DD_CLUSNET_DEVICE_NAME);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.Context = (unsigned short) NTEContext;
    requestBuffer.Address = Address;
    requestBuffer.SubnetMask = SubnetMask;
    requestBuffer.Type = IP_ADDRTYPE_TRANSIENT;

    status = ClusResDoIoctl(
                 handle,
                 IOCTL_CLUSNET_SET_NTE_ADDRESS,
                 &requestBuffer,
                 requestBufferSize,
                 NULL,
                 &responseBufferSize
                 );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
TcpipGetNTEInfo(
    IN  ULONG            NTEContext,
    OUT PTCPIP_NTE_INFO  NTEInfo
    )
/*++

Routine Description:

    Gathers information about a specified NTE.

Arguments:

    NTEContext - The context value identifying the NTE to query.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    IP_GET_NTE_INFO_REQUEST      requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    IP_GET_NTE_INFO_RESPONSE     responseBuffer;
    DWORD                        responseBufferSize = sizeof(responseBuffer);


    status = ClusResOpenDriver(&handle, L"\\Device\\Ip");

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.Context = (unsigned short) NTEContext;

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_IP_GET_NTE_INFO,
                        &requestBuffer,
                        requestBufferSize,
                        &responseBuffer,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        NTEInfo->Instance = responseBuffer.Instance;
        NTEInfo->Address = responseBuffer.Address;
        NTEInfo->SubnetMask = responseBuffer.SubnetMask;
        NTEInfo->Flags = responseBuffer.Flags;

        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
NbtAddInterface(
    OUT    LPWSTR   DeviceName,
    IN OUT LPDWORD  DeviceNameSize,
    OUT    PULONG   DeviceInstance
    )
/*++

Routine Description:

    Adds a new NBT interface.

Arguments:

    DeviceName - A unicode string identifying the new NBT interface.

    DeviceNameSize - On input, the size of theh device name buffer.
                     On output, the size of the device name string, or
                     the size needed to accomodate the string.

    DeviceInstance - A pointer to a variable into which to place the
                     instance ID associated with the new interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       nbthandle = (HANDLE) NULL;
    HANDLE                       cnhandle = (HANDLE) NULL;
    PNETBT_ADD_DEL_IF            requestBuffer = NULL;
    DWORD                        requestBufferSize = 0;
    PNETBT_ADD_DEL_IF            responseBuffer = NULL;
    DWORD                        responseBufferSize = 0;
    HKEY                         key = NULL;
    LPWSTR                       NBTDeviceName;
    LPWSTR                       exportString = NULL;
    DWORD                        exportStringSize = 0;
    LONG                         valueType;


    //
    // get a handle to NetBT's Linkage key, query the size of the
    // export value, allocate a buffer large enough to hold it and
    // read it in
    //

    status = RegOpenKeyExW(
                 HKEY_LOCAL_MACHINE,
                 L"SYSTEM\\CurrentControlSet\\Services\\NetBT\\Linkage",
                 0,
                 KEY_READ,
                 &key);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = RegQueryValueExW(
                 key,
                 L"Export",
                 NULL,
                 &valueType,
                 NULL,
                 &exportStringSize
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    exportString = LocalAlloc( LMEM_FIXED, exportStringSize );
    if ( exportString == NULL ) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    status = RegQueryValueExW(
                 key,
                 L"Export",
                 NULL,
                 &valueType,
                 (LPBYTE)exportString,
                 &exportStringSize
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Export is a multi-sz; loop through all the interfaces
    // until we find one that we can open successfully.
    //
    // Hold the handle until we are done with the ioctl so 
    // that the NBT device doesn't go away.
    //

    NBTDeviceName = exportString;
    do {

        status = ClusResOpenDriver(&nbthandle, NBTDeviceName);

        if ( status == ERROR_FILE_NOT_FOUND ) {

            //
            // get the next device name from the export string
            //

            NBTDeviceName += ( lstrlenW( NBTDeviceName ) + 1 );
            if ( *NBTDeviceName == 0 ) {
                status = ERROR_FILE_NOT_FOUND;
                break;
            }
        }
    } while ( status == ERROR_FILE_NOT_FOUND );

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    requestBufferSize = FIELD_OFFSET(NETBT_ADD_DEL_IF, IfName[0])
                        + lstrlenW( NBTDeviceName ) * sizeof(WCHAR)
                        + sizeof(UNICODE_NULL);

    if (requestBufferSize < sizeof(NETBT_ADD_DEL_IF)) {
        requestBufferSize = sizeof(NETBT_ADD_DEL_IF);
    }

    requestBuffer = LocalAlloc(LMEM_FIXED, requestBufferSize);

    if (requestBuffer == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    RtlZeroMemory( requestBuffer, requestBufferSize );

    requestBuffer->Length = lstrlenW( NBTDeviceName ) * sizeof(WCHAR)
        + sizeof(UNICODE_NULL);
    
    RtlCopyMemory( 
        &requestBuffer->IfName[0], 
        NBTDeviceName, 
        requestBuffer->Length 
        );

    responseBufferSize = FIELD_OFFSET(NETBT_ADD_DEL_IF, IfName[0]) +
                         *DeviceNameSize;

    if (responseBufferSize < sizeof(NETBT_ADD_DEL_IF)) {
        responseBufferSize = sizeof(NETBT_ADD_DEL_IF);
    }

    responseBuffer = LocalAlloc(LMEM_FIXED, responseBufferSize);

    if (responseBuffer == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    status = ClusResOpenDriver(&cnhandle, DD_CLUSNET_DEVICE_NAME);

    if ( status == ERROR_SUCCESS ) {
    
        status = ClusResDoIoctl(
                     cnhandle,
                     IOCTL_CLUSNET_ADD_NBT_INTERFACE,
                     requestBuffer,
                     requestBufferSize,
                     responseBuffer,
                     &responseBufferSize
                     );
    
        if (NT_SUCCESS(status)) {
            *DeviceNameSize = responseBuffer->Length;
    
            if (NT_SUCCESS(responseBuffer->Status)) {
                wcscpy(DeviceName, &(responseBuffer->IfName[0]));
                *DeviceInstance = responseBuffer->InstanceNumber;
                status = ERROR_SUCCESS;
            }
            else {
               status = responseBuffer->Status;
            }
        }
        else {
            status = RtlNtStatusToDosError(status);
        }
    }

error_exit:
    if ( key ) {
        RegCloseKey( key );
    }

    if ( exportString ) {
        LocalFree( exportString );
    }

    if ( requestBuffer ) {
        LocalFree( requestBuffer );
    }

    if ( responseBuffer ) {
        LocalFree( responseBuffer );
    }

    if ( nbthandle ) {
        CloseHandle( nbthandle );
    }

    if ( cnhandle ) {
        CloseHandle( cnhandle );
    }

    return(status);
}


DWORD
NbtDeleteInterface(
    IN LPWSTR   DeviceName
    )
/*++

Routine Description:

    Deletes an NBT interface.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle = (HANDLE) NULL;
    DWORD                        responseBufferSize = 0;
    PNETBT_ADD_DEL_IF            requestBuffer = NULL;
    DWORD                        requestBufferSize = 0;


    requestBufferSize = FIELD_OFFSET(NETBT_ADD_DEL_IF, IfName[0])
                        + lstrlenW( DeviceName ) * sizeof(WCHAR)
                        + sizeof(UNICODE_NULL);

    if (requestBufferSize < sizeof(NETBT_ADD_DEL_IF)) {
        requestBufferSize = sizeof(NETBT_ADD_DEL_IF);
    }

    requestBuffer = LocalAlloc(LMEM_FIXED, requestBufferSize);

    if (requestBuffer == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    RtlZeroMemory( requestBuffer, requestBufferSize );

    requestBuffer->Length = lstrlenW( DeviceName ) * sizeof(WCHAR)
                            + sizeof(UNICODE_NULL);
    
    RtlCopyMemory( 
        &requestBuffer->IfName[0], 
        DeviceName, 
        requestBuffer->Length 
        );

    status = ClusResOpenDriver(&handle, DD_CLUSNET_DEVICE_NAME);

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_CLUSNET_DEL_NBT_INTERFACE,
                        requestBuffer,
                        requestBufferSize,
                        NULL,
                        &responseBufferSize
                        );

    if (NT_SUCCESS(status)) {
            status = ERROR_SUCCESS;
    }
    else {
        status = RtlNtStatusToDosError(status);
    }

error_exit:

    if (requestBuffer) {
        LocalFree(requestBuffer);
    }

    if (handle) {
        CloseHandle(handle);        
    }

    return(status);
}


DWORD
NbtBindInterface(
    IN LPWSTR  DeviceName,
    IN IPAddr  Address,
    IN IPMask  SubnetMask
    )
/*++

Routine Description:

    Binds a specified NBT interface to a specified IP address.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    Address - The IP address to which bind the interface. Assigning 0.0.0.0
              invalidates the interface.

    SubnetMask - The subnet mask of the IP interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    tNEW_IP_ADDRESS              requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = 0;


    status = ClusResOpenDriver(&handle, DeviceName);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.IpAddress = Address;
    requestBuffer.SubnetMask = SubnetMask;

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_NEW_IPADDRESS,
                        &requestBuffer,
                        requestBufferSize,
                        NULL,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}

DWORD
NbtSetWinsAddrInterface(
    IN LPWSTR  DeviceName,
    IN IPAddr  PrWinsAddress,
    IN IPAddr  SecWinsAddress
    )
/*++

Routine Description:

    Sets the WINS addrs for a given Nbt Interface.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    PrWinsAddress - Primary WINS addr

    SecWinsAddress - Secondary WINS addr

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    NETBT_SET_WINS_ADDR          requestBuffer;
    DWORD                        requestBufferSize = sizeof(requestBuffer);
    DWORD                        responseBufferSize = 0;


    status = ClusResOpenDriver(&handle, DeviceName);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    requestBuffer.PrimaryWinsAddr = ntohl(PrWinsAddress);
    requestBuffer.SecondaryWinsAddr = ntohl(SecWinsAddress);

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_SET_WINS_ADDRESS,
                        &requestBuffer,
                        requestBufferSize,
                        NULL,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
NbtGetWinsAddresses(
    IN  LPWSTR    DeviceName,
    OUT IPAddr *  PrimaryWinsServer,
    OUT IPAddr *  SecondaryWinsServer
    )
/*++

Routine Description:

    Returns the addresses of the WINS servers for which the specified device
    is configured.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    PrimaryWinsServer - A pointer to a variable into which to place the address
                        of the primary WINS server.

    SecondaryWinsServer - A pointer to a variable into which to place the address
                          of the primary WINS server.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    tWINS_ADDRESSES              responseBuffer;
    DWORD                        responseBufferSize = sizeof(responseBuffer);


    status = ClusResOpenDriver(&handle, DeviceName);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_GET_WINS_ADDR,
                        NULL,
                        0,
                        &responseBuffer,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (NT_SUCCESS(status)) {
        *PrimaryWinsServer = htonl(responseBuffer.PrimaryWinsServer);
        *SecondaryWinsServer = htonl(responseBuffer.BackupWinsServer);
        return(ERROR_SUCCESS);
    }

    return(RtlNtStatusToDosError(status));
}


DWORD
NbtGetInterfaceInfo(
    IN LPWSTR    DeviceName,
    OUT IPAddr * Address,
    OUT PULONG   DeviceInstance
    )
/*++

Routine Description:

    Returns the IP address to which an NBT interface is bound and the interface
    instance ID.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    Address - A pointer to the location in which to store the address of the
              interface.

    DeviceInstance - A pointer to the location in which to store the instance ID
                     associated with the interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    HANDLE                       handle;
    IPAddr                       address;
    NETBT_ADD_DEL_IF             responseBuffer;
    DWORD                        responseBufferSize;


    status = ClusResOpenDriver(&handle, DeviceName);

    if ( status != ERROR_SUCCESS ) {
        return status;
    }

    responseBufferSize = sizeof(address);

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_GET_IP_ADDRS,
                        NULL,
                        0,
                        &address,
                        &responseBufferSize
                        );

    if (!((status == STATUS_SUCCESS) || (status == STATUS_BUFFER_OVERFLOW))) {
        CloseHandle(handle);
        return(RtlNtStatusToDosError(status));
    }

    *Address = htonl(address);

    responseBufferSize = sizeof(responseBuffer);

    status = ClusResDoIoctl(
                        handle,
                        IOCTL_NETBT_QUERY_INTERFACE_INSTANCE,
                        NULL,
                        0,
                        &responseBuffer,
                        &responseBufferSize
                        );

    CloseHandle(handle);

    if (status == STATUS_SUCCESS) {
        if (responseBuffer.Status == STATUS_SUCCESS) {
            *DeviceInstance = responseBuffer.InstanceNumber;
        }
        else {
            status = RtlNtStatusToDosError(responseBuffer.Status);
        }
    }
    else {
        status = RtlNtStatusToDosError(status);
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\inc\clusstrs.h ===
#define RES_NETNAME_COMPUTER_ACCOUNT_DESCRIPTION    12000
#define RES_NETNAME_DC_BIND_FAILED                  12001
#define RES_NETNAME_RESDATA_ALLOC_FAILED            12002
#define RES_NETNAME_PASSWORD_UPDATE_FAILED          12003
#define RES_NETNAME_PARAMS_KEY_PERMISSION_UPDATE_FAILED 12004
#define RES_NETNAME_RESDATA_STORE_FAILED            12005
#define RES_NETNAME_CO_CANT_BE_REENABLED            12006
#define RES_NETNAME_CREATE_CO_FAILED                12007
#define RES_NETNAME_GET_LDAP_NAME_FAILED            12008
#define RES_NETNAME_GET_CO_GUID_FAILED              12009
#define RES_NETNAME_GET_CO_POINTER_FAILED           12010
#define RES_NETNAME_DNSHOSTNAME_UPDATE_FAILED       12011
#define RES_NETNAME_SPN_UPDATE_FAILED               12012
#define RES_NETNAME_CREATINDC_ALLOC_FAILED          12013
#define RES_NETNAME_MISSING_CO                      12014
#define RES_NETNAME_DECRYPT_RESDATA_FAILED          12015
#define RES_NETNAME_NO_DC_FOR_PASSWORD_UPDATE       12016
#define RES_NETNAME_CREATINGDC_UPDATE_FAILED        12017
#define RES_NETNAME_CO_PASSWORD_UPDATE_FAILED       12018
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ipaddr\ipaddr.c ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    ipaddr.c

Abstract:

    Resource DLL for an IP address.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/

#define UNICODE 1

#include "clusres.h"
#include "clusrtl.h"
#include <winsock.h>
#include <ipexport.h>
#include <icmpapi.h>
#include "util.h"
#include "nteapi.h"
#include <dnsapi.h>


//
// Private Constants
//
#define LOG_CURRENT_MODULE LOG_MODULE_IPADDR

#define INVALID_NTE_CONTEXT  0xFFFFFFFF

#define MAX_NODE_ID_LENGTH       5
#define NETINTERFACE_ID_LENGTH  36   // size of a guid
#define NETWORK_ID_LENGTH       36

#define PROP_NAME__NETWORK            CLUSREG_NAME_IPADDR_NETWORK
#define PROP_NAME__ADDRESS            CLUSREG_NAME_IPADDR_ADDRESS
#define PROP_NAME__SUBNETMASK         CLUSREG_NAME_IPADDR_SUBNET_MASK
#define PROP_NAME__ENABLENETBIOS      CLUSREG_NAME_IPADDR_ENABLE_NETBIOS
#define PROP_NAME__OVERRIDE_ADDRMATCH CLUSREG_NAME_IPADDR_OVERRIDE_ADDRMATCH


//
// Private Macros
//
#define IpaLogEvent           ClusResLogEvent
#define IpaSetResourceStatus  ClusResSetResourceStatus

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT( ArgumentPointer )   (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#endif

#define IpaAcquireGlobalLock()  \
            {  \
                DWORD status;  \
                status = WaitForSingleObject(IpaGlobalMutex, INFINITE);  \
            }

#define IpaReleaseGlobalLock()  \
            { \
                BOOL    released;  \
                released = ReleaseMutex(IpaGlobalMutex);  \
            }

#define IpaAcquireResourceLock(_res)   EnterCriticalSection(&((_res)->Lock))
#define IpaReleaseResourceLock(_res)   LeaveCriticalSection(&((_res)->Lock))

#define DBG_PRINT printf


//
// Private Types.
//
typedef struct _IPA_PRIVATE_PROPS {
    PWSTR     NetworkString;
    PWSTR     AddressString;
    PWSTR     SubnetMaskString;
    DWORD     EnableNetbios;
    DWORD     OverrideAutomatch;
} IPA_PRIVATE_PROPS, *PIPA_PRIVATE_PROPS;

typedef struct _IPA_LOCAL_PARAMS {
    LPWSTR             InterfaceId;
    LPWSTR             InterfaceName;
    LPWSTR             AdapterName;
    LPWSTR             AdapterId;
    IPAddr             NbtPrimaryWinsAddress;
    IPAddr             NbtSecondaryWinsAddress;
} IPA_LOCAL_PARAMS, *PIPA_LOCAL_PARAMS;

typedef struct {
    LIST_ENTRY                    Linkage;
    CLUSTER_RESOURCE_STATE        State;
    DWORD                         FailureStatus;
    RESOURCE_HANDLE               ResourceHandle;
    BOOLEAN                       InternalParametersInitialized;
    IPAddr                        Address;
    IPMask                        SubnetMask;
    DWORD                         EnableNetbios;
    IPA_PRIVATE_PROPS             InternalPrivateProps;
    IPA_LOCAL_PARAMS              LocalParams;
    HNETINTERFACE                 InterfaceHandle;
    DWORD                         NteContext;
    DWORD                         NteInstance;
    LPWSTR                        NbtDeviceName;
    DWORD                         NbtDeviceInstance;
    CLUS_WORKER                   OnlineThread;
    HKEY                          ResourceKey;
    HKEY                          ParametersKey;
    HKEY                          NodeParametersKey;
    HKEY                          NetworksKey;
    HKEY                          InterfacesKey;
    WCHAR                         NodeId[MAX_NODE_ID_LENGTH + 1];
    CRITICAL_SECTION              Lock;
} IPA_RESOURCE, *PIPA_RESOURCE;


//
// Private Data
//
HANDLE               IpaGlobalMutex = NULL;
USHORT               IpaResourceInstance = 0;
HCLUSTER             IpaClusterHandle = NULL;
HCHANGE              IpaClusterNotifyHandle = NULL;
HANDLE               IpaWorkerThreadHandle = NULL;
DWORD                IpaOpenResourceCount = 0;
DWORD                IpaOnlineResourceCount = 0;
LIST_ENTRY           IpaResourceList = {NULL, NULL};
WCHAR                NbtDevicePrefix[] = L"\\Device\\NetBT_Tcpip_{";
WCHAR                NbtDeviceSuffix[] = L"}";
DWORD                IpaMaxIpAddressStringLength = 0;


RESUTIL_PROPERTY_ITEM
IpaResourcePrivateProperties[] = {
    { PROP_NAME__NETWORK,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0, 0, 0, RESUTIL_PROPITEM_REQUIRED,
      FIELD_OFFSET(IPA_PRIVATE_PROPS,NetworkString)
    },
    { PROP_NAME__ADDRESS,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0, 0, 0, RESUTIL_PROPITEM_REQUIRED,
      FIELD_OFFSET(IPA_PRIVATE_PROPS,AddressString)
    },
    { PROP_NAME__SUBNETMASK,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0, 0, 0, RESUTIL_PROPITEM_REQUIRED,
      FIELD_OFFSET(IPA_PRIVATE_PROPS,SubnetMaskString)
    },
    { PROP_NAME__ENABLENETBIOS,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      1, 0, 0xFFFFFFFF, 0,
      FIELD_OFFSET(IPA_PRIVATE_PROPS,EnableNetbios)
    },
    { PROP_NAME__OVERRIDE_ADDRMATCH,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      0, 0, 0xFFFFFFFF, 0,
      FIELD_OFFSET(IPA_PRIVATE_PROPS,OverrideAutomatch)
    },
    { 0 }
};


//
// External Data
//
extern CLRES_FUNCTION_TABLE IpAddrFunctionTable;


//
// Private Routine Headers
//
DWORD
IpaGetPrivateResProperties(
    IN OUT  PIPA_RESOURCE   ResourceEntry,
    OUT     PVOID           OutBuffer,
    IN      DWORD           OutBufferSize,
    OUT     LPDWORD         BytesReturned
    );

DWORD
IpaValidatePrivateResProperties(
    IN OUT PIPA_RESOURCE       ResourceEntry,
    IN     PVOID               InBuffer,
    IN     DWORD               InBufferSize,
    OUT    PIPA_PRIVATE_PROPS  Props
    );

DWORD
IpaSetPrivateResProperties(
    IN OUT PIPA_RESOURCE  ResourceEntry,
    IN     PVOID          InBuffer,
    IN     DWORD          InBufferSize
    );

DWORD
IpaWorkerThread(
    LPVOID   Context
    );

VOID
WINAPI
IpaClose(
    IN RESID Resource
    );


//
// Utility functions
//
BOOLEAN
IpaInit(
    VOID
    )
/*++

Routine Description:

    Process attach initialization routine.

Arguments:

    None.

Return Value:

    TRUE if initialization succeeded. FALSE otherwise.

--*/
{
    INT      err;
    WSADATA  WsaData;


    InitializeListHead(&IpaResourceList);

    ClRtlQueryTcpipInformation(&IpaMaxIpAddressStringLength, NULL, NULL);

    err = WSAStartup(0x0101, &WsaData);

    if (err) {
        return(FALSE);
    }

    IpaGlobalMutex = CreateMutex(NULL, FALSE, NULL);

    if (IpaGlobalMutex == NULL) {
        WSACleanup();
        return(FALSE);
    }

    return(TRUE);

}  // IpaInit


VOID
IpaCleanup(
    VOID
    )
/*++

Routine Description:

    Process detach cleanup routine.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IpaGlobalMutex != NULL) {
        CloseHandle(IpaGlobalMutex);
        IpaGlobalMutex = NULL;
    }

    WSACleanup();

    return;
}



LPWSTR
IpaGetNameOfNetwork(
    IN OUT PIPA_RESOURCE ResourceEntry,
    IN LPCWSTR NetworkId
    )

/*++

Routine Description:

    Get the name of a network from its GUID.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    NetworkId - Supplies the ID of the network.

Return Value:

    String allocated using LocalAlloc() containing the name of the
        network.

    NULL - An error occurred getting the name of the network.  Call
        GetLastError() for more details.

--*/

{
    DWORD       status;
    DWORD       ival;
    DWORD       type;
    DWORD       nameLength;
    WCHAR       name[256];
    LPWSTR      networkName = NULL;
    HKEY        networkKey = NULL;
    FILETIME    fileTime;

    //
    // Enumerate the networks, looking for the specified GUID.
    //
    for ( ival = 0 ; ; ival++ ) {
        nameLength = sizeof(name);
        status = ClusterRegEnumKey( ResourceEntry->NetworksKey,
                                    ival,
                                    name,
                                    &nameLength,
                                    &fileTime );
        if ( status == ERROR_MORE_DATA ) {
            continue;
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // If we found a match, open the key and read the name.
        //
        if ( lstrcmpiW( name, NetworkId ) == 0 ) {
            status = ClusterRegOpenKey( ResourceEntry->NetworksKey,
                                        name,
                                        KEY_READ,
                                        &networkKey );
            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            //
            // Get the size of the name value.
            //
            status = ClusterRegQueryValue( networkKey,
                                           CLUSREG_NAME_NET_NAME,
                                           &type,
                                           NULL,
                                           &nameLength );
            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            //
            // Allocate memory for the network name.
            //
            networkName = LocalAlloc( LMEM_FIXED, nameLength );
            if ( networkName == NULL ) {
                status = GetLastError();
                goto error_exit;
            }

            //
            // Read the name value.
            //
            status = ClusterRegQueryValue( networkKey,
                                           CLUSREG_NAME_NET_NAME,
                                           &type,
                                           (LPBYTE) networkName,
                                           &nameLength );
            if ( status != ERROR_SUCCESS ) {
                LocalFree( networkName );
                networkName = NULL;
                goto error_exit;
            }

            break;
        }
    }

error_exit:
    if ( networkKey != NULL ) {
        ClusterRegCloseKey( networkKey );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }
    return(networkName);

} // IpaGetNameOfNetwork



DWORD
IpaGetRoleOfNetwork(
    IN OUT PIPA_RESOURCE ResourceEntry,
    IN LPCWSTR NetworkId,
    OUT PDWORD NetworkRole
    )

/*++

Routine Description:

    Get the name of a network from its GUID.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    NetworkId - Supplies the ID of the network.

    NetworkRole - Supplies network role to be filled in

Return Value:

    ERROR_SUCCESS if function completes successfully

    Win32 error code if function fails

--*/

{
    DWORD       status;
    DWORD       ival;
    DWORD       type;
    DWORD       nameLength;
    WCHAR       name[256];
    DWORD       roleSize;
    HKEY        networkKey = NULL;
    FILETIME    fileTime;

    //
    // Enumerate the networks, looking for the specified GUID.
    //
    for ( ival = 0 ; ; ival++ ) {
        nameLength = sizeof(name);
        status = ClusterRegEnumKey( ResourceEntry->NetworksKey,
                                    ival,
                                    name,
                                    &nameLength,
                                    &fileTime );
        if ( status == ERROR_MORE_DATA ) {
            continue;
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // If we found a match, open the key and read the name.
        //
        if ( lstrcmpiW( name, NetworkId ) == 0 ) {
            status = ClusterRegOpenKey( ResourceEntry->NetworksKey,
                                        name,
                                        KEY_READ,
                                        &networkKey );
            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            //
            // Read the role value.
            //
            roleSize = sizeof(*NetworkRole);
            status = ClusterRegQueryValue( networkKey,
                                           CLUSREG_NAME_NET_ROLE,
                                           &type,
                                           (LPBYTE) NetworkRole,
                                           &roleSize);
            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            break;
        }
    }

error_exit:
    if ( networkKey != NULL ) {
        ClusterRegCloseKey( networkKey );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return(status);

} // IpaGetRoleOfNetwork


PWCHAR
WcsDup(
    IN PWCHAR str
    )

/*++

Routine Description:

    Duplicates the string.
    It does the same as _wcsdup, except that
    it uses LocalAlloc for allocation

Arguments:

    str - string to be copied

Return Value:

    String allocated using LocalAlloc() containing the copy
        of str.

    NULL - not enough memory

--*/
{
    UINT   n = (wcslen(str) + 1) * sizeof(WCHAR);
    PWCHAR result = LocalAlloc( LMEM_FIXED , n );

    if (result) {
        CopyMemory( result, str, n );
    }

    return result;
}


// The automatch mask determines whether the role/address match is 
// higher or lower than the guid match. 
#define IPADDR_MATCHNETGUID_NOTOVERRIDE  0x1
#define IPADDR_MATCHNETADDR              0x2
#define IPADDR_MATCHNETROLE              0x4
#define IPADDR_MATCHNETGUID_OVERRIDE     0x8

#define IPADDR_MATCHNETGUID              ( IPADDR_MATCHNETGUID_NOTOVERRIDE | \
                                           IPADDR_MATCHNETGUID_OVERRIDE )

#define IPADDR_ADDRMATCH_OVERRIDEMASK    (~(IPADDR_MATCHNETGUID_NOTOVERRIDE))
#define IPADDR_ADDRMATCH_NOTOVERRIDEMASK (~(IPADDR_MATCHNETGUID_OVERRIDE))


DWORD
IpaPatchNetworkGuidIfNecessary(
    IN OUT PIPA_RESOURCE ResourceEntry,
    IN OUT PIPA_PRIVATE_PROPS props
    )

/*++

Routine Description:

    Find the best-matching network for this resource in the cluster
    database. The match criteria depends on the OverrideAutomatch
    private property. 

    If OverrideAutomatch is not set (default), the criteria is as
    follows:
    1. Resource address and mask match network mask. Network allows
       client access.
    2. Resource network guid matches cluster database network guid. 
       Network allows client access.
    3. Resource address and mask match network mask. Network does 
       not allow client access.
    4. Resource network guid matches cluster database network guid. 
       Network does not allow client access.

    If OverrideAutomatch is set, the criteria is as follows:
    1. Resource network guid matches cluster database network guid. 
       Network allows client access.
    2. Resource network guid matches cluster database network guid. 
       Network does not allow client access.
    3. Resource address and mask match network mask. Network allows
       client access.
    4. Resource address and mask match network mask. Network does 
       not allow client access.
    

    If a network is chosen whose role does not allow client access,
    the guid will be patched, but an online will be forbidden by 
    the caller of this routine.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    props - Supplies IP address properties.

Return Value:

    String allocated using LocalAlloc() containing the name of the
        network.

    NULL - An error occurred getting the name of the network.  Call
        GetLastError() for more details.

--*/

{
    DWORD       status = ERROR_SUCCESS;
    DWORD       ival;
    DWORD       type;
    DWORD       bufLength;
    WCHAR       buf[256];
    DWORD       nameLength;
    WCHAR       name[256];
    PWCHAR      match = NULL;

    ULONG       networkAddr;
    ULONG       networkMask;
    ULONG       ipAddr;
    ULONG       ipAddrMask;
    ULONG       networkRole;

    DWORD       bestMatchFlags = 0;
    DWORD       overrideMask = 0;
    DWORD       bestPossibleMatch = 0;

    HKEY        networkKey = NULL;
    FILETIME    fileTime;

    if (props == NULL) {
        return ERROR_SUCCESS;
    }

    if ( props->NetworkString == NULL ) {
        return ERROR_SUCCESS;
    }

    if ( props->AddressString == NULL
       || !UnicodeInetAddr(props->AddressString, &ipAddr) )
    {
        return ERROR_SUCCESS;
    }

    if ( props->SubnetMaskString == NULL
        || !UnicodeInetAddr(props->SubnetMaskString, &ipAddrMask) )
    {
        return ERROR_SUCCESS;
    }

    //
    // Determine whether we are overriding the address automatch.
    //
    if ( props->OverrideAutomatch ) {
        overrideMask = IPADDR_ADDRMATCH_OVERRIDEMASK;
        bestPossibleMatch = 
            (IPADDR_MATCHNETGUID & overrideMask) | IPADDR_MATCHNETROLE;
    } else {
        overrideMask = IPADDR_ADDRMATCH_NOTOVERRIDEMASK;
        bestPossibleMatch = IPADDR_MATCHNETADDR |
                            (IPADDR_MATCHNETGUID & overrideMask) | 
                            IPADDR_MATCHNETROLE;        
    }

    //
    // Enumerate the networks, looking for the specified GUID.
    //
    for ( ival = 0 ; ; ival++ ) {

        DWORD   curMatchFlags = 0;
        
        nameLength = sizeof(name);
        status = ClusterRegEnumKey( ResourceEntry->NetworksKey,
                                    ival,
                                    name,
                                    &nameLength,
                                    &fileTime );
        if ( status == ERROR_MORE_DATA ) {
            continue;
        }
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // If we found a guid match, we will remember it but still
        // look for an address and role match.
        //
        if ( lstrcmpiW( name, props->NetworkString ) == 0 ) {
            curMatchFlags |= IPADDR_MATCHNETGUID;
        }

        if ( networkKey != NULL ) {
            ClusterRegCloseKey( networkKey );
            networkKey = NULL;
        }

        //
        // Open network key to get properties.
        //
        status = ClusterRegOpenKey( ResourceEntry->NetworksKey,
                                    name,
                                    KEY_READ,
                                    &networkKey );

        if ( status != ERROR_SUCCESS ) {
            continue;
        }

        //
        // Get the network role.
        //
        bufLength = sizeof(networkRole);
        status = ClusterRegQueryValue( networkKey,
                                       CLUSREG_NAME_NET_ROLE,
                                       &type,
                                       (LPBYTE)&networkRole,
                                       &bufLength );
        if ( status != ERROR_SUCCESS || type != REG_DWORD )
        {
            continue;
        }

        //
        // Verify that the role of this network allows IP address
        // resources.
        //
        if ( networkRole == ClusterNetworkRoleClientAccess ||
             networkRole == ClusterNetworkRoleInternalAndClient ) {
            curMatchFlags |= IPADDR_MATCHNETROLE;
        }

        //
        // Check whether ip address fits this network.
        // Get the network address
        //
        bufLength = sizeof(buf);
        status = ClusterRegQueryValue( networkKey,
                                       CLUSREG_NAME_NET_ADDRESS,
                                       &type,
                                       (LPBYTE)buf,
                                       &bufLength );
        if ( status != ERROR_SUCCESS
         || !UnicodeInetAddr(buf, &networkAddr) )
        {
            continue;
        }

        //
        // Get subnet mask
        //
        bufLength = sizeof(buf);
        status = ClusterRegQueryValue( networkKey,
                                       CLUSREG_NAME_NET_ADDRESS_MASK,
                                       &type,
                                       (LPBYTE)buf,
                                       &bufLength );
        if ( status != ERROR_SUCCESS
         || !UnicodeInetAddr(buf, &networkMask) )
        {
            continue;
        }

        (IpaLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Checking for network match: network masks %1!08X!=%2!08X! "
            L"and addresses %3!08X!^%4!08X!, role %5!u!.\n",
            ipAddrMask, networkMask,
            ipAddr, networkAddr,
            networkRole
            );

        if ( (networkMask == ipAddrMask) && 
             ((ipAddr ^ networkAddr) & networkMask) == 0 ) {

            //
            // The resource address matches the current network.
            //
            curMatchFlags |= IPADDR_MATCHNETADDR;
        }

        //
        // Adjust the flags for whether we are overriding automatch.
        //
        curMatchFlags &= overrideMask;

        //
        // If only the role matched, we cannot use this network.
        //
        if ( curMatchFlags == IPADDR_MATCHNETROLE ) {
            continue;
        }

        //
        // If we have already seen a better match, keep searching.
        //
        if ( curMatchFlags < bestMatchFlags ) {
            continue;
        }

        //
        // This is the best match so far.
        //
        bestMatchFlags = curMatchFlags;
        
        //
        // Create a string with its name if it's
        // not a guid match. (For a guid match, the name 
        // is already stored in the resource data structure).
        //
        if ( !(curMatchFlags & IPADDR_MATCHNETGUID) ) {
            if ( match ) {
                LocalFree( match );
            }
            match = WcsDup( name );
        }

        //
        // If this is an unbeatable match, stop searching.
        //
        if ( (curMatchFlags & bestPossibleMatch) == bestPossibleMatch ) {
            break;
        }
    }

    ASSERT( bestMatchFlags != IPADDR_MATCHNETROLE );

    if ( status != ERROR_SUCCESS && bestMatchFlags ) {
        //
        // We have at least one match. Update status.
        //
        status = ERROR_SUCCESS;
    }

    if ( !(bestMatchFlags & IPADDR_MATCHNETGUID) && bestMatchFlags ) {

        LPWSTR networkName = NULL;
        
        //
        // We have a match, but it's not with the network GUID.
        // We need to patch network information
        //
        LocalFree(props->NetworkString);
        props->NetworkString = match;

        status = ClusterRegSetValue(
                     ResourceEntry->ParametersKey,
                     CLUSREG_NAME_IPADDR_NETWORK,
                     REG_SZ,
                     (LPBYTE) match,
                     (wcslen(match) + 1) * sizeof(WCHAR)
                     );

        (IpaLogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_WARNING,
            L"Patch with network GUID %2!ws!, status %1!u!.\n",
            status,
            match
            );

        match = NULL;

        //
        // Write an event log entry reporting the change.
        //
        networkName = IpaGetNameOfNetwork(
                          ResourceEntry, 
                          props->NetworkString
                          );
        if ( networkName != NULL ) {
            ClusResLogSystemEventByKey1(
                ResourceEntry->ResourceKey,
                LOG_UNUSUAL,
                RES_IPADDR_PATCHED_NETWORK,
                networkName
                );
            LocalFree(networkName);
        }        
    }

    if ( networkKey != NULL ) {
        ClusterRegCloseKey( networkKey );
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    if (match != NULL) {
        LocalFree(match);
    }

    return(status);

} // IpaPatchNetworkGuidIfNecessary

LPWSTR
IpaGetNameOfNetworkPatchGuidIfNecessary(
    IN OUT PIPA_RESOURCE ResourceEntry,
    IN OUT PIPA_PRIVATE_PROPS props
    )

/*++

Routine Description:

    Get the name of a network from its GUID.
    If the guid cannot be found, it will try to find
    appropriate network using IpaPatchNetworkGuidIfNecessary routine

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    props - Supplies IP address properties.

Return Value:

    String allocated using LocalAlloc() containing the name of the
        network.

    NULL - An error occurred getting the name of the network.  Call
        GetLastError() for more details.

--*/

{
    DWORD status;
    LPWSTR result = IpaGetNameOfNetwork(ResourceEntry, props->NetworkString);
    if (result) {
        return result;
    }

    status = IpaPatchNetworkGuidIfNecessary(ResourceEntry, props);
    if (status != ERROR_SUCCESS) {
        SetLastError( status );
        return 0;
    }

    return IpaGetNameOfNetwork(ResourceEntry, props->NetworkString);
} // IpaGetNameOfNetworkPatchGuidIfNecessary


LPWSTR
IpaGetIdOfNetwork(
    IN OUT PIPA_RESOURCE ResourceEntry,
    IN LPCWSTR NetworkName
    )

/*++

Routine Description:

    Get the ID of a network from its name.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    NetworkName - Supplies the name of the network.

Return Value:

    String allocated using LocalAlloc() containing the name of the
        network.

    NULL - An error occurred getting the name of the network.  Call
        GetLastError() for more details.

--*/

{
    DWORD       status;
    DWORD       networkIdLength;
    LPWSTR      networkId = NULL;
    HCLUSTER    hcluster = NULL;
    HNETWORK    hnetwork = NULL;

    //
    // Open the cluster.
    //
    hcluster = OpenCluster( NULL );
    if ( hcluster == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Open the network.
    //
    hnetwork = OpenClusterNetwork( hcluster, NetworkName );
    if ( hnetwork == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    //
    // Get the network ID length.
    //
    networkIdLength = 0;
    status = GetClusterNetworkId( hnetwork,
                                  NULL,
                                  &networkIdLength );
    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // Allocate a string buffer.
    //
    networkId = LocalAlloc( LMEM_FIXED, (networkIdLength + 1) * sizeof(WCHAR) );
    if ( networkId == NULL ) {
        status = GetLastError();
        goto error_exit;
    }
    networkIdLength++;

    //
    // Get the network ID.
    //
    status = GetClusterNetworkId( hnetwork,
                                  networkId,
                                  &networkIdLength );
    if ( status != ERROR_SUCCESS ) {
        LocalFree( networkId );
        networkId = NULL;
    }

error_exit:
    if ( hnetwork != NULL ) {
        CloseClusterNetwork( hnetwork );
    }
    if ( hcluster != NULL ) {
        CloseCluster( hcluster );
    }

    return( networkId );

} // IpaGetIdOfNetwork


VOID
IpaDeleteNte(
    IN OUT LPDWORD          NteContext,
    IN     HKEY             NodeParametersKey,
    IN     RESOURCE_HANDLE  ResourceHandle
    )
/*++

Routine Description:

    Deletes a previously created NTE.

Arguments:

    NteContext - A pointer to a variable containing the context value
                 identifying the NTE to delete.

    NodeParametersKey - An open handle to the resource's node-specific
                        parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

Return Value:

    None.

--*/
{
    DWORD status;


    ASSERT(*NteContext != INVALID_NTE_CONTEXT);
    ASSERT(ResourceHandle != NULL);

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Deleting IP interface %1!u!.\n",
        *NteContext
        );

    status = TcpipDeleteNTE(*NteContext);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_WARNING,
            L"Failed to delete IP interface %1!u!, status %2!u!.\n",
            *NteContext,
            status
            );
    }

    *NteContext = INVALID_NTE_CONTEXT;

    //
    // Clear the NTE information from the registry
    //
    if (NodeParametersKey != NULL) {
        status = ClusterRegDeleteValue(
                     NodeParametersKey,
                     L"InterfaceContext"
                     );

        if (status != ERROR_SUCCESS) {
            (IpaLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Failed to delete IP interface information from database, status %1!u!.\n",
                status
                );
        }
    }

    return;

}  // IpaDeleteNte


DWORD
IpaCreateNte(
    IN  LPWSTR           AdapterId,
    IN  HKEY             NodeParametersKey,
    IN  RESOURCE_HANDLE  ResourceHandle,
    OUT LPDWORD          NteContext,
    OUT LPDWORD          NteInstance
    )
/*++

Routine Description:

    Creates a new NTE to hold an IP address.

Arguments:

    AdapterId - A pointer to a buffer containing the unicode name
                  of the adapter on which the NTE is to be created.

    NodeParametersKey - An open handle to the resource's node-specific
                        parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

    NteContext - A pointer to a variable into which to place the context value
                 which identifies the new NTE.

    NteInstance - A pointer to a variable into which to place the instance value
                  which identifies the new NTE.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

--*/
{
    DWORD status;


    *NteContext = INVALID_NTE_CONTEXT;

    status = TcpipAddNTE(
                 AdapterId,
                 0,
                 0,
                 NteContext,
                 NteInstance
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create new IP interface, status %1!u!\n",
            status);
        return(status);
    }

    //
    // Write the NTE information to the registry
    //
    status = ClusterRegSetValue(
                 NodeParametersKey,
                 L"InterfaceContext",
                 REG_DWORD,
                 (LPBYTE) NteContext,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to write IP interface information to database, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ClusterRegSetValue(
                 NodeParametersKey,
                 L"InterfaceInstance",
                 REG_DWORD,
                 (LPBYTE) NteInstance,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to write IP interface information to database, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Created IP interface %1!u! (instance 0x%2!08X!).\n",
        *NteContext,
        *NteInstance
        );

    return(ERROR_SUCCESS);


error_exit:

    if (*NteContext != INVALID_NTE_CONTEXT) {
        IpaDeleteNte(
            NteContext,
            NodeParametersKey,
            ResourceHandle
            );
    }

    return(status);
}


VOID
IpaDeleteNbtInterface(
    IN OUT LPWSTR *         NbtDeviceName,
    IN     HKEY             NodeParametersKey,
    IN     RESOURCE_HANDLE  ResourceHandle
    )
/*++

Routine Description:

    Deletes an NBT device (interface).

Arguments:

    NbtDeviceName - A pointer to a buffer containing the unicode name
                    of the NBT device to delete.

    NodeParametersKey - An open handle to the resource's node-specific
                        parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

Return Value:

    None.

--*/
{
    DWORD status;


    ASSERT(*NbtDeviceName != NULL);
    ASSERT(ResourceHandle != NULL);

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Deleting NBT interface %1!ws!.\n",
        *NbtDeviceName
        );

    status = NbtDeleteInterface(*NbtDeviceName);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_WARNING,
            L"Failed to delete NBT interface %1!ws!, status %2!u!.\n",
            *NbtDeviceName,
            status
            );
    }

    LocalFree(*NbtDeviceName);
    *NbtDeviceName = NULL;

    //
    // Clear the interface information from the registry
    //
    if (NodeParametersKey != NULL) {
        status = ClusterRegDeleteValue(
                     NodeParametersKey,
                     L"NbtDeviceName"
                     );

        if (status != ERROR_SUCCESS) {
            (IpaLogEvent)(
                ResourceHandle,
                LOG_WARNING,
                L"Failed to delete NBT interface information from database, status %1!u!.\n",
                status
                );
        }
    }

    return;

} // IpaDeleteNbtInterface


DWORD
IpaCreateNbtInterface(
    IN  HKEY             NodeParametersKey,
    IN  RESOURCE_HANDLE  ResourceHandle,
    OUT LPWSTR *         NbtDeviceName,
    OUT LPDWORD          NbtDeviceInstance
    )
/*++

Routine Description:

    Creates a new NBT device (interface) to be bound to an IP address.

Arguments:

    NodeParametersKey - An open handle to the resource's node-specific
                        parameters key.

    ResourceHandle - The Resource Monitor handle associated with this resource.

    NbtDeviceName - A pointer to a buffer into which to place the unicode name
                    of the new NBT device.

    NbtDeviceInstance - A pointer to a variable into which to place the instance
                        value which identifies the new NBT device.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

--*/
{
    DWORD status;
    DWORD deviceNameSize = 38;  // size of L"\\Device\\NetBt_Ifxx\0"


    *NbtDeviceName = NULL;

    do {
        if (*NbtDeviceName != NULL) {
            LocalFree(*NbtDeviceName);
            *NbtDeviceName = NULL;
        }

        *NbtDeviceName = LocalAlloc(LMEM_FIXED, deviceNameSize);

        if (*NbtDeviceName == NULL) {
            (IpaLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to allocate memory.\n");
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        status = NbtAddInterface(
                     *NbtDeviceName,
                     &deviceNameSize,
                     NbtDeviceInstance
                     );

    } while (status == STATUS_BUFFER_TOO_SMALL);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create new NBT interface, status %1!u!\n",
            status
            );

        if (*NbtDeviceName != NULL) {
            LocalFree(*NbtDeviceName);
            *NbtDeviceName = NULL;
        }

        return(status);
    }

    status = ClusterRegSetValue(
                 NodeParametersKey,
                 L"NbtDeviceName",
                 REG_SZ,
                 (LPBYTE) *NbtDeviceName,
                 (lstrlenW(*NbtDeviceName) + 1) * sizeof(WCHAR)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to write NBT interface information to database, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ClusterRegSetValue(
                 NodeParametersKey,
                 L"NbtDeviceInstance",
                 REG_DWORD,
                 (LPBYTE) NbtDeviceInstance,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to write NBT interface information to database, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Created NBT interface %1!ws! (instance 0x%2!08X!).\n",
        *NbtDeviceName,
        *NbtDeviceInstance
        );

    return(ERROR_SUCCESS);


error_exit:

    if (*NbtDeviceName != NULL) {
        IpaDeleteNbtInterface(
            NbtDeviceName,
            NodeParametersKey,
            ResourceHandle
            );
    }

    return(status);
}


VOID
IpaLastOfflineCleanup(
    VOID
    )
/*++

Notes:

    Called with IpaGlobalLock held.
    Returns with IpaGlobalLock released.

--*/
{
    HCHANGE   notifyHandle = IpaClusterNotifyHandle;
    HANDLE    workerThreadHandle = IpaWorkerThreadHandle;


    if (!IsListEmpty(&IpaResourceList)) {
        PIPA_RESOURCE   resource;

        resource = CONTAINING_RECORD(
                       IpaResourceList.Flink,
                       IPA_RESOURCE,
                       Linkage
                       );

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"All resources offline - cleaning up\n"
            );
    }

    IpaClusterNotifyHandle = NULL;
    IpaWorkerThreadHandle = NULL;

    IpaReleaseGlobalLock();

    if (notifyHandle != NULL) {
        CloseClusterNotifyPort(notifyHandle);
    }

    if (workerThreadHandle != NULL) {
        WaitForSingleObject(workerThreadHandle, INFINITE);
        CloseHandle(workerThreadHandle);
    }

    return;

}  // IpaLastOfflineCleanup


DWORD
IpaFirstOnlineInit(
    IN  RESOURCE_HANDLE      ResourceHandle
    )
/*++

Notes:

    Called with IpaGlobalLock held.
    Returns with IpaGlobalLock released.

--*/
{
    DWORD     status = ERROR_SUCCESS;
    DWORD     threadId;


    IpaClusterNotifyHandle = CreateClusterNotifyPort(
                                 INVALID_HANDLE_VALUE,
                                 IpaClusterHandle,
                                 CLUSTER_CHANGE_HANDLE_CLOSE,
                                 0
                                 );

    if (IpaClusterNotifyHandle == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create cluster notify port, status %1!u!.\n",
            status
            );
        goto error_exit;
    }
    else {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Created cluster notify port.\n"
            );
    }

    IpaWorkerThreadHandle = CreateThread(
                                NULL,
                                0,
                                IpaWorkerThread,
                                NULL,
                                0,
                                &threadId
                                );

    if (IpaWorkerThreadHandle == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to create worker thread, status %1!u!.\n",
            status
            );
        goto error_exit;
    }
    else {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_INFORMATION,
            L"Created worker thread.\n"
            );
    }

    IpaReleaseGlobalLock();

    return(ERROR_SUCCESS);


error_exit:

    IpaLastOfflineCleanup();
    //
    // The lock was released.
    //

    return(status);

} // IpaFirstOnlineInit


PIPA_RESOURCE
IpaFindResourceInList(
    PVOID  Key
    )
{
    PIPA_RESOURCE   resource;
    PLIST_ENTRY     entry;


    for ( entry = IpaResourceList.Flink;
          entry != &IpaResourceList;
          entry = entry->Flink
        )
    {
        resource = CONTAINING_RECORD(
                       entry,
                       IPA_RESOURCE,
                       Linkage
                       );

        if (resource == Key) {
            return(resource);
        }
    }

    return(NULL);

} // IpaFindResourceInList


VOID
IpaValidateAndOfflineInterfaces(
    IN PIPA_RESOURCE   Resource
    )
{
    DWORD        status;


    //
    // Take care of NBT first.
    //
    if (Resource->NbtDeviceName != NULL) {
        DWORD  instance;
        IPAddr boundAddress;

        //
        // Make sure that this is still our interface.
        //
        status = NbtGetInterfaceInfo(
                     Resource->NbtDeviceName,
                     &boundAddress,
                     &instance
                     );

        if ( (status == ERROR_SUCCESS) &&
             (Resource->NbtDeviceInstance == instance)
           )
        {
            //
            // Clear the WINS addresses
            //
            status = NbtSetWinsAddrInterface(Resource->NbtDeviceName, 0, 0);

            if (status != NO_ERROR) {
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_WARNING,
                    L"Failed to clear WINS addresses for NBT device %1!ws!, status %2!u!.\n",
                    Resource->NbtDeviceName,
                    status
                    );
            }

            //
            // Unbind the interface from IP if necessary
            //
            if (boundAddress != 0) {
                status = NbtBindInterface(Resource->NbtDeviceName, 0, 0);

                if (status != ERROR_SUCCESS) {
                    //
                    // Delete the interface, since it is misbehaving.
                    //
                    (IpaLogEvent)(
                        Resource->ResourceHandle,
                        LOG_WARNING,
                        L"Failed to unbind NBT device %1!ws!, status %2!u!.\n",
                        Resource->NbtDeviceName,
                        status
                        );
                    IpaDeleteNbtInterface(
                        &(Resource->NbtDeviceName),
                        Resource->NodeParametersKey,
                        Resource->ResourceHandle
                        );
                }
            }
        }
        else {
            //
            // Querying the NBT interface failed. See if we can determine
            // why.
            //
            if (status == ERROR_WORKING_SET_QUOTA
                || status == ERROR_NO_SYSTEM_RESOURCES) {

                //
                // The NBT ioctl probably failed due to low resources.
                // Leave record of the NBT interface in our database. We
                // will clean it up next time we try to bring this resource
                // on-line or (via clusnet) when the cluster service shuts
                // down.
                //
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_INFORMATION,
                    L"NBT interface %1!ws! (instance 0x%2!08X!) could not be queried, status %3!u!.\n",
                    Resource->NbtDeviceName,
                    Resource->NbtDeviceInstance,
                    status
                    );
            }
            else {
                
                //
                // The interface is no longer valid or it isn't ours.
                // Forget about it.
                //
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_INFORMATION,
                    L"NBT interface %1!ws! (instance 0x%2!08X!) is no longer valid, status %3!u!.\n",
                    Resource->NbtDeviceName,
                    Resource->NbtDeviceInstance,
                    status
                    );
                LocalFree(Resource->NbtDeviceName);
                Resource->NbtDeviceName = NULL;

                if (Resource->NodeParametersKey != NULL) {
                    status = ClusterRegDeleteValue(
                                 Resource->NodeParametersKey,
                                 L"NbtDeviceName"
                                 );

                    if (status != ERROR_SUCCESS) {
                        (IpaLogEvent)(
                            Resource->ResourceHandle,
                            LOG_WARNING,
                            L"Failed to delete NBT interface information from database, status %1!u!.\n",
                            status
                            );
                    }
                }
            }
        }
    }

    //
    // Now take care of IP
    //
    if (Resource->NteContext != INVALID_NTE_CONTEXT) {
        TCPIP_NTE_INFO  nteInfo;

        //
        // Make sure that this is still our interface.
        //
        status = TcpipGetNTEInfo(
                     Resource->NteContext,
                     &nteInfo
                     );

        if ( (status == ERROR_SUCCESS) &&
             (nteInfo.Instance == Resource->NteInstance)
           )
        {

            //
            // In Windows 2000, TCP/IP ignores requests to set the address
            // of an NTE if the underlying interface is disconnected.
            // This can result in the same IP address being brought online
            // on two different nodes. In order to workaround this bug
            // in TCP/IP, we now delete the NTE during offline processing
            // instead of reusing it.
            //
            // Note that IpaDeleteNte() invalidates the value
            // of Resource->NteContext.
            //
            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

#if 0
            //
            // If the NTE is still online, take care of that.
            //
            if (nteInfo.Address != 0) {
                status = TcpipSetNTEAddress(Resource->NteContext, 0, 0);

                if (status != ERROR_SUCCESS) {
                    //
                    // Delete the interface, since it is misbehaving.
                    //
                    (IpaLogEvent)(
                        Resource->ResourceHandle,
                        LOG_WARNING,
                        L"Failed to clear address for IP Interface %1!u!, status %2!u!.\n",
                        Resource->NteContext,
                        status
                        );

                    IpaDeleteNte(
                        &(Resource->NteContext),
                        Resource->NodeParametersKey,
                        Resource->ResourceHandle
                        );
                }
            }
#endif
        }
        else {
            //
            // The NTE is no longer valid or isn't ours. Forget about it.
            //
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_INFORMATION,
                L"IP interface %1!u! (instance 0x%2!08X!) is no longer valid.\n",
                Resource->NteContext,
                Resource->NteInstance
                );

            Resource->NteContext = INVALID_NTE_CONTEXT;

            if (Resource->NodeParametersKey != NULL) {
                status = ClusterRegDeleteValue(
                             Resource->NodeParametersKey,
                             L"InterfaceContext"
                             );

                if (status != ERROR_SUCCESS) {
                    (IpaLogEvent)(
                        Resource->ResourceHandle,
                        LOG_WARNING,
                        L"Failed to delete IP interface information from database, status %1!u!.\n",
                        status
                        );
                }
            }
        }
        
        //
        // Tell the DNS resolver to update its list of local ip addresses.
        //
        // BUGBUG - The DNS resolver should do this automatically based
        //          on PnP events in the Whistler release. Remove this code 
        //          after verifiying that functionality.
        //
        //          This issue is tracked with bug 97134.
        // DnsNotifyResolver(0, 0);
        DnsNotifyResolverClusterIp((IP_ADDRESS)Resource->Address, FALSE);
    }

    return;

}  // IpaValidateAndOfflineInterfaces


DWORD
IpaGetNodeParameters(
    PIPA_RESOURCE   Resource,
    BOOL            OkToCreate
    )

/*++

Routine Description:

    get any node based parameters from the registry. We can't call create
    during IpaOpen so this won't do much for the first open of a new resource.

Arguments:

    Resource - pointer to IP internal resource data block

    OkToCreate - true if we can use ClusterRegCreateKey instead of
                 ClusterRegOpenKey

Return Value:

    success if everything worked ok

--*/

{
    DWORD status;

    if (Resource->NodeParametersKey == NULL) {
        //
        // create or open the resource's node-specific parameters key.
        //
        if ( OkToCreate ) {
            status = ClusterRegCreateKey(Resource->ParametersKey,
                                         Resource->NodeId,
                                         0,
                                         KEY_READ,
                                         NULL,
                                         &(Resource->NodeParametersKey),
                                         NULL);
        }
        else {
            status = ClusterRegOpenKey(Resource->ParametersKey,
                                       Resource->NodeId,
                                       KEY_READ,
                                       &(Resource->NodeParametersKey));
        }

        if (status != NO_ERROR) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to %1!ws! node parameters key, status %2!u!.\n",
                OkToCreate ? L"create" : L"open",
                status
                );

            if ( !OkToCreate ) {
                //
                // we still need to init some values in the resource data
                // block if open fails
                //
                Resource->NteContext = INVALID_NTE_CONTEXT;
                Resource->NteInstance = 0;
                Resource->NbtDeviceName = NULL;
                Resource->NbtDeviceInstance = 0;
            }

            return(status);
        }
    }

    //
    // Read the old TCP/IP and NBT parameters.
    //
    status = ResUtilGetDwordValue(
                 Resource->NodeParametersKey,
                 L"InterfaceContext",
                 &(Resource->NteContext),
                 INVALID_NTE_CONTEXT
                 );

    if (status == ERROR_SUCCESS) {
        status = ResUtilGetDwordValue(
                     Resource->NodeParametersKey,
                     L"InterfaceInstance",
                     &(Resource->NteInstance),
                     0
                     );

        if (status != ERROR_SUCCESS) {
            Resource->NteContext = INVALID_NTE_CONTEXT;
        }
    }

    // [RajDas] 493527 --> Free the NbtDeviceName string before it's reallocated.
    if (Resource->NbtDeviceName != NULL) {
    	LocalFree(Resource->NbtDeviceName);
    	Resource->NbtDeviceName = NULL;
    }

    Resource->NbtDeviceName = ResUtilGetSzValue(
                                  Resource->NodeParametersKey,
                                  L"NbtDeviceName"
                                  );

    if (Resource->NbtDeviceName != NULL) {
        status = ResUtilGetDwordValue(
                     Resource->NodeParametersKey,
                     L"NbtDeviceInstance",
                     &(Resource->NbtDeviceInstance),
                     0
                     );

        if (status != ERROR_SUCCESS) {
            LocalFree(Resource->NbtDeviceName);
            Resource->NbtDeviceName = NULL;
        }
    }

    return status;
}

DWORD
IpaInitializeInternalParameters(
    PIPA_RESOURCE   Resource
    )
{
    DWORD   status;


    ASSERT(Resource->ResourceKey != NULL);
    ASSERT(Resource->ResourceHandle != NULL);

    if (Resource->ParametersKey == NULL) {
        //
        // Open the resource's parameters key.
        //
        status = ClusterRegOpenKey(
                     Resource->ResourceKey,
                     CLUSREG_KEYNAME_PARAMETERS,
                     KEY_READ,
                     &(Resource->ParametersKey)
                     );

        if (status != NO_ERROR) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to open parameters key, status %1!u!.\n",
                status
                );
            return(status);
        }
    }

    if (Resource->NodeParametersKey == NULL) {
        status = IpaGetNodeParameters( Resource, FALSE );
    }

    Resource->InternalParametersInitialized = TRUE;

    return(ERROR_SUCCESS);

}  // IpaInitializeInternalParameters


VOID
IpaFreePrivateProperties(
    IN PIPA_PRIVATE_PROPS  PrivateProps
    )
{
    if (PrivateProps->NetworkString != NULL) {
        LocalFree(PrivateProps->NetworkString);
        PrivateProps->NetworkString = NULL;
    }

    if (PrivateProps->AddressString != NULL) {
        LocalFree(PrivateProps->AddressString);
        PrivateProps->AddressString = NULL;
    }

    if (PrivateProps->SubnetMaskString != NULL) {
        LocalFree(PrivateProps->SubnetMaskString);
        PrivateProps->SubnetMaskString = NULL;
    }

    return;

}  // IpaFreePrivateProperties


VOID
IpaFreeLocalParameters(
    IN PIPA_LOCAL_PARAMS  LocalParams
    )
{
    if (LocalParams->InterfaceId != NULL) {
        LocalFree(LocalParams->InterfaceId);
        LocalParams->InterfaceId = NULL;
    }

    if (LocalParams->InterfaceName != NULL) {
        LocalFree(LocalParams->InterfaceName);
        LocalParams->InterfaceName = NULL;
    }

    if (LocalParams->AdapterName != NULL) {
        LocalFree(LocalParams->AdapterName);
        LocalParams->AdapterName = NULL;
    }

    if (LocalParams->AdapterId != NULL) {
        LocalFree(LocalParams->AdapterId);
        LocalParams->AdapterId = NULL;
    }

    return;

} // IpaFreeLocalParameters


DWORD
IpaGetLocalParameters(
    IN      PIPA_RESOURCE       Resource,
    IN OUT  PIPA_LOCAL_PARAMS   LocalParams
    )
/*++

Routine Description:

    Reads the local parameters needed to bring an IP address resource online.

Arguments:

    Resource - Resource structure for the resource.

    LocalParams - A pointer to a structure to fill in with the new
                  local parameters.

Return Value:

    ERROR_SUCCESS if the routine is successful.
    A Win32 error code otherwise.

--*/
{
    DWORD    status;
    DWORD    valueType;
    LPWSTR   deviceName;
    DWORD    deviceNameLength;
    HKEY     interfaceKey = NULL;
    WCHAR    networkId[NETWORK_ID_LENGTH + 1];
    WCHAR    nodeId[MAX_NODE_ID_LENGTH];
    DWORD    i;
    DWORD    valueLength;
    DWORD    type;
    DWORD    interfaceIdSize = (NETINTERFACE_ID_LENGTH + 1 ) * sizeof(WCHAR);


    ZeroMemory(LocalParams, sizeof(IPA_LOCAL_PARAMS));

    LocalParams->InterfaceId = LocalAlloc(LMEM_FIXED, interfaceIdSize);

    if (LocalParams->InterfaceId == NULL) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to allocate memory for netinterface ID.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Enumerate the interface keys looking for the right one for this
    // node/network.
    //
    for (i=0; ;i++) {
        if (interfaceKey != NULL) {
            ClusterRegCloseKey(interfaceKey); interfaceKey = NULL;
        }

        valueLength = interfaceIdSize;

        status = ClusterRegEnumKey(
                     Resource->InterfacesKey,
                     i,
                     LocalParams->InterfaceId,
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            if ( status == ERROR_NO_MORE_ITEMS ) {
                status = ERROR_NETWORK_NOT_AVAILABLE;
            }

            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Open: Unable to find netinterface for node %1!ws! on network %2!ws!, status %3!u!.\n",
                Resource->NodeId,
                Resource->InternalPrivateProps.NetworkString,
                status
                );
            goto error_exit;
        }

        //
        // Open the enumerated interface key
        //
        status = ClusterRegOpenKey(
                     Resource->InterfacesKey,
                     LocalParams->InterfaceId,
                     KEY_READ,
                     &interfaceKey
                     );

        if (status != ERROR_SUCCESS) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Open: Unable to open key for network interface %1!ws!, status %2!u!.\n",
                LocalParams->InterfaceId,
                status
                );
            continue;
        }

        //
        // Read the node value.
        //
        valueLength = sizeof(nodeId);

        status = ClusterRegQueryValue(
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_NODE,
                     &type,
                     (LPBYTE) &(nodeId[0]),
                     &valueLength
                     );

        if ( status != ERROR_SUCCESS ) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Open: Unable to read node value for netinterface %1!ws!, status %2!u!.\n",
                LocalParams->InterfaceId,
                status
                );
            continue;
        }

        if (wcscmp(Resource->NodeId, nodeId) != 0) {
            continue;
        }

        //
        // Read the network value.
        //
        valueLength = sizeof(networkId);

        status = ClusterRegQueryValue(
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_NETWORK,
                     &type,
                     (LPBYTE) &(networkId[0]),
                     &valueLength
                     );

        if ( status != ERROR_SUCCESS ) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Open: Unable to read network value for netinterface %1!ws!, status %2!u!.\n",
                LocalParams->InterfaceId,
                status
                );
            continue;
        }

        if (wcscmp(
                Resource->InternalPrivateProps.NetworkString,
                networkId
                ) == 0
           )
        {
            //
            // Found the right interface key.
            //
            break;
        }
    }

    //
    // Read the adapter name for the interface.
    //
    LocalParams->AdapterName = ResUtilGetSzValue(
                                   interfaceKey,
                                   CLUSREG_NAME_NETIFACE_ADAPTER_NAME
                                   );

    if (LocalParams->AdapterName == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to read adapter name parameter for interface %1!ws!, status %2!u!.\n",
            LocalParams->InterfaceId,
            status
            );
        goto error_exit;
    }

    //
    // Read the adapter Id for the interface.
    //
    LocalParams->AdapterId = ResUtilGetSzValue(
                                   interfaceKey,
                                   CLUSREG_NAME_NETIFACE_ADAPTER_ID
                                   );

    if (LocalParams->AdapterId == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to read adapter Id parameter for interface %1!ws!, status %2!u!.\n",
            LocalParams->InterfaceId,
            status
            );
        goto error_exit;
    }

    LocalParams->InterfaceName = ResUtilGetSzValue(
                                     interfaceKey,
                                     CLUSREG_NAME_NETIFACE_NAME
                                     );

    if (LocalParams->InterfaceName == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Open: Unable to read name for netinterface %1!ws!, status %2!u!.\n",
            LocalParams->InterfaceId,
            status
            );
        goto error_exit;
    }

    ClusterRegCloseKey(interfaceKey); interfaceKey = NULL;

    //
    // Get the WINS addresses for this interface.
    //
    deviceNameLength = sizeof(WCHAR) * ( lstrlenW(NbtDevicePrefix) +
                                         lstrlenW(LocalParams->AdapterId) +
                                         lstrlenW(NbtDeviceSuffix) + 1
                                       );

    deviceName = LocalAlloc(LMEM_FIXED, deviceNameLength);

    if (deviceName == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate memory for NBT device name.\n"
            );
        goto error_exit;
    }

    lstrcpyW(deviceName, NbtDevicePrefix);
    lstrcatW(deviceName, LocalParams->AdapterId);
    lstrcatW(deviceName, NbtDeviceSuffix);

    status = NbtGetWinsAddresses(
                 deviceName,
                 &(LocalParams->NbtPrimaryWinsAddress),
                 &(LocalParams->NbtSecondaryWinsAddress)
                 );

    LocalFree(deviceName);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_WARNING,
            L"Unable to determine WINS server addresses for adapter %1!ws!, status %2!u!\n",
            LocalParams->AdapterName,
            status
            );

        //
        // NBT sets the WINS server addresses to loopback by default.
        //
        LocalParams->NbtPrimaryWinsAddress = inet_addr("127.0.0.1");
        LocalParams->NbtSecondaryWinsAddress =
            LocalParams->NbtPrimaryWinsAddress;
    }

    status = ERROR_SUCCESS;

error_exit:

    if (interfaceKey != NULL) {
        ClusterRegCloseKey(interfaceKey);
    }

    if (status != ERROR_SUCCESS) {
        IpaFreeLocalParameters(LocalParams);
    }

    return(status);

} // IpaGetLocalParameters


//
// Primary Resource Functions
//
BOOLEAN
WINAPI
IpAddrDllEntryPoint(
    IN HINSTANCE DllHandle,
    IN DWORD     Reason,
    IN LPVOID    Reserved
    )
{
    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        return(IpaInit());
        break;

    case DLL_PROCESS_DETACH:
        IpaCleanup();
        break;

    default:
        break;
    }

    return(TRUE);
}



RESID
WINAPI
IpaOpen(
    IN LPCWSTR          ResourceName,
    IN HKEY             ResourceKey,
    IN RESOURCE_HANDLE  ResourceHandle
    )

/*++

Routine Description:

    Open routine for IP Address resource

Arguments:

    ResourceName - supplies the resource name

    ResourceKey - a registry key for access registry information for this
            resource.

    ResourceHandle - the resource handle to be supplied with SetResourceStatus
            is called.

Return Value:

    RESID of created resource
    NULL on failure

--*/

{
    DWORD           status;
    PIPA_RESOURCE   resource = NULL;
    DWORD           nodeIdSize = MAX_NODE_ID_LENGTH + 1;
    HKEY            clusterKey = NULL;


    IpaAcquireGlobalLock();

    if (IpaOpenResourceCount == 0) {
        ASSERT(IpaClusterHandle == NULL);

        IpaClusterHandle = OpenCluster(NULL);

        if (IpaClusterHandle == NULL) {
            status = GetLastError();
            IpaReleaseGlobalLock();
            (IpaLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Unable to open cluster handle, status %1!u!.\n",
                status
                );
            return(0);
        }
    }

    IpaOpenResourceCount++;

    IpaReleaseGlobalLock();

    resource = LocalAlloc(
                   (LMEM_FIXED | LMEM_ZEROINIT),
                   sizeof(IPA_RESOURCE)
                   );

    if (resource == NULL) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Resource allocation failed.\n"
            );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(0);
    }

    //
    // Initialize known fields.
    //
    InitializeCriticalSection(&(resource->Lock));
    resource->ResourceHandle = ResourceHandle;
    resource->State = ClusterResourceOffline;
    resource->NteContext = INVALID_NTE_CONTEXT;

    //
    // Initialize the Linkage field as a list head. This
    // prevents an AV in IpaClose if IpaOpen fails before
    // the resource is added to IpaResourceList.
    //
    InitializeListHead(&(resource->Linkage));

    //
    // Allocate an address string buffer.
    //
    resource->InternalPrivateProps.AddressString =
        LocalAlloc(
            LMEM_FIXED,
            ( (IpaMaxIpAddressStringLength + 1) *
                sizeof(WCHAR)
            ));

    if (resource->InternalPrivateProps.AddressString == NULL) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Resource allocation failed.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    lstrcpyW(resource->InternalPrivateProps.AddressString, L"[Unknown]");

    //
    // Figure out what node we're running on.
    //
    status = GetCurrentClusterNodeId(
                 &(resource->NodeId[0]),
                 &nodeIdSize
                 );

    if ( status != ERROR_SUCCESS ) {
        status = GetLastError();
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to get local node ID, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Open a private handle to our resource key so that we can get our
    // name later if we need to log an event.
    //
    status = ClusterRegOpenKey(
                 ResourceKey,
                 L"",
                 KEY_READ,
                 &(resource->ResourceKey)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open resource key. Error: %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Open a key to the networks portion of the cluster registry.
    //
    clusterKey = GetClusterKey(IpaClusterHandle, KEY_READ);

    if (clusterKey == NULL) {
        status = GetLastError();
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open cluster registry key, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ClusterRegOpenKey(
                 clusterKey,
                 L"Networks",
                 KEY_READ,
                 &(resource->NetworksKey)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open networks registry key, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Open a key to the interfaces portion of the cluster registry.
    //
    status = ClusterRegOpenKey(
                 clusterKey,
                 L"NetworkInterfaces",
                 KEY_READ,
                 &(resource->InterfacesKey)
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open network interfaces registry key, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    ClusterRegCloseKey(clusterKey); clusterKey = NULL;

    status = IpaInitializeInternalParameters(resource);

    if (status == ERROR_SUCCESS) {
        //
        // Validate our TCP/IP and NBT parameters and clean up any old
        // interfaces we left hanging around from the last run.
        //
        IpaValidateAndOfflineInterfaces(resource);
    }

    //
    // Link the resource onto the global list.
    //
    IpaAcquireGlobalLock();

    InsertTailList(&IpaResourceList, &(resource->Linkage));

    IpaReleaseGlobalLock();

    (IpaLogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Resource open, resource ID = %1!u!.\n",
        resource
        );

    return(resource);

error_exit:

    IpaClose((RESID) resource);

    if (clusterKey != NULL) {
        ClusterRegCloseKey(clusterKey);
    }

    SetLastError( status );

    return(0);

} // IpaOpen



VOID
WINAPI
IpaDoOfflineProcessing(
    IN PIPA_RESOURCE      Resource,
    IN RESOURCE_STATUS *  ResourceStatus
    )

/*++

Routine Description:

    Final offline processing for IP Address resource.

Arguments:

    Resource - supplies the resource it to be taken offline

Return Value:

    None.

Notes:

    Called with the resource lock held.
    Returns with the resource lock released.

--*/

{
    DWORD          status = ERROR_SUCCESS;
    ULONG          address = 0, mask = 0;
    HNETINTERFACE  ifHandle;


    ASSERT(Resource->State == ClusterResourceOfflinePending);

    IpaValidateAndOfflineInterfaces(Resource);

    //
    // Make local copies of external resource handles
    //
    ifHandle = Resource->InterfaceHandle;
    Resource->InterfaceHandle = NULL;

    Resource->State = ClusterResourceOffline;

    if (ResourceStatus != NULL) {
        ResourceStatus->CheckPoint++;
        ResourceStatus->ResourceState = ClusterResourceOffline;
        (IpaSetResourceStatus)(Resource->ResourceHandle, ResourceStatus);
    }

    (IpaLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"Address %1!ws! on adapter %2!ws! offline.\n",
        Resource->InternalPrivateProps.AddressString,
        ( (Resource->LocalParams.AdapterName != NULL) ?
          Resource->LocalParams.AdapterName : L"[Unknown]"
        ));

    IpaReleaseResourceLock(Resource);

    //
    // Free external resources.
    //
    if (ifHandle != NULL) {
        CloseClusterNetInterface(ifHandle);
    }

    IpaAcquireGlobalLock();

    //
    // If this is the last resource, cleanup the global state.
    //
    ASSERT(IpaOnlineResourceCount > 0);

    if (--IpaOnlineResourceCount == 0) {
        IpaLastOfflineCleanup();
        //
        // The lock was released.
        //
    }
    else {
        IpaReleaseGlobalLock();
    }

    return;

}  // IpaDoOfflineProcessing



VOID
WINAPI
IpaInternalOffline(
    IN PIPA_RESOURCE Resource
    )

/*++

Routine Description:

    Internal offline routine for IP Address resource.

Arguments:

    Resource - supplies the resource it to be taken offline

Return Value:

    None.

--*/

{
    //
    // Terminate the online thread, if it is running.
    //
    ClusWorkerTerminate(&(Resource->OnlineThread));

    //
    // Synchronize IpaOffline, IpaTerminate, and IpaWorkerThread.
    //
    IpaAcquireResourceLock(Resource);

    if (Resource->State == ClusterResourceOffline) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_INFORMATION,
            L"Resource is already offline.\n"
            );
        IpaReleaseResourceLock(Resource);
        return;
    }

    Resource->State = ClusterResourceOfflinePending;

    IpaDoOfflineProcessing(Resource, NULL);
    //
    // The lock was released.
    //

    return;

}  // IpaInternalOffline



DWORD
WINAPI
IpaOffline(
    IN RESID Resource
    )

/*++

Routine Description:

    Offline routine for IP Address resource.

Arguments:

    Resource - supplies resource id to be taken offline.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

--*/
{
    DWORD           status;
    PIPA_RESOURCE   resource = (PIPA_RESOURCE) Resource;


    if (resource != NULL) {
        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Taking resource offline...\n"
            );
        IpaInternalOffline(resource);
        status = ERROR_SUCCESS;
    }
    else {
        status = ERROR_RESOURCE_NOT_FOUND;
    }

    return(status);

} // IpaOffline



VOID
WINAPI
IpaTerminate(
    IN RESID Resource
    )

/*++

Routine Description:

    Terminate routine for IP Address resource.

Arguments:

    Resource - supplies resource id to be terminated

Return Value:

    None.

--*/

{
    PIPA_RESOURCE   resource = (PIPA_RESOURCE) Resource;


    if (resource != NULL) {
        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Terminating resource...\n"
            );
        IpaInternalOffline(resource);
    }

    return;

} // IpaTerminate



DWORD
IpaOnlineThread(
    IN PCLUS_WORKER pWorker,
    IN PIPA_RESOURCE Resource
    )

/*++

Routine Description:

    Brings an IP address resource online.

Arguments:

    pWorker - Supplies the worker structure

    Resource - A pointer to the IPA_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS if successful.
    Win32 error code on failure.

--*/

{
    DWORD                        status = ERROR_SUCCESS;
    DWORD                        i;
    RESOURCE_EXIT_STATE          exit;
    RESOURCE_STATUS              resourceStatus;
    BOOL                         retried;
    IPA_LOCAL_PARAMS             newParams;
    PIPA_LOCAL_PARAMS            localParams = NULL;
    PIPA_PRIVATE_PROPS           privateProps = NULL;
    LPWSTR                       nameOfPropInError = NULL;
    DWORD                        networkRole;
    CLUSTER_NETINTERFACE_STATE   state;
    BOOL                         firstOnline = FALSE;
    DWORD                        numTries;


    ZeroMemory(&newParams, sizeof(newParams));

    (IpaLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"Online thread running.\n",
        Resource
        );

    IpaAcquireGlobalLock();

    IpaAcquireResourceLock(Resource);

    if (IpaOnlineResourceCount++ == 0) {
        firstOnline = TRUE;
    }

    ResUtilInitializeResourceStatus(&resourceStatus);
    resourceStatus.CheckPoint = 1;
    resourceStatus.ResourceState = ClusterResourceOnlinePending;
    exit = (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    if ( exit == ResourceExitStateTerminate ) {
        IpaReleaseGlobalLock();
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online thread aborted.\n"
            );
        status = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    //
    // If this is the first resource to go online in this process,
    // initialize the global state.
    //
    if (firstOnline) {
        status = IpaFirstOnlineInit(Resource->ResourceHandle);
        //
        // The global lock was released.
        //
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }
    else {
        IpaReleaseGlobalLock();
    }

    resourceStatus.CheckPoint++;
    exit = (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    if ( exit == ResourceExitStateTerminate ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online thread aborted.\n"
            );
        status = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    //
    // Check to see if the online operation was aborted while this thread
    // was starting up.
    //
    if (ClusWorkerCheckTerminate(pWorker)) {
        status = ERROR_OPERATION_ABORTED;
        Resource->State = ClusterResourceOfflinePending;
        goto error_exit;
    }

    if (!Resource->InternalParametersInitialized) {
        status = IpaInitializeInternalParameters(Resource);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }
    else {
        status = IpaGetNodeParameters( Resource, TRUE );
    }

    //
    // Make sure the old interfaces are valid and offline.
    //
    IpaValidateAndOfflineInterfaces(Resource);

    //
    // Read and verify the resource's private properties.
    //
    privateProps = &(Resource->InternalPrivateProps);

    status = ResUtilGetPropertiesToParameterBlock(
                 Resource->ParametersKey,
                 IpaResourcePrivateProperties,
                 (LPBYTE) privateProps,
                 TRUE, // CheckForRequiredProperties
                 &nameOfPropInError
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status
            );
        goto error_exit;
    }

    Resource->EnableNetbios = privateProps->EnableNetbios;

    //
    // Convert the address and subnet mask strings to binary.
    //
    status = ClRtlTcpipStringToAddress(
                 privateProps->AddressString,
                 &(Resource->Address)
                 );

    if (status != ERROR_SUCCESS) {
        status = ERROR_INVALID_PARAMETER;
        ClusResLogSystemEventByKeyData(
            Resource->ResourceKey,
            LOG_CRITICAL,
            RES_IPADDR_INVALID_ADDRESS,
            sizeof(Resource->Address),
            &(Resource->Address)
            );
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Invalid address %1!ws!.\n",
            privateProps->AddressString
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 privateProps->SubnetMaskString,
                 &(Resource->SubnetMask)
                 );

    if (status != ERROR_SUCCESS) {
        status = ERROR_INVALID_PARAMETER;
        ClusResLogSystemEventByKeyData(
            Resource->ResourceKey,
            LOG_CRITICAL,
            RES_IPADDR_INVALID_SUBNET,
            sizeof(Resource->SubnetMask),
            &(Resource->SubnetMask)
            );
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Invalid subnet mask %1!ws!.\n",
            privateProps->SubnetMaskString
            );
        goto error_exit;
    }

    status = IpaPatchNetworkGuidIfNecessary(Resource, privateProps);

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_WARNING,
            L"IpaPatchNetworkGuidIfNecessary failed, status %1!d!.\n",
            status
            );
    }

    //
    // The network has been chosen. Verify that its role allows 
    // IP address resources.
    //
    status = IpaGetRoleOfNetwork(
                 Resource, 
                 privateProps->NetworkString,
                 &networkRole
                 );

    if ( status != ERROR_SUCCESS ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"IpaGetRoleOfNetwork failed for network %1!ws!, "
            L"status %2!d!.\n",
            privateProps->NetworkString,
            status
            );
        goto error_exit;
    } else if ( networkRole != ClusterNetworkRoleClientAccess && 
                networkRole != ClusterNetworkRoleInternalAndClient ) {

        LPWSTR networkName = NULL;
        
        status = ERROR_CLUSTER_INVALID_NETWORK;

        networkName = IpaGetNameOfNetwork(
                          Resource, 
                          privateProps->NetworkString
                          );
        if ( networkName != NULL ) {
            ClusResLogSystemEventByKeyData1(
                Resource->ResourceKey,
                LOG_CRITICAL,
                RES_IPADDR_INVALID_NETWORK_ROLE,
                sizeof(networkRole),
                (LPBYTE) &networkRole,
                networkName
                );
        }

        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Cannot bring resource online because network %1!ws! "
            L"(%2!ws!) has role %3!u!.\n",
            privateProps->NetworkString,
            (networkName != NULL) ? networkName : L"<Unknown>",
            networkRole
            );

        if ( networkName != NULL ) {
            LocalFree(networkName);
        }
        
        goto error_exit;
    }


    //
    // Fetch the resource's parameters for the local node.
    //
    status = IpaGetLocalParameters(Resource, &newParams);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    localParams = &(Resource->LocalParams);

    //
    // Update the interface name.
    //
    if (localParams->InterfaceName != NULL) {
        LocalFree(localParams->InterfaceName);
    }

    localParams->InterfaceName = newParams.InterfaceName;
    newParams.InterfaceName = NULL;

    //
    // Update the interface ID.
    //
    if ( (localParams->InterfaceId != NULL)  &&
         (lstrcmp(localParams->InterfaceId, newParams.InterfaceId) != 0)
       )
    {
        LocalFree(localParams->InterfaceId);
        localParams->InterfaceId = NULL;

        if (Resource->InterfaceHandle != NULL) {
            CloseClusterNetInterface(Resource->InterfaceHandle);
            Resource->InterfaceHandle = NULL;
        }
    }

    if (localParams->InterfaceId == NULL) {
        localParams->InterfaceId = newParams.InterfaceId;
        newParams.InterfaceId = NULL;
    }

    //
    // Update the interface handle.
    //
    if (Resource->InterfaceHandle == NULL) {
        Resource->InterfaceHandle = OpenClusterNetInterface(
                                        IpaClusterHandle,
                                        localParams->InterfaceName
                                        );

        if (Resource->InterfaceHandle == NULL) {
            status = GetLastError();
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Online: Unable to open object for netinterface %1!ws!, status %2!u!.\n",
                localParams->InterfaceId,
                status
                );
            goto error_exit;
        }
        else {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_INFORMATION,
                L"Online: Opened object handle for netinterface %1!ws!.\n",
                localParams->InterfaceId
                );
        }
    }

    //
    // Register for state change notifications for the interface.
    //
    status = RegisterClusterNotify(
                 IpaClusterNotifyHandle,
                 ( CLUSTER_CHANGE_NETINTERFACE_STATE |
                   CLUSTER_CHANGE_NETINTERFACE_DELETED
                 ),
                 Resource->InterfaceHandle,
                 (DWORD_PTR) Resource
                 );

    if (status != ERROR_SUCCESS) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online: Unable to register notification for netinterface %1!ws!, status %2!u!.\n",
            localParams->InterfaceId,
            status
            );
        goto error_exit;
    }
    else {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_INFORMATION,
            L"Online: Registered notification for netinterface %1!ws!.\n",
            localParams->InterfaceId
            );
    }

    //
    // Check if the interface has failed already. We will sleep for a while
    // and retry under certain conditions. The network state can take a few
    // seconds to settle.
    //
    numTries = 0;

    for (;;) {

        resourceStatus.CheckPoint++;
        exit = (IpaSetResourceStatus)(
                   Resource->ResourceHandle,
                   &resourceStatus
                   );

        if ( exit == ResourceExitStateTerminate ) {
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Online thread aborted.\n"
                );
            status = ERROR_OPERATION_ABORTED;
            goto error_exit;
        }

        state = GetClusterNetInterfaceState(
                    Resource->InterfaceHandle
                    );

        if (state == ClusterNetInterfaceUp) {
            break;
        }
        else if (state == ClusterNetInterfaceUnavailable ||
                 state == ClusterNetInterfaceUnreachable )
        {
            PWCHAR stateName = ( state == ClusterNetInterfaceUnavailable ?
                                 L"available" : L"reachable" );

            if (++numTries <= 5) {
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_WARNING,
                    L"NetInterface %1!ws! is not %2!ws!. Wait & retry.\n",
                    Resource->LocalParams.InterfaceId,
                    stateName
                    );
                Sleep(1000);
                continue;
            }
            else {
                status = ERROR_IO_DEVICE;
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Timed out waiting for NetInterface %1!ws! to be available. Failing resource.\n",
                    Resource->LocalParams.InterfaceId
                    );
                goto error_exit;
            }
        }
        else if (state == ClusterNetInterfaceFailed) {
            status = ERROR_IO_DEVICE;
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"NetInterface %1!ws! has failed.\n",
                Resource->LocalParams.InterfaceId
                );
            goto error_exit;
        }
        else if (state == ClusterNetInterfaceStateUnknown) {
            status = GetLastError();
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Failed to get state for netinterface %1!ws!, status %2!u!.\n",
                Resource->LocalParams.InterfaceId,
                status
                );
                goto error_exit;
        }
        else {
            ASSERT(FALSE);
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Unrecognized state for netinterface %1!ws!, state %2!u!.\n",
                Resource->LocalParams.InterfaceId,
                state
                );
            status = ERROR_INVALID_PARAMETER;
            goto error_exit;
        }
    }

    Resource->FailureStatus = ERROR_SUCCESS;

    //
    // Update the adapter name parameter.
    //
    if (localParams->AdapterName != NULL) {
        LocalFree(localParams->AdapterName);
    }

    localParams->AdapterName = newParams.AdapterName;
    newParams.AdapterName = NULL;

    //
    // Update the adapter Id parameter.
    //
    if ((localParams->AdapterId == NULL) ||
        (lstrcmpiW(localParams->AdapterId, newParams.AdapterId) != 0)) {

        if (localParams->AdapterId != NULL) {
            LocalFree(localParams->AdapterId);
        }

        localParams->AdapterId = newParams.AdapterId;
        newParams.AdapterId = NULL;

        if (Resource->NteContext != INVALID_NTE_CONTEXT) {
            //
            // Delete the old NTE.
            //
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_INFORMATION,
                L"Adapter Id has changed to %1!ws!.\n",
                localParams->AdapterId
                );

            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );
        }
    }

    //
    // Create a new NTE if we need one.
    //
    if (Resource->NteContext == INVALID_NTE_CONTEXT) {

        status = IpaCreateNte(
                     localParams->AdapterId,
                     Resource->NodeParametersKey,
                     Resource->ResourceHandle,
                     &(Resource->NteContext),
                     &(Resource->NteInstance)
                     );

        if (status != ERROR_SUCCESS) {
            ClusResLogSystemEventByKeyData(
                Resource->ResourceKey,
                LOG_CRITICAL,
                RES_IPADDR_NTE_CREATE_FAILED,
                sizeof(status),
                &status
                );
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"Failed to created new IP interface, status %1!u!.\n",
                status
                );
            goto error_exit;
        }
    }

    //
    // Create a new NBT interface if we need one.
    //
    if (privateProps->EnableNetbios) {
        if (Resource->NbtDeviceName == NULL) {
            status = IpaCreateNbtInterface(
                         Resource->NodeParametersKey,
                         Resource->ResourceHandle,
                         &(Resource->NbtDeviceName),
                         &(Resource->NbtDeviceInstance)
                         );

            if (status != ERROR_SUCCESS) {
                ClusResLogSystemEventByKeyData(
                    Resource->ResourceKey,
                    LOG_CRITICAL,
                    RES_IPADDR_NBT_INTERFACE_CREATE_FAILED,
                    sizeof(status),
                    &status
                    );
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Failed to created new NBT interface, status %1!u!.\n",
                    status
                    );
                goto error_exit;
            }
        }
    }
    else {
        if (Resource->NbtDeviceName != NULL) {
            IpaDeleteNbtInterface(
                &(Resource->NbtDeviceName),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );
        }
    }

    //
    // Update the resource's WINS parameters
    //
    localParams->NbtPrimaryWinsAddress = newParams.NbtPrimaryWinsAddress;
    localParams->NbtSecondaryWinsAddress = newParams.NbtSecondaryWinsAddress;

    //
    // We have valid, offline interfaces to work with. Send out a few ICMP
    // Echo requests to see if any other machine has this address online.
    // If one does, we'll abort this online operation.
    //
    resourceStatus.CheckPoint++;
    exit = (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    if ( exit == ResourceExitStateTerminate ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online thread aborted.\n"
            );
        status = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    retried = FALSE;

    while (TRUE) {
        status = TcpipSetNTEAddress(
                    Resource->NteContext,
                    Resource->Address,
                    Resource->SubnetMask
                    );
        
        if(status == ERROR_SUCCESS)
            break;

        if (!retried ) {
            //
            // Check to see if the online operation was aborted while
            // this thread was blocked.
            //
            if (ClusWorkerCheckTerminate(pWorker)) {
                status = ERROR_OPERATION_ABORTED;
                Resource->State = ClusterResourceOfflinePending;
                goto error_exit;
            }

            //
            // Wait 5 secs to give the holder of the address a
            // chance to let go
            //
            Sleep(5000);

            //
            // Check to see if the online operation was aborted while
            // this thread was blocked.
            //
            if (ClusWorkerCheckTerminate(pWorker)) {
                status = ERROR_OPERATION_ABORTED;
                Resource->State = ClusterResourceOfflinePending;
                goto error_exit;
            }

            retried = TRUE;
        }
        else {
            //
            // Delete the failed NTE.
            //
            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

            status = ERROR_CLUSTER_IPADDR_IN_USE;
            ClusResLogSystemEventByKey1(
                Resource->ResourceKey,
                LOG_CRITICAL,
                RES_IPADDR_IN_USE,
                Resource->InternalPrivateProps.AddressString
                );
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_ERROR,
                L"IP address %1!ws! is already in use on the network, status %2!u!.\n",
                Resource->InternalPrivateProps.AddressString,
                status
                );
            goto error_exit;
        }
    }

    //
    // Check to see if the online operation was aborted while this thread
    // was blocked.
    //
    if (ClusWorkerCheckTerminate(pWorker)) {
        status = ERROR_OPERATION_ABORTED;
        Resource->State = ClusterResourceOfflinePending;
        goto error_exit;
    }

    resourceStatus.CheckPoint++;
    exit = (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    if ( exit == ResourceExitStateTerminate ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Online thread aborted.\n"
            );
        status = ERROR_OPERATION_ABORTED;
        goto error_exit;
    }

    if (Resource->EnableNetbios) {
        //
        // Bind NBT to the NTE
        //
        status = NbtBindInterface(
                     Resource->NbtDeviceName,
                     Resource->Address,
                     Resource->SubnetMask
                     );

        if (status != ERROR_SUCCESS) {
            (IpaLogEvent)(
               Resource->ResourceHandle,
               LOG_ERROR,
               L"Failed to bind NBT interface %1!ws! to IP address %2!ws!, status %3!u!.\n",
               Resource->NbtDeviceName,
               Resource->InternalPrivateProps.AddressString,
               status
               );

            //
            // Delete the failed NBT interface.
            //
            IpaDeleteNbtInterface(
                &(Resource->NbtDeviceName),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

            //
            // Take the IP address offline
            //
            // In Windows 2000, TCP/IP ignores requests to set the address
            // of an NTE if the underlying interface is disconnected.
            // This can result in the same IP address being brought online
            // on two different nodes. In order to workaround this bug
            // in TCP/IP, we now delete the NTE during offline processing
            // instead of reusing it.
            //
            // Note that IpaDeleteNte() invalidates the value
            // of Resource->NteContext.
            //
            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );
#if 0
            TcpipSetNTEAddress(Resource->NteContext, 0, 0);
#endif

            goto error_exit;
        }

        //
        // Set the WINS addresses
        //
        status = NbtSetWinsAddrInterface(
                     Resource->NbtDeviceName,
                     localParams->NbtPrimaryWinsAddress,
                     localParams->NbtSecondaryWinsAddress
                     );

        if (status != ERROR_SUCCESS) {
            ClusResLogSystemEventByKeyData1(
                Resource->ResourceKey,
                LOG_CRITICAL,
                RES_IPADDR_WINS_ADDRESS_FAILED,
                sizeof(status),
                &status,
                Resource->NbtDeviceName
                );

            (IpaLogEvent)(
               Resource->ResourceHandle,
               LOG_ERROR,
               L"Failed to set WINS addresses on NBT interface %1!ws!, status %2!u!.\n",
               Resource->NbtDeviceName,
               status
               );

            //
            // Delete the failed NBT interface.
            //
            IpaDeleteNbtInterface(
                &(Resource->NbtDeviceName),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

            //
            // Take the IP address offline
            //
            // In Windows 2000, TCP/IP ignores requests to set the address
            // of an NTE if the underlying interface is disconnected.
            // This can result in the same IP address being brought online
            // on two different nodes. In order to workaround this bug
            // in TCP/IP, we now delete the NTE during offline processing
            // instead of reusing it.
            //
            // Note that IpaDeleteNte() invalidates the value
            // of Resource->NteContext.
            //
            IpaDeleteNte(
                &(Resource->NteContext),
                Resource->NodeParametersKey,
                Resource->ResourceHandle
                );

#if 0
            TcpipSetNTEAddress(Resource->NteContext, 0, 0);
#endif

            goto error_exit;
        }
    }

    //
    // Tell the DNS resolver to update its list of local ip addresses.
    //
    // BUGBUG - The DNS resolver should do this automatically based
    //          on PnP events in the Whistler release. Remove this code 
    //          after verifiying that functionality.
    //
    //          This issue is tracked with bug 97134.
    // DnsNotifyResolver(0, 0);
    DnsNotifyResolverClusterIp((IP_ADDRESS)Resource->Address, TRUE);
    
    Resource->State = ClusterResourceOnline;

    resourceStatus.CheckPoint++;
    resourceStatus.ResourceState = ClusterResourceOnline;
    (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

    (IpaLogEvent)(
        Resource->ResourceHandle,
        LOG_INFORMATION,
        L"IP Address %1!ws! on adapter %2!ws! online\n",
        Resource->InternalPrivateProps.AddressString,
        localParams->AdapterName
        );

    IpaReleaseResourceLock(Resource);

    IpaFreeLocalParameters(&newParams);

    return(ERROR_SUCCESS);


error_exit:

    ASSERT(status != ERROR_SUCCESS);

    if (Resource->State == ClusterResourceOfflinePending) {
        IpaDoOfflineProcessing(Resource, &resourceStatus);
        //
        // The resource lock was released.
        //
    }
    else {
        Resource->State = ClusterResourceFailed;

        resourceStatus.CheckPoint++;
        resourceStatus.ResourceState = ClusterResourceFailed;
        (IpaSetResourceStatus)(Resource->ResourceHandle, &resourceStatus);

        IpaReleaseResourceLock(Resource);
    }

    IpaFreeLocalParameters(&newParams);

    return(status);

} // IpaOnlineThread



DWORD
WINAPI
IpaOnline(
    IN RESID Resource,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for IP Address resource.

Arguments:

    Resource - supplies resource id to be brought online

    EventHandle - supplies a pointer to a handle to signal on error.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_RESOURCE_NOT_FOUND if RESID is not valid.
    ERROR_RESOURCE_NOT_AVAILABLE if resource was arbitrated but failed to
        acquire 'ownership'.
    Win32 error code if other failure.

--*/

{
    PIPA_RESOURCE          resource = (PIPA_RESOURCE)Resource;
    DWORD                  status;


    if (resource != NULL) {
        IpaAcquireResourceLock(resource);

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Bringing resource online...\n",
            Resource
            );

        ASSERT(resource->OnlineThread.hThread == NULL);
        ASSERT(
            (resource->State == ClusterResourceOffline) ||
            (resource->State == ClusterResourceFailed)
            );

        resource->State = ClusterResourceOnlinePending;

        status = ClusWorkerCreate(
                     &(resource->OnlineThread),
                     IpaOnlineThread,
                     resource
                     );

        if (status != ERROR_SUCCESS) {
            resource->State = ClusterResourceOffline;
            (IpaLogEvent)(
                resource->ResourceHandle,
                LOG_ERROR,
                L"Unable to start online thread, status %1!u!.\n",
                status
                );
        } else {
            status = ERROR_IO_PENDING;
        }

        IpaReleaseResourceLock(resource);

    } else {
        status = ERROR_RESOURCE_NOT_FOUND;
    }

    return(status);

}  // IpaOnline


DWORD
IpaWorkerThread(
    LPVOID   Context
    )
{
    DWORD                        status;
    DWORD                        dwFilter;
    DWORD_PTR                    key;
    DWORD                        event;
    PIPA_RESOURCE                resource;
    CLUSTER_NETINTERFACE_STATE   state;
    HCHANGE                      notifyHandle;


    IpaAcquireGlobalLock();

    notifyHandle = IpaClusterNotifyHandle;

    if (notifyHandle == NULL) {
        if (!IsListEmpty(&IpaResourceList)) {
            resource = CONTAINING_RECORD(
                           IpaResourceList.Flink,
                           IPA_RESOURCE,
                           Linkage
                           );

            (IpaLogEvent)(
                resource->ResourceHandle,
                LOG_ERROR,
                L"WorkerThread aborted.\n"
                );
        }

        IpaReleaseGlobalLock();

        return(ERROR_INVALID_PARAMETER);
    }

    if (!IsListEmpty(&IpaResourceList)) {
        resource = CONTAINING_RECORD(
                       IpaResourceList.Flink,
                       IPA_RESOURCE,
                       Linkage
                       );

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"WorkerThread running\n"
            );
    }

    IpaReleaseGlobalLock();

    do {
        status = GetClusterNotify(
                     notifyHandle,
                     &key,
                     &event,
                     NULL,
                     NULL,
                     INFINITE
                     );

        if (status == ERROR_SUCCESS) {
            if ( (event == CLUSTER_CHANGE_NETINTERFACE_STATE) ||
                 (event == CLUSTER_CHANGE_NETINTERFACE_DELETED)
               )
            {

                IpaAcquireGlobalLock();

                resource = IpaFindResourceInList((PVOID) key);

                if (resource != NULL) {

                    IpaAcquireResourceLock(resource);

                    IpaReleaseGlobalLock();

                    if( (resource->State == ClusterResourceOnline) ||
                        (resource->State == ClusterResourceOnlinePending)
                      )
                    {
                        //
                        // Process the event.
                        //
                        if (event == CLUSTER_CHANGE_NETINTERFACE_STATE) {

                            resource->FailureStatus = ERROR_SUCCESS;

                            state = GetClusterNetInterfaceState(
                                        resource->InterfaceHandle
                                        );

                            if (state == ClusterNetInterfaceStateUnknown) {
                                status = GetLastError();
                                (IpaLogEvent)(
                                    resource->ResourceHandle,
                                    LOG_ERROR,
                                    L"WorkerThread: Failed to get state for netinterface %1!ws!, status %2!u!.\n",
                                    resource->LocalParams.InterfaceId,
                                    status
                                    );
                            }
                            else if ((state == ClusterNetInterfaceFailed) ||
                                     (state == ClusterNetInterfaceUnavailable)
                                    )
                            {
                                resource->FailureStatus = ERROR_IO_DEVICE;
                                (IpaLogEvent)(
                                    resource->ResourceHandle,
                                    LOG_WARNING,
                                    L"WorkerThread: NetInterface %1!ws! has failed. Failing resource.\n",
                                    resource->LocalParams.InterfaceId
                                    );
                            }
                            else {
                                (IpaLogEvent)(
                                    resource->ResourceHandle,
                                    LOG_WARNING,
                                    L"WorkerThread: NetInterface %1!ws! changed to state %2!u!.\n",
                                    resource->LocalParams.InterfaceId,
                                    state
                                    );
                            }
                        }
                        else {
                            ASSERT(
                                event == CLUSTER_CHANGE_NETINTERFACE_DELETED
                                );
                            resource->FailureStatus = ERROR_DEV_NOT_EXIST;
                            (IpaLogEvent)(
                                resource->ResourceHandle,
                                LOG_ERROR,
                                L"WorkerThread: NetInterface %1!ws! was deleted. Failing resource.\n",
                                resource->LocalParams.InterfaceId
                                );
                        }
                    }

                    IpaReleaseResourceLock(resource);
                }
                else {
                    IpaReleaseGlobalLock();
                }
            }
            else if (event == CLUSTER_CHANGE_HANDLE_CLOSE) {
                //
                // Time to exit.
                //
                break;
            }
            else {
                IpaAcquireGlobalLock();

                if (!IsListEmpty(&IpaResourceList)) {
                    resource = CONTAINING_RECORD(
                                   IpaResourceList.Flink,
                                   IPA_RESOURCE,
                                   Linkage
                                   );

                    (IpaLogEvent)(
                        resource->ResourceHandle,
                        LOG_WARNING,
                        L"WorkerThread: Received unknown event %1!u!.\n",
                        event
                        );
                }

                IpaReleaseGlobalLock();

                ASSERT(event);
            }
        }
        else {
            IpaAcquireGlobalLock();

            if (!IsListEmpty(&IpaResourceList)) {
                resource = CONTAINING_RECORD(
                               IpaResourceList.Flink,
                               IPA_RESOURCE,
                               Linkage
                               );

                (IpaLogEvent)(
                    resource->ResourceHandle,
                    LOG_ERROR,
                    L"WorkerThread: GetClusterNotify failed with status %1!u!.\n",
                    status
                    );
            }

            IpaReleaseGlobalLock();

            break;
        }

    } while (status == ERROR_SUCCESS);

    IpaAcquireGlobalLock();

    if (!IsListEmpty(&IpaResourceList)) {
        resource = CONTAINING_RECORD(
                       IpaResourceList.Flink,
                       IPA_RESOURCE,
                       Linkage
                       );

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"WorkerThread terminating\n"
            );
    }

    IpaReleaseGlobalLock();

    return(status);

}  // IpaWorkerThread



BOOL
WINAPI
IpaInternalLooksAlive(
    IN RESID Resource,
    IN LPWSTR Mode
    )

/*++

Routine Description:

    LooksAlive routine for IP Address resource.

Arguments:

    Resource - supplies the resource id to be polled.

    Mode - string indicating "Looks" or "Is"

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    PIPA_RESOURCE   resource = (PIPA_RESOURCE) Resource;
    BOOLEAN         returnValue = TRUE;
    TCPIP_NTE_INFO  nteInfo;
    DWORD           status;
    IPAddr          address;
    DWORD           instance;


    if (resource != NULL) {

        IpaAcquireResourceLock(resource);

        if (resource->FailureStatus == ERROR_SUCCESS) {
            status = TcpipGetNTEInfo(resource->NteContext, &nteInfo);

            if (status != ERROR_SUCCESS) {
                returnValue = FALSE;
            }
            else if (nteInfo.Instance == resource->NteInstance) {
                if (resource->EnableNetbios) {
                    status = NbtGetInterfaceInfo(
                                 resource->NbtDeviceName,
                                 &address,
                                 &instance
                                 );

                    if (status != ERROR_SUCCESS) {
                        returnValue = FALSE;
                    }
                    else if (instance != resource->NbtDeviceInstance) {
                        status = ERROR_DEV_NOT_EXIST;
                        returnValue = FALSE;
                    }
                }
            }
            else {
                status = ERROR_DEV_NOT_EXIST;
                returnValue = FALSE;
            }
        }
        else {
            status = resource->FailureStatus;
            returnValue = FALSE;
        }

        if (!returnValue) {
            ClusResLogSystemEventByKeyData(
                resource->ResourceKey,
                LOG_CRITICAL,
                RES_IPADDR_NTE_INTERFACE_FAILED,
                sizeof(status),
                &status
                );
            (IpaLogEvent)(
                resource->ResourceHandle,
                LOG_WARNING,
                L"IP Interface %1!u! (address %2!ws!) failed %3!ws!Alive check, status %4!u!, address 0x%5!lx!, instance 0x%6!lx!.\n",
                resource->NteContext,
                resource->InternalPrivateProps.AddressString,
                Mode,
                status,
                address,
                resource->NteInstance
                );
        }

        IpaReleaseResourceLock(resource);
    }

    return(returnValue);

}  // IpaInternalLooksAliveCheck


BOOL
WINAPI
IpaLooksAlive(
    IN RESID Resource
    )

/*++
Routine Description:

    LooksAlive routine for IP Address resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource looks like it is alive and well

    FALSE - Resource looks like it is toast.

--*/

{
    return(IpaInternalLooksAlive(Resource, L"Looks"));
}



BOOL
WINAPI
IpaIsAlive(
    IN RESID Resource
    )

/*++

Routine Description:

    IsAlive routine for IP Address resource.

Arguments:

    Resource - supplies the resource id to be polled.

Return Value:

    TRUE - Resource is alive and well

    FALSE - Resource is toast.

--*/

{
    return(IpaInternalLooksAlive(Resource, L"Is"));
}



VOID
WINAPI
IpaClose(
    IN RESID Resource
    )

/*++

Routine Description:

    Close routine for IP Address resource.

Arguments:

    Resource - supplies resource id to be closed.

Return Value:

    None.

--*/

{
    PIPA_RESOURCE   resource = (PIPA_RESOURCE)Resource;
    PLIST_ENTRY     entry;
    TCPIP_NTE_INFO  nteInfo;
    DWORD           status;


    if (resource != NULL) {
        //
        // First, terminate the online thread without the lock.
        //
        ClusWorkerTerminate(&(resource->OnlineThread));

        IpaAcquireGlobalLock();

        IpaAcquireResourceLock(resource);

        //
        // Remove the resource from the global list
        //
        RemoveEntryList(&(resource->Linkage));

        IpaReleaseResourceLock(resource);

        IpaOpenResourceCount--;

        if ((IpaOpenResourceCount == 0) && (IpaClusterHandle != NULL)) {
            HCLUSTER  handle = IpaClusterHandle;


            IpaClusterHandle = NULL;

            IpaReleaseGlobalLock();

            CloseCluster(handle);
        }
        else {
            IpaReleaseGlobalLock();
        }

        //
        // Delete the resource's parameters
        //
        if (resource->NbtDeviceName != NULL) {
            //
            // Try to delete it.
            //
            IpaDeleteNbtInterface(
                &(resource->NbtDeviceName),
                resource->NodeParametersKey,
                resource->ResourceHandle
                );
        }

        if (resource->NteContext != INVALID_NTE_CONTEXT) {
            //
            // Try to delete it.
            //
            IpaDeleteNte(
                &(resource->NteContext),
                resource->NodeParametersKey,
                resource->ResourceHandle
                );
        }

        IpaFreePrivateProperties(&(resource->InternalPrivateProps));
        IpaFreeLocalParameters(&(resource->LocalParams));

        if (resource->ResourceKey != NULL) {
            ClusterRegCloseKey(resource->ResourceKey);
        }

        if (resource->ParametersKey != NULL) {
            ClusterRegCloseKey(resource->ParametersKey);
        }

        if (resource->NodeParametersKey != NULL) {
            ClusterRegCloseKey(resource->NodeParametersKey);
        }

        if (resource->NetworksKey != NULL) {
            ClusterRegCloseKey(resource->NetworksKey);
        }

        if (resource->InterfacesKey != NULL) {
            ClusterRegCloseKey(resource->InterfacesKey);
        }

        DeleteCriticalSection(&(resource->Lock));

        (IpaLogEvent)(
            resource->ResourceHandle,
            LOG_INFORMATION,
            L"Resource closed.\n"
            );

        LocalFree(resource);
    }

    return;

} // IpaClose



DWORD
IpaResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Generic Application resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs.

--*/

{
    DWORD           status;
    PIPA_RESOURCE   resource = (PIPA_RESOURCE) ResourceId;
    DWORD           resourceIndex;
    DWORD           required;


    if ( resource == NULL ) {
        DBG_PRINT( "IPAddress: ResourceControl request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return(FALSE);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( IpaResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;


        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties(
                         IpaResourcePrivateProperties,
                         OutBuffer,
                         OutBufferSize,
                         BytesReturned,
                         &required
                         );

            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }

            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = IpaGetPrivateResProperties(
                         resource,
                         OutBuffer,
                         OutBufferSize,
                         BytesReturned
                         );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = IpaValidatePrivateResProperties(
                         resource,
                         InBuffer,
                         InBufferSize,
                         NULL
                         );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = IpaSetPrivateResProperties(
                         resource,
                         InBuffer,
                         InBufferSize
                         );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // IpaResourceControl



DWORD
IpaResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Generic Application resources.

    Perform the control request specified by ControlCode on this resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs.

--*/

{
    DWORD           status;
    DWORD           required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( IpaResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties(
                         IpaResourcePrivateProperties,
                         OutBuffer,
                         OutBufferSize,
                         BytesReturned,
                         &required
                         );

            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }

            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // IpaResourceTypeControl



DWORD
IpaGetPrivateResProperties(
    IN OUT PIPA_RESOURCE Resource,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type IP Address.

Arguments:

    Resource - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs.

--*/

{
    DWORD                   status;
    DWORD                   statusReturn = ERROR_SUCCESS;
    DWORD                   required;
    IPA_PRIVATE_PROPS       props;
    LPWSTR                  networkName;
    LPWSTR                  nameOfPropInError;


    ZeroMemory(&props, sizeof(props));

    status = ResUtilGetPropertiesToParameterBlock(
                 Resource->ParametersKey,
                 IpaResourcePrivateProperties,
                 (LPBYTE) &props,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    if ( status != ERROR_SUCCESS ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        statusReturn = status;
        goto error_exit;
    }

    //
    // Find the name of the network if we read the network GUID.
    //
    if ( props.NetworkString != NULL ) {
        networkName = IpaGetNameOfNetworkPatchGuidIfNecessary(Resource, &props);

        if ( networkName == NULL ) {
            status = GetLastError();
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Error getting name of network whose GUID is '%1' property. Error: %2!u!.\n",
                props.NetworkString,
                status
                );
            status = ERROR_SUCCESS;
        } else {
            LocalFree( props.NetworkString );
            props.NetworkString = networkName;
        }
    }

    //
    // Construct a property list from the parameter block.
    //
    status = ResUtilPropertyListFromParameterBlock(
                 IpaResourcePrivateProperties,
                 OutBuffer,
                 &OutBufferSize,
                 (LPBYTE) &props,
                 BytesReturned,
                 &required
                 );

    //
    // Add unknown properties to the property list.
    //
    if ( (status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA ) ) {
        statusReturn = status;
        status = ResUtilAddUnknownProperties(
                     Resource->ParametersKey,
                     IpaResourcePrivateProperties,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     &required
                     );
        if ( status != ERROR_SUCCESS ) {
            statusReturn = status;
        }

        if ( statusReturn == ERROR_MORE_DATA ) {
            *BytesReturned = required;
        }
    }

error_exit:

    ResUtilFreeParameterBlock(
        (LPBYTE) &props,
        NULL,
        IpaResourcePrivateProperties
        );

    return(statusReturn);

} // IpaGetPrivateResProperties



DWORD
IpaValidatePrivateResProperties(
    IN OUT PIPA_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PIPA_PRIVATE_PROPS Props
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type IP Address.

Arguments:

    Resource - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Props - Supplies the property block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs.

--*/

{
    DWORD                  status;
    DWORD                  required;
    IPA_PRIVATE_PROPS      currentProps;
    LPWSTR                 networkId;
    LPWSTR                 networkName;
    LPWSTR                 nameOfPropInError;
    IPA_PRIVATE_PROPS      newProps;
    PIPA_PRIVATE_PROPS     pNewProps = NULL;
    DWORD                  networkRole;


    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) || (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Capture the current set of private properties from the registry.
    //
    ZeroMemory(&currentProps, sizeof(currentProps));

    IpaAcquireResourceLock(Resource);

    status = ResUtilGetPropertiesToParameterBlock(
                 Resource->ParametersKey,
                 IpaResourcePrivateProperties,
                 (LPBYTE) &currentProps,
                 FALSE, /*CheckForRequiredProperties*/
                 &nameOfPropInError
                 );

    IpaReleaseResourceLock(Resource);

    if ( status != ERROR_SUCCESS ) {
        (IpaLogEvent)(
            Resource->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (nameOfPropInError == NULL ? L"" : nameOfPropInError),
            status );
        goto error_exit;
    }

    //
    // Find the name of the network if we read the network GUID.
    //
    if ( currentProps.NetworkString != NULL ) {
        networkName = IpaGetNameOfNetworkPatchGuidIfNecessary(
                          Resource,
                          &currentProps
                          );

        if ( networkName == NULL ) {

            //
            // this is not necessarily an error. Changing the network of the
            // NIC on which this resource is dependent will cause the old
            // network GUID in the registry to be invalid. If the user has
            // specified a new network, we'll discover later on in this
            // routine and get the correct GUID.
            //
            status = GetLastError();
            (IpaLogEvent)(
                Resource->ResourceHandle,
                LOG_WARNING,
                L"Error getting name of network whose GUID is '%1' property. Error: %2!u!.\n",
                currentProps.NetworkString,
                status
                );
        }

        LocalFree( currentProps.NetworkString );
        currentProps.NetworkString = networkName;
    }

    //
    // Duplicate the current parameter block.
    //
    if ( Props == NULL ) {
        pNewProps = &newProps;
    } else {
        pNewProps = Props;
    }

    ZeroMemory( pNewProps, sizeof(IPA_PRIVATE_PROPS) );

    status = ResUtilDupParameterBlock(
                 (LPBYTE) pNewProps,
                 (LPBYTE) &currentProps,
                 IpaResourcePrivateProperties
                 );

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // Parse and validate the new properties.
    //
    status = ResUtilVerifyPropertyTable(
                 IpaResourcePrivateProperties,
                 NULL,
                 TRUE,    // Allow unknowns
                 InBuffer,
                 InBufferSize,
                 (LPBYTE) pNewProps
                 );

    if ( status == ERROR_SUCCESS ) {
        ULONG newIpAddress = 0;
        //
        // Validate the parameter values.
        //
        if (pNewProps->NetworkString != NULL) {
            //
            // Get the network ID for the specified network.
            //
            networkId = IpaGetIdOfNetwork(
                            Resource,
                            pNewProps->NetworkString
                            );

            if ( networkId == NULL ) {
                status = GetLastError();
                goto error_exit;
            }

            LocalFree( pNewProps->NetworkString );
            pNewProps->NetworkString = networkId;

            //
            // Verify that the network role allows an IP address resource.
            //
            status = IpaGetRoleOfNetwork(
                         Resource,
                         networkId,
                         &networkRole
                         );
            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

             if ( networkRole != ClusterNetworkRoleClientAccess && 
                  networkRole != ClusterNetworkRoleInternalAndClient ) {
                 
                (IpaLogEvent)(
                    Resource->ResourceHandle,
                    LOG_ERROR,
                    L"Cannot set network to %1!ws! because "
                    L"network role (%2!u!) does not allow "
                    L"IP address resources.\n",
                    networkId,
                    networkRole
                    );
                status = ERROR_CLUSTER_INVALID_NETWORK;
                goto error_exit;
            }
        }

        if (pNewProps->AddressString != NULL) {
            //
            // Validate the IP address.
            //
            ULONG   nAddress;

            status = ClRtlTcpipStringToAddress(
                         pNewProps->AddressString,
                         &nAddress
                         );

            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            if ( ClRtlIsValidTcpipAddress( nAddress ) == FALSE ) {
                status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }

            newIpAddress = nAddress;

            //
            // if the address is changed, make sure it is not a duplicate
            //
            if (lstrcmpW(
                    pNewProps->AddressString,
                    currentProps.AddressString
                    ) != 0
               )
            {
                BOOL isDuplicate;

                isDuplicate = ClRtlIsDuplicateTcpipAddress(nAddress);

                if (isDuplicate) {
                    //
                    // If this isn't the address we currently have online,
                    // then it is a duplicate.
                    //
                    IpaAcquireResourceLock(Resource);

                    if (!( ((Resource->State == ClusterResourceOnlinePending)
                            ||
                            (Resource->State == ClusterResourceOnline)
                            ||
                            (Resource->State == ClusterResourceOfflinePending)
                           )
                           &&
                           (lstrcmpW(
                               pNewProps->AddressString,
                               Resource->InternalPrivateProps.AddressString
                               ) == 0
                           )
                         )
                       )
                    {
                        status = ERROR_CLUSTER_IPADDR_IN_USE;
                        IpaReleaseResourceLock(Resource);
                        goto error_exit;
                    }

                    IpaReleaseResourceLock(Resource);
                }
            }
        }

        if (pNewProps->SubnetMaskString != NULL) {
            //
            // Validate the subnet mask.
            //
            ULONG   nAddress;

            status = ClRtlTcpipStringToAddress(
                         pNewProps->SubnetMaskString,
                         &nAddress
                         );

            if ( status != ERROR_SUCCESS ) {
                goto error_exit;
            }

            if ( ClRtlIsValidTcpipSubnetMask( nAddress ) == FALSE ) {
                status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }

            if (newIpAddress &&
                (ClRtlIsValidTcpipAddressAndSubnetMask(newIpAddress, nAddress) == FALSE) ) {
                status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }
        }
    }

error_exit:

    //
    // Cleanup our parameter block.
    //
    if (
        ( status != ERROR_SUCCESS && pNewProps != NULL )
        ||
        ( pNewProps == &newProps )
       )
    {
        ResUtilFreeParameterBlock(
            (LPBYTE) pNewProps,
            (LPBYTE) &currentProps,
            IpaResourcePrivateProperties
            );
    }

    ResUtilFreeParameterBlock(
        (LPBYTE) &currentProps,
        NULL,
        IpaResourcePrivateProperties
        );

    return(status);

} // IpaValidatePrivateResProperties



DWORD
IpaSetPrivateResProperties(
    IN OUT PIPA_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type IP Address.

Arguments:

    Resource - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

Notes:

    We don't need to acquire the resource lock because the Cluster Service
    guarantees synchronization with other APIs. The asynchronous OnlineThread
    isn't a problem because we captured its properties during the IpaOnline
    routine.

--*/

{
    DWORD                  status;
    IPA_PRIVATE_PROPS      props;


    ZeroMemory( &props, sizeof(IPA_PRIVATE_PROPS) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = IpaValidatePrivateResProperties(
                 Resource,
                 InBuffer,
                 InBufferSize,
                 &props
                 );

    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    IpaAcquireResourceLock(Resource);

    //
    // Save the parameter values.
    //
    status = ResUtilSetPropertyParameterBlock(
                 Resource->ParametersKey,
                 IpaResourcePrivateProperties,
                 NULL,
                 (LPBYTE) &props,
                 InBuffer,
                 InBufferSize,
                 NULL
                 );

    //
    // If the resource is online, return a non-success status.
    //
    // Note that we count on the fact that 32-bit reads are atomic.
    //
    if (status == ERROR_SUCCESS) {
        DWORD state = Resource->State;

        if ( (state == ClusterResourceOnline) ||
             (state == ClusterResourceOnlinePending)
           )
        {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    IpaReleaseResourceLock(Resource);

    ResUtilFreeParameterBlock(
        (LPBYTE) &props,
        NULL,
        IpaResourcePrivateProperties
        );

    return status;

} // IpaSetPrivateResProperties



//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( IpAddrFunctionTable,  // Name
                         CLRES_VERSION_V1_00,  // Version
                         Ipa,                  // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         IpaResourceControl,   // ResControl
                         IpaResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ipaddr\util.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Utility functions for IP Address resource.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/

BOOLEAN
UnicodeInetAddr(
    PWCHAR  AddressString,
    PULONG  Address
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ipaddr\nteapi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nteapi.h

Abstract:

    Definitions of routines for manipulating dynamic IP Network Table
    Entries (NTEs) and NBT devices (interfaces).

Author:

    Mike Massa (mikemas)  18-Mar-1996

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NTEAPI_INCLUDED_
#define _NTEAPI_INCLUDED_


//
// Types
//
typedef struct {
    unsigned long   Instance;
    IPAddr          Address;
    IPMask          SubnetMask;
    unsigned long   Flags;
} TCPIP_NTE_INFO, *PTCPIP_NTE_INFO;

#define TCPIP_NTE_DYNAMIC 0x00000010


//
// APIs
//
DWORD
TcpipAddNTE(
    IN  LPWSTR  AdapterName,
    IN  IPAddr  Address,
    IN  IPMask  SubnetMask,
    OUT PULONG  NTEContext,
    OUT PULONG  NTEInstance
    );
/*++

Routine Description:

    Adds a new NTE to a specified IP interface. The target IP interface is
    identified by the name of the adapter associated with it.

Arguments:

    AdapterName - A unicode string identifying the adapter/interface to which
                  to add the new NTE.

    Address - The IP address to assign to the new NTE.

    SubnetMask - The IP subnet mask to assign to the new NTE.

    NTEContext - On output, contains the context value identifying the new NTE.

    NTEInstance - On output, contains the instance ID of the new NTE.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
TcpipDeleteNTE(
    IN ULONG  NTEContext
    );
/*++

Routine Description:

    Deletes a specified NTE. The target NTE must have been added using
    TcpipAddNTE.

Arguments:

    NTEContext - The context value identifying the NTE to delete.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
TcpipSetNTEAddress(
    IN DWORD   NTEContext,
    IN IPAddr  Address,
    IN IPMask  SubnetMask
    );
/*++

Routine Description:

    Sets the address of a specified NTE.

Arguments:

    NTEContext - The context value identifying the target NTE.

    Address - The IP address to assign to the NTE. Assigning 0.0.0.0
              invalidates the NTE.

    SubnetMask - The IP subnet mask to assign to the NTE.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
TcpipGetNTEInfo(
    IN  ULONG            NTEContext,
    OUT PTCPIP_NTE_INFO  NTEInfo
    );
/*++

Routine Description:

    Gathers information about a specified NTE.

Arguments:

    NTEContext - The context value identifying the NTE to query.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
NbtAddInterface(
    OUT    LPWSTR   DeviceName,
    IN OUT LPDWORD  DeviceNameSize,
    OUT    PULONG   DeviceInstance
    );
/*++

Routine Description:

    Adds a new NBT interface.

Arguments:

    DeviceName - A unicode string identifying the new NBT interface.

    DeviceNameSize - On input, the size of theh device name buffer.
                     On output, the size of the device name string, or
                     the size needed to accomodate the string.

    DeviceInstance - A pointer to a variable into which to place the
                     instance ID associated with the new interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
NbtDeleteInterface(
    IN LPWSTR   DeviceName
    );
/*++

Routine Description:

    Deletes an NBT interface.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
NbtBindInterface(
    IN LPWSTR  DeviceName,
    IN IPAddr  Address,
    IN IPMask  SubnetMask
    );
/*++

Routine Description:

    Binds a specified NBT interface to a specified IP address.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    Address - The IP address to which bind the interface. Assigning 0.0.0.0
              invalidates the interface.

    SubnetMask - The subnet mask of the IP interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/

DWORD
NbtSetWinsAddrInterface(
    IN LPWSTR  DeviceName,
    IN IPAddr  PrWinsAddress,
    IN IPAddr  SecWinsAddress
    );
/*++

Routine Description:

    Sets the WINS addrs for a given Nbt Interface.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    PrWinsAddress - Primary WINS addr

    SecWinsAddress - Secondary WINS addr

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/

DWORD
NbtGetInterfaceInfo(
    IN LPWSTR    DeviceName,
    OUT IPAddr * Address,
    OUT PULONG   DeviceInstance
    );
/*++

Routine Description:

    Returns the IP address to which an NBT interface is bound and the interface
    instance ID.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    Address - A pointer to the location in which to store the address of the
              interface.

    DeviceInstance - A pointer to the location in which to store the instance ID
                     associated with the interface.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


DWORD
NbtGetWinsAddresses(
    IN  LPWSTR    DeviceName,
    OUT IPAddr *  PrimaryWinsServer,
    OUT IPAddr *  SecondaryWinsServer
    );

/*++

Routine Description:

    Returns the addresses of the WINS servers for which the specified device
    is configured.

Arguments:

    DeviceName - A unicode string identifying the target NBT interface.

    PrimaryWinsServer - A pointer to a variable into which to place the address
                        of the primary WINS server.

    SecondaryWinsServer - A pointer to a variable into which to place the address
                          of the primary WINS server.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/


#endif // ifndef _NTEAPI_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ipaddr\util.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Utility functions for IP Address resource.

Author:

    Mike Massa (mikemas) 29-Dec-1995

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock.h>

#define IP_ADDRESS_STRING_LENGTH  16


BOOLEAN
UnicodeInetAddr(
    PWCHAR  AddressString,
    PULONG  Address
    )
{
    UNICODE_STRING  uString;
    STRING          aString;
    UCHAR           addressBuffer[IP_ADDRESS_STRING_LENGTH];
    NTSTATUS        status;


    aString.Length = 0;
    aString.MaximumLength = IP_ADDRESS_STRING_LENGTH;
    aString.Buffer = addressBuffer;

    RtlInitUnicodeString(&uString, AddressString);

    status = RtlUnicodeStringToAnsiString(
                 &aString,
                 &uString,
                 FALSE
                 );

    if (!NT_SUCCESS(status)) {
        return(FALSE);
    }

    *Address = inet_addr(addressBuffer);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\lkquorum\lkquorum.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    LkQuorum.c

Abstract:

    Resource DLL for Local Quorum

Author:

	Sivaprasad Padisetty (sivapad) April 21, 1997

Revision History:

--*/

#define UNICODE 1
#include "clusres.h"
#include "clusrtl.h"
//
// Type and constant definitions.
//

#define MAX_RETRIES 20

#define DBG_PRINT printf

// ADDPARAM: Add new parameters here.
#define PARAM_NAME__PATH L"Path"
#define PARAM_NAME__DEBUG L"Debug"

// ADDPARAM: Add new parameters here.
typedef struct _LKQUORUM_PARAMS {
    PWSTR           Path;
    DWORD           Debug;
} LKQUORUM_PARAMS, *PLKQUORUM_PARAMS;

typedef struct _LKQUORUM_RESOURCE {
    RESID                   ResId; // for validation
    LKQUORUM_PARAMS         Params;
    HKEY                    ParametersKey;
    RESOURCE_HANDLE         ResourceHandle;
    CLUSTER_RESOURCE_STATE  State;
} LKQUORUM_RESOURCE, *PLKQUORUM_RESOURCE;


//
// Global data.
//

WCHAR   LkQuorumDefaultPath[MAX_PATH]=L"%SystemRoot%\\cluster";
//
// Local Quorum resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
LkQuorumResourcePrivateProperties[] = {
    { PARAM_NAME__PATH, NULL, CLUSPROP_FORMAT_SZ, 
      (DWORD_PTR) LkQuorumDefaultPath, 0, 0, 0, 
      FIELD_OFFSET(LKQUORUM_PARAMS,Path) },
    { PARAM_NAME__DEBUG, NULL, CLUSPROP_FORMAT_DWORD, 
      0, 0, 1, 0,
      FIELD_OFFSET(LKQUORUM_PARAMS,Debug) },           
    { 0 }
};


#ifdef OLD 
// Event Logging routine.

PLOG_EVENT_ROUTINE g_LogEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL;

#else

#define g_LogEvent ClusResLogEvent

#endif

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_LkQuorumFunctionTable;

//
// Function prototypes.
//

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    );

RESID
WINAPI
LkQuorumOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

VOID
WINAPI
LkQuorumClose(
    IN RESID ResourceId
    );

DWORD
WINAPI
LkQuorumOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    );


DWORD
WINAPI
LkQuorumOffline(
    IN RESID ResourceId
    );

VOID
WINAPI
LkQuorumTerminate(
    IN RESID ResourceId
    );

DWORD
LkQuorumDoTerminate(
    IN PLKQUORUM_RESOURCE ResourceEntry
    );

BOOL
WINAPI
LkQuorumLooksAlive(
    IN RESID ResourceId
    );

BOOL
WINAPI
LkQuorumIsAlive(
    IN RESID ResourceId
    );

BOOL
LkQuorumCheckIsAlive(
    IN PLKQUORUM_RESOURCE ResourceEntry
    );

DWORD
WINAPI
LkQuorumResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
LkQuorumGetPrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
LkQuorumValidatePrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PLKQUORUM_PARAMS Params
    );

DWORD
LkQuorumSetPrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );


DWORD
LkQuorumGetDiskInfo(
    IN LPWSTR  lpszPath,
    OUT PVOID *OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    ) ;


BOOLEAN
LkQuorumInit(
    VOID
    )
{
    return(TRUE);
}


BOOLEAN
WINAPI
LkQuorumDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        if ( !LkQuorumInit() ) {
            return(FALSE);
        }
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return(TRUE);

} // LkQuorumDllEntryPoint

DWORD BreakIntoDebugger (LPCWSTR) ;

#ifdef OLD

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    ResourceType - The type of resource requesting a function table.

    MinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    MaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    SetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    LogEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( !g_LogEvent ) {
        g_LogEvent = LogEvent;
        g_SetResourceStatus = SetResourceStatus;
    }

    *FunctionTable = &g_LkQuorumFunctionTable;

    return(ERROR_SUCCESS);

} // Startup

#endif


RESID
WINAPI
LkQuorumOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for Local Quourm resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    ResourceName - Supplies the name of the resource to open.

    ResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    ResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called. See the 
        description of the SetResourceStatus and LogEvent methods on the
        LkQuorumStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    DWORD               status = ERROR_SUCCESS;
    DWORD               disposition;
    RESID               resid = 0;
    HKEY                parametersKey = NULL;
    PLKQUORUM_RESOURCE  resourceEntry = NULL;
    DWORD               dwStrLen = 0;
    DWORD               dwSubStrLen = 0;
    LPWSTR              lpszNameofPropInError;
    
    //
    // Open the Parameters registry key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                   L"Parameters",
                                   KEY_READ,
                                   &parametersKey);

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open Parameters key. Error: %1!u!.\n",
            status );
        goto exit;
    }


    //
    // Allocate a resource entry.
    //

    resourceEntry = (PLKQUORUM_RESOURCE) LocalAlloc( LMEM_FIXED, sizeof(LKQUORUM_RESOURCE) );

    if ( resourceEntry == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Initialize the resource entry..
    //

    ZeroMemory( resourceEntry, sizeof(LKQUORUM_RESOURCE) );

    resourceEntry->ResId = (RESID)resourceEntry; // for validation
    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->State = ClusterResourceOffline;

    //
    // Read the resource's properties.
    //
    status = ResUtilGetPropertiesToParameterBlock( resourceEntry->ParametersKey,
                                                   LkQuorumResourcePrivateProperties,
                                                   (LPBYTE) &resourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &lpszNameofPropInError );
                                                   
    if (status != ERROR_SUCCESS)
    {
        (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to read the parameter lock\n");
        goto exit;
    }

    //
    // Startup for the resource.
    //
    resid = (RESID)resourceEntry;

exit:

    if ( resid == 0 ) {
        if ( parametersKey != NULL ) {
            ClusterRegCloseKey( parametersKey );
        }
        if ( resourceEntry != NULL ) {
            LocalFree( resourceEntry );
        }
    }

    SetLastError( status );
    return(resid);

} // LkQuorumOpen



VOID
WINAPI
LkQuorumClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for Local Quourm resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
    PLKQUORUM_RESOURCE resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "LkQuorum: Close request for a nonexistent resource id 0x%p\n",
                   ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );
#endif

    //
    // Close the Parameters key.
    //

    if ( resourceEntry->ParametersKey ) {
        ClusterRegCloseKey( resourceEntry->ParametersKey );
    }

    //
    // Deallocate the resource entry.
    //

    // ADDPARAM: Add new parameters here.
    LocalFree( resourceEntry->Params.Path );

    LocalFree( resourceEntry );
} // LkQuorumClose



DWORD
WINAPI
LkQuorumOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for Local Quourm resources.

    Bring the specified resource online (available for use). 

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    EventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    Win32 error code - The operation failed.

--*/

{
    PLKQUORUM_RESOURCE  resourceEntry = NULL;
    DWORD               status = ERROR_SUCCESS;
    LPWSTR              lpszNameofPropInError;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "LkQuorum: Online request for a nonexistent resource id 0x%p.\n",
                   ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    //
    // Read the resource's properties.
    //
    status = ResUtilGetPropertiesToParameterBlock( resourceEntry->ParametersKey,
                                                   LkQuorumResourcePrivateProperties,
                                                   (LPBYTE) &resourceEntry->Params,
                                                   TRUE, // CheckForRequiredProperties
                                                   &lpszNameofPropInError );
                                                   
    if (status != ERROR_SUCCESS)
    {
        (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to read the parameter lock\n");
        return( status );
    }
    
#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n" );
#endif

    resourceEntry->State = ClusterResourceOnline;

    return(status);

} // LkQuorumOnline



DWORD
WINAPI
LkQuorumOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for Local Quourm resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    PLKQUORUM_RESOURCE resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "LkQuorum: Offline request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n" );
#endif

    // TODO: Offline code

    // NOTE: Offline should try to shut the resource down gracefully, whereas
    // Terminate must shut the resource down immediately. If there are no
    // differences between a graceful shut down and an immediate shut down,
    // Terminate can be called for Offline, as it is below.  However, if there
    // are differences, replace the call to Terminate below with your graceful
    // shutdown code.

    //
    // Terminate the resource.
    //

    LkQuorumDoTerminate( resourceEntry );

    return ERROR_SUCCESS ;

} // LkQuorumOffline



VOID
WINAPI
LkQuorumTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for Local Quourm resources.

    Take the specified resource offline immediately (the resource is
    unavailable for use).

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
    PLKQUORUM_RESOURCE resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT( "LkQuorum: Terminate request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" );
#endif

    //
    // Terminate the resource.
    //
    LkQuorumDoTerminate( resourceEntry );

} // LkQuorumTerminate



DWORD
LkQuorumDoTerminate(
    IN PLKQUORUM_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Do the actual Terminate work for Local Quourm resources.

Arguments:

    ResourceEntry - Supplies resource entry for resource to be terminated

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    DWORD       status = ERROR_SUCCESS;

    ResourceEntry->State = ClusterResourceOffline;

    return(status);

} // LkQuorumDoTerminate



BOOL
WINAPI
LkQuorumLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for Local Quourm resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PLKQUORUM_RESOURCE  resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("LkQuorum: LooksAlive request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n" );
#endif

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    //
    // Check to see if the resource is alive.
    //
    return(LkQuorumCheckIsAlive( resourceEntry ));

} // LkQuorumLooksAlive



BOOL
WINAPI
LkQuorumIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for Local Quourm resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PLKQUORUM_RESOURCE  resourceEntry;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("LkQuorum: IsAlive request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" );
#endif

    //
    // Check to see if the resource is alive.
    //
    return(LkQuorumCheckIsAlive( resourceEntry ));

} // LkQuorumIsAlive



BOOL
LkQuorumCheckIsAlive(
    IN PLKQUORUM_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Check to see if the resource is alive for Local Quourm resources.

Arguments:

    ResourceEntry - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    return(TRUE);

} // LkQuorumCheckIsAlive



DWORD
WINAPI
LkQuorumResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for Local Quourm resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PLKQUORUM_RESOURCE  resourceEntry;
    DWORD               required;

    resourceEntry = (PLKQUORUM_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        DBG_PRINT("LkQuorum: ResourceControl request for a nonexistent resource id 0x%p\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( LkQuorumResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_LOCAL_QUORUM |
                    ((resourceEntry->Params.Debug == TRUE) ?
                    CLUS_CHAR_LOCAL_QUORUM_DEBUG : 0);
                status = ERROR_SUCCESS;                    
            }
            break;

        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_STORAGE;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
            //
            // Chittur Subbaraman (chitturs) - 12/23/98
            //
            // If the local quorum drive letter cannot be found in the
            // path parameter, it defaults to "SystemDrive" environment 
            // variable.
            //
            status = LkQuorumGetDiskInfo(resourceEntry->Params.Path,
                                  &OutBuffer,
                                  OutBufferSize,
                                  BytesReturned);


            // Add the endmark.
            if ( OutBufferSize > *BytesReturned ) {
                OutBufferSize -= *BytesReturned;
            } else {
                OutBufferSize = 0;
            }
            *BytesReturned += sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize >= sizeof(CLUSPROP_SYNTAX) ) {
                PCLUSPROP_SYNTAX ptrSyntax = (PCLUSPROP_SYNTAX) OutBuffer;
                ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            }
      
            break;

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( LkQuorumResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = LkQuorumGetPrivateResProperties( resourceEntry,
                                                      OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = LkQuorumValidatePrivateResProperties( resourceEntry,
                                                           InBuffer,
                                                           InBufferSize,
                                                           NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = LkQuorumSetPrivateResProperties( resourceEntry,
                                                      InBuffer,
                                                      InBufferSize );
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // LkQuorumResourceControl



DWORD
WINAPI
LkQuorumResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for Local Quourm resources.

    Perform the control request specified by ControlCode on this resource type.

Arguments:

    ResourceTypeName - Supplies the resource type name.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( LkQuorumResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( LkQuorumResourcePrivateProperties,
                                            OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_LOCAL_QUORUM ;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_STORAGE;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
                status = ERROR_SUCCESS;
            }
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // LkQuorumResourceTypeControl



DWORD
LkQuorumGetPrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type Local Quorum.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    //
    // Get all our properties.
    //
    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      LkQuorumResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // LkQuorumGetPrivateResProperties



DWORD
LkQuorumValidatePrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PLKQUORUM_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type Local Quourm.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    LKQUORUM_PARAMS     params;
    PLKQUORUM_PARAMS    pParams;
    HCLUSTER            hCluster = NULL;
    HCLUSENUM           hEnum = NULL;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) 
    {
        return(ERROR_INVALID_DATA);
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) 
    {
        pParams = &params;
    } else 
    {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(LKQUORUM_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &ResourceEntry->Params,
                                       LkQuorumResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) 
    {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( LkQuorumResourcePrivateProperties,
                                         NULL,
                                         TRUE,   // Accept unknowns
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) 
    {

        //initialize to the value already set
        DWORD   dwTmp = ResourceEntry->Params.Debug;
        //
        // Validate the parameter values.
        //
        // TODO: Code to validate interactions between parameters goes here.
        // see if the Debug value is being set, if so we need to check if
        // the number of nodes in the cluster allows it
        if (ClRtlFindDwordProperty(InBuffer, InBufferSize,PARAM_NAME__DEBUG, &dwTmp) == ERROR_SUCCESS)
        { 
            
            if (dwTmp == FALSE)
            {
                //dont allow the DEBUG parameter to be set to FALSE, if this 
                //cluster is multi-node
                DWORD   dwNumNodes;
                
                hCluster = OpenCluster(NULL);
                if (hCluster == NULL)
                {
                    status = GetLastError();
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"ValidatePrivateProperties: OpenCluster() failed! status = %1!u!.\n",
                        status );
                    goto FnExit;     
                }
                hEnum = ClusterOpenEnum(hCluster, CLUSTER_ENUM_NODE);

                if (hEnum == NULL)
                {
                    status = GetLastError();
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"ValidatePrivateProperties: ClusterOpenEnum() failed! status = %1!u!.\n",
                        status );
                    goto FnExit;
                }
                dwNumNodes = ClusterGetEnumCount(hEnum);

                if (dwNumNodes > 1)
                {
                    //if there are more than one node in the cluster, 
                    //dont allow the user to set the debug property to FALSE
                    status = ERROR_INVALID_PARAMETER;
                    goto FnExit;
                }

                status = ClusterCloseEnum(hEnum);
                if (status != ERROR_SUCCESS)
                {
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"ValidatePrivateProperties: ClusterCloseEnum() failed! status = %1!u!.\n",
                        status );
                    goto FnExit;
                }
                hEnum = NULL;
            }                
        }
    }

FnExit:
    if (hEnum) ClusterCloseEnum(hEnum);
    if (hCluster) CloseCluster(hCluster);

    //
    // Cleanup our parameter block.
    //
    if ( pParams == &params ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   LkQuorumResourcePrivateProperties );
    }

    return(status);

} // LkQuorumValidatePrivateResProperties



DWORD
LkQuorumSetPrivateResProperties(
    IN OUT PLKQUORUM_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type Local Quourm.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD            status = ERROR_SUCCESS;
    LKQUORUM_PARAMS  params;

    ZeroMemory( &params, sizeof(LKQUORUM_PARAMS) );

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    status = LkQuorumValidatePrivateResProperties( ResourceEntry,
                                                   InBuffer,
                                                   InBufferSize,
                                                   &params );

    if ( status != ERROR_SUCCESS ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   LkQuorumResourcePrivateProperties );
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               LkQuorumResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               LkQuorumResourcePrivateProperties );

    if ( status == ERROR_SUCCESS ) {
        if ( ResourceEntry->State == ClusterResourceOnline ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else if ( ResourceEntry->State == ClusterResourceOnlinePending ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // LkQuorumSetPrivateResProperties



DWORD WINAPI LkQuorumArbitrate(
    RESID ResourceId,
    PQUORUM_RESOURCE_LOST LostQuorumResource
    )

/*++

Routine Description:

    Perform full arbitration for a disk. Once arbitration has succeeded,
    a thread is started that will keep reservations on the disk, one per second.

Arguments:

    DiskResource - the disk info structure for the disk.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD status = ERROR_SUCCESS ;
    return status ;
}



DWORD
WINAPI
LkQuorumRelease(
    IN RESID Resource
    )

/*++

Routine Description:

    Release arbitration for a device by stopping the reservation thread.

Arguments:

    Resource - supplies resource id to be brought online

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_HOST_NODE_NOT_OWNER if the resource is not owned.
    A Win32 error code if other failure.

--*/

{
    DWORD status = ERROR_SUCCESS ;

    return status ;
}



DWORD
LkQuorumGetDiskInfo(
    IN LPWSTR   lpszPath,
    OUT PVOID * OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Gets all of the disk information for a given signature.

Arguments:

    Signature - the signature of the disk to return info.

    OutBuffer - pointer to the output buffer to return the data.

    OutBufferSize - size of the output buffer.

    BytesReturned - the actual number of bytes that were returned (or
                the number of bytes that should have been returned if
                OutBufferSize is too small).

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD   status;
    DWORD   bytesReturned = *BytesReturned;
    PVOID   ptrBuffer = *OutBuffer;
    PCLUSPROP_DWORD ptrDword;
    PCLUSPROP_PARTITION_INFO ptrPartitionInfo;

    DWORD   letterIndex;
    DWORD   letterCount = 1;
    WCHAR   driveLetters[1];
    LPWSTR  pszExpandedPath = NULL;
    WCHAR   chDrive;
    DWORD   dwLength;
    
    // Return the signature - a DWORD
    bytesReturned += sizeof(CLUSPROP_DWORD);
    if ( bytesReturned <= OutBufferSize ) {
        ptrDword = (PCLUSPROP_DWORD)ptrBuffer;
        ptrDword->Syntax.dw = CLUSPROP_SYNTAX_DISK_SIGNATURE;
        ptrDword->cbLength = sizeof(DWORD);
        ptrDword->dw = 777;//return a bogus signature for now
        ptrDword++;
        ptrBuffer = ptrDword;
    }

    status = ERROR_SUCCESS;

    pszExpandedPath = ClRtlExpandEnvironmentStrings(lpszPath);
    if (!pszExpandedPath)
    {
        status = GetLastError();
        goto FnExit;
    }
    //get a drive letter to fake the partition info
    //if the first char is drive letter, use that  
    if ((lstrlenW(pszExpandedPath) > 2) && (pszExpandedPath[1] == L':'))
    {
        driveLetters[0] = pszExpandedPath[0];
    }
    else
    {
        WCHAR   lpszTmpPath[MAX_PATH];
        DWORD   dwStrLen;
        
        //the path name could not have a drive letter
        //it can point to a share \\xyz\abc
        dwStrLen = GetWindowsDirectoryW( lpszTmpPath,
                                         MAX_PATH );
        if (!dwStrLen)
        {
            status = GetLastError();
            goto FnExit;
        }
        driveLetters[0] = lpszTmpPath[0];
        
    }        
    

    for ( letterIndex = 0 ; letterIndex < letterCount ; letterIndex++ ) {

        bytesReturned += sizeof(CLUSPROP_PARTITION_INFO);
        if ( bytesReturned <= OutBufferSize ) {
            ptrPartitionInfo = (PCLUSPROP_PARTITION_INFO) ptrBuffer;
            ZeroMemory( ptrPartitionInfo, sizeof(CLUSPROP_PARTITION_INFO) );
            ptrPartitionInfo->Syntax.dw = CLUSPROP_SYNTAX_PARTITION_INFO;
            ptrPartitionInfo->cbLength = sizeof(CLUSPROP_PARTITION_INFO) - sizeof(CLUSPROP_VALUE);
            if ( iswlower( driveLetters[letterIndex] ) ) {
                driveLetters[letterIndex] = towupper( driveLetters[letterIndex] );
            } else {
                ptrPartitionInfo->dwFlags = CLUSPROP_PIFLAG_STICKY;
            }
            ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_USABLE;
            ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_DEFAULT_QUORUM;

            wsprintfW( ptrPartitionInfo->szDeviceName,
                       L"%hc:\\",
                       driveLetters[letterIndex] );
            if ( !GetVolumeInformationW( ptrPartitionInfo->szDeviceName,
                                         ptrPartitionInfo->szVolumeLabel,
                                         sizeof(ptrPartitionInfo->szVolumeLabel)/sizeof(WCHAR),
                                         &ptrPartitionInfo->dwSerialNumber,
                                         &ptrPartitionInfo->rgdwMaximumComponentLength,
                                         &ptrPartitionInfo->dwFileSystemFlags,
                                         ptrPartitionInfo->szFileSystem,
                                         sizeof(ptrPartitionInfo->szFileSystem)/sizeof(WCHAR) ) ) {
                ptrPartitionInfo->szVolumeLabel[0] = L'\0';
            }

            //set the partition name to the path
            //in future, siva wants to be able to provide an smb name here
            lstrcpy(ptrPartitionInfo->szDeviceName, pszExpandedPath);
            dwLength = lstrlenW(ptrPartitionInfo->szDeviceName);
            //this should not be terminated in a '\'
            if (ptrPartitionInfo->szDeviceName[dwLength-1] == L'\\')
            {
                ptrPartitionInfo->szDeviceName[dwLength-1] = L'\0';
            }

            ptrPartitionInfo++;
            ptrBuffer = ptrPartitionInfo;
        }
    }

    //
    // Check if we got what we were looking for.
    //
    *OutBuffer = ptrBuffer;
    *BytesReturned = bytesReturned;

FnExit:
    if (pszExpandedPath) 
        LocalFree(pszExpandedPath);
    return(status);

} // LkQuorumGetDiskInfo





//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( LkQuorumFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         LkQuorum,                    // Prefix
                         LkQuorumArbitrate,           // Arbitrate
                         LkQuorumRelease,             // Release
                         LkQuorumResourceControl,     // ResControl
                         LkQuorumResourceTypeControl); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\msmq\localsvc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    localsvc.h

Abstract:

    Header file for definitions and structure for the NT Cluster
    Special generic services.

Author:

    John Vert (jvert) 23-May-1997

Revision History:

--*/

#ifndef _LOCALSVC_INCLUDED_
#define _LOCALSVC_INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif


#define SERVICE_NAME    L"MSMQ"

#define SYNC_VALUE_COUNT 2
#define REG_SYNC_VALUE1 L"Software\\Microsoft\\Cryptography\\MachineKeys\\MSMQ"
#define REG_SYNC_VALUE2 L"Software\\Microsoft\\MSMQ\\Parameters"

#define CRYPTO_VALUE_COUNT 1
#define CRYPTO_SYNC_VALUE1 L"1\\Microsoft Base Cryptographic Provider v1.0\\MSMQ"

#define DOMESTIC_CRYPTO_VALUE_COUNT 1
#define DOMESTIC_CRYPTO_SYNC_VALUE1 L"1\\Microsoft Enhanced Cryptographic Provider v1.0\\MSMQ_128"

#define ENVIRONMENT 1   // Need GetComputerName to lie.

#define COMMON_SEMAPHORE L"Cluster$MSMQSemaphore" // Limit of one resource of this type

#define LOG_CURRENT_MODULE LOG_MODULE_MSMQ

static DWORD   RegSyncCount = SYNC_VALUE_COUNT;
static LPWSTR  RegSync[SYNC_VALUE_COUNT] = {
    REG_SYNC_VALUE1,
    REG_SYNC_VALUE2 };

static DWORD   CryptoSyncCount = CRYPTO_VALUE_COUNT;
static LPWSTR  CryptoSync[CRYPTO_VALUE_COUNT] = {
    CRYPTO_SYNC_VALUE1 };

static DWORD   DomesticCryptoSyncCount = DOMESTIC_CRYPTO_VALUE_COUNT;
static LPWSTR  DomesticCryptoSync[DOMESTIC_CRYPTO_VALUE_COUNT] = {
    DOMESTIC_CRYPTO_SYNC_VALUE1 };

#define CommonReadParameters MsMQReadParameters

DWORD
MsMQReadParametersEx(
    IN OUT PVOID pvResourceEntry,
    IN BOOL bCheckForRequiredProperties
    );

_inline
DWORD
MsMQReadParameters(
    IN OUT PVOID pvResourceEntry
    )
{
    return MsMQReadParametersEx( pvResourceEntry, FALSE /* bCheckForRequiredProperties */ );
}


#define COMMON_CONTROL  1           // Need control functions

typedef struct _COMMON_DEPEND_DATA {
    CLUSPROP_RESOURCE_CLASS storageEntry;
    CLUSPROP_SZ_DECLARE( networkEntry, sizeof(CLUS_RESTYPE_NAME_NETNAME) / sizeof(WCHAR) );
    CLUSPROP_SZ_DECLARE( msdtcEntry, sizeof(CLUS_RESTYPE_NAME_MSDTC) / sizeof(WCHAR) );
    CLUSPROP_SYNTAX endmark;
} COMMON_DEPEND_DATA, *PCOMMON_DEPEND_DATA;


static COMMON_DEPEND_SETUP CommonDependSetup[] = {
    { FIELD_OFFSET(COMMON_DEPEND_DATA, storageEntry), CLUSPROP_SYNTAX_RESCLASS, sizeof(CLUSTER_RESOURCE_CLASS), (PVOID)(ULONGLONG)CLUS_RESCLASS_STORAGE },
    { FIELD_OFFSET(COMMON_DEPEND_DATA, networkEntry), CLUSPROP_SYNTAX_NAME, sizeof(CLUS_RESTYPE_NAME_NETNAME), CLUS_RESTYPE_NAME_NETNAME },
    { FIELD_OFFSET(COMMON_DEPEND_DATA, msdtcEntry), CLUSPROP_SYNTAX_NAME, sizeof(CLUS_RESTYPE_NAME_MSDTC), CLUS_RESTYPE_NAME_MSDTC },
    { 0, 0 }
};

#define COMMON_PARAMS_DEFINED 1     // Define private parameters
typedef struct _COMMON_PARAMS {
    DWORD   dwVersion;
} COMMON_PARAMS, * PCOMMON_PARAMS;

#ifdef _cplusplus
}
#endif


#endif // ifndef _LOCALSVC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\msmq\msmq.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    msmq.c

Abstract:

    Resource DLL to control and monitor the NT DHCPServer service.

Author:


    Robs 3/28/96, based on RodGa's generic resource dll

Revision History:

--*/

#include "..\common\svc.c"
#include "clusudef.h"
#include "ntverp.h"

extern CLRES_FUNCTION_TABLE MsMQFunctionTable;


#define MSMQ_VERSION        L"Version"

#define MSMQ_DEFAULT_VERSION 0x04000000

#define PARAM_NAME__VERSION         L"Version"


RESUTIL_PROPERTY_ITEM
MsMQResourcePrivateProperties[] = {
    { PARAM_NAME__VERSION, NULL, CLUSPROP_FORMAT_DWORD, MSMQ_DEFAULT_VERSION, 0, 0xFFFFFFFF, 0, FIELD_OFFSET(COMMON_PARAMS,dwVersion) },
    { 0 }
};



//
// Forward Functions
//
DWORD
WINAPI
MsMQResourceControl(
    IN RESID ResourceId,
    IN DWORD nControlCode,
    IN PVOID pvInBuffer,
    IN DWORD cbInBufferSize,
    OUT PVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD
MsMQGetPrivateResProperties(
    IN OUT PCOMMON_RESOURCE pResourceEntry,
    OUT PVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );


//
// Local Functions
//

VOID
MsMQResetCheckpoints(
    PCOMMON_RESOURCE ResourceEntry
    )

/*++

Routine Description

    Delete and then set registry checkpoints this will clean out old
    registry checkpoint settings.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD   returnSize;
    DWORD   idx;
    DWORD   status;

    //
    // Delete old registry checkpoints that were set.
    //
    if ( RegSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < RegSyncCount; idx++ ) {
            status = ClusterResourceControl( ResourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
                                             RegSync[idx],
                                             (lstrlenW( RegSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if ( status == ERROR_ALREADY_EXISTS ){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to delete registry checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set new registry checkpoints that we need.
    //
    if ( RegSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < RegSyncCount; idx++ ) {
            status = ClusterResourceControl( ResourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                                             RegSync[idx],
                                             (lstrlenW( RegSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if ( status == ERROR_ALREADY_EXISTS ){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to set registry checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set any crypto checkpoints that we need.
    //
    if ( CryptoSyncCount != 0 ) {
        returnSize = 0;
        //
        // Set registry sync keys if we need them.
        //
        for ( idx = 0; idx < CryptoSyncCount; idx++ ) {
            status = ClusterResourceControl( ResourceEntry->hResource,
                                             NULL,
                                             CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                             CryptoSync[idx],
                                             (lstrlenW( CryptoSync[idx] ) + 1) * sizeof(WCHAR),
                                             NULL,
                                             0,
                                             &returnSize );
            if ( status != ERROR_SUCCESS ){
                if (status == ERROR_ALREADY_EXISTS){
                    status = ERROR_SUCCESS;
                }
                else{
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"Failed to set crypto checkpoint, status %1!u!.\n",
                        status );
                    goto error_exit;
                }
            }
        }
    }

    //
    // Set any domestic crypto checkpoints that we need.
    //
    if ( DomesticCryptoSyncCount != 0 ) {
        HCRYPTPROV hProv = 0;
        //
        // check if domestic crypto is available
        //
        if (CryptAcquireContextA( &hProv,
                                  NULL,
                                  MS_ENHANCED_PROV_A,
                                  PROV_RSA_FULL,
                                  CRYPT_VERIFYCONTEXT)) {
            CryptReleaseContext( hProv, 0 );
            returnSize = 0;
            //
            // Set registry sync keys if we need them.
            //
            for ( idx = 0; idx < DomesticCryptoSyncCount; idx++ ) {
                status = ClusterResourceControl( ResourceEntry->hResource,
                                                 NULL,
                                                 CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                                 DomesticCryptoSync[idx],
                                                 (lstrlenW( DomesticCryptoSync[idx] ) + 1) * sizeof(WCHAR),
                                                 NULL,
                                                 0,
                                                 &returnSize );
                if ( status != ERROR_SUCCESS ){
                    if (status == ERROR_ALREADY_EXISTS){
                        status = ERROR_SUCCESS;
                    }
                    else{
                        (g_LogEvent)(
                            ResourceEntry->ResourceHandle,
                            LOG_ERROR,
                            L"Failed to set domestic crypto checkpoint, status %1!u!.\n",
                            status );
                        goto error_exit;
                    }
                }
            }
        }
    }

error_exit:

    return;

} // MsMQResetCheckpoints


DWORD
MsMQReadParametersEx(
    IN OUT PVOID pvResourceEntry,
    IN BOOL bCheckForRequiredProperties
    )

/*++

Routine Description:

    Reads all the parameters for a specied MsMQ resource.

Arguments:

    pResourceEntry - Entry in the resource table.

    bCheckForRequiredProperties - TRUE = make sure required properties are
        present.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code if failure occurrs.

--*/

{
    DWORD               status;
    COMMON_PARAMS       params = { 0 };
    LPWSTR              pszNameOfPropInError;
    PCOMMON_RESOURCE    pResourceEntry = (PCOMMON_RESOURCE) pvResourceEntry;

    //
    // Read our parameters.
    //
    status = ResUtilGetPropertiesToParameterBlock(
                    pResourceEntry->ParametersKey,
                    MsMQResourcePrivateProperties,
                    (LPBYTE) &pResourceEntry->Params,
                    bCheckForRequiredProperties,
                    &pszNameOfPropInError
                    );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1' property. Error: %2!u!.\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            status
            );
    }

    return(status);

} // MsMQReadParametersEx



VOID
MsMQPerformFixup(
    IN OUT PCOMMON_RESOURCE pResourceEntry
    )
{
    DWORD   status;
    DWORD   version;
    DWORD   bytesReturned;
    DWORD   bytesRequired;
    PVOID   propBuffer;
    COMMON_PARAMS params;

    status = MsMQReadParametersEx(
                        pResourceEntry,
                        FALSE );
    if ( status != ERROR_SUCCESS ) {
        return;
    }

    version = pResourceEntry->Params.dwVersion;
    version = version >> 16;

    if ( version < 0x0500 ) {
        //
        // Delete Old Checkpoints and set new ones
        //
        MsMQResetCheckpoints( pResourceEntry );

        params.dwVersion = VER_PRODUCTVERSION_DW;

        //
        // Get version number as a property list
        //
        status = ResUtilGetProperties(
                        pResourceEntry->ParametersKey,
                        MsMQResourcePrivateProperties,
                        NULL,
                        0,
                        &bytesReturned,
                        &bytesRequired
                        );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to get properties. Error: %1!u!.\n",
                status
                );
            return;
        }

        propBuffer = LocalAlloc( LMEM_FIXED, bytesRequired + 2 );
        if ( !propBuffer ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to allocate property buffer.\n"
                );
            return;
        }

        status = ResUtilGetProperties(
                        pResourceEntry->ParametersKey,
                        MsMQResourcePrivateProperties,
                        propBuffer,
                        bytesRequired+2,
                        &bytesReturned,
                        &bytesRequired
                        );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to get properties. Error: %1!u!.\n",
                status
                );
            LocalFree( propBuffer );
            return;
        }

        //
        // Set Version Number
        //
        status = ResUtilSetPropertyParameterBlock(
                        pResourceEntry->ParametersKey,
                        MsMQResourcePrivateProperties,
                        NULL,
                        (LPBYTE) &params,
                        propBuffer,
                        bytesReturned,
                        (LPBYTE) &pResourceEntry->Params
                        );
        LocalFree( propBuffer );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Unable to set the property parameter block. Error: %1!u!.\n",
                status
                );
            return;
        }
    }

} //MsMQPerformFixup


DWORD
WINAPI
MsMQResourceControl(
    IN RESID ResourceId,
    IN DWORD nControlCode,
    IN PVOID pvInBuffer,
    IN DWORD cbInBufferSize,
    OUT PVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for MsMQ Service resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    nControlCode - Supplies the control code that defines the action
        to be performed.

    pvInBuffer - Supplies a pointer to a buffer containing input data.

    cbInBufferSize - Supplies the size, in bytes, of the data pointed
        to by pvInBuffer.

    pvOutBuffer - Supplies a pointer to the output buffer to be filled in.

    cbOutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by pvOutBuffer.

    pcbBytesReturned - Returns the number of bytes of pvOutBuffer actually
        filled in by the resource. If pvOutBuffer is too small, pcbBytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    DWORD               cbRequired;
    PCOMMON_RESOURCE    pResourceEntry = (PCOMMON_RESOURCE) ResourceId;

    switch ( nControlCode ) {

        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_UNKNOWN:
            *pcbBytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = MsMQGetPrivateResProperties(
                                pResourceEntry,
                                pvOutBuffer,
                                cbOutBufferSize,
                                pcbBytesReturned );
            break;

        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
            MsMQPerformFixup( pResourceEntry );
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = ERROR_INVALID_PARAMETER;
            break;

        default:
            status = CommonResourceControl(
                            ResourceId,
                            nControlCode,
                            pvInBuffer,
                            cbInBufferSize,
                            pvOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;
    }

    return(status);

} // MsMQResourceControl



DWORD
MsMQGetPrivateResProperties(
    IN OUT PCOMMON_RESOURCE pResourceEntry,
    OUT PVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type MsMQ Service.

Arguments:

    pResourceEntry - Supplies the resource entry on which to operate.

    pvOutBuffer - Returns the output data.

    cbOutBufferSize - Supplies the size, in bytes, of the data pointed
        to by pvOutBuffer.

    pcbBytesReturned - The number of bytes returned in pvOutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           cbRequired;
    DWORD           cbLocalOutBufferSize = cbOutBufferSize;

    do {
        //
        // Read our parameters.
        //
        status = MsMQReadParametersEx( pResourceEntry, FALSE /* bCheckForRequiredProperties */ );
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Construct a property list from the parameter block.
        //
        status = ResUtilPropertyListFromParameterBlock(
                        MsMQResourcePrivateProperties,
                        pvOutBuffer,
                        &cbLocalOutBufferSize,
                        (const LPBYTE) &pResourceEntry->Params,
                        pcbBytesReturned,
                        &cbRequired
                        );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Error constructing property list from parameter block. Error: %1!u!.\n",
                status
                );
            break;
        }

        //
        // Add unknown properties.
        //
        status = ResUtilAddUnknownProperties(
                        pResourceEntry->ParametersKey,
                        MsMQResourcePrivateProperties,
                        pvOutBuffer,
                        cbOutBufferSize,
                        pcbBytesReturned,
                        &cbRequired
                        );
        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                pResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Error adding unknown properties to the property list. Error: %1!u!.\n",
                status
                );
            break;
        }

    } while ( 0 );

    if ( status == ERROR_MORE_DATA ) {
        *pcbBytesReturned = cbRequired;
    }

    return(status);

} // MsMQGetPrivateResProperties



BOOLEAN
WINAPI
MsMQDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
{
    switch ( Reason ) {

        case DLL_PROCESS_ATTACH:
            CommonSemaphore = CreateSemaphoreW( NULL,
                                        0,
                                        1,
                                        COMMON_SEMAPHORE );
            if ( CommonSemaphore == NULL ) {
                return(FALSE);
            }
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                //if the semaphore didnt exist, set its initial count to 1
                ReleaseSemaphore(CommonSemaphore, 1, NULL);
            }

            break;

        case DLL_PROCESS_DETACH:
            if ( CommonSemaphore ) {
                CloseHandle( CommonSemaphore );
            }
            break;

        default:
            break;
    }

    return(TRUE);

} // MsMQDllEntryPoint



//***********************************************************
//
// Define MsMQ Function Table
//
//***********************************************************


CLRES_V1_FUNCTION_TABLE( MsMQFunctionTable,    // Name
                         CLRES_VERSION_V1_00,  // Version
                         Common,               // Prefix
                         NULL,                 // Arbitrate
                         NULL,                 // Release
                         MsMQResourceControl,  // ResControl
                         CommonResourceTypeControl ); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\crs.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    crs.c

Abstract:

    Implements Consistency Replica Set Algorithm

Author:

    Ahmed Mohamed (ahmedm) 1-Jan-2001

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <assert.h>

#define QFS_DBG
#include "crs.h"

#include "fsutil.h"

#define xmalloc(size)  VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE)

#define xfree(buffer) VirtualFree(buffer, 0, MEM_RELEASE) 

#define CrspEqual(r1,r2)        ((r1)->hdr.seq == (r2)->hdr.seq && \
                                 (r1)->hdr.epoch == (r2)->hdr.epoch && \
                                 (r1)->hdr.state == (r2)->hdr.state)

DWORD CrsForcedQuorumSize = 0xffff;

void
WINAPI
CrsSetForcedQuorumSize(DWORD size)
{
    CrsForcedQuorumSize = size;
}

VOID
CrsForceClose(CrsInfo_t *p)
/*
    This should be called only on emergency terminations. This would unlock the crs.log
    file and close the handle. This does not hold any lock.
*/
{
    if (p == NULL) {
        CrsLog(("CrsForceClose: Exiting...\n"));
        return;
    }

    CrsLog(("CrsForceClose: fh 0x%x, nid %d\n", p->fh, p->lid));
    
    if (p->fh != INVALID_HANDLE_VALUE) {
        if(!UnlockFile(p->fh, 0, 0, (DWORD)-1, (DWORD)-1)) {
            CrsLog(("CrsForceClose: UnlockFile(0x%x) returns %d\n", p->fh, GetLastError()));
        }
        if(!CloseHandle(p->fh)) {
            CrsLog(("CrsForceClose: CloseHandle(0x%x) returns %d\n", p->fh, GetLastError()));
        }
        p->fh = INVALID_HANDLE_VALUE;
    }
}

DWORD
CrspFindLast(CrsInfo_t *p, DWORD logsz)
{
    
    CrsRecord_t *rec, *last_rec;
    BOOL err;
    DWORD n, i;

    if (p->fh == INVALID_HANDLE_VALUE) {
        CrsLog(("CrspFindLast: Invalid file handle. Exiting...\n"));
        return ERROR_INVALID_HANDLE;
    }
    
    n = SetFilePointer(p->fh, 0, NULL, FILE_BEGIN);
    if (n == INVALID_SET_FILE_POINTER) {
        return GetLastError();
    }

    err = ReadFile(p->fh, p->buf, logsz, &n, NULL);
    if (!err)
        return GetLastError();

    if (n != logsz) {
        CrsLog(("Crs%d: failed to load complete file, read %d expected %d\n",
                p->lid,
                n, logsz));
        return ERROR_BAD_LENGTH;
    }
    
    // Not needed.
    // ASSERT(p->max_records * CRS_RECORD_SZ == (int)n);
    // if(p->max_records * CRS_RECORD_SZ != (int)n) {
    //    CrsLog(("Crs%d: unable to load log file %d bytes, got %d bytes\n",
    //           p->lid, n, logsz));
    //    return ERROR_BAD_LENGTH;
    // }

    CrsLog(("Crs%d: loaded %d bytes, %d records\n", p->lid,
           n, p->max_records));

    last_rec = NULL;
    rec = p->buf;
    for (i = 0; i < logsz; i += CRS_RECORD_SZ, rec++) {
        if (rec->hdr.tag != CRS_TAG) {
            CrsLog(("crs%d: Bad record %d, got %x expected %x\n",
                    p->lid,
                    i/CRS_RECORD_SZ, rec->hdr.tag, CRS_TAG));
            return ERROR_BAD_FORMAT;
        }

        if (!last_rec ||
            rec->hdr.epoch > last_rec->hdr.epoch ||
            (rec->hdr.epoch == last_rec->hdr.epoch &&
             (rec->hdr.seq > last_rec->hdr.seq))) {
            last_rec = rec;
        }
    }
    ASSERT(last_rec);

    // make sure only the last record is not committed or aborted
    rec = p->buf;
    for (i = 0; i < logsz; i += CRS_RECORD_SZ, rec++) {
        if (!(rec->hdr.state & (CRS_COMMIT | CRS_ABORT))) {
            if (rec != last_rec) {
                CrsLog(("crs:%d Bad record %d state %x expected commit|abort\n",
                        p->lid, i/CRS_RECORD_SZ, rec->hdr.state));
                return ERROR_INTERNAL_ERROR;
            }
        }
    }

    p->last_record = (int) (last_rec - p->buf);
    p->seq = last_rec->hdr.seq;
    p->epoch = last_rec->hdr.epoch;

    return ERROR_SUCCESS;

}

#define CrspFlush(p,offset)     CrspWrite(p,offset, CRS_SECTOR_SZ)

static
DWORD
CrspWrite(CrsInfo_t *p, int offset, DWORD length)
{
    DWORD       n;

    if (p->fh == INVALID_HANDLE_VALUE) {
        CrsLog(("CrspWrite: Invalid file handle. Exiting...\n"));
        return ERROR_INVALID_HANDLE;
    }

    p->pending = FALSE;

    n = (DWORD) offset;
    // write out last sector, assumes lock is held
    ASSERT(offset < p->max_records);
    offset = offset / CRS_RECORDS_PER_SECTOR;

    CrsLog(("Crs%d: flush %d bytes record %d -> %d,%d\n", p->lid,
            length, n,
            offset, offset*CRS_SECTOR_SZ));

    n = SetFilePointer(p->fh, offset * CRS_SECTOR_SZ, NULL, FILE_BEGIN);
    if (n == INVALID_SET_FILE_POINTER) {
        return GetLastError();
    }

    n = 0;
    if (WriteFile(p->fh, (PVOID) &p->buf[offset*CRS_RECORDS_PER_SECTOR], length, &n, NULL)) {
        if (n != length) {
            CrsLog(("Write count mismatch, wrote %d, expected %d\n", n, length));
            return ERROR_BAD_LENGTH;
        }
        return ERROR_SUCCESS;
    }

    n = GetLastError();
    CrsLog(("Crs%d: flush record %d failed err %d\n", p->lid, offset, n));
    if (n == ERROR_UNEXP_NET_ERR) {
        // repeat the write one more time
        p->pending = TRUE;
    }

    return n;
}

static
DWORD
CrspAppendRecord(CrsInfo_t *p, CrsRecord_t *rr, CrsRecord_t **rec)
{
    CrsRecord_t *q;
    DWORD err;

    // tag record 
    rr->hdr.tag = CRS_TAG;

    // assumes lock is held
    if ((p->last_record & CRS_SECTOR_MASK) == CRS_SECTOR_MASK) {
        // flush current sector
        err = CrspFlush(p, p->last_record);
        if (err != ERROR_SUCCESS)
            return err;

    }

        // advance last record
    p->last_record++;
    if (p->last_record == p->max_records)
        p->last_record = 0;

    CrsLog(("Crs%d: append record %d epoch %I64d seq %I64d state %x\n",
            p->lid, p->last_record,
            rr->hdr.epoch, rr->hdr.seq, rr->hdr.state));

    // copy record
    q = &p->buf[p->last_record];
    memcpy((PVOID)q, (PVOID) rr, CRS_RECORD_SZ);

    // flush it out now
    err = CrspFlush(p, p->last_record);
    if (err == ERROR_SUCCESS) {
        if (rec) *rec = q;
    } else {
        if (p->last_record == 0)
            p->last_record = p->max_records;
        p->last_record--;
    }

    return err;
}

// NextRecord:
//      if seq is null, fill in last record and return SUCCESS
//      if seq is not found, return NOT_FOUND
//      if seq is last record, return EOF
//      otherwise return next record after seq in lrec and SUCCESS
DWORD
CrspNextLogRecord(CrsInfo_t *info, CrsRecord_t *seq,
                  CrsRecord_t *lrec, BOOLEAN this_flag)
{
    CrsRecord_t *last, *p;
    DWORD err = ERROR_SUCCESS;

    if (lrec == NULL || info == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    // read record
    EnterCriticalSection(&info->lock);
    last = &info->buf[info->last_record];
    if (seq == NULL) {
        CrsLog(("Crs%d: last record %d %I64d %I64d\n",
                info->lid, info->last_record, last->hdr.epoch, last->hdr.seq));

        // read last record
        memcpy(lrec, last, CRS_RECORD_SZ);

    } else if (seq->hdr.epoch != last->hdr.epoch ||
               seq->hdr.seq != last->hdr.seq) {
        int i;

        CrsLog(("Crs%d: last record %d %I64d %I64d search %I64d %I64d\n",
                info->lid, info->last_record,
                last->hdr.epoch, last->hdr.seq,
                seq->hdr.epoch, seq->hdr.seq));

        // assume we don't have it
        p = seq;
        seq = NULL;
        // do a search instead of index, so that
        // seq can be reset as epoch increments
        for (i = 0; i < info->max_records; i++) {
            last = &info->buf[i];
            if (p->hdr.epoch == last->hdr.epoch &&
                p->hdr.seq == last->hdr.seq) {

                seq = last;
                break;
            }
        }
        if (seq != NULL) {
            if (this_flag == FALSE) {
                // return record after this one
                i++;
                if (i >= info->max_records)
                    i = 0;
                seq = &info->buf[i];
            }
            CrsLog(("Crs%d: search found %d %I64d, %I64d\n", info->lid,
                   seq - info->buf, seq->hdr.epoch, seq->hdr.seq));
            memcpy(lrec, seq, CRS_RECORD_SZ);
        } else {
            err = ERROR_NOT_FOUND;
        }
    } else {
        
        CrsLog(("Crs%d: reached last record %d %I64d %I64d, %I64d %I64d\n",
                info->lid, info->last_record,
                last->hdr.epoch, last->hdr.seq,
                seq->hdr.epoch, seq->hdr.seq));

        if (this_flag == TRUE) {
            // we are trying to read the last record
            memcpy(lrec, last, CRS_RECORD_SZ);
            err = ERROR_SUCCESS;
        } else {
            err = ERROR_HANDLE_EOF;
        }
    }

    LeaveCriticalSection(&info->lock);

    if (err == ERROR_SUCCESS && lrec->hdr.epoch == 0) {
        // invalid rec, log is empty
        err = ERROR_HANDLE_EOF;
    }


    return err;
}

// Call into fs with <undo, replay, query, disable, enable, done>
//      undo: pass replica in recovery due to a conflict
//      replay: replica is missing change, if replay fails with abort, we
//              do a full copy; otherwise we issue a skip record
//      query: ask replica if record was completed or not
//      done: signal end of recovery and pass in new wset, rset
// we silently handle <abort(skip) and epoch records>
//      abort: add a skip record
//      epoch records: just log it as is
DWORD
CrspReplay(LPVOID rec)
{
    CrsRecoveryBlk_t *rr;
    CrsInfo_t *info, *minfo;
    CrsRecord_t *p, *q;
    CrsRecord_t lrec, mlrec;
    DWORD err;

    rr = (CrsRecoveryBlk_t *) rec;
    info = rr->info;
    minfo = rr->minfo;

    CrsLog(("CrsReplay%d mid %d, lid %d leader_id %d\n",
            rr->nid, rr->mid, info->lid, info->leader_id));

    // for now force a full copy. It seems sometimes I get into a bad state, when we
    // get the time, we can reenable this and find out exactly the corner cases that
    // cause us to be out of sync.
#if 1
    do {
        p = NULL;
        // read last record
        err = CrspNextLogRecord(info, NULL, &lrec, FALSE);
        if (err != ERROR_SUCCESS) {
            CrsLog(("CrsReplay%d: unable to read last record %d\n",
                    info->lid, err));
            break;
        }

        // find our last record in master replica
        q = &lrec;
        p = &mlrec;
        err = CrspNextLogRecord(minfo, q, p, TRUE);
        // if found and consistent with master, no undo
        if (err == ERROR_SUCCESS && p->hdr.state == q->hdr.state) {
            CrsLog(("CrsReplay%d: last record %I64d, %I64d consistent %x %x\n",
                    info->lid, q->hdr.epoch, q->hdr.seq,
                    p->hdr.state, q->hdr.state));
            break;
        }

        if (err != ERROR_SUCCESS) {
            CrsLog(("CrsReplay%d: missing lrec %I64d, %I64d in disk %d, err %d\n",
                    info->lid, q->hdr.epoch, q->hdr.seq, minfo->lid, err));
        } else {
            CrsLog(("CrsReplay%d: undo last record %I64d, %I64d %x needs %x\n",
                    info->lid, q->hdr.epoch, q->hdr.seq,
                    q->hdr.state, p->hdr.state));
            ASSERT(p->hdr.state & (CRS_COMMIT|CRS_ABORT));
        }

        // last record is in conflict, we must undo it first
        if (!(q->hdr.state & CRS_EPOCH)) {
            // if we found this record in master and a conflict is detected,
            // we undo it. Otherwise, we need to do a full copy
            if (err == ERROR_SUCCESS) {
                ASSERT(p->hdr.state & (CRS_COMMIT|CRS_ABORT));
                ASSERT(q->hdr.state & CRS_PREPARE);
                err = info->callback(info->callback_arg,
                                     rr->nid, q,
                                     CRS_ACTION_UNDO, rr->mid);
            }
        } else {
            // A missing epoch record doesn't mean we are old. A regroup
            // could have happened but no new data records got added. We
            // undo it, and continue;
            err = STATUS_SUCCESS;
        }

        if (err == STATUS_SUCCESS) {
            // update current record, sequence, epoch
            info->buf[info->last_record].hdr.state = 0;
            info->buf[info->last_record].hdr.epoch = 0;
            info->buf[info->last_record].hdr.seq = 0;
            if (info->last_record == 0) {
                info->last_record = info->max_records;
            }
            info->last_record--;
            info->seq = info->buf[info->last_record].hdr.seq;
            info->epoch = info->buf[info->last_record].hdr.epoch;
            CrsLog(("CrsReplay%d: new last record %d %I64d, %I64d\n",
                    info->lid, info->last_record, info->epoch, info->seq));
        } else {
            // can't undo it, do full copy and readjust our log
            CrsLog(("CrsReplay%d: Unable to undo record %I64d, %I64d\n",
                    info->lid, q->hdr.epoch, q->hdr.seq));
            p = NULL;
        }
    } while (err == STATUS_SUCCESS && info->state == CRS_STATE_RECOVERY);

                   
    while (p != NULL && info->state == CRS_STATE_RECOVERY) {
        // read master copy
        err = CrspNextLogRecord(minfo, p, &mlrec, FALSE);
        if (err != ERROR_SUCCESS) {
            if (err == ERROR_HANDLE_EOF) {
                CrsLog(("CrsReplay%d: last record %I64d, %I64d in disk %d\n",
                        info->lid, q->hdr.epoch, q->hdr.seq, minfo->lid));

                // the last record is where we are at
                info->seq = info->buf[info->last_record].hdr.seq;
                info->epoch = info->buf[info->last_record].hdr.epoch;

                // This would be performed later in CrsStart().
#if 0
                // we reached the end, signal end of recovery
                err = info->callback(info->callback_arg,
                               rr->nid, p,
                               CRS_ACTION_DONE, rr->mid);

#else
                err = STATUS_SUCCESS;
#endif

                goto exit;
            }
            break;
        }

        p = &mlrec;
        if ((p->hdr.state & CRS_EPOCH) || (p->hdr.state & CRS_ABORT)) {
            CrsLog(("CrsReplay%d: skip record %I64d, %I64d %x\n",
                    info->lid, p->hdr.epoch, p->hdr.seq, p->hdr.state));
            err = !STATUS_SUCCESS;
        } else if (p->hdr.state & CRS_COMMIT) {
            err = info->callback(info->callback_arg,
                                 rr->nid, p,
                                 CRS_ACTION_REPLAY, rr->mid);
            if (err == STATUS_TRANSACTION_ABORTED) {
                CrsLog(("CrsReplay: failed nid %d seq %I64d err %x\n",
                        rr->nid, p->hdr.seq, err));
                break;
            }
        } else {
            ASSERT(p->hdr.state & CRS_PREPARE);
            // what if the record is prepared but not yet committed or
            // aborted; in transit record. 
            // stop now
            CrsLog(("CrsReplay%d: bad record seq %I64d state %x\n",
                    rr->nid, p->hdr.seq, p->hdr.state));
            break;
        }
        if (err != STATUS_SUCCESS) {
            // add record
            err = CrspAppendRecord(info, p, NULL);
            if (err != ERROR_SUCCESS) {
                CrsLog(("CrsReplay%d: failed append seq %I64d err %x\n",
                        rr->nid, p->hdr.seq, err));
                break;
            }
            if (p->hdr.state & CRS_EPOCH) {
                ; //ASSERT(info->epoch+1 == p->hdr.epoch);
            } else {
                ASSERT(info->epoch == p->hdr.epoch);
                ASSERT(info->seq+1 == p->hdr.seq);
            }
            info->seq = p->hdr.seq;
            info->epoch = p->hdr.epoch;
        } else if (info->seq == p->hdr.seq) {
            // make sure we have added it
            ASSERT(info->seq == p->hdr.seq);
            ASSERT(info->epoch == p->hdr.epoch);
            ASSERT(info->buf[info->last_record].hdr.seq == p->hdr.seq);
            ASSERT(info->buf[info->last_record].hdr.epoch == p->hdr.epoch);

            // Propagate dubious bit
            if (p->hdr.state & CRS_DUBIOUS) {
                info->buf[info->last_record].hdr.state |= CRS_DUBIOUS;
            }
            ASSERT(info->buf[info->last_record].hdr.state == p->hdr.state);
        } else {
            // force a full copy
            err = !STATUS_SUCCESS;
            break;
        }
    }
#else
    p = NULL;
#endif
    if (p == NULL || err != STATUS_SUCCESS) {
        CrsLog(("CrsReplay%d: Full copy from disk %d\n",
                info->lid, minfo->lid));
        // we are out of date or need full recovery, do a full copy
        err = info->callback(info->callback_arg,
                             rr->nid, NULL,
                             CRS_ACTION_COPY, rr->mid);

        if (err == STATUS_SUCCESS) {
            DWORD len;

            // we now copy our master log and flush it
            ASSERT(minfo->max_records == info->max_records);

            len = info->max_records * CRS_RECORD_SZ;
            memcpy(info->buf, minfo->buf, len);
            err = CrspWrite(info, 0, len);
            if (err == ERROR_SUCCESS) {
                // adjust our state
                info->last_record = minfo->last_record;
                info->seq = info->buf[info->last_record].hdr.seq;
                info->epoch = info->buf[info->last_record].hdr.epoch;

                // The action below would be performed later in CrsStart().
#if 0
                // we reached the end, signal end of recovery
                err = info->callback(info->callback_arg,
                               rr->nid, p,
                               CRS_ACTION_DONE, rr->mid);
#endif

            }
        }
    }

 exit:

    CrsLog(("CrsReplay%d mid %d status 0x%x\n", rr->nid, rr->mid, err));

    return err;
}


/////////////////////// Public Functions //////////////////////
DWORD
WINAPI
CrsOpen(crs_callback_t callback, PVOID callback_arg, USHORT lid,
        WCHAR *log_name, int max_logsectors, HANDLE *outhdl)
{

    // Open the log file
    // If the file in newly create, set the proper size
    // If the file size is not the same size, we need to either
    // expand or truncate the file. (truncate needs copy)
    // Scan file to locate last sector and record
    // If last record hasn't been commited, issue a query.
    // If query succeeded then, mark it as committed.
    // Set epoch,seq
    DWORD status;
    HANDLE maph;
    CrsInfo_t   *p;
    int logsz;
    ULONG disp=FILE_OPEN_IF;

    if (outhdl == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *outhdl = NULL;

    p = (CrsInfo_t *) malloc(sizeof(*p));
    if (p == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memset((PVOID) p, 0, sizeof(*p));

    // CrsLog(("Crs%d file '%S'\n", lid, log_name));
    p->lid = lid;
    p->callback = callback;
    p->callback_arg = callback_arg;
    p->pending = FALSE;

#if 0
    // Create log file, and set size of newly created
    p->fh = CreateFileW(log_name,
                     GENERIC_READ | GENERIC_WRITE,
                     FILE_SHARE_READ|FILE_SHARE_WRITE,
                     NULL,
                     OPEN_ALWAYS,
                     FILE_FLAG_WRITE_THROUGH,
                     NULL);
#else
    p->fh = INVALID_HANDLE_VALUE;
    status = xFsCreate(&p->fh, 
                    NULL, 
                    log_name, 
                    wcslen(log_name), 
                    FILE_WRITE_THROUGH|FILE_SYNCHRONOUS_IO_ALERT,
                    0,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    &disp,
                    GENERIC_READ | GENERIC_WRITE | FILE_WRITE_EA,
                    NULL,
                    0
                    );

    if ((status == STATUS_SUCCESS)&&(disp == FILE_OPENED)) {
        status = ERROR_ALREADY_EXISTS;
    }

#endif

    // status = GetLastError();
    if(p->fh == INVALID_HANDLE_VALUE){
        free((char *) p);
        return status;
    }

    // acquire an exclusive lock on the whole file
    if (!LockFile(p->fh, 0, 0, (DWORD)-1, (DWORD)-1)) {
        FILE_FULL_EA_INFORMATION ea[2] = {0};
        IO_STATUS_BLOCK ios;
        NTSTATUS err;

        // get status
        status = GetLastError();

        // change the ea to cause a notification to happen
        ea[0].NextEntryOffset = 0;
        ea[0].Flags = 0;
        ea[0].EaNameLength = 1;
        ea[0].EaValueLength = 1;
        ea[0].EaName[0] = 'X';
        // Increment size by 1, due to value.
        err = NtSetEaFile(p->fh, &ios, (PVOID) ea, sizeof(ea));
        CrsLog(("Crs%d Setting EA err=0x%x status=0x%x\n", lid, err, status));

        goto error;
    }

    if (status == ERROR_ALREADY_EXISTS) {
        // todo: compare current file size to new size and adjust file
        // size accordingly. For now, just use old size
        logsz = GetFileSize(p->fh, NULL);
        CrsLog(("Crs%d: (Open) Filesz %d max_sec %d\n", lid, logsz, max_logsectors));
        ASSERT(logsz == max_logsectors * CRS_SECTOR_SZ);
    } else {
        //extend the file pointer to max size 
        logsz = max_logsectors * CRS_SECTOR_SZ;
        SetFilePointer(p->fh, logsz, NULL, FILE_BEGIN);
        SetEndOfFile(p->fh);
        CrsLog(("Crs%d: (Create) Set Filesz %d max_sec %d\n", lid, logsz, max_logsectors));
    }

    // allocate file copy in memory
    p->buf = xmalloc(logsz);
    if (p->buf == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    
    // set max record
    p->max_records = logsz / CRS_RECORD_SZ;

    if (status == ERROR_ALREADY_EXISTS) {
        // load file and compute last epoch/seq
        status = CrspFindLast(p, logsz);
    } else {
        status = !ERROR_SUCCESS;
    }
    // init the file, when we detect a read failure or first time
    if (status != ERROR_SUCCESS) {
        CrsRecord_t *r;
        int i;

        // initialize file
        p->seq = 0;
        p->epoch = 0;
        p->last_record = 0;

        r = p->buf;
        for (i = 0; i < logsz; i+= CRS_RECORD_SZ, r++) {
            r->hdr.epoch = p->epoch;
            r->hdr.seq = p->seq;
            r->hdr.tag = CRS_TAG;
            r->hdr.state = CRS_COMMIT | CRS_PREPARE | CRS_EPOCH;
        }
        status = CrspWrite(p, 0, logsz);
    }

    if (status != ERROR_SUCCESS) {
        goto error;
    }

    CrsLog(("Crs%d: %x Last record %d max %d epoch %I64d seq %I64d\n", p->lid,
            p->fh,
            p->last_record, p->max_records, p->epoch, p->seq));

    // initialize rest of state
    p->state = CRS_STATE_INIT;
    p->refcnt = 1;
    p->leader_id = 0;
    InitializeCriticalSection(&p->lock);

    *outhdl = p;

    return ERROR_SUCCESS;

 error:
    CloseHandle(p->fh);
    if (p->buf) {
        xfree(p->buf);
    }
    free((PVOID) p);
    return status;
}

//
DWORD
WINAPI
CrsStart(PVOID *hdls, ULONG alive_set, int cluster_sz,
         ULONG *write_set, ULONG *read_set, ULONG *evict_set)

{
    DWORD status;
    CrsInfo_t **info = (CrsInfo_t **) hdls;
    int i, active_sz, mid;
    ULONG mask, active_set, fail_set;
    CrsInfo_t *p;
    CrsRecord_t *q, *mlrec;

    if (write_set) *write_set = 0;
    if (read_set) *read_set = 0;
    if (evict_set) *evict_set = 0;

    // no alive node
    if (cluster_sz == 0 || alive_set == 0) {
        // nothing to do
        return ERROR_WRITE_PROTECT;
    }


    // scan each hdl and make sure it is initialized and lock all hdls
    mask = alive_set;
    for (i = 0; mask != 0; i++, mask = mask >> 1) {
        if (!(mask & 0x1)) {
            continue;
        }

        p = info[i];
        if (p == NULL) {
            continue;
        }

        EnterCriticalSection(&p->lock);

        // check the state of the last record
        p = info[i];
        q = &p->buf[p->last_record];
        CrsLog(("Crs%d last record %d epoch %I64d seq %I64d state %x\n",
                p->lid, p->last_record,
                q->hdr.epoch, q->hdr.seq, q->hdr.state));
    }

    mid = 0;
    mlrec = NULL;
    // select master replica
    for (i = 0, mask = alive_set; mask != 0; i++, mask = mask >> 1) {
        if (!(mask & 0x1)) {
            continue;
        }
        p = info[i];
        if (p == NULL)
            continue;

        q = &p->buf[p->last_record];
        if (!mlrec || 
            mlrec->hdr.epoch < q->hdr.epoch || 
            (mlrec->hdr.epoch == q->hdr.epoch && mlrec->hdr.seq < q->hdr.seq) ||
            (mlrec->hdr.epoch == q->hdr.epoch && mlrec->hdr.seq == q->hdr.seq &&
             mlrec->hdr.state != q->hdr.state && (q->hdr.state & CRS_COMMIT))) {

            mid = i;
            mlrec = q;
        }
    }

    ASSERT(mid != 0);

    // if master last record is in doubt, query filesystem. If the filesystem
    // is certain that the operation has occured, it returns STATUS_SUCCESS for
    //  COMMIT, STATUS_CANCELLED for ABORT, and STATUS_NOT_FOUND for can't tell.
    // All undetermined IO must be undone and redone in all non-master replicas
    // to ensure all replicas reach consistency. This statement is true even
    // for replicas that are currently absent from our set. We tag such records
    // we both COMMIT and ABORT, so that the replay thread issues replay for
    // new records and undo,replay for last records
    p = info[mid];
    p->leader_id = (USHORT) mid;
    ASSERT(mlrec != NULL);
    if (!(mlrec->hdr.state & (CRS_COMMIT | CRS_ABORT))) {
        ASSERT(mlrec->hdr.state & CRS_PREPARE);
        status = p->callback(p->callback_arg, p->lid,
                             mlrec, CRS_ACTION_QUERY,
                             p->lid);

        if (status == STATUS_SUCCESS) {
            mlrec->hdr.state |= CRS_COMMIT;
        } else if (status == STATUS_CANCELLED) {
            mlrec->hdr.state |= CRS_ABORT;
        } else if (status == STATUS_NOT_FOUND) {
            // assume it is committed, but mark it for undo during recovery
            mlrec->hdr.state |= (CRS_COMMIT | CRS_DUBIOUS);
        }

        // todo: if status == TRANSACTION_ABORTED, we need to bail out since
        // must master is dead
        // no need to flush, I think!
//      CrspFlush(p, p->last_record);

        // todo: what if the flush fails here, I am assuming that
        // an append will equally fail.
    }


    ASSERT(mlrec->hdr.state & (CRS_COMMIT | CRS_ABORT));

    // compute sync and recovery masks
    fail_set = 0;
    active_set = 0;
    active_sz = 0;
    for (i = 0, mask = alive_set; mask != 0; i++, mask = mask >> 1) {
        if (!(mask & 0x1)) {
            continue;
        }

        p = info[i];
        if (p == NULL) {
            continue;
        }

        // set leader id
        p->leader_id = (USHORT) mid;
        q = &p->buf[p->last_record];
            
        if (CrspEqual(mlrec, q)) {
            ASSERT(q->hdr.state & (CRS_COMMIT | CRS_ABORT));
            p->state = CRS_STATE_READ;
            active_set |= (1 << i);
            active_sz++;
        } else if (p->state != CRS_STATE_RECOVERY) {
            CrsRecoveryBlk_t rrbuf;
            CrsRecoveryBlk_t *rr = &rrbuf;

            // recover replica
            rr->nid = i;
            rr->mid = mid;
            rr->info = p;
            rr->minfo = info[mid];

            // set recovery state
            p->state = CRS_STATE_RECOVERY;

            status = CrspReplay((LPVOID) rr);

            // if we fail, evict this replica
            if (status != ERROR_SUCCESS) {
                fail_set |= (1 << i);
            } else {
                // repeat this replica again
                i--;
                mask = mask << 1;
            }
        }
    }

    // Now recreate the open file state. This needs to be done for all replicas.
    // Removed this operation from CrspReplay() since now it needs to be performed on
    // all replicas, even master.
    //
    for (i=0, mask=active_set; mask != 0;i++, mask = mask >>1) {
        if (!(mask & 0x1)) {
            continue;
        }

        status = info[i]->callback(info[i]->callback_arg, i, NULL, CRS_ACTION_DONE, mid);

        if (status != STATUS_SUCCESS) {
            active_set &= (~(1<<i));
            active_sz--;
            fail_set |= (1<<i);
        }
    }

    // assume success
    status = ERROR_SUCCESS;

    // set read sets
    if (read_set) *read_set = active_set;

    if (!CRS_QUORUM(active_sz, cluster_sz)) {
        CrsLog(("No quorum active %d cluster %d\n", active_sz, cluster_sz));
        mid = 0;
        status = ERROR_WRITE_PROTECT;
    } else {
        int pass_cnt = 0;
        ULONG pass_set = 0;

        // Enable writes on all active replicas
        for (i = 0, mask = active_set; mask != 0; i++, mask = mask >> 1) {
            CrsRecord_t rec;
            if (!(mask & 0x1)) {
                continue;
            }
            p = info[i];
            if (p == NULL)
                continue;

            p->state = CRS_STATE_WRITE;

            // we now generate a new epoch and flush it to the disk
            p->epoch++;
            if (p->epoch == 0)
                p->epoch = 1;
            // reset seq to zero
            p->seq = 0;

            // write new epoch now, if not a majority replicas succeeded in writing
            // the new <epoch, seq> we fail
            rec.hdr.epoch = p->epoch;
            rec.hdr.seq = p->seq;
            rec.hdr.state = CRS_PREPARE | CRS_COMMIT | CRS_EPOCH;
            memset(rec.data, 0, sizeof(rec.data));
            if (CrspAppendRecord(p, &rec, NULL) == ERROR_SUCCESS) {
                pass_cnt++;
                pass_set |= (1 << i);
            } else {
                fail_set |= (1 << i);
            }
        }

        // Recheck to make sure all replicas have advanced epoch
        if (!CRS_QUORUM(pass_cnt, cluster_sz)) {
            CrsLog(("No quorum due to error pass %d cluster %d\n", pass_cnt, cluster_sz));
            mid = 0;
            pass_set = 0;
            pass_cnt = 0;
            status = ERROR_WRITE_PROTECT;
        }

        if (pass_cnt != active_sz) {
            // some replicas have died
            for (i = 0, mask = pass_set; mask != 0; i++, mask = mask >> 1) {
                if ((alive_set & (1 << i)) && ((~mask) & (1 << i))) {
                    p = info[i];
                    ASSERT(p != NULL);
                    p->state = CRS_STATE_READ;
                }
            }
        }
        // set write set
        if (write_set) *write_set = pass_set;
    }

    if (evict_set) *evict_set = fail_set;

    // unlock all hdls and set new master if any
    for (i = 0, mask = alive_set; mask != 0; i++, mask = mask >> 1) {
        if (!(mask & 0x1)) {
            continue;
        }
        p = info[i];
        if (p == NULL)
            continue;

        p->leader_id = (USHORT) mid;
        LeaveCriticalSection(&p->lock);
    }

    return status;
}


void
WINAPI
CrsClose(PVOID hd)
{
    DWORD err=ERROR_SUCCESS;
    CrsInfo_t *info = (CrsInfo_t *) hd;

    // If we any recovery threads running, make sure we terminate them first
    // before close and free all of this stuff
    if (info == NULL) {
        CrsLog(("CrsClose: try to close a null handle!\n"));
        return;
    }

    // Flush everything out and close the file
    EnterCriticalSection(&info->lock);
    // flush 
    CrspFlush(info, info->last_record);
    LeaveCriticalSection(&info->lock);

    DeleteCriticalSection(&info->lock);

    if (info->fh != INVALID_HANDLE_VALUE) {
        UnlockFile(info->fh, 0, 0, (DWORD)-1, (DWORD)-1);
        err = CloseHandle(info->fh);
        info->fh = INVALID_HANDLE_VALUE;
    }

    CrsLog(("Crs%d: %x Closed %d\n", info->fh, info->lid, err));

    xfree(info->buf);
    free((char *) info);
}

void
WINAPI
CrsFlush(PVOID hd)
{
    CrsInfo_t *info = (CrsInfo_t *) hd;

    // if we have a commit or abort that isn't flushed yet, flush it now
    EnterCriticalSection(&info->lock);
    if (info->pending == TRUE) {
        CrspFlush(info, info->last_record);
    }
    LeaveCriticalSection(&info->lock);
}

PVOID
WINAPI
CrsPrepareRecord(PVOID hd, PVOID lrec, crs_id_t id, ULONG *retVal)
{
    CrsRecord_t *p = (CrsRecord_t *)lrec;
    CrsInfo_t *info = (CrsInfo_t *) hd;
    DWORD err;

    // move to correct slot in this sector. If we need a new sector,
    // read it from the file. Make sure we flush any pending commits on
    // current sector before we over write our in memory sector buffer.

    // prepare record, if seq none 0 then we are skipping the next sequence

    *retVal = STATUS_MEDIA_WRITE_PROTECTED;
    EnterCriticalSection(&info->lock);

    if (info->state == CRS_STATE_WRITE ||
        (info->state == CRS_STATE_RECOVERY && id != NULL && id[0] != 0)) {

        if (id != NULL && id[0] != 0) {
            CrsHdr_t *tmp = (CrsHdr_t *) id;
            assert(id[0] == info->seq+1);
            p->hdr.seq = tmp->seq;
            p->hdr.epoch = tmp->epoch;
        } else {
            p->hdr.seq = info->seq+1;
            p->hdr.epoch = info->epoch;
        }
        p->hdr.state = CRS_PREPARE;
        err = CrspAppendRecord(info, p, &p);
        *retVal = err;
        if (err == ERROR_SUCCESS) {
            // we return with the lock held, gets release on commitorabort
            CrsLog(("Crs%d prepare %x seq %I64d\n",info->lid, p, p->hdr.seq));
            return p;
        }
        CrsLog(("Crs%d: Append failed seq %I64%d\n", info->lid, p->hdr.seq));
    } else {
        CrsLog(("Crs%d: Prepare bad state %d id %x\n", info->lid, info->state, id));
    }

    LeaveCriticalSection(&info->lock);
    return NULL;
}

int
WINAPI
CrsCommitOrAbort(PVOID hd, PVOID lrec, int commit)
{
    CrsRecord_t *p = (CrsRecord_t *)lrec;
    CrsInfo_t *info = (CrsInfo_t *) hd;

    if (p == NULL || info == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    // update state of record
    if (p->hdr.seq != info->seq+1) {
        CrsLog(("Crs: sequence mis-match on commit|abort %I64d %I64d\n",
                p->hdr.seq, info->seq));
        assert(0);
        return ERROR_INVALID_PARAMETER;
    }

    assert(!(p->hdr.state & (CRS_COMMIT | CRS_ABORT)));

    // todo: this is wrong, what if one replica succeeds
    // and others abort. Now, the others will reuse the
    // same seq for a different update and when the
    // succeeded replica rejoins it can't tell that the
    // sequence got reused.
    if (commit == TRUE) {
        p->hdr.state |= CRS_COMMIT;
        // advance the sequence
        info->seq++;
        CrsLog(("Crs%d: commit last %d leader %d seq %I64d\n", info->lid, 
                info->last_record,
                info->leader_id, p->hdr.seq));
    } else {
        p->hdr.state |= CRS_ABORT;
        // we need to re-adjust our last record
        if (info->last_record == 0) {
            info->last_record = info->max_records;
        }
        info->last_record--;
        CrsLog(("Crs%d: abort last %d leader %d seq %I64d\n", info->lid, 
                info->last_record,
                info->leader_id, p->hdr.seq));
    }

    info->pending = TRUE;
    LeaveCriticalSection(&info->lock);

    return ERROR_SUCCESS;
}


int
WINAPI
CrsCanWrite(PVOID hd)
{
    CrsInfo_t *info = (CrsInfo_t *) hd;
    int err;

    // do we have a quorm or not
    EnterCriticalSection(&info->lock);
    err = (info->state == CRS_STATE_WRITE);
    LeaveCriticalSection(&info->lock);
    return err;
}

crs_epoch_t
CrsGetEpoch(PVOID hd)
{
    CrsInfo_t *info=(CrsInfo_t *)hd;
    crs_epoch_t epoch;

    EnterCriticalSection(&info->lock);
    epoch = info->epoch;
    LeaveCriticalSection(&info->lock);
    return epoch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\fs.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fs.c

Abstract:

    Implements filesystem operations

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "fs.h"
#include "crs.h"
#include "fsp.h"
#include "fsutil.h"
#include <strsafe.h>
#include "clstrcmp.h"
#include "Clusudef.h"

#include <Align.h>
#include <Ntddnfs.h>
#include <Clusapi.h>

// For testing only
// VOID
// ClRtlLogWmi(PCHAR FormatString);

DWORD
CrspNextLogRecord(CrsInfo_t *info, CrsRecord_t *seq,
                  CrsRecord_t *lrec, BOOLEAN this_flag);

VOID
MajorityNodeSetCallLostquorumCallback(PVOID arg);

ULONG
FspFindMissingReplicas(VolInfo_t *p, ULONG set);

void 
FspCloseVolume(VolInfo_t *vol, ULONG AliveSet);

// CRS returns Win32 errors, so need to add them too here.
#define IsNetworkFailure(x) \
    (((x) == STATUS_CONNECTION_DISCONNECTED)||\
    ((x) == STATUS_BAD_NETWORK_PATH)||\
    ((x) == STATUS_IO_TIMEOUT)||\
    ((x) == STATUS_VOLUME_DISMOUNTED)||\
    ((x) == STATUS_REMOTE_NOT_LISTENING)||\
    ((x) == ERROR_BAD_NETPATH)||\
    ((x) == ERROR_UNEXP_NET_ERR)||\
    ((x) == ERROR_NETNAME_DELETED)||\
    ((x) == ERROR_SEM_TIMEOUT)||\
    ((x) == ERROR_NOT_READY)||\
    ((x) == ERROR_REM_NOT_LIST)||\
    (RtlNtStatusToDosError(x) == ERROR_BAD_NETPATH)||\
    (RtlNtStatusToDosError(x) == ERROR_UNEXP_NET_ERR)||\
    (RtlNtStatusToDosError(x) == ERROR_NETNAME_DELETED))

char Mystaticchangebuff[sizeof(FILE_NOTIFY_INFORMATION) + 16];
IO_STATUS_BLOCK MystaticIoStatusBlock;

VOID CALLBACK
FsNotifyCallback(
    IN PVOID                par,
    IN BOOLEAN              isFired
    )
{
    WaitRegArg_t    *wReg=(WaitRegArg_t *)par;
    VolInfo_t       *vol=(VolInfo_t *)wReg->vol;
    HANDLE          regHdl;
    NTSTATUS        status;

    if (wReg == NULL) {
        FsLog(("FsNotifyCallback(): Exiting...\n"));
        return;
    }

    FsLog(("FsNotifyCallback: Enqueing Change notification for Fd:0x%x\n", wReg->notifyFd));

    status = NtNotifyChangeDirectoryFile(wReg->notifyFd,
                vol->NotifyChangeEvent[wReg->id],
                NULL,
                NULL,
                &MystaticIoStatusBlock,
                &Mystaticchangebuff,
                sizeof(Mystaticchangebuff),
                FILE_NOTIFY_CHANGE_EA,
                (BOOLEAN)FALSE
                );

    if (!NT_SUCCESS(status)) {
        FsLog(("FsNotifyCallback: Failed to enque change notify, status 0x%x\n", status));
        FsLog(("FsNotifyCallback: Deregistering wait notification, nid:%d\n", wReg->id));
        LockEnter(vol->ArbLock);
        regHdl = vol->WaitRegHdl[wReg->id];
        vol->WaitRegHdl[wReg->id] = INVALID_HANDLE_VALUE;
        LockExit(vol->ArbLock);
        if ((regHdl != INVALID_HANDLE_VALUE)&&(!UnregisterWaitEx(regHdl, NULL))) {
            FsLog(("FsNotifyCallback: UnregisterWaitEx() failed, status %d\n", GetLastError()));
        }
    }
}

////////////////////////////////////////////////////////////////////////////
UINT32
get_attributes(DWORD a)
{
    UINT32 attr = 0;
    if (a & FILE_ATTRIBUTE_READONLY) attr |= ATTR_READONLY;
    if (a & FILE_ATTRIBUTE_HIDDEN)   attr |= ATTR_HIDDEN;
    if (a & FILE_ATTRIBUTE_SYSTEM)   attr |= ATTR_SYSTEM;
    if (a & FILE_ATTRIBUTE_ARCHIVE)  attr |= ATTR_ARCHIVE;
    if (a & FILE_ATTRIBUTE_DIRECTORY) attr |= ATTR_DIRECTORY;
    if (a & FILE_ATTRIBUTE_COMPRESSED) attr |= ATTR_COMPRESSED;
    if (a & FILE_ATTRIBUTE_OFFLINE) attr |= ATTR_OFFLINE;
    return attr;
}


DWORD
unget_attributes(UINT32 attr)
{
    DWORD a = 0;
    if (attr & ATTR_READONLY)  a |= FILE_ATTRIBUTE_READONLY;
    if (attr & ATTR_HIDDEN)    a |= FILE_ATTRIBUTE_HIDDEN;
    if (attr & ATTR_SYSTEM)    a |= FILE_ATTRIBUTE_SYSTEM;
    if (attr & ATTR_ARCHIVE)   a |= FILE_ATTRIBUTE_ARCHIVE;
    if (attr & ATTR_DIRECTORY) a |= FILE_ATTRIBUTE_DIRECTORY;
    if (attr & ATTR_COMPRESSED) a |= FILE_ATTRIBUTE_COMPRESSED;
    if (attr & ATTR_OFFLINE) a |= FILE_ATTRIBUTE_OFFLINE;
    return a;
}


DWORD
unget_disp(UINT32 flags)
{
    switch (flags & FS_DISP_MASK) {
    case DISP_DIRECTORY:
    case DISP_CREATE_NEW:        return FILE_CREATE;
    case DISP_CREATE_ALWAYS:     return FILE_OPEN_IF;
    case DISP_OPEN_EXISTING:     return FILE_OPEN;
    case DISP_OPEN_ALWAYS:       return FILE_OPEN_IF;
    case DISP_TRUNCATE_EXISTING: return FILE_OVERWRITE;
    default: return 0;
    }
}

DWORD
unget_access(UINT32 flags)
{
    DWORD win32_access = (flags & FS_DISP_MASK) == DISP_DIRECTORY ? 
        FILE_GENERIC_READ|FILE_GENERIC_WRITE :  FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES;
    if (flags & ACCESS_READ)  win32_access |= FILE_GENERIC_READ;
    if (flags & ACCESS_WRITE) win32_access |= FILE_GENERIC_WRITE;
    win32_access |= FILE_READ_EA | FILE_WRITE_EA;
    return win32_access;
}

DWORD
unget_share(UINT32 flags)
{
    // we always open read shared because this simplifies recovery.
    DWORD win32_share = FILE_SHARE_READ;
    if (flags & SHARE_READ)  win32_share |= FILE_SHARE_READ;
    if (flags & SHARE_WRITE) win32_share |= FILE_SHARE_WRITE;
    return win32_share;
}


DWORD
unget_flags(UINT32 flags)
{
    DWORD x;

    x = 0;
    if ((flags & FS_DISP_MASK) == DISP_DIRECTORY) {
        x = FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT;
    } else {
        // I don't think I can tell without doing a query first, so don't!
//      x = FILE_NON_DIRECTORY_FILE;
    }


    if ((flags & FS_CACHE_MASK) == CACHE_WRITE_THROUGH) {
        x |= FILE_WRITE_THROUGH;
    }
    if ((flags & FS_CACHE_MASK) == CACHE_NO_BUFFERING) {
        x |= FILE_NO_INTERMEDIATE_BUFFERING;
    }

    return x;
}


void
DecodeCreateParam(UINT32 uflags, UINT32 *flags, UINT32 *disp, UINT32 *share, UINT32 *access)
{
    *flags = unget_flags(uflags);
    *disp = unget_disp(uflags);
    *share = unget_share(uflags);
    *access = unget_access(uflags);

}
/********************************************************************/

NTSTATUS
FspAllocatePrivateHandle(UserInfo_t *p, fhandle_t *fid)
{
    int i;
    NTSTATUS err = STATUS_NO_MORE_FILES;
    int j;

    LockEnter(p->Lock);

    // Don't use entry 0, functions might interpret this as error.
    for (i = 1; i < FsTableSize; i++) {
        if (p->Table[i].Flags == 0) {
            p->Table[i].Flags = ATTR_SYMLINK; // place marker
            err = STATUS_SUCCESS;
            // Reset all the handle values
            for(j=0;j<FsMaxNodes;j++) {
                p->Table[i].Fd[j] = INVALID_HANDLE_VALUE;
            }
            p->Table[i].FileName = NULL;
            p->Table[i].hState = HandleStateAssigned;
            break;
        }
    }

    LockExit(p->Lock);

    *fid = (fhandle_t) i;

    return err;
}

void
FspFreeHandle(UserInfo_t *p, fhandle_t fnum)
{
    int i;

    FsLog(("FreeHandle %d\n", fnum));

    ASSERT(fnum != INVALID_FHANDLE_T);
    LockEnter(p->Lock);
    p->Table[fnum].Flags = 0;
    // Close any open handles in the Fd.
    for(i=0;i<FsMaxNodes;i++) {
        if (p->Table[fnum].Fd[i] != INVALID_HANDLE_VALUE) {
            xFsClose(p->Table[fnum].Fd[i]);
            p->Table[fnum].Fd[i] = INVALID_HANDLE_VALUE;
        }
    }
    // Deallocate the file name.
    if (p->Table[fnum].FileName != NULL) {
        LocalFree(p->Table[fnum].FileName);
        p->Table[fnum].FileName = NULL;
    }
    p->Table[fnum].hState = HandleStateInit;
    LockExit(p->Lock);
    
}

/*********************************************************** */

void
FspEvict(VolInfo_t *p, ULONG mask, BOOLEAN full_evict)
/*++
    This function should be called with writer's lock held.
    FspJoin() & FspEvict() are the only functions which can modify VolInfo->State.
 */    

{
    DWORD err;
    ULONG set;

    // Only evict those shares that are still in the alive set.
    mask = (mask & p->AliveSet);

    FsArbLog(("FspEvict Entry: WSet %x Rset %x ASet %x EvictMask %x\n",
           p->WriteSet, p->ReadSet, p->AliveSet, mask));
    
    while (mask != 0) {

        if (full_evict == FALSE) {
            // we just need to close the volume and return since
            // these replicas are not yet added to the aliveset and crs doesn't know
            // about them
            FspCloseVolume(p, mask);
            break;
        }

        // clear nid
        p->AliveSet &= ~mask;
        set = p->AliveSet;

        //  close nid handles <crs, vol, open files>
        FspCloseVolume(p, mask);

        mask = 0;

        err = CrsStart(p->CrsHdl, set, p->DiskListSz,
                       &p->WriteSet, &p->ReadSet, &mask);

        if (mask == 0) {
            // Now update the MNS state.
            if (p->WriteSet) {
                p->State = VolumeStateOnlineReadWrite;
            }
            else if (p->ReadSet) {
                p->State = VolumeStateOnlineReadonly;
            }
            else {
                p->State = VolumeStateInit;
            }
        }
    }

    FsArbLog(("FspEvict Exit: vol %S WSet %x RSet %x ASet %x\n",
           p->Root, p->WriteSet, p->ReadSet, p->AliveSet));
}

void
FspJoin(VolInfo_t *p, ULONG mask)
/*++
    This function should be called with writer's lock held.
    FspJoin() & FspEvict() are the only functions which can modify VolInfo->State.
 */    
{       
    DWORD       err;
    ULONG       set=0;
    DWORD       i;

    // Join only those shares that are not already in the AliveSet.
    mask = (mask & (~p->AliveSet));

    FsArbLog(("FspJoin Entry: WSet %x Rset %x ASet %x JoinMask %x\n",
           p->WriteSet, p->ReadSet, p->AliveSet, mask));
    
    if (mask != 0) {

        p->AliveSet |= mask;
        set = p->AliveSet;

        // Mark the share state to be online, if they fail in CrsStart, they would
        // set to offline in FspEvict()
        //
        for(i=1;i<FsMaxNodes;i++) {
            if (set & (1<<i)) {
                p->ShareState[i] = SHARE_STATE_ONLINE;
            }
        }
        mask = 0;
        err = CrsStart(p->CrsHdl, set, p->DiskListSz, 
                       &p->WriteSet, &p->ReadSet, &mask);

        if (mask != 0) {
            // we need to evict dead members
            FspEvict(p, mask, TRUE);
        }
        
        // Now update the MNS state.
        if (p->WriteSet) {
            p->State = VolumeStateOnlineReadWrite;
        }
        else if (p->ReadSet) {
            p->State = VolumeStateOnlineReadonly;
        }
        else {
            p->State = VolumeStateInit;
        }
    }

    FsArbLog(("FspJoin Exit: vol %S WSet %x Rset %x ASet %x\n",
           p->Root, p->WriteSet, p->ReadSet, p->AliveSet));
}

void
FspInitAnswers(IO_STATUS_BLOCK *ios, PVOID *rbuf, char *r, int sz)
{

    int i;

    for (i = 0; i < FsMaxNodes; i++) {
        ios[i].Status = STATUS_HOST_UNREACHABLE;
        if (rbuf) {
            rbuf[i] = r;
            r += sz;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////

NTSTATUS
FspCreate(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
          PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{

    // each file has a name stream that contains its crs log. We first
    // must open the parent crs log, issue a prepare on it. Create the new file
    // and then issuing a commit or abort on parent crs log. We also, have
    // to issue joins for each new crs handle that we get for the new file or
    // opened file. Note, this open may cause the file to enter recovery
    fs_create_msg_t *msg = (fs_create_msg_t *)args;
    NTSTATUS err=STATUS_SUCCESS, status;
    UINT32 disp, share, access, flags;
    fs_log_rec_t        lrec;
    PVOID seq;
    fs_ea_t x;
    HANDLE fd;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    fs_create_reply_t *rmsg = (fs_create_reply_t *)rbuf;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    fs_id_t     *fid;
    ULONG retVal;

    // This has to work with replays, if fd is not INVALID_HANDLE_VALUE
    // return success immediately. This is because replaying a successful open/create
    // might change the disposition.
    //
    if (uinfo && (msg->fnum != INVALID_FHANDLE_T) &&
        (uinfo->Table[msg->fnum].Fd[nid] != INVALID_HANDLE_VALUE)) {
        FsLog(("Create '%S' already open nid %u fid %u handle 0x%x\n",
            msg->name, nid, msg->fnum, 
            uinfo->Table[msg->fnum].Fd[nid]));
        return err;
    }

    DecodeCreateParam(msg->flags, &flags, &disp, &share, &access);

    FsInitEa(&x);

    memset(&lrec.fs_id, 0, sizeof(lrec.fs_id));
    lrec.command = FS_CREATE;
    lrec.flags = msg->flags;
    lrec.attrib = msg->attr;
    seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid, &retVal);
    if (seq == 0) {
        FsLog(("create: Unable to prepare log record!, open readonly\n"));
        return retVal;
    }
    // set fid 
    {
        fs_log_rec_t    *p = (PVOID) seq;

        memcpy(p->fs_id, p->id, sizeof(fs_id_t));

        FsInitEaFid(&x, fid);
        memcpy(fid, p->id, sizeof(fs_id_t));
    }

    err = xFsCreate(&fd, vfd, msg->name, msg->name_len,
                   flags, msg->attr, share, &disp, access,
                   (PVOID) &x, sizeof(x));

    xFsLog(("create: %S err %x access %x disp %x\n", msg->name, 
           err, access, disp));

    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS &&
                     (disp == FILE_CREATED || 
                      disp == FILE_OVERWRITTEN));

    if (err == STATUS_SUCCESS) {
        // we need to get the file id, no need to do this, for debug only
        err = xFsQueryObjectId(fd, (PVOID) fid);
        if (err != STATUS_SUCCESS) {
            FsLog(("Failed to get fileid %x\n", err));
            err = STATUS_SUCCESS;
        }

        // Copy the crs record.
        *(fs_log_rec_t *)rec = lrec;
    }


#ifdef FS_ASYNC
    BindNotificationPort(comport, fd, (PVOID) fdnum);
#endif      

    if (uinfo != NULL && msg->fnum != INVALID_FHANDLE_T) {
        FS_SET_USER_HANDLE(uinfo, nid, msg->fnum, fd);
    } else {
        xFsClose(fd);
    }

    ASSERT(rmsg != NULL);

    memcpy(&rmsg->fid, fid, sizeof(fs_id_t));
    rmsg->action = (USHORT)disp;
    rmsg->access = (USHORT)access;
    *rlen = sizeof(*rmsg);

    FsLog(("Create '%S' nid %d fid %d handle %x oid %I64x:%I64x\n",
           msg->name,
           nid, msg->fnum, fd,
           rmsg->fid[0], rmsg->fid[1]));

    return err;
}

NTSTATUS
FspOpen(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
        PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    // same as create except disp is allows open only and
    // no crs logging
    fs_create_msg_t *msg = (fs_create_msg_t *)args;
    NTSTATUS err=STATUS_SUCCESS, status;
    UINT32 disp, share, access, flags;
    HANDLE fd;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    fs_create_reply_t *rmsg = (fs_create_reply_t *)rbuf;

    ASSERT(rmsg != NULL);

    // This has to work with replays, if fd is not INVALID_HANDLE_VALUE
    // return success immediately. This is because replaying a successful open/create
    // might change the disposition.
    //
    if (uinfo && (msg->fnum != INVALID_FHANDLE_T) &&
        (uinfo->Table[msg->fnum].Fd[nid] != INVALID_HANDLE_VALUE)) {
        FsLog(("Open '%S' already open nid %u fid %u handle 0x%x\n",
            msg->name, nid, msg->fnum, 
            uinfo->Table[msg->fnum].Fd[nid]));
        return err;
    }
    
    DecodeCreateParam(msg->flags, &flags, &disp, &share, &access);

    disp = FILE_OPEN;
    err = xFsCreate(&fd, vfd, msg->name, msg->name_len,
                   flags, msg->attr, share, &disp, access,
                   NULL, 0);

    xFsLog(("open: %S err %x access %x disp %x\n", msg->name, 
           err, access, disp));

    if (err == STATUS_SUCCESS) {
        ASSERT(disp != FILE_CREATED && disp != FILE_OVERWRITTEN);
        // we need to get the file id, no need to do this, for debug only
        err = xFsQueryObjectId(fd, (PVOID) &rmsg->fid);
        if (err != STATUS_SUCCESS) {
            FsLog(("Open '%S' failed to get fileid %x\n",
                        msg->name, err));
            err = STATUS_SUCCESS;
        }
    }


#ifdef FS_ASYNC
    BindNotificationPort(comport, fd, (PVOID) fdnum);
#endif      

    if (uinfo != NULL && msg->fnum != INVALID_FHANDLE_T) {
        FS_SET_USER_HANDLE(uinfo, nid, msg->fnum, fd);
    } else {
        xFsClose(fd);
    }

    rmsg->action = (USHORT)disp;
    rmsg->access = (USHORT)access;
    *rlen = sizeof(*rmsg);

    FsLog(("Open '%S' nid %d fid %d handle %x oid %I64x:%I64x\n",
           msg->name,
           nid, msg->fnum, fd,
           rmsg->fid[0], rmsg->fid[1]));

    return err;
}


NTSTATUS
FspSetAttr(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
           PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{
    fs_setattr_msg_t *msg = (fs_setattr_msg_t *)args;
    NTSTATUS err;
    fs_log_rec_t        lrec;
    PVOID seq;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE fd = FS_GET_USER_HANDLE(uinfo, nid, msg->fnum);
    ULONG retVal;

    lrec.command = FS_SETATTR;
    memcpy((PVOID) lrec.fs_id, (PVOID) msg->fs_id, sizeof(fs_id_t));
    lrec.attrib = msg->attr.FileAttributes;

    if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid, &retVal)) == 0) {
        return retVal;
    }
    
    // can be async ?
    err = xFsSetAttr(fd, &msg->attr);

    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);

    if (err == STATUS_SUCCESS) {
        // copy the crs record.
        *(fs_log_rec_t *)rec = lrec;
    }
    return err;

}


NTSTATUS
FspSetAttr2(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
            PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{
    fs_setattr_msg_t *msg = (fs_setattr_msg_t *)args;
    HANDLE fd = INVALID_HANDLE_VALUE;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    NTSTATUS err;
    fs_log_rec_t        lrec;
    PVOID seq;
    ULONG retVal;

    assert(len == sizeof(*msg));

    // must be sync in order to close file
    err = xFsOpenWA(&fd, vfd, msg->name, msg->name_len);
    if (err == STATUS_SUCCESS) {
        err = xFsQueryObjectId(fd, (PVOID) &lrec.fs_id);
    }

    if (err == STATUS_SUCCESS) {

        lrec.command = FS_SETATTR;
        lrec.attrib = msg->attr.FileAttributes;

        if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid, &retVal)) != 0) {

            err = xFsSetAttr(fd, &msg->attr);

            CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);

            if (err == STATUS_SUCCESS) {
                // copy the crs record.
                *(fs_log_rec_t *)rec = lrec;
            }
        } else {
            return retVal;
        }
    }

    if (fd != INVALID_HANDLE_VALUE)
        xFsClose(fd);

    xFsLog(("setattr2 nid %d '%S' err %x\n", nid, msg->name, err));

    return err;

}

NTSTATUS
FspLookup(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
          PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_lookup_msg_t *msg = (fs_lookup_msg_t *) args;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    FILE_NETWORK_OPEN_INFORMATION *attr = (FILE_NETWORK_OPEN_INFORMATION *)rbuf;
    
    ASSERT(*rlen == sizeof(*attr));

    return xFsQueryAttrName(vfd, msg->name, msg->name_len, attr);

}

NTSTATUS
FspGetAttr(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
           PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fhandle_t handle = *(fhandle_t *) args;
    HANDLE fd = FS_GET_USER_HANDLE(uinfo, nid, handle);
    FILE_NETWORK_OPEN_INFORMATION *attr = (FILE_NETWORK_OPEN_INFORMATION *)rbuf;

    ASSERT(*rlen == sizeof(*attr));

    return xFsQueryAttr(fd, attr);
}


NTSTATUS
FspClose(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
         PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen)
{
    fhandle_t handle = *(fhandle_t *) args;
    HANDLE fd;
    NTSTATUS err=STATUS_SUCCESS;

    if (uinfo != NULL && handle != INVALID_FHANDLE_T)
        fd = FS_GET_USER_HANDLE(uinfo, nid, handle);
    else
        fd = FS_GET_VOL_HANDLE(vinfo, nid);

    FsLog(("Closing nid %d fid %d handle %x\n", nid, handle, fd));

    if (fd != INVALID_HANDLE_VALUE) {
        err = xFsClose(fd);
    }

    // Map failures to success. Shares shouldn't be evicted because of this,    
    if (err != STATUS_SUCCESS) {
        FsLogError(("Close nid %d fid %d handle 0x%x returns 0x%x\n", nid, handle, fd, err));
        err = STATUS_SUCCESS;
    }
        

    if (uinfo != NULL && handle != INVALID_FHANDLE_T) {
        FS_SET_USER_HANDLE(uinfo, nid, handle, INVALID_HANDLE_VALUE);
    } else {
        FS_SET_VOL_HANDLE(vinfo, nid, INVALID_HANDLE_VALUE);
    }

    return err;
}


NTSTATUS
FspReadDir(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
           PVOID args, ULONG len, PVOID rbuf,
           ULONG_PTR *entries_found)
{
    fs_io_msg_t *msg = (fs_io_msg_t *)args;
    int i;
    NTSTATUS e = STATUS_SUCCESS;
    int size = (int) msg->size;
    int cookie = (int) msg->cookie;
    HANDLE dir; 
    dirinfo_t *buffer = (dirinfo_t *)msg->buf;

    xFsLog(("DirLoad: size %d\n", size));

    if (uinfo != NULL && msg->fnum != INVALID_FHANDLE_T)
        dir = FS_GET_USER_HANDLE(uinfo, nid, msg->fnum);
    else
        dir = FS_GET_VOL_HANDLE(vinfo, nid);

    *entries_found = 0;
    for(i = 0; size >= sizeof(dirinfo_t) ; i+=PAGESIZE) {
        // this must come from the source if we are to do async readdir
        char buf[PAGESIZE];
        int sz;

        sz = min(PAGESIZE, size);
        e = xFsReadDir(dir, buf, &sz, (cookie == 0) ? TRUE : FALSE);
        if (e == STATUS_SUCCESS) {
            PFILE_DIRECTORY_INFORMATION p;

            p = (PFILE_DIRECTORY_INFORMATION) buf;
            while (size >= sizeof(dirinfo_t)) {
                char *foo;
                int k;

                k = p->FileNameLength/sizeof(WCHAR);
                p->FileName[k] = L'\0';
                // name is a WCHAR array of size MAX_PATH.
                StringCchCopyW(buffer->name, MAX_PATH, p->FileName);
                buffer->attribs.file_size = p->EndOfFile.QuadPart;
                buffer->attribs.alloc_size = p->AllocationSize.QuadPart;
                buffer->attribs.create_time = p->CreationTime.QuadPart;
                buffer->attribs.access_time = p->LastAccessTime.QuadPart;
                buffer->attribs.mod_time = p->LastWriteTime.QuadPart;
                buffer->attribs.attributes = p->FileAttributes;
                buffer->cookie = ++cookie;
                buffer++;
                size -= sizeof(dirinfo_t);
                (*entries_found)++;

                if (p->NextEntryOffset == 0)
                    break;

                foo = (char *) p;
                foo += p->NextEntryOffset;
                p = (PFILE_DIRECTORY_INFORMATION) foo;
            }
        }
        else {
            break;
        }
    }

    return e;

}

NTSTATUS
FspMkDir(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
         PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{
    fs_create_msg_t     *msg = (fs_create_msg_t *)args;
    NTSTATUS err;
    HANDLE fd;
    fs_log_rec_t        lrec;
    PVOID seq;
    fs_ea_t x;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    fs_id_t *fid;
    UINT32 disp, share, access, flags;
    ULONG retVal;

    FsInitEa(&x);

    memset(&lrec.fs_id, 0, sizeof(lrec.fs_id));
    lrec.command = FS_MKDIR;
    lrec.attrib = msg->attr;
    lrec.flags = msg->flags;

    if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid, &retVal)) == 0) {
        return retVal;
    }

    // set fid 
    {
        fs_log_rec_t    *p = (PVOID) seq;

        memcpy(p->fs_id, p->id, sizeof(fs_id_t));

        FsInitEaFid(&x, fid);
        // set fs_id of the file
        memcpy(fid, p->id, sizeof(fs_id_t));
    }

    // decode attributes
    DecodeCreateParam(msg->flags, &flags, &disp, &share, &access);

    // always sync call
    err = xFsCreate(&fd, vfd, msg->name, msg->name_len, flags,
                   msg->attr, share, &disp, access,
                   (PVOID) &x, sizeof(x));

    FsLog(("Mkdir '%S' %x: cflags %x flags:%x attr:%x share:%x disp:%x access:%x\n",
           msg->name, err, msg->flags,
           flags, msg->attr, share, disp, access));


    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS &&
                     (disp == FILE_CREATED || 
                      disp == FILE_OVERWRITTEN));

    if (err == STATUS_SUCCESS) {
        // return fid
        if (rbuf != NULL) {
            ASSERT(*rlen == sizeof(fs_id_t));
            memcpy(rbuf, fid, sizeof(fs_id_t));
        }
        xFsClose(fd);

        // copy the crs record.
        *(fs_log_rec_t *)rec = lrec;
    }

    return err;

}

NTSTATUS
FspRemove(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
          PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{
    fs_remove_msg_t     *msg = (fs_remove_msg_t *)args;
    NTSTATUS err;
    fs_log_rec_t        lrec;
    PVOID       seq;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    HANDLE fd;
    ULONG retVal;

    *rlen = 0;

    // next three statements to obtain name -> fs_id
    err = xFsOpenRA(&fd, vfd, msg->name, msg->name_len); 
    if (err != STATUS_SUCCESS) {
        return err;
    }

    // get object id
    err = xFsQueryObjectId(fd, (PVOID) &lrec.fs_id);

    xFsClose(fd);

    lrec.command = FS_REMOVE;

    if (err != STATUS_SUCCESS) {
        return err;
    }

    if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid, &retVal)) == 0) {
        return retVal;
    }

    err = xFsDelete(vfd, msg->name, msg->name_len);

    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);

    if (err == STATUS_SUCCESS) {
        // copy the crs record.
        *(fs_log_rec_t *)rec = lrec;
    }

    xFsLog(("Rm nid %d '%S' %x\n", nid, msg->name, err));

    return err;

}

NTSTATUS
FspRename(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
          PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{
    fs_rename_msg_t     *msg = (fs_rename_msg_t *)args;
    NTSTATUS err;
    fs_log_rec_t        lrec;
    PVOID       seq;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    HANDLE fd;
    ULONG retVal;

    lrec.command = FS_RENAME;

    err = xFsOpen(&fd, vfd, msg->sname, msg->sname_len,
                  STANDARD_RIGHTS_REQUIRED| SYNCHRONIZE |
                  FILE_READ_EA |
                  FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                  FILE_SHARE_READ, // | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                  0);

    if (err != STATUS_SUCCESS) {
        return err;
    }

    // get file id
    err = xFsQueryObjectId(fd, (PVOID) &lrec.fs_id); 

    if (err == STATUS_SUCCESS) {
        if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid, &retVal)) != 0) {
            err = xFsRename(fd, vfd, msg->dname, msg->dname_len);
            CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);

            if (err == STATUS_SUCCESS) {
                // copy the crs record.
                *(fs_log_rec_t *)rec = lrec;
            }
        } else {
            err = retVal;
        }
    } else {
        xFsLog(("Failed to obtain fsid %x\n", err));
    }

    xFsClose(fd);

    xFsLog(("Mv nid %d %S -> %S err %x\n", nid, msg->sname, msg->dname,
           err));

    return err;

}

NTSTATUS
FspWrite(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
         PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    LARGE_INTEGER off;
    ULONG key;
    fs_io_msg_t *msg = (fs_io_msg_t *)args;
    fs_log_rec_t        lrec;
    PVOID seq;
    PVOID crs_hd = FS_GET_CRS_HANDLE(vinfo, nid);
    HANDLE fd;
    ULONG retVal;

    if (uinfo != NULL && msg->fnum != INVALID_FHANDLE_T)
        fd = FS_GET_USER_HANDLE(uinfo, nid, msg->fnum);
    else
        fd = (HANDLE) msg->context;

    lrec.command = FS_WRITE;
    memcpy(lrec.fs_id, (PVOID) msg->fs_id, sizeof(fs_id_t));
    lrec.offset = msg->offset;
    lrec.length = msg->size;

    if ((seq = CrsPrepareRecord(crs_hd, (PVOID) &lrec, msg->xid, &retVal)) == 0) {
        return retVal;
    }

    // Write ops
    xFsLog(("Write %d fd %p len %d off %d\n", nid, fd, msg->size, msg->offset));

    off.LowPart = msg->offset;
    off.HighPart = 0;   
    key = FS_BUILD_LOCK_KEY((uinfo ? uinfo->Uid : 0), nid, msg->fnum);

    if (msg->size > 0) {
        err = NtWriteFile(fd, NULL, NULL, (PVOID) NULL, &ios,
                          msg->buf, msg->size, &off, &key);
    } else {
        FILE_END_OF_FILE_INFORMATION x;

        x.EndOfFile = off;

        ios.Information = 0;
        err = NtSetInformationFile(fd, &ios,
                                   (char *) &x, sizeof(x),
                                   FileEndOfFileInformation);
    }

    if (err == STATUS_PENDING) {
        EventWait(fd);
        err = ios.Status;
    }

    *rlen = ios.Information;

    CrsCommitOrAbort(crs_hd, seq, err == STATUS_SUCCESS);

    if (err == STATUS_SUCCESS) {
        // copy the crs record.
        *(fs_log_rec_t *)rec = lrec;
    }

    xFsLog(("fs_write%d err %x sz %d\n", nid, err, *rlen));
    return err;

}

NTSTATUS
FspRead(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
        PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_io_msg_t *msg = (fs_io_msg_t *)args;
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    LARGE_INTEGER off;
    HANDLE fd = FS_GET_USER_HANDLE(uinfo, nid, msg->fnum);
    ULONG key;

    assert(sz == sizeof(*msg));

    // Read ops
    off.LowPart = msg->offset;
    off.HighPart = 0;   
    key = FS_BUILD_LOCK_KEY(uinfo->Uid, nid, msg->fnum);

    ios.Information = 0;
    err = NtReadFile(fd, NULL, NULL, NULL,
                     &ios, msg->buf, msg->size, &off, &key);

    if (err == STATUS_PENDING) {
        EventWait(fd);
        err = ios.Status;
    }

    *rlen = ios.Information;

    xFsLog(("fs_read%d err %x sz %d\n", nid, err, *rlen));

    return err;
}


NTSTATUS
FspFlush(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
         PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{
    fhandle_t fnum = *(fhandle_t *)args;
    IO_STATUS_BLOCK ios;
    HANDLE fd;

    ASSERT(sz == sizeof(fhandle_t));
    *rlen = 0;

    if (uinfo != NULL && fnum != INVALID_FHANDLE_T) {
        fd = FS_GET_USER_HANDLE(uinfo, nid, fnum);
    } else {
        fd = FS_GET_VOL_HANDLE(vinfo, nid);
    }
    return NtFlushBuffersFile(fd, &ios);
}

NTSTATUS
FspLock(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
        PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{
    fs_lock_msg_t *msg = (fs_lock_msg_t *)args;
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    LARGE_INTEGER offset, len;
    BOOLEAN wait, shared;
    ULONG key = FS_BUILD_LOCK_KEY(uinfo->Uid, nid, msg->fnum);

    assert(sz == sizeof(*msg));

    // xxx: need to log

    FsLog(("Lock %d off %d len %d flags %x\n", msg->fnum, msg->offset, msg->length,
           msg->flags));

    offset.LowPart = msg->offset;
    offset.HighPart = 0;
    len.LowPart = msg->length;
    len.HighPart = 0;

    // todo: need to be async, if we are the owner node and failnow is false, then
    // we should pass in the context and the completion port responses back
    // to the user
    wait = (BOOLEAN) ((msg->flags & FS_LOCK_WAIT) ? TRUE : FALSE);
    // todo: this can cause lots of headache, never wait.
    wait = FALSE;
    shared = (BOOLEAN) ((msg->flags & FS_LOCK_SHARED) ? FALSE : TRUE);
    
    err = NtLockFile(uinfo->Table[msg->fnum].Fd[nid],
                     NULL, NULL, (PVOID) NULL, &ios,
                     &offset, &len,
                     key, wait, shared);

    // xxx: Need to log in software only

    *rlen = 0;
    FsLog(("Lock err %x\n", err));
    return err;
}

NTSTATUS
FspUnlock(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
          PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen, PVOID rec)
{
    fs_lock_msg_t *msg = (fs_lock_msg_t *)args;
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    LARGE_INTEGER offset, len;
    ULONG key = FS_BUILD_LOCK_KEY(uinfo->Uid, nid, msg->fnum);

    assert(sz == sizeof(*msg));

    // xxx: need to log

    xFsLog(("Unlock %d off %d len %d\n", msg->fnum, msg->offset, msg->length));

    offset.LowPart = msg->offset;
    offset.HighPart = 0;
    len.LowPart = msg->length;
    len.HighPart = 0;

    // always sync I think
    err = NtUnlockFile(uinfo->Table[msg->fnum].Fd[nid], &ios, &offset, &len, key);

    // xxx: need to log in software only

    FsLog(("Unlock err %x\n", err));

    *rlen = 0;
    return err;
}

NTSTATUS
FspStatFs(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
          PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    fs_attr_t *msg = (fs_attr_t *)args;
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    FILE_FS_SIZE_INFORMATION fsinfo;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);

    assert(sz == sizeof(*msg));

    // xxx: need to log
    lstrcpyn(msg->fs_name, "FsCrs", MAX_FS_NAME_LEN);

    err = NtQueryVolumeInformationFile(vfd, &ios,
                                       (PVOID) &fsinfo,
                                       sizeof(fsinfo),
                                       FileFsSizeInformation);
    if (err == STATUS_SUCCESS) {
        msg->total_units = fsinfo.TotalAllocationUnits.QuadPart;
        msg->free_units = fsinfo.AvailableAllocationUnits.QuadPart;
        msg->sectors_per_unit = fsinfo.SectorsPerAllocationUnit;
        msg->bytes_per_sector = fsinfo.BytesPerSector;
    }

    *rlen = 0;
    return err;
}

NTSTATUS
FspCheckFs(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
           PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    FILE_FS_SIZE_INFORMATION fsinfo;
    HANDLE vfd = FS_GET_VOL_HANDLE(vinfo, nid);
    PVOID crshdl = FS_GET_CRS_HANDLE(vinfo, nid);

    err = NtQueryVolumeInformationFile(vfd, &ios,
                                       (PVOID) &fsinfo,
                                       sizeof(fsinfo),
                                       FileFsSizeInformation);

    // We need to issue crsflush to flush last write
    CrsFlush(crshdl);

    if (err == STATUS_SUCCESS) {
#if 0        
        HANDLE notifyfd = FS_GET_VOL_NOTIFY_HANDLE(vinfo, nid);
        // Just an additional thing.
        if (WaitForSingleObject(notifyfd, 0) == WAIT_OBJECT_0) {
            // reload notification again
#if 1
            NtNotifyChangeDirectoryFile(notifyfd,
                        vinfo->NotifyChangeEvent[nid],
                        NULL,
                        NULL,
                        &MystaticIoStatusBlock,
                        &Mystaticchangebuff,
                        sizeof(Mystaticchangebuff),
                        FILE_NOTIFY_CHANGE_EA,
                        (BOOLEAN)FALSE
                        );

#else
            FindNextChangeNotification(notifyfd);
#endif
        }
#endif        
    } else {
        FsLog(("FsReserve failed nid %d err %x\n", nid, err));
    }

    *rlen = 0;
    return err;
}

NTSTATUS
FspGetRoot(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid,
           PVOID args, ULONG sz, PVOID rbuf, ULONG_PTR *rlen)
{
    LPWSTR vname = FS_GET_VOL_NAME(vinfo, nid);

    // I know rbuf is 8192 WCHARS, see FileNameDest field of JobBuf_t structure. 
    // Use MAX_PATH.
    StringCchPrintfW(rbuf, MAX_PATH, L"\\\\?\\%s\\%s",vname,vinfo->Root);

    FsLog(("FspGetRoot '%S'\n", rbuf));

    return STATUS_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////////////

VOID
TryAvailRequest(fs_handler_t callback, VolInfo_t *vol, UserInfo_t *uinfo,
            PVOID msg, ULONG len, PVOID *rbuf, ULONG rsz, IO_STATUS_BLOCK *ios)
/*
    This is similar to SendAvailRequest(), but on failure this would just evict the shares.
*/
{
    ULONG mask; 
    int i;
    DWORD counts=0, countf=0;
    ULONG masks=0, maskf=0;
    ULONG rets=0, retf=0, ret=0;
    ULONG evict_set=0;    
    NTSTATUS statusf;

    // Grab Shared Lock
    RwLockShared(&vol->Lock);
    for (mask = vol->ReadSet, i = 0; mask != 0; mask = mask >> 1, i++) {
        if (mask & 0x1) {
            ios[i].Information = rsz;
            ios[i].Status = callback(vol, uinfo, i, 
                                     msg, len,
                                     rbuf ? rbuf[i] : NULL,
                                     &ios[i].Information);
            if (ios[i].Status == STATUS_SUCCESS) {
                counts++;
                masks |= (1<<i);
                rets = i;
            }
            else if (IsNetworkFailure(ios[i].Status)) {
                evict_set |= (1<<i);
            }
            else {
                countf++;
                maskf |= (1<<i);
                statusf = ios[i].Status;
                retf = i;
            }
        }
    }

    evict_set |= maskf;

    if (evict_set) {
        RwUnlockShared(&vol->Lock);
        RwLockExclusive(&vol->Lock);
        FspEvict(vol, evict_set, TRUE);
        RwUnlockExclusive(&vol->Lock);
    }
    else {
        RwUnlockShared(&vol->Lock);
    }
    return;

}

int
SendAvailRequest(fs_handler_t callback, VolInfo_t *vol, UserInfo_t *uinfo,
            PVOID msg, ULONG len, PVOID *rbuf, ULONG rsz, IO_STATUS_BLOCK *ios)
{
    ULONG mask; 
    int i;
    DWORD counts=0, countf=0;
    ULONG masks=0, maskf=0;
    ULONG rets=0, retf=0, ret=0;
    ULONG evict_set=0;    
    NTSTATUS statusf;

    if (vol == NULL)
        return ERROR_INVALID_HANDLE;

Retry:

    mask = counts = countf = masks = maskf = rets = retf = ret = evict_set = 0;    

    WaitForArbCompletion(vol);
    
    // Check for the going away flag.
    if (vol->GoingAway) {
        ios[0].Status = STATUS_DEVICE_NOT_READY;
        ios[0].Information = 0;
        return 0;
    }

    // Grab Shared Lock
    RwLockShared(&vol->Lock);

    // issue update for each replica
    i = 0;
    for (mask = vol->ReadSet; mask != 0; mask = mask >> 1, i++) {
        if (mask & 0x1) {
            ios[i].Information = rsz;
            ios[i].Status = callback(vol, uinfo, i, 
                                     msg, len,
                                     rbuf ? rbuf[i] : NULL,
                                     &ios[i].Information);
            if (ios[i].Status == STATUS_SUCCESS) {
                counts++;
                masks |= (1<<i);
                rets = i;
            }
            else if (IsNetworkFailure(ios[i].Status)) {
                evict_set |= (1<<i);
            }
            else {
                countf++;
                maskf |= (1<<i);
                statusf = ios[i].Status;
                retf = i;
            }
        }
    }

    // Logic:
    // 1. Shares in the evict set have to be evicted.
    // 2. If countf > counts, evict masks, and viceversa.
    //
    // New logic:
    // 1. counts or countf have to be majority.
    // 2. If 1 is correct evict shares in minority.
    // 3. If 1 is wrong. evict shares in evict_set and start arbitration.
    //

    if (CRS_QUORUM(counts, vol->DiskListSz)) {
        evict_set |= maskf;
        ios[0].Status = STATUS_SUCCESS;
        ios[0].Information = counts;
        ret = rets;        
    } else if (CRS_QUORUM(countf, vol->DiskListSz)) {
        evict_set |= masks;
        ios[0].Status = statusf;
        ios[0].Information = countf;
        ret = retf;        
    } else {
        HANDLE  cleanup, arbThread;
        PVOID   arb;
        
        // evict the shares in the evict set and restart arbitration.
        RwUnlockShared(&vol->Lock);
        RwLockExclusive(&vol->Lock);
        FspEvict(vol, evict_set, TRUE);
        RwUnlockExclusive(&vol->Lock);

        arb = FsArbitrate(vol, &cleanup, &arbThread);
        // FsLog(("SendAvailRequest() starting arbitration %x\n", arb));
        ASSERT((arb != NULL));
        SetEvent(cleanup);
        CloseHandle(arbThread);
        goto Retry;
    }

    // FsLog(("SendAvailRequest() exititng evict_set %x\n", evict_set));
    if (evict_set) {
        RwUnlockShared(&vol->Lock);
        RwLockExclusive(&vol->Lock);
        FspEvict(vol, evict_set, TRUE);
        RwUnlockExclusive(&vol->Lock);
    }
    else {
        RwUnlockShared(&vol->Lock);
    }
    return ret;    
}

int
SendRequest(fs_handler1_t callback, UserInfo_t *uinfo,
            PVOID msg, ULONG len, PVOID *rbuf, ULONG rsz, IO_STATUS_BLOCK *ios)
{
    ULONG mask;
    int i, j;
    VolInfo_t *vol = uinfo->VolInfo;
    DWORD counts=0, countf=0;
    ULONG masks=0, maskf=0;
    ULONG rets=0, retf=0, ret=0;    
    ULONG evict_set=0;    
    NTSTATUS statusf;
    CrsRecord_t crsRec, crsRec1;

    if (vol == NULL)
        return ERROR_INVALID_HANDLE;

    RtlZeroMemory(&crsRec, sizeof(crsRec));

Retry:

    WaitForArbCompletion(vol);

    // Check for the going away flag.
    if (vol->GoingAway) {
        ios[0].Status = STATUS_DEVICE_NOT_READY;
        ios[0].Information = 0;
        return 0;
    }
    
    // lock volume for update
    RwLockShared(&vol->Lock);
    
    if(FsIsOnlineReadWrite((PVOID)vol) != ERROR_SUCCESS) {
        HANDLE  cleanup, arbThread;
        PVOID   arb;
        
        // Start arbitration.
        RwUnlockShared(&vol->Lock);
        arb = FsArbitrate(vol, &cleanup, &arbThread);
        ASSERT((arb != NULL));
        SetEvent(cleanup);
        CloseHandle(arbThread);
        goto Retry;
    }

    // Since we are in a retry loop verify that our last attempt at update failed before
    // proceeding.
    //
    // Try to access the crs log record, and check the state field.
    //
    if (crsRec.hdr.epoch) {
        for (i=0;i<FsMaxNodes;i++) {
            if (vol->WriteSet & (1<<i)) {
                DWORD   retVal;
                retVal = CrspNextLogRecord(vol->CrsHdl[i], &crsRec, &crsRec1, TRUE);

                if ((retVal != ERROR_SUCCESS)||(!(crsRec1.hdr.state & CRS_COMMIT))) {
                    // The previous update did not suceed.
                    // zero crsRec and continue.
                    RtlZeroMemory(&crsRec, sizeof(crsRec));
                    break;
                }
                else {
                    // The last update did suceed.
                    // Return replica index on which it suceeded last time and which is also in
                    // the current write set.
                    //
                    for (j=0;j<FsMaxNodes;j++) {
                        if ((masks & vol->WriteSet) & (1<<j)) {
                            RwUnlockShared(&vol->Lock);
                            return j;
                        }
                    }
                    RwUnlockShared(&vol->Lock);
                    return i;
                }
            }
        }
    }

    mask = counts = countf = masks = maskf = rets = retf = ret = evict_set = 0;

    // issue update for each replica
    i = 0;
    for (mask = vol->WriteSet; mask != 0; mask = mask >> 1, i++) {
        if (mask & 0x1) {
            ios[i].Information = rsz;
            ios[i].Status = callback(vol, uinfo, i, 
                                     msg, len,
                                     rbuf ? rbuf[i] : NULL,
                                     &ios[i].Information, (PVOID)&crsRec);

            if (ios[i].Status == STATUS_SUCCESS) {
                counts++;
                masks |= (1<<i);
                rets = i;
            }
            else if (IsNetworkFailure(ios[i].Status)) {
                evict_set |= (1<<i);
            }
            else {
                countf++;
                maskf |= (1<<i);
                statusf = ios[i].Status;
                retf = i;
            }
        }
    }

    // Logic:
    // 1. Shares in the evict set have to be evicted.
    // 2. If countf > counts. evict masks and viceversa.
    //
    // New logic:
    // 1. counts or countf have to be majority.
    // 2. If 1 is correct evict shares in minority.
    // 3. If 1 is wrong. evict shares in evict_set and start arbitration.
    //
    if (CRS_QUORUM(counts, vol->DiskListSz)) {
        evict_set |= maskf;
        ios[0].Status = STATUS_SUCCESS;
        ios[0].Information = counts;
        ret = rets;        
    } else if (CRS_QUORUM(countf, vol->DiskListSz)) {
        evict_set |= masks;
        ios[0].Status = statusf;
        ios[0].Information = countf;
        ret = retf;        
    } else {
        HANDLE  cleanup, arbThread;
        PVOID   arb;
        
        // evict the shares in the evict set and restart arbitration.
        RwUnlockShared(&vol->Lock);
        RwLockExclusive(&vol->Lock);
        FspEvict(vol, evict_set, TRUE);
        RwUnlockExclusive(&vol->Lock);

        arb = FsArbitrate(vol, &cleanup, &arbThread);
        ASSERT((arb != NULL));
        SetEvent(cleanup);
        CloseHandle(arbThread);
        goto Retry;
    }

    // evict the shares in the evict set.
    if (evict_set) {
        RwUnlockShared(&vol->Lock);
        RwLockExclusive(&vol->Lock);
        FspEvict(vol, evict_set, TRUE);
        RwUnlockExclusive(&vol->Lock);
    }
    else {
        RwUnlockShared(&vol->Lock);
    }
    return ret;    
}

NTSTATUS
SendReadRequest(fs_handler_t callback, UserInfo_t *uinfo,
            PVOID msg, ULONG len, PVOID rbuf, ULONG rsz, IO_STATUS_BLOCK *ios)
{
    ULONG mask;
    int i;
    VolInfo_t *vol = uinfo->VolInfo;
    DWORD counts=0, countf=0;
    ULONG masks=0, maskf=0;
    ULONG evict_set=0;    
    NTSTATUS statusf;
    

    if (vol == NULL)
        return ERROR_INVALID_HANDLE;

Retry:

    mask = counts = countf = masks = maskf = evict_set = 0;

    WaitForArbCompletion(vol);

    // Check for the going away flag.
    if (vol->GoingAway) {
        ios[0].Status = STATUS_DEVICE_NOT_READY;
        ios[0].Information = 0;
        return 0;
    }
    
    // Lock volume for update
    RwLockShared(&vol->Lock);

#if 0
    // Volume has to be online in readonly mode atleast for this to suceed.
    if (FsIsOnlineReadonly((PVOID)vol) != ERROR_SUCCESS) {
        ios[0].Status = STATUS_DEVICE_NOT_READY;
        ios[0].Information = 0;
        RwUnlockShared(&vol->Lock);
        return 0;
    }
#endif    

    // issue update for each replica
    i = 0;
    for (mask = vol->ReadSet; mask != 0; mask = mask >> 1, i++) {
        if (mask & 0x1) {
            ios->Information = rsz;
            ios->Status = callback(vol, uinfo, i, 
                                   msg, len, rbuf, &ios->Information);

            if (ios->Status == STATUS_SUCCESS) {
                counts++;
                masks |= (1<<i);
                break;
            }
            else if (IsNetworkFailure(ios->Status)) {
                evict_set |= (1<<i);
            }
            else {
                countf++;
                maskf |= (1<<i);
                statusf = ios->Status;
            }
        }
    }

    // Logic:
    // 1. Evict evict_set.
    // 2. if counts > 0. Evict maskf.
    //
    // New Logic:
    // 1. If couns > 0 add maskf to evict_set.
    // 2. 

    if (counts > 0) {
        evict_set |= maskf;

        //ios[0].Status = STATUS_SUCCESS;
        //ios[0].Information = 0;
    }
    else if (countf > 0) {
        // ios->Status = statusf;
        // ios->Information = countf;
    }
    else {
        HANDLE  cleanup, arbThread;
        PVOID   arb;
        
        // evict the shares in the evict set and restart arbitration.
        RwUnlockShared(&vol->Lock);
        RwLockExclusive(&vol->Lock);
        FspEvict(vol, evict_set, TRUE);
        RwUnlockExclusive(&vol->Lock);

        arb = FsArbitrate(vol, &cleanup, &arbThread);
        ASSERT((arb != NULL));
        SetEvent(cleanup);
        CloseHandle(arbThread);
        goto Retry;
    }
    
    if (evict_set) {
        RwUnlockShared(&vol->Lock);
        RwLockExclusive(&vol->Lock);
        FspEvict(vol, evict_set, TRUE);
        RwUnlockExclusive(&vol->Lock);
    }
    else {
        RwUnlockShared(&vol->Lock);
    }
    return 0;    
}

///////////////////////////////////////////////////////////////////////////////

DWORD
FsCreate(
    PVOID       fshdl,
    LPWSTR      name,
    USHORT namelen,
    UINT32 flags, 
    fattr_t* fattr, 
    fhandle_t* phandle,
    UINT32   *action
    )
{
    UserInfo_t  *uinfo = (UserInfo_t *) fshdl;
    NTSTATUS err=STATUS_SUCCESS;
    fs_create_reply_t nfd[FsMaxNodes];
    IO_STATUS_BLOCK status[FsMaxNodes];
    PVOID rbuf[FsMaxNodes];
    fs_create_msg_t msg;
    fhandle_t fdnum=INVALID_FHANDLE_T;

    ASSERT(uinfo != NULL);

    xFsLog(("FsDT::create(%S, 0x%08X, 0x%08X, 0x%08d)\n",
                 name, flags, fattr, namelen));

    if (!phandle) return ERROR_INVALID_PARAMETER;
    *phandle = INVALID_FHANDLE_T;

    if (!name) return ERROR_INVALID_PARAMETER;

    if (flags != (FLAGS_MASK & flags)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (action != NULL)
        *action = flags & FS_ACCESS_MASK;

    // if we are doing a directory, open locally
    // todo: this should be merged with other case, if
    // we are doing an existing open, then no need to
    // issue update and log it, but we have to do
    // mcast in order for the close to work.

    if (namelen > 0) {
        if (*name == L'\\') {
            name++;
            namelen--;
        }

        if (name[namelen-1] == L'\\') {
            namelen--;
            name[namelen] = L'\0';
        }
    }

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.name = name;
    msg.name_len = namelen;
    msg.flags = flags;
    msg.attr = 0;
    if (fattr) {
        msg.attr = unget_attributes(fattr->attributes);
    }

    FspInitAnswers(status, rbuf, (char *) nfd, sizeof(nfd[0]));

    // allocate a new handle
    err = FspAllocatePrivateHandle(uinfo, &fdnum);
    if (err == STATUS_SUCCESS) {
        int sid;

        // Copy the filename to the table entry here. Has to work with retrys.
        // Copy the file name.
        uinfo->Table[fdnum].FileName = LocalAlloc(0, (namelen +1) * sizeof(WCHAR));
        if (uinfo->Table[fdnum].FileName == NULL) {
            err = GetLastError();
            goto Finally;
        }
        
        if ((err = StringCchCopyW(uinfo->Table[fdnum].FileName, namelen+1, name)) != S_OK) {
            LocalFree(uinfo->Table[fdnum].FileName);
            uinfo->Table[fdnum].FileName = NULL;
            goto Finally;
        }
        
        msg.fnum = fdnum;
        // Set flags in advance to sync with replay
        uinfo->Table[fdnum].Flags = flags;

        if (namelen < 2 ||
            ((flags & FS_DISP_MASK) == DISP_DIRECTORY) ||
            (unget_disp(flags) == FILE_OPEN)) {
    
            sid = SendAvailRequest(FspOpen, uinfo->VolInfo,
                              uinfo,
                              (PVOID) &msg, sizeof(msg),
                              rbuf, sizeof(nfd[0]),
                              status);
        } else {
            sid = SendRequest(FspCreate,
                              uinfo,
                              (PVOID) &msg, sizeof(msg),
                              rbuf, sizeof(nfd[0]),
                              status);
        }
        // Test
        // FsLog(("FsCreate: Debug sid: %d flags: 0x%x action: 0x%x\n", sid, flags, nfd[sid].action));
        if (action != NULL) {
            if (!(nfd[sid].access & FILE_GENERIC_WRITE))
                flags &= ~ACCESS_WRITE;
            *action = flags | nfd[sid].action;
        }

        err = status[sid].Status;
        if (err == STATUS_SUCCESS) {
            fs_id_t *fid = FS_GET_FID_HANDLE(uinfo, fdnum);

            // set file id
            memcpy((PVOID) fid, (PVOID) nfd[sid].fid, sizeof(fs_id_t));
            FsLog(("File id %I64x:%I64x\n", (*fid)[0], (*fid)[1]));
            uinfo->Table[fdnum].hState = HandleStateOpened;
            
            // todo: bind handles to completion port if we do async
        } else {
            // free handle
            FspFreeHandle(uinfo, fdnum);
            fdnum = INVALID_FHANDLE_T;
        }
   }

Finally:
    // todo: need to set fid 

    if (err == STATUS_SUCCESS) {
        *phandle = fdnum;
    }
    else {
        if (fdnum != INVALID_FHANDLE_T) {
            FspFreeHandle(uinfo, fdnum);
        }
    }

    FsLog(("create: return fd %d err %x action 0x%x\n", *phandle, err, action? *action:0));

    return RtlNtStatusToDosError(err);
}

void
BuildFileAttr(FILE_BASIC_INFORMATION *attr, fattr_t *fattr)
{

    memset(attr, 0, sizeof(*attr));
    if (fattr->create_time != INVALID_UINT64)
        attr->CreationTime.QuadPart = fattr->create_time;

    if (fattr->mod_time != INVALID_UINT64)
        attr->LastWriteTime.QuadPart = fattr->mod_time;

    if (fattr->access_time != INVALID_UINT64)
        attr->LastAccessTime.QuadPart = fattr->access_time;

    if (fattr->attributes != INVALID_UINT32)
        attr->FileAttributes = unget_attributes(fattr->attributes);

}


DWORD
FsSetAttr(
    PVOID       fshdl,
    fhandle_t handle,
    fattr_t* attr
    )
{
    UserInfo_t *uinfo = (UserInfo_t *)fshdl;
    fs_setattr_msg_t msg;
    int sid;
    IO_STATUS_BLOCK status[FsMaxNodes];

    if (!attr || handle == INVALID_FHANDLE_T)
        return ERROR_INVALID_PARAMETER;

    // todo: get file id
    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.fs_id = FS_GET_FID_HANDLE(uinfo, handle);
    BuildFileAttr(&msg.attr, attr);
    msg.fnum = handle;

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspSetAttr, uinfo,
                      (char *)&msg, sizeof(msg),
                      NULL, 0,
                      status);

    return RtlNtStatusToDosError(status[sid].Status);
}

DWORD
FsSetAttr2(
    PVOID       fshdl,
    LPWSTR      name,
    USHORT      name_len,
    fattr_t* attr
    )
{
    UserInfo_t *uinfo = (UserInfo_t *) fshdl;
    fs_setattr_msg_t msg;
    int sid;
    IO_STATUS_BLOCK status[FsMaxNodes];

    if (!attr || !name)
        return ERROR_INVALID_PARAMETER;

    if (*name == '\\') {
        name++;
        name_len--;
    }

    // todo: locate file id

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.name = name;
    msg.name_len = name_len;

    BuildFileAttr(&msg.attr, attr);

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspSetAttr2, uinfo,
                      (char *)&msg, sizeof(msg),
                      NULL, 0,
                      status);

    return RtlNtStatusToDosError(status[sid].Status);
}

DWORD
FsLookup(
    PVOID       fshdl,
    LPWSTR      name,
    USHORT      name_len,
    fattr_t* fattr
    )
{
    fs_lookup_msg_t msg;
    int err;
    IO_STATUS_BLOCK ios;
    FILE_NETWORK_OPEN_INFORMATION attr;
    

    FsLog(("Lookup name '%S' %x\n", name, fattr));

    if (!fattr) return ERROR_INVALID_PARAMETER;

    if (*name == '\\') {
        name++;
        name_len--;
    }

    msg.name = name;
    msg.name_len = name_len;

    err = SendReadRequest(FspLookup, (UserInfo_t *)fshdl,
                          (PVOID) &msg, sizeof(msg),
                          (PVOID) &attr, sizeof(attr),
                          &ios);

    err = ios.Status;
    if (ios.Status == STATUS_SUCCESS) {
        fattr->file_size = attr.EndOfFile.QuadPart;
        fattr->alloc_size = attr.AllocationSize.QuadPart;
        fattr->create_time = *(TIME64 *)&attr.CreationTime;
        fattr->access_time = *(TIME64 *)&attr.LastAccessTime;
        fattr->mod_time = *(TIME64 *)&attr.LastWriteTime;
        fattr->attributes = get_attributes(attr.FileAttributes);
    }


    FsLog(("Lookup: return %x\n", err));

    return RtlNtStatusToDosError(err);
}

DWORD
FsGetAttr(
    PVOID       fshdl,
    fhandle_t handle, 
    fattr_t* fattr
    )
{
    int err;
    IO_STATUS_BLOCK ios;
    FILE_NETWORK_OPEN_INFORMATION attr;

    xFsLog(("Getattr fid '%d' %x\n", handle, fattr));

    if (!fattr) return ERROR_INVALID_PARAMETER;

    err = SendReadRequest(FspGetAttr, (UserInfo_t *)fshdl,
                          (PVOID) &handle, sizeof(handle),
                          (PVOID) &attr, sizeof(attr),
                          &ios);

    err = ios.Status;
    if (err == STATUS_SUCCESS) {
        fattr->file_size = attr.EndOfFile.QuadPart;
        fattr->alloc_size = attr.AllocationSize.QuadPart;
        fattr->create_time = *(TIME64 *)&attr.CreationTime;
        fattr->access_time = *(TIME64 *)&attr.LastAccessTime;
        fattr->mod_time = *(TIME64 *)&attr.LastWriteTime;
        fattr->attributes =attr.FileAttributes;
    }

    FsLog(("Getattr: return %d\n", err));

    return RtlNtStatusToDosError(err);
}


DWORD
FsClose(
    PVOID       fshdl,
    fhandle_t handle
    )
{
    int sid, err;
    IO_STATUS_BLOCK status[FsMaxNodes];
    UserInfo_t *uinfo;

    if (handle == INVALID_FHANDLE_T) return ERROR_INVALID_PARAMETER;
    if (handle >= FsTableSize) return ERROR_INVALID_PARAMETER;


    FsLog(("Close: fid %d\n", handle));

    FspInitAnswers(status, NULL, NULL, 0);

    uinfo = (UserInfo_t *) fshdl;
    sid = SendAvailRequest(FspClose, uinfo->VolInfo, uinfo,
                      (PVOID) &handle, sizeof(handle),
                      NULL, 0,
                      status);

    err = status[sid].Status;
    if (err == STATUS_SUCCESS) {
        // need to free this handle slot
        FspFreeHandle((UserInfo_t *) fshdl, handle);
    }

    FsLog(("Close: fid %d err %x\n", handle, err));

    return RtlNtStatusToDosError(err);
}

DWORD
FsWrite(
    PVOID       fshdl,
    fhandle_t handle, 
    UINT32 offset, 
    UINT16 *pcount, 
    void* buffer,
    PVOID context
    )
{
    DWORD       err;
    IO_STATUS_BLOCK status[FsMaxNodes];
    int i, sid;
    fs_io_msg_t msg;
    UserInfo_t *uinfo = (UserInfo_t *) fshdl;
    
    if (!pcount || handle == INVALID_FHANDLE_T) return ERROR_INVALID_PARAMETER;

    FsLog(("Write %d offset %d count %d\n", handle, offset, *pcount));

    i = (int) offset;
    if (i < 0) {
        offset = 0;
        (*pcount)--;
    }

    // todo: locate file id

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.fs_id = FS_GET_FID_HANDLE(uinfo, handle);
    msg.offset = offset;
    msg.size = (UINT32) *pcount;
    msg.buf = buffer;
    msg.context = context;
    msg.fnum = handle;

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspWrite, (UserInfo_t *)fshdl,
                      (PVOID) &msg, sizeof(msg),
                      NULL, 0,
                      status);


    err = status[sid].Status;
    *pcount = (USHORT) status[sid].Information;

    FsLog(("write: return %x\n", err));

    return RtlNtStatusToDosError(err);
}

DWORD
FsRead(
    PVOID       fshdl,
    fhandle_t handle, 
    UINT32 offset, 
    UINT16* pcount, 
    void* buffer,
    PVOID context
    )
{
    NTSTATUS    err;
    IO_STATUS_BLOCK ios;
    fs_io_msg_t msg;
    
    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.offset = offset;
    msg.buf = buffer;
    msg.size = (UINT32) *pcount;
    msg.context = context;
    msg.fnum = handle;

    FsLog(("read: %x fd %d sz %d\n", context, handle, msg.size));

    err = SendReadRequest(FspRead, (UserInfo_t *)fshdl,
                          (PVOID) &msg, sizeof(msg),
                          NULL, 0,
                          &ios);

    err = ios.Status;
    if (err == STATUS_END_OF_FILE) {
        *pcount = 0;
        return ERROR_SUCCESS;
    }
        
    err = RtlNtStatusToDosError(err);

    *pcount = (USHORT) ios.Information;

    FsLog(("read: %x return %x sz %d\n", context, err, *pcount));

    return err;
#if 0
#ifdef FS_ASYNC
    return ERROR_IO_PENDING; //err;
#else
    return ERROR_SUCCESS;
#endif
#endif
}



DWORD
FsReadDir(
    PVOID       fshdl,
    fhandle_t dir, 
    UINT32 cookie, 
    dirinfo_t* buffer,
    UINT32 size, 
    UINT32 *entries_found
    )
{
    fs_io_msg_t msg;
    int err;
    IO_STATUS_BLOCK     ios;


    FsLog(("read_dir: cookie %d buf %x entries %x\n", cookie, buffer, entries_found));
    if (!entries_found || !buffer) return ERROR_INVALID_PARAMETER;

    msg.cookie = cookie;
    msg.buf = (PVOID) buffer;
    msg.size = size;
    msg.fnum = dir;

    err = SendReadRequest(FspReadDir, (UserInfo_t *)fshdl,
                          (PVOID) &msg, sizeof(msg),
                          NULL, 0,
                          &ios);

    err = ios.Status;
    *entries_found = (UINT32) ios.Information;

    xFsLog(("read_dir: err %d entries %d\n", err, *entries_found));
    return RtlNtStatusToDosError(err);
}


DWORD
FsRemove(
    PVOID       fshdl,
    LPWSTR      name,
    USHORT      name_len
    )
{
    fs_remove_msg_t msg;
    int err, sid;
    IO_STATUS_BLOCK status[FsMaxNodes];


    if (*name == L'\\') {
        name++;
        name_len--;
    }

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.name = name;
    msg.name_len = name_len;

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspRemove, (UserInfo_t *) fshdl,
                      (PVOID *)&msg, sizeof(msg),
                      NULL, 0,
                      status);

    err = status[sid].Status;

    return RtlNtStatusToDosError(err);
}

DWORD
FsRename(
    PVOID       fshdl,
    LPWSTR      from_name,
    USHORT      from_name_len,
    LPWSTR      to_name,
    USHORT      to_name_len
    )
{

    int err, sid;
    fs_rename_msg_t msg;
    IO_STATUS_BLOCK status[FsMaxNodes];


    if (!from_name || !to_name) 
        return ERROR_INVALID_PARAMETER;

    if (*from_name == L'\\') {
        from_name++;
        from_name_len--;
    }

    if (*to_name == L'\\') {
        to_name++;
        to_name_len--;
    }
    if (*from_name == L'\0' || *to_name == L'\0') 
        return ERROR_INVALID_PARAMETER;


    FsLog(("rename %S -> %S,%d\n", from_name, to_name,to_name_len));

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.sname = from_name;
    msg.sname_len = from_name_len;
    msg.dname = to_name;
    msg.dname_len = to_name_len;

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspRename, (UserInfo_t *) fshdl,
                      (PVOID) &msg, sizeof(msg),
                      NULL, 0,
                      status);

    err = status[sid].Status;

    return RtlNtStatusToDosError(err);
}


DWORD
FsMkDir(
    PVOID       fshdl,
    LPWSTR      name,
    USHORT      name_len,
    fattr_t* attr
    )
{
    int err, sid;
    IO_STATUS_BLOCK status[FsMaxNodes];
    fs_id_t     ids[FsMaxNodes];
    PVOID       *rbuf[FsMaxNodes];
    fs_create_msg_t msg;

    // XXX: we ignore attr for now...
    if (!name) return ERROR_INVALID_PARAMETER;
    if (*name == L'\\') {
        name++;
        name_len--;
    }

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.attr = (attr != NULL ? unget_attributes(attr->attributes) : 
                FILE_ATTRIBUTE_DIRECTORY);
    msg.flags = DISP_DIRECTORY | SHARE_READ | SHARE_WRITE;
    msg.name = name;
    msg.name_len = name_len;

    FspInitAnswers(status, (PVOID *)rbuf, (PVOID) ids, sizeof(ids[0]));

    sid = SendRequest(FspMkDir, (UserInfo_t *) fshdl,
                      (PVOID) &msg, sizeof(msg),
                      (PVOID *)rbuf, sizeof(ids[0]),
                      status);

    err = status[sid].Status;
    // todo: insert pathname and file id into hash table

    return RtlNtStatusToDosError(err);
}


DWORD
FsFlush(
    PVOID       fshdl,
    fhandle_t handle
    )
{
    NTSTATUS status;
    int sid;
    IO_STATUS_BLOCK ios[FsMaxNodes];

    FspInitAnswers(ios, NULL, NULL, 0);

    sid = SendRequest(FspFlush, (UserInfo_t *) fshdl,
                         (PVOID) &handle, sizeof(handle),
                         NULL, 0,
                         ios);
    status = ios[sid].Status;

    FsLog(("Flush %d err %x\n", handle, status));

    if (status == STATUS_PENDING) {
        status = STATUS_SUCCESS;
    }

    return RtlNtStatusToDosError(status);
}

DWORD
FsLock(PVOID fshdl, fhandle_t handle, ULONG offset, ULONG length, ULONG flags,
               PVOID context)
{
    fs_lock_msg_t msg;
    int err, sid;
    IO_STATUS_BLOCK status[FsMaxNodes];

    if (handle == INVALID_FHANDLE_T)
        return ERROR_INVALID_PARAMETER;

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.offset = offset;
    msg.length = length;
    msg.flags = flags;
    msg.fnum = handle;

    FsLog(("Lock fid %d off %d len %d\n", msg.fnum, offset, length));

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspLock, (UserInfo_t *) fshdl,
                      (PVOID)&msg, sizeof(msg),
                      NULL, 0,
                      status);

    err = status[sid].Status;

    FsLog(("Lock fid %d err %x\n", msg.fnum, err));

    return RtlNtStatusToDosError(err);
}

DWORD
FsUnlock(PVOID fshdl, fhandle_t handle, ULONG offset, ULONG length)
{
    fs_lock_msg_t msg;
    int err, sid;
    IO_STATUS_BLOCK status[FsMaxNodes];

    if (handle == INVALID_FHANDLE_T)
        return ERROR_INVALID_PARAMETER;

    memset(&msg.xid, 0, sizeof(msg.xid));
    msg.offset = offset;
    msg.length = length;
    msg.fnum = handle;

    FsLog(("Unlock fid %d off %d len %d\n", handle, offset, length));

    FspInitAnswers(status, NULL, NULL, 0);

    sid = SendRequest(FspUnlock, (UserInfo_t *) fshdl,
                      (PVOID)&msg, sizeof(msg),
                      NULL, 0,
                      status);

    err = status[sid].Status;

    return RtlNtStatusToDosError(err);
}

DWORD
FsStatFs(
    PVOID       fshdl,
    fs_attr_t* attr
    )
{
    DWORD err;
    IO_STATUS_BLOCK ios;

    if (!attr) return ERROR_INVALID_PARAMETER;

    err = SendReadRequest(FspStatFs, (UserInfo_t *) fshdl,
                          (PVOID) attr, sizeof(*attr),
                          NULL, 0,
                          &ios);

    err = ios.Status;

    return RtlNtStatusToDosError(err);
}


DWORD
FsGetRoot(PVOID fshdl, LPWSTR fullpath)
{
    DWORD err;
    IO_STATUS_BLOCK ios;

    if (!fullpath || !fshdl) return ERROR_INVALID_PARAMETER;

    // use local replica instead
    if ((((UserInfo_t *)fshdl)->VolInfo->LocalPath)) {
        StringCchPrintfW(fullpath, MAX_PATH, L"\\\\?\\%s\\%s",
                 (((UserInfo_t *)fshdl)->VolInfo->LocalPath),
                 (((UserInfo_t *)fshdl)->VolInfo->Root));
             
        FsLog(("FspGetRoot '%S'\n", fullpath));
        err = STATUS_SUCCESS;
    } else {
        err = SendReadRequest(FspGetRoot, (UserInfo_t *) fshdl,
                              NULL, 0,
                              (PVOID)fullpath, 0,
                              &ios);
        err = ios.Status;
    }
    return RtlNtStatusToDosError(err);
}

UINT32* FsGetFilePointerFromHandle(
    PVOID *fshdl,
    fhandle_t handle
)
{
    UserInfo_t* u = (UserInfo_t *) fshdl;
    return FS_GET_USER_HANDLE_OFFSET(u, handle);
}

DWORD
FsConnect(PVOID resHdl, DWORD pid)
{
    UserInfo_t  *u=(UserInfo_t *)resHdl;
    VolInfo_t   *vol=u->VolInfo;
    HANDLE      pHdl=NULL;
    HANDLE      regHdl=NULL;
    DWORD       status=ERROR_SUCCESS;
    
    FsLog(("FsConnect: pid %d\n", pid));

    // Get exclusive lock.
    RwLockExclusive(&vol->Lock);
    if((pHdl = OpenProcess(PROCESS_ALL_ACCESS,
                    FALSE,
                    pid)) == NULL) {
        status = GetLastError();
        FsLogError(("FsConnect: OpenProcess(%d) returns, %d\n", pid, status));
        goto error_exit;
    }

    if (!RegisterWaitForSingleObject(&regHdl,
            pHdl,
            FsForceClose,
            (PVOID)vol,
            INFINITE,
            WT_EXECUTEONLYONCE|WT_EXECUTEDEFAULT)) {
            status = GetLastError();
            regHdl = NULL;
            FsLogError(("FsConnect: RegisterWaitForSingleObject() returns, %d\n", status));
            goto error_exit;
    }

error_exit:

    if (status == ERROR_SUCCESS) {
        // Paranoid Check.
        if (vol->ClussvcTerminationHandle != INVALID_HANDLE_VALUE) {
            UnregisterWaitEx(vol->ClussvcTerminationHandle, INVALID_HANDLE_VALUE);
        }
        if (vol->ClussvcProcess != INVALID_HANDLE_VALUE) {
            CloseHandle(vol->ClussvcProcess);
        }
        
        vol->ClussvcProcess = pHdl;
        vol->ClussvcTerminationHandle = regHdl;
    }
    else {
        if (regHdl != NULL) {
            UnregisterWaitEx(regHdl, INVALID_HANDLE_VALUE);
        }
        if (pHdl != NULL) {
            CloseHandle(pHdl);
        }
    }
    RwUnlockExclusive(&vol->Lock);
    return status;
}

static FsDispatchTable gDisp = {
    0x100,
    FsCreate,
    FsLookup,
    FsSetAttr,
    FsSetAttr2,
    FsGetAttr,
    FsClose,
    FsWrite,
    FsRead,
    FsReadDir,
    FsStatFs,
    FsRemove,
    FsRename,
    FsMkDir,
    FsRemove,
    FsFlush,
    FsLock,
    FsUnlock,
    FsGetRoot,
    FsConnect
};
//////////////////////////////////////////////////////////////

DWORD
FsInit(PVOID resHdl, PVOID *Hdl)
{
    DWORD status=ERROR_SUCCESS;
    FsCtx_t     *ctx;

    // This should be a compile check instead of runtime check
    ASSERT(sizeof(fs_log_rec_t) == CRS_RECORD_SZ);
    ASSERT(sizeof(fs_log_rec_t) == sizeof(CrsRecord_t));

    if (Hdl == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    FsLog(("FsInit:\n"));

    // allocate a context
    ctx = (FsCtx_t *) MemAlloc(sizeof(*ctx));
    if (ctx == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // initialize configuration table and other global state
    memset(ctx, 0, sizeof(*ctx));

    // local path
    // Not needed.
    // ctx->Root = NULL;

    LockInit(ctx->Lock);

    ctx->reshdl = resHdl;
    *Hdl = (PVOID) ctx;

    return status;
}

void
FspFreeSession(SessionInfo_t *s)
{
        
    UserInfo_t *u;
    int i, j;

    u = &s->TreeCtx;
    FsLog(("Session free uid %d tid %d ref %d\n", u->Uid, u->Tid, u->RefCnt));

    LockEnter(u->Lock);
    if (u->VolInfo != NULL) {
        UserInfo_t **p;
        VolInfo_t *v = u->VolInfo;

        LockExit(u->Lock);

        // remove from vollist now
        RwLockExclusive(&v->Lock);
        p = &v->UserList;
        while (*p != NULL) {
            if (*p == u) {
                // found it
                *p = u->Next;
                FsLog(("Remove uinfo %x,%x from vol %x %S\n", u, u->Next, 
                       v->UserList, v->Root));
                break;
            }
            p = &(*p)->Next;
        }
        RwUnlockExclusive(&v->Lock);

        // relock again
        LockEnter(u->Lock);
    }

    // Close all user handles
    for (i = 0; i < FsTableSize; i++) {
        if (u->Table[i].Flags) {
            FsLog(("Close slot %d %x\n", i, u->Table[i].Flags));
            // Cannot call FsClose(), GoingAway Flag might be already set.
            // Close the handles individually.
            // FsClose((PVOID) u, (fhandle_t)i);
            FspFreeHandle(u, (fhandle_t)i);
        }
    }

    // sap volptr
    u->VolInfo = NULL;

    LockExit(u->Lock);

    DeleteCriticalSection(&u->Lock);

    // free memory now, don't free u since it's part of s
    MemFree(s);
}

void
FspCloseVolume(VolInfo_t *vol, ULONG AliveSet)
{
    DWORD   i;
    HANDLE  regHdl;

    // Close crs and root handles, by evicting our alive set
    //  close nid handles <crs, vol, open files>
    for (i = 0; i < FsMaxNodes; i++) {
        if (AliveSet & (1 << i)) {
            vol->ShareState[i] = SHARE_STATE_OFFLINE;
            if (vol->CrsHdl[i]) {
                CrsClose(vol->CrsHdl[i]);
                vol->CrsHdl[i] = NULL;
            }

            LockEnter(vol->ArbLock);
            regHdl = vol->WaitRegHdl[i];
            vol->WaitRegHdl[i] = INVALID_HANDLE_VALUE;
            LockExit(vol->ArbLock);
            if (regHdl != INVALID_HANDLE_VALUE) {
                UnregisterWaitEx(regHdl, INVALID_HANDLE_VALUE);
            }
            
            if (vol->NotifyFd[i] != INVALID_HANDLE_VALUE) {
                FindCloseChangeNotification(vol->NotifyFd[i]);
                vol->NotifyFd[i] = INVALID_HANDLE_VALUE;
            }

            if (vol->Fd[i] != INVALID_HANDLE_VALUE) {
                xFsClose(vol->Fd[i]);
                vol->Fd[i] = INVALID_HANDLE_VALUE;
            }
            // need to close all user handles now
            {
                UserInfo_t *u;

                for (u = vol->UserList; u; u = u->Next) {
                    DWORD j;
                    FsLog(("Lock user %x root %S\n", u, vol->Root));
                    LockEnter(u->Lock);

                    // close all handles for this node
                    for (j = 0; j < FsTableSize; j++) {
                        if (u->Table[j].Fd[i] != INVALID_HANDLE_VALUE) {
                            FsLog(("Close fid %d\n", j));
                            xFsClose(u->Table[j].Fd[i]);
                            u->Table[j].Fd[i] = INVALID_HANDLE_VALUE;
                        }
                    }
                    LockExit(u->Lock);
                    FsLog(("Unlock user %x\n", u));
                }
            }
            // Close the tree connection handle.
            if (vol->TreeConnHdl[i] != INVALID_HANDLE_VALUE) {
                xFsClose(vol->TreeConnHdl[i]);
                vol->TreeConnHdl[i] = INVALID_HANDLE_VALUE;
            }
        }
    }
}


// call this when we are deleting resource and we need to get ride of
// our IPC reference to directory
void
FsEnd(PVOID Hdl)
{
    FsCtx_t     *ctx = (FsCtx_t *) Hdl;
    VolInfo_t   *p;

#if 0
    if (!ctx)
        return;

    LockEnter(ctx->Lock);
    p = (VolInfo_t *)ctx->ipcHdl;
    if (p) {
        xFsClose(p->Fd[0]);
        p->Fd[0] = INVALID_HANDLE_VALUE;
        p->ReadSet = 0;
        p->AliveSet = 0;
    }

    LockExit(ctx->Lock);
#else
    return;
#endif
    
}

void
FsExit(PVOID Hdl)
{
    // flush all state
    FsCtx_t     *ctx = (FsCtx_t *) Hdl;
    VolInfo_t   *p;
    SessionInfo_t *s;
    LogonInfo_t *log;

    LockEnter(ctx->Lock);

    // There shouldn't be any sessions, volumes or logon info right now. If there is
    // Just remove it and log a warning.
    //
    while (s = ctx->SessionList) {
        FsLogError(("FsExit: Active session at exit, Tid=%d Uid=%d\n", s->TreeCtx.Tid, s->TreeCtx.Uid));
        ctx->SessionList = s->Next;
        // free this session now
        FspFreeSession(s);
    }
    
    while (p = ctx->VolList) {
        ctx->VolList = p->Next;
        ctx->VolListSz--;
        // Unregister this volume. There should not be any here now.
        FsLogError(("FsExit Active volume at exit, Root=%S\n", p->Root));
        RwLockExclusive(&p->Lock);
        FspCloseVolume(p, p->AliveSet);
        RwUnlockExclusive(&p->Lock);
        RwLockDelete(&p->Lock);
        MemFree(p);
    }

    while (log = ctx->LogonList) {
        ctx->LogonList = log->Next;
        FsLogError(("FsExit: Active Logon at exit, Uid=%d\n", log->LogOnId.LowPart));
        // free token
        if (log->Token) {
            CloseHandle(log->Token);
        }
        MemFree(log);
    }

    // now we free our structure
    LockExit(ctx->Lock);
    LockDestroy(ctx->Lock);
    MemFree(ctx);
}

// adds a new share to list of trees available
DWORD
FsRegister(PVOID Hdl, LPWSTR root, LPWSTR local_path,
           LPWSTR disklist[], DWORD len, DWORD ArbTime, PVOID *vHdl)
{
    FsCtx_t     *ctx = (FsCtx_t *) Hdl;
    VolInfo_t   *p;
    NTSTATUS    status=ERROR_SUCCESS;
    UINT32      disp = FILE_OPEN;
    HANDLE      vfd;
    WCHAR       path[MAX_PATH];
    DWORD       ndx;
      

    // check limit
    if (len >= FsMaxNodes) {
        return ERROR_TOO_MANY_NAMES;
    }

    if (root == NULL || local_path == NULL || (wcslen(local_path) > (MAX_PATH - 5))) {
        return ERROR_INVALID_PARAMETER;
    }


    // add a new volume to the list of volume. path is an array
    // of directories. Note: The order of this list MUST be the
    // same in all nodes since it also determines the disk id

    // this is a simple check and assume one thread is calling this function
    LockEnter(ctx->Lock);

    // find the volume share
    for (p = ctx->VolList; p != NULL; p = p->Next) {
        if (!wcscmp(root, p->Root)) {
            FsLog(("FsRegister: %S already registered Tid %d\n", root, p->Tid));
            LockExit(ctx->Lock);
            return ERROR_SUCCESS;
        }
    }

    p = (VolInfo_t *)MemAlloc(sizeof(*p));
    if (p == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(p, 0, sizeof(*p));

    // Open the root of our local share. store it in Fd[0].
    StringCchCopyW(path, MAX_PATH, L"\\??\\");
    StringCchCatW(path, (MAX_PATH - wcslen(path)-1), local_path);
    StringCchCatW(path, (MAX_PATH - wcslen(path)-1), L"\\");
    
    status = xFsCreate(&vfd, NULL, path, wcslen(path),
                       FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT,
                       0,
                       FILE_SHARE_READ|FILE_SHARE_WRITE,
                       &disp,
                       FILE_GENERIC_READ|FILE_GENERIC_WRITE|FILE_GENERIC_EXECUTE,
                       NULL, 0);

    if (status == STATUS_SUCCESS) {
        // our root must have already been created and secured.
        ASSERT(disp != FILE_CREATED);
        p->Fd[0] = vfd;
    } else {
        FsLog(("Fsregister: Failed to open share root %S status=%x\n", path, status));
        LockExit(ctx->Lock);
        MemFree(p);
        return RtlNtStatusToDosError(status);
    }

    RwLockInit(&p->Lock);
    // lock the volume
    RwLockExclusive(&p->Lock);

    p->Tid = (USHORT)++ctx->VolListSz;
    p->Next = ctx->VolList;
    ctx->VolList = p;
    p->FsCtx = ctx;

    LockExit(ctx->Lock);

    p->Label = L"Cluster Quorum";
    p->State = VolumeStateInit;
    p->Root = root;
    p->LocalPath = local_path;
    p->ArbTime = ArbTime;
    if (disklist) {
        for (ndx = 1; ndx < FsMaxNodes; ndx++) {
            p->DiskList[ndx] = disklist[ndx];
        }
    }
    p->DiskListSz = len;
    LockInit(p->ArbLock);
    p->AllArbsCompleteEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    p->NumArbsInProgress = 0;
    p->GoingAway = FALSE;

    // Initialize all handles to INVALID_HANDLE_VALUE.
    for (ndx=0;ndx<FsMaxNodes;ndx++) {
        p->Fd[ndx] = INVALID_HANDLE_VALUE;
        p->NotifyFd[ndx] = INVALID_HANDLE_VALUE;
        p->TreeConnHdl[ndx] = INVALID_HANDLE_VALUE;
        p->WaitRegHdl[ndx] = INVALID_HANDLE_VALUE;
        p->NotifyChangeEvent[ndx] = CreateEventW(NULL, FALSE, FALSE, NULL);
        if (p->NotifyChangeEvent[ndx] == NULL) {
            status = GetLastError();
            break;
        }
    }

    // This handles would be valid only after connect.
    p->ClussvcTerminationHandle = INVALID_HANDLE_VALUE;
    p->ClussvcProcess = INVALID_HANDLE_VALUE;

    FsLog(("FsRegister Tid %d Share '%S' %d disks\n", p->Tid, root, len));

    // drop the volume lock
    RwUnlockExclusive(&p->Lock);

    *vHdl = (PVOID) p;


    if ((status != ERROR_SUCCESS) && p) {
        if (p->AllArbsCompleteEvent) {
            CloseHandle(p->AllArbsCompleteEvent);
        }

        if (p->Fd[0] != INVALID_HANDLE_VALUE) {
            CloseHandle(p->Fd[0]);
        }

        for(ndx=0;ndx<FsMaxNodes;ndx++) {
            if (p->NotifyChangeEvent[ndx] != NULL) {
                CloseHandle(p->NotifyChangeEvent[ndx]);
            }
        }

        RwLockDelete(&p->Lock);
        MemFree(p);
    }
    
    return status;
}

SessionInfo_t *
FspAllocateSession()
{
    SessionInfo_t *s;
    UserInfo_t  *u;
    int i;

    // add user to our tree and initialize handle tables
    s = (SessionInfo_t *)MemAlloc(sizeof(*s));
    if (s != NULL) {
        memset(s, 0, sizeof(*s));

        u = &s->TreeCtx;
        LockInit(u->Lock);

        // init handle table
        for (i = 0; i < FsTableSize; i++) {
            int j;
            for (j = 0; j < FsMaxNodes; j++) {
                u->Table[i].Fd[j] = INVALID_HANDLE_VALUE;
            }
            u->Table[i].hState = HandleStateInit;
        }
    }

    return s;
}

// binds a session to a specific tree/share
DWORD
FsMount(PVOID Hdl, LPWSTR root_name, USHORT uid, USHORT *tid)
{
    FsCtx_t     *ctx = (FsCtx_t *) Hdl;
    SessionInfo_t *s = NULL, *ns;
    VolInfo_t   *p;
    DWORD       err = ERROR_SUCCESS;


    *tid = 0;

    // allocate new ns
    ns = FspAllocateSession();
    if (ns == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LockEnter(ctx->Lock);
    // locate share
    for (p = ctx->VolList; p != NULL; p = p->Next) {
        if (!ClRtlStrICmp(root_name, p->Root)) {
            FsLog(("Mount share '%S' tid %d\n", p->Root, p->Tid));
            break;
        }
    }

    if (p != NULL) {

        *tid = p->Tid;

        for (s = ctx->SessionList; s != NULL; s = s->Next) {
            if (s->TreeCtx.Uid == uid && s->TreeCtx.Tid == p->Tid) {
                break;
            }
        }

        if (s == NULL) {
            UserInfo_t *u = &ns->TreeCtx;

            // insert into session list
            ns->Next = ctx->SessionList;
            ctx->SessionList = ns;
            
            FsLog(("Bind uid %d -> tid %d <%x,%x>\n", uid, p->Tid,
                   u, p->UserList));

            u->RefCnt++;
            u->Uid = uid;
            u->Tid = p->Tid;
            u->VolInfo = p;
            // insert user_info into volume list
            RwLockExclusive(&p->Lock);
            FsLog(("Add <%x,%x>\n",    u, p->UserList));
            u->Next = p->UserList;
            p->UserList = u;
            RwUnlockExclusive(&p->Lock);
        } else {
            // we already have this session opened, increment refcnt
            s->TreeCtx.RefCnt++;
            // free ns
            MemFree(ns);
        }
    } else {
        err = ERROR_BAD_NET_NAME;
    }

    LockExit(ctx->Lock);

    return (err);
}

// This function is also a CloseSession
void
FsDisMount(PVOID Hdl, USHORT uid, USHORT tid)
{
    FsCtx_t     *ctx = (FsCtx_t *) Hdl;
    SessionInfo_t *s, **last;

    // lookup tree and close all user handles
    s = NULL;
    LockEnter(ctx->Lock);

    last = &ctx->SessionList;
    while (*last != NULL) {
        UserInfo_t *u = &(*last)->TreeCtx;
        if (u->Uid == uid && u->Tid == tid) {
            ASSERT(u->RefCnt > 0);
            u->RefCnt--;
            if (u->RefCnt == 0) {
                FsLog(("Dismount uid %d tid %d <%x,%x>\n", uid, tid,
                       u, *last));
                s = *last;
                *last = s->Next;
            }
            break;
        }
        last = &(*last)->Next;
    }
    LockExit(ctx->Lock);
    if (s != NULL) {
        FspFreeSession(s);
    }
}

// todo: I am not using the token for now, but need to use it for all
// io operations
DWORD
FsLogonUser(PVOID Hdl, HANDLE token, LUID logonid, USHORT *uid)
{
    FsCtx_t     *ctx = (FsCtx_t *) Hdl;
    LogonInfo_t *s;
    int i;

    // add user to our tree and initialize handle tables
    s = (LogonInfo_t *)MemAlloc(sizeof(*s));
    if (s == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(s, 0, sizeof(*s));

    s->Token = token;
    s->LogOnId = logonid;

    LockEnter(ctx->Lock);
    s->Next = ctx->LogonList;
    ctx->LogonList = s;
    LockExit(ctx->Lock);

    *uid = (USHORT) logonid.LowPart; 
    FsLog(("Logon %d,%d, uid %d\n", logonid.HighPart, logonid.LowPart, *uid));

    return (ERROR_SUCCESS);

}

void
FsLogoffUser(PVOID Hdl, LUID logonid)
{
    FsCtx_t     *ctx = (FsCtx_t *) Hdl;
    LogonInfo_t *s, **pps;
    USHORT      uid;

    LockEnter(ctx->Lock);
    for (s = ctx->LogonList, pps=&ctx->LogonList; s != NULL; s = s->Next) {
        if (s->LogOnId.LowPart == logonid.LowPart &&
            s->LogOnId.HighPart == logonid.HighPart) {
            uid = (USHORT) logonid.LowPart;

            // Remove the logon info.
            *pps = s->Next;
            break;
        }
        pps = &s->Next;
    }
    
    if (s != NULL) {
        SessionInfo_t   **last;

        FsLog(("Logoff user %d\n", uid));

        // Flush all user trees
        last = &ctx->SessionList;
        while (*last != NULL) {
            UserInfo_t *u = &(*last)->TreeCtx;
            if (u->Uid == uid) {
                SessionInfo_t *ss = *last;
                // remove session and free it now
                *last = ss->Next;
                FspFreeSession(ss);
            } else {
                last = &(*last)->Next;
            }
        }
        MemFree(s);
    }

    LockExit(ctx->Lock);
}



FsDispatchTable* 
FsGetHandle(PVOID Hdl, USHORT tid, USHORT uid, PVOID *fshdl)
{
    FsCtx_t     *ctx = (FsCtx_t *) Hdl;
    SessionInfo_t *s;

    // locate tid,uid in session list
    LockEnter(ctx->Lock);
    for (s = ctx->SessionList; s != NULL; s = s->Next) {
        if (s->TreeCtx.Uid == uid && s->TreeCtx.Tid == tid) {
            *fshdl = (PVOID *) &s->TreeCtx;
            LockExit(ctx->Lock);
            return &gDisp;
        }
    }

    LockExit(ctx->Lock);

    *fshdl = NULL;
    return NULL;
}

//////////////////////////////////// Arb/Release ///////////////////////////////

DWORD
FspOpenReplica(VolInfo_t *p, DWORD id, LPWSTR myAddr, HANDLE *CrsHdl, HANDLE *Fd, HANDLE *notifyFd, HANDLE *WaitRegHdl)
{
    WCHAR       path[MAXPATH];
    UINT32      disp = FILE_OPEN_IF;
    NTSTATUS    err=STATUS_SUCCESS;

    // StringCchPrintfW(path, MAXPATH, L"\\\\?\\%s\\crs.log", p->DiskList[id]);
    // Format: \Device\LanmanRedirector\<ip addr>\shareGuid$\crs.log
    //
    StringCchPrintfW(path, MAXPATH, L"%ws\\%ws\\%ws\\crs.log", MNS_REDIRECTOR, myAddr, p->Root);
    err = CrsOpen(FsCrsCallback, (PVOID) p, (USHORT)id,
                  path, FsCrsNumSectors,
                  CrsHdl);

    if (err == ERROR_SUCCESS && CrsHdl != NULL) {
        // got it
        // open root volume directory
        // StringCchPrintfW(path, MAXPATH, L"\\??\\%s\\%s\\", p->DiskList[id], p->Root);
        // Format: \Device\LanmanRedirector\<ip addr>\shareGuid$\shareGuid$\
        //
        StringCchPrintfW(path, MAXPATH, L"%ws\\%ws\\%ws\\%ws\\", MNS_REDIRECTOR, myAddr, p->Root, p->Root);
        err = xFsCreate(Fd, NULL, path, wcslen(path),
                        FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT,
                        0,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        &disp,
                        FILE_GENERIC_READ|FILE_GENERIC_WRITE|FILE_GENERIC_EXECUTE,
                        NULL, 0);

        if (err == STATUS_SUCCESS) {
            FsArbLog(("Mounted %S\n", path));
            // StringCchPrintfW(path, MAXPATH, L"\\\\?\\%s\\", p->DiskList[id]);
            // Format: \Device\LanmanRedirector\<ip addr>\shareGuid$\
            //
            
            StringCchPrintfW(path, MAXPATH, L"%ws\\%ws\\%ws\\", MNS_REDIRECTOR, myAddr, p->Root);

            // scan the tree to break any current oplocks on dead nodes
            err = xFsTouchTree(*Fd);
            if (!NT_SUCCESS(err)) {
                CrsClose(*CrsHdl);
                xFsClose(*Fd);
                *CrsHdl = NULL;
                *Fd = INVALID_HANDLE_VALUE;
                return err;
            }

#if 1
            // Directly use NT api.
            err = xFsOpenEx(notifyFd, 
                        NULL, 
                        path, 
                        wcslen(path), 
                        (ACCESS_MASK)FILE_LIST_DIRECTORY|SYNCHRONIZE,
                        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                        FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                        );

            if (NT_SUCCESS(err)) {
                err = NtNotifyChangeDirectoryFile(*notifyFd,
                        p->NotifyChangeEvent[id],
                        NULL,
                        NULL,
                        &MystaticIoStatusBlock,
                        &Mystaticchangebuff,
                        sizeof(Mystaticchangebuff),
                        FILE_NOTIFY_CHANGE_EA,
                        (BOOLEAN)FALSE
                        );
                if (!NT_SUCCESS(err)) {
                    FindCloseChangeNotification(*notifyFd);
                    *notifyFd = INVALID_HANDLE_VALUE;
                }
            }
#else
            // we now queue notification changes to force srv to contact client
            *notifyFd = FindFirstChangeNotificationW(path, FALSE, FILE_NOTIFY_CHANGE_EA);
#endif
            FsArbLog(("NtNotifyChangeDirectoryFile(%ws) returns 0x%x FD: %p\n", path, err, *notifyFd));

            // Register wait.
            if (*notifyFd != INVALID_HANDLE_VALUE) {
                p->WaitRegArgs[id].notifyFd = *notifyFd;
                p->WaitRegArgs[id].vol = p;
                p->WaitRegArgs[id].id = id;
                if (!RegisterWaitForSingleObject(WaitRegHdl,
                        p->NotifyChangeEvent[id],
                        FsNotifyCallback,
                        (PVOID)(&p->WaitRegArgs[id]),
                        INFINITE,
                        WT_EXECUTEINWAITTHREAD)) {
                    err = GetLastError();
                    FsArbLog(("RegisterWaitForSingleObject(0x%x) returned %d\n", *notifyFd, err));
                    FindCloseChangeNotification(*notifyFd);
                    *notifyFd = INVALID_HANDLE_VALUE;
                }
            }

            if (*notifyFd != INVALID_HANDLE_VALUE) {
                int i;

                // Since we have a valid file handle, map err to success.
                err = ERROR_SUCCESS;

                // Just register 8 extra notifications. That way if this does not work
                // we would not flood the redirector. 8 since we can have max 8 node
                // cluster in Windows Server 2003.
                //
                for (i = 0; i < 8; i++) {
#if 1
                    NtNotifyChangeDirectoryFile(*notifyFd,
                        p->NotifyChangeEvent[id],
                        NULL,
                        NULL,
                        &MystaticIoStatusBlock,
                        &Mystaticchangebuff,
                        sizeof(Mystaticchangebuff),
                        FILE_NOTIFY_CHANGE_EA,
                        (BOOLEAN)FALSE
                        );

#else
                    FindNextChangeNotification(*notifyFd);
#endif

                }

            } else {
                FsArbLog(("Failed to register notification %d\n", err));
                xFsClose(*Fd);
                CrsClose(*CrsHdl);
                *CrsHdl = NULL;
                *Fd = INVALID_HANDLE_VALUE;
            }
        } else {
            FsArbLog(("Failed to mount root '%S' %x\n", path, err));
            CrsClose(*CrsHdl);
            *CrsHdl = NULL;
        }
    } else if (err == ERROR_LOCK_VIOLATION || err == ERROR_SHARING_VIOLATION) {
        FsArbLog(("Replica '%S' already locked\n", path));
    } else {
        // FsArbLog(("Replica '%S' probe failed 0x%x\n", path, err));
    }
    
    // If we successfully arbitrated for the quorum set the Share State field.
    if (err == ERROR_SUCCESS) {
        p->ShareState[id] = SHARE_STATE_ARBITRATED;
    }
    
    return err;
}

typedef struct {
    FspArbitrate_t   *arb;
    DWORD       id;
}FspProbeReplicaId_t;

typedef struct {
    AddrList_t      *addrList;
    DWORD           addrId;
}FspProbeAddr_t;

DWORD WINAPI
ProbeThread(LPVOID arg)
{
    FspProbeAddr_t  *probe = (FspProbeAddr_t *) arg;
    FspArbitrate_t  *arb = probe->addrList->arb;
    DWORD           i = probe->addrList->NodeId;
    VolInfo_t       *p = arb->vol;
    NTSTATUS        status=STATUS_SUCCESS;
    HANDLE          crshdl, fshdl, notifyhdl, waitRegHdl, treeConnHdl=INVALID_HANDLE_VALUE;
    WCHAR           path[MAX_PATH];
    LPWSTR          myAddr=probe->addrList->Addr[probe->addrId];

    // set our priority
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    FsArbLog(("Probe thread for Replica %d Addr %ws\n", i, myAddr));
    
    while (TRUE) {
        // Open tree connection. This has to be done inside the try loop because
        // it might fail during first attempt.
        if (treeConnHdl == INVALID_HANDLE_VALUE) {
            StringCchPrintfW(path, MAX_PATH, L"%ws\\%ws", myAddr, p->Root);
            status = CreateTreeConnection(path, &treeConnHdl);
            FsArbLog(("CreateTreeConnection(%ws) returned 0x%x hdl 0x%x\n", path, status, treeConnHdl));
            if ((!NT_SUCCESS(status))||(treeConnHdl == INVALID_HANDLE_VALUE)) {
                // set status to something that won't map to a network failure.
                // We need to check for arbitration terminations and other cases below.
                //
                status = ERROR_LOCK_VIOLATION;
                treeConnHdl = INVALID_HANDLE_VALUE;
                goto Retry;
            }
            // Sleep.
            Sleep(MNS_LOCK_DELAY * probe->addrId);
        }
        
        status = FspOpenReplica(p, i, myAddr, &crshdl, &fshdl, &notifyhdl, &waitRegHdl);

Retry:
    
        if (status == ERROR_SUCCESS) {
            EnterCriticalSection(&arb->Lock);
            FsArbLog(("Probe Thread probe replica %d suceeded, ShareSet %x\n", i, (arb->NewAliveSet|(1<<i))));
            arb->CrsHdl[i] = crshdl;
            arb->Fd[i] = fshdl;
            arb->NotifyFd[i] = notifyhdl;
            arb->WaitRegHdl[i] = waitRegHdl;
            arb->TreeConnHdl[i] = treeConnHdl;
            arb->NewAliveSet |= (1 << i);
            arb->Count++;
            if (CRS_QUORUM(arb->Count, arb->DiskListSz)) {
                SetEvent(arb->GotQuorumEvent);
            }
            LeaveCriticalSection(&arb->Lock);
            break;
        }
        else if ((p->ShareState[i] == SHARE_STATE_ARBITRATED)||(p->GoingAway)) {
            // Don't increment the count here, do it in ProbeNodeThread() to prevent.
            // multiple increments.
            //
            // Check for the the go away flag.
#if 0
            // Some other thread managed to get the share. Consider it to be success.
            EnterCriticalSection(&arb->Lock);
            FsArbLog(("Some other thread managed to win arbitration for the share, consider success.\n"));
            arb->Count++;
            if (CRS_QUORUM(arb->Count, arb->DiskListSz)) {
                SetEvent(arb->GotQuorumEvent);
            }
            LeaveCriticalSection(&arb->Lock);
#endif            
            break;
        }
        else {
            // If arbitration has been cancelled, bail out.
            EnterCriticalSection(&arb->Lock);
            if (arb->State != ARB_STATE_BUSY) {
                LeaveCriticalSection(&arb->Lock);
                break;
            }
            LeaveCriticalSection(&arb->Lock);
        }

        if ((status != ERROR_LOCK_VIOLATION) && 
            (status != ERROR_SHARING_VIOLATION) &&
            IsNetworkFailure(status)) {
            xFsClose(treeConnHdl);
            treeConnHdl = INVALID_HANDLE_VALUE;
        }
        
        // retry in 5 seconds again
        Sleep(5 * 1000);
    }

    if ((status != STATUS_SUCCESS) && (treeConnHdl != INVALID_HANDLE_VALUE)) {
        xFsClose(treeConnHdl);
    }
    
    return status;
}

DWORD WINAPI
ProbeNodeThread(LPVOID arg)
{
    FspProbeReplicaId_t     *probe=(FspProbeReplicaId_t *) arg;
    FspArbitrate_t          *arb=probe->arb;
    AddrList_t              aList;
    NTSTATUS                status;
    DWORD                   ndx;
    HANDLE                  hdls[MAX_ADDR_NUM];
    FspProbeAddr_t          probeAddr[MAX_ADDR_NUM];
    DWORD                   hdlCount=0;


    RtlZeroMemory(&aList, sizeof(aList));
    aList.arb = probe->arb;
    aList.NodeId = probe->id;

    if ((status = GetTargetNodeAddresses(&aList)) != STATUS_SUCCESS) {
        FsArbLog(("Failed to get node %u ip addresses, status 0x%x\n", probe->id, status));
        return status;
    }

    if (aList.AddrSz == 0) {
        FsArbLog(("Failed to get any target ipaddress, falling back on nodename\n"));
        status = GetNodeName(aList.NodeId, aList.Addr[0]);
        if (status == ERROR_SUCCESS) {
            aList.AddrSz++;
        }
    }

    for (ndx = 0; ndx < aList.AddrSz;ndx++) {
        probeAddr[ndx].addrId = ndx;
        aList.arb = probe->arb;
        probeAddr[ndx].addrList = &aList;
        hdls[ndx] = CreateThread(NULL, 0, ProbeThread, (LPVOID)(&probeAddr[ndx]), 0, NULL);
        ASSERT(hdls[ndx] != NULL);
    }

    // Wait for the threads to complete.
    if (aList.AddrSz) {
        WaitForMultipleObjects(aList.AddrSz, hdls, TRUE, INFINITE);
    }

    // Handle the case where, the probe thread has got the share. The arbitrate threads have
    // exited, but count has not been incremented.
    //
    EnterCriticalSection(&arb->Lock);
    if ((!(arb->NewAliveSet & (1 << probe->id)))&&
        (arb->vol->ShareState[probe->id] == SHARE_STATE_ARBITRATED)) {
        arb->Count++;
        if (CRS_QUORUM(arb->Count, arb->DiskListSz)) {
            SetEvent(arb->GotQuorumEvent);
        }
    }
    LeaveCriticalSection(&arb->Lock);

    // Close all thread handles.
    for (ndx = 0; ndx < aList.AddrSz;ndx++) {
        CloseHandle(hdls[ndx]);
    }
    
    return 0;
}

DWORD WINAPI
VerifyThread(LPVOID arg)
/*
    This function is called during arbitration to check the health of my owned shares.
 */
{
    FspProbeReplicaId_t *probe = (FspProbeReplicaId_t *) arg;
    FspArbitrate_t *arb = probe->arb;
    DWORD       i = probe->id;
    VolInfo_t *p = arb->vol;
    ULONG_PTR rlen=0;
    NTSTATUS status;

    // set our priority
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    FsArbLog(("Verify Thread for Replica %d\n", i));
    while(TRUE) {    
        status = FspCheckFs(p, NULL, i, NULL, 0, NULL, &rlen);
        if(status == STATUS_SUCCESS) {
            EnterCriticalSection(&arb->Lock);
            FsArbLog(("Verify Thread probe replica %d suceeded, ShareSet %x\n", i, (arb->NewAliveSet|(1<<i))));
            arb->NewAliveSet |= (1<<i);
            arb->Count++;
            if (CRS_QUORUM(arb->Count, arb->DiskListSz)) {
                SetEvent(arb->GotQuorumEvent);
            }
            LeaveCriticalSection(&arb->Lock);
            break;
        }
        else if ((status != ERROR_LOCK_VIOLATION) &&
                    (status != ERROR_SHARING_VIOLATION) &&
                    IsNetworkFailure(status)) {
            // No need to continue probing after these errors.
            break;
        } else if (p->GoingAway) {
            break;
        }
        else {
            // If arbitration has been cancelled, bail out.
            EnterCriticalSection(&arb->Lock);
            if (arb->State != ARB_STATE_BUSY) {
                LeaveCriticalSection(&arb->Lock);
                break;
            }
            LeaveCriticalSection(&arb->Lock);
        }

        // Sleep for 5 secs.
        Sleep(5 * 1000);
    }
    return 0;
}


ULONG
FspFindMissingReplicas(VolInfo_t *p, ULONG set)
/*++
    This should be called with exclusive lock held.
 */
{
    ULONG FoundSet = 0;
    DWORD i, err;
    HANDLE crshdl, fshdl, notifyfd;

    // Just return here. No need to do anything.
    // Trampoline functions would take care of this.
    //if (set == 0)
    return 0;

#if 0
    for (i = 1; i < FsMaxNodes; i++) {
        if (p->DiskList[i] == NULL)
            continue;
        
        if (!(set & (1 << i))) {
            err = FspOpenReplica(p, i, &crshdl, &fshdl, &notifyfd);

            if (err == STATUS_SUCCESS) {
                if (p->CrsHdl[i] == NULL) {
                    p->NotifyFd[i] = notifyfd;
                    p->Fd[i] = fshdl;
                    p->CrsHdl[i] = crshdl;
                    FoundSet |= (1 << i);
                } else {
                    // someone beat us to it, close ours
                    CrsClose(crshdl);
                    xFsClose(fshdl);
                    FindCloseChangeNotification(notifyfd);
                }
            }
        }
    }
    if (FoundSet != 0)
        FsArbLog(("New replica set after probe %x\n", FoundSet));

    return FoundSet;
#endif

}


DWORD WINAPI
FspArbitrateThread(LPVOID arg)
{
    FspArbitrate_t *arb = (FspArbitrate_t *)arg;
    HANDLE hdl[FsMaxNodes];
    DWORD       i, count = 0, err;
    FspProbeReplicaId_t Ids[FsMaxNodes];
    BOOLEAN flag;
    DWORD count1=0, count2=0;
    IO_STATUS_BLOCK ios[FsMaxNodes];

    FsArbLog(("ArbitrateThread begin\n"));
    // set our priority
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    // Before starting arbitration verify the health of existing shares. That would
    // minimize chances of failure. This would clear up the stale handles.
    //
    FspInitAnswers(ios, NULL, NULL, 0);
    TryAvailRequest(FspCheckFs, arb->vol, NULL, NULL, 0, NULL, 0, ios);

    // Grab the reader's lock.
    EnterCriticalSection(&arb->Lock);
    RwLockShared(&arb->vol->Lock);
    
    // Now copy rest of the arbitration stuff from volume info.
    arb->OrigAliveSet = arb->vol->AliveSet;
    arb->NewAliveSet = 0;
    arb->Count = 0;
    arb->DiskListSz = arb->vol->DiskListSz;

    FsArbLog(("ArbitrateThread current AliveSet=%x\n", arb->OrigAliveSet));

    // Get the epoch number, any member in the read set would do.
    if (arb->vol->ReadSet) {
        for (i=1;i<FsMaxNodes;i++) {
            if (arb->vol->ReadSet & (1 << i)) {
                arb->epoch = CrsGetEpoch(arb->vol->CrsHdl[i]);
                break;
            }
        }    
    }
    else {
        arb->epoch = 0;
    }
    
    arb->State = ARB_STATE_BUSY;
    LeaveCriticalSection(&arb->Lock);
    
    // we now start a thread for each replica and do the probe in parallel
    for (i = 1; i < FsMaxNodes; i++) {
        if (arb->vol->DiskList[i] == NULL)
            continue;

        Ids[i].arb = arb;
        Ids[i].id = i;
        
        if (arb->OrigAliveSet & (1 << i)) {
            hdl[count] = CreateThread(NULL, 0, VerifyThread, (LPVOID)(&Ids[i]), 0, NULL);
        }
        else {
            hdl[count] = CreateThread(NULL, 0, ProbeNodeThread, (LPVOID)(&Ids[i]), 0, NULL);
        }
        
        if (hdl[count] != NULL) {
            count++;
        } else {
            FsArbLog(("Unable to create thread to probe replica %d\n", i));
            ProbeThread((LPVOID) &Ids[i]);
        }
    }

    // we now wait
    err = WaitForMultipleObjects(count, hdl, TRUE, arb->vol->ArbTime);

    if (err == WAIT_TIMEOUT) {
        EnterCriticalSection(&arb->Lock);
        // Make the arb threads exit, with whatever they have got. Do this only if
        // the main thread hasn't already cancelled the arbitration.
        // Expected state and their implications:
        // 1. ARB_STATE_IDLE ==> Not possible.
        // 2. ARB_STATE_BUSY ==> Either the main thread is still waiting or has already returned
        //                       with success. In any case make the rest of the arb threads exit.
        // 3. ARB_STATE_CANCEL ==> Main thread has cancelled the arbitration. We should cleanup
        //                         even if we ultimately get quorum. Arb threads have already
        //                         begun exiting.
        //
        if (arb->State == ARB_STATE_BUSY) {
            arb->State = ARB_STATE_IDLE;
        }
        LeaveCriticalSection(&arb->Lock);
        WaitForMultipleObjects(count, hdl, TRUE, INFINITE);
    }
    
    // Close the handles
    for (i = 0; i < count; i++)
        CloseHandle(hdl[i]);

    // Signal the wait Event, if we haven't done so already.
    SetEvent(arb->GotQuorumEvent);

    // Now wait for cleanup event. This signals the fact that the main thread has left.
    WaitForSingleObject(arb->CleanupEvent, INFINITE);
    
    // If we have been cancelled in between, or arbitration failed. 
    // Close the handles we grabbed during arbitration.
    // Then get writers lock and evict the AliveSet.
    EnterCriticalSection(&arb->Lock);
    if ((arb->State == ARB_STATE_CANCEL)||(!CRS_QUORUM(arb->Count, arb->DiskListSz))) {
        for (i=1;i<FsMaxNodes;i++) {
            if ((arb->NewAliveSet & (~arb->OrigAliveSet)) & (1 << i)) {
                CrsClose(arb->CrsHdl[i]);
                UnregisterWaitEx(arb->WaitRegHdl[i], INVALID_HANDLE_VALUE);
                FindCloseChangeNotification(arb->NotifyFd[i]);
                xFsClose(arb->Fd[i]);
                xFsClose(arb->TreeConnHdl[i]);
                arb->vol->ShareState[i] = SHARE_STATE_OFFLINE;
            }
        }

        if (arb->OrigAliveSet) {
            crs_epoch_t newEpoch;
            
            // Exit Reader's lock, get writer's lock.
            RwUnlockShared(&arb->vol->Lock);
            RwLockExclusive(&arb->vol->Lock);

            // We released the read lock and got write lock, if in between something
            // changed, don't do anything. Check the epoch.
            if (arb->vol->ReadSet) {
                for(i=1;i<FsMaxNodes;i++) {
                    if(arb->vol->ReadSet & (1 << i)) {
                        newEpoch = CrsGetEpoch(arb->vol->CrsHdl[i]);
                        break;
                    }
                }
            }
            else {
                newEpoch = 0;
            }

            if (newEpoch == arb->epoch) {
                FspEvict(arb->vol, arb->OrigAliveSet, TRUE);
            }
            RwUnlockExclusive(&arb->vol->Lock);
        }
        else {
            RwUnlockShared(&arb->vol->Lock);
        }

        // Invoke the lost quorum callback.
        // Logic: If the GoingAway flag is already set don't call the lost quorum
        // callback, shutdown is already in progress. If the flag is not set
        // call the lost quorum callback.
        //
        // NOTE: The GoingAway flag should only be set if we call the lost quorum callback.
        // else clussvc might decide to retry arbitration.
        //
        if (arb->vol->GoingAway == FALSE) {
            MajorityNodeSetCallLostquorumCallback(arb->vol->FsCtx->reshdl);
        }
    }
    else {
        // Arbitration suceeded. Get Writer's lock and Join the New shares if any.
        RwUnlockShared(&arb->vol->Lock);
        RwLockExclusive(&arb->vol->Lock);

        // Evict the shares that we had originally but were unable to verify.
        FspEvict(arb->vol, (~arb->NewAliveSet) & arb->OrigAliveSet, TRUE);

        // Now add the new shares.
        for (i=1;i<FsMaxNodes;i++) {
            if ((arb->NewAliveSet & (~arb->OrigAliveSet)) & (1 << i)) {
                if (arb->vol->AliveSet & (1 << i)) {
                    CrsClose(arb->CrsHdl[i]);
                    UnregisterWaitEx(arb->WaitRegHdl[i], INVALID_HANDLE_VALUE);
                    FindCloseChangeNotification(arb->NotifyFd[i]);
                    xFsClose(arb->Fd[i]);
                    xFsClose(arb->TreeConnHdl[i]);
                }
                else {
                    arb->vol->CrsHdl[i] = arb->CrsHdl[i];
                    arb->vol->Fd[i] = arb->Fd[i];
                    arb->vol->NotifyFd[i] = arb->NotifyFd[i];
                    arb->vol->WaitRegHdl[i] = arb->WaitRegHdl[i];
                    arb->vol->TreeConnHdl[i] = arb->TreeConnHdl[i];
                }
            }
        }
        FspJoin(arb->vol, arb->NewAliveSet & (~arb->OrigAliveSet));

        // Now the ultimate test, check for quorum. If not there, evict all the shares.
        // The FsReserve thread would make the callback in Resmon.
        // No use trying to signal the main thread it has already gone back.
        // NOTE: This should be a rare scenario. Arbitration was able to grab a majority
        // of shares but was unable to join them, which is odd.
        //
        // [RajDas] 607258, since the reserve thread is working in parallel, it might
        // have grabbed some shares. We should map that case to success. 
        // The MNS arbitrating thread however would not return success
        // if arb->count is not majority.
        // The assumption here is, whoever grabbed the shares other than the arbitrating
        // threads would be able to successfully join the shares.
        //
        for (i=1;i<FsMaxNodes;i++) {
            if (arb->NewAliveSet & (1<<i)) {
                count1++;
            }
            if (arb->vol->ReadSet & (1<<i)) {
                count2++;
            }
        }
        
        if (!CRS_QUORUM((arb->Count - count1 + count2), arb->DiskListSz)) {
            FspEvict(arb->vol, arb->vol->AliveSet, TRUE);
            RwUnlockExclusive(&arb->vol->Lock);
            
            // Invoke the lost quorum callback.
            // Logic: If the GoingAway flag is already set don't call the lost quorum
            // callback, shutdown is already in progress. If the flag is not set
            // call the lost quorum callback.
            //
            // NOTE: The GoingAway flag should only be set if we call the lost quorum callback.
            // else clussvc might decide to retry arbitration.
            //
            if (arb->vol->GoingAway == FALSE) {
                MajorityNodeSetCallLostquorumCallback(arb->vol->FsCtx->reshdl);
            }
        } else {
            RwUnlockExclusive(&arb->vol->Lock);
        }
    }

    LeaveCriticalSection(&arb->Lock);

    // Signal end of arbitration.
    ArbitrationEnd((PVOID)arb->vol);

    // Now cleanup the fields in arb. and free the structure.
    CloseHandle(arb->CleanupEvent);
    CloseHandle(arb->GotQuorumEvent);
    DeleteCriticalSection(&arb->Lock);
    LocalFree(arb);
    return 0;

}


PVOID
FsArbitrate(PVOID arg, HANDLE *Cleanup, HANDLE *ArbThread)
/*++
    This routine is reentrant, i.e. it can be called multiple number of times, at the same
    time.
 */   
{
    VolInfo_t *p = (VolInfo_t *)arg;
    DWORD err=ERROR_SUCCESS;
    FspArbitrate_t *arb=NULL;
    
    if (p) {
        if (!(arb = LocalAlloc(LMEM_ZEROINIT|LMEM_FIXED, sizeof(FspArbitrate_t)))) {
            err = GetLastError();
            FsArbLog(("FsArb: Failed to allocate memory, status=%d\n", err));
            goto error_exit;
        }

        arb->State = ARB_STATE_IDLE;
        arb->vol = p;
        InitializeCriticalSection(&arb->Lock);        
        if ((arb->CleanupEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) {
            err = GetLastError();
            FsArbLog(("FsArb: Failed to create cleanup event, status=%d\n", err));
            LocalFree(arb);
            goto error_exit;
        }
        if ((arb->GotQuorumEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) {
            err = GetLastError();
            FsArbLog(("FsArb: Failed to create notify event, status=%d\n", err));
            CloseHandle(arb->CleanupEvent);
            LocalFree(arb);
            goto error_exit;
        }
        
        // The rest of the fields in arb comes from the voulme info and should only be
        // accessed while holding the shared lock, let the arbitrate thread do it.
        //
        FsArbLog(("FsArb: Creating arbitration thread\n"));

#if 0
        // Start the arbitration thread, close the previous handle.
        if (*ArbThread != NULL) {
            CloseHandle(*ArbThread);
            *ArbThread = NULL;
        }
#endif
        
        *ArbThread = CreateThread(NULL, 0, FspArbitrateThread, (LPVOID) arb, 0, NULL);
        if (*ArbThread == NULL) {
            err = GetLastError();
            FsLogError(("FsArb: Failed to create arbitration thread status=%d\n", err));
            CloseHandle(arb->CleanupEvent);
            CloseHandle(arb->GotQuorumEvent);
            LocalFree(arb);
            goto error_exit;
        }
    } 
    else {
        err = ERROR_INVALID_PARAMETER;
    }
    
error_exit:

    if (err != ERROR_SUCCESS) {
        arb = NULL;
    }
    else {
        *Cleanup = arb->CleanupEvent;
        ArbitrationStart((PVOID)p);
    }
    SetLastError(err);
    return (PVOID)arb;
}

DWORD
FsCompleteArbitration(PVOID arg, DWORD delta)
{
    DWORD err;
    FspArbitrate_t *arb=(FspArbitrate_t *)arg;
    
    err = WaitForSingleObject(arb->GotQuorumEvent, delta);

    ASSERT((err == WAIT_OBJECT_0)||(err == WAIT_TIMEOUT));
    EnterCriticalSection(&arb->Lock);
    if (CRS_QUORUM(arb->Count, arb->DiskListSz)) {
        err = ERROR_SUCCESS;
    }
    else {
        // Abandon this arbitration. This would make the probe/verify threads to exit.
        arb->State = ARB_STATE_CANCEL;
        err = ERROR_CANCELLED;
    }
    LeaveCriticalSection(&arb->Lock);
    // Set the cleanup event, the arbitrate thread would clean everything up.
    SetEvent(arb->CleanupEvent);

    return err;
}

DWORD
FsRelease(PVOID vHdl)
/*++
    Check if anybody is using this volume then fail the request.
 */
{
    DWORD i;
    VolInfo_t *p = (VolInfo_t *)vHdl;
    FsCtx_t *ctx = p->FsCtx;
    NTSTATUS err;

    if (p) {
        ULONG   set;
        // lock volume
        ASSERT(ctx != NULL);

        // Grab the FS lock and then grab the vol lock in exclusive mode. This is just to
        // throw away any slackers. There shouldn't be anybody accessing the volume at this
        // moment anyway.

        // Set the flag
        p->GoingAway = TRUE;
        
        LockEnter(ctx->Lock);        
        RwLockExclusive(&p->Lock);

        if (p->UserList) {
            FsArbLog(("FsRelease: Volume with Tid=%d in use by user %d\n", p->Tid, p->UserList->Uid));
            RwUnlockExclusive(&p->Lock);
            LockExit(ctx->Lock);
            return ERROR_BUSY;
        }

        // Evict the Shares.
        set = p->AliveSet;

        FsArbLog(("FsRelease %S AliveSet %x\n", p->Root, set));

        FspEvict(p, p->AliveSet, TRUE);

        FsArbLog(("FsRelease %S done\n", p->Root));

        // unlock volume
        RwUnlockExclusive(&p->Lock);
        RwLockDelete(&p->Lock);
        
        //Close the root handle.
        xFsClose(p->Fd[0]);
        
        // Remove this volume from the file system context & free the memory.
        ctx = p->FsCtx;
        if (ctx->VolList == p) {
            ctx->VolList = p->Next;
            ctx->VolListSz--;
        }
        else {
            VolInfo_t *last=ctx->VolList;
            while ((last->Next != p) && last) {
                last = last->Next;
            }
            if (last != NULL) {
                last->Next = p->Next;
                ctx->VolListSz--;
            }
            else {
                FsLogError(("FsRelease: Volume not in FsContext VolumeList Vol root=%S\n", p->Root));
            }
        }
        LockDestroy(p->ArbLock);
        CloseHandle(p->AllArbsCompleteEvent);
        // Deregister the clussvc termination registration.
        if (p->ClussvcTerminationHandle != INVALID_HANDLE_VALUE) {
            UnregisterWaitEx(p->ClussvcTerminationHandle, INVALID_HANDLE_VALUE);
        }

        if (p->ClussvcProcess != INVALID_HANDLE_VALUE) {
            CloseHandle(p->ClussvcProcess);
        }
        for (i=0;i<FsMaxNodes;i++) {
            if (p->NotifyChangeEvent[i] != NULL) {
                CloseHandle(p->NotifyChangeEvent[i]);
            }
        }
        
        MemFree(p);
        LockExit(ctx->Lock);
        err = ERROR_SUCCESS;

    } else {
        err = ERROR_INVALID_PARAMETER;
    }


    return err;
}

VOID
FsForceClose(
    IN PVOID                par,
    IN BOOLEAN              isFired
    )
{
    VolInfo_t   *vol=(VolInfo_t *)par;
    DWORD       ndx;

    if (vol == NULL) {
        FsLogError(("FsForceClose: Exiting...\n"));
        return;
    }
    
    FsLogError(("FsForceClose: Force terminating volume 0x%x, root %S, AliveSet 0x%x\n", vol, vol->Root, vol->AliveSet));
    vol->GoingAway = TRUE;

    for(ndx=1;ndx<FsMaxNodes;ndx++) {
        if (vol->AliveSet & (1 << ndx)) {
            CrsForceClose(vol->CrsHdl[ndx]);
        }
    }
    
    // The  rest of the handles need to be closed too.
    // At this point I don't care for locks, clussvc has exited. Close all the
    // user handles ASAP.
    //
    {
        UserInfo_t  *user=vol->UserList;

        while (user != NULL) {
            for(ndx=0;ndx<FsTableSize;ndx++) {
                if (user->Table[ndx].hState != HandleStateInit) {
                    FspFreeHandle(user, (fhandle_t)ndx);
                }
            }
            user = user->Next;
        }    
    }
}

DWORD
FsReserve(PVOID vhdl)
{
    VolInfo_t *p = (VolInfo_t *)vhdl;
    DWORD err=ERROR_SUCCESS;
    DWORD NewAliveSet;
    PVOID CrsHdl;
    HANDLE Fd;
    HANDLE NotifyFd;
    HANDLE WaitRegHdl;
    HANDLE TreeConnHdl;
    static DWORD LastProbed=1;
    DWORD i, j, ndx;
    IO_STATUS_BLOCK ios[FsMaxNodes];
    DWORD sid;
    AddrList_t  nodeAddr;

    // check if there is a new replica online
    // FsLog(("FsReserve: Enter LastProbed=%d AliveSet=%x\n", LastProbed, p->AliveSet));

    if ((p == NULL)||(p->GoingAway)) {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }
    
    RwLockShared(&p->Lock);

    // Probe for missing shares, one share at a time. In circular order.
    for(i=1;i<=FsMaxNodes;i++) {
        j = (LastProbed + i)%FsMaxNodes;
        // FsLog(("FsReserve: Debug i=%d LastProbed=%d AliveSet=0x%x\n", j, LastProbed, p->AliveSet));
        if (j == 0) {
            continue;
        }
        if (p->DiskList[j] == NULL) {
            continue;
        }
        if (p->AliveSet & (1 << j)) {
            continue;
        }
        LastProbed = j;
        RtlZeroMemory(&nodeAddr, sizeof(nodeAddr));
        nodeAddr.NodeId = j;
        err = GetTargetNodeAddresses(&nodeAddr);
        if (err != ERROR_SUCCESS) {
            continue;
        }

        // Now try them one by one.
        for (ndx=0;ndx<nodeAddr.AddrSz;ndx++) {
            LPWSTR  myAddr=nodeAddr.Addr[ndx];
            WCHAR   path[MAX_PATH];

            StringCchPrintfW(path, MAX_PATH, L"%ws\\%ws", myAddr, p->Root);
            err = CreateTreeConnection(path, &TreeConnHdl);
            if (err != STATUS_SUCCESS) {
                continue;
            }
            err = FspOpenReplica(p, j, myAddr, &CrsHdl, &Fd, &NotifyFd, &WaitRegHdl);
            if (err == STATUS_SUCCESS) {
                // Join this replica and exit.
                FsLog(("FsReserve: Got new Replica %d, AliveSet 0x%x, Joining\n", j, p->AliveSet));
                RwUnlockShared(&p->Lock);
                RwLockExclusive(&p->Lock);
                if (p->AliveSet & (1 << j)) {
                    // GET OUT!!!!
                    FsLogError(("FsReserve: New share already in AliveSet=%x Id=%d\n", p->AliveSet, j));
                    CrsClose(CrsHdl);
                    xFsClose(Fd);
                    UnregisterWaitEx(WaitRegHdl, INVALID_HANDLE_VALUE);
                    FindCloseChangeNotification(NotifyFd);
                    xFsClose(TreeConnHdl);
                }
                else {
                    p->CrsHdl[j] = CrsHdl;
                    p->NotifyFd[j] = NotifyFd;
                    p->WaitRegHdl[j] = WaitRegHdl;
                    p->Fd[j] = Fd;
                    p->TreeConnHdl[j] = TreeConnHdl;
                    FspJoin(p, (1 << j));
                }
                RwUnlockExclusive(&p->Lock);
                RwLockShared(&p->Lock);
                break;
            } else {
                xFsClose(TreeConnHdl);
            }
        }
        // FsLog(("FsReserve: Probed Replica=%d\n", LastProbed));
        break;
    }    
    RwUnlockShared(&p->Lock);

    // check each crs handle to be valid
    FspInitAnswers(ios, NULL, NULL, 0);
    sid = SendAvailRequest(FspCheckFs, p, NULL,
                      NULL, 0, NULL, 0, ios);
    err = RtlNtStatusToDosError(ios[sid].Status);

    // Check if the volume is online atleast in readonly mode.
    err = FsIsOnlineReadonly(p);    
    return err;
}


DWORD
FsIsOnlineReadWrite(PVOID vHdl)
{
    
    VolInfo_t *p = (VolInfo_t *)vHdl;
    DWORD err = ERROR_INVALID_PARAMETER;

    if (p) {

        // Just grab the reader lock & get the state.
        RwLockShared(&p->Lock);
        if (p->State == VolumeStateOnlineReadWrite) {
            err = ERROR_SUCCESS;
        }
        else {
            err = ERROR_RESOURCE_NOT_ONLINE;
        }
        RwUnlockShared(&p->Lock);
    }
    return err;
}

DWORD
FsIsOnlineReadonly(PVOID vHdl)
{
    
    VolInfo_t *p = (VolInfo_t *)vHdl;
    DWORD err = ERROR_INVALID_PARAMETER;

    if (p) {

        // Just grab the reader lock & get the state.
        RwLockShared(&p->Lock);
        if ((p->State == VolumeStateOnlineReadWrite)||
            (p->State == VolumeStateOnlineReadonly)) {
            err = ERROR_SUCCESS;
        }
        else {
            err = ERROR_RESOURCE_NOT_ONLINE;
        }
        RwUnlockShared(&p->Lock);
    }
    return err;
}



DWORD
FsUpdateReplicaSet(PVOID vhdl, LPWSTR new_path[], DWORD new_len)
{
    VolInfo_t   *p = (VolInfo_t *)vhdl;
    DWORD       err=ERROR_SUCCESS;
    DWORD       i, j;
    ULONG       evict_mask, add_mask;

    if (p == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (new_len >= FsMaxNodes) {
        return ERROR_TOO_MANY_NAMES;
    }

    RwLockExclusive(&p->Lock);

    // Find which current replicas are in the new set, and keep them
    // We skip the IPC share, since it's local
    evict_mask = 0;
    for (j=1; j < FsMaxNodes; j++) {
        BOOLEAN found;
        if (p->DiskList[j] == NULL)
            continue;
        found = FALSE;
        for (i=1; i < FsMaxNodes; i++) {
            if (new_path[i] != NULL && wcscmp(new_path[i], p->DiskList[j]) == 0) {
                // keep this replica
                found = TRUE;
                break;
            }
        }
        if (found == FALSE) {
            // This replica is evicted from the new set, add to evict set mask
            evict_mask |= (1 << j);
            FsArbLog(("FsUpdateReplicaSet evict replica # %d '%S' set 0x%x\n",
                   j, p->DiskList[j], evict_mask));
        }
    }

    // At this point we have all the replicas in the current and new sets. We now need
    // to find replicas that are in the new set but missing from current set.
    add_mask = 0;
    for (i=1; i < FsMaxNodes; i++) {
        BOOLEAN found;
        if (new_path[i] == NULL)
            continue;
        found = FALSE;
        for (j=1; j < FsMaxNodes; j++) {
            if (p->DiskList[j] != NULL && wcscmp(new_path[i], p->DiskList[j]) == 0) {
                // keep this replica
                found = TRUE;
                break;
            }
        }
        if (found == FALSE) {
            add_mask |= (1 << i);
            FsArbLog(("FsUpdateReplicaSet adding replica # %d '%S' set 0x%x\n",
                   i, new_path[i], add_mask));
        }
    }

    // we now update our disklist with new disklist
    for (i = 1; i < FsMaxNodes; i++) {
        if ((evict_mask & 1 << i) || (add_mask & (1 << i)))
            FsArbLog(("FsUpdateReplicat %d: %S -> %S\n",
                   i, p->DiskList[i], new_path[i]));
        p->DiskList[i] = new_path[i];

    }
    p->DiskListSz = new_len;

    // If we are alive, apply changes
    if (p->WriteSet != 0 || p->ReadSet != 0) {
        // At this point we evict old replicas
        if (evict_mask != 0)
            FspEvict(p, evict_mask, TRUE);

        // check if there is a new replica online
        if (add_mask > 0) {
            ULONG ReplicaSet = 0;

            ReplicaSet = p->AliveSet;
            ReplicaSet = FspFindMissingReplicas(p, ReplicaSet);

            // we found new disks
            if (ReplicaSet > 0) {
                FspJoin(p, ReplicaSet);
            }
        }
    }

    RwUnlockExclusive(&p->Lock);
    
    return err;
}

VOID
ArbitrationStart(PVOID arg)
{
    VolInfo_t *vol=(VolInfo_t *)arg;

    if (vol == NULL) {
        return;
    }
    
    LockEnter(vol->ArbLock);
    vol->NumArbsInProgress++;
    if (vol->NumArbsInProgress==1) {
        ResetEvent(vol->AllArbsCompleteEvent);
    }
    LockExit(vol->ArbLock);
}

VOID
ArbitrationEnd(PVOID arg)
{
    VolInfo_t *vol=(VolInfo_t *)arg;

    if (vol == NULL) {
        return;
    }

    LockEnter(vol->ArbLock);
    vol->NumArbsInProgress--;
    if (vol->NumArbsInProgress == 0) {
        SetEvent(vol->AllArbsCompleteEvent);
    }
    LockExit(vol->ArbLock);
}

VOID
WaitForArbCompletion(PVOID arg)    
{
    VolInfo_t *vol=(VolInfo_t *)arg;

    if (vol == NULL) {
        return;
    }
    
    WaitForSingleObject(vol->AllArbsCompleteEvent, INFINITE);
}

BOOL
IsArbInProgress(PVOID arg)
{
    VolInfo_t   *vol=(VolInfo_t *)arg;
    BOOL        ret=FALSE;

    if (vol == NULL) {
        return ret;
    }

    LockEnter(vol->ArbLock);
    ret = (vol->NumArbsInProgress > 0);
    LockExit(vol->ArbLock);

    return ret;
}

NTSTATUS
CreateTreeConnection(LPWSTR path, HANDLE *Fd)
{
    NTSTATUS                    status=STATUS_SUCCESS;
    IO_STATUS_BLOCK             ioStatus;
    UNICODE_STRING              uStr;
    OBJECT_ATTRIBUTES           objAttr;
    PFILE_FULL_EA_INFORMATION   EaBuffer=NULL, Ea=NULL;
    USHORT                      TransportNameSize=0;
    ULONG                       EaBufferSize=0;
    UCHAR                       EaNameTransportNameSize;
    WCHAR                       lPath[MAX_PATH];

    EaNameTransportNameSize = (UCHAR) (ROUND_UP_COUNT(
                                    strlen(EA_NAME_TRANSPORT) + sizeof(CHAR),
                                    ALIGN_WCHAR
                                    ) - sizeof(CHAR));
    TransportNameSize = (USHORT)(wcslen(MNS_TRANSPORT) * sizeof(WCHAR));

    EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameTransportNameSize + sizeof(CHAR) +
                            TransportNameSize,
                            ALIGN_DWORD
                            );
    
    EaBuffer = LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, EaBufferSize);
    if (EaBuffer == NULL) {
        status = STATUS_NO_MEMORY;
        goto error_exit;
    }
    Ea = EaBuffer;
    StringCbCopyA(Ea->EaName, EaBufferSize, EA_NAME_TRANSPORT);
    Ea->EaNameLength = EaNameTransportNameSize;
    StringCbCopyW(
        (LPWSTR) &(Ea->EaName[EaNameTransportNameSize + sizeof(CHAR)]),
        EaBufferSize,
        MNS_TRANSPORT
        );
    Ea->EaValueLength = TransportNameSize;
    Ea->Flags = 0;
    Ea->NextEntryOffset = 0;

    // Remove back slashes at the start of the path. <dest ip addr>\shareGuid$
    while (*path == L'\\') {
        path++;
    }
    status = StringCchPrintfW(lPath, MAX_PATH, L"%ws\\%ws", MNS_REDIRECTOR, path);
    if (status != S_OK) {
        goto error_exit;
    }
    
    uStr.Buffer = lPath;
    uStr.Length = (USHORT)(wcslen(lPath) * sizeof(WCHAR));
    uStr.MaximumLength = MAX_PATH * sizeof(WCHAR);

    InitializeObjectAttributes(&objAttr, &uStr, OBJ_CASE_INSENSITIVE, NULL, NULL);
    *Fd = INVALID_HANDLE_VALUE;
    status = NtCreateFile(
                Fd,
                SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
                &objAttr,
                &ioStatus,
                0,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_ALERT|FILE_CREATE_TREE_CONNECTION,
                EaBuffer,
                EaBufferSize
                );

error_exit:

    if (NT_SUCCESS(status)) {
        status = STATUS_SUCCESS;
    }
    else {
        *Fd = INVALID_HANDLE_VALUE;
    }
    
    if (EaBuffer) {
        LocalFree(EaBuffer);
    }
    
    return status;
}

DWORD
IsNodeConnected(HKEY hClusKey, LPWSTR netName, DWORD nid, BOOL *isConnected)
{
    DWORD       status=ERROR_SUCCESS;
    HKEY        hIntfsKey=NULL, hIntfKey=NULL;
    WCHAR       intName[MAX_PATH], netName1[MAX_PATH], nodeId[20];
    FILETIME    fileTime;
    DWORD       size, type;
    DWORD       ndx;
    LONG        tnid;
    

    *isConnected = FALSE;

    status = RegOpenKeyExW(hClusKey, CLUSREG_KEYNAME_NETINTERFACES, 0, KEY_READ, &hIntfsKey);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }
    for (ndx=0;TRUE;ndx++) {
        size = MAX_PATH;
        status = RegEnumKeyExW(hIntfsKey, ndx, intName, &size, NULL, NULL, 0, &fileTime);
        if (status != ERROR_SUCCESS) {
            break;
        }

        status = RegOpenKeyExW(hIntfsKey, intName, 0, KEY_READ, &hIntfKey);
        if (status != ERROR_SUCCESS) {
            break;
        }

        size = MAX_PATH;
        status = RegQueryValueExW(hIntfKey, CLUSREG_NAME_NETIFACE_NETWORK, NULL, &type, (LPBYTE)netName1, &size);
        if (status != ERROR_SUCCESS) {
            break;
        }

        if (wcscmp(netName, netName1)) {
            // Wrong network, Close interface key and continue.
            RegCloseKey(hIntfKey);
            hIntfKey = NULL;
            continue;
        }
        
        size = 20;
        status = RegQueryValueExW(hIntfKey, CLUSREG_NAME_NETIFACE_NODE, NULL, &type, (LPBYTE)nodeId, &size);
        if (status != ERROR_SUCCESS) {
            break;
        }
            
        tnid = wcstol(nodeId, NULL, 10);

        if (tnid != nid) {
            // Wrong node, close interface key and continue.
            RegCloseKey(hIntfKey);
            hIntfKey = NULL;
            continue;
        }

        // The node is connected.
        *isConnected = TRUE;
        break;
    }

    // This is the only expected error.
    if (status == ERROR_NO_MORE_ITEMS) {
        status = ERROR_SUCCESS;
    }

error_exit:

    if (hIntfKey) {
        RegCloseKey(hIntfKey);
    }

    if (hIntfsKey) {
        RegCloseKey(hIntfsKey);
    }
    
    return status;
}

DWORD
GetLocalNodeId(HKEY hClusKey)
{
    WCHAR       nodeName[MAX_PATH], nodeId[MAX_PATH], cName[MAX_PATH];
    DWORD       ndx;
    HKEY        hNodesKey=NULL, hNodeKey=NULL;
    DWORD       nId=0, size, type;
    DWORD       status=ERROR_SUCCESS;
    FILETIME    fileTime;
    

    status = RegOpenKeyExW(hClusKey, CLUSREG_KEYNAME_NODES, 0, KEY_READ, &hNodesKey);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    size = MAX_PATH;
    if (!GetComputerNameW(cName, &size)) {
        status = GetLastError();
        goto error_exit;
    }
    
    for (ndx=0;TRUE;ndx++) {
        size = MAX_PATH;
        status = RegEnumKeyExW(hNodesKey, ndx, nodeId, &size, NULL, NULL, 0, &fileTime);
        if (status != ERROR_SUCCESS) {
            break;
        }

        status = RegOpenKeyExW(hNodesKey, nodeId, 0, KEY_READ, &hNodeKey);
        if (status != ERROR_SUCCESS) {
            break;
        }

        size = MAX_PATH;
        status = RegQueryValueExW(hNodeKey, CLUSREG_NAME_NODE_NAME, NULL, &type, (LPBYTE)nodeName, &size);
        if (status != ERROR_SUCCESS) {
            break;
        }

        if (wcscmp(cName, nodeName)) {
            RegCloseKey(hNodeKey);
            hNodeKey = NULL;
            continue;
        }

        // Match.
        nId = wcstol(nodeId, NULL, 10);
        break;
    }

error_exit:

    if (hNodeKey) {
        RegCloseKey(hNodeKey);
    }

    if (hNodesKey) {
        RegCloseKey(hNodesKey);
    }

    SetLastError(status);
    return nId;
}

DWORD
GetNodeName(DWORD nodeId, LPWSTR nodeName)
{
    WCHAR       nName[MAX_PATH], nId[MAX_PATH];
    DWORD       status=ERROR_SUCCESS;
    HKEY        hNodesKey=NULL, hNodeKey=NULL, hClusKey=NULL;
    DWORD       size, type, ndx, id;
    FILETIME    fileTime;

    if ((status = RegOpenKeyExW(HKEY_LOCAL_MACHINE, CLUSREG_KEYNAME_CLUSTER, 0, KEY_READ, &hClusKey)) != ERROR_SUCCESS) {
        goto error_exit;
    }
    
    status = RegOpenKeyExW(hClusKey, CLUSREG_KEYNAME_NODES, 0, KEY_READ, &hNodesKey);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    for (ndx=0;TRUE;ndx++) {
        size = MAX_PATH;
        status = RegEnumKeyExW(hNodesKey, ndx, nId, &size, NULL, NULL, 0, &fileTime);
        if (status != ERROR_SUCCESS) {
            break;
        }

        id = wcstol(nId, NULL, 10);
        if (id != nodeId) {
            // Wrong node
            continue;
        }

        status = RegOpenKeyExW(hNodesKey, nId, 0, KEY_READ, &hNodeKey);
        if (status != ERROR_SUCCESS) {
            break;
        }
        
        size = MAX_PATH;
        status = RegQueryValueExW(hNodeKey, CLUSREG_NAME_NODE_NAME, NULL, &type, (LPBYTE)nName, &size);
        if (status != ERROR_SUCCESS) {
            break;
        }

        // This is a bit of cheating. I know nodeName is of size MAX_PATH.
        StringCchCopyW(nodeName, MAX_PATH, nName);
        break;
        
    }


error_exit:

    if (hNodeKey) {
        RegCloseKey(hNodeKey);
    }
    
    if (hNodesKey) {
        RegCloseKey(hNodesKey);
    }

    if (hClusKey) {
        RegCloseKey(hClusKey);
    }

    return status;
}

DWORD
GetTargetNodeAddresses(AddrList_t *addrList)
{
    ULONG       lid, tnid;
    LPWSTR      networkGuids[MAX_ADDR_NUM];
    DWORD       ndx, ndx1, size, type, role, pri;
    DWORD       status=ERROR_SUCCESS;
    // HCLUSTER    hCluster=NULL;
    HKEY        hClusKey=NULL;
    HKEY        hNetsKey=NULL, hNetKey=NULL;
    HKEY        hIntfsKey=NULL, hIntfKey=NULL;
    FILETIME    fileTime;
    WCHAR       netName[MAX_PATH], intfName[MAX_PATH], nodeId[20], intAddr[MAX_ADDR_SIZE]; 
    BOOL        isConnected;    

    for (ndx=0;ndx<MAX_ADDR_NUM;ndx++) {
        networkGuids[ndx] = NULL;
    }

#if 0
    // get the local node id.
    ndx = 20;
    if ((status = GetClusterNodeId(NULL, nodeId, &ndx)) != ERROR_SUCCESS) {
        goto error_exit;
    }
    lid = wcstol(nodeId, NULL, 10);
#endif


    // Enumearte all the networks and put the guids in the array according to their
    // priorities. Remove the networks which are for client access only or ones to which
    // the local node is not directly connected.
    //
#if 0    
    if ((hCluster = OpenCluster(NULL)) == NULL) {
        status = GetLastError();
        goto error_exit;
    }
#endif    

    if ((status = RegOpenKeyExW(HKEY_LOCAL_MACHINE, CLUSREG_KEYNAME_CLUSTER, 0, KEY_READ, &hClusKey)) != ERROR_SUCCESS) {
        goto error_exit;
    }

    if ((lid = GetLocalNodeId(hClusKey)) == 0) {
        status = GetLastError();
        goto error_exit;
    }

    status = RegOpenKeyExW(hClusKey, CLUSREG_KEYNAME_NETWORKS, 0, KEY_READ, &hNetsKey);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    for (ndx = 0;TRUE;ndx++) {
        size = MAX_PATH;
        status = RegEnumKeyExW(hNetsKey, ndx, netName, &size, NULL, NULL, 0, &fileTime);
        if (status != ERROR_SUCCESS) {
            break;
        }

        // Open the network GUID.
        status = RegOpenKeyExW(hNetsKey, netName, 0, KEY_READ, &hNetKey);
        if (status != ERROR_SUCCESS) {
            break;
        }

        // Check that the network is for internal access.
        size = sizeof(DWORD);
        status = RegQueryValueExW(hNetKey, CLUSREG_NAME_NET_ROLE, NULL, &type, (LPBYTE)&role, &size);
        if (status != ERROR_SUCCESS) {
            break;
        }

        if (!(role & ClusterNetworkRoleInternalUse)) {
            RegCloseKey(hNetKey);
            hNetKey = NULL;
            continue;
        }

        // Now check that the local node is connected to the network.
        status = IsNodeConnected(hClusKey, netName, lid, &isConnected);
        if (status != ERROR_SUCCESS) {
            break;
        }

        if (!isConnected) {
            RegCloseKey(hNetKey);
            hNetKey = NULL;
            continue;
        }

        // Query the network priority.
        size = sizeof(DWORD);
        status = RegQueryValueExW(hNetKey, CLUSREG_NAME_NET_PRIORITY, NULL, &type, (LPBYTE)&pri, &size);
        if (status != ERROR_SUCCESS) {
            break;
        }

        // Only consider networks with priorities 0<->(MAX_ADDR_NUM-1) included.
        if (pri >= MAX_ADDR_NUM) {
            RegCloseKey(hNetKey);
            hNetKey = NULL;
            continue;
        }
        
        size = (wcslen(netName) + 1) * sizeof(WCHAR);
        networkGuids[pri] = HeapAlloc(GetProcessHeap(), 0, size);
        if (networkGuids[pri] == NULL) {
            status = GetLastError();
            break;
        }
        status = StringCbCopyW(networkGuids[pri], size, netName);
        if (status != S_OK) {
            break;
        }

        RegCloseKey(hNetKey);
        hNetKey = NULL;
    }

    // These are the only 2 exit conditions tolerated.
    if ((status != ERROR_SUCCESS)&&(status != ERROR_NO_MORE_ITEMS)) {
        goto error_exit;
    }

    status = ERROR_SUCCESS;

    // Now enumerate the interfaces and get the ip addresses of the target node corresponding
    // to the networks.
    status = RegOpenKeyExW(hClusKey, CLUSREG_KEYNAME_NETINTERFACES, 0, KEY_READ, &hIntfsKey);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    for (ndx1=0;ndx1<MAX_ADDR_NUM;ndx1++) {
        if (networkGuids[ndx1] == NULL) {
            continue;
        }
        
        for (ndx=0;TRUE;ndx++) {
            size = MAX_PATH;
            status = RegEnumKeyExW(hIntfsKey, ndx, intfName, &size, NULL, NULL, 0, &fileTime);
            if (status != ERROR_SUCCESS) {
                break;
            }

            status = RegOpenKeyExW(hIntfsKey, intfName, 0, KEY_READ, &hIntfKey);
            if (status != ERROR_SUCCESS) {
                break;
            }

            size = MAX_PATH;
            status = RegQueryValueExW(hIntfKey, CLUSREG_NAME_NETIFACE_NETWORK, NULL, &type, (LPBYTE)netName, &size);
            if (status != ERROR_SUCCESS) {
                break;
            }
            
            if (wcscmp(netName, networkGuids[ndx1])) {
                // Wrong network, close key and continue.
                RegCloseKey(hIntfKey);
                hIntfKey = NULL;
                continue;
            }

            size = 20;
            status = RegQueryValueExW(hIntfKey, CLUSREG_NAME_NETIFACE_NODE, NULL, &type, (LPBYTE)nodeId, &size);
            if (status != ERROR_SUCCESS) {
                break;
            }
            
            tnid = wcstol(nodeId, NULL, 10);

            // If wrong target node, or I have already go MAX_ADDR_NUM addresses to the target, 
            // don't bother.
            if ((tnid != addrList->NodeId)||(addrList->AddrSz >= MAX_ADDR_NUM)) {
                // Wrong node or max target addr reached, close key and continue.
                RegCloseKey(hIntfKey);
                hIntfKey = NULL;
                continue;
            }

            // Copy the ipaddress from the network interface key to the addrlist.
            size = MAX_ADDR_SIZE;
            status = RegQueryValueExW(hIntfKey, CLUSREG_NAME_NETIFACE_ADDRESS, NULL, &type, (LPBYTE)intAddr, &size);
            if (status != ERROR_SUCCESS) {
                break;
            }
            StringCchCopyW(addrList->Addr[addrList->AddrSz], MAX_ADDR_SIZE, intAddr);
            addrList->AddrSz++;
            RegCloseKey(hIntfKey);
            hIntfKey = NULL;
        }

        if ((status != ERROR_SUCCESS)&&(status != ERROR_NO_MORE_ITEMS)) {
            goto error_exit;
        }
        status = ERROR_SUCCESS;

        // Just to be sure close the interfaces key and reopen it.
        RegCloseKey(hIntfsKey);
        hIntfsKey = NULL;
        status = RegOpenKeyExW(hClusKey, CLUSREG_KEYNAME_NETINTERFACES, 0, KEY_READ, &hIntfsKey);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
    }    
    
error_exit:

    // Just testing.
    // FsLog(("Node %u addresses, Sz:%u\n", addrList->NodeId, addrList->AddrSz));
    // for (ndx=0;ndx<addrList->AddrSz;ndx++) {
    //     FsLog(("addr[%u]=%ws\n", ndx, addrList->Addr[ndx]));
    // }
    
    // This is the only tolerated error
    if (status == ERROR_NO_MORE_ITEMS) {
        status = ERROR_SUCCESS;
    }

    for(ndx=0;ndx<MAX_ADDR_NUM;ndx++) {
        if (networkGuids[ndx] != NULL) {
            HeapFree(GetProcessHeap(), 0, networkGuids[ndx]);
        }
    }

    if (hIntfKey) {
        RegCloseKey(hIntfKey);
    }

    if (hIntfsKey) {
        RegCloseKey(hIntfsKey);
    }

    if (hNetKey) {
        RegCloseKey(hNetKey);
    }

    if (hNetsKey) {
        RegCloseKey(hNetsKey);
    }

    if (hClusKey) {
        RegCloseKey(hClusKey);
    }

#if 0
    if (hCluster) {
        CloseCluster(hCluster);
    }
#endif

    return status;
}


VOID
FsSignalShutdown(PVOID arg)
{
    VolInfo_t *vol=(VolInfo_t *)arg;

    if (vol) {
        FsLog(("Vol '%S' going away\n", vol->Root));
        vol->GoingAway = TRUE;
    }
}

#if USE_RTL_RESOURCE
    // Use RTL implementation of Reader-Writer Lock. Not as efficient as the RPC one.
    // Defined in Fsp.h

#else
// This is the Reader Writer lock api, copied from CSharedLock class of RPC.
DWORD
RwLockInit(RwLock *lock)
{
    DWORD status=ERROR_SUCCESS;

    // ClRtlLogWmi("RwLockInit() Enter\n");
    InitializeCriticalSection(&lock->lock);
    if (!lock->hevent) {
        lock->hevent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }
    
    if (!lock->hevent) {
        status = GetLastError();
        DeleteCriticalSection(&lock->lock);
        return status;
    }

    lock->readers = 0;
    lock->writers = 0;
    // ClRtlLogWmi("RwLockInit() Exit\n");
    return status;
}

VOID
RwLockDelete(RwLock *lock)
{
    // ClRtlLogWmi("RwLockDelete() Enter\n");
    DeleteCriticalSection(&lock->lock);
    if (lock->hevent) {
        CloseHandle(lock->hevent);
        lock->hevent = 0;
    }
    lock->readers = 0;
    lock->writers = 0;
    // ClRtlLogWmi("RwLockDelete() Exit\n");
}

VOID
RwLockShared(RwLock *lock)
{
    CHAR arr[200];
    ASSERT(lock->hevent != 0);

    sprintf(arr, "RwLockShared(readers=%d, writers=%d) Enter\n", lock->readers, lock->writers);
    // ClRtlLogWmi(arr);
    InterlockedIncrement(&lock->readers);
    if (lock->writers) {
        if (InterlockedDecrement(&lock->readers) == 0) {
            SetEvent(lock->hevent);
        }
        EnterCriticalSection(&lock->lock);
        InterlockedIncrement(&lock->readers);
        LeaveCriticalSection(&lock->lock);
    }
    sprintf(arr, "RwLockShared(readers=%d, writers=%d) Exit\n", lock->readers, lock->writers);
    // ClRtlLogWmi(arr);
}

VOID
RwUnlockShared(RwLock *lock)
{
    CHAR arr[200];
    ASSERT(lock->readers > 0);
    ASSERT(lock->hevent != 0);

    sprintf(arr, "RwUnlockShared(readers=%d, writers=%d) Enter\n", lock->readers, lock->writers);
    // ClRtlLogWmi(arr);
    if ((InterlockedDecrement(&lock->readers) == 0)&&lock->writers) {
        SetEvent(lock->hevent);
    }
    sprintf(arr, "RwUnlockShared(readers=%d, writers=%d) Exit\n", lock->readers, lock->writers);
    // ClRtlLogWmi(arr);
}

VOID
RwLockExclusive(RwLock *lock)
{
    CHAR arr[200];
    ASSERT(lock->hevent != 0);

    sprintf(arr, "RwLockExclusive(readers=%d, writers=%d) Enter\n", lock->readers, lock->writers);
    // ClRtlLogWmi(arr);
    EnterCriticalSection(&lock->lock);
    lock->writers++;
    while (lock->readers) {
        WaitForSingleObject(lock->hevent, INFINITE);
    }
    sprintf(arr, "RwLockExclusive(readers=%d, writers=%d) Exit\n", lock->readers, lock->writers);
    // ClRtlLogWmi(arr);
}

VOID
RwUnlockExclusive(RwLock *lock)
{
    CHAR arr[200];
    ASSERT(lock->writers > 0);
    ASSERT(lock->hevent != 0);

    sprintf(arr, "RwUnlockExclusive(readers=%d, writers=%d) Enter\n", lock->readers, lock->writers);
    // ClRtlLogWmi(arr);
    lock->writers--;
    LeaveCriticalSection(&lock->lock);
    sprintf(arr, "RwUnlockExclusive(readers=%d, writers=%d) Exit\n", lock->readers, lock->writers);
    // ClRtlLogWmi(arr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\fsapi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsapi.h

Abstract:

    External APIs to replication file system

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#ifndef _FS_API_H
#define _FS_API_H

// upto 16 nodes for now, node id start from 1
#define	FsMaxNodes	17

// initial crs log is 16 sectors, which is 8k
#define	FsCrsNumSectors	16

DWORD	FsInit(PVOID, PVOID *);
void	FsExit(PVOID);
void	FsEnd(PVOID);
DWORD 	FsRegister(PVOID, LPWSTR name, LPWSTR ipcshare, LPWSTR disks[], DWORD disksz, DWORD ArbTime, HANDLE *fsid);
DWORD 	FsUpdateReplicaSet(HANDLE fsid, LPWSTR disks[], DWORD disksz);
PVOID 	FsArbitrate(PVOID vid, HANDLE *event, HANDLE *ArbThread);
DWORD   FsCompleteArbitration(PVOID arg, DWORD delta);
DWORD 	FsIsOnlineReadonly(PVOID vid);
DWORD 	FsIsOnlineReadWrite(PVOID vid);
DWORD 	FsRelease(PVOID vid);
DWORD 	FsReserve(PVOID vid);
VOID    FsSignalShutdown(PVOID arg);

BOOL    IsArbInProgress(PVOID arg);
VOID    ArbitrationStart(PVOID arg);
VOID    ArbitrationEnd(PVOID arg);
VOID    WaitForArbCompletion(PVOID arg);


DWORD	SrvInit(PVOID, PVOID, PVOID *);
DWORD	SrvOnline(PVOID, LPWSTR name, DWORD nic);
DWORD	SrvOffline(PVOID);
void	SrvExit(PVOID);

extern void WINAPI error_log(char *, ...);
extern void WINAPI debug_log(char *, ...);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\crs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    crs.h

Abstract:

    Consistency replica set data structures and API

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#ifndef _CRS_DEF
#define _CRS_DEF

#include <windows.h>
#include <assert.h>

#include <stdio.h>
#include <stdlib.h>

#define	CRS_VERSION	1
#define	CRS_TAG		( (CRS_VERSION << 24) | ('crs'))

// sizes must be power of 2
#define CRS_RECORD_SZ 64
#define	CRS_SECTOR_SZ	512
#define	CRS_RECORDS_PER_SECTOR	(CRS_SECTOR_SZ / CRS_RECORD_SZ)
#define	CRS_SECTOR_MASK	(CRS_RECORDS_PER_SECTOR - 1)
#define	CRS_MAX_GROUP_SZ       16

#define CRS_QUORUM(sz, total)   ((sz > total/2) || ((DWORD)sz >= CrsForcedQuorumSize))

#define	CRS_PREPARE	0x1
#define	CRS_COMMIT	0x2
#define	CRS_ABORT	0x4
#define	CRS_EPOCH	0x8
#define	CRS_DUBIOUS	0x10

typedef ULONGLONG	crs_id_t[2];

typedef ULONGLONG	crs_epoch_t;
typedef ULONGLONG	crs_seq_t;

typedef struct {
    crs_epoch_t	epoch;
    crs_seq_t	seq;
    UINT	state;
    UINT	tag;
}CrsHdr_t;

typedef struct {
    CrsHdr_t	hdr;
    char	data[CRS_RECORD_SZ - sizeof(CrsHdr_t)];
}CrsRecord_t;


typedef NTSTATUS (WINAPI *crs_callback_t)(PVOID hd, int nid,
				       CrsRecord_t *singlerec, 
				       int action, int mid);

#define CRS_STATE_INIT		0
#define CRS_STATE_RECOVERY	1
#define CRS_STATE_READ		2
#define CRS_STATE_WRITE		3

typedef struct {
    CRITICAL_SECTION	lock;

    // log file handle
    HANDLE	fh;

    crs_epoch_t	epoch;		// current epoch
    crs_seq_t	seq;		// current sequence
    CrsRecord_t	*buf;		// current sector
    int		last_record;    // last record in this sector
    int		max_records;	// max number of records in update file

    USHORT	refcnt;
    USHORT	leader_id;
    USHORT	lid;
    USHORT	state; 	// write, read, recovery, init
    BOOLEAN	pending;

    // client call back routine
    crs_callback_t	callback;
    PVOID		callback_arg;

}CrsInfo_t;


typedef struct _CrsRecoveryBlk_t {
    CrsInfo_t	*info, *minfo;
    int		nid, mid;
}CrsRecoveryBlk_t;

#if defined(QFS_DBG)
extern void WINAPI debug_log(char *, ...);
#define CrsLog(_x_)	debug_log _x_
#else
#define CrsLog(_x_)
#endif

#define	CRS_ACTION_REPLAY	0x0	// apply record on specified node
#define	CRS_ACTION_UNDO		0x1	// undo update record
#define	CRS_ACTION_COPY		0x2	// copy one replica to other
#define	CRS_ACTION_QUERY	0x3	// ask about outcome of specified record
#define	CRS_ACTION_DONE		0x4	// signal send of recovery

extern DWORD CrsForcedQuorumSize;

void
WINAPI
CrsSetForcedQuorumSize(DWORD size);

DWORD
WINAPI
CrsOpen(crs_callback_t callback, PVOID callback_arg, USHORT lid,
	WCHAR *log_name, int max_logsectors, HANDLE *hdl);

void
WINAPI
CrsClose(PVOID hd);

void
WINAPI
CrsFlush(PVOID hd);

DWORD
WINAPI
CrsStart(PVOID hd[], ULONG aset, int cluster_sz,
	 ULONG *wset, ULONG *rset, ULONG *fset);

PVOID
WINAPI
CrsPrepareRecord(PVOID hd, PVOID lrec, crs_id_t id, ULONG *retVal);

int
WINAPI
CrsCommitOrAbort(PVOID hd, PVOID lrec, int commit);

int
WINAPI
CrsCanWrite(PVOID hd);

crs_epoch_t
CrsGetEpoch(PVOID hd);

VOID CrsForceClose(CrsInfo_t *p);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\fs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fs.h

Abstract:

    Interface between srv and fs

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#ifndef __FS_INTERFACE_H__
#define __FS_INTERFACE_H__

// note: we assume DWORD and DWORDDLONG are defined (from windows.h)
#define UINT16	USHORT
#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef _BASETSD_H_
typedef DWORDLONG UINT64;    // a 64-bit unsigned value
typedef DWORD     UINT32;    // a 32-bit unsigned value
#endif

#ifndef MAXPATH
#define	MAXPATH 1024
#endif

typedef UINT64    TIME64;    // in units of 100ns since Jan 1, 1601 (AD)

#define fhandle_t USHORT

#define INVALID_UINT64    ((UINT64)(0))
#define INVALID_UINT32    ((UINT32)(0))
#define INVALID_TIME64    INVALID_UINT64
#define INVALID_FHANDLE_T ((fhandle_t)(-1))

    // disposition:
#define DISP_CREATE_NEW        0x10000000
#define DISP_CREATE_ALWAYS     0x20000000
#define DISP_OPEN_EXISTING     0x30000000
#define DISP_OPEN_ALWAYS       0x40000000
#define DISP_TRUNCATE_EXISTING 0x50000000
#define DISP_DIRECTORY         0x60000000
#define FS_DISP_MASK              0x70000000

    // access:
#define ACCESS_READ         0x00010000
#define ACCESS_WRITE        0x00020000
#define FS_ACCESS_MASK         0x00030000

    // cache:
#define CACHE_WRITE_THROUGH 0x01000000
#define CACHE_NO_BUFFERING  0x02000000
#define FS_CACHE_MASK          0x03000000

    // sharing:
#define SHARE_READ          0x00100000
#define SHARE_WRITE         0x00200000
#define FS_SHARE_MASK          0x00300000

    // flags = dispositions | access | sharing
#define FLAGS_MASK (FS_DISP_MASK | FS_ACCESS_MASK | FS_SHARE_MASK | FS_CACHE_MASK)

    // attributes:
#define ATTR_SYMLINK        0x00002000
#define ATTR_DIRECTORY      0x00000010
#define ATTR_READONLY       0x00000001
#define ATTR_HIDDEN         0x00000002
#define ATTR_SYSTEM         0x00000004
#define ATTR_ARCHIVE        0x00000020
#define ATTR_COMPRESSED     0x00000800
#define ATTR_OFFLINE        0x00001000
#define ATTR_MASK           (ATTR_SYMLINK  | ATTR_DIRECTORY |  \
                                        ATTR_READONLY | ATTR_HIDDEN    | \
                                        ATTR_SYSTEM   | ATTR_ARCHIVE   | \
                                        ATTR_COMPRESSED | ATTR_OFFLINE)

#define MAX_FS_NAME_LEN  64

    // file system attributes
typedef struct {
    CHAR  fs_name[MAX_FS_NAME_LEN];
    UINT64 total_units;
    UINT64 free_units;
    ULONG  sectors_per_unit;
    ULONG  bytes_per_sector;
}fs_attr_t;

typedef struct {
    // sizes
    UINT64 file_size;
    UINT64 alloc_size;
    // times
    TIME64 create_time;
    TIME64 access_time;
    TIME64 mod_time;
    // mode/attr
    UINT32 attributes;
}fattr_t;

typedef struct {
    UINT32	cookie;
    fattr_t	attribs;
    WCHAR	name[MAX_PATH];
} dirinfo_t;

typedef struct {
    DWORD	FsVer;
    DWORD (*FsCreate)(
            IN     PVOID       fshandle,
            IN     LPWSTR      name,
	    IN	   USHORT      name_len,
            IN     UINT32      flags, 
            IN     fattr_t*    attr, 
            OUT    fhandle_t*  handle,
            OUT    UINT32*     action
            );

    DWORD (*FsLookup)(
            IN     PVOID       fshandle,
            IN     LPWSTR	name, 
	    IN	   USHORT	len,
            OUT    fattr_t*    attr
            );

    DWORD (*FsSetAttr)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle,
            IN     fattr_t*    attr
            );

    DWORD (*FsSetAttr2)(
            IN     PVOID       fshandle,
	    IN	   LPWSTR	path,
	    IN	   USHORT	len,
            IN     fattr_t*    attr
            );

    DWORD (*FsGetAttr)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle, 
            OUT    fattr_t*    attr
            );

    DWORD (*FsClose)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle
            );

    DWORD (*FsWrite)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle, 
            IN     UINT32      offset, 
            IN OUT UINT16*     count, 
            IN     void*       buffer,
	    IN	   PVOID	context
            );

    DWORD (*FsRead)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle, 
            IN     UINT32      offset, 
            IN OUT UINT16*     count, 
            OUT    void*       buffer,
	    IN	   PVOID	context
            );


        // to use readir(), we do a create() with DISP_DIRECTORY
        // returns ERROR_NO_MORE_FILES when done...
    DWORD (*FsReadDir)(
            IN     PVOID       fshandle,
            IN     fhandle_t   dir, 
            IN     UINT32      cookie, 
            OUT    dirinfo_t*  buffer, 
            IN     UINT32      size, 
            OUT    UINT32*     entries_found
            );


    DWORD (*FsStatfs)(
            IN     PVOID       fshandle,
            OUT    fs_attr_t*  attr
            );

    DWORD (*FsRemove)(
            IN     PVOID       fshandle,
            IN     LPWSTR      name,
	    IN	   USHORT      len
            );

    DWORD (*FsRename)(
            IN     PVOID       fshandle,
            IN     LPWSTR      fromname, 
	    IN	   USHORT      from_len,
            IN     LPWSTR      toname,
	    IN	   USHORT      to_len
            );

    DWORD (*FsMkdir)(
            IN     PVOID       fshandle,
            IN     LPWSTR      name, 
	    IN	   USHORT	len,
            IN     fattr_t*    attr
            );

    DWORD (*FsRmdir)(
            IN     PVOID       fshandle,
            IN     LPWSTR      name,
	    IN	   USHORT	len
            );

    DWORD (*FsFlush)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle
            );

    DWORD (*FsLock)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle,
	    IN	   ULONG       offset,
	    IN	   ULONG       length,
	    IN	   ULONG       flags,
	    IN	   PVOID       context
            );

    DWORD (*FsUnlock)(
            IN     PVOID       fshandle,
            IN     fhandle_t   handle,
	    IN	   ULONG       offset,
	    IN	   ULONG       length
            );

    DWORD (*FsGetRoot)(
            IN     PVOID       fshandle,
	    IN OUT LPWSTR      fullpath
            );

    DWORD (*FsConnect)(
            IN      PVOID       fshandle,
            IN      DWORD       pid
            );
} FsDispatchTable;

#include "fsapi.h"

DWORD	
FsMount(PVOID hdl, LPWSTR root_name, USHORT uid, USHORT *tid);

void
FsDisMount(PVOID hdl, USHORT uid, USHORT tid);

DWORD
FsLogonUser(PVOID hdl, HANDLE token, LUID LogonId, USHORT *uid);

void
FsLogoffUser(PVOID hdl, LUID LogonId);

DWORD
LsaInit(
    HANDLE  *LsaHandle,
    ULONG   *AuthenticationPackage
    );

BOOL
LsaValidateLogon(
    HANDLE  LsaHandle,
    ULONG   AuthenticationPackage,
    LPBYTE  lpChallenge,
    UINT    cbChallengeSize,
    LPBYTE  lpResponse,
    UINT    cbResponseSize,
    LPSTR   lpszUserName,
    LPSTR   lpszDomainName,
    LUID    *pLogonId,
    PHANDLE phLogonToken
    );

BOOL
LsaGetChallenge(
    HANDLE  LsaHandle,
    ULONG   AuthenticationPackage,
    LPBYTE lpChallenge,
    UINT cbSize,
    PUINT lpcbChallengeSize
    );


FsDispatchTable *
FsGetHandle(PVOID FsCtx, USHORT tid, USHORT uid, PVOID *fshandle);

UINT32* FsGetFilePointerFromHandle(
    PVOID *fshdl,
    fhandle_t handle
);

#define EPRINT(_x_)	error_log _x_ 
#define DPRINT(_x_)	debug_log _x_ 

#define	SrvLogError(_x_)	EPRINT(_x_)

#define FsLogError(_x_)	EPRINT(_x_)
#define FsArbLog(_x_)	DPRINT(_x_)
#define FsLogReplay(_x_) DPRINT(_x_)
#define FsLogUndo(_x_)	DPRINT(_x_)

// enable this for now as rodga requested
#define QFS_DBG	1

// enable this if you want details logging

#ifdef QFS_DBG
#define xFsLog(_x_)	DPRINT(_x_)
#define FsLog(_x_)	DPRINT(_x_)
#define	SrvLog(_x_)	DPRINT(_x_)
#else
#define xFsLog(_x_)	
#define FsLog(_x_)	
#define	SrvLog(_x_)	
#endif

#endif /* __FS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\fsp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsp.h

Abstract:

    Private replication file system data structures and functions

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/

#ifndef FS_P_H
#define FS_P_H

#ifdef __cplusplus
extern "C" {
#endif

#include "crs.h"

typedef ULONGLONG 	fs_id_t[2];

#define	PAGESIZE	4*1024

#define FsTableSize	128

#define	FS_FID_NAME	"CRSFID$"
#define	FS_FID_NAME_LEN	7

#define MNS_REDIRECTOR   DD_NFS_DEVICE_NAME_U
#define MNS_TRANSPORT    L"\\Device\\NetbiosSmb"

// This is the delay in ms a MNS arbitrate thread should wait before trying to lock a share.
// This gives preference to the highest priority network. The actual delay of a thread.
// MNS_LOCK_DELAY * <Network Priority of the network>.
//
#define MNS_LOCK_DELAY   2000 

typedef struct {
    FILE_FULL_EA_INFORMATION hdr;
    CHAR		data[FS_FID_NAME_LEN+sizeof(fs_id_t)];
}fs_ea_t;

typedef struct {
    FILE_GET_EA_INFORMATION hdr;
    CHAR		data[FS_FID_NAME_LEN];
}fs_ea_name_t;

#define	FsInitEa(x) { \
    (x)->hdr.NextEntryOffset = 0; \
    (x)->hdr.Flags = 0; \
    (x)->hdr.EaNameLength = FS_FID_NAME_LEN; \
    strncpy((x)->hdr.EaName, FS_FID_NAME, FS_FID_NAME_LEN+1); \
    (x)->hdr.EaValueLength = sizeof(fs_id_t); \
}

#define	FsInitEaName(x) { \
    (x)->hdr.NextEntryOffset = 0; \
    (x)->hdr.EaNameLength = FS_FID_NAME_LEN; \
    strncpy((x)->hdr.EaName, FS_FID_NAME, FS_FID_NAME_LEN+1); \
}

#define	FsInitEaFid(x, fid) { \
    (fid) = (fs_id_t *) (&((x)->hdr.EaName[FS_FID_NAME_LEN+1])); \
}

#define xFsOpenRA(fd,hvol,name,sz) \
        xFsOpen(fd,hvol,name,sz,FILE_READ_EA | (FILE_GENERIC_READ & ~FILE_READ_DATA), \
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0)

#define xFsOpenWA(fd,hvol,name,sz) \
        xFsOpen(fd,hvol,name,sz, FILE_WRITE_EA | ((FILE_GENERIC_READ|FILE_GENERIC_WRITE)&~(FILE_READ_DATA|FILE_WRITE_DATA|FILE_APPEND_DATA)), \
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0)

#define xFsOpenRD(fd,hvol,id,sz) \
        xFsOpen(fd,hvol,name,sz,FILE_READ_EA | FILE_GENERIC_READ, \
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0)

#define xFsOpenWD(fd,hvol,name,sz) \
        xFsOpenById(fd,hvol,name,sz,FILE_WRITE_EA | fFILE_GENERIC_WRITE, \
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0)

#define LockType	CRITICAL_SECTION
#define	LockInit(x)	InitializeCriticalSection(&x)
#define	LockEnter(x)	EnterCriticalSection(&x)
#define	LockTryEnter(x)	TryEnterCriticalSection(&x)
#define	LockExit(x)	LeaveCriticalSection(&x)
#define   LockDestroy(x) DeleteCriticalSection(&x)

#define USE_RTL_RESOURCE 1

// Reader Writer Lock, Modeled on CSharedLock class, used by RPC.
typedef struct _RwLock {
#if USE_RTL_RESOURCE
RTL_RESOURCE            lock;
#else
    CRITICAL_SECTION    lock;
    HANDLE              hevent;
    LONG                readers;
    LONG                writers;
#endif    
} RwLock;

#if USE_RTL_RESOURCE

#define RwLockInit(p) RtlInitializeResource(&((p)->lock))
#define RwLockDelete(p) RtlDeleteResource(&((p)->lock))
#define RwLockShared(p) RtlAcquireResourceShared(&((p)->lock), TRUE)
#define RwLockExclusive(p) RtlAcquireResourceExclusive(&((p)->lock), TRUE)
#define RwUnlockShared(p) RtlReleaseResource(&((p)->lock))
#define RwUnlockExclusive(p) RtlReleaseResource(&((p)->lock))

// Two new functions courtesy of RTL.
#define RwLockUpgrade(p) RtlConvertSharedToExclusive(&((p)->lock))
#define RwLockDowngrade(p) RtlConvertExclusiveToShared(&((p)->lock))

#else

DWORD RwLockInit(RwLock *lock);
VOID RwLockDelete(RwLock *lock);
VOID RwLockShared(RwLock *lock);
VOID RwUnlockShared(RwLock *lock);
VOID RwLockExclusive(RwLock *lock);
VOID RwUnlockExclusive(RwLock *lock);

#endif

typedef enum _VOLUME_STATE {
    VolumeStateInit=0,
    VolumeStateOnlineReadonly=1,
    VolumeStateOnlineReadWrite=2,
    VolumeStateMax=3
} VOLUME_STATE;

typedef enum _HANDLE_STATE {
    HandleStateInit=0,
    HandleStateAssigned=1,
    HandleStateOpened=2
}HANDLE_STATE;
    
typedef struct _hdl_t {
    fs_id_t	        Id;
    UINT32	        Flags;
    HANDLE	        Fd[FsMaxNodes];
    UINT32          FilePointer;
    LPWSTR          FileName;
    HANDLE_STATE    hState;
}hdl_t;

// todo: if we want to support more than one tree/user we need to split this
typedef struct _USERINFO_ {
    LockType		Lock;
    // Add a refcnt, we can have multiple connects on an existing session
    DWORD		RefCnt;
    UINT16		Tid;
    UINT16		Uid;
    struct _VOLINFO_	*VolInfo;
    hdl_t		Table[FsTableSize];
    struct _USERINFO_	*Next;
}UserInfo_t;

typedef enum _ArbState_t {
    ARB_STATE_IDLE=     0,
    ARB_STATE_BUSY=     1,
    ARB_STATE_CANCEL=   2
}ArbState_t;

typedef enum _SHARE_STATE {
    SHARE_STATE_OFFLINE = 0,
    SHARE_STATE_ARBITRATED = 1,
    SHARE_STATE_ONLINE = 2,
}SHARE_STATE;

typedef struct WaitRegArg {
    HANDLE  notifyFd;
    PVOID   vol;
    DWORD   id;
}WaitRegArg_t;

// This is the node ip address list. The ipaddresses are ordered according to
// preference.
//
#define MAX_ADDR_NUM    10
#define MAX_ADDR_SIZE   100

typedef struct _AddrList_t {
    DWORD           AddrSz;
    WCHAR           Addr[MAX_ADDR_NUM][MAX_ADDR_SIZE];
    VOID            *arb;
    DWORD           NodeId;
}AddrList_t;

typedef struct _VOLINFO_ {
    VOLUME_STATE        State;
    RwLock              Lock;
    struct _VOLINFO_   *Next;
    UINT16              Tid;
    PVOID               CrsHdl[FsMaxNodes];	// crs log handles
    HANDLE              Fd[FsMaxNodes];	// root directory handles
    HANDLE              NotifyFd[FsMaxNodes];	// root directory notification handles
    HANDLE              WaitRegHdl[FsMaxNodes]; // Wait registration handles.
    HANDLE              NotifyChangeEvent[FsMaxNodes];
    WaitRegArg_t        WaitRegArgs[FsMaxNodes];
    HANDLE              TreeConnHdl[FsMaxNodes]; // Tree connect handle.
    ULONG               ReadSet;
    ULONG               WriteSet;
    ULONG               AliveSet;
    USHORT              LockUpdates;
    // AddrList_t          AddrList[FsMaxNodes]; // this has to be read during FsRegister().
    LPWSTR              DiskList[FsMaxNodes];
    DWORD               DiskListSz;
    UserInfo_t          *UserList;
    LPWSTR              Label;
    struct _FSCTX_     *FsCtx;
    WCHAR               *Root; // Share name: GUID$
    WCHAR               *LocalPath; // Local Path.(FsCtx_t->Root) %Windir%\Cluster\MNS.GUID$
    DWORD               ArbTime; // Max arbitration time.
    SHARE_STATE         ShareState[FsMaxNodes];
    LONG                NumArbsInProgress; // Keeps count of number of arbs.
    HANDLE              AllArbsCompleteEvent; // Set when all arbs in progress end.
    LockType            ArbLock; // Lock to access NumArbInProgress.
    BOOL                GoingAway;
    HANDLE              ClussvcTerminationHandle;
    HANDLE              ClussvcProcess;
}VolInfo_t; 

typedef struct _FspArbitrate_t {
    ArbState_t	        State;
    ULONG               OrigAliveSet;
    ULONG	            NewAliveSet;
    ULONG	            Count;
    ULONG               DiskListSz;
    VolInfo_t           *vol;
    HANDLE	            GotQuorumEvent; // Signalled when quorum is obtained or timeout reached.
    HANDLE              CleanupEvent;
    crs_epoch_t         epoch;

    // Need the following 3 arrays since we should not be modifying Volume while holding the
    // Read lock.
    PVOID               CrsHdl[FsMaxNodes]; // CRS Handles.
    HANDLE              Fd[FsMaxNodes];	// Root Directory Handles.
    HANDLE              NotifyFd[FsMaxNodes]; // Notify Handles.
    HANDLE              WaitRegHdl[FsMaxNodes];
    HANDLE              TreeConnHdl[FsMaxNodes];
    CRITICAL_SECTION    Lock; // <-- All access to this structure is through this lock.
}FspArbitrate_t;


typedef struct _SESSIONINFO_ {
    struct _SESSIONINFO_ *Next;
    UserInfo_t	TreeCtx;	// at tree connect time
}SessionInfo_t;

typedef struct _LOGONINFO_ {
    struct _LOGONINFO_ *Next;
    HANDLE	Token;
    LUID	LogOnId;
}LogonInfo_t;

typedef struct _FSCTX_ {
    LockType	Lock;
    VolInfo_t 	*VolList;
    DWORD	VolListSz;
    PVOID	reshdl;
    // list of logged on users that we have obtained valid lsa tokens
    // add an entry during session setup, when we assign a user an id
    // At tree connect, we validate the user and create a private structure
    // to hold state
    LogonInfo_t	*LogonList;
    SessionInfo_t *SessionList;
}FsCtx_t;
    
#define FS_GET_USER_HANDLE_OFFSET(u,f) (&(u)->Table[f].FilePointer)
#define FS_SET_USER_HANDLE(u,nid,f,h) ((u)->Table[f].Fd[nid] = h)
#define FS_GET_USER_HANDLE(u,nid,f) ((u)->Table[f].Fd[nid])
#define FS_GET_FID_HANDLE(u,f) (&(u)->Table[f].Id)
#define FS_GET_VOL_HANDLE(v,nid) ((v)->Fd[nid])
#define FS_GET_VOL_NAME(v,nid) ((v)->DiskList[nid])
#define FS_SET_VOL_HANDLE(v,nid,h) ((v)->Fd[nid] = (h))
#define FS_GET_CRS_HANDLE(v,n) ((v)->CrsHdl[nid])
#define FS_GET_CRS_NID_HANDLE(v,nid) ((v)->CrsHdl[(nid)])
#define FS_GET_VOL_NOTIFY_HANDLE(v,nid) ((v)->NotifyFd[nid])

#define FS_BUILD_LOCK_KEY(uid,nid,fid) ((uid << 16) | fid)

#define MemAlloc(x)	malloc(x)
#define	MemFree(x)	free(x)


typedef NTSTATUS (*fs_handler_t)(VolInfo_t *,UserInfo_t *,int,PVOID,ULONG,PVOID,ULONG_PTR *);
typedef NTSTATUS (*fs_handler1_t)(VolInfo_t *,UserInfo_t *,int,PVOID,ULONG,PVOID,ULONG_PTR *, PVOID);


#define FS_CREATE	0
#define FS_SETATTR	1
#define FS_WRITE	2
#define FS_MKDIR	3
#define FS_REMOVE	4
#define FS_RENAME	5

// 

typedef struct {
    crs_id_t	xid;
    UINT32	flags;
    UINT32	attr;
    LPWSTR	name;
    USHORT	name_len;
    USHORT	fnum;	// file number
}fs_create_msg_t;

typedef struct {
    fs_id_t	fid;
    USHORT	action;	// action taken
    USHORT	access;	// access granted
}fs_create_reply_t;

typedef struct {
    crs_id_t	xid;
    fs_id_t	*fs_id;
    FILE_BASIC_INFORMATION attr;
    union {
	struct {
	    USHORT	name_len;
	    LPWSTR	name;
	};
	USHORT	fnum;	// file number
    };
}fs_setattr_msg_t;

typedef struct {
    LPWSTR	name;
    int		name_len;
}fs_lookup_msg_t;

typedef struct {
    crs_id_t	xid;
    fs_id_t	*fs_id;
    union {
	UINT32	offset;
	UINT32	cookie;
    };
    UINT32	size;
    PVOID	buf;
    PVOID	context;
    USHORT	fnum;	// file number
}fs_io_msg_t;

typedef struct {
    crs_id_t	xid;
    fs_id_t	*fs_id;
    LPWSTR	name;
    int		name_len;
}fs_remove_msg_t;

typedef struct {
    crs_id_t	xid;
    fs_id_t	*fs_id;
    LPWSTR	sname;
    LPWSTR	dname;
    USHORT	sname_len;
    USHORT	dname_len;
}fs_rename_msg_t;

#define	FS_LOCK_WAIT	0x1
#define FS_LOCK_SHARED	0x2

typedef struct {
    crs_id_t	xid;
    USHORT	fnum;
    ULONG	offset;
    ULONG	length;
    ULONG	flags;
}fs_lock_msg_t;


#define EventWait(x)	WaitForSingleObject(x, INFINITE)

// Forward declaration
void
DecodeCreateParam(UINT32 uflags, UINT32 *flags, UINT32 *disp, UINT32 *share, UINT32 *access);

NTSTATUS
FspCreate(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf,
	  ULONG_PTR *rlen, PVOID rec);

NTSTATUS
FspSetAttr2(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf,
	    ULONG_PTR *rlen, PVOID rec);

NTSTATUS
FspMkDir(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec);

NTSTATUS
FspRemove(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec);

NTSTATUS
FspRename(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec);

NTSTATUS
FspWrite(VolInfo_t *vinfo, UserInfo_t *uinfo, int nid, PVOID args, ULONG len, PVOID rbuf, ULONG_PTR *rlen, PVOID rec);

void
FspEvict(VolInfo_t *vinfo, ULONG mask, BOOLEAN flag);

void
FspJoin(VolInfo_t *vinfo, ULONG mask);


//Consistency Replica Set
NTSTATUS
FsUndoXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int  mid);

NTSTATUS
FsReplayXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int mid);

// this must be 64 bytes
typedef struct {
    fs_id_t	id;	// crs epoch,seq
    ULONGLONG	crshdr;	// crs header
    fs_id_t 	fs_id;
    UINT32	command;
    UINT32	flags;
    union {
	char	buf[CRS_RECORD_SZ - (sizeof(ULONGLONG) * 5 + sizeof(int) * 2)];
	struct {
	    // create, set attrib
	    UINT32	attrib;
	};
	struct {
	    // write, lock
	    UINT32	offset;
	    UINT32	length;
	};
    };
}fs_log_rec_t;

typedef NTSTATUS (*FsReplayHandler_t)(VolInfo_t *info,
				      fs_log_rec_t *lrec,
				      int nid, int mid);

NTSTATUS
WINAPI
FsCrsCallback(PVOID hd, int nid, CrsRecord_t *arg, int action, int mid);

NTSTATUS
CreateTreeConnection(LPWSTR path, HANDLE *Fd);

DWORD
GetTargetNodeAddresses(AddrList_t *addrList);

DWORD
GetNodeName(DWORD nodeId, LPWSTR nodeName);

VOID
FsForceClose(PVOID par, BOOLEAN isFired);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\pipe.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pipe.h

Abstract:

    Header for pipe interface for rudimentary quorum access server

Author:

    Gor Nishanov (gorn) 20-Sep-2001

Revision History:

--*/

#ifndef _PIPE_H_INCLUDED
# define _PIPE_H_INCLUDED

DWORD
PipeInit(PVOID resHdl, PVOID fsHdl, PVOID *Hdl);

void
PipeExit(PVOID Hdl);

DWORD PipeOnline(PVOID Hdl, PVOID VolHdl);
DWORD PipeOffline(PVOID Hdl);
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\replay.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    replay.c

Abstract:

    Implements replay of records during replica recovery

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <stdio.h>
#include <ntddvol.h>
#include <string.h>
#include <assert.h>


#include "fs.h"
#include "fsp.h"

#include "fsutil.h"
#include <strsafe.h>

NTSTATUS
fs_replay_create(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_create_msg_t msg;
    fs_create_reply_t reply;
    WCHAR name[MAXPATH];
    int name_sz = sizeof(name);
    HANDLE      vfd = FS_GET_VOL_HANDLE(volinfo, mid);
    fs_log_rec_t myRec;


    name[0] = '\0';
    memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
    msg.flags = lrec->flags;
    msg.attr = lrec->attrib;

    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    FsLogReplay(("fs_replay_create: try %I64x:%I64x\n", lrec->id[0],
                  lrec->id[1]));

    err = xFsGetPathById(vfd, &lrec->id, name, &name_sz);

    if (err == STATUS_SUCCESS) {
        IO_STATUS_BLOCK ios;

        msg.name = xFsBuildRelativePath(volinfo, mid, name);
        msg.name_len = (USHORT) wcslen(msg.name);
        msg.fnum = INVALID_FHANDLE_T;

        ios.Information = sizeof(reply);
        err = FspCreate(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
                        (PVOID) &reply, &ios.Information, (PVOID)&myRec);
    }

    FsLogReplay(("fs_replay_create: %S err %x\n", name, err));

    return err;
}

NTSTATUS
fs_replay_setattr(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_setattr_msg_t msg;
    WCHAR       name[MAXPATH];
    int name_sz = sizeof(name);
    HANDLE      vfd = FS_GET_VOL_HANDLE(volinfo, nid);
    fs_log_rec_t myRec;    

    // find path for fs_id 
    FsLogReplay(("fs_replay_setattr: try %I64x:%I64x\n", lrec->fs_id[0],
                  lrec->fs_id[1]));

    err = xFsGetPathById(vfd, &lrec->fs_id, name, &name_sz);
    if (err == STATUS_SUCCESS) {
        IO_STATUS_BLOCK ios;

        ios.Information = 0;

        // todo: we need to read current attr from master and apply it into nid disk.
        // FileAttributes are not enough, we could have time changes which need to be
        // in sync in all disks.
        memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
        msg.fs_id = &lrec->fs_id;
        msg.name = xFsBuildRelativePath(volinfo, nid, name);
        msg.name_len = (USHORT) wcslen(msg.name);
        memset(&msg.attr, 0, sizeof(msg.attr));
        msg.attr.FileAttributes = lrec->attrib;

        err = FspSetAttr2(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
                         NULL, &ios.Information, (PVOID)&myRec);
    }
    FsLogReplay(("replay_setattr: %I64x err %x\n",
                 lrec->fs_id[0], err));

    return err;

}

NTSTATUS
fs_replay_mkdir(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_create_msg_t msg;
    WCHAR name[MAXPATH];
    int name_sz = sizeof(name);
    HANDLE      vfd = FS_GET_VOL_HANDLE(volinfo, mid);
    fs_log_rec_t myRec;

    name[0] = '\0';

    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    FsLogReplay(("fs_replay_mkdir: %I64x:%I64x\n", lrec->id[0],
                  lrec->id[1]));

    err = xFsGetPathById(vfd, &lrec->id, name, &name_sz);

    if (err == STATUS_SUCCESS) {
        IO_STATUS_BLOCK ios;

        ios.Information = 0;

        memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
        msg.name = xFsBuildRelativePath(volinfo, mid, name);
        msg.name_len = (USHORT) wcslen(msg.name);
        msg.flags = lrec->flags;
        msg.attr = lrec->attrib;

        err = FspMkDir(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
                       NULL, &ios.Information, (PVOID)&myRec);

    }

    FsLogReplay(("Replay Mkdir %S err %x\n", name, err));

    return err;
}


NTSTATUS
fs_replay_remove(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_remove_msg_t msg;
    // we find the objectid in the old replica, since file is already delete in master
    HANDLE ovfd = FS_GET_VOL_HANDLE(volinfo, nid);
    WCHAR name[MAXPATH];
    int name_sz = sizeof(name);
    fs_log_rec_t myRec;

    name[0] = '\0';

    FsLogReplay(("fs_relay_remove: %I64x:%I64x\n", lrec->fs_id[0],
                  lrec->fs_id[1]));

    err = xFsGetPathById(ovfd, &lrec->fs_id, name, &name_sz);

    if (err == STATUS_SUCCESS) {
        IO_STATUS_BLOCK ios;

        ios.Information = 0;

        memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
        msg.fs_id = &lrec->fs_id;
        msg.name = xFsBuildRelativePath(volinfo, nid, name);
        msg.name_len = (USHORT) wcslen(msg.name);

        err = FspRemove(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
                        NULL, &ios.Information, (PVOID)&myRec);

    }

    FsLogReplay(("Replay remove %S err %x\n", name, err));

    return err;
}


NTSTATUS
fs_replay_rename(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    fs_rename_msg_t msg;
    HANDLE      vfd = FS_GET_VOL_HANDLE(volinfo,mid);
    HANDLE      ovfd = FS_GET_VOL_HANDLE(volinfo, nid);
    WCHAR       old_name[MAXPATH];
    WCHAR       new_name[MAXPATH];
    int old_name_sz = sizeof(old_name);
    int new_name_sz = sizeof(new_name);
    fs_log_rec_t myRec;

    new_name[0] = old_name[0] = '\0';

    FsLogReplay(("fs_relay_rename: %I64x:%I64x\n", lrec->fs_id[0],
                  lrec->fs_id[1]));

    // get old name
    err = xFsGetPathById(ovfd, &lrec->fs_id, old_name, &old_name_sz);
    if (err == STATUS_SUCCESS) {
        IO_STATUS_BLOCK ios;

        ios.Information = 0;

        // get the new name
        err = xFsGetPathById(vfd, &lrec->fs_id, new_name, &new_name_sz);

        if (err == STATUS_OBJECT_PATH_NOT_FOUND) {
            NTSTATUS e;
            // if we can't find file in the master disk, we must
            // rename the file, pick a name based on file id
            StringCchPrintfW(new_name, MAXPATH, L"%s%I64x%I64x", old_name,
                    lrec->fs_id[0],lrec->fs_id[1]);
            new_name_sz = wcslen(new_name);
            err = STATUS_SUCCESS;
            mid = nid;
        }

        if (err == STATUS_SUCCESS) {


            memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
            msg.fs_id = &lrec->fs_id;
            msg.sname = xFsBuildRelativePath(volinfo, nid, old_name);
            msg.sname_len = (USHORT) wcslen(msg.sname);
            msg.dname = xFsBuildRelativePath(volinfo, mid, new_name);
            msg.dname_len = (USHORT) wcslen(msg.dname);
            
            err = FspRename(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg),
                            NULL, &ios.Information, (PVOID)&myRec);
        
        }
    }

    FsLogReplay(("Replay rename %S -> %S err %x\n", old_name, new_name, err));

    return err;
}


NTSTATUS
fs_replay_write(VolInfo_t *volinfo, fs_log_rec_t *lrec, int nid, int mid)
{
    NTSTATUS err;
    IO_STATUS_BLOCK ios;
    HANDLE shdl = INVALID_HANDLE_VALUE;
    HANDLE dhdl = INVALID_HANDLE_VALUE;
    char *buf = NULL;
    fs_io_msg_t msg;
    HANDLE      ovfd = FS_GET_VOL_HANDLE(volinfo, nid);
    HANDLE      vfd = FS_GET_VOL_HANDLE(volinfo, mid);
    fs_log_rec_t myRec;

    FsLogReplay(("fs_replay_write: %I64x:%I64x\n", lrec->fs_id[0],
                  lrec->fs_id[1]));

    // get the new file first
    err = xFsGetHandleById(vfd, &lrec->fs_id, FILE_READ_EA|FILE_GENERIC_READ, &shdl);

    if (err == STATUS_SUCCESS) {
        LARGE_INTEGER off;
        IO_STATUS_BLOCK ios2;

        ios2.Information = 0;

        // get old file
        err = xFsGetHandleById(ovfd, &lrec->fs_id, FILE_READ_EA|FILE_GENERIC_WRITE, &dhdl);
        if (err != STATUS_SUCCESS) {
            // this is a very bad error, must abort now
            FsLogReplay(("Aborting replay_write err %x\n", err));
            err = STATUS_TRANSACTION_ABORTED;
            goto done;
        }


        // we need to read the new data from the sfd first
        if (lrec->length > 0) {
            // allocate buf
            buf = VirtualAlloc(NULL, lrec->length, MEM_COMMIT, PAGE_READWRITE);

            if (buf == NULL) {
                FsLogError(("Unable to allocate write buffer to replay\n"));
                err = STATUS_TRANSACTION_ABORTED;
                goto done;
            }


            off.LowPart = lrec->offset;
            off.HighPart = 0;

            // read local data. xxx: what if the file is locked? 
            err = NtReadFile(shdl, NULL, NULL, NULL, &ios, buf,
                             lrec->length, &off, NULL);

            if (err == STATUS_PENDING) {
                EventWait(shdl);
                err = ios.Status;
            }

            if (err != STATUS_SUCCESS) {
                FsLogReplay(("Read failed for replay 0x%x\n", err));
                err = STATUS_TRANSACTION_ABORTED;
                goto done;
            }
        } else {
            buf = NULL;
            ios.Information = 0;
        }
                        
        memcpy(&msg.xid, lrec->id, sizeof(msg.xid));
        msg.fs_id = &lrec->fs_id;
        msg.offset = lrec->offset;
        msg.size = (UINT32)ios.Information;
        msg.buf = buf;
        msg.context = (PVOID) dhdl;
        msg.fnum = INVALID_FHANDLE_T;

        err = FspWrite(volinfo, NULL, nid, (PVOID) &msg, sizeof(msg), NULL, &ios2.Information, (PVOID)&myRec);
        // check if we have the same size, otherwise abort
        if ((ULONG)ios2.Information != lrec->length) {
            FsLogError(("Write sz mismatch, %d expected %d\n", (ULONG)ios2.Information, lrec->length));
            err = STATUS_TRANSACTION_ABORTED;
        }
    } else if (err != STATUS_OBJECT_PATH_NOT_FOUND) {
        err = STATUS_TRANSACTION_ABORTED;
    }

 done:
    if (buf != NULL) {
        VirtualFree(buf, 0, MEM_RELEASE);
    }

    if (shdl != INVALID_HANDLE_VALUE)
        xFsClose(shdl);

    if (dhdl != INVALID_HANDLE_VALUE)
        xFsClose(dhdl);

    FsLogReplay(("Replay write offset %d len %d err %x\n", 
                 lrec->offset, lrec->length, err));

    return err;
}


FsReplayHandler_t FsReplayCallTable[] = {
    fs_replay_create,
    fs_replay_setattr,
    fs_replay_write,
    fs_replay_mkdir,
    fs_replay_remove,
    fs_replay_rename
};

NTSTATUS
FsReplayFid(VolInfo_t *volinfo, UserInfo_t *uinfo, int nid, int mid)
{
    int i;
    // WCHAR path[MAXPATH];
    // WCHAR *name;
    int name_len;
    NTSTATUS err = STATUS_SUCCESS;

    // Open on replica nid all currently open files.
    for (i = 0; i < FsTableSize; i++) {
        HANDLE fd;
        UINT32 disp, share, access, flags;

        if (uinfo->Table[i].Flags == 0) {
            continue;
        }

        if (uinfo->Table[i].Fd[nid] != INVALID_HANDLE_VALUE) {
            continue;
        }

        // Perform replays on completely open handles only. partially opened handles
        // should be taken care of by the send*() functions.
        //
        if (uinfo->Table[i].hState != HandleStateOpened) {
            continue;
        }

#if 0        
        // todo: this should be in a for loop
        fd = uinfo->Table[i].Fd[mid];
        if (fd == INVALID_HANDLE_VALUE) 
            continue;
        
        // get path name
        name_len = sizeof(path);
        err = xFsGetHandlePath(fd, path, &name_len);
        if (err != STATUS_SUCCESS) {
            FsLogReplay(("FsReplayFid %d failed on handlpath %x\n",
                         mid, err));
            // todo: the master might have failed, we should just
            // try to go to a differnet replica if possible
            return err;
        }
        // issue open against nid, but first get filename from master
        name = xFsBuildRelativePath(volinfo, mid, path);
#endif

        DecodeCreateParam(uinfo->Table[i].Flags, &flags, &disp, &share, &access);

        err = xFsOpen(&fd, FS_GET_VOL_HANDLE(volinfo, nid),
                      uinfo->Table[i].FileName, wcslen(uinfo->Table[i].FileName),
                      access, share, 0);

        if (err != STATUS_SUCCESS) {
            FsLogReplay(("FsReplayFid mid %d nid %d open file '%S' failed %x\n",
                         mid, nid, uinfo->Table[i].FileName, err));
            // Cleanup all open handles we have before returning an
            // error. We cleanup this node later, so that's ok.
            return err;
        }

        FsLogReplay(("FsReplayFid mid %d nid %d file '%S' flags %x\n",
                     mid, nid, uinfo->Table[i].FileName, uinfo->Table[i].Flags));

        // we now add the open handle to the nid slot
        FS_SET_USER_HANDLE(uinfo, nid, i, fd);

        // todo: issue locks
    }
    return err;
}

NTSTATUS
FsReplayXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int mid)
{
    fs_log_rec_t        *p = (fs_log_rec_t *) arg;
    NTSTATUS            err = ERROR_SUCCESS;
    fs_id_t             *fs_id;
    HANDLE              vhdl;

    vhdl = FS_GET_VOL_HANDLE(volinfo, nid);
    if (vhdl == INVALID_HANDLE_VALUE) {
        FsLogUndo(("FsUndoXid Failed to get crs handle %d\n",
                     nid));
        return STATUS_TRANSACTION_ABORTED;
    }

    vhdl = FS_GET_VOL_HANDLE(volinfo, mid);
    if (vhdl == INVALID_HANDLE_VALUE) {
        FsLogReplay(("FsReplayXid Failed to get crs handle %d\n",
                     mid));
        return STATUS_TRANSACTION_ABORTED;
    }


    // note: use id instead of fs_id since we don't have fs_id till
    // a prepare has committed.
    fs_id = &p->id;

    FsLogReplay(("Replay cmd %d mid %d nid %d objid %I64x:%I64x\n", p->command,
                 mid, nid,
                 (*fs_id)[0], (*fs_id)[1]));

    err = FsReplayCallTable[p->command](volinfo, p, nid, mid);

    FsLogReplay(("Replay Status %x\n", err));

    return err;
}

NTSTATUS
FsQueryXid(VolInfo_t *volinfo, int nid, PVOID arg, int action, int mid)
{
    fs_log_rec_t        *p = (fs_log_rec_t *) arg;
    NTSTATUS            err = ERROR_SUCCESS;
    fs_id_t             *fs_id;
    HANDLE              vhdl;
    WCHAR               name[MAXPATH];
    int                 name_sz = sizeof(name);

    ASSERT(nid == mid);
    vhdl = FS_GET_VOL_HANDLE(volinfo, nid);
    if (vhdl == INVALID_HANDLE_VALUE) {
        FsLogUndo(("FsUndoXid Failed to get crs handle %d\n",
                     nid));
        return STATUS_TRANSACTION_ABORTED;
    }

    fs_id = &p->fs_id;

    FsLogReplay(("Query cmd %d nid %d objid %I64x:%I64x\n", p->command,
                 nid, (*fs_id)[0], (*fs_id)[1]));

    switch(p->command) {
    case FS_CREATE:
    case FS_MKDIR:
        // issue a lookup, 
        // note: use id instead of fs_id since we don't have fs_id till
        // a prepare has committed.
        fs_id = &p->id;
        err = xFsGetPathById(vhdl, fs_id, name, &name_sz);
        if (err == STATUS_OBJECT_PATH_NOT_FOUND)
            err = STATUS_CANCELLED;
        break;
    case FS_REMOVE:
        err = xFsGetPathById(vhdl, fs_id, name, &name_sz);
        if (err == STATUS_OBJECT_PATH_NOT_FOUND)
            err = STATUS_SUCCESS;
        else if (err == STATUS_SUCCESS)
            err = STATUS_CANCELLED;
        break;
    default:
        // can't make any determination
        err = STATUS_NOT_FOUND;
        break;
    }

    FsLogReplay(("Commit Status %x\n", err));

    return err;
}



////////////////////////// Recovery Callback ////////////////////////////


NTSTATUS
WINAPI
FsCrsCallback(PVOID hd, int nid, CrsRecord_t *arg, int action, int mid)
{
    NTSTATUS            err = STATUS_SUCCESS;
    VolInfo_t           *volinfo = (VolInfo_t *) hd;

    switch(action) {

    case CRS_ACTION_REPLAY:

        err = FsReplayXid(volinfo, nid, arg, action, mid);
        break;

    case CRS_ACTION_UNDO:

        err = FsUndoXid(volinfo, nid, arg, action, mid);
        break;

    case CRS_ACTION_QUERY:

        err = FsQueryXid(volinfo, nid, arg, action, mid);
        break;

    case CRS_ACTION_DONE:
        FsLogReplay(("Vol %S done recovery nid %d mid %d\n",
                     volinfo->Root, nid, mid));


        // we now need to walk our current open table and join this new replica.
        {
            UserInfo_t *u = volinfo->UserList;

            for (; u != NULL; u = u->Next) {
                err = FsReplayFid(volinfo, u, nid, mid);
                if (err != STATUS_SUCCESS)
                    break;
            }
        }
        break;

    case CRS_ACTION_COPY:

        FsLogReplay(("FullCopy Disk%d -> Disk%d\n", mid, nid));

        //
        // We need to open new directory handles instead of using current ones. Otherwise,
        // our enum on directory might not be consistent
        //
        if (0) {
            WCHAR       path[MAXPATH];
            HANDLE      mvfd, ovfd;
            UINT32      disp;

            // open root volume directory
            disp = FILE_OPEN;
            StringCchPrintfW(path, MAXPATH, L"\\??\\%s\\%s\\", FS_GET_VOL_NAME(volinfo, mid), volinfo->Root);
            err = xFsCreate(&mvfd, NULL, path, wcslen(path),
                            FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT,
                            0,
                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                            &disp,
                            FILE_GENERIC_READ|FILE_GENERIC_WRITE|FILE_GENERIC_EXECUTE,
                            NULL, 0);
            if (err != STATUS_SUCCESS) {
                FsLogReplay(("Failed to open mid %d '%S' err %x\n", mid, path, err));
                return err;
            }

            // open root volume directory
            disp = FILE_OPEN;
            StringCchPrintfW(path, MAXPATH, L"\\??\\%s\\%s\\", FS_GET_VOL_NAME(volinfo, nid), volinfo->Root);
            err = xFsCreate(&ovfd, NULL, path, wcslen(path),
                            FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_ALERT,
                            0,
                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                            &disp,
                            FILE_GENERIC_READ|FILE_GENERIC_WRITE|FILE_GENERIC_EXECUTE,
                            NULL, 0);
            if (err != STATUS_SUCCESS) {
                xFsClose(mvfd);
                FsLogReplay(("Failed to open nid %d '%S' err %x\n", mid, path, err));
                return err;
            }

            
            err = xFsCopyTree(mvfd, ovfd);
            xFsClose(mvfd);
            xFsClose(ovfd);
        } else {
            err = xFsCopyTree(FS_GET_VOL_HANDLE(volinfo, mid),
                              FS_GET_VOL_HANDLE(volinfo,nid));

        }
        FsLogReplay(("SlowStart Crs%d status %x\n", nid, err));

        break;

    default:
        FsLogReplay(("Unknown action %d\n", action));
        ASSERT(FALSE);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\fsutil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsutil.h

Abstract:

    Forward declarations

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#ifndef _FS_UTIL_H
#define _FS_UTIL_H

NTSTATUS
xFsCreate(HANDLE *fd, HANDLE root, LPWSTR name, int len, UINT32 flag,
	  UINT32 attrib, UINT32 share, UINT32 *disp, UINT32 access,
	  PVOID eabuf, int easz);

NTSTATUS
xFsOpen(HANDLE *fd, HANDLE root, LPWSTR name, int len, UINT32 access,
	UINT32 share, UINT32 flags);

NTSTATUS
xFsOpenEx(HANDLE *fd, HANDLE root, LPWSTR buf, int n, UINT32 access,
        UINT32 share, UINT32 flags);
        
#define xFsClose(fd)	NtClose(fd)

NTSTATUS
xFsQueryObjectId(HANDLE fd, PVOID id);

NTSTATUS
xFsDelete(HANDLE root, LPWSTR name, int len);

NTSTATUS
xFsQueryObjectId(HANDLE fd, PVOID id);

NTSTATUS
xFsQueryAttrName(HANDLE root, LPWSTR name, int len, FILE_NETWORK_OPEN_INFORMATION *attr);

NTSTATUS
xFsRename(HANDLE fh, HANDLE root, LPWSTR dname, int dlen);

NTSTATUS
xFsDupFile(HANDLE mvfd, HANDLE tvfd, LPWSTR name, int len, BOOLEAN flag);

NTSTATUS
xFsSetAttr(HANDLE fd, FILE_BASIC_INFORMATION *attr);

NTSTATUS
xFsQueryAttr(HANDLE fd, FILE_NETWORK_OPEN_INFORMATION *attr);

NTSTATUS
xFsReadDir(HANDLE fd, PVOID buf, int *rlen, BOOLEAN flag);

NTSTATUS
xFsCopyTree(HANDLE mvfd, HANDLE vfd);

NTSTATUS
xFsDeleteTree(HANDLE vfd);

NTSTATUS
xFsTouchTree(HANDLE vfd);

#ifdef FS_P_H

extern 
LPWSTR
xFsBuildRelativePath(VolInfo_t *vol, int nid, LPWSTR path);

NTSTATUS
xFsGetHandleById(HANDLE root, fs_id_t *id, UINT32 access, HANDLE *fhdl);

DWORD
xFsGetHandlePath(HANDLE fd, LPWSTR path, int *pathlen);

NTSTATUS
xFsGetPathById(HANDLE vfd, fs_id_t *id, LPWSTR name, int *name_len);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\majoritynodeset.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    MajorityNodeSet.c

Abstract:

    Resource DLL for Majority Node Set (MajorityNodeSet).

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

    George Potts (gpotts) 05, 17, 2001
    Renamed from Node Quorum to Majority Node Set 

--*/

#pragma comment(lib, "clusapi.lib")
#pragma comment(lib, "resutils.lib")

#define UNICODE 1

#pragma warning( disable : 4115 )  // named type definition in parentheses
#pragma warning( disable : 4201 )  // nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )  // nonstandard extension used : bit field types other than int

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>

#pragma warning( default : 4214 )  // nonstandard extension used : bit field types other than int
#pragma warning( default : 4201 )  // nonstandard extension used : nameless struct/union
#pragma warning( default : 4115 )  // named type definition in parentheses


#include <clusapi.h>
#include <clusudef.h>
#include <resapi.h>
#include <stdio.h>
#include "clusres.h"
#include "fsapi.h"
#include "pipe.h"
#include "crs.h"        // for crssetforcedquorumsize()
#include "clusrtl.h"

// Enable MNS to auconfig, allowing MNS config parameters can be a security risk.
//
#define ENABLE_MNS_AUTOCONFIG_ONLY 1

//
// Define a separate MNS resource Class. So that DTC doesn't try to use it a disk #573603.
// Use a unique ID obtained from resclass@microsoft.com.
//
#define CLUS_RESCLASS_MAJORITY_NODE_SET 32775

//
// Type and constant definitions.
//
#ifdef STANDALONE_DLL

#define MajorityNodeSetDllEntryPoint DllEntryPoint
#define MNS_RESNAME  L"Majority Node Set"

// Event Logging routine.
PLOG_EVENT_ROUTINE g_LogEvent = NULL;
// Resource Status routine for pending Online and Offline calls.
PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL;

#else

// Event Logging routine.
#define g_LogEvent ClusResLogEvent
// Resource Status routine for pending Online and Offline calls.
#define g_SetResourceStatus ClusResSetResourceStatus
#endif // end of standalone_DLL

// ADDPARAM: Add new parameters here.
#define PARAM_NAME__PATH L"Path"
#define PARAM_NAME__ALLOWREMOTEACCESS L"AllowRemoteAccess"
#define PARAM_NAME__DISKLIST L"DiskList"

#define PARAM_MIN__ALLOWREMOTEACCESS     (0)
#define PARAM_MAX__ALLOWREMOTEACCESS     (4294967295)
#define PARAM_DEFAULT__ALLOWREMOTEACCESS (0)

#define MUTEX_FILE_NAME L"MajorityNodeSet_FileMutex"

// ADDPARAM: Add new parameters here.
typedef struct _MNS_PARAMS {
    PWSTR           Path;
    DWORD           AllowRemoteAccess;
    PWSTR           DiskList;
    DWORD           DiskListSize;
} MNS_PARAMS, *PMNS_PARAMS;

// Once we have UNC support in service, we need to disable this flag
// #define USE_DRIVE_LETTER 1

typedef struct _MNS_SETUP {
    LPWSTR      Path;

#ifdef USE_DRIVE_LETTER
    WCHAR       DriveLetter[10];
#else
#define DriveLetter Path
#endif

    LPWSTR      DiskList[FsMaxNodes];
    DWORD       DiskListSz;
    DWORD       Nic;
    LPWSTR      Transport;
    DWORD       ArbTime;
} MNS_SETUP, *PMNS_SETUP;

typedef struct _MNS_RESOURCE {
    RESID                   ResId; // for validation
    MNS_PARAMS              Params;
    HKEY                    ParametersKey;
    RESOURCE_HANDLE         ResourceHandle;
    LPWSTR                  ResourceName;
    CLUS_WORKER             OnlineThread;
    CLUS_WORKER             ReserveThread;
    CLUSTER_RESOURCE_STATE  State;
    PQUORUM_RESOURCE_LOST   LostQuorumResource;

    CRITICAL_SECTION        Lock;
    HANDLE                  ArbThread;
    HANDLE                  hMutexFile;

    PVOID                   PipeHdl;
    PVOID                   FsHdl;
    PVOID                   VolHdl;

    MNS_SETUP        Setup;
} MNS_RESOURCE, *PMNS_RESOURCE;


#define MNS_ONLINE_PERIOD    (4 * 1000)
#define MNS_RESERVE_PERIOD   (4 * 1000)

//
// Global data.
//
RESOURCE_HANDLE         g_resHdl = 0;

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE MajorityNodeSetFunctionTable;

#ifdef ENABLE_MNS_AUTOCONFIG_ONLY
RESUTIL_PROPERTY_ITEM
MajorityNodeSetResourcePrivateProperties[] = {{ 0 }};
#else
//
// MajorityNodeSet resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
MajorityNodeSetResourcePrivateProperties[] = {
    { PARAM_NAME__PATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(MNS_PARAMS,Path) },
    { PARAM_NAME__ALLOWREMOTEACCESS, NULL, CLUSPROP_FORMAT_DWORD, PARAM_DEFAULT__ALLOWREMOTEACCESS, PARAM_MIN__ALLOWREMOTEACCESS, PARAM_MAX__ALLOWREMOTEACCESS, 0, FIELD_OFFSET(MNS_PARAMS,AllowRemoteAccess) },
    { PARAM_NAME__DISKLIST, NULL, CLUSPROP_FORMAT_MULTI_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET(MNS_PARAMS,DiskList) },
    { 0 }
};
#endif

#define MajorityNodeSetIoctlPhase1   CLUSCTL_USER_CODE(0, CLUS_OBJECT_RESOURCE)

//
// Function prototypes.
//
extern
DWORD
SetupIoctlQuorumResource(LPWSTR ResType, DWORD ControlCode);

extern
DWORD
SetupDelete(IN LPWSTR Path);

extern
DWORD
SetupStart(LPWSTR ResourceName, LPWSTR *SrvPath,
       LPWSTR *DiskList, DWORD *DiskListSize,
       DWORD *NicId, LPWSTR *Transport, DWORD *ArbTime);

DWORD
GetIDFromRegistry(IN HKEY hClusKey, IN LPWSTR resname, OUT LPWSTR *id);

DWORD
SetupShare(LPWSTR name, LPWSTR *lpath);

extern
DWORD
SetupTree(
    IN LPTSTR TreeName,
    IN LPTSTR DlBuf,
    IN OUT DWORD *DlBufSz,
    IN LPTSTR TransportName OPTIONAL,
    IN LPVOID SecurityDescriptor OPTIONAL
    );

RESID
WINAPI
MajorityNodeSetOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

VOID
WINAPI
MajorityNodeSetClose(
    IN RESID ResourceId
    );

DWORD
WINAPI
MajorityNodeSetOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    );

DWORD
WINAPI
MajorityNodeSetOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PMNS_RESOURCE ResourceEntry
    );

DWORD
WINAPI
MajorityNodeSetOffline(
    IN RESID ResourceId
    );

VOID
WINAPI
MajorityNodeSetTerminate(
    IN RESID ResourceId
    );

DWORD
MajorityNodeSetDoTerminate(
    IN PMNS_RESOURCE ResourceEntry
    );

BOOL
WINAPI
MajorityNodeSetLooksAlive(
    IN RESID ResourceId
    );

BOOL
WINAPI
MajorityNodeSetIsAlive(
    IN RESID ResourceId
    );

BOOL
MajorityNodeSetCheckIsAlive(
    IN PMNS_RESOURCE ResourceEntry
    );

DWORD
WINAPI
MajorityNodeSetResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
MajorityNodeSetGetPrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
MajorityNodeSetValidatePrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PMNS_PARAMS Params
    );

DWORD
MajorityNodeSetSetPrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    IN const PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
MajorityNodeSetGetDiskInfo(
    IN LPWSTR  lpszPath,
    OUT PVOID *OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    ) ;

DWORD
WINAPI
MajorityNodeSetReserveThread(
    PCLUS_WORKER WorkerPtr,
    IN PMNS_RESOURCE ResourceEntry
    );


DWORD
WINAPI
MajorityNodeSetRelease(
    IN RESID ResourceId
    );

DWORD
MajorityNodeSetReadDefaultValues(
    PMNS_RESOURCE ResourceEntry
    );


BOOLEAN
WINAPI
MajorityNodeSetDllEntryPoint(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )

/*++

Routine Description:

    Main DLL entry point.

Arguments:

    DllHandle - DLL instance handle.

    Reason - Reason for being called.

    Reserved - Reserved argument.

Return Value:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);

} // DllMain

#ifdef STANDALONE_DLL

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    ResourceType - The type of resource requesting a function table.

    MinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    MaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    SetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    LogEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( lstrcmpiW( ResourceType, MNS_RESNAME ) != 0 ) {
        (LogEvent)(
            NULL,
            LOG_ERROR,
            L"MajorityNodeSet: %1 %2.\n", ResourceType, MNS_RESNAME);

        return(ERROR_MOD_NOT_FOUND);
    }

    if ( !g_LogEvent ) {
        g_LogEvent = LogEvent;
        g_SetResourceStatus = SetResourceStatus;
    }

    *FunctionTable = &MajorityNodeSetFunctionTable;

    return(ERROR_SUCCESS);

} // Startup

#endif

DWORD OpenMutexFileExclusive(
    IN RESOURCE_HANDLE ResourceHandle,
    IN LPWSTR Name, 
    OUT HANDLE* pHandle
    )
{
    WCHAR fname[MAX_PATH];
    DWORD Status;
    int ccLen = wcslen(Name);

    *pHandle = INVALID_HANDLE_VALUE;    
    if ( ( Status = ClRtlGetClusterDirectory( fname, MAX_PATH - ccLen - 1) ) != ERROR_SUCCESS )
    {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"OpenMutexFileExclusive: Error %1!d! in getting cluster dir !!!\n", Status);
        goto exit_gracefully;
    }
    wcscat(fname, L"\\");
    wcscat(fname, Name);
    *pHandle = CreateFile(
        fname,                            // file name
        GENERIC_READ | GENERIC_WRITE,               // access mode
        0,         // No sharing whatsoever
        NULL, // SD
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_TEMPORARY | FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_DELETE_ON_CLOSE, // file attributes
        NULL                        // handle to template file
        );

    if (*pHandle == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Only one resource of MNS type is supported. Status: %1!u!.\n",
            Status );
    }
    
exit_gracefully:
    
    return Status;        
}



RESID
WINAPI
MajorityNodeSetOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for MajorityNodeSet resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    ResourceName - Supplies the name of the resource to open.

    ResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    ResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called. See the 
        description of the SetResourceStatus and LogEvent methods on the
        MajorityNodeSetStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    DWORD               status;
    DWORD               disposition;
    RESID               resid = 0;
    HKEY                parametersKey = NULL;
    PMNS_RESOURCE resourceEntry = NULL;

    //
    // Open the Parameters registry key for this resource.
    //

    status = ClusterRegOpenKey( ResourceKey,
                                L"Parameters",
                                KEY_READ,
                                &parametersKey);

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open Parameters key. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Allocate a resource entry.
    //

    resourceEntry = (PMNS_RESOURCE) LocalAlloc( LMEM_FIXED, sizeof(MNS_RESOURCE) );
    if ( resourceEntry == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Initialize the resource entry..
    //

    ZeroMemory( resourceEntry, sizeof(MNS_RESOURCE) );

    resourceEntry->ResId = (RESID)resourceEntry; // for validation
    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->State = ClusterResourceOffline;
    resourceEntry->hMutexFile = INVALID_HANDLE_VALUE;

    // todo: get ride off this hack. See bug # 389483
    if (g_resHdl == 0)
        g_resHdl = resourceEntry->ResourceHandle;

    // initialize lock
    InitializeCriticalSection(&resourceEntry->Lock);    

    //
    // Save the name of the resource.
    //
    resourceEntry->ResourceName = LocalAlloc( LMEM_FIXED, (lstrlenW( ResourceName ) + 1) * sizeof(WCHAR) );
    if ( resourceEntry->ResourceName == NULL ) {
        status = GetLastError();
        goto exit;
    }
    lstrcpyW( resourceEntry->ResourceName, ResourceName );

    status = OpenMutexFileExclusive(ResourceHandle, MUTEX_FILE_NAME, &resourceEntry->hMutexFile);
    if (status != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // Setup stuff
    //
    memset(&resourceEntry->Setup, 0, sizeof(resourceEntry->Setup));

    //
    // If we are the quorum, we need to make sure the share has been created. So,
    // we call setup now.
    //
#if 0    
    {
        HKEY    hClusKey=NULL;
        LPWSTR  guid=NULL, lpath=NULL;

        status = RegOpenKeyExW(HKEY_LOCAL_MACHINE, CLUSREG_KEYNAME_CLUSTER, 0, KEY_READ, &hClusKey);
        if (status != ERROR_SUCCESS) {
            goto setup_done;
        }

        status = GetIDFromRegistry(hClusKey, resourceEntry->ResourceName, &guid);
        if (status != ERROR_SUCCESS) {
            goto setup_done;
        }
        
        wcscat(guid, L"$");
        status = SetupShare(guid, &lpath);

setup_done:

        if (guid) {
            LocalFree(guid);
        }
        if (lpath) {
            LocalFree(lpath);
        }
        if (hClusKey) {
            RegCloseKey(hClusKey);
        }
    }

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Open share setup status %1!u!.\n", status);

#else
    // read from private properties
    status = MajorityNodeSetReadDefaultValues(resourceEntry);
    if (status != ERROR_SUCCESS || resourceEntry->Setup.DiskListSz == 0) {
        // read from our own setup stuff
        status = SetupStart(resourceEntry->ResourceName,
                            &resourceEntry->Setup.Path,
                            resourceEntry->Setup.DiskList,
                            &resourceEntry->Setup.DiskListSz,
                            &resourceEntry->Setup.Nic,
                            &resourceEntry->Setup.Transport,
                            &resourceEntry->Setup.ArbTime);

        (g_LogEvent)(

            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Open %1 setup status %2!u!.\n", ResourceName, status);
    }

#endif

    // init fs
    if (status == ERROR_SUCCESS) {

        status = FsInit((PVOID)resourceEntry, &resourceEntry->FsHdl);


        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Open %1 fs status %2!u!.\n", ResourceName, status);
    }

    // init pipe srv
    if (status == ERROR_SUCCESS) {
        status = PipeInit((PVOID)resourceEntry, resourceEntry->FsHdl,
                         &resourceEntry->PipeHdl);
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Open %1 pipe status %2!u!.\n", ResourceName, status);
    }
#ifdef ENABLE_SMB    
    // init srv
    if (status == ERROR_SUCCESS) {
        status = SrvInit((PVOID)resourceEntry, resourceEntry->FsHdl,
                         &resourceEntry->SrvHdl);
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Open %1 srv status %2!u!.\n", ResourceName, status);
    }
#endif
    if (status == ERROR_SUCCESS) {
        resid = (RESID)resourceEntry;

        //
        // Startup for the resource.
        //
    }

 exit:

    (g_LogEvent)(
        ResourceHandle,
        LOG_INFORMATION,
        L"Open %1 status %2!u!.\n", ResourceName, status);

    if ( resid == 0 ) {
        if (resourceEntry) {
            if (g_resHdl == resourceEntry->ResourceHandle) {
                g_resHdl = NULL;
            }
            MajorityNodeSetClose((RESID)resourceEntry);
        } else if ( parametersKey != NULL ) {
            ClusterRegCloseKey( parametersKey );
        }
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return(resid);

} // MajorityNodeSetOpen



VOID
WINAPI
MajorityNodeSetClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for MajorityNodeSet resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
    PMNS_RESOURCE resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }


    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );

    //
    // Hack: Check if we are online, just return. This must be the RPC run-down stuff
    //
    if (resourceEntry->VolHdl && 
        (FsIsOnlineReadonly(resourceEntry->VolHdl) == ERROR_SUCCESS))
        return;

    //
    // Close the Parameters key.
    //

    if ( resourceEntry->ParametersKey ) {
        ClusterRegCloseKey( resourceEntry->ParametersKey );
    }

    //
    // Sync any arb threads
    //
    if (resourceEntry->ArbThread) {
        WaitForSingleObject(resourceEntry->ArbThread, INFINITE);
        CloseHandle(resourceEntry->ArbThread);
        resourceEntry->ArbThread = NULL;
    }

    if (resourceEntry->PipeHdl) {
        PipeExit(resourceEntry->PipeHdl);
    }

    if (resourceEntry->FsHdl) {
        FsExit(resourceEntry->FsHdl);
    }

    //
    // Deallocate setup stuff
    //
    if (resourceEntry->Setup.Path) {
        LocalFree( resourceEntry->Setup.Path);
    }

    if (resourceEntry->Setup.DiskList) {
        DWORD i;
        for (i = 0; i < FsMaxNodes; i++) {
            if (resourceEntry->Setup.DiskList[i] != NULL)
                LocalFree(resourceEntry->Setup.DiskList[i]);
        }
    }

    if (resourceEntry->Setup.Transport) {
        LocalFree( resourceEntry->Setup.Transport);
    }

    // ADDPARAM: Add new parameters here.
    if ( resourceEntry->Params.Path )
        LocalFree( resourceEntry->Params.Path );

    if ( resourceEntry->Params.DiskList )
        LocalFree( resourceEntry->Params.DiskList );

    
    if ( resourceEntry->ResourceName )
        LocalFree( resourceEntry->ResourceName );

    if (resourceEntry->hMutexFile != INVALID_HANDLE_VALUE) {
        CloseHandle(resourceEntry->hMutexFile);
    }

    DeleteCriticalSection(&resourceEntry->Lock);

    LocalFree( resourceEntry );

    g_resHdl = 0; // [HACKHACK] Assumes that there could be only one MNS resource

} // MajorityNodeSetClose



DWORD
WINAPI
MajorityNodeSetOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for MajorityNodeSet resources.

    Bring the specified resource online (available for use). The resource
    DLL should attempt to arbitrate for the resource if it is present on a
    shared medium, like a shared SCSI bus.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    EventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some 
        other systems and one of the other systems won the arbitration.

    ERROR_IO_PENDING - The request is pending, a thread has been activated 
        to process the online request. The thread that is processing the 
        online request will periodically report status by calling the 
        SetResourceStatus callback method, until the resource is placed into 
        the ClusterResourceOnline state (or the resource monitor decides to 
        timeout the online request and Terminate the resource. This pending 
        timeout value is settable and has a default value of 3 minutes.).

    Win32 error code - The operation failed.

--*/

{
    PMNS_RESOURCE resourceEntry = NULL;
    DWORD               status;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }


    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n" );


    resourceEntry->State = ClusterResourceOffline;
    ClusWorkerTerminate( &resourceEntry->OnlineThread );
    status = ClusWorkerCreate( &resourceEntry->OnlineThread,
                               (PWORKER_START_ROUTINE)MajorityNodeSetOnlineThread,
                               resourceEntry );
    if ( status != ERROR_SUCCESS ) {
        resourceEntry->State = ClusterResourceFailed;
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // MajorityNodeSetOnline


DWORD
MajorityNodeSetReadDefaultValues(PMNS_RESOURCE ResourceEntry)
{
    return ERROR_NOT_SUPPORTED;
} // MajorityNodeSetReadDefaultValues

DWORD
MajorityNodeSetDoRegister(IN PMNS_RESOURCE ResourceEntry)
{
    DWORD       status = ERROR_SUCCESS;

    if (ResourceEntry->VolHdl == NULL) {
        // if we have no volume handle, read config now

        // read from private properties
        status = MajorityNodeSetReadDefaultValues(ResourceEntry);

        if ((status != ERROR_SUCCESS) || (ResourceEntry->Setup.DiskListSz == 0)) {

            // read from our own setup stuff
            status = SetupStart(ResourceEntry->ResourceName,
                                &ResourceEntry->Setup.Path,
                                ResourceEntry->Setup.DiskList,
                                &ResourceEntry->Setup.DiskListSz,
                                &ResourceEntry->Setup.Nic,
                                &ResourceEntry->Setup.Transport,
                                &ResourceEntry->Setup.ArbTime);

        }

        
        if (status == ERROR_SUCCESS) {
            LPWSTR ShareName, IpcName;


            // register volume
            ShareName = ResourceEntry->Setup.Path + 2;
            ShareName = wcschr(ShareName, L'\\');
            ASSERT(ShareName);
            ShareName++;
            ASSERT(*ShareName != L'\0');
            
            IpcName = ResourceEntry->Setup.DiskList[0];
            if (IpcName == NULL) {
                // We use first replica. This must be the case when our private property is set
                IpcName = ResourceEntry->Setup.DiskList[1];
            }
            ASSERT(IpcName);
            status = FsRegister(ResourceEntry->FsHdl,
                                ShareName,      // share name
                                IpcName, // ipc local name
                                ResourceEntry->Setup.DiskList,  // replica set
                                ResourceEntry->Setup.DiskListSz,        // num of replicas
                                ResourceEntry->Setup.ArbTime,
                                &ResourceEntry->VolHdl);

        }
    }


    return status;

}




DWORD
WINAPI
MajorityNodeSetOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PMNS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    ResourceEntry - A pointer to the MNS_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{
    RESOURCE_STATUS     resourceStatus;
    DWORD               i, status = ERROR_SUCCESS, status1;

    ASSERT(ResourceEntry != NULL);

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"onlinethread request.\n"
        );

    // Get lock
    EnterCriticalSection(&ResourceEntry->Lock);

    // There are two cases here. If the MNS resource is the quorum, arbitration has
    // already been called, then try to avoid arbitrating again. To do this call into
    // FsIsOnlineReadWrite(). If MNS is not the quorum we would have to do arbitration.
    //
    // NOTE: Here we are trying to get MNS online. This is a bit different from just arbitrate
    // path. Arbitrate path is optimized to return ASAP, even before FspJoin completes, but here
    // we need to wait till FspJoin completes and then verify that the volume is in
    // VolumeStateOnlineReadWrite state.
    //
    status = MajorityNodeSetDoRegister(ResourceEntry);

    if (status == ERROR_SUCCESS) {
        HANDLE th;
        PVOID arb;
        HANDLE Cleanup;

        ASSERT(ResourceEntry->VolHdl);
        status = FsIsOnlineReadWrite(ResourceEntry->VolHdl);

        if (status != ERROR_SUCCESS) {

            // We need to start a new arbitration or else wait for the current arbitrate
            // thread to complete.
            //
            status = ERROR_SUCCESS;
            if (ResourceEntry->ArbThread != NULL) {
                // check if this is an old completed handle
                status1 = WaitForSingleObject(ResourceEntry->ArbThread, 0);
                if (status1 != WAIT_TIMEOUT) {
                    CloseHandle(ResourceEntry->ArbThread);
                    ResourceEntry->ArbThread = NULL;
                    arb = FsArbitrate(ResourceEntry->VolHdl, &Cleanup, &ResourceEntry->ArbThread);
                    if (arb == NULL) {
                        status = GetLastError();
                    }
                    else {
                        // Set the cleanup event now, else the arbitrate thread would get
                        // stuck forever.
                        SetEvent(Cleanup);
                    }
                }
            }
            else {
                arb = FsArbitrate(ResourceEntry->VolHdl, &Cleanup, &ResourceEntry->ArbThread);
                if (arb == NULL) {
                    status = GetLastError();
                }
                else {
                    SetEvent(Cleanup);
                }
            }

            if (status == ERROR_SUCCESS) {
                // Now wait for the arbitrate thread to exit.
                //
                while (ResourceEntry->ArbThread != NULL) {
                    // The ArbThread handle might be closed from other places, so duplicate it
                    // instead of copying.
                    //
                    th = INVALID_HANDLE_VALUE;
                    DuplicateHandle(
                        GetCurrentProcess(),
                        ResourceEntry->ArbThread,
                        GetCurrentProcess(),
                        &th,
                        0,
                        FALSE,
                        DUPLICATE_SAME_ACCESS);
                    ASSERT(th != INVALID_HANDLE_VALUE);
                    LeaveCriticalSection(&ResourceEntry->Lock);
                    do {
                        // inform rcmon that we are working
                        resourceStatus.ResourceState = ClusterResourceOnlinePending;
                        resourceStatus.CheckPoint++;
                        g_SetResourceStatus( ResourceEntry->ResourceHandle,
                                     &resourceStatus );

                        (g_LogEvent)(
                            ResourceEntry->ResourceHandle,
                            LOG_INFORMATION,
                            L"waiting for fs to online %1!u!.\n",
                            status );

                        status = WaitForSingleObject(th, MNS_ONLINE_PERIOD);
                    } while (status == WAIT_TIMEOUT);
                    CloseHandle(th);
                    EnterCriticalSection(&ResourceEntry->Lock);
                    if (ResourceEntry->ArbThread != NULL) {
                        status1 = WaitForSingleObject(ResourceEntry->ArbThread, 0);
                        if (status1 != WAIT_TIMEOUT) {
                            CloseHandle(ResourceEntry->ArbThread);
                            ResourceEntry->ArbThread = NULL;
                        }
                    }
                }
                LeaveCriticalSection(&ResourceEntry->Lock);
                    
            }
            else {
                LeaveCriticalSection(&ResourceEntry->Lock);
            }
            // arbitrate thread must have finished, check if we are online or not
            status = FsIsOnlineReadWrite(ResourceEntry->VolHdl);
        }
        else {
            LeaveCriticalSection(&ResourceEntry->Lock);
        }
    } 
    else {
        // drop lock
        LeaveCriticalSection(&ResourceEntry->Lock);
    }
    
    if (status == ERROR_SUCCESS) {
        status = PipeOnline(ResourceEntry->PipeHdl, ResourceEntry->Setup.Path);
    }

#ifdef ENABLE_SMB
    if (status == ERROR_SUCCESS) {
        LPWSTR SrvName;
        // Online server
        SrvName = ResourceEntry->Setup.Path + 2;
        status = SrvOnline(ResourceEntry->SrvHdl, SrvName,
                           ResourceEntry->Setup.Nic);
    }


    //
    // Bring drive letter online
    //
    if (status == ERROR_SUCCESS) {
        PDWORD psz = NULL;
#ifdef USE_DRIVE_LETTER
        DWORD sz;
        sz = sizeof(ResourceEntry->Setup.DriveLetter);
        psz = &sz;
#endif
        // todo: create security descriptor and pass it onto tree
        status = SetupTree(ResourceEntry->Setup.Path,
                           ResourceEntry->Setup.DriveLetter, psz,
                           ResourceEntry->Setup.Transport, NULL);
        status = ERROR_SUCCESS;
#ifdef USE_DRIVE_LETTERxx
        if (status == ERROR_DUP_NAME)
            status = ERROR_SUCCESS;
#endif
        if (status == ERROR_SUCCESS) {
#ifdef USE_DRIVE_LETTER
            ResourceEntry->Setup.DriveLetter[sz] = L'\0';
#endif
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Resource %1 mounted on drive %2.\n",
                ResourceEntry->ResourceName,
                ResourceEntry->Setup.DriveLetter);
        } else {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"failed to setup tree path %1 drive %2 %3!u!.\n",
                ResourceEntry->Setup.Path,
                ResourceEntry->Setup.DriveLetter,
                status);
        }
    }
#endif

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error %1!u! bringing resource online.\n",
            status );
        resourceStatus.ResourceState = ClusterResourceFailed;
    } else {
        resourceStatus.ResourceState = ClusterResourceOnline;
    }

    // _ASSERTE(g_SetResourceStatus != NULL);
    g_SetResourceStatus( ResourceEntry->ResourceHandle, &resourceStatus );
    ResourceEntry->State = resourceStatus.ResourceState;

    return(status);

} // MajorityNodeSetOnlineThread



DWORD
WINAPI
MajorityNodeSetOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for MajorityNodeSet resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    PMNS_RESOURCE resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }


    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n" );


    // TODO: Offline code

    // NOTE: Offline should try to shut the resource down gracefully, whereas
    // Terminate must shut the resource down immediately. If there are no
    // differences between a graceful shut down and an immediate shut down,
    // Terminate can be called for Offline, as it is below.  However, if there
    // are differences, replace the call to Terminate below with your graceful
    // shutdown code.

    //
    // Terminate the resource.
    //
    return MajorityNodeSetDoTerminate( resourceEntry );

} // MajorityNodeSetOffline



VOID
WINAPI
MajorityNodeSetTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for MajorityNodeSet resources.

    Take the specified resource offline immediately (the resource is
    unavailable for use).

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
    PMNS_RESOURCE resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" );

    //
    // Terminate the resource.
    //
    MajorityNodeSetDoTerminate( resourceEntry );
    resourceEntry->State = ClusterResourceOffline;

} // MajorityNodeSetTerminate



DWORD
MajorityNodeSetDoTerminate(
    IN PMNS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Do the actual Terminate work for MajorityNodeSet resources.

Arguments:

    ResourceEntry - Supplies resource entry for resource to be terminated

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    DWORD       status = ERROR_SUCCESS;

    // Set the volume going away flag.
    FsSignalShutdown(ResourceEntry->VolHdl);
    
    // Get lock
    EnterCriticalSection(&ResourceEntry->Lock);

    //
    // wait for arb thread if any
    //
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"DoTerminate: Wait for any arbitration threads to finish.\n" );

    while (ResourceEntry->ArbThread) {
        HANDLE th = ResourceEntry->ArbThread;
        // drop lock
        LeaveCriticalSection(&ResourceEntry->Lock);

        WaitForSingleObject(ResourceEntry->ArbThread, INFINITE);

        // Get lock
        EnterCriticalSection(&ResourceEntry->Lock);
        if (th == ResourceEntry->ArbThread) {
            CloseHandle(ResourceEntry->ArbThread);
            ResourceEntry->ArbThread = NULL;
        }
    }

    // Drop lock
    LeaveCriticalSection(&ResourceEntry->Lock);

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"DoTerminate: Now kill off any pending Online or Reserve threads.\n" );

    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &ResourceEntry->OnlineThread );

    ClusWorkerTerminate( &ResourceEntry->ReserveThread );

    //
    // Terminate the resource.
    //
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offlining server.\n" );

#ifdef ENABLE_SMB    
    // Remove our network name now
    ASSERT(ResourceEntry->SrvHdl);
    SrvOffline(ResourceEntry->SrvHdl);
#endif
    PipeOffline(ResourceEntry->PipeHdl);

#ifdef ENABLE_SMB
    // disconnect network connection
    status = WNetCancelConnection2(ResourceEntry->Setup.DriveLetter, FALSE, TRUE);
    if (status != NO_ERROR) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Failed to disconnect '%1' err %2!d!.\n",
            ResourceEntry->Setup.DriveLetter, status);

        status = ERROR_SUCCESS;
    } else {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"DoTerminate: Server is now offline and connections cancelled.\n" );
    }
#endif
    // xxx: call our release since resmon won't do it
    MajorityNodeSetRelease((RESID)ResourceEntry);
    
    if ( status == ERROR_SUCCESS ) {
        ResourceEntry->State = ClusterResourceOffline;
    }


    return(status);

} // MajorityNodeSetDoTerminate



BOOL
WINAPI
MajorityNodeSetLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for MajorityNodeSet resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PMNS_RESOURCE  resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n" );
#endif

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    //
    // Check to see if the resource is alive.
    //
    return(MajorityNodeSetCheckIsAlive( resourceEntry ));

} // MajorityNodeSetLooksAlive



BOOL
WINAPI
MajorityNodeSetIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for MajorityNodeSet resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PMNS_RESOURCE  resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" );
#endif

    //
    // Check to see if the resource is alive.
    //
    return(MajorityNodeSetCheckIsAlive( resourceEntry ));

} // MajorityNodeSetIsAlive



BOOL
MajorityNodeSetCheckIsAlive(
    IN PMNS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Check to see if the resource is alive for MajorityNodeSet resources.

Arguments:

    ResourceEntry - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    DWORD err;
    HANDLE vol;

    //
    // Check to see if the resource is alive.
    //
    if (ResourceEntry->State == ClusterResourceFailed) {
        return FALSE;
    }
    else {
        return TRUE;
    }

    // Not reliable in the new design.    
    // Get lock
    EnterCriticalSection(&ResourceEntry->Lock);
    vol = ResourceEntry->VolHdl;
    // Drop lock
    LeaveCriticalSection(&ResourceEntry->Lock);
    if (vol) {
        err = FsIsOnlineReadonly(vol);
    }
    else {
        err = ERROR_INVALID_PARAMETER;
    }
    
    if (err != ERROR_SUCCESS && err != ERROR_IO_PENDING) {
        return FALSE;
    }
    
    return(TRUE);

} // MajorityNodeSetCheckIsAlive


/////////////////////////////////////////////////////////////////////////////
//++
//
//	MajorityNodeSetNameHandler
//
//	Description:
//		Handle the CLUSCTL_RESOURCE_SET_NAME control code by saving the new
//		name of the resource.
//
//	Arguments:
//		pResourceEntry [IN OUT]
//			Supplies the resource entry on which to operate.
//
//		pszName [IN]
//			The new name of the resource.
//
//	Return Value:
//		ERROR_SUCCESS
//			The function completed successfully.
//
//		Win32 error code
//			The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD MajorityNodeSetNameHandler(
	IN OUT	PMNS_RESOURCE       pResourceEntry,
	IN		LPWSTR              pszName
	)
{
	DWORD	nStatus = ERROR_SUCCESS;
    DWORD   cbNameBuffer;
    HRESULT hr = S_OK;

    //
    // Save the name of the resource.
    //
    if (pResourceEntry->ResourceName != NULL) {
        LocalFree(pResourceEntry->ResourceName);
    }
    cbNameBuffer = (lstrlenW(pszName) + 1) * sizeof(WCHAR);
    pResourceEntry->ResourceName = LocalAlloc(LMEM_FIXED, cbNameBuffer);
    if (pResourceEntry->ResourceName == NULL)
    {
        nStatus = GetLastError();
        (g_LogEvent)(
            pResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Failed to allocate memory for the new resource name '%1'. Error %2!u!.\n",
            pszName,
            nStatus
            );
        goto Cleanup;
    } // if: error allocating memory for the name.

    lstrcpyW( pResourceEntry->ResourceName, pszName );

Cleanup:

	return nStatus;

} //*** MajorityNodeSetNameHandler()

/////////////////////////////////////////////////////////////////////////////
//
// System Check Functions.
//
/////////////////////////////////////////////////////////////////////////////


DWORD
WINAPI
MajorityNodeSetResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for MajorityNodeSet resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PMNS_RESOURCE  resourceEntry;
    DWORD               required;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

		case CLUSCTL_RESOURCE_SET_NAME:
		    if (InBuffer != NULL) {
			    status = MajorityNodeSetNameHandler(
							resourceEntry,
							InBuffer
							);
		    }
		    else {
		        status = ERROR_INVALID_PARAMETER;
		    }
			break;


        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( MajorityNodeSetResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_FORCE_QUORUM:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            if (InBufferSize >= sizeof(CLUS_FORCE_QUORUM_INFO)) {
                PCLUS_FORCE_QUORUM_INFO p = (PCLUS_FORCE_QUORUM_INFO)InBuffer;
                DWORD mask = p->dwNodeBitMask;
                // count number of set bits.
                for (required = 0; mask != 0; mask = mask >> 1) {
                    if (mask & 0x1)
                        required++;
                }

                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_INFORMATION,
                    L"Setting quorum size = %1!u!.\n",
                    required/2+1);

                // BugFix: 653110
                CrsSetForcedQuorumSize((required/2)+1);
            } else {
                status = ERROR_INVALID_PARAMETER;
            }
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
            *BytesReturned = sizeof(DWORD);
            if ( OutBufferSize < sizeof(DWORD) ) {
                status = ERROR_MORE_DATA;
            } else {
                LPDWORD ptrDword = OutBuffer;
                *ptrDword = CLUS_CHAR_QUORUM | CLUS_CHAR_DELETE_REQUIRES_ALL_NODES | CLUS_CHAR_REQUIRES_STATE_CHANGE_REASON;
                status = ERROR_SUCCESS;                    
            }
            break;

        case CLUSCTL_RESOURCE_STATE_CHANGE_REASON:
            status = ERROR_SUCCESS;
            if (InBufferSize == sizeof(CLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT)) {
                PCLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT pStateChangeReason=(PCLUSCTL_RESOURCE_STATE_CHANGE_REASON_STRUCT)InBuffer;

                // Do this only for rundown not shutdown.
                if (pStateChangeReason->eReason == eResourceStateChangeReasonRundown) {
                    FsSignalShutdown(resourceEntry->VolHdl);
                }
            } else {
                status = ERROR_INVALID_PARAMETER;
            }
            break;
            
        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
            *BytesReturned = sizeof(CLUS_RESOURCE_CLASS_INFO);
            if ( OutBufferSize < sizeof(CLUS_RESOURCE_CLASS_INFO) ) {
                status = ERROR_MORE_DATA;
            } else {
                PCLUS_RESOURCE_CLASS_INFO ptrResClassInfo = (PCLUS_RESOURCE_CLASS_INFO) OutBuffer;
                ptrResClassInfo->rc = CLUS_RESCLASS_MAJORITY_NODE_SET;
                ptrResClassInfo->SubClass = (DWORD) CLUS_RESSUBCLASS_SHARED;
                status = ERROR_SUCCESS;
            }
            break;

        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
            //
            // If the local quorum drive letter cannot be found in the
            // path parameter, it defaults to "SystemDrive" environment 
            // variable.
            //
            status = MajorityNodeSetGetDiskInfo(resourceEntry->Setup.DriveLetter,
                                  &OutBuffer,
                                  OutBufferSize,
                                  BytesReturned);


            // Add the endmark.
            if ( OutBufferSize > *BytesReturned ) {
                OutBufferSize -= *BytesReturned;
            } else {
                OutBufferSize = 0;
            }
            *BytesReturned += sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize >= sizeof(CLUSPROP_SYNTAX) ) {
                PCLUSPROP_SYNTAX ptrSyntax = (PCLUSPROP_SYNTAX) OutBuffer;
                ptrSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
            }
      
            break;
        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( MajorityNodeSetResourcePrivateProperties,
                                            (LPWSTR)OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            status = MajorityNodeSetGetPrivateResProperties( resourceEntry,
                                                      OutBuffer,
                                                      OutBufferSize,
                                                      BytesReturned );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            status = MajorityNodeSetValidatePrivateResProperties( resourceEntry,
                                                           InBuffer,
                                                           InBufferSize,
                                                           NULL );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            status = MajorityNodeSetSetPrivateResProperties( resourceEntry,
                                                      InBuffer,
                                                      InBufferSize );
            break;

        case CLUSCTL_RESOURCE_DELETE:

            // todo: we need to only do this if are using local defaults.
            // we need to remove our share and directory now
            if (resourceEntry->Setup.DiskList[0]) {
                // need to end IPC session in order to be able to delete
                // directory
                FsEnd(resourceEntry->FsHdl);
                status = SetupDelete(resourceEntry->Setup.DiskList[0]);
            } else {
                status = ERROR_INVALID_PARAMETER;
            }


            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Delete ResourceId = %1 err %2!u!.\n",
                resourceEntry->ResourceName, status);
        
            break;

        // We need to find which node got added and adjust our
        // disklist. If we are online or we own quorum, then we need
        // to add this new replica to current filesystem set.
        case CLUSCTL_RESOURCE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_EVICT_NODE:
            (g_LogEvent)(
                resourceEntry->ResourceHandle,
                LOG_INFORMATION,
                L"Recompute %1 quorum set changed, Install or Evict node = '%2'.\n",
                resourceEntry->ResourceName, (InBuffer ? InBuffer : L""));
            // fall through

        case MajorityNodeSetIoctlPhase1:
        // we need to enumerate the current cluster and check it against
        // our disklist. we need to do this only if we actually have some
        if (1) {
            MNS_SETUP Setup;

            memset(&Setup, 0, sizeof(Setup));
            status = SetupStart(resourceEntry->ResourceName,
                                &Setup.Path,
                                Setup.DiskList,
                                &Setup.DiskListSz,
                                &Setup.Nic,
                                &Setup.Transport,
                                &Setup.ArbTime);

            if (status != ERROR_SUCCESS)
                return status;

            EnterCriticalSection(&resourceEntry->Lock);
            
            if (resourceEntry->Setup.DiskListSz != Setup.DiskListSz)
                status = ERROR_INVALID_PARAMETER;
            else {
                DWORD i;

                for (i = 0; i < FsMaxNodes; i++) {
                    if (Setup.DiskList[i] == NULL && resourceEntry->Setup.DiskList[i] == NULL)
                        continue;
                    if (Setup.DiskList[i] == NULL || resourceEntry->Setup.DiskList[i] == NULL) {
                        status = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (wcscmp(Setup.DiskList[i],
                               resourceEntry->Setup.DiskList[i])) {
                        status = ERROR_INVALID_PARAMETER;
                        break;
                    }
                }
            }

            if (status != ERROR_SUCCESS && resourceEntry->VolHdl) {
                // Update ourself now
                status = FsUpdateReplicaSet(resourceEntry->VolHdl,
                                            Setup.DiskList,
                                            Setup.DiskListSz);

                if (status == ERROR_SUCCESS) {
                    DWORD i;
                    // we need to free the current disklist, careful with slot 0
                    if (Setup.DiskList[0])
                        LocalFree(Setup.DiskList[0]);
                    for (i = 1; i < FsMaxNodes; i++) {
                        if (resourceEntry->Setup.DiskList[i]) {
                            LocalFree(resourceEntry->Setup.DiskList[i]);
                        }
                        resourceEntry->Setup.DiskList[i] = Setup.DiskList[i];
                    }
                    resourceEntry->Setup.DiskListSz = Setup.DiskListSz;
                }

                // set new arb timeout value
                resourceEntry->Setup.ArbTime = Setup.ArbTime;

                (g_LogEvent)(
                    resourceEntry->ResourceHandle,
                    LOG_WARNING,
                    L"Configuration change, new set size %1!u! status %2!u!.\n",
                    Setup.DiskListSz, status
                    );
            }

            LeaveCriticalSection(&resourceEntry->Lock);

                // free stuff
            if (Setup.Path)
                LocalFree(Setup.Path);

            if (Setup.Transport)
                LocalFree(Setup.Transport);

        }

        break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // MajorityNodeSetResourceControl



DWORD
WINAPI
MajorityNodeSetResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for MajorityNodeSet resources.

    Perform the control request specified by ControlCode.

Arguments:

    ResourceTypeName - Supplies the name of the resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status = ERROR_INVALID_FUNCTION;
    DWORD               required;

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_ARB_TIMEOUT:
        {
            PCLUSPROP_DWORD     ptrDword;
            DWORD               bytesReturned;
            
            // Return the Arbitration Timeout value needed - 180.
            bytesReturned = sizeof(CLUSPROP_DWORD);
            *BytesReturned = bytesReturned;
            if ( bytesReturned <= OutBufferSize ) {
                ptrDword = (PCLUSPROP_DWORD)OutBuffer;
                ptrDword->Syntax.dw = CLUSPROP_SYNTAX_LIST_VALUE_DWORD;
                ptrDword->cbLength = sizeof(DWORD);
                ptrDword->dw = 180;
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
            break;
        }            
            
        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            status = ResUtilGetPropertyFormats( MajorityNodeSetResourcePrivateProperties,
                                                OutBuffer,
                                                OutBufferSize,
                                                BytesReturned,
                                                &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            status = ResUtilEnumProperties( MajorityNodeSetResourcePrivateProperties,
                                            (LPWSTR)OutBuffer,
                                            OutBufferSize,
                                            BytesReturned,
                                            &required );
            if ( status == ERROR_MORE_DATA ) {
                *BytesReturned = required;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_STARTING_PHASE1:
            status = SetupIoctlQuorumResource(CLUS_RESTYPE_NAME_MAJORITYNODESET,
                                              MajorityNodeSetIoctlPhase1);
            break;

        case CLUSCTL_RESOURCE_TYPE_STARTING_PHASE2:
            status = ERROR_SUCCESS;
        break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // MajorityNodeSetResourceTypeControl



DWORD
MajorityNodeSetGetPrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control function
    for resources of type MajorityNodeSet.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    OutBuffer - Returns the output data.

    OutBufferSize - Supplies the size, in bytes, of the data pointed
        to by OutBuffer.

    BytesReturned - The number of bytes returned in OutBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status;
    DWORD           required;

    status = ResUtilGetAllProperties( ResourceEntry->ParametersKey,
                                      MajorityNodeSetResourcePrivateProperties,
                                      OutBuffer,
                                      OutBufferSize,
                                      BytesReturned,
                                      &required );
    if ( status == ERROR_MORE_DATA ) {
        *BytesReturned = required;
    }

    return(status);

} // MajorityNodeSetGetPrivateResProperties



DWORD
MajorityNodeSetValidatePrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PMNS_PARAMS Params
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
    function for resources of type MajorityNodeSet.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    Params - Supplies the parameter block to fill in.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    MNS_PARAMS   params;
    PMNS_PARAMS  pParams;

    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Duplicate the resource parameter block.
    //
    if ( Params == NULL ) {
        pParams = &params;
    } else {
        pParams = Params;
    }
    ZeroMemory( pParams, sizeof(MNS_PARAMS) );
    status = ResUtilDupParameterBlock( (LPBYTE) pParams,
                                       (LPBYTE) &ResourceEntry->Params,
                                       MajorityNodeSetResourcePrivateProperties );
    if ( status != ERROR_SUCCESS ) {
        return(status);
    }

    //
    // Parse and validate the properties.
    //
    status = ResUtilVerifyPropertyTable( MajorityNodeSetResourcePrivateProperties,
                                         NULL,
                                         TRUE, // AllowUnknownProperties
                                         InBuffer,
                                         InBufferSize,
                                         (LPBYTE) pParams );

    if ( status == ERROR_SUCCESS ) {
        //
        // Validate the parameter values.
        //
        // TODO: Code to validate interactions between parameters goes here.
        // we need to validate that the user specified '\\srvname\share'
        if (pParams->Path != NULL) {
            if (pParams->Path[0] != L'\\' || pParams->Path[1] != L'\\' || lstrlenW(pParams->Path) < 3) {
                status = ERROR_INVALID_PARAMETER;
            } else {
                LPWSTR sharename;

                sharename = wcschr(&pParams->Path[2], L'\\');
                if (sharename == NULL || sharename[1] == L'\0') {
                    status = ERROR_INVALID_PARAMETER;
                }
            }

        }

        // we need to validate user specified disklist 'drive:\path or \\srv\path'
        if (pParams->DiskList != NULL) {
            DWORD cnt = 0, i, len;
            LPWSTR p;

            p = pParams->DiskList;

            for (i = 0; p != NULL && *p != L'\0' && i < pParams->DiskListSize; ) {

                // validate format as '\\srvname\share'
                if (p[0] == L'\\' && p[1] == L'\\' && p[2] != L'\0') {
                    if (wcschr(&p[2],L'\\') == NULL) {
                        status = ERROR_INVALID_PARAMETER;
                    }
                } else if (p[0] == L'\0' || !iswalpha(p[0]) || p[1] != L':' || p[2] != L'\\') {
                    status = ERROR_INVALID_PARAMETER;
                }

                if (status != ERROR_INVALID_PARAMETER)
                    break;

                cnt++;
                len = wcslen(p) + 1;
                i += (len * sizeof(WCHAR));
                p += len;
            }

            if (cnt == 0)
                status = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Cleanup our parameter block.
    //
    if ( pParams == &params ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   MajorityNodeSetResourcePrivateProperties );
    }

    return status;

} // MajorityNodeSetValidatePrivateResProperties



DWORD
MajorityNodeSetSetPrivateResProperties(
    IN OUT PMNS_RESOURCE ResourceEntry,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control function
    for resources of type MajorityNodeSet.

Arguments:

    ResourceEntry - Supplies the resource entry on which to operate.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_INVALID_PARAMETER - The data is formatted incorrectly.

    ERROR_NOT_ENOUGH_MEMORY - An error occurred allocating memory.

    Win32 error code - The function failed.

--*/

{
    DWORD           status = ERROR_SUCCESS;
    MNS_PARAMS   params;

    //
    // Parse the properties so they can be validated together.
    // This routine does individual property validation.
    //
    ZeroMemory( &params, sizeof(params));
    status = MajorityNodeSetValidatePrivateResProperties( ResourceEntry, InBuffer, InBufferSize, &params );
    if ( status != ERROR_SUCCESS ) {
        ResUtilFreeParameterBlock( (LPBYTE) &params,
                                   (LPBYTE) &ResourceEntry->Params,
                                   MajorityNodeSetResourcePrivateProperties );
        return(status);
    }

    //
    // Save the parameter values.
    //

    status = ResUtilSetPropertyParameterBlock( ResourceEntry->ParametersKey,
                                               MajorityNodeSetResourcePrivateProperties,
                                               NULL,
                                               (LPBYTE) &params,
                                               InBuffer,
                                               InBufferSize,
                                               (LPBYTE) &ResourceEntry->Params );

    ResUtilFreeParameterBlock( (LPBYTE) &params,
                               (LPBYTE) &ResourceEntry->Params,
                               MajorityNodeSetResourcePrivateProperties );

    //
    // If the resource is online, return a non-success status.
    //
    // TODO: Modify the code below if your resource can handle
    // changes to properties while it is still online.
    if ( status == ERROR_SUCCESS ) {
        if ( ResourceEntry->State == ClusterResourceOnline ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else if ( ResourceEntry->State == ClusterResourceOnlinePending ) {
            status = ERROR_RESOURCE_PROPERTIES_STORED;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    return status;

} // MajorityNodeSetSetPrivateResProperties

DWORD
WINAPI
MajorityNodeSetReserveThread(
    PCLUS_WORKER WorkerPtr,
    IN PMNS_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    ResourceEntry - A pointer to the MNS_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    PVOID   vol;


    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"MNS FsReserve thread start.\n"
        );

    //
    // todo: this should wait on a notify port and listen for 
    //  1- New nodes added to the cluster.
    //  2- Nodes removed from the cluster.
    //  3- Network priority changes.
    //  4- Network binding (added, removed, state) changes.
    //
    // check if we are being killed
    do {
        if (ResourceEntry->State != ClusterResourceFailed) {
#if 0            
            vol=NULL;
            // don't hold any locks as not to hold back an arb
            EnterCriticalSection(&ResourceEntry->Lock);

            // Check if arbitration is going on, then don't do this.
            if (ResourceEntry->ArbThread != NULL) {
                DWORD err;
                err = WaitForSingleObject(ResourceEntry->ArbThread, 0);
                if (err != WAIT_TIMEOUT) {
                    vol = ResourceEntry->VolHdl;
                }
            }
            else {
                vol = ResourceEntry->VolHdl;
            }
            
            LeaveCriticalSection(&ResourceEntry->Lock);
#else
            vol = ResourceEntry->VolHdl;
            WaitForArbCompletion(vol);
#endif
            if (vol)
                status = FsReserve(vol);
        } else {
            status = ERROR_INVALID_PARAMETER;
        }

        if (status == ERROR_SHUTDOWN_IN_PROGRESS) {
            goto error_exit;
        }
        else if (status != ERROR_SUCCESS) {
            PQUORUM_RESOURCE_LOST   func;

            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Reserve thread failed status %1!u!, resource '%2'.\n",
                status, ResourceEntry->ResourceName);
#if 0
            EnterCriticalSection(&ResourceEntry->Lock);
            func = ResourceEntry->LostQuorumResource;
            LeaveCriticalSection(&ResourceEntry->Lock);

            if (func) {
                func(ResourceEntry->ResourceHandle);
            }
            break;
#endif            
        }

        // Check every x seconds.
        // todo: need to make this a private property
        Sleep(MNS_RESERVE_PERIOD);
    } while(!ClusWorkerCheckTerminate(&ResourceEntry->ReserveThread));

error_exit:

    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Reserve thread exiting, resource '%1' %2!u!.\n",ResourceEntry->ResourceName,
        status);

    return(status);

} // MajorityNodeSetReserveThread


DWORD WINAPI MajorityNodeSetArbitrate(
    RESID ResourceId,
    PQUORUM_RESOURCE_LOST LostQuorumResource
    )

/*++

Routine Description:

    Perform full arbitration for a disk. Once arbitration has succeeded,
    a thread is started that will keep reservations on the disk, one per second.

Arguments:

    DiskResource - the disk info structure for the disk.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code on failure.

--*/

{
    DWORD           status=ERROR_SUCCESS;
    PMNS_RESOURCE   ResourceEntry;
    PVOID           arb;
    HANDLE          Cleanup;


    ResourceEntry = (PMNS_RESOURCE)ResourceId;

    if ( ResourceEntry == NULL ) {
        return(FALSE);
    }

    if ( ResourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }


    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Arbitrate request.\n"
        );

    // If an arbitration is in progress wait for it to complete and directly return
    // it's result. No need to rearbitrate.
    //
    if ((status = FsIsOnlineReadWrite(ResourceEntry->VolHdl)) == ERROR_SUCCESS) {
        goto Finally;
    }
    else if (IsArbInProgress(ResourceEntry->VolHdl)) {
        PVOID vol=ResourceEntry->VolHdl;

        WaitForArbCompletion(vol);
        status = FsIsOnlineReadWrite(vol);
        if (status == ERROR_SUCCESS) {
            goto Finally;
        }
    }

    // Get lock
    EnterCriticalSection(&ResourceEntry->Lock);

    status = MajorityNodeSetDoRegister(ResourceEntry);

    // If an arbitrate thread is active we need to wait for it to complete.
    while (ResourceEntry->ArbThread != NULL) {
        HANDLE th = ResourceEntry->ArbThread;
        LeaveCriticalSection(&ResourceEntry->Lock);
        WaitForSingleObject(th, INFINITE);
        EnterCriticalSection(&ResourceEntry->Lock);
        if (th == ResourceEntry->ArbThread) {
            CloseHandle(ResourceEntry->ArbThread);
            ResourceEntry->ArbThread = NULL;
        }
    }

    if (status == ERROR_SUCCESS) {
        // we wait for arbitration timeout in worse case
        DWORD delta = ResourceEntry->Setup.ArbTime;

        // NOTE: There might be another srbitrate thread active, but we cannot wait for that.
        // FsArbitrate() routine is reentrant (hopefully).
        ASSERT(ResourceEntry->VolHdl);
        if((arb = FsArbitrate(ResourceEntry->VolHdl, &Cleanup, &ResourceEntry->ArbThread)) == NULL) {
            status = GetLastError();
        }
        else {
            status = FsCompleteArbitration(arb, delta);
        }
    }

    if (status == ERROR_SUCCESS) {

        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_INFORMATION,
            L"Arb: status %1!u!.\n",
            status
            );

        // we remember the callback and create a thread to monitor the quorum if we
        // don't have one already
        if (ResourceEntry->LostQuorumResource == NULL) {
            status = ClusWorkerCreate( &ResourceEntry->ReserveThread,
                                       (PWORKER_START_ROUTINE)MajorityNodeSetReserveThread,
                                       ResourceEntry );
        }
        ResourceEntry->LostQuorumResource = LostQuorumResource;

        if ( status != ERROR_SUCCESS ) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"Arb: Unable to start thread, status %1!u!.\n",
                status
                );
        }

    }

    // Drop lock
    LeaveCriticalSection(&ResourceEntry->Lock);

Finally:
    
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Arbitrate request status %1!u!.\n",status);

    return status;
}


DWORD
WINAPI
MajorityNodeSetRelease(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Release arbitration for a device by stopping the reservation thread.

Arguments:

    Resource - supplies resource id to be brought online

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_HOST_NODE_NOT_OWNER if the resource is not owned.
    A Win32 error code if other failure.

--*/

{
    DWORD status = ERROR_SUCCESS ;
    PMNS_RESOURCE resourceEntry;

    resourceEntry = (PMNS_RESOURCE)ResourceId;

 again:

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Release request resource %1.\n",resourceEntry->ResourceName);

    // Get lock
    EnterCriticalSection(&resourceEntry->Lock);
    // clear callback and stop thread
    resourceEntry->LostQuorumResource = NULL;
    // Drop lock
    LeaveCriticalSection(&resourceEntry->Lock);
    
    // kill reserve thread
    ClusWorkerTerminate( &resourceEntry->ReserveThread );

    // Get lock
    EnterCriticalSection(&resourceEntry->Lock);

    // clear callback and stop thread
    if (resourceEntry->LostQuorumResource != NULL) {
        // dam arb got called again
        goto again;
    }

    // issue FsRelease
    if (resourceEntry->VolHdl) {
        status = FsRelease(resourceEntry->VolHdl);
        if (status == ERROR_SUCCESS)
            resourceEntry->VolHdl = NULL;
    }

    // Drop lock
    LeaveCriticalSection(&resourceEntry->Lock);

    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Release request status %1!u!.\n",status);

    return status ;
}

DWORD
MajorityNodeSetGetDiskInfo(
    IN LPWSTR   lpszPath,
    OUT PVOID * OutBuffer,
    IN DWORD  OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    Gets all of the disk information for a given signature.

Arguments:

    Signature - the signature of the disk to return info.

    OutBuffer - pointer to the output buffer to return the data.

    OutBufferSize - size of the output buffer.

    BytesReturned - the actual number of bytes that were returned (or
                the number of bytes that should have been returned if
                OutBufferSize is too small).

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error on failure.

--*/

{
    DWORD   status;
    DWORD   bytesReturned = *BytesReturned;
    PVOID   ptrBuffer = *OutBuffer;
    PCLUSPROP_DWORD ptrDword;
    PCLUSPROP_PARTITION_INFO ptrPartitionInfo;

    // Return the signature - a DWORD
    bytesReturned += sizeof(CLUSPROP_DWORD);
    if ( bytesReturned <= OutBufferSize ) {
        ptrDword = (PCLUSPROP_DWORD)ptrBuffer;
        ptrDword->Syntax.dw = CLUSPROP_SYNTAX_DISK_SIGNATURE;
        ptrDword->cbLength = sizeof(DWORD);
        ptrDword->dw = 777;//return a bogus signature for now
        ptrDword++;
        ptrBuffer = ptrDword;
    }

    status = ERROR_SUCCESS;

    if (g_resHdl)
    (g_LogEvent)(
        g_resHdl,
        LOG_INFORMATION,
        L"Expanded path '%1'\n",lpszPath);


    bytesReturned += sizeof(CLUSPROP_PARTITION_INFO);
    if ( bytesReturned <= OutBufferSize ) {
    ptrPartitionInfo = (PCLUSPROP_PARTITION_INFO) ptrBuffer;
    ZeroMemory( ptrPartitionInfo, sizeof(CLUSPROP_PARTITION_INFO) );
    ptrPartitionInfo->Syntax.dw = CLUSPROP_SYNTAX_PARTITION_INFO;
    ptrPartitionInfo->cbLength = sizeof(CLUSPROP_PARTITION_INFO) - sizeof(CLUSPROP_VALUE);

    // set flags
//  ptrPartitionInfo->dwFlags = CLUSPROP_PIFLAG_STICKY;
    ptrPartitionInfo->dwFlags |= CLUSPROP_PIFLAG_USABLE;

    // copy device name
    if (lpszPath[0] == L'\\') {
        wcscpy(ptrPartitionInfo->szDeviceName, lpszPath);
        wcscat(ptrPartitionInfo->szDeviceName, L"\\");
    } else {
        ptrPartitionInfo->szDeviceName[0] = lpszPath[0];
        ptrPartitionInfo->szDeviceName[1] = L':';
        ptrPartitionInfo->szDeviceName[2] = L'\\';
        ptrPartitionInfo->szDeviceName[3] = L'\0';
    }
#ifdef ENABLE_SMB
    if ( !GetVolumeInformationW( ptrPartitionInfo->szDeviceName,
                     ptrPartitionInfo->szVolumeLabel,
                     sizeof(ptrPartitionInfo->szVolumeLabel)/sizeof(WCHAR),
                     &ptrPartitionInfo->dwSerialNumber,
                     &ptrPartitionInfo->rgdwMaximumComponentLength,
                     &ptrPartitionInfo->dwFileSystemFlags,
                     ptrPartitionInfo->szFileSystem,
                     sizeof(ptrPartitionInfo->szFileSystem)/sizeof(WCHAR) ) ) 
#endif
    {
        ptrPartitionInfo->szVolumeLabel[0] = L'\0';
    }
    //set the partition name to the path, nothing to do
    if (ptrPartitionInfo->szDeviceName[0] == L'\\')
        wcscpy(ptrPartitionInfo->szDeviceName, lpszPath);
    else
        ptrPartitionInfo->szDeviceName[2] = L'\0';

    ptrPartitionInfo++;
    ptrBuffer = ptrPartitionInfo;
    }

    //
    // Check if we got what we were looking for.
    //
    *OutBuffer = ptrBuffer;
    *BytesReturned = bytesReturned;

    return(status);

} // MajorityNodeSetGetDiskInfo

VOID
MajorityNodeSetCallLostquorumCallback(PVOID arg)
{
    PMNS_RESOURCE ResourceEntry=(PMNS_RESOURCE)arg;
    PQUORUM_RESOURCE_LOST   func;

    if (!ResourceEntry) {
        return;
    }
    (g_LogEvent)(
        ResourceEntry->ResourceHandle,
        LOG_ERROR,
        L"Lost quorum resource '%1'.\n",
        ResourceEntry->ResourceName);

    EnterCriticalSection(&ResourceEntry->Lock);
    func = ResourceEntry->LostQuorumResource;
    LeaveCriticalSection(&ResourceEntry->Lock);

    if (func) {
        FsSignalShutdown(ResourceEntry->VolHdl);
        func(ResourceEntry->ResourceHandle);
    }
}

//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( MajorityNodeSetFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         MajorityNodeSet,                    // Prefix
                         MajorityNodeSetArbitrate,           // Arbitrate
                         MajorityNodeSetRelease,             // Release
                         MajorityNodeSetResourceControl,     // ResControl
                         MajorityNodeSetResourceTypeControl); // ResTypeControl


void
msg_log(int level, char *buf, int cnt)
{
    WCHAR   wbuf[1024];

    cnt = mbstowcs(wbuf, buf, cnt-1);
    wbuf[cnt] = L'\0';
    if (g_resHdl)
        g_LogEvent(g_resHdl, level, L"%1\n", wbuf);
}

void
WINAPI
debug_log(char *format, ...)
{
    va_list marker;
    char buf[1024];
    int cnt;

    va_start(marker, format);
    cnt = vsprintf(buf, format, marker);
    msg_log(LOG_INFORMATION, buf, cnt);
    va_end(marker);
}

void
WINAPI
error_log(char *format, ...)
{
    va_list marker;
    char buf[1024];
    int cnt;

    va_start(marker, format);
    cnt = vsprintf(buf, format, marker);
    msg_log(LOG_ERROR, buf, cnt);
    va_end(marker);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\resdll\ndquorum\setup.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    setup.c

Abstract:

    Implements "Majority Node Set" setup and configuration in cluster

Author:

    Ahmed Mohamed (ahmedm) 1-Feb-2000

Revision History:

--*/
#define UNICODE 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>

#include <string.h>
#include <ctype.h>
#include <stdlib.h>

#include <tchar.h>
#include <clusapi.h>
#include <resapi.h>

#include <aclapi.h>
#include <accctrl.h>
#include <lm.h>
#include <lmshare.h>
#include <sddl.h>

// These may be included in any order:


#include <ntddnfs.h>            // DD_NFS_DEVICE_NAME, EA_NAME_ equates, etc.
#include <ntioapi.h>            // NtFsControlFile().
#include <ntrtl.h>              // Rtl APIs.
//#include <prefix.h>     // PREFIX_ equates.
#include <tstr.h>               // STRCAT(), STRCPY(), STRLEN().
#include <lmuse.h>              // USE_IPC...
#include <align.h>              // ALIGN_xxx

#include "fsutil.h"

#include <Iphlpapi.h>
#include <clusudef.h>
#include <clusrtl.h>

#define MAX_NAME_SIZE 256
#define PROTECTED_DACL_SECURITY_INFORMATION     (0x80000000L)

#define SETUP_DIRECTORY_PREFIX  L"\\cluster\\" MAJORITY_NODE_SET_DIRECTORY_PREFIX

extern void WINAPI debug_log(char *, ...);

#define SetupLog(x) debug_log x
#define SetupLogError(x) debug_log x

DWORD
GetLocalNodeId(HKEY hClusKey);

    
DWORD
FindTransport(LPWSTR TransportId, LPWSTR *Transport);

// node section

#define MAX_CLUSTER_SIZE    16
#define MAX_NAME_SIZE       256

typedef struct _VCD_NODE_ {
    struct _VCD_NODE_   *next;
    DWORD   id;
    LPWSTR  name;
}VCD_NODE;

typedef struct {
    ULONG   lid;
    DWORD   ArbTime;
#ifdef ENABLE_SMB    
    DWORD   Nic;
    LPWSTR  Transport;
#endif    
    DWORD   ClusterSize;
    VCD_NODE    *ClusterList;
}VCD_INFO, *PVCD_INFO;

#ifdef ENABLE_SMB

DWORD LinkageGuidToIndex(
    IN LPWSTR Guid, 
    OUT LPDWORD pNdx)
/*
Returns zero based index of the binding.
If not found, returns ERROR_FILE_NOT_FOUND

Sample Usage:

    DWORD ndx, status;
    status = LinkageGuidToIndex(L"\\Device\\NetBT_Tcpip_{59309371-A3AB-4305-BB25-FAE11E8D4606}", &Ndx);
    printf("ndx %d status %d\n", ndx, status);

 */
{
    DWORD size = 0;
    DWORD type;
    LONG status;
    DWORD index;

    WCHAR* Buf = NULL, *p;
    HKEY LinkageKey = 0;    

    status = RegOpenKeyEx( 
        HKEY_LOCAL_MACHINE,        // handle to key to query
        L"SYSTEM\\CurrentControlSet\\Services\\NetBIOS\\Linkage",
        0, // DWORD ulOptions (Reserved, must be zero)
        KEY_QUERY_VALUE, 
        &LinkageKey );

    if (status != ERROR_SUCCESS) {
        goto exit_gracefully;
    }

    status = RegQueryValueEx( 
        LinkageKey, 
        L"Bind", 
        0, 
        NULL, // TypeCode is not required
        NULL, // just query the length, no data needed
        &size ); 

    if (status != ERROR_SUCCESS) {
        goto exit_gracefully;
    }

    Buf = (WCHAR*)HeapAlloc(GetProcessHeap(), 0, size);    
    if (Buf == NULL) {
        status = GetLastError();
        goto exit_gracefully;
    }

    status = RegQueryValueEx( 
        LinkageKey, 
        L"Bind", 
        0, 
        &type, 
        (LPBYTE)Buf, 
        &size ); 

    if (status != ERROR_SUCCESS) {
        goto exit_gracefully;
    }

    if (type != REG_MULTI_SZ) {
        status = ERROR_INVALID_DATA;
        goto exit_gracefully;
    }

    index = 0;
    for(p = Buf; *p; p += wcslen(p)+1) {
        if (ClRtlStrICmp(p, Guid) == 0) {
            status = ERROR_SUCCESS;
            *pNdx = index;
            goto exit_gracefully;
        }
        index += 1;
    }
    status = ERROR_FILE_NOT_FOUND;

exit_gracefully:

    if (LinkageKey) {
        RegCloseKey(LinkageKey);
    }
    
    if (Buf) {
        HeapFree(GetProcessHeap(), 0, Buf);
    }
      
    return status;    
}

void
GetAdapterMask(DWORD *nic, LPWSTR id)
{
    DWORD sz, err;
    PIP_INTERFACE_INFO ilist;
    LONG num;

    sz = 0;
    GetInterfaceInfo(NULL, &sz);
    ilist = (PIP_INTERFACE_INFO) malloc(sz);
    if (ilist != NULL) {
        err = GetInterfaceInfo(ilist, &sz);
        if (err == NO_ERROR) {
            for (num = 0; num < ilist->NumAdapters; num++) {
                if (wcsstr(ilist->Adapter[num].Name, id)) {
                    *nic = (DWORD) (ilist->Adapter[num].Index % ilist->NumAdapters);
                    SetupLog(("Adapter 0x%x '%S'\n", *nic, id));
                    break;
                }
            }
        } else {
            SetupLog(("GetInterfaceInfo failed %d\n", err));
        }
        free(ilist);
    }
}

DWORD
FindTransport(LPWSTR TransportId, LPWSTR *Transport)
{
   LPSERVER_TRANSPORT_INFO_0 pBuf = NULL;
   LPSERVER_TRANSPORT_INFO_0 pTmpBuf;
   DWORD dwLevel = 0;
   DWORD dwPrefMaxLen = 256;//-1
   DWORD dwEntriesRead = 0;
   DWORD dwTotalEntries = 0;
   DWORD dwResumeHandle = 0;
   NET_API_STATUS nStatus;
   DWORD i;

   *Transport = NULL;
   //
   // Call the NetServerTransportEnum function; specify level 0.
   //
   do // begin do
   {
       nStatus = NetServerTransportEnum(NULL,
                                        dwLevel,
                                        (LPBYTE *) &pBuf,
                                        dwPrefMaxLen,
                                        &dwEntriesRead,
                                        &dwTotalEntries,
                                        &dwResumeHandle);
       //
       // If the call succeeds,
       //
       if ((nStatus != NERR_Success) && (nStatus != ERROR_MORE_DATA)) {
           break;
       }

       if ((pTmpBuf = pBuf) == NULL)  {
           nStatus = ERROR_NOT_FOUND;
           break;
       }

       //
       // Loop through the entries;
       //
       for (i = 0; i < dwEntriesRead; i++) {

           SetupLog(("\tTransport: %S address %S\n",
                     pTmpBuf->svti0_transportname,
                     pTmpBuf->svti0_networkaddress));

           if (wcsstr(pTmpBuf->svti0_transportname, TransportId)) {
               // found it, we are done
               LPWSTR p;
               DWORD sz;

               sz = wcslen(pTmpBuf->svti0_transportname) + 1;
               p = (LPWSTR) LocalAlloc(LMEM_FIXED, sz * sizeof(WCHAR));
               if (p != NULL) {
                   wcscpy(p, pTmpBuf->svti0_transportname);
                   *Transport = p;
                   nStatus = ERROR_SUCCESS;
                   break;
               }
           }
           pTmpBuf++;
       }
       //
       // Free the allocated buffer.
       //
       if (pBuf != NULL) {
           NetApiBufferFree(pBuf);
           pBuf = NULL;
       }
   } while (nStatus == ERROR_MORE_DATA);

   // Check again for an allocated buffer.
   //
   if (pBuf != NULL)
       NetApiBufferFree(pBuf);

   return nStatus;
}


DWORD 
NetInterfaceProp( IN  HNETINTERFACE hNet,IN  LPCWSTR name, WCHAR *buf)
{
    DWORD dwError     = ERROR_SUCCESS; // for return values
    DWORD cbAllocated = 1024;          // allocated size of output buffer
    DWORD cbReturned  = 0;             // adjusted size of output buffer
    WCHAR *value;

    //
    // Allocate output buffer
    //
    PVOID pPropList = LocalAlloc( LPTR, cbAllocated );
    if ( pPropList == NULL )
    {
        dwError = GetLastError();
        goto EndFunction;
    }

    //
    // Verify valid handle
    //
    if ( hNet == NULL )
    {
        dwError = ERROR_BAD_ARGUMENTS;
        goto EndFunction;
    }

    //
    // Retrieve common group properties.
    // cbReturned will be set to the size of the property list.
    //
    dwError = ClusterNetInterfaceControl(hNet, 
                     NULL,
                     CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES,
                     NULL, 
                     0, 
                     pPropList, 
                     cbAllocated, 
                     &cbReturned );

    //
    // If the output buffer was not big enough, reallocate it
    // according to cbReturned.
    //

    if ( dwError == ERROR_MORE_DATA )
    {
        cbAllocated = cbReturned;
        LocalFree( pPropList );
        pPropList = LocalAlloc( LPTR, cbAllocated );
        if ( pPropList == NULL )
        {
            dwError = GetLastError();
            goto EndFunction;
        }
        dwError = ClusterNetInterfaceControl(hNet, 
                         NULL,
                         CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES, 
                         NULL, 
                         0, 
                         pPropList, 
                         cbAllocated, 
                         &cbReturned );
    }

    if ( dwError != ERROR_SUCCESS ) goto EndFunction;

    dwError = ResUtilFindSzProperty( pPropList, 
                     cbReturned,
                     name,
                     &value);
    if (dwError == ERROR_SUCCESS) {
    wcscpy(buf, value);
    }
     
EndFunction:

    if (pPropList)
    LocalFree( pPropList );

    return dwError;

} //

#endif // ENABLE_SMB
int
strcmpwcs(char *s, WCHAR *p)
{
    char c;

    for (wctomb(&c,*p); (c == *s) && *s != '\0'; s++) {
    p++;
    wctomb(&c,*p);
    }
    if (*s == '\0' && c == *s)
    return 0;

    return 1;
}

#ifdef ENABLE_SMB

DWORD
NetworkIsPrivate(HCLUSTER chdl, LPWSTR netname)
{
    HCLUSENUM ehdl;
    DWORD err, index;

    // Open enum handle
    ehdl = ClusterOpenEnum(chdl, CLUSTER_ENUM_INTERNAL_NETWORK);
    if (!ehdl) {
    err = GetLastError();
    return err;
    }


    for (index = 0; TRUE; index++) {
    DWORD type;
    DWORD sz;
    WCHAR name[MAX_NAME_SIZE];

    sz = sizeof(name) / sizeof(WCHAR);
    err = ClusterEnum(ehdl, index, &type, name, &sz);
    if (err == ERROR_NO_MORE_ITEMS)
        break;
    if (err != ERROR_SUCCESS) {
        break;
    }
    ASSERT(type == CLUSTER_ENUM_INTERNAL_NETWORK);


    if (wcscmp(name, netname) == 0) {
        break;
    }

    err = ERROR_NOT_FOUND;
    // always return first one only, since I changed from a mask to a single number
    break;
    }

    ClusterCloseEnum(ehdl);

    return err;
}

DWORD
NodeNetworkAdapterMask(HCLUSTER chdl, HNODE nhdl, DWORD *nic, LPWSTR *transport)
{
    HNODEENUM nehdl = NULL;
    int index, done;
    DWORD err, type;
    DWORD sz = MAX_NAME_SIZE;
    WCHAR  buf[MAX_NAME_SIZE];
    LPWSTR id = (LPWSTR) buf;

    *nic = 0;
    *transport = NULL;

    // Open node enum handle
    nehdl = ClusterNodeOpenEnum(nhdl, CLUSTER_NODE_ENUM_NETINTERFACES);
    if (!nehdl) {
        err = GetLastError();
        return err;
    }

    // Get node properties
    done = 0;
    for (index = 0; !done; index++) {
        HNETINTERFACE nethdl;

        sz = MAX_NAME_SIZE;
        err = ClusterNodeEnum(nehdl, index, &type, id, &sz);
        if (err == ERROR_NO_MORE_ITEMS)
            break;
        if (err != ERROR_SUCCESS) {
            break;
        }

        nethdl = OpenClusterNetInterface(chdl, id);
        if (!nethdl) {
            continue;
        }
          
        err = NetInterfaceProp(nethdl, L"Network", id);
        if (err != ERROR_SUCCESS) {
            continue;
        }
        // check if this network can be used by cluster service
        err = NetworkIsPrivate(chdl, id);
        if (err != ERROR_SUCCESS) {
            continue;
        }

        err = NetInterfaceProp(nethdl, L"AdapterId", id);
        if (err == ERROR_SUCCESS) {
            // find transport name
            err = FindTransport(id, transport);
            if (err == ERROR_SUCCESS) {
                SetupLog(("NetBT: %S\n", *transport));
            }
            // find nic
            LinkageGuidToIndex(*transport, nic);
//          GetAdapterMask(nic, id);

        }

        CloseClusterNetInterface(nethdl);
    }

    if (*transport == NULL) {
        SetupLog(("No transport is found\n"));
    }

    if (nehdl)
    ClusterNodeCloseEnum(nehdl);

    return err;
  
}

#endif

DWORD
NodeGetId(HNODE nhdl, ULONG *nid)
{
    DWORD sz = MAX_NAME_SIZE;
    WCHAR  buf[MAX_NAME_SIZE], *stopstring;
    LPWSTR id = (LPWSTR) buf;
    DWORD err;

    err = GetClusterNodeId(nhdl, id, &sz);
    if (err == ERROR_SUCCESS) {
    *nid = wcstol(id, &stopstring,10);
    }

    return err;
}

void
NodeAddNode(PVCD_INFO info, WCHAR *name, DWORD id)
{
    WCHAR   *p;
    VCD_NODE    *n, **last;

    n = (VCD_NODE *) LocalAlloc(LMEM_FIXED, ((wcslen(name)+1) * sizeof(WCHAR)) + sizeof(*n));
    if (n == NULL) {
    return;
    }
    p = (WCHAR *) (n+1);
    wcscpy(p, name);
    n->name = p;
    n->id = id;
    // insert into list in proper order, ascending
    last = &info->ClusterList;
    while (*last && (*last)->id < id) {
    last = &(*last)->next;
    }
    n->next = *last;
    *last = n;
    info->ClusterSize++;
}

NodeInit(PVCD_INFO info, HKEY hClusKey)
{
    HKEY        hNodesKey=NULL, hNodeKey=NULL;
    WCHAR       nName[MAX_PATH], nId[20];
    DWORD       status=ERROR_SUCCESS;
    DWORD       ndx, id, type, size;
    FILETIME    fileTime;

    status = RegOpenKeyExW(hClusKey, CLUSREG_KEYNAME_NODES, 0, KEY_READ, &hNodesKey);
    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    for(ndx=0;TRUE;ndx++) {
        size = 20;
        status = RegEnumKeyExW(hNodesKey, ndx, nId, &size, NULL, NULL, 0, &fileTime);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        status = RegOpenKeyExW(hNodesKey, nId, 0, KEY_READ, &hNodeKey);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        size = MAX_PATH;
        status = RegQueryValueExW(hNodeKey, CLUSREG_NAME_NODE_NAME, NULL, &type, (LPBYTE)nName, &size);
        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }
        NodeAddNode(info, nName, wcstol(nId, NULL, 10));
        RegCloseKey(hNodeKey);
        hNodeKey = NULL;
    }
    
error_exit:

    if (status == ERROR_NO_MORE_ITEMS) {
        status = ERROR_SUCCESS;
    }

    if (hNodeKey) {
        RegCloseKey(hNodeKey);
    }

    if (hNodesKey) {
        RegCloseKey(hNodesKey);
    }

    return status;
}

// In order to deal with auto-setup:
// we need to create a directory mscs.<resource name>.
// we then create a share with guid:.....\mscs.<resource name>.
// set security on both directory and share for cluster service account only
DWORD
SetupShare(LPWSTR name, LPWSTR *lpath)
{
    
    DWORD err, len=0;
    WCHAR *path=NULL;

    if (name == NULL || wcslen(name) > MAX_PATH)
    return ERROR_INVALID_PARAMETER;

    *lpath = NULL;
    if (!( len = GetWindowsDirectoryW(path, 0))) {
        return GetLastError();
    }
    len += wcslen(name) + wcslen(SETUP_DIRECTORY_PREFIX) + 4;
    path = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len * sizeof(WCHAR));
    if (path) {
        SECURITY_ATTRIBUTES sec;
        HANDLE hDir;

        // Assuming this will suceed since the last call did.
        len = GetWindowsDirectoryW(path, len);
        path[len] = L'\0';
        lstrcatW(path, SETUP_DIRECTORY_PREFIX);
        lstrcatW(path, name);

        memset((PVOID) &sec, 0, sizeof(sec));

        if (!CreateDirectoryW(path, NULL)) {
            err = GetLastError();
            if (err != ERROR_ALREADY_EXISTS) {
                SetupLogError(("Failed to create \"%s\" %d\n", path, err));
                goto exit_gracefully;
            }
        }
        hDir =  CreateFileW(path,
                            GENERIC_READ|WRITE_DAC|READ_CONTROL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL);

        if (hDir != INVALID_HANDLE_VALUE) {
            // set the security attributes for the file.
            err = ClRtlSetObjSecurityInfo(hDir, SE_FILE_OBJECT,
                        GENERIC_ALL, GENERIC_ALL, 0);

            // close directory handle
            CloseHandle